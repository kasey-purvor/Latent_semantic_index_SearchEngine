{"doi":"10.1109\/APSEC.2000.896718","coreId":"102426","oai":"oai:epubs.surrey.ac.uk:1885","identifiers":["oai:epubs.surrey.ac.uk:1885","10.1109\/APSEC.2000.896718"],"title":"CIMO - Component Integration MOdel","authors":["Xia, Yan","Ho, Anthony T. S.","Zhang, YuCheng"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2000-12-05","abstract":"<p>The Component Object Model (COM) represents a binary interface standard that allows developers to build specialized software components that interface in a common way with other software components. After being compiled, these components are integrated into an application and can interoperate with each other in a reliable, controlled manner. Can the components be integrated into an application and interoperate without recompiled? This article describes the Component Integration Model (CIMO), a software platform that allows the components written by different software programmers to be integrated into an application and to inter-operate without re-compiling. Firstly, the paper concentrates on a general overview of CIMO and describes the constitution and functions of the CIMO architecture. Secondly, the paper presents the definition of the CIMO component concept and addresses how CIMO facilitates users to establish scalable component-based applications and how CIMO supports the synchronous and asynchronous communication between components. Thirdly, the paper explains how CIMO sets up the deployment of components and processes after users have developed components based on CIMO specifications.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1885<\/identifier><datestamp>\n      2017-10-31T14:03:31Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1885\/<\/dc:relation><dc:title>\n        CIMO - Component Integration MOdel<\/dc:title><dc:creator>\n        Xia, Yan<\/dc:creator><dc:creator>\n        Ho, Anthony T. S.<\/dc:creator><dc:creator>\n        Zhang, YuCheng<\/dc:creator><dc:description>\n        <p>The Component Object Model (COM) represents a binary interface standard that allows developers to build specialized software components that interface in a common way with other software components. After being compiled, these components are integrated into an application and can interoperate with each other in a reliable, controlled manner. Can the components be integrated into an application and interoperate without recompiled? This article describes the Component Integration Model (CIMO), a software platform that allows the components written by different software programmers to be integrated into an application and to inter-operate without re-compiling. Firstly, the paper concentrates on a general overview of CIMO and describes the constitution and functions of the CIMO architecture. Secondly, the paper presents the definition of the CIMO component concept and addresses how CIMO facilitates users to establish scalable component-based applications and how CIMO supports the synchronous and asynchronous communication between components. Thirdly, the paper explains how CIMO sets up the deployment of components and processes after users have developed components based on CIMO specifications.<\/p><\/dc:description><dc:date>\n        2000-12-05<\/dc:date><dc:type>\n        Conference or Workshop Item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1885\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Xia, Yan, Ho, Anthony T. S. and Zhang, YuCheng  (2000) CIMO - Component Integration MOdel  In: Proceedings Seventh Asia-Pacific Software Engeering Conference. APSEC 2000.     <\/dc:identifier><dc:relation>\n        10.1109\/APSEC.2000.896718<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1885\/","10.1109\/APSEC.2000.896718"],"year":2000,"topics":[],"subject":["Conference or Workshop Item","PeerReviewed"],"fullText":"CIMO - Component Integration Model \nYan Xia, Anthony Tung Shuen Ho \nSchool of Electrical and Electronic Engineering \nNanyang Technological University, Singapore 639798 \nTel. (65)7905465, Fax: (65)7904161, E-mail address: evxia@,ntu.edu.sq \nYuCheng Zhang \nBeijing Conuco Electronics Co. Ltd \nAbstract \nComponent Object Model (COM) represents a binary \ninterface standard that allows developers to build \nspecialized software component that interface in a \ncommon way with other software components. After \ncompiled, these components are integrated into an \napplication and can interoperate with each other in a \nreliable, controlled manner. Can the components be \nintegrated and operated into an application without re- \ncompiled? This article describes the Component \nIntegration Model (CIMO), a software platform that \nallows the components written by different software \nprogrammer to be integrated and operated into an \napplication without re-compiling. Firstly, the paper \nconcentrates on a general overview o f the  CIMO and \ndescribes the constitutions and functions of the CIMO \narchitecture. Secondly, the paper presents the definition \nof CIMO component concept und addresses how CIMO \nfacilitates users to establish scalable component-based \napplications, and how CIMO supports the synchronous \nand asynchronous communication between components. \nThirdly, the paper explains how CIMO sets up the \ndeployment of components and processes after Users \ndevelop components based on CIMO specification. \nKeywords: CIMO, Component Technology, \nConfiguration, Integration \n1. Introduction \nComponent technology is very popular in the \nsoftware world because COM represents a binary \ninterface standard that allows developers to build \nspecialized software component that interface in a \ncommon way with other software components. The \ncomponents can be developed by separate project team \nmembers using a wide variety of language - independent \ntools, and can be used and reused in many applications if \nthese components have the COM interface [l]. This \ntechnology provides tremendous design flexibility and \nopens a new worlc&and challenge-to software \nprogrammers, and demands new ways of thinking and \nworking. However, the component technology does not \npay more attention to the component integration problem. \nThese components are not late-bound freely; they cannot \nbe integrated or combined into a variety of applications \nwithout re-compiling. OLE-related technologies can \nintegrate between functional components of all sorts, \nallowing the features of those components to evolve over \ntime, wherever they may be - in the system or inside \napplications, inside in-process DLLs or out -of-process \n.EXE files [2]. But re-compiling for components is \nneeded at most situations in OLE. \nTo meet the customer\u2019s requirements of adding or \nmodifying functionality, or inserting new components to \nthe existed application, we researched and developed the \nComponent Integration Model. CIMO is a software \nplatform that allows the components written by different \nsoftware programmer to be integrated and operated into \nan application without re-compiling. Also, the CIMO can \nsupport to extend the functionality to component and to \ninsert new components to the application. In this article, \nthe CIMO technique and framework will be presented. \nFirstly, the paper gives a general overview of the CIMO \nand describes the constitutions and functions of the CIMO \narchitecture. Secondly, the paper focuses on the definition \nof CIMO component concept and addresses how CIMO \nfacilitates users to establish scalable component-based \napplications, and how CIMO supports the synchronous \nand asynchronous communication between components. \nThirdly, the paper explains how CIMO sets up the \ndeployment of components and processes, and how \nClMO manages the components running in the \napplication after Users develop components based on \nCIMO specification. \n1530-1362\/00 $10.00 0 2000 EEE \n344 \nI I \nFigure 1 CIMO Architecture \n2. Architecture of CIMO \nHow does CIMO facilitate customers to establish \nscalable component -based on application without re- \ncompiling? What makes it such a useful and unifying \nmodel? To examine these problems that CIMO is meant \nto solve and how CIMO provides solutions for these \nproblems, it will be helpful to first see the architecture of \nCIMO. CIMO has a layered structure: CIMO \nComponent Layer and CIMO Service Layer. Figure 1 \nshows the static structure and feature of CIMO having \nobjects at different levels and relationship between the \nvarious objects. \nCIMO Component Layer contains CIMO \ncomponents, which work together and make up a \nCIMO application. \nClMO Service Layer consists of CIMO service \ncomponents -- CIMO Configurator, CIMO \nManager, CIMO Container, and CIMO System. \nCIMO Service Layer is mainly intended for \nsupporting the management, communication and \nconfiguration of CIMO components. A CIMO \nSystem and a group of CIMO Containers make up a \nplatform for CIMO components - CIMO Platform. \nCIMO will provide all the classes in CIMO Service \nLayer and instructions for application composers to \nestablish the application components. Application \ncomposers will write application components and scripts \nfor configuring the application system. Application users \nwill use the final application. \n3. CIMO Component Layer \nCIMO components are located in the CIMO \nComponent Layer. These components will be developed \nCIMO \nComponent \nLaver \nCIMO \nService \nLayer \nI I \nby application composers based on the component \nspecification, and be integrated, managed and supported \nby CIMO Service Layer Components. CIMO components \nmay be distributed on network and assigned to different \nprocesses. \n3.1. CTMO Component Definition \nGenerally, a CIMO component is a Microsoft COM \nobject. Each CIMO component is a discrete unit of code \nbuilt on Component technologies that delivers a well- \nspecified set ofservices through well-specified interfaces \n[2][3]. Compared with other component (standard \nMicrosoft COM component), CIMO component has not \nonly common COM interface, but also special CIMO \nComponent Interface, as shown in figure 2 .  \nEach CIMO component may have a set of Source \nInterfaces that implemented by the component and \nhave a set of Sink Interfaces that used by the \ncomponent. It consumes messages incoming \nthrough its Source Interfaces and sends out \nmessages through its Sink Interfaces. \nEach component has a group of services. These \nservices handle the incoming messages through \nSource Interfaces, and the services may produce \nmessages and send out through its Sink Interface. \nk s u r c e  Interface \n' \/ I  T\" I ... ... \n4 Messazeflow \nSink Interface I\nFigure 2 Structure of CIMO Component \n345 \nA component is not a process. It may be a thread or \nan object staying in the process of a container. It can send \nand receive messages to other components via the CIMO \nContainer or even via the CIMO System. It knows \nnothing about other components even if they are in the \nsame CIMO Container. Component creator can extend \nfunctionality to components by adding more services in \naddition to the basic ones. Only in this way, concrete \napplication can be realized. \n3.2. CIMO Interface \nThe CIMO Interface is a group of semantically \nrelated functions, or \"methods\". Taken together, the \nmethods in an interface define a logical group of services \nthat a ClMO component object can provide the expected \nbehavior and responsibilities. CIMO Source Interface: \nthe CIMO Interface implemented by a CIMO component \nis a CIMO Source Interface, through which the \ncomponent receives incoming messages. CIMO Sink \nInterface: the CIMO Interface used by a CIMO \ncomponent is a CIMO Sink Interface, through which the \ncomponent sends out-coming messages. \nWhen a Sink Interface is coupled with a Source \nInterface, which type is the same as the Sink Interface, a \nclient-server communication connection of two \ncomponents is established. Figure 3 depicts how the three \ncomponents are coupled together. Services existing in the \nCIMO Platform support the communication between \ncomponents. \n4. CIMO Service Layer \nThe CIMO software platform includes a CIMO \nSystem and a number of CIMO Containers, a CIMO \nConfigurator, and a CIMO Manager. These \ncomponents are located in the CIMO Service layer, and \nwould guarantee safe operation in terms of process \nmanagement, component management, memory \nmanagement, and component communication. \nA I M 0  Components \nI ''1 CIMO \nb CIMO sink ~nterface \nh CIMO Source \n+ A client-server connection \nbetween two components \nFigure 3 CIMO Component Integration \n4.1. CIMO Platform \nThe CIMO platform provides a platform for CIMO \ncomponents running on it. It supports the setup, \nintegration, communication and management of the \ncomponents in the CIMO application. A CIMO platform \nhas one CIMO system to coordinate the whole system and \nhas a number of CIMO containers, which directly \ncontains CIMO components. \nCIMO System \nThe ClMO system may contain a number of CIMO \ncontainers and coordinate them to provide a system-level \nmanagement for the CIMO application. CIMO System is \na process that is responsible for communication between \nContainers. And it also plays a partial role in \ncommunication between Components in different \nContainers. It is started by the end user; it gets the \napplication topology information from application \nconfiguration and does work accordingly. For example, it \nconstructs and starts all the containers, establishes \ncommunication channel to these containers, and requests \nthem to construct components by sending messages to \nthem according the configuration information. \nAdditionally, the CIMO System knows only its children, \nwhich containers are in it, oblivious of its grand children, \nwhich components it has. The CIMO System talks to \ncontainers but not to components directly. It can send and \nreceive messages, and communicates with Configurator \nand Component Manager directly, as shown in figure 4. \nCIMO Container \nHigh performance is an important requirement for \ncomponent software architecture. While cross -process and \ncross-network transparency is a laudable goal, high \nperformance is critical for software structure. So, a CIMO \nContainer is used to organize the components that will \ninteract within the same address space to utilize each \nother's services without any undue \"system\" overhead. A \nClMO container contains a number of CIMO components \nand has its own process. It can also setup, integrate, \nmanage components and provide communication \nmanagement for these components. The CIMO Container \ncommunicates only with the System directly instead of \nother containers. If it wants to communicate with other \ncontainers, it has to perform via the CIMO System. It can \nsend and receive messages, and play a role in \ncommunication between components in different \ncontainers. \nCIMO Platform's Communication Mechanism \nmessages, know nothing about other components, and \nThe CIMO components can only process and send the \n346 \nI I -.-.-.-.-.-.-.-.-.-._._. : I .-.-.-. -.- \nVirtual Route \n- \nActual Route \nFigure 4 Communication Routes \nadditionally, may be distributed on network and assigned \nto different processes. So, communication plays an very \nimportant role in CIMO. The messages need to be \nexchanged smoothly and accurately between layer and \nlayer, and among layer, and need also to run in one \nprocess, in different processes, and even at different \ncomputers. Fortunately, Microsoft COM technology has \nprovided the communication mechanism for components; \nMS COM object can transfer any messages even over \nLANs. Additionally, in order to realize asynchronous \ntransportation, asynchronous OLE automation and \nmultithread technology are employed. \nIn the CIMO Platform, whenever a node, maybe a \nsystem object, a container object, or a component object, \nreceives a message, i t  puts the message into its messages \nqueue and this message is then waiting for processing. \nThis node will check its message queue regularly and \nprocess the messages in it  according to their priority, as \nshown as figure 5.  When a node processes a message, it \nchecks if the destination is itself. If so, the corresponding \nservice will be invoked. If not, i t  checks whether the \ndestination is one of its children, if so, the messages will \nbe sent out again to this child. Otherwise the messages \nwill be sent to its parent for further dispatching. \nMessage \n+ \nMessage \nFigure 5 Message Processing \n4.2. CIMO Component Manager \nTo guarantee the uniqueness of the components \nwithin the application\u2019s memory, each instantiated \ncomponents must be registered into a centralized r egistry. \nThe CIMO Component Manager is a centralized registry \nand manages the components running in the application. It \nbelongs to the CIMO Service Component, intended for \nthe registry and management of the CIMO Components \nand CIMO Interface, even the CIMO Messages. It records \na reference to the running system. After a system starts \nup, only an object of the CIMO Component Manager can \nbe created and then starts to store the reference of whole \napplication\u2019s system. The CIMO components in the \napplication\u2019s system are usually identified in the CIMO \nComponent Manager using their unique identifiers. The \nClMO Components Manager connects to an existing \napplication system, acts just like a database manager to \nmanipulate components, and exists until the system object \nterminates. \n347 \n4.3. CIMO Configurator \nThe CIMO Configurator is a very important CIMO \nService Component because it implements from basic \nsoftware components to a running application system. It \ncoordinates with the CIMO platform to configure \napplications, that is, reads configuration information to \nconstruct and start the application system, tells the \napplication to create all the nodes (including a CIMO \nSystem, many CIMO Containers and Components) in the \napplication, sets up message-service mapping within one \nnode, and sets up links between components. It controls \nwhich components and services are loaded during the \ninitialization process. After the Configurator has finished \nits task, it can exit without any effect to the platform. The \ntasks are as follow: \nConfigure CIMO applications, such as process \ntopology, component topology, message route within \na component, link between components \n0 Terminate after an application system has been \nestablished. Also it can connect to and delete an \nexisting application system \nSend messages to the application system in the debug \nmode. \nShow the application system structure and detailed \ninformation within each node, such as message route \nwithin a component and links of components. \n0 \nNow, we support scripts as messages to construct the \napplication system. Script file is a plain text file in a \ndatabase. Each line is a message in the file. The \nconfigurator reads and runs the script files in a sequential \norder, and performs tasks taccordingly, either to create a \nsystem or to send messages to this system, Fig.6. \nConfiguration \nFigure 6 Concept of Configuration \n5. Conclusion \nWe have successfully used the CIMO for control \nsoftware for a new generation machine of Multi-Factor \nfor MIKRON AG, a world-leading company of industrial \nautomated machine in Switzerland. Although it is a \nsimple software platform, it integrates and operates the \nCIMO components into an application without re- \ncompiling. \nCIMO has a layered structure. CIMO Component \nLayer contains CIMO components, which work \ntogether and make up a CIMO application. The \nCIMO Service Layer objects intend for supporting \nthe management, communication and configuration \nof CIMO components. Wlsiness logic deployed on \ncentralized services rather than scattered user service \nmakes CIMO to be changed easier so that it \nconsistently gears to the customer\u2019s requirements. \nCIMO supports COM technology. \u2018Ihe CIMO \ncomponent has both COM Interface and CIMO \nInterface. They can be written by different software \nengineers based on the CIMO specification and can \nbe integrated and operated into an application without \nre-compiling. \nCIMO is a hlly configurable application system; the \nCIMO Configurator configures both the application \nand application messages, such as process topology, \ncomponent topology, message route within a \ncomponent, links between components, and so on. \nThe CIMO components only process and send the \nmessages. The CIMO provides the communication \nmechanism for messages exchanged, and supports \nsynchronous and Asynchronous communication \nbetween components, distribution of components. \nManageability. While cross-process and cross- \nnetwork transparency is a goal, CIMO container is \nused to organize group components that will interact \nwithin the same address space, which helps in \naddressing high performance requirements. \nReference \n[l] Sara Willliams and Charlie Kindel, \u201cThe Component Object \nModel: A Technical Overview\u201d, Dr. Dobb\u2019s Joumal, the \nnewsstand special edition, December 1994. \n[2] Kraig Brockschmidt, \u201cOLE Integration Technologies: A \nTechnical Overview\u201d, Dr. Dobb\u2019s Joumal, the newsstand special \nedition, December 1994. \n[3] Paul Stafford and Joel Powell, \u201cCOM: A Model Problem \nSolver\u201d, March IO, 1995 \n348 \n"}