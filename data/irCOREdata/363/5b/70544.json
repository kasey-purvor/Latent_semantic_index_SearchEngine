{"doi":"10.1109\/INM.1999.770731","coreId":"70544","oai":"oai:eprints.lancs.ac.uk:11710","identifiers":["oai:eprints.lancs.ac.uk:11710","10.1109\/INM.1999.770731"],"title":"Management of Proxy Objects Providing Multimedia Applications in the Mobile Environment","authors":["Seitz, Jochen","Cheverst, Keith","Davies, Nigel","Ebner, Michael","Friday, Adrian"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"1999-05-24","abstract":"Due to increasing computational power, long-life batteries and wireless links with improving bandwidth, distributed multimedia applications have become more and more attractive for mobile users. However, the varying quality of service (QoS) on the wireless link is still a major problem. One generally accepted solution to this problem utilises \u201cproxies\u201d which act on behalf of the mobile user and modify the communication data stream in order to match the current QoS conditions. These proxies are generally dependent on protocol layers, applications or application data. Therefore, in order to enable proxy objects to be flexibly inserted for a given multimedia stream, an architecture is required for managing supplied and installed proxy objects","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/70544.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/11710\/1\/IM99.pdf","pdfHashValue":"c2cd51e600c41b651b1707e56bfd69a4a23719cf","publisher":"IEEE Publishing","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:11710<\/identifier><datestamp>\n      2018-01-24T02:18:18Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D6F74686572<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Management of Proxy Objects Providing Multimedia Applications in the Mobile Environment<\/dc:title><dc:creator>\n        Seitz, Jochen<\/dc:creator><dc:creator>\n        Cheverst, Keith<\/dc:creator><dc:creator>\n        Davies, Nigel<\/dc:creator><dc:creator>\n        Ebner, Michael<\/dc:creator><dc:creator>\n        Friday, Adrian<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        Due to increasing computational power, long-life batteries and wireless links with improving bandwidth, distributed multimedia applications have become more and more attractive for mobile users. However, the varying quality of service (QoS) on the wireless link is still a major problem. One generally accepted solution to this problem utilises \u201cproxies\u201d which act on behalf of the mobile user and modify the communication data stream in order to match the current QoS conditions. These proxies are generally dependent on protocol layers, applications or application data. Therefore, in order to enable proxy objects to be flexibly inserted for a given multimedia stream, an architecture is required for managing supplied and installed proxy objects.<\/dc:description><dc:publisher>\n        IEEE Publishing<\/dc:publisher><dc:date>\n        1999-05-24<\/dc:date><dc:type>\n        Other<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/eprints.lancs.ac.uk\/11710\/1\/IM99.pdf<\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1109\/INM.1999.770731<\/dc:relation><dc:identifier>\n        Seitz, Jochen and Cheverst, Keith and Davies, Nigel and Ebner, Michael and Friday, Adrian (1999) Management of Proxy Objects Providing Multimedia Applications in the Mobile Environment. IEEE Publishing, Sixth IFIP\/IEEE International Symposium on Integrated Network Management, Distributed Management for the Networked Millennium.<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/11710\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1109\/INM.1999.770731","http:\/\/eprints.lancs.ac.uk\/11710\/"],"year":1999,"topics":["QA75 Electronic computers. Computer science"],"subject":["Other","NonPeerReviewed"],"fullText":"0DQDJHPHQW\u0003RI\u00033UR[\\\u00032EMHFWV\u00033URYLGLQJ\n0XOWLPHGLD\u0003$SSOLFDWLRQV\u0003LQ\u0003WKH\u00030RELOH\n(QYLURQPHQW\n-\u0011\u00036HLW]\u000f\u0003.\u0011\u0003&KHYHUVW\u000f\u00031\u0011\u0003\u2019DYLHV\u000f\u00030\u0011\u0003(EQHU\u000f\u0003$\u0011\u0003)ULGD\\\n&RPSXWLQJ\u0003\u2019HSDUWPHQW\u000f\u0003\/DQFDVWHU\u00038QLYHUVLW\\\n\/DQFDVWHU\u0003\/$\u0014\u0003\u0017<5\u000f\u00038\u0011\u0003.\u0011\n7HO\u0011\u0003\u000e\u000e\u0017\u0017\u0003\u000b\u0013\f\u0014\u0018\u0015\u0017\u0003\u0019\u0018\u0015\u0013\u0014\u000f\u0003)D[\u0011\u0003\u000e\u000e\u0017\u0017\u0003\u000b\u0013\f\u0014\u0018\u0015\u0017\u0003\u0018\u001c\u0016\u0019\u0013\u001b\n(\u0010PDLO\u0003\u000bVHLW]\u000f\u0003NF\u000f\u0003QLJHO\u000f\u0003HEQHU\u000f\u0003DGULDQ\f#FRPS\u0011ODQFV\u0011DF\u0011XN\n$EVWUDFW\nDue to increasing computational power, long-life batteries and wireless links with\nimproving bandwidth, distributed multimedia applications have become more and\nmore attractive for mobile users. However, the varying quality of service (QoS) on\nthe wireless link is still a major problem. One, generally accepted solution to this\nproblem utilises \u2018proxies\u2019 which act on behalf of the mobile user and modify the\ncommunication data stream in order to match the current QoS conditions. These\nproxies are generally dependent on protocol layers, applications or application data.\nTherefore, in order to enable proxy objects to be flexibly inserted for a given mul-\ntimedia stream, an architecture is required for managing supplied and installed\nproxy objects.\n.H\\ZRUGV\nManagement of Distributed Object-Oriented Multimedia Applications, Mobile\nSystems, CORBA, Quality of Service, Proxy\n\u0014\u0011 ,QWURGXFWLRQ\nMultimedia communication has been made feasible by emerging broadband net-\nworking technologies based on fiber, e.g. ATM, and high performance chips. Fur-\nthermore, due to increasing battery power and improving display technology, mo-\nbile computers have become more and more popular. However, new wireless \u201cun-\ntethered\u201d communication services must be able to adapt to a constantly changing\ncommunications environment brought on by mobility [12]. Because physical prob-\nlems like signal reflection, fading and distortion prevent a constant and high bit rate\nover a wireless link, the strong QoS requirements of multimedia applications have\nto be decreased by modifying the communication stream to adapt its requirements\nto match the characteristics of the wireless transmission link.\nOne way to achieve this adaptation is to install SUR[LHV into the communication\ndata stream. A proxy acts on behalf of the mobile client, separating the wireless\nfrom the wireline link. In addition to this, it also acts as a mediator between these\ntwo different links modifying the communication stream to adapt its requirements\n(c) 1999 IFIP\n(see figure 1, [20]). The technique to insert a proxy has been most commonly used\nto access World-Wide Web pages [15] and to implement firewalls [14]. However,\nthe idea of proxies has proved to be valuable for mobile clients, too.\nDFFHVV\u0003QRGH\n\u000b3UR[\\\f\nPRELOH\u0003FRPSXWHU\n\u000b&OLHQW\f\nORZ\u0003EDQGZLGWK\nKLJK\u0003ODWHQF\\\nKLJK\u0003EDQGZLGWK\nORZ\u0003ODWHQF\\\nFRPSXWHU\u0003LQ\nZLUHG\u0003QHWZRUN\n\u000b6HUYHU\f\nZLUHOHVV\u0003QHWZRUN\n\u000bH\u0011J\u0011\u000f\u0003UDGLR\f\nZLUHG\u0003QHWZRUN\n\u000bH\u0011J\u0011\u000f\u0003,QWHUQHW\f\n)LJXUH\u0003\u0014: Scheme of a Proxy\nHowever, although this approach has been implemented in several research\nprojects, the insertion of proxies remains rather static. Thus, we propose an archi-\ntecture to flexibly insert proxies \u201con the fly\u201d. The architecture is based on the\n&RPPRQ\u0003 2EMHFW\u0003 5HTXHVW\u0003 %URNHU\u0003 $UFKLWHFWXUH\u0003 \u000b&25%$\f\u0003 standard by the Object\nManagement Group [16]. CORBA is a widespread architecture for the implemen-\ntation of distributed applications. Its applicability in the area of (tele-)commu-\nnication services and their management has also been proved [21]. Furthermore,\nactual research projects deal with real-time CORBA implementations.\nThis paper focuses on the management of proxies. For selecting and installing\nproxies, a generic modeling technique has to be defined. We propose a multi-\nlayered technique to supply several interfaces that allow the use of the proxies\nwhile assuming different knowledge of their functionality. Furthermore, we detail\nthe part of the architecture dealing with supplying, selecting and installing proxies.\nThe remainder of this paper is structured as follows. Section 2 introduces the\nRAPP architecture, discussing different levels of proxies and related work. Next,\nsection 3 works out a classification scheme for proxy objects on which their man-\nagement is based. The details of the management of proxies as part of the RAPP\narchitecture are described in section 4. Finally, section 5 summarizes this paper and\ngives an outlook on future work.\n\u0015\u0011 7KH\u00035DSS\u0003$UFKLWHFWXUH\n\u0015\u0011\u0014 5HODWHG\u0003:RUN\nIn the area of mobile computing, proxies can be found on two different levels:-\n3URWRFRO\u00033UR[LHV operate on the protocol level. They can interfere on the trans-\nport level by introducing indirectness like in ,QGLUHFW\u00037&3\u0003[2] or by acting on be-\nhalf of the mobile client as in the 6QRRS\u0003protocol [3]. More specific proxies work\non the base of a modified application protocol like a version of HTTP improved for\nmobile clients [17] or the \/RZ\u0003%DQGZLGWK\u0003;\u00033URWRFRO\u0003 \u000b\/%;\f [10] suitable for X-\nWindows applications running on a mobile client.\n(c) 1999 IFIP\n$SSOLFDWLRQ\u0003 3UR[LHV additionally modify application data to reduce the re-\nquired bandwidth or to pre-compute data. One example, covering the area of CAD\nand network management using a pen-based palmtop computer, is described in [5].\nSome approaches combine the two levels of proxies, leading to proxy instances\nimproving the behaviour of protocols and modifying (e.g. compressing or filtering)\napplication data to reduce the required bandwidth. Some examples of this are the\n*\/2023 project [6], its follow-on project 3\\WKLD\u0003 [8], the use of VHUYLFH\u0003 SUR[LHV\n[11] and an architecture based on real-time distillation [24]. Other approaches do\nnot only include proxies but define a complete platform for supporting adaptive\nmobile applications. One of the most interesting approaches is the 0RELZDUH\u00037RRO\u0010\nNLW [4], which provides a set of open programmable interfaces and algorithms and,\nhence, deals with mobile devices, base stations and mobile-capable switches or\nrouters. However, this architecture demands serious modifications in the distributed\napplications.\nGenerally, the following issues have not been solved completely in these ap-\nproaches:-\n\u2022 ([WHQVLELOLW\\. Most approaches have developed specific proxies for certain\napplications or for special data types, but it is often hard to extend these ap-\nproaches to deal with new applications and data types.\n\u2022 )OH[LEOH\u0003%HKDYLRXU. In most systems the behaviour of the proxy is statically\ndefined. In addition to this, it is generally not possible to fine-tune the proxy\u2019s\noperation to cope with variations in the wireless link\u2019s QoS.\n\u2022 )OH[LEOH\u00033ODFHPHQW. The location of the proxy is an important factor in deter-\nmining the performance of the overall proxy system.\n\u2022 6FDODELOLW\\. Finally, there is the issue of scalability. All the described ap-\nproaches work well, if you have one or two mobile hosts, each being repre-\nsented by their own proxy, or if you scale to the number of mobile nodes by in-\nstalling a high-performance computer or cluster of computers to host the prox-\nies (e.g. [7]). However, for the system to scale proxies must be distributed\nthroughout the system.\nWe have attempted to address the above issues in our architecture, which is de-\nscribed in the next section.\n\u0015\u0011\u0015 $Q\u00032YHUYLHZ\u0003RI\u0003WKH\u00035$33\u0003$UFKLWHFWXUH\nThe RAPP (5eactive $daptive 3roxy 3lacement) architecture is based on the\n&RPPRQ\u0003 2EMHFW\u0003 5HTXHVW\u0003 %URNHU\u0003 $UFKLWHFWXUH\u0003 \u000b&25%$\f standard [16]. Using\nCORBA, it is easy to extend existing applications and proxy objects to become part\nof the RAPP architecture. Proxy objects can be installed on the fly using CORBA\nobject calls. Furthermore, the CORBA adapters for the application components\nexchange QoS messages via a generic QoS service on which decisions to install or\ndeinstall proxy objects are based. Figure 2 illustrates the RAPP architecture.\nOne key issue of the RAPP architecture is the management of proxy objects.\nTherefore, a consistent model for proxy objects was created based on a comprehen-\nsive classification of proxy objects, which is detailed in the next section.\n(c) 1999 IFIP\n4R6\u00036HUYLFH\u0003 4R6\u00036HUYLFH\u0003\n&25%$\u0003$GDSWHU &25%$\u0003$GDSWHU\n0XOWLPHGLD\u0010\n6HUYHU\n0XOWLPHGLD\u0010\n&OLHQW\n0XOWLPHGLD\u0003VWUHDP\nXVLQJ\u0003VSHFLILF\u0003SURWRFRO\n3UR[\\\u0003)DFWRU\\\n2EMHFW\u00035HTXHVW\u0003%URNHU\n7UDQVPLVVLRQ\u0003&RQWURO\u00033URWRFRO\n3\n,QWHUQHW\u0003,QWHU\u001025%\u00033URWRFRO\n:LUHG\u00037UDQVPLVVLRQ\u0003\/LQN\n8VHU\u0003'DWDJUDP\u00033URWRFRO\n,QWHU\u001025%\u00033URWRFRO\nDGDSWHG\u0003IRU\u0003ZLUHOHVV\u0003OLQNV\n:LUHOHVV\u00037UDQVPLVVLRQ\u0003\/LQN\nLQ\nV\nWD\nOO\u0012P\nR\nG\nLI\\\nUHTXHVW\nLQVWDOODWLRQ\n)LJXUH\u0003\u0015: An Overview of the RAPP Architecture\n\u0016\u0011 3UR[\\\u00032EMHFWV\n\u0016\u0011\u0014 &ODVVLILFDWLRQ\u0003RI\u00033UR[\\\u00032EMHFWV\nOne of the goals of the RAPP architecture is to transparently provide proxy objects\nfor distributed applications. This enables a suitable proxy object to be chosen and\ninstalled, whenever the actual link\u2019s characteristic demands a proxy object. As the\ncollection of different proxy objects offered via the RAPP architecture is independ-\nent of the applications, one cannot expect the distributed application to be prepared\nto cope with any of these proxy objects. However, the application can use the ad-\nvantages of the proxy objects via generic interfaces. To determine these generic\ninterfaces proxy objects require classification. We propose a hierarchical classifi-\ncation in order to allow flexibility in defining and using these interfaces.\nAt top level, three main characteristics define the classification scheme:-\n1. The proxy object modifies the input stream without changing the stream type.\nHence, the types of input and output stream are the same, but the amount of\ndata in the output stream has been changed by (usually loss-prone) compres-\nsion. This characteristic is called \u2019DWD\u0003)LOWHULQJ.\n2. The proxy object receives an input stream, processes the data and sends the\nprocessed data in an output stream. This data processing might not only change\nthe amount of data to be sent but also its type. We call this characteristic \u2019DWD\n7\\SH\u00030RGLILFDWLRQ.\n3. Besides processing the data, the proxy object might also be capable of storing\nthe data so that the client can retrieve them later, which we call \u2019DWD\u0003&DFKLQJ.\n(c) 1999 IFIP\nAccording to these three main characteristics, three different classes of proxy ob-\njects have been identified and are described below:-\n)LOWHULQJ\u00033UR[LHV\nA proxy object that cannot cache data and cannot change the data type when proc-\nessing the incoming stream is called a ILOWHULQJ\u0003 SUR[\\. One example of this is a\nproxy object acting as an MPEG filter to reduce the required bandwidth by drop-\nping colours or less relevant video frames [22].\n7UDQVIRUPLQJ\u00033UR[LHV\nA proxy object that modifies the stream type without being able to store the trans-\nformed data locally is classified as a WUDQVIRUPLQJ\u0003SUR[\\. Such a proxy might com-\npress an ASCII stream into a compressed binary stream to save bandwidth.\n&DFKLQJ\u00033UR[LHV\nIn mobile computing the user would sometimes like to work without being con-\nnected to the wired network. Therefore, a FDFKLQJ\u0003SUR[\\, like a mail proxy, might\nstore data for the mobile client so that they can request the stored data after having\nestablished a reliable connection to the wired network again.\nFurthermore, these proxy classes can also be combined. A transforming proxy\nmight use a loss-prone compression technique, hence it also acts as a filtering\nproxy, whereas a caching proxy might additionally implement a function to change\nthe type of the stream or to compress data. Because each proxy class results in a\nspecific interface (see section 3.3), a proxy implementing different proxy classes\noffers the combination of their interfaces.\n\u0016\u0011\u0015 7\\SHV\u0003RI\u00033UR[\\\u00032EMHFWV\nThe next level of the classification scheme is based on the types of streams a proxy\nobject receives and emits. Therefore, we introduce a three-fold stream classification\nscheme involving a coarse-grain classification, a fine-grain classification and an\nextension of the latter. In the coarse-grain classification we differentiate between\nfive VWUHDP\u0003 W\\SHV according to the 0XOWLSXUSRVH\u0003 ,QWHUQHW\u00030DLO\u0003([WHQVLRQV\u00030,0(\nstandard [9]. To formally define the stream type we use the Object Type Macro as\ndefined in [18] shown below.\nstreamType OBJECT-TYPE\n    SYNTAX  Integer{\n               text(1),\n               application(2),\n               image(3),\n               audio(4),\n               video(5)}\n    ACCESS  read-write\n    STATUS  mandatory\n    DESCRIPTION\n          \u201cTo classify a communication data stream coarsely,\n           five MIME Content-Types can be used:\n             1 \u2013 text;\n             2 \u2013 application;\n             3 \u2013 image;\n             4 \u2013 audio;\n             5 \u2013 video.\u201d\n    ::= { commDataStreamEntry 2 }\n(c) 1999 IFIP\nEach of the five stream types can be further subdivided using fine-grain sub-\ntypes shown in figure 3.\n6WUHDP\u00037\\SH6WUHDP\u00037\\SH\nWH[W DSSOLFDWLRQ LPDJH DXGLR YLGHR\nSODLQ\nKWPO\nSGI\nUWI\nSRVWVFULSW\nRFWHW\u0010VWUHDP\nPVZRUG\nJLI\nMSHJ\nELWPDS\nSKRWR\u0010FG\nSFP\nZDY\nPLGL\nPSHJ\nUHDODXGLR\nPSHJ\nP\u0010MSHJ\nTXLFNWLPH\u0011\u0011\u0011\n\u0011\u0011\u0011 \u0011\u0011\u0011\n\u0011\u0011\u0011 \u0011\u0011\u0011\nK\u0011\u0015\u0019\u0014\n)LJXUH\u0003\u0016: Stream Types and Subtypes\nEach of the subtypes can be enhanced by a specific characteristic: examples are\n\u201cencrypted\u201d or \u201ccompressed\u201d. To be as flexible as possible both subtypes and sub-\ntype enhancements are easily extensible. Any proxy object might then be charac-\nterized by the stream it receives and the stream it sends. This characterization is\nmirrored in the proxy selection process described in section 4.\n\u0016\u0011\u0016 ,QWHUIDFHV\u0003RI\u00033UR[\\\u00032EMHFWV\nEach proxy object offers an interface for requesting the different services which the\nobject has implemented. Because the RAPP architecture is a generic architecture,\nthe applications using the services of a proxy object should not be specially cus-\ntomized for these services. Hence, the proxy objects should supply a generic inter-\nface making it easier for applications to request services independently of the proxy\nobject\u2019s implementation. However, because the proxy objects have different tasks\nand serve different purposes, we propose to use four levels of interfaces.\n*HQHULF\u00033UR[\\\u00032EMHFW\u0003,QWHUIDFH\nAny proxy object should offer an interface independently of the implemented serv-\nices. This generic interface allows the following operations:-\n\u2022 ProxyObject installProxy (IPAddress sender, integer port,\n   IPAddress receiver, integer recPort, integer StreamID)\nTo install a proxy object, this generic \u201cinstallProxy\u201d operation is used.\nWhen calling this operation, one must supply the sender of the stream to be\nmodified by the proxy, the port the stream should be re-routed to, the receiver\nand its port, and the stream identification. As a result, a handle to the installed\nproxy object is returned. (Note that this interface procedure is indirectly of-\nfered by the proxy factory described in section 4.1.)\n\u2022 boolean reRouteProxy (IPAddress sender, integer port,\n   IPAddress receiver, integer recPort, integer StreamID)\nTo modify the route through a proxy, e.g. if a new proxy has to be inserted into\nthe stream or if another proxy has been deleted, the \u201creRouteProxy\u201d proce-\n(c) 1999 IFIP\ndure is used. It requires the same parameters as the \u201cinstallProxy\u201d proce-\ndure, but is directly called at the proxy object\u2019s interface.\n\u2022 boolean deleteProxy (ProxyObject proxy)\nA proxy object can be deleted using this operation. Note that the stream has to\nbe re-routed first before deleting the proxy object.\n&ODVV\u0010GHSHQGHQW\u00033UR[\\\u00032EMHFW\u0003,QWHUIDFH\nTo influence the behaviour of a proxy object in a general way, the proxy object\nshould offer an interface according to its class. We suggest the following opera-\ntions: The behaviour of a ILOWHULQJ\u0003 SUR[\\ can be controlled using the operations\nfilterOn() to enable the filter, filterOff() to disable the filter, increase-\nFiltering() to reduce the required bandwidth of the data stream leaving the\nproxy object and decreaseFiltering() to loosen the degree of filtering. A\nWUDQVIRUPLQJ\u0003SUR[\\ offers the operations transformOn() to start the transforming\nprocess and transformOff() to stop it. The user can affect the behaviour of a\nFDFKLQJ\u0003 SUR[\\ using the operations cacheOn() to enable the caching, cache-\nOff() to disable caching and emptyCache() to delete all the data stored in the\ncache.\nAs stated above, a proxy that implements more than one proxy object class must\nsupply an interface combining all the interface operations defined for these proxy\nobject classes.\n7\\SH\u0010GHSHQGHQW\u00033UR[\\\u00032EMHFW\u0003,QWHUIDFH\nDue to the different types of streams a proxy object can process, type dependent\noperations have to be gathered in a special interface. Because the number of differ-\nent stream types and their subtypes is large, not all type-dependent interfaces can be\ndetailed here. The following example for a filtering proxy illustrates what a type\ndependent interface might look like.\nIn the first prototype implementing the RAPP architecture, we experimented\nwith a proxy object that filters an MPEG video stream [22]. Therefore, this proxy\noffers a class-dependent interface for filtering proxies consisting of the operations\nfilterOn(), filterOff(), encreaseFiltering() and decreaseFilter-\ning(). Furthermore, as a proxy specifically developed to filter an MPEG stream, it\noffers the following type-dependent operations (amongst others):-\n\u2022 dropBFrames(): erase all the B-frames in the MPEG stream;\n\u2022 dropBandPFrames(): erase all B- and P-frames in the MPEG stream;\n\u2022 dropColor(): change the colors to black & white;\n\u2022 requantize(): requantize the resolution.\nAll proxy objects suitable for an MPEG stream must implement these interface\noperations. In addition, these operations may also be used when realizing the op-\nerations of the class-dependent proxy object interface: the filterOn() operation\nmight be mapped onto the dropBFrames() operation, whereas the encrease-\nFiltering() operation would then be performed by calling the drop-\nBandPFrames() operation.\n,PSOHPHQWDWLRQ\u0010GHSHQGHQW\u00033UR[\\\u00032EMHFW\u0003,QWHUIDFH\nFinally, any proxy object implementation might offer an implementation-specific\ninterface. The operations contained in this interface are not restricted in any way.\n(c) 1999 IFIP\nHowever, the application must be aware of the implementation if it wants to use\nany of these operations.\n\u0016\u0011\u0017 \/RFDWLRQ\u0003RI\u00033UR[\\\u00032EMHFWV\nAnother critical issue is the location of a proxy object. There are two restrictions\nthat have to be considered when installing a proxy:-\n1. The proxy object must be installed on a node where (a) the required resources\n(hardware, software, qualitative requirements) can be fulfilled and (b) the ob-\nject PD\\ be installed.\n2. The installation of one proxy object may result in the installation of another\nproxy object. E.g., if a transforming proxy is installed which compresses data,\nthen another one has to be installed to uncompress the data for the receiver.\nThe location of a proxy has not been deeply considered in other research projects in\nthis area. The location of the proxy objects might be crucial to the performance\nexperienced by the mobile user, especially for applications distributed over a wide\narea network. However, due to complex network structures and different network\ndomains, it is generally very complicated to compute the optimal location for proxy\ninstallation. Therefore, we propose a simplified decision scheme for proxy place-\nment. For each proxy object, a list of five placement options determines the se-\nquence of location preferences. The five options are [20]:-\n1. The proxy should be located on the server.\n2. The proxy should be located within the server\u2019s domain (e.g., the same subnet).\n3. The proxy should be located in the client\u2019s domain.\n4. The proxy should be located on the client.\n5. The proxy could be located anywhere in the network.\nFor example, the location preference for the MPEG proxy described above is the\nsequence <1,2,3,5>. This means that the proxy should be installed on the MPEG\nserver if possible to filter the MPEG stream before it leaves the sender. The second\noption is to install the proxy in the server\u2019s domain to minimize the bandwidth\nneeded between the server\u2019s subnet and the client. The third option is to install the\nproxy within the mobile client\u2019s actual domain, but preferably within the wired\nnetwork, to disburden the (possible) wireless link to the mobile user of a stream\nrequesting too much bandwidth. Finally, if all these options are not feasible (due to\nsecurity or performance reasons), the proxy might be installed somewhere in the\nnetwork (possibly resulting in a longer transmission delay). However, to install the\nproxy on the (mobile) client is not advisable, because this would have no effect on\nthe quality of the transmission over the wireless link.\nThe location preferences play an important role in the management of proxy\nobjects as described in the next section.\n\u0017\u0011 0DQDJHPHQW\u0003RI\u00033UR[\\\u00032EMHFWV\nAfter the classification of proxy objects, this section deals with their management.\nTherefore, we differentiate between the following tasks:-\n\u2022 Proxy objects must be hosted for instantiation.\n\u2022 Suitable proxy objects must be selected.\n(c) 1999 IFIP\n\u2022 Instantiated proxy objects must be parametrised, modified and de-installed.\nThe following sections describe the components cooperating for the given tasks.\n\u0017\u0011\u0014 3UR[\\\u0003)DFWRU\\\nProxy objects are kept in proxy repositories managed by SUR[\\\u0003 IDFWRULHV. Each\nproxy factory is responsible for a number of different proxy objects. One can add\nany proxy object to a given proxy factory by supplying a description of the proxy\nobject. This description contains the following information:\n\u2022 a classification of the stream received by the proxy object, represented by the\ntriple <streamType, streamSubType, streamSubTypeSpecific>;\n\u2022 a classification of the stream emitted by the proxy object using the same\nstructure as introduced above;\n\u2022 the location preference of the proxy object given as a vector containing be-\ntween one and five integers in the numeric range of one to five, as described in\nsection 3.4;\n\u2022 a boolean variable specifying, whether the proxy object uses loss-prone com-\npression or not.\nHence, a proxy object that filters an MPEG video stream can be described by the\nfollowing information:\n<video, mpeg, none> \/\/ Instream is an MPEG video\n                    \/\/ stream without special characteristics\n<video, mpeg, none> \/\/ Outstream is an MPEG video stream\n                    \/\/ without special characteristics\n[1,2,3,5]           \/\/ Location preferences\ntrue                \/\/ The proxy uses loss-prone compression\nThe proxy factory registers all its proxy objects with a local proxy trader. This\nproxy trading service is detailed in the next section.\n\u0017\u0011\u0015 3UR[\\\u00037UDGLQJ\u00036HUYLFH\nDuring the proxy selection phase, the client requests a proxy object to be installed\nfor a given data stream. As described in the section above, the effect of a proxy\ndepends on the place it is installed. In order to simplify the process of finding a\nsuitable proxy object, we suggest the use of a SUR[\\\u0003WUDGLQJ\u0003VHUYLFH. This service is\nprovided by several SUR[\\\u0003 WUDGHUV. Each proxy trader is responsible for a certain\nnetwork domain, e.g. a subnet. Via a UHJLVWUDWLRQ process, a proxy trader receives\nthe information about all the proxies available through all the proxy factories of this\ndomain.\nIn order to register a proxy object, the proxy factory responsible for that object\nhas to export its service description to the proxy trading service. Following [1], this\n\u201cexport\u201d procedure must supply an object reference to the object being offered,\ni.e. the proxy factory\u2019s ID, a service type name and a set of properties, given as\nname and value pairs. In the case of the proxy trading service, the service type\nname is the class of the proxy object (as defined in section 3.1) and the set of prop-\nerties is given through the information on the proxy object given above. As a result,\nthe trader returns a proxy offer ID, which is used for further modifications of the\nregistered service, including its withdrawal.\n(c) 1999 IFIP\nTo de-register a proxy object, the \u201cwithdraw\u201d procedure must be called sup-\nplying the proxy offer ID. Furthermore, it is sometimes advantageous to have a\nprocedure de-registering all the proxy objects of a given proxy factory. For this, the\nCORBA standard suggests the \u201cwithdraw_using_constraints\u201d procedure.\nFinally, the \u201cmodify\u201d procedure can be used to modify an already registered\nproxy offer specifying its offer ID and a new set of properties.\nTo keep the proxy trading service simple, the standardised trader operations\n\u201cdescribe\u201d and \u201cresolve\u201d are not currently included.\nSince each domain has its own proxy trader, it is easy to assign a proxy trader to\nboth servers and mobile clients. When the client first uses a service offered by the\nserver, it also receives a handle to the server\u2019s proxy trader. This is important,\nbecause some proxy objects might prefer to be installed close to the server.\nOnce the client decides that a proxy object should be installed into the stream, it\naddresses the proxy trading service using the \u201cquery\u201d procedure supplying the\nfollowing parameters:-\n\u2022 the client\u2019s ID;\n\u2022 a reference to the proxy trading service of the server\u2019s domain;\n\u2022 a description of the desired proxy service (according to the proxy object de-\nscription above, but without location specification);\n\u2022 a preference scheme to influence the sequence of results;\n\u2022 an integer value (\u201chow_many\u201d) for describing the maximum length for the\nsequence of results.\nThis query leads to the proxy trading service trying to find a sequence of proxy\nfactories that offer proxy objects of the required kind via the following three steps\n(see figure 4):-\n1. The trading service searches its local database where the proxy offer descrip-\ntions are stored. All the offers that allow local installation and have suitable in-\nput and output streams are gathered in a vector V1. Furthermore, the trader\ncreates a vector V2 of all the offers whose outgoing streams correspond to the\none the client expects. These offers might be combined with a proxy object to\nbe installed on the server side. Hence, the trader will send additional queries to\nfind complement proxies to the ones stored in V2.\n2. After the proxy trading service of the server\u2019s domain has received the original\nquery it performs the retrieving of its local database, but without looking for\noffers fitting the output stream only. The same is done for the additional que-\nries looking for complementary proxy objects. For each query a result con-\ntaining the offers and the corresponding proxy factories is returned.\n3. The client\u2019s proxy trading service then merges the results of its local query\nstored in V1 and the first result returned by the server\u2019s proxy trading in vector\nV3. Then it combines the offers stored in vector V2 with the results of the ad-\nditional queries and extends vector V3 with the suitable proxy object pairs. If\nthe merged list is empty, the proxy trading service could then query other\nproxy trading service instances, but only if the client did not prevent that in its\n\u201cpreference\u201d parameter.\n(c) 1999 IFIP\nIf the result list is not empty, the proxy trading service orders the entries according\nto the \u201cpreference\u201d parameter given in the query. It also considers the\n\u201chow_many\u201d parameter for only returning the best [ results to the query. It is then\nup to the client to decide which of the offers included in the returned list to choose.\n \n \n \n LAN\n \n \n \n LAN\n6HUYHU\n0RELOH\u0003&OLHQW\n,QWHUQHW\n&OLHQW\n$SSOLFDWLRQ\n6HUYHU\n$SSOLFDWLRQ\n5$33\u00033OXJLQ 5$33\u00033OXJLQ\nWorkstation\nWorkstation\nWorkstation\nWorkstation\nWorkstation\nWorkstation\nWorkstation\n3UR[\\\n7UDGLQJ\n6HUYLFH\n3UR[\\\n7UDGLQJ\n6HUYLFH\n&OLHQW\nV\u0003'RPDLQ 6HUYHU\nV\u0003'RPDLQ\n4XHU\\\n3UR[\\\n2IIHUV\n6WHS\u0003\u0014\u001d\u00034XHU\\\u0003ORFDO\u0003GDWDEDVH\n3UR[\\\n2IIHUV\n6WHS\u0003\u0015\u001d\n4XHU\\\u0003VHUYHU\nV\nSUR[\\\u0003WUDGLQJ\u0003VHUYLFH\n4XHU\\\u0003ORFDO\u0003GDWDEDVH\n6WHS\u0003\u0016\u001d\n4XHU\\\u0003,QWHUQHW\n)LJXUH\u0003\u0017: Functionality of the Proxy Trading Service\n\u0017\u0011\u0016 3UR[\\\u0003,QVWDOODWLRQ\u000f\u00030RGLILFDWLRQ\u0003DQG\u0003\u2019H\u0010LQVWDOODWLRQ\nHaving received the results to its query, the client chooses the proxy factory (or\nfactories, if there are two proxy objects to be installed) and requests the installation\nof the proxy object. For the installation, the procedure \u201cinstallProxy\u201d is called,\nwhich is part of the generic proxy object interface and is offered indirectly by the\nproxy factory.\nThe client can then enable the functionality of the proxy object by calling the\nfunctions of the class-dependent proxy interface. Based on monitoring the actual\nQoS associated with the stream, the client is able to modify the behaviour of a\nproxy object, choosing from three options:-\n1. The class-dependent proxy interface offers high-level operations to influence\nthe functionality of the proxy object.\n2. A finer degree of control is offered through the type-dependent proxy inter-\nface. However, the client\u2019s application must be prepared to use these opera-\ntions.\n3. Finally, the client could use the implementation-dependent interface offering\nlow-level operations.\nOnce the actual QoS is sufficient or the data stream has finished, a proxy object can\nbe de-installed using the \u201cdeleteProxy\u201d operation. Note that de-installing a proxy\nobject might result in having to re-route the stream calling the \u201creRouteProxy\u201d\noperation of other installed proxy objects.\n\u0017\u0011\u0017\u0003 7KH\u00035$33\u00033URWRW\\SH\nFor a first prototype we chose the following components:\n\u2022 A modification of the Berkley MPEG player is used as a client\/server applica-\ntion [19].\n(c) 1999 IFIP\n\u2022 As a proxy object, we used an MPEG filter developed by N. Yeadon [23].\nWe had to enhance these components with special CORBA stubs (as can be seen in\nfigure 5, called \u201cRAPP Plugin\u201d consisting of the generic QoS Service component\nand the CORBA adapter illustrated in figure 2). These enhancements were pro-\ngrammed using the OmniBroker as an Object Request Broker implementation [13].\nThe video stream emitted by the MPEG video player is sent using UDP packets.\nThese UDP packets are not touched by the RAPP plugins. The plugins are only\nresponsible for signalling.\n&OLHQW\n&OLHQW\n5$33\u00033OXJLQ5$33\u00033OXJLQ\n03(*\u00039LGHR\u00036WUHDP\n&RQWURO\u00036WUHDP\n\u000bD\f\u0003EHIRUH\u0003SUR[\\\u0003LQVWDOODWLRQ\n&OLHQW&OLHQW\n5$33\u00033OXJLQ5$33\u00033OXJLQ\n\u000bE\f\u0003DIWHU\u0003SUR[\\\u0003LQVWDOODWLRQ\n6HUYHU\n6HUYHU\n5$33\u00033OXJLQ5$33\u00033OXJLQ\n)LOWHU\n)LOWHU\n5$33\u00033OXJLQ\n5$33\u00033OXJLQ\n6HUYHU6HUYHU\n5$33\u00033OXJLQ5$33\u00033OXJLQ\n03(*\u00039LGHR\u00036WUHDP\n)LOWHU\nHG\u00030\n3(*\n9LGHR\n\u00036WUH\nDP\n3UR[\\\u00032EMHFW\n)LJXUH\u0003\u0018: Functionality of the Prototype\nWe organized the scenario as follows:\n\u2022 The client part was started on a Linux Pentium-based PC in the Computing\nDepartment of Lancaster University.\n\u2022 The server part ran on another Linux Pentium-based PC in the same depart-\nment.\n\u2022 The proxy trader service was supplied by a third PC in the Computing De-\npartment.\nThe MPEG filter we chose as a proxy was, however, installed on a Sun Worksta-\ntion in the Institute of Telematics in the University of Karlsruhe\/Germany. This\nmeant, that the multimedia stream containing the MPEG video frames had to be re-\nrouted over Karlsruhe.\nThe results of this experiment have been very satisfying. Installing and de-\ninstalling the proxy worked without any kind of disturbing delay. Although the\napplication parts and the MPEG filter used as a proxy object ran on different ma-\n(c) 1999 IFIP\nchine architectures and operating systems, CORBA provided a seamless integration\nof the different application parts. This prototype is a solid foundation to extend the\nimplementation of the RAPP architecture.\n\u0018\u0011 &RQFOXVLRQ\nProxies have been proven to be an effective means of adapting the QoS require-\nments of multimedia applications to the varying characteristics of wireless links. In\norder to be flexible when supporting different kinds of distributed applications and\nmultimedia streams we introduced an architecture for managing proxy objects\nbased on the CORBA standard.\nKey factors for the success of this architecture are a comprehensive technique to\nexpress the characteristics of proxies for the proxy selection process and an easy to\nhandle interface to interact with proxy objects. This interface makes it easy to call\noperations and, thus, change the proxy\u2019s behaviour, without having to know the\nproxy\u2019s functionality in detail.\nThe prototype of the architecture has been implemented and tested both locally\nand over wide distances (between England and Germany). The results have been\nvery promising, and therefore we plan to enhance the prototype in order to produce\nperformance data. Furthermore, because installing and modifying proxies is critical\nfor security, the RAPP architecture will also be extended to contain a security\nmechanism to control the handling of proxies.\n$FNQRZOHGJHPHQWV\nThis work has been partly supported by the EPSRC under the auspices of the Re-\nactive Services project.\n5HIHUHQFHV\n[1] S. Baker: &25%$\u0003 \u2019LVWULEXWHG\u0003 2EMHFWV\u0003 8VLQJ\u0003 2UEL[. ACM Press \/ Addison\nWesley, Harlow, England - Reading, Massachusetts, 1997.\n[2] A. Bakre and B.R. Badrinath: ,\u00107&3\u001d\u0003 ,QGLUHFW\u0003 7&3\u0003 IRU\u0003 0RELOH\u0003 +RVWV. 15th\nInternational Conference on Distributed Computing Systems, Vancouver, Can-\nada, May 30 - June 2, 1995.\n[3] H. Balakrishnan, S. Seshan and R.H. Katz: ,PSURYLQJ\u00035HOLDEOH\u00037UDQVSRUW\u0003DQG\n+DQGRII\u0003 3HUIRUPDQFH\u0003 LQ\u0003 &HOOXODU\u0003 :LUHOHVV\u0003 1HWZRUNV. ACM Wireless Net-\nworks 1(IV), 1995.\n[4] A.T. Campbell: 7KH\u0003 0RELZDUH\u0003 7RRONLW, Fourth International Workshop on\nHigh Performance Protocol Architectures (HIPPARCH '98), London, June 15\u2013\n16, 1998\n[5] W. Citrin, P. Hamill, M.D. Gross and A. Warmack: 6XSSRUW\u0003 IRU\u0003PRELOH\u00033HQ\u0010\nEDVHG\u0003 $SSOLFDWLRQV. Third annual ACM\/IEEE International Conference on\nMobile Computing and Networking MobiCom'97, Budapest, Hungary, Sep-\ntember 26\u201330, 1997.\n[6] A. Fox and E.A. Brewer: *OR0RS\u001d\u0003 *OREDO\u0003 0RELOH\u0003 &RPSXWLQJ\u0003 E\\\u0003 3UR[\\.\nhttp:\/\/www.research.microsoft.com\/os\/sosp%2D15\/fox.txt, 1995.\n(c) 1999 IFIP\n[7] A. Fox and E.A. Brewer: 5HGXFLQJ\u0003:::\u0003\/DWHQF\\\u0003 DQG\u0003%DQGZLGWK\u0003 5HTXLUH\u0010\nPHQWV\u0003E\\\u00035HDO\u00107LPH\u0003\u2019LVWLOODWLRQ. Fifth International World Wide Web Confer-\nence, Paris, France, May 6-10, 1996.\n[8] A. Fox, S.D. Gribble, E.A. Brewer and E. Amir: $GDSWLQJ\u0003 WR\u0003 1HWZRUN\u0003 DQG\n&OLHQW\u00039DULDELOLW\\\u0003YLD\u00032Q\u0010\u2019HPDQG\u0003\u2019\\QDPLF\u0003\u2019LVWLOODWLRQ. ASPLOS-VII - Sev-\nenth International Conference on Architectural Support for Programming Lan-\nguages and Operating Systems, Cambridge, Mass., USA, October 1\u20135, 1996.\n[9] N. Freed and N. Borenstein: 0XOWLSXUSRVH\u0003 ,QWHUQHW\u00030DLO\u0003([WHQVLRQV\u0003 \u000b0,0(\f\n3DUW\u00037ZR\u001d\u00030HGLD\u00037\\SHV. Request for Comments 2046, November 1996.\n[10] J. Fulton and C. Kantarjiev: $Q\u00038SGDWH\u0003RQ\u0003\/RZ\u0003%DQGZLGWK\u0003;\u0003 \u000b\/%;\f. The X\nResource 5(1), pp. 251\u2013266, January 1993.\n[11] A. Hokimoto, K. Kurihara and T. Nakajima: $Q\u0003 $SSURDFK\u0003 IRU\u0003 &RQVWUXFWLYH\n0RELOH\u0003$SSOLFDWLRQV\u00038VLQJ\u00036HUYLFH\u00033UR[LHV. 16th International Conference on\nDistributed Computing Systems ICDCS, Hong Kong, May 27\u201330, 1996.\n[12] R.H. Katz: $GDSWDWLRQ\u0003DQG\u00030RELOLW\\\u0003LQ\u0003:LUHOHVV\u0003,QIRUPDWLRQ\u00036\\VWHPV. Personal\nCommunications 1(1), pp. 6\u201317, First Quarter, 1994.\n[13] M. Laukien and U. Seimet: 2PQL%URNHU, Object-Oriented Concepts, Inc.,\nBillerica (USA) and Ettlingen (Germany). Manual, December 16, 1997.\n[14] S.W. Lodin and C.L. Schuba: )LUHZDOOV\u0003IHQG\u0003RII\u0003LQYDVLRQV\u0003IURP\u0003WKH\u00031HW. IEEE\nSpectrum 35(2), pp. 26\u201334, February 1998.\n[15] A. Luotonen and K. Altis: :RUOG\u0010:LGH\u0003:HE\u00033UR[LHV. First International Con-\nference on the World-Wide Web, Geneva, Switzerland, May 25\u201327, 1994.\n[16] OMG: 7KH\u0003&RPPRQ\u00032EMHFW\u00035HTXHVW\u0003%URNHU\u001d\u0003$UFKLWHFWXUH\u0003DQG\u00036SHFLILFDWLRQ,\nObject Management Group (OMG). Revision 2.2, February 1998.\n[17] V.N. Padmanabhan and J.C. Mogul: ,PSURYLQJ\u0003 +773\u0003 \/DWHQF\\. Computer\nNetworks and ISDN Systems 28(1\/2), pp. 25\u201335, December 1995.\n[18] M.T. Rose and K. McCloghrie: &RQFLVH\u00030,%\u0003\u2019HILQLWLRQV. Request for Com-\nments 1212, March 1991.\n[19] L. Rowe, S. Smoot and E. Hung: 03(*\u0003 5HVHDUFK\u0003 DW\u0003 8\u0011&\u0011\u0003 %HUNHOH\\.\nhttp:\/\/bmrc.berkeley.edu\/projects\/mpeg\/, 1998.\n[20] J. Seitz, N. Davies, M. Ebner and A. Friday: $\u0003&25%$\u0010EDVHG\u00033UR[\\\u0003$UFKL\u0010\nWHFWXUH\u0003 IRU\u00030RELOH\u00030XOWLPHGLD\u0003$SSOLFDWLRQV. Second IFIP\/IEEE International\nConference on Management of Multimedia Networks and Services MMNS'98,\nVersailles, France, November 16\u201318, 1998.\n[21] T. Urquhart: 1HWZRUN\u0003 DQG\u0003 6HUYLFH\u0003 0DQDJHPHQW\u0003 \u0010\u0003 :K\\\u0003 &25%$\"\u0003NOC'98 -\nThird European Conference on Networks and Optical Communications, Man-\nchester, UK, June 23\u201325, 1998.\n[22] N.J. Yeadon, F. Garc\u00eda, D. Hutchison and D. Shepherd: )LOWHUV\u001d\u00034R6\u00036XSSRUW\n0HFKDQLVPV\u0003IRU\u00030XOWLSHHU\u0003&RPPXQLFDWLRQV. IEEE Journal on Selected Areas\nin Communications 14(7), pp. 1245\u20131262, September 1996.\n[23] N.J. Yeadon: 4XDOLW\\\u0003 RI\u0003 6HUYLFH\u0003 )LOWHULQJ\u0003 IRU\u0003 0XOWLPHGLD\u0003 &RPPXQLFDWLRQ.\nPhD-thesis. Computing Dept., Lancaster University, Lancaster, UK, 1996.\n[24] B. Zenel and D. Duchamp: $\u0003*HQHUDO\u0003 3XUSRVH\u0003 3UR[\\\u0003 )LOWHULQJ\u00030HFKDQLVP\n$SSOLHG\u0003 WR\u0003 WKH\u0003 0RELOH\u0003 (QYLURQPHQW. Third annual ACM\/IEEE International\nConference on Mobile Computing and Networking MobiCom'97, Budapest,\nHungary, September 26\u201330, 1997.\n(c) 1999 IFIP\n"}