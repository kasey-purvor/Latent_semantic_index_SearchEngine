{"doi":"10.1109\/INFCOM.2004.1357017","coreId":"71322","oai":"oai:eprints.lancs.ac.uk:2541","identifiers":["oai:eprints.lancs.ac.uk:2541","10.1109\/INFCOM.2004.1357017"],"title":"Impact of simple cheating in application-level multicast.","authors":["Mathy, Laurent M. J.","Blundell, Nick","Roca, Vincent","El-Sayed, Ayman"],"enrichments":{"references":[{"id":16368727,"title":"1328 Authorized licensed use limited to:","authors":[],"date":"2010","doi":null,"raw":"0-7803-8355-9\/04\/$20.00 C~2.2004  IEEE.  1328 Authorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply.","cites":null},{"id":16368714,"title":"A Case for End System Multicast.","authors":[],"date":"2000","doi":"10.1145\/339331.339337","raw":"[-I]  Y-If.  Chu: S.  Rm. and If. Zhang. A Case for End System Multicast. In ACM SIGMETRICS. pap  1-11.  Santa Clare. CA.  USA.  June 2000. 151, S.  Ikzring and D. Chcciton.  Multicast Routing  in Untqrnnw Intcmctwork and Extended LANs. ACM  Tmni.  Conp. S\\Tl..  8:85-11@.  May 19'M.","cites":null},{"id":16368724,"title":"A Host-Based .Mullic3st Solution for Group Communications. In","authors":[],"date":"2001","doi":null,"raw":"(121  V.  Roca and A.  El-Snyed.  A Host-Based .Mullic3st  Solution for Group Communications.  In IEEE bill. CUI$ Nrhrorking. Jul 2001. 1131  A.  Rowstron.  A.M.  Kermarrec. M.  Castru. and P.  Dnrcchcl.  SCRIBE the Design of B Larpz-Sc~la  Event Notification Infrastructure. In Pmc. of Ind workrlmp on Nrrworkrd Grmp Conearr,zicalion (NGC).  Nov 2W 1.","cites":null},{"id":16368716,"title":"A Survey of Propn~als for an Alternatiw Group Communication Service.","authors":[],"date":"2003","doi":null,"raw":"171  A.  El-Suycd. V.  Roca.  and 1.  Mathy.  A  Survey of  Propn~als  for  an Alternatiw Group Communication Service.  IEEE Nrrirork.  l7(11:46 51. Janffeh 2003.","cites":null},{"id":16368722,"title":"ALMI an Application Level Multicast Intiustructuc.","authors":[],"date":"2001","doi":null,"raw":"[IO] D. Pendarakis.  S. Shi.  D.  Vsma.  and  41.  Waldvogcl.  ALMI  an Application  Level Multicast Intiustructuc.  In 3rd USEh'lX  S?ntposism 01  Irmmel Trrlr,rologius. San Francism. CA. USA.  Mar 2001 I111  S. Kattnasamy.  M. Handky. and S. Shcnkcr. Applirulion-Lcwl  Multicast using  Content  Addrcssshlc  Networks.  In Pnx. of  bll. wurkd~op  on Nrrworked Gmiip Commio!icnrion (IVGCJ.  Nov 2001.","cites":null},{"id":16368720,"title":"An Owlay Trez Buildins Control F~oiocoI.","authors":[],"date":"2001","doi":null,"raw":"191  L.  Mathy. R. Canonico. and D.  Hutchison.  An Owlay Trez Buildins Control  F~oiocoI. In  Pm.  of  \/nil.  worh\/!op 011  Nerorkrd  Gmup Commnnicnlion (NCC). pasis 7687. Nov 2001.","cites":null},{"id":16368709,"title":"and M..Hakn. A vQm solaion for fully secure and effici6nt group communications.","authors":[],"date":"2003","doi":null,"raw":"[I] 1.  Alchanl.  V.  Rwa. A.  El-Snyed. and  M..Hakn.  A  vQm  solaion for  fully  secure  and  effici6nt group  communications.  In Xrb IEEE Symposim  ON Compnlerr  and  c,~,~,,&quot;,,,,;~',~;~,,~~  (ISCC'OJJ.  Kmirr.hrnlyn. lhrk~~.~  June 2003.","cites":null},{"id":16368718,"title":"Application-Layzr Multicast with Ddaunay Tnunsulutions.","authors":[],"date":"2001","doi":null,"raw":"(81  1.  Liskrherr. M.  Nahas.  and W. Si.  Application-Layzr Multicast with Ddaunay Tnunsulutions.  In IEEE GLOBECOM. Sou 2001.","cites":null},{"id":16368726,"title":"Hat Multicast: a Framework for klivcring Multicast to End Users. lo IEEE Iilfi,com.","authors":[],"date":"2002","doi":null,"raw":"[I51  B.  Zhani.  S. Jamin.  and  L. Zhnng.  Hat  Multicast:  a  Framework for klivcring Multicast to End Users.  lo IEEE Iilfi,com. Jun 2002.","cites":null},{"id":16368725,"title":"How to Mal4 an Intzmstwork.","authors":[],"date":"1996","doi":null,"raw":"11.11  E.  %gura.  K.  Calvan.  and  S. Bhuttachwjcc.  How  to  Mal4 an Intzmstwork.  In IEEE Infocorn. pages J&5?. Mar  1996.","cites":null},{"id":16368713,"title":"LMX: Reliable Multican for Hzterogmeous Network. In","authors":[],"date":"2000","doi":null,"raw":"cCunne. and E. Brzwer.  LMX:  Reliable Multican for Hzterogmeous Network.  In IEEE hlfucom. Mar 2000.","cites":null},{"id":16368711,"title":"Scalable Application Layer Multicast.","authors":[],"date":"2002","doi":null,"raw":"[2]  S. Ransrjzc.  B. Rhattachxjulcc. and C. Kommarsddy. Scalable Application Layer Multicast.  In .ACM  SIGCOMM. Aug 2002.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2004-03-07","abstract":"We study the impact of cheating nodes in application-level multicast overlay trees. We focus on selfish nodes acting independently, cheating about their distance measurements during the control phase building or maintaining the tree. More precisely, we study, through simulations, the impact of simple cheating strategies in four protocols, representatives of different application-level multicast protocol \"families\": HBM (a protocol based on a centralized approach), TBCP (a distributed, tree first protocol), NICE (a distributed, tree first protocol based on clustering) and NARADA (a mesh first protocol). We evaluate the impact of cheats on the performance of the overlay trees as perceived by their nodes and the underlying network","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/71322.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/2541\/1\/getPDF2.pdf","pdfHashValue":"4c28b6be524fd0944e10073bc912f596e22b7ad6","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:2541<\/identifier><datestamp>\n      2018-01-24T02:09:09Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D626F6F6B5F73656374696F6E<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Impact of simple cheating in application-level multicast.<\/dc:title><dc:creator>\n        Mathy, Laurent M. J.<\/dc:creator><dc:creator>\n        Blundell, Nick<\/dc:creator><dc:creator>\n        Roca, Vincent<\/dc:creator><dc:creator>\n        El-Sayed, Ayman<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        We study the impact of cheating nodes in application-level multicast overlay trees. We focus on selfish nodes acting independently, cheating about their distance measurements during the control phase building or maintaining the tree. More precisely, we study, through simulations, the impact of simple cheating strategies in four protocols, representatives of different application-level multicast protocol \"families\": HBM (a protocol based on a centralized approach), TBCP (a distributed, tree first protocol), NICE (a distributed, tree first protocol based on clustering) and NARADA (a mesh first protocol). We evaluate the impact of cheats on the performance of the overlay trees as perceived by their nodes and the underlying network.<\/dc:description><dc:date>\n        2004-03-07<\/dc:date><dc:type>\n        Contribution in Book\/Report\/Proceedings<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/eprints.lancs.ac.uk\/2541\/1\/getPDF2.pdf<\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1109\/INFCOM.2004.1357017<\/dc:relation><dc:identifier>\n        Mathy, Laurent M. J. and Blundell, Nick and Roca, Vincent and El-Sayed, Ayman (2004) Impact of simple cheating in application-level multicast. In: INFOCOM 2004. Twenty-third Annual Joint Conference of the IEEE Computer and Communications Societies. , 1318- 1328.<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/2541\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1109\/INFCOM.2004.1357017","http:\/\/eprints.lancs.ac.uk\/2541\/"],"year":2004,"topics":["QA75 Electronic computers. Computer science"],"subject":["Contribution in Book\/Report\/Proceedings","NonPeerReviewed"],"fullText":"Impact of Simple Cheating \nin Application-Level Multicast \nLaurent Mathy Nick Blundell Vincent Roca Ayinan El-Sayed \nComputing Deparunent Plan& Project \nLancaster University. UK INRIA Rhones-Aples, France \n{laurent. n.blundell}~comp.lancs.ac.uk {vincent.roca. ayman.elsayed}Binrialpes.fr \nAbstract-We study the inipaet of cheating nodes in \napplication-level niulticast overlay trees. We focus on selfish \nnodes acting independently. cheating ahout their distance mea- \nsurements during the control phase huilding or maintaining the \ntree. More precisely, we study, through simulations, the impact \nof simple cheating strategies in four protocols. representatives of \ndifferent application-level multicast protoml \u201cfaniilies\u201d: HBM (a \nprotoeol hased on a centralized approach), TBCP (a distributed, \ntree fin1 protncnl), NICE (a distrihuted. tree first protocol hased \non clustering) and NARADA (a mesh first protocol). We evaluate \nthe impact of cheats on the performance of the overlay trees as \nperceived hy their nodes and the underlying network. \nI .  INTRODUCTION \nApplication-level multicast [7]. a technique whereby hosts \nor end-nodes are organized into an overlay distribution tree \nwithout requiring any specific support from the network (i.e. \nhased on normal unicast routing and forwarding). has been \nproposed mainly as a way to palliate to the lack of deployment \nof native IP multicast in production networks [GI. Application- \nlevel multicast represents a trade-off between the efficiency of \n1P multicast and the ease o f  deployment of group cornmunica- \ntions as a single source replicating the data sequentially, using \nunicast. to a group of receivers. \nAlthough there is no question about the superiority of IP \nmulticast for data distribution to large groups. application- \nlevel multicast may still prove a cheaper solution for com- \nmunications within small groups (groups whose membership \nis in the order of tens of receivers). Also. some systems and \napplications need to establish relations and communications \nrequiring a semantics richer than that provided by IP. Levels \nof control of the communication patterns and reliability of \nthe communication structure may be needed, that cannot be \nprovided by IP multicast. For example. because the group \nmembers are the nodes of the overlay application-level multi- \ncast tree. these nodes can interpret and modify the distributed \ncontent \u201cen route\u201d. something not possible in native multicast \nwhere application nodes are always leaf nodes of the tree. \nFor these reasons. we believe that application-level multicast \nis complementary to IP multicast and will remain a useful \ngroup communication tool if and when IP multicast is de- \nployed ubiquitously. \nApplication-level multicast is based on the collaboration of \ng o u p  members with each other. Indeed. as group members \n(i.e. receivers) are the nodes of the overlay tree. they rely on \neach other to distribute the data. However, there is an intrinsic \nimbalance of roles in an overlay tree: non-leaf nodes must \ntake part in the burden of replicating data along the tree. while \nnodes which are. on the uee, closer to the source (the source \nis often the root of the tree) observe lower propagation delays. \nAlso, the closer to the source a node is. the lower the loss rate \nobserved (since in normal data transfer from root to leafnodes. \nlosses \u201caccumulate\u201d as data travels down the tree branches). \nThe collaboration is also extended to the control of the overlay \ntree which is often built based on distance measurements \ntaken by the receivers amongst themselves. Whether a full \nmeasurement matrix is required prior to the construction of the \ntree. or the matrix can be populated overtime while improving \nthe tree. or partial group and measurement knowledge is \nenough. is entirely dependent on the protocol used. As a rule \nof thumb. the better the knowledge of the group membership \nand distances between members. the better the performance of \nthe tree can be tuned. but the least scalable the corresponding \napplication-level multicast protocol is. \nThe important point here is that lhere is an opportunity for \nreceivers to try and improve their position on the overlay \nuee by \u201cmanipulating\u201d distance measurements. in order to \nbe positioned closer to the data source while limiting, to a \nminimum. their replication burden. In the rest of the paper. we \nwill refer to such receivers as \u201ccheats\u201d. and the consequences \nof their actions is the focus of this paper. \nIf we consider the very popular round-trip time ( R l T )  dis- \ntance measurements used in many application-level multicast \nprotocols. a cheat could delay a probe received from another \nreceiver to artificially increase their measured distance in order \nto try and reduce its replication burden (since the further \naway another receiver is. the more likely that receiver will be \nconnected to another (closer) node). For scalability reasons. \nmost of the existing application-level multicast protocols re- \nquire that each node measures its distance to other nudes in \nthe overlay tree and reports these distance measurements to \nother nodes and\/or uses these for decision making. A cheat \ncan therefore lie outright ahout its distance messurements. in \norder to try and improve its position in the tree. \nIt is important to note that the cheats considered in this \npaper do not attempt to disrupt the flow of data along the \noverlay tree or even to break the protocol used to build the \ntree. they simply try and improve their position in the tree. \n07803-8355-9M20.M) 02004 IEEE. 1318 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \nIn other words. we are not interested in disruptive behaviour \nsuch as denial of service: once in the tree. although the cheats \ncan keep lying about measurements. they otherwise follow all \nother protocol rules. \nIn some controlled environments. cheating is almost im- \npossible. For instance. this is the case when application-level \nmulticast is used to provide a group communication service \nin an IPSec virtual private network (VPN) environment [l]. \nHere the gateways of the various sites connected through the \nVPN are fully secured and remotely controlled by the VPN \noperator. However, such a situation belongs to a very specific \napplication domain. \nNevertheless. although the problems of cheats in \napplication-level structures (and overlay trees in particular) \nhas often been mentioned, we are not aware of any quantitative \nstudy of their effects on application-level multicast protocols. \nas well as on the underlying network. We believe that \nunderstanding such effects is critical i f  the benefits offered \nby application-level multicast are to be reaped in application \ndomains where the receivers do not pertain to the same, \ntightly controlled. administrative domain (e.g. corporation), \nas is the case in gaming. video distributioniwehcasting. etc. \nTherefore. in this paper. we will study the effects of simple \ncheating strategies on four application-level multicast proto- \ncols. These cheating strategies will he simple. but targeted to \nthe respective protocols: the cheating will he slightly different \ndepending 1x7 the protocol considered. For this reason. it  is \nimportant to note that our goal is not to compare the relative \nability of the protocols considered to deal with cheats. but \nrather we seek to extract possible common consequences \nand trends created by the presence of cheats in application- \nlevel multicast overlay trees. Also. the protocols studied in \nthis paper were chosen as being representatives o l  different \napplication-level multicat protocol \u201chmilies\u201d. and because \nsimulators were readily available for these. \nFurthermore. although there may exist more sophisticated \ncheating strategies. in this paper we deliberately look at simple \nones. where selfish cheats act independently of each other and \nmake no attempt tn evade possible detection. \nIn section 11. we brieHy review the different families of \napplication-level multicast protocols. In section 111. we de- \nscribe in more details the workings of the protocols chosen \nfor this study. and we describe the simple cheating strategies \nused. Section IV presents our simulation study. while section V \nconcludes with a summay of our observations and some \nrecommendations. \n11. APPLICATIOS-LEVEL MULTICAST \nI11 this section. we give a brief overview of  application-level \nmulticast protocol families. \nA. Cmtraliz?rl .4 lgui-irhrris \nThe ALMI protocol [IO] and HBM [I?]  are examples of a \ncentralized approach to application-level multicast. They have \na session controller node which gathers distance information \nfrom all of the group nodes and calculates the overlay tree \nwhich i t  uses to inform each node of its neighbours. \nB. Di.strihirted Algorittrms \nf )  Mex\/i-Fint A[gorif\/ inu: Narada [4] is an example of \na mesh-first application-level multicast protocol where nodes \narrange themselves into a well connected mesh on top of which \na routing protocol similar to DVMRP is run. to build per- \nsource overlay trees. The quality of the mesh. and therefore the \noverlay trees are improved incrementally over time by nodes \nadding and dropping mesh l i n b  based on a decentralised \nutility function. SCATTERCAST [ 3 ]  is another protocol taking \nthe same approach. \n2 )  i\u201d-wFirsr: The NICE [2] protocol uses hierarchical \nclustering techniques to build overlay trees whereby group \nmembers arrange themselves into clusters with nodes closest \nto themselves. \nTBCP [91 and HMTP [IS] build an overlay tree by having \nreceiver nodes recursively choose better parents to connect \nto, in a distributed fashion. These protocols are said to use \na \u201climited scope approach\u201d. because. at each step of the \nrecursion. a node only measures its distance to the children \nof its current parent. \n3) Courtlinate S\\.steriis: The protocols presented in this \nsection use the notion of coordinates in various virtual ge- \nometrical spaces. \nIn the Delaunay triangulation method [SI. each receiver \nis assigned coordinates i n  a Euclidian plane and the tree \nis computed via a distributed application of the geometric \nprocess known as Delaunay triangulation. \nApplication-level multicast based nn CAN [ l  I]  splits a \nmutli-dimensional virtual torus into adjacent regions and uses \na snrt of broadcast method to Hood a data packet to all the \nregions in a controlled way. \nFinally. SCRIBE [I31 exploits the properties of a peer-to- \npeer network system to build application-level multi \nby merging peer-to-peer \u201csearch\u201d paths to form a tree. \n111. THE PROTOCOLS IN OUR STtiDY \nIn this paper. we chose to concenuate on four protocols: \nHBM as a representative of the centralized approach: TBCP \nas a representative of distributed. tree first. limited scope \napproach: NICE as presentative of the method based on \nclustering technique d NARADA as a representative of the \nmesh-lirst approach. \nA. HBM \n1 )  Principles: In HBM. the consuuction and maintenance \nof the overlay tree is under the control of a single host. \nthe render-vous point (RP) or controller. Periodically and \nasynchronously. each group member measures its distance \nto all the others (or a subset of them) and reports these \nto the UP which thus knows the identity of each group \nmember and the communication costs between them. The UP \nis then responsible for the overlay topology calculation and its \ndissemination among the group members. \nAlthough HBM is a general protocol that does not restrict \nthe properties of its overlay topology. the topology used in \n~7803-8355-9\/04\/s20.00 2004 IEEE. 1319 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \nthis study is a degree-bounded shared tree of minimum cost. \nbased on RTT distance metrics. \n2 )  Simple Cheating ibfethod: An HBM cheat always reports \na distance of zero to the source. and adds I O  seconds to the \nKIT distances it measured to the rest of the group. An HBM \ncheat also delays by I O  seconds any measurement probes it \nreceives from any other group member. This probe delaying \naction is mandatory since otherwise the RP could easily \ndetect cheats hy comparing the A B and B - A RTT \nmensurements. I f  they differ significantly. the RP could easily \nconclude that one of A and B has a suspect behaviour. Then. \nafter cross-checking with other metrics evaluations where A \nand B are implicated. the RP could easily determine which \nnode is cheating. \nA cheat is thus aiming to become one of the source\u2019s \nchildren. while having no children at all. \nR. TBCP \n1) Principles: In TBCP. each node chooses individually \nthe maximum iiumber of children (i.e. the fanout) that i t  will \naccept. This fanout is strictly enforced and must have a value \nof at least one. TBCP has been designed to operate with \nminimum knowledge of the group memhership and. associated \nmeasurement matrix. It is a recursive algorithm where. starting \nat the tree root (which is considered to be the source) as a \npotential parent. a newcomer measures the distance between \nitself and the potential parcnt. along with the distance between \nitself and all ~i its poirntial siblitigs (i.e. the potential parent\u2019s \ncurrent children). These distaiices are reported to the potential \nparent who. thanks to-the rncasurcrnciits prcviously reported \nhy.its existing children. has coinplcic knowledge nf the mea- \nstuement matrix for the \u201clocal\u201d full mcsh comprising itself. its \nchildren and the newcomer. The poientiul parcm then considers \nall the local contigurations for the acceptance of the newcomer \nin the tree (i.e. con\u2019siders the newcomer as a child i f  there \nis room. considers sending the newcomer as a child of one \nof its current children. considers keeping the newcomer as a \nchild while sending one of its existing children as a child \nof the newcomer. and considers keeping the newcomer as \nchild while sending one of its existing children as a child \nof one of its existing children). evaluating the \u201cgoodness\u201d \nof each local configuration with a score function. The best \nlocal configuration (according to the score function) is chosen \nand the appropriate node directed to its \u201cnext\u201d potential \nparcnt where the algorithm starts again. It is important to \nnote that when choosing amongst several equivalent local \nconfigurations. TBCP always favours those resulting in the \nnewcomer \u201cmoving\u201d. to provide stability for already joined \nreceivers. \nTBCP has a maintenance method where nodes periodically \n%-join\u201d one of its known ancestors chosen at random. but \nfor the purpose of this study. all nodes will always \u201cre-join\u201d \nat the root, as we expect this to be the behaviour chosen by a \ncheat who is trying to get as close as possible to the root. \n2) Sbnple Cllearing Mrfliod; A TBCP cheat will always \nreport a distance of zero to its potential parent. As all receivers \nstart joining the tree at the root. this provides the cheats with \nan opportunity to try and stay as close as possible to the root. \nBecause cheats want to minimize the work they do for the \nrest of the group. a cheat will choose the minimum allowed \nfanout value (i.e. I) .  However, to try and avoid having a child, \ncheats also lie about their distance to other receivers: a cheat \nalways delays a received probe by a tixed amount of time (10 \nseconds) and always adds a fixed amount of time ( I O  seconds) \nto the distance it reports from other receivers. \nC. NICE \n1 )  Principlrs: In NICE. nodes arrange themselves into a \nhierarchy of clusters whereby clusters belong to layers and \nnodes belonging to a cluster are close to each other in relation \nto some given cost metric[2]. At the highest layer of the \nhierarchy is a single cluster whose cluster members are each \nthe leader of a single cluster in each of the subsequent lower \nlayers. All nodes belong to a cluster in the lowest layer of the \nhierarchy but cluster leaders are also members of a cluster in \ntheir next-higher layer. \nA node joins the group by first contacting a Rendez-vous \nPoint (RP) to discover members belonging to the highest-layer \ncluster. The joining node then probes each of these cluster \nmembers to discover the closest to itself with whom it  makes \na request to join. The closest. highest-layer cluster memher \nreplies to- the joining node with a list of cluster members in \nthe next-lower layer to who it is the cluster leader. The joining \nnode then probes each of the cluster members in the next- \nlower layer and the algorithm continues recursively until the \nnew node joins the cluster closest to itself in the Iowcst-layer \nof the hierarchy. \nMembers of a cluster periodically exchange heo~-rDeor mes- \nsages with each other containing an estimate of the distance \nfrom themselves to each of the other cluster members. When- \never membership of a cluster changes (i.e. if a new node joins \nor leaves) the cluster leader. using this cluster member distance \ninformation. checks if it is still the center of the cluster and \nthus the most appropriate leader. transferring leadership to \nanother cluster member if necessary. \nThe cluster leader periodically checks the size of its cluster \nand splits the cluster if its membership exceeds an upper \nbound. Likewise, if the cluster size falls below a lower bound \nthe leader merges its cluster with the closest cluster belonging \nto the next-higher layer. \n2 )  Simple Clleafing Method: A NICE cheat sets out to join \na cluster in the highest layer possible in order to minimise its \ndistance to the data source. Note that. although NICE supports \nany-source. application-level multicast routing through a bi- \ndirectional overlay tree. in this study we consider only the \noptimal case o f a  single source at the root. For a cheat to join a \ncluster in the next-higher layer it must become the leader of its \nhighest-layer cluster and so tries to achieve leadership through \nquoting. in its heartbeat messages. only a fraction of the actual \ndistances to the other cluster members. On recalculating which \nnode is closest to all of the other nodes the current cluster \n0-7803-8355-9\/M\/S20.M) 02004 IEEE. 1320 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \nleader will likely transfer its leadership to the cheat which. in \neffect. geu: pushed up to the next-higher layer. \nOnce a cheat has gained leadership of a cluster it will make \nsure never to  transfer leadership from itself to any other cluster \nmembers, by reporting a distance of zero to all other cluster \nmembers in its regular heartheat messages. \nIn an attempt to preserve its resources, a cheat will never \nmerge its clusters in the lower layers if their size falls below \na lower bound and will also delay cluster join requests from \nother nodes by I O  seconds to reduce the likelihood of these \njoining the clusters. Note that. whilst a cheat will try to avoid \nhaving large clusters in all of the layers it occupies. the cheat \nwill be required to forward d S a  to members of its clusters in \neach of the lower layers which could potentially result in a \nhigh node ianout inr the cheat as described in [2]'. \nD. NARADA \nI )  Principles: Narada is a mesh-first. application-level mul- \nticast protocol whereby nodes organise themselves into a well \nconnected mesh through the addition of links to other group \nmembers. termed their 1nesh-ne~phhoitrs[4]. Nodes exchange \nrouting tables with their rseslt-nrighboirrs allowing per-source \ndata delivery trees to be constructed on the mesh using well- \nknown reverse-shortest-path routing techniques as in DVMRP \n[SI. Narada therefore supports multi-source. application-level \nmulticast but group size is limited by the need ior nodes to \nhave complete knowledge of all other group members. \nOn joining the mesh. a node selects. at random. a hand- \n%I of nodes to add as niesh-neighboitrs from il subset o i  \ncurrently active mesh members obtained using some out-of- \nband bootstrap mechanism. As a result of adding these random \nmesh links. the recently,joined node's position in the mesh is \nlikely to he suh-optimal in rclation to the given cost metric. \nHowever. once connected a node is able to improve its position \nin the mesh by periodically pr'obing random members. learned \nof through gossipping membership update messages with its \nrriesh-neiphborrrs. When a node is probed. i t  returns a copy of \nits routing table to the probing node who then calculates the \nutility of adding a mesh link to the probed node. A mesh link \nis deemed to he good if it improves the cost of a number of \npaths in the probing node's routing table such that the number \nof improved paths is greater than some threshold parameter. \nIn order for nodes to keep adding better mesh links. it is \nnecessary for them to 'drop' their least useful links. where use- \nhlness when considering to drop a mesh link is approximated \nby how many other members can he reached on shortest-paths \nthrough the mesh link. \nConsequently. the overall mesh quality imprnves over time \nwith respect to the given cost metric. resulting in more efficient \ndata routing paths on the per-source overbay trees. \n2 )  Sirrrple Clieuting Merhofl: On discovering the identity \nof a data source in the mesh. through either receiving a data \npacket or through out-of-band mechanisms. a Narada cheat \n'Note that. in this study we do not consider thz NICE prolocot exlention \nwhcrchy cluslsr lender's delqate somz of lhcir data forwarding rzsponrihility \nto their highest~layzr clusldr members. \nwill set out to add the source as a mesli-neiphboirr and so \nreceive dara directly from the source. \nHowever. to reduce the likelihood o f a  cheat being dropped \nas a mesh-neiphhorrr to the source when the source eventually \ndiscovers that i t  is not very useful. a cheat makes sure to \nestablish at least one mesh link to another node through which. \nby lying to the source about the cost of shortest-paths in \nrouting update messages. it misleads the source to believe \nthat i t  can deliver data to all of the other group members \nat a fraction of the actual costs (this is achieved by the cheat \nreporting route costs to other nodes that are a small fraction \nof their actual values). Once attached to the source. a cheat \nis likely to be dropped by its other rriesh-neighboiirs and so \nin the same way. as with the source. misleads them as to its \nbenefit for reaching other members of the group. \nNarada is susceptible to partitioning when the degree of \nmesh nodes is small. so in order not to break the protocol \nwhilst preserving resources, a cheat maintains three mesh links \nand no more (by setting its maximum out-degree - fanout - \nto the appropriate value). \nIV. EFFECTS OF CHEATING I N  APPLICATION-LEVEL \nMULTICAST \nA.  Peiforrrinncr hidiccrtors \nSeveral indicators are widely used to evaluate the per- \nformance of application-level multicast protocols. Two such \nclassical performance indicators are the link sri-ess and the \n.streri.li. \nThe link stress (or stress. in short) is a measure of the \nnetwork efficiency of the application-level multicast protocols \nand is defined as the number of redundant copies of a data \npacket carried on a network link. The maximum stress is \ntherefore the maximum number of duplicates seen by any \nsingle network link. while the average suess is the sum of \nduplicates divided by the total number of network links making \nup the branches of the tree. A ma.ior goal of all applicalion- \nlevel multicast protocols is. of course, to keep the value \nof these stress indicators as small as possible. since higher \nnetwork suess levels (especially maximum stress) indicate \nhipher risks of network congestion. \nThe stretch. or relative delay penalty (RDP). is a measure \nof the penalty paid by a receiver for receiving data on an \napplication-level wee rather than directly from the source. \nIt is defined as the ratio 'TDjLiD. where TD is the tree \ndelay. that is the latency from the source to the receiver \nobserved along the tree; and UD is the unicast delay, that \nis the networked delay resulting from direct communication \nfrom the source to the receiver. The average stretch (over \nall the receivers) and maximum stretch (i.e. worse penalty) \naxe therefore good indicator of the tree efficiency of the \napplication-level multicast protocols. \nThe above mentioned performance indicators are used to \ncharacterize the intrinsic performace of application-level mul- \nticast protocols. However. in this paper. our focus is not on \nbenchmarking the performance of the protocols, but rather \nto study the impact of cheats on their performance. In our \n0-7803-8355-9\/04\/%20.00 02004 IEEE. 1321 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \nstudy. we therciore use the following performance indicators \nwhich are the above mentioned metrics normalized to the \nperformance of the protocol without cheat. used as a reference: \nstress-ratio = stress\/stressrer. where st,ressrer is the \ncorresponding stress observed when a11 receivers behave \nin an honest way. \nWe will be interested in the maximum stress ratio as a \n. measurement of the impact of cheats on the underlying \nphysical network. Indeed. maximum stress represents the \nhighest load created by an application-level overhy tree \non any network link. and thus the maximum stress ratio \ngives a good idea about the way risks of congestion \nevolve in the presence of cheats. Note that a stress ratio \nsmaller (resp. greater) than 1 represents an improvement \n(resp. deterioration) compared with the case without any \ncheat. . s t re tchra t io  =.stret,cti\/stretcti,,r, where 'stretch,,f is \nthe stretch of a receiver observed when-all receivers \nbehave in an honest way. Note that since the unicast delay \nis dictated by the physical topology and routing in the un- \nderlying network. i t  is independent of whether a receiver \ncheats or not, and we therefore have s t re tchrat io  = \n(TD\/UD)\/(TD,,r\/IJD,,r) = TD\/TD,,r. since UD = \nTo have a hetter view of the inhence  of cheating in \napplication-level multicast: we will segregate the re- \nceivers in a group of cheats and a group of honest \nreceivers. and measure average. minimum and maximum \n-stretch ratios in each group. This will allow us to not only \nstudy the impact of cheats on the performance observed \nby honest nodes. but also study the effects independent, \nselfish cheats have on each others. Note that as the overall \ngoal is always to try and minimize stretch. a stretch ratio \nsmaller (resp. greater) than I represents an improvement \n(resp. a deterioration). with a minimum ratio therefore \nrepresenting the best improvement and a maximum ratio \nrepresenting the worst deterioration. \n'JDref. \nB. Siinirlation Setup \nWe.have studied the effects of cheats in application-level \nmulticast on an Internet topology of 600 routers generated \nby GT-ITM [14]. We have tested 25 groups of 20 receivers \nand 25 groups of 100 receivers. Each group was tried with \nrespectively 5%. 10%. 20% 30%. 40%. 50%. 75% and 100% \nof cheating receivers. It is worth noting that all the protocols \nwere studied with the same groups and the same cheats within \nthese groups. while nodes hosting application-level multicast \nagents were always connected to edge routers ofthe topology'. \nto achieve a realistic set-up. Trees of maximum fanout of 2, \n3. 4 and 5 were built for each of these groups3. \n'For ssch trial. the total number of simulated nodes was therefore either \n621 or 701. comprising the rmters. the source and ths rzccivsrs. \n'More precisely, the parametdr controlling the maxlmum numbdr of chil- \ndren was set to these values. It  is imponant to note that some protocols. NICE \nin particular in our study. do not enforce the fanout value at all times. but \nrather use it as a taqct  value for stable trees. \nFor protocols that improve the quality of their overlay trees \nover time (e.g. NARADA and NICE), simulations run for 1000 \nseconds in order to ensure stabilisation of these trees. \nAs a comparison point. beside the case where the protocols \nwere run with all receivers hehaving in an honest way. we also \nh i l t  random trees for each of the groups, where the receivers \njoined in random order and simply randomly connected to one \nof the nodes in the tree (i.e. the source or an already existing \nreceiver), whose maximum fanout had not been attained yet. \nThese random trees are used as representatives of \"bad' \napplication-level multicast trees. \nThe cheating techniques described in section 111 were imple- \nmented in the HBM simulator that was used in [12], the TBCP \nsimulator used in [91, and the NAKADANICE simulator' used \nin [?I. \nC. Network Stress Ratios \nWe study the stress ratio in order to assess the overall \nimpact of cheats in application-level multicast on the network. \nFigures 1 to 4 depict the maximum stress ratio ohserved during \nthe simulations \n501ch_, \nFig. 1. Maximum link strzss mt ia  in HBM \nn \n0-7803-8355-9\/04\/$20.00 82004 EEE. 1322 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \n-I \n5011hPI. \nFig. 4. .Maximum link st re^^ m t m ~  in NARADA \nWe see that the effects of cheats are quite different in the \nvarious protocols. In HBM (figure 1)  the maximum stress \nratio progressively increases with the percentage of cheats \nbecause the centralized algorithm creates a shared tree using a \ndistance database that is less and less related to the reality. As \na consequence the resulting overlay topology is less and less \nefficient. However. we also observe that the maximum link \nstress ratio is hetter when most or all of the receivers cheat \nthan when the cheats are in smaller numbers. This is because \nof the complete distance knowledge at the RP: when most of \nthe receivers cheat. the vast majority of distances advertised to \nthe RP are merely the real values shifted by a constant (except \nof course for the distances to the source which are advertised \nas zero. and therefore introduce some degree of randomness at \nthe top of the tree). We have also observed that HBM almost \nalways produces an overlay tree whose maximum stress is \nsmaller than that of a random overlay tree. This is again due \nto the fact that HBM always strives to make the best usage \nout of its complete distance knowledge. \nTBCP (figure 2) shows a smaller maximum stress ratio. that \nis somewhat independent of the group size and the number \nof cheats. This is explained hy the facts that, in TBCP. the \ncheats have the luxury to ensure their own maximum fanout \nis reduced to 1. thus shifting the stress from the edge of the \nnetwork (i.e. access links) towards link? inside the network. \nas the tree growths in \"lengrh\" (with long branches of cheats \ndangling from the root) rather than in \"width\". In other words. \nin TBCP. the effects of cheats is to shuttle data packets several \ntimes across the network, while cheats do the minimum data \nreplication they can. \nBecause ofthe way TBCP overlay trees grow in \"length' in \nthe presence of cheats. the maximum stress ratio was always \nworse for random overlay trees than for TBCl? This is because \nrandom overlay trees tend to concentrate mnre traffc towards \nthe edge of the network (as receivers limit their fanout to the \nsame value as honest receivers in TBCP - and random trees \ntherefore grow \"wider\" than TBCP trees with cheats). while \nstill producing the shuttling effects of data packets across the \nnetwork. \nIn NICE (figure 3). the situation is opposed to the one \nobserved for TBCP. Indeed. NICE does not strictly enforce its \nfanout at all times (see section In-C.1) and therefore allows \nclusters to form whose membership is greater than dictated by \nthe fanout value (in particular near the tree root). resulting in \nsome cluster heads serving more children than \"they should\". \nAs a result. we see that for small groups. the maximum stress \nratio is small as most cheats would have occupied a position \nclose to the root if they had not cheated anyway. thus resulting \nin an overlay tree very similar to a tree of honest receivers. For \nlarger groups. the maximum stress ratios can show the greatest \nvalues we observed. hecause cheats creilte large clusters near \nthe root. thus increasing the stress on the access links of \nnodes near the top of the overlay tree (including the root). \nWe therefore see that NICE has actually a tendency to grow \nits overlay \"too wide\". \nNo surprisingly. the maximum stress ratio was almost \nalways better for random trees than for NICE. hecause the \nfanout is strictly enforced in the random trees. \nIn NARADA (figure 4). we make the interesting observation \nthat fewer cheats have a greater effect on the network effi- \nciency of the protocol than when cheats are present in larger \nnumbers. This is because the more cheats are present. the \nfewer the opportunities that exist for a cheat to create \"forced\" \nmesh links to nodes near the source. as the utility (see section \nlI1-D.1) associated with each cheat decreases. This decrease \nin utility is caused by the fact that. as the number of cheats \nincreases. honest receivers and cheats alike are fooled into \nthinking that they are close to more and more members of the \ngroup. in essence choosing cheats as mesh-neighbours with \nequal prohahility. In other words. through the combination \nof enforcing a strict degree for all nodes in the mesh and \nthe use of the notion of utility for the construction of the \noverlay tree. NARADA forces the cheats to share the profits \nof cheating. As a result. hecause cheats also report distances \nto other receivers as a fraction of the real values (this strategy \nis actually chosen to \"beat\" the utility function (see section \nIll-D.2). the more cheats in the group. the more NARADA \nbrings the mesh \"back\" to what it is when all receivers are \nhonest (to the exception of the \"lucky\" cheats who connect \ndirectly to the root). This behaviour. although also observed \n0-7803-8355-9\/Cl4\/$20.00 2004 IEEE. 1323 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \nin HHM. is much more prominent with NARADA. \nFigure 4 also shows that NAKADA just does not cope \nvery well with srnall tree fanout (or mesh degree) values, as \nreported in L41. \nNot surprisingly given &e discussion above. we found \nthat NARADA produces stress ratios that a e  w m e  than \nthose produced by a random overlay tree. when there is a \nsmall number of cheats. However. as the number of cheats \nincreases. NARADA outperforms random trees as far as stress \nis concerned. \nI). S1rm.h Rotios \nThere are basically two ways to grow an overlay tree: in \nlength and in width. Growing an overlay tree in length results \nin lower network stress levels at the expense of higher stretch \nlevels (as receivers are pushed away from the sourcelroot and \nthereiore observe longer delays along the tree). The opposite \nholds true for an overlay tree grown in width. Therefore. when \nconsidering average stretch levels over all receivers in the tree. \nwe would observe that the application-level protocols that were \nshowing the smaller stress ratios show the higher stretch ratios. \nand vice versa. To have a better understanding of-the effects \nof cheats on the stretch levels of receivers in an application- \nlevel overlay uee. we will therefore focus separately on the \ne k t s  of cheats on hiinest receivers and amongst the cheats \nthemselves. \nFigures 5 to  8 shr)w llic a\\'erage stretch ratio for honest \nreceivers i n  the presence iir clicii~s. \n, w.. \nI \n%echm, ,  \nFip. 5. Awmps stretch ratios far honzst receivers in HBM \nWe see that in I-IBM (figure 5). the average stretch ratio \nfor honest receivers rapidly increases. even with a small \npercenuge of cheats. This is due to the fact that honest \nreceivers are immediately moved away from the source. and \nthis is particularly uue with trees having a small fanout. We \nalso ohserve that the average stretch ratio for honest receivers \ntend to stabilize as the number of cheats increases. because. \nas explained in section IV-C_ the more cheats are present. \nthe more accurate the RP's neighbour selection becomes (and \ntherefore honest receivers end up in the \"correct\" pan of the \ntree). \nFig. 6. Aversoe stretch ratios for honest recei\\:ccs in TBCP \nFio. 7. Avzrapc stretch ratios for honest rccerrcct in SICE \nWe see that in TBCP (figure 6) .  the average stretch ratio for \nhonest receivers increases steadily. with the rate of increase \nproportional to the group size. This is because. as cheats \noccupy higher positions in the overlay tree. the remaining \nhonest receivers get pushed towards the bottom of the tree \nand thus see an increasing stretch. Also note that even a \nsmall increase in stretch, when more cheats (with a fanout \nof I) are added. can result in a more substantial increase in \naverage stretch ratio for honest receivers. as this number of \nhonest receivers decreases steadily (i.e. the increase in stretch \nis shared amongst fewer honest receivers). \nExpectedly. NICE (figure 7) shows little average stretch \nratio for honest receivers. almost independently of the group \nsize. This is again due to the fact that. during normal op- \nerations of the protocol. clusters are allowed to grow bigger \nthan dictated by the maximum fanout. leaving more unaffected \nhonest receivers by the presence of cheats than in  the other \nprotocols. \nIn NARADA (figure S). we see that the effects of cheats \non the stretch of honest receivers stabilizes as the number of \ncheats increases. especially in small groups. This is because. \nas explained in section IV-C. NARADA operates in such a \nway that the actions of individual cheats tend to balance each \nother as the number of cheats increases. This effect is less \n0-7803-8355-9\/04\/S20.00 2.2004 IEEE. 1324 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \n\\\u201clrhll \nFig. 8. Average slrctch ratios for honest receivers in NARADA \nnoticeable for larger groups. though. as the overlay tree gets \nlonger. and thus the effkcts on the stretch (of honest receivers) \naccumulate faster. \nFigures 9 to 12 show the average ratio in stretch for the \ncheats themselves. \nXI (I, a) 70.  \nlidChU. \nFig. 9. Auerase stretch ratios for cheats in HBM \nIn all the protocols. we see a decrease in average stretch \nratios for cheats when the number of cheats are small. This \nindicates that the cheats indeed get a better position near the \nsource when cheating. However. as more and more cheats \noperate in an overlay uee. these compete with each other. and \nthe rate of increase of the average stretch ratio for cheats give \nan indication of the ferocity of the competition. \nThis is particularly visible with HBM (figure 9). Cheats \nexperience an average benefit only if  the fmout enables them \nto be close to the source. Thereafter. the situation rapidly \ndeteriorates because the additional cheats are located lower \nin the tree. beneath honest receivers. So when the number \nof cheats increases. honest receivers experience on average \na slightly better stretch ratio than cheats. Yet this average \nhides a ma,jor discrepancy between cheats who succeeded to \nbe directly attached to the source and others. \nFigure 10 shows that competition between cheats is the \nfiercest in TBCP. This is because cheats that have already \nFig. 10. Avcraec stretch ratios for chcals in  TBCP \nFig. 11. Average stretch ratios for chats in NICE \nfound a place in the tree. do not relinquish their position to \nnew cheats joining. the latter getting pushed down the tree. \nFurther more. the rate of \u201cdescent\u201d towards the bottom of the \ntree is exacerbated by the fact that cheats use a fanout of 1. \nleaving other cheats far further away from the source than in \nthe reference overlay tree where all receivers iue honest. \nThere is very little competition amongst cheats in NICE \n(figure 11) and NARADA (figure 12). NICE. however. offers \nbetter opportunities for cheats to better their positions in the \ntree. thus resulting in lower average stretch ratio values for \ncheats. \nTables I to IV. indicate when the average stretch ratios \nfor cheats become worse than in random trees. These tables \nshow that. from the point of view of cheats, the collrcrive \nbenefit of cheating always eventually disappears. leaving the \n\u201caverage\u201d cheat in a worse position than i i  the tree was \nrandom. However. this observation should be contrasted by \nthe fact that cheats are selfish and that some of the cheats \nalways see a dramatic improvement in their positions in the \noverlay trees. as illustrated in figures 13 to 16. \nThese tables show that NICE and NARADA provide more \nfavourable conditions for cheats to collectively gain an ad- \nvantage over the honest receivers. in term of suetch. Table I1 \nalso confirms that competition amongst cheats is very high \n0-7803-8355-9\/04\/$20.00 02004 BEE. 1325 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \n100 3 40 - 50 \n100 4 30 - 40 \n100 5 20 - 30 \nTABLE 111 \nNICE CHE4TS VS R.ANDOM TREE: % OF CHEATS WHEN CHEATS ARE \nBETTER OFF BEIRG IS RASOOM TREE. \nFig. 12. Average stretch ratios for cheats in NARADA \ngroup SEC fanout 7O of cheats \n20 2 40 - 50 \ngroup size fanout 9% of cheals \n20 2 20 - 30 \n20 3 30 - -10 \n20 4 30 - 40 \n20 5 40 - 50 \n100 2 5 - 1 0  \n100 3 5 - 10 \n100 4 5 - 1 0  \n100 5 5 - 10 \n. TABLEI \nHBM CHE.%TS VS R.ANDOM TREE: ?? OF CHE.\\TS WHEN CHE1TS A R E  \nBETTER OFF BEING IK R:\\SOO.M TREE. \nin TBCP as a small number of cheats makes these cheats \ncollectively better ,oii in  a random tree. \nFigures 13 to 16 show that cheating in NICE and NARADA \nis potentially very rewarding for individual cheats. while the \nbenefits of cheating for an individual are similar in HBM and \nTBCP. It should he noted that NICE gives more chances to \nmore individual cheats to improve dramatically their position \nin the tree. then any other of the protocols studied in this paper. \nFinally. for HBM. TBCP and NARADA. we have observed \nthat the maximum stretch ratio for honest receivers can be in \nthe order of several hundreds (i.e. one of the honest receivers \ngroup size fanout \"U of cheats \n20 2 10 - 30 \n20 4 '  2 0 -  30 \n20 5 40 - 50 \n100 2 0 - 5  \n100 3 5 ~ I 0  \nion 4 5 - 10 \n100 5 10 - 20 \n20 3 ' 30-40 \nTABLE I1 \nTBCP C H E h r S  VS R.ANDOM TREE: % O F C H E I T S  WHEN C H E I S  I R E  \nBETTER OFF BElSG IN RANDOM TREE. ' \n20.  4 20 - 30 \n20 5 20 - 30 \n100 2 10 - 20 \nLOO 3 10 - 20 \nIW 4 0 - 5  \n100 5 10 - 20 \nTABLE IV \nNARADA CHEATS VS RANDOM TREE: % OF CHEATS WHEN CHE.ATS .ARE \nBETTER OFF BEIUG IN R.ANDGM TREE. \nis several hundred times further away from the source than \nit was in the reference tree). These situations occur when the \nhonest receiver is actually physically close to the source and \ntherefore gets displaced relatively very Far by the cheats. The \nnoticeable exception is of course that in NICE. the honest \nreceivers are relatively undisturbed by the cheats and the \nobserved maximum stretch ratio for honest receivers are small \n(usually less than 10). \nV. DISCUSSIONS \nIn this paper. we have studied the impact of simple cheating \non the performance of application-level multicast overlay trees. \nI \na R I ,  7, 111, \nPdthlPl l  \nFig. 13. Minimum stretch ratios for cheats in HBM \n0-7803-8355-9\/@4B20.00 02004 IEEE 1326 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \nI I \nCI I)> I n ,  \n3o,cbm,* -.Olihllil \nFis. 14. Mirumum stetch ratio iw cheats in TBCP Fig. 16. Mitimum stretch ratio for chcats in NARADA \nFig. 15. .Minimum slrrrch ratio fw chcats in NICE \nWe have shown that simple cheating strategies always have \nnegative impact. either on the performance of the tree as \nperceived by its nodes (both cheats and honest receivers), or \non the underlying physical network, or on both. \nWe have also witnessed a range of responses to the cheating \nstrategies from the studied protocols. However. none of the \nstudied protocols coped well. in the presence of cheats, for \nall the performance aspects described. Actually. none of these \nprotocols were explicitly designed to deal with cheats. and all \nshowed. at various point of the study. that their performance \ncould quickly degrade to be worse than the performance \nexhibited by a random tree. \nAlthough the simple cheating techniques used in this study \nwere tailored to the specific protocols. it is worth noting that \nthey 1111 exploited the fact that the protocols relied on receivers \nto take their own distance measurements and either make \nindependent decisions based upon these measurements or ad- \nvertise these to other nodes. In the case of the distance metric \nused in this study (the RTT). detection of a cheat advertising \ndramatically reduced distances seems rather straightforward: \nthe node which the cheat claims to be close to. can always \ncheck its distance to the cheat_ with tamper-proof probes (e.g. \nprobes that do not contain any timestamp information or that \nhave undergone a cryptographic modification such as hashing). \nHowever, in order not to jeopardize scalability by increasing \nthe measurement overhead too much. such distance checks \nshould probably he carried out as a periodic sampling process \nthat eventually detects cheats. Note that such an approach is \nonly applicable for metrics whose values are independent of \nthe point of measurement (which is the case for the R T I  \nbetween two points and measured at either point. but certainly \nnot for the delay between these points). The sampling methods \nshould probably also make use of statistical methods to help \ncope with natural variations in the measured values. \nNevertheless. it is not clear at all how effective such simple \ndistance sampling methods would be in the presence of several \ncooperating cheats, since at the very least. the actual distance \nbetween these may never be reliably verified. In such a case. \ncorrelating the distance measurements taken among several \napplication-level multicast nodes may be a way ahead. but \ndoing so in a distributed fashion without requiring complete \nknowledge. at all nodes. of the group and its measurement \nmatrix is a challenging problem. \nOn the other hand. it is probably impossible to ever detect, \nor prevent. a cheat which delays measurement probes system- \natically. in order to artificially increase measured disrances. \nSuch an \"attack\" can even easily be implemented by putting a \nproxy in front of the node which desires to cheat. As a result. \ncheat detection methods may just provide a \"high-pass filter\" \non measurement matrices (i.e. a method to weed out artificially \nlow distances but not artificially high ones). We will study the \nimpact of such detection methods on the performance of the \nresulting overlay uees in the presence of cheats in our future \nwork. \nDesigning general cheat detection andlor prevention tech- \nniques for various types of metrics is. we believe. an open \nresearch challenge. Indeed. there is always the danger that \nsuch techniques be designed on an ad-hoc basis. depending \non the metric and cheating methods used, resulting in some \nkind of \"cat and mouse\" situation with cheats. \nThis paper was only concerned with selfish cheats operating \nindependently. The case of cooperating cheats. maybe using \nevolutionary cheating strategies. is an open research challenge. \n0-7803-8355-9\/04\/S20.00 Q2004 BEE. 1327 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \nAs iuture work we will also study the effects of simple \ncheating on coordinate-based methods. and the application- \nt protocols built on top of peer-to-peer systems \n(sec section 11). For such protocols. the cheats will not only \nhave the opportunity to lie about their distance to other nodes. \nhut they will also he able to carefully \"choose\" their place in \nthe corresponding virtual geometric space. \nREFERENCES \n[ I ]  1. Alchanl. V. Rwa. A. El-Snyed. and M. .Hakn .  A vQm solaion \nfor fully secure and effici6nt group communications. In  X r b  IEEE \nSymposim ON Compnlerr and c,~,~,,\",,,,;~',~;~,,~~ (ISCC'OJJ. Kmirr- \n.hrnlyn. l h r k ~ ~ . ~  June 2003. \n[2] S .  Ransrjzc. B. Rhattachxjulcc. and C. Kommarsddy. Scalable Applica- \ntion Layer Multicast. In  .ACM SIGCOMM. Aug 2002. \ncCunne. and E. Brzwer. LMX: Reliable Multican \nfor Hzterogmeous Network. In IEEE hlfucom. Mar 2000. \n[-I] Y-If. Chu: S .  R m .  and If.  Zhang. A Case for End System Multicast. In \nACM SIGMETRICS. p a p  1-11. Santa Clare. CA. USA. June 2000. \n151, S. Ikzring and D. Chcciton. Multicast Routing in Untqrnnw Intcmct- \nwork and Extended LANs. ACM Tmni. Conp. S\\Tl.. 8:85-11@. May \n19'M. \n'(61 C. Diol. R.  Lwinc. R .  Lyles. H. Kasscm. and D. Balensizfm Dr- \nployment Issuer for the 1P Multicast Service and Architccturz. IEEE \nNerwork. 1.1111:7&88. J u n k h  2000. \n171 A. El-Suycd. V. Roca. and 1. Mathy. A Survey of Propn~als for an \nAlternatiw Group Communication Service. IEEE Nrrirork. l7(11:46 \n51. Janffeh 2003. \n(81 1. Liskrherr. M. Nahas. and W. Si. Application-Layzr Multicast with \nDdaunay Tnunsulutions. In  IEEE GLOBECOM. Sou 2001. \n191 L. Mathy. R. Canonico. and D. Hutchison. An O w l a y  Trez Buildins \nControl F~oiocoI. In P m .  of \/nil. worh\/!op 011 Nerorkrd Gmup \nCommnnicnlion (NCC). pasis 7687. Nov 2001. \n[IO] D. Pendarakis. S .  Shi. D. Vsma. and 41. Waldvogcl. ALMI an \nApplication Level Multicast Intiustructuc. In  3rd USEh'lX S?ntposism \n01 Irmmel Trrlr,rologius. San Francism. CA. USA. Mar 2001 \nI111 S .  Kattnasamy. M. Handky. and S. Shcnkcr. Applirulion-Lcwl Multicast \nusing Content Addrcssshlc Networks. In Pnx. of bl l .  wurkd~op on \nNrrworked Gmiip Commio!icnrion (IVGCJ. Nov 2001. \n(121 V. Roca and A. El-Snyed. A Host-Based .Mullic3st Solution for Group \nCommunications. In IEEE bill. CUI$ Nrhrorking. Jul 2001. \n1131 A. Rowstron. A.M. Kermarrec. M. Castru. and P. Dnrcchcl. SCRIBE \nthe Design of B Larpz-Sc~la Event Notification Infrastructure. In Pmc. of \nI n d  workrlmp on Nrrworkrd Grmp Conearr,zicalion (NGC). Nov 2W 1. \n11.11 E. %gura. K. Calvan. and S .  Bhuttachwjcc. How to M a l 4  an \nIntzmstwork. In IEEE Infocorn. pages J&5?. Mar 1996. \n[I51 B. Zhani. S .  Jamin. and L. Zhnng. H a t  Multicast: a Framework for \nklivcring Multicast to End Users. lo IEEE Iilfi,com. Jun 2002. \n0-7803-8355-9\/04\/$20.00 C~2.2004 IEEE. 1328 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on February 8, 2010 at 05:14 from IEEE Xplore.  Restrictions apply. \n"}