{"doi":"10.1007\/978-3-540-88194-0_10","coreId":"65305","oai":"oai:dro.dur.ac.uk.OAI2:6244","identifiers":["oai:dro.dur.ac.uk.OAI2:6244","10.1007\/978-3-540-88194-0_10"],"title":"A formal soundness proof of region-based memory management for object-oriented paradigm.","authors":["Craciun, F.","Qin, S.","Chin, W.-N."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Liu, S.","Maibaum, T.","Araki, K."],"datePublished":"2008-10-01","abstract":"Region-based memory management has been proposed as a viable alternative to garbage collection for real-time applications and embedded software. In our previous work we have developed a region type inference algorithm that provides an automatic compile-time region-based memory management for object-oriented paradigm. In this work we present a formal soundness proof of the region type system that is the target of our region inference. More precisely, we prove that the object-oriented programs accepted by our region type system achieve region-based memory management in a safe way. That means, the regions follow a stack-of-regions discipline and regions deallocation never create dangling references in the store and on the program stack. Our contribution is to provide a simple syntactic proof that is based on induction and follows the standard steps of a type safety proof. In contrast the previous safety proofs provided for other region type systems employ quite elaborate techniques","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65305.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6244\/1\/6244.pdf","pdfHashValue":"5d9b5b8accb59177ddf0aa7265237031d88dde47","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6244<\/identifier><datestamp>\n      2015-03-31T11:53:41Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        A formal soundness proof of region-based memory management for object-oriented paradigm. <\/dc:title><dc:creator>\n        Craciun, F.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Chin, W.-N.<\/dc:creator><dc:description>\n        Region-based memory management has been proposed as a viable alternative to garbage collection for real-time applications and embedded software. In our previous work we have developed a region type inference algorithm that provides an automatic compile-time region-based memory management for object-oriented paradigm. In this work we present a formal soundness proof of the region type system that is the target of our region inference. More precisely, we prove that the object-oriented programs accepted by our region type system achieve region-based memory management in a safe way. That means, the regions follow a stack-of-regions discipline and regions deallocation never create dangling references in the store and on the program stack. Our contribution is to provide a simple syntactic proof that is based on induction and follows the standard steps of a type safety proof. In contrast the previous safety proofs provided for other region type systems employ quite elaborate techniques. <\/dc:description><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Liu, S. & Maibaum, T. & Araki, K. (Eds.). (2008). Formal methods and software engineering : 10th International Conference on Formal Engineering Methods, ICFEM 2008, 27-31 October 2008, Kitakyushu-City, Japan ; proceedings. Berlin: Springer, pp. 126-146, Lecture notes in computer science(5256)<\/dc:source><dc:contributor>\n        Liu, S.<\/dc:contributor><dc:contributor>\n        Maibaum, T.<\/dc:contributor><dc:contributor>\n        Araki, K.<\/dc:contributor><dc:date>\n        2008-10-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6244<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/978-3-540-88194-0_10<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6244\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/978-3-540-88194-0_10<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6244\/1\/6244.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/978-3-540-88194-0_10<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2008,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nCraciun, F. and Qin, S. and Chin, W.-N. (2008) \u2019A formal soundness proof of region-based memory\nmanagement for object-oriented paradigm.\u2019, in Formal methods and software engineering : 10th International\nConference on Formal Engineering Methods, ICFEM 2008, 27-31 October 2008, Kitakyushu-City, Japan ;\nproceedings. Berlin: Springer, pp. 126-146. Lecture notes in computer science. (5256).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/978-3-540-88194-010\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nCraciun, F. and Qin, S. and Chin, W.-N. (2008) 'A formal soundness proof of region-based \nmemory management for object-oriented paradigm.', in Formal methods and software \nengineering : 10th International Conference on Formal Engineering Methods, ICFEM 2008, \n27-31 October 2008, Kitakyushu-City, Japan ; proceedings. Berlin: Springer, pp. 126-146. \nLecture notes in computer science. (5256). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/978-3-540-88194-0_10 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nA Formal Soundness Proof of Region-based Memory\nManagement for Object-Oriented Paradigm \u22c6\nFlorin Craciun1, Shengchao Qin1, and Wei-Ngan Chin2\n1 Department of Computer Science, Durham University, UK\n{florin.craciun,shengchao.qin}@durham.ac.uk\n2 Department of Computer Science, National University of Singapore, Singapore\nchinwn@comp.nus.edu.sg\nAbstract. Region-based memory management has been proposed as a viable\nalternative to garbage collection for real-time applications and embedded soft-\nware. In our previous work we have developed a region type inference algorithm\nthat provides an automatic compile-time region-based memory management for\nobject-oriented paradigm. In this work we present a formal soundness proof of\nthe region type system that is the target of our region inference. More precisely,\nwe prove that the object-oriented programs accepted by our region type system\nachieve region-based memory management in a safe way. That means, the re-\ngions follow a stack-of-regions discipline and regions deallocation never create\ndangling references in the store and on the program stack. Our contribution is to\nprovide a simple syntactic proof that is based on induction and follows the stan-\ndard steps of a type safety proof. In contrast the previous safety proofs provided\nfor other region type systems employ quite elaborate techniques.\n1 Introduction\nModern object-oriented programming languages provide a run-time system that auto-\nmatically reclaims memory using tracing garbage collection [24]. A correct garbage\ncollector can guarantee that the memory is not collecting too early, and also that all\nmemory is eventually reclaimed if the program terminates. However the space and time\nrequirements of garbage-collected programs are very difficult to estimate in practice.\nTherefore many different solutions have been proposed for real-time applications and\nembedded software running on resource-limited platforms. These solutions either com-\npletely omit the use of garbage collectors (e.g. JavaCard platform), or use real-time\ngarbage collectors [1], or use region-based memory management (e.g. Real-Time Spec-\nification for Java (RTSJ) [3]).\nRegion-based memory management systems allocate each new object into a program-\nspecified region, with the entire set of objects in each region deallocated simultaneously\nwhen the region is deleted. Various studies have shown that region-based memory man-\nagement can provide memory management with good real-time performance. Individ-\nual object deallocation is accurate but time unpredictable, while region deletion presents\na better temporal behavior, at the cost of some space overhead. Data locality may also\n\u22c6 The work is supported in part by the EPSRC project EP\/E021948\/1.\nimprove when related objects are placed together in the same region. Classifying objects\ninto regions based on their lifetimes may deliver better memory utilization if regions are\ndeleted in a timely manner.\nThe first safe region-based memory system was introduced by Tofte and Talpin [22,\n23] for a functional language. Using a region type inference system, they have pro-\nvided an automatic static region-based memory management for Standard ML. More\nprecisely, their compiler can group heap allocations into regions and it can statically\ndetermine the program points where it is safe to deallocate the regions. Later, several\nprojects have investigated the use of region-based memory management for C-like lan-\nguages (e.g. Cyclone [13]) and object-oriented languages [9, 5]. These projects provide\nregion type checkers and require programmers to annotate their programs with region\ndeclarations. The type checkers then use these declarations to verify that well-typed\nprograms safely use the region-based memory.\nIn our previous work [8], we have developed the first automatic region type infer-\nence system for object-oriented paradigm. Our compiler automatically augments unan-\nnotated object-oriented programs with regions type declarations and inserts region allo-\ncation\/deallocation instructions that achieve a safe memory management. In this paper\nwe provide the safety proof of our region type system that is the target of our previous\nregion inference algorithm.\nBottom (oldest region)\nr2\nr4\nr3\nTop (youngest region)\nr1\npossible dangling reference \nnon\u2212dangling reference \nr0\nFig. 1. Lexically-Scoped Regions\nIn our work, we use lexically-scoped\nregions such that the memory is or-\nganised as a stack of regions, as\nillustrated in Fig. 1. Regions are\nmemory blocks that are allocated\nand deallocated by the construct\nletreg r in e, where the region\nr can only be used to allocate ob-\njects in the program e. The older re-\ngions (with longer lifetime) are allo-\ncated at the bottom of the stack while\nthe younger regions (with shorter life-\ntime) are at the top. The region life-\ntime relations are expressed using a\ntransitive outlive relation, denoted by\n\u0017. Thus, we can define the lifetime\nconstraints r0\u0017r1\u2227r1\u0017r2\u2227r2\u0017r3\u2227r3\u0017r4 on the regions of Fig. 1. Region lifetime\nconstraints (as shown in Fig. 2) are of two main forms r1\u0017r2 and r1=r2. The constraint\nr1\u0017r2 indicates that the lifetime of region r1 is not shorter than that of r2, while the\nconstraint r1=r2 denotes that r1 and r2 must be the same region. The equality can be\nexpressed as an outlive relation such that r1=r2 iff r1\u0017r2 and r2\u0017r1.\nDangling references are a safety issue for region-based memory management. Fig. 1\nshows two kinds of references: non-dangling references and possible dangling refer-\nences. Non-dangling references originate from objects placed in a younger region and\npoint to objects placed either in an older region or inside the same region. Possible dan-\ngling references occur when objects placed in an older region point to objects placed in\na younger region. They turn into dangling references when the younger region is deal-\nlocated. Using a dangling reference to access memory is unsafe because the accessed\nmemory may have been recycled to store other objects. There are two approaches to\neliminating this problem. The first approach allows the program to create dangling ref-\nerences, but uses an effect-based region type system to ensure that the program never\naccesses memory through a dangling reference [22, 23, 9, 13]. The second approach\nuses a region type system to prevent the program from creating dangling references at\nall [5]. Our work has adopted the second approach.\nContributions. The main contribution of this paper is the soundness proof of our re-\ngion type system for object-oriented paradigm. We prove that our region type system\nguarantees that well-typed programs use lexically-scoped regions and never create dan-\ngling references in the store and on the program stack. We provide a simple syntactic\nproof based on induction (rather than a more elaborate co-induction machinery), that\nfollows the standard steps of a type safety proof [25]. Our small-step dynamic seman-\ntics decomposes high-level expression letreg r in e into three intermediate opera-\ntions: allocation of region r on the stack, evaluation of program e, and deallocation of\nregion r. The difficulty is to prove that after deallocation of region r, the store, the pro-\ngram stack and the remaining code do not contain any reference to region r and to the\nobjects stored in region r. To prove that region deallocation is safe, we use the region\nconstraints of our type system and a syntactic condition that we imposed to restrict the\nvalid intermediate code. However our syntactic restriction does not restrict high-level\nsource code, it only defines the correct intermediate code to which high-level code can\nbe evaluated.\nRelated Work. In the original effect-based region type system, Tofte and Talpin [23,\n21, 2] and later Christiansen and Velschow [9], in their region calculus for object-\noriented languages make use of co-induction to prove the soundness. Their proof re-\nquires co-induction partly because they prove two properties at the same time: type\nsoundness and translation soundness. The latter property guarantees that there exists\na semantic relation between source program and its region-annotated counterpart. Our\nsafety theorems are only focused on the problem of type soundness, thus are simpler to\nprove. A co-inductive definition is required in their proof also because they use a big-\nstep semantics where certain information is lost when deleting a region from the store,\nas discussed in [15, 7]. Our system uses a small-step operational semantics instrumented\nwith regions which makes the consistency definition and the proof easier. Calcagno [6]\nuses a stratified operational semantics to avoid co-induction in the proof of safety prop-\nerties of a simple version of Tofte and Talpin\u2019s region calculus, while Helsen et al. [15,\n14] introduces a special constant for defunct regions in their big-step semantics which\nmakes the soundness proof simpler. A similar proof with ours is the safety proof of\nNiss [19], that in addition to a simple functional language handles an imperative calcu-\nlus, and like our proof avoids explicit co-induction by using store typing. Cyclone [13]\nalso has an effect system used for a soundness proof and does not use co-induction. Els-\nman [12] refines Tofte and Talpin\u2019s region type system in order to forbid the dangling\nreferences and proves by induction the safety for a small functional language. There\nare many differences between his proof and ours. His proof is based on a small-step\ncontextual semantics [17], while in our proof we explicitly model the heap as a stack of\nt ::= cn\u3008r+\u3009 | prim\u3008\u3009 | \u22a5 (region types)\nprim ::= int | boolean | void\n\u03d5 ::= r1 \u0017 r2 | r1 = r2 | true | \u03d51 \u2227 \u03d52 (region constraints)\nP ::= def\u2217 (region annotated program)\ndef ::= class cn1\u3008r+\u3009 extends cn2\u3008r+\u3009 where \u03d5\n{(t f)\u2217 meth\u2217} (region annotated class declaration)\nmeth ::= t mn\u3008r\u2217\u3009((t v)\u2217) where \u03d5 {e} (region annotated method)\ne ::= null | k | v | v.f | v = e | v.f = e (region annotated expression)\n| e1 ; e2 | {(t v) e} | new cn\u3008r+\u3009(v\u2217)\n| v.mn\u3008r\u2217\u3009(v\u2217) | if v then e1 else e2 | while v e\n| letreg r in e (region declaration)\ncn \u2208 class names r \u2208 region variable names\nmn \u2208 method names k \u2208 integer or boolean constants\nf \u2208 field names v \u2208 variable names\nFig. 2. The Syntax of Region-Annotated Core-Java\nregions and we use a consistency relation between the static and dynamic semantics. In\naddition Elsman uses a syntax-directed containment relation to express the regions of\nthe program values and also to force the stack discipline for regions\u2019allocation and deal-\nlocation. In our case the region requirements and the order among regions are expressed\nby the region constraints of the type system. However we also impose a syntactic con-\ndition to restrict the valid intermediate (non-source) programs. Boudol [4] refines Tofte\nand Talpin\u2019s region calculus to a flow-sensitive effect-based region type system, that\nexplicitly records the deallocations effects. He provides a simple proof for a functional\nlanguage by means of a subject reduction property up to simulation. Although his sim-\nulation is half-bisimulation, his proof does not employ co-induction. In contrast our\nregion type system is a flow-insensitive calculus. However our syntactic restriction on\nintermediate code has a similar role as the flow-sensitive deallocation effect. Our type\nsystem is similar to SafeJava\u2019s type system of Boyapati et al. [5], but in addition we sup-\nport the region subtyping principle [13]. However SafeJava does not provide a formal\nproof for its region type system.\nOutline. The paper is organized as follows. Section 2 introduces the syntax of our re-\ngion calculus. Section 3 presents our region type system, while Section 4 defines the\ndynamic semantics of our region calculus. Section 5 extends the static semantics to in-\ntermediate expressions, while Section 6 presents the soundness theorems. A brief con-\nclusion is given. The technical report [11] contains the details of our inductive proofs.\n2 Region Calculus\nOur region calculus is designed by annotating with regions a Java-like object-oriented\nlanguage, named Core-Java [10]. The full syntax of the region-annotated Core-Java\nlanguage is given in Fig. 2. Core-Java is designed in the same minimalist spirit as the\npure functional calculus Featherweight Java [16]. Despite its expression-oriented syn-\ntax, Core-Java supports imperative features.\nEach class definition is parameterized with one or more regions to form a region\ntype. For instance, a region type cn\u3008r1, ..., rn\u3009 is a class name cn annotated with region\nparameters r1...rn. Parameterization allows us to obtain a region-polymorphic type for\neach class whose fields can be allocated in different regions. The first region parameter\nr1 is special: it refers to the region in which the instance object of this class is allocated.\nThe fields of the objects, if any, are allocated in the other regions r2...rn which should\noutlive the region of the object. This is expressed by the constraint \u2227n\ni=2\n(ri \u0017 r1), which\ncaptures the property that the regions of the fields (in r2...rn) should have lifetimes no\nshorter than the lifetime of the region (namely r1) of the object that refers to them. This\ncondition, called no-dangling requirement, prevents dangling references completely, as\nit guarantees that each object never references another object in a younger region. In\ngeneral the class invariant, \u03d5, of a class consists of the no-dangling requirement for\nthe region type of the current class, the no-dangling requirements for the fields\u2019 region\ntypes, and the class invariant of the parent class We do not require region parameters\nfor primitive types, since primitive values can be copied and stored directly on the stack\nor they are part of an object. In order to keep the same notation, we use prim\u3008\u3009 to denote\na region annotated primitive type. Although null values are of object type, they are\nregarded as primitive values. The type of a null value is denoted by \u22a5.\n[RegSub]\n\u03d5=(x1\u0017x\u02c61) \u2227\n\u2227n\ni=2(xi=x\u02c6i)\n\u22a2cn\u3008x1..n\u3009<:cn\u3008x\u02c61..n\u3009, \u03d5\n[SubClass]\nclass cn\u3008r1..n\u3009 extends cn\u2032\u3008r1..m\u3009.. \u2208 P\u2032\nn\u2265m\u2265p \u22a2 cn\u2032\u3008x1..m\u3009<:cn\n\u2032\u2032\u3008x\u20321..p\u3009, \u03d5\n\u22a2 cn\u3008x1..n\u3009<:cn\u2032\u2032\u3008x\u20321..p\u3009, \u03d5\n[Null]\n\u22a2 \u22a5<:cn\u3008x1..n\u3009, true\nFig. 3. Region Subtyping Rules\nThe region subtyping principle allows\nan object from a region with longer life-\ntime to be assigned to a location where a\nregion with a shorter lifetime is expected.\nThis principle is illustrated by the subtyp-\ning rule [RegSub] of Fig. 3. This rule relies\non the fact that once an object is allocated\nin a particular region, it stays within the\nsame region and never migrates to another\nregion. This property allows us to apply co-\nvariant subtyping to the region of the cur-\nrent object. However, the object fields are\nmutable (in general) and must therefore use\ninvariant subtyping to ensure the soundness\nof subsumption. The other two rules, [SubClass] and [Null] from Fig. 3 denote the class\nsubtyping and the fact that a null value can be assigned to any object, respectively.\nEvery method is decorated with zero or more region parameters; these parameters\ncapture the regions used by each method\u2019s parameters (including this) and result. For\nsimplicity, no other externally defined regions are made available for a method. Thus,\nall regions used in a method either are mapped to these region parameters or are lo-\ncalised by letreg in the method body. Each method also has a method precondition, \u03d5\nexpressed as a region lifetime constraint that is consistent with the operations performed\nin the method body. The method precondition also contains the class invariants of its\nparameters including the receiver and its result. The instance methods of a subclass can\noverride the instance methods of the superclass.\nConsider the Pair class in Fig. 4. As there are two fields in this class, a distinct\nregion is introduced for each of them, r2 for fst field and r3 for snd field. The Pair\nobject is placed in the region r1. To ensure that every Pair instance satisfies the no-\ndangling requirement, the region lifetime constraint r2\u0017r1\u2227r3\u0017r1 is added to the\nclass invariant.\nclass Pair\u3008r1,r2,r3\u3009 extends Object\u3008r1\u3009\nwhere r2\u0017r1 \u2227 r3\u0017r1 {\nObject\u3008r2\u3009 fst;\nObject\u3008r3\u3009 snd;\nvoid setSnd\u3008r1,r2,r3,r4\u3009(Object\u3008r4\u3009 o)\nwhere r4\u0017r3\u2227r2\u0017r1\u2227r3\u0017r1\n{snd=o;}\nvoid swap\u3008r1,r2,r3\u3009() where r2=r3\u2227r2\u0017r1\n{ Object\u3008r2\u3009 tmp=fst;fst=snd;snd=tmp}\nPair\u3008r5,r6,r7\u3009 exalloc\u3008r1,r2,r3,r5,r6,r7\u3009()\nwhere r7\u0017r5\u2227r6\u0017r5\u2227r2\u0017r1\u2227r3\u0017r1\n{letreg r in {\nPair\u3008r7,r7,r7\u3009 p4;\nPair\u3008r,r,r\u3009 p3;\nPair\u3008r5,r6,r7\u3009 p2;\nPair\u3008r,r,r\u3009 p1;\np4 = new Pair\u3008r7,r7,r7\u3009(null,null);\np3 = new Pair\u3008r,r,r\u3009(p4,null);\np2 = new Pair\u3008r5,r6,r7\u3009(null,p4);\np1 = new Pair\u3008r,r,r\u3009(p2,null);\np1.setSnd\u3008r,r,r,r\u3009(p3); p2} }\n}\nFig. 4. Region-Annotated Core-Java Program\nConsider the setSnd,\nswap, and exalloc meth-\nods of the Pair class. A\nset of distinct region param-\neters are introduced for the\nmethods\u2019 parameters, and\nthe results, as shown in\nFig. 4. The receiver regions\nare taken from the class def-\ninition. Moreover, the meth-\nods\u2019 region lifetime con-\nstraints are based on the\npossible operations of the\nrespective methods. For ex-\nample, due to an assign-\nment operation and region\nsubtyping, we have r4\u0017r3\nfor setSnd, while r2=r3\nis present due to the swap-\nping operation on the re-\nceiver object in the swap\nmethod. Though the swap\nmethod\u2019s region constraint\nis exclusively on the regions\nof the current object, we as-\nsociate the constraint with the method. In this way, only those objects that might call\nthe method are required to satisfy this constraint. The class invariants of methods\u2019 pa-\nrameters (including the receiver and their result) are also added to the methods\u2019 region\nconstraints. The exalloc method\u2019s body introduces a local region r using letreg.\nSince the p1 and p3 objects do not escape from the exalloc method\u2019s body, they are\nstored in the local region r. The p2 and p4 objects escape through the method result,\ntherefore they are stored in the method result\u2019s regions r5 and r7, respectively.\n3 Region Type System: Static Semantics\nOur region type system guarantees that region-annotated Core-Java programs never cre-\nate dangling references. To avoid variable name duplication, we assume that the local\nvariables of the blocks and the arguments of the functions are uniquely renamed in a\npreprocessing phase. A part of region type checking rules are depicted in Fig. 5, with\nsome auxiliary rules in Fig. 6 (a complete description of region type system is given\nin [11]). Judgments of the following forms are employed:\n\u2013 \u22a2 P denoting that a program P is well-typed.\n[RC\u2212PROG]\nWFClasses(P)\nP = def1 .. defn\nFieldsOnce(defi) i = 1..n\nMethodsOnce(defi) i = 1..n\nP \u22a2 InheritanceOK(defi) i = 1..n\nP \u22a2def defi i = 1..n\n\u22a2 P\n[RC\u2212CLASS]\ndef = class cn\u3008r1..n\u3009extends c\u3008r1..m\u3009\nwhere \u03d5 {field1..p meth1..q}\nr1 6\u2208\n\u22c3p\ni=1\nreg(fieldi)\n\u03d5\u21d2ri \u0017 r1 i = 2..n R = {r1, . . . , rn}\nP; {this : cn\u3008r1..n\u3009}; R;\u03d5 \u22a2meth methi i = 1..q\nP; R;\u03d5 \u22a2field fieldi i = 1..p\nP \u22a2def def\n[RC\u2212METH]\n\u0393 \u2032 = \u0393 + (vj : tj)j:1..p R\u2032 = R \u222a {r1, . . . , rm}\n\u03d5\u2032 = \u03d5 \u2227 \u03d50 P; R\u2032;\u03d5\u2032 \u22a2type tj , j = 0..p\nP;\u0393 \u2032; R\u2032;\u03d5\u2032 \u22a2 e : t\u20320 P; R\u2032;\u03d5\u2032 \u22a2 t\u20320 <: t0\nP;\u0393 ; R;\u03d5 \u22a2meth t0 mn\u3008r1..m\u3009((tj vj)j:1..p)where \u03d50 {e}\n[RC\u2212EB]\nP; R;\u03d5 \u22a2type t\u2032\n\u0393 \u2032 = \u0393 + (v : t\u2032)\nP;\u0393 \u2032; R;\u03d5 \u22a2 e : t\nP;\u0393 ; R;\u03d5 \u22a2 {(t\u2032 v) e} : t\n[RC\u2212VAR]\n(v : t) \u2208 \u0393\nP;\u0393 ; R;\u03d5 \u22a2 v : t\n[RC\u2212NEW]\nP; R;\u03d5 \u22a2type cn\u3008r1..n\u3009 fieldlist(cn\u3008r1..n\u3009) = (ti fi)i:1..p\n(vi : t\u2032i) \u2208 \u0393 P; R;\u03d5 \u22a2 t\u2032i <: ti i = 1..p\nP;\u0393 ; R;\u03d5 \u22a2 new cn\u3008r1..n\u3009(v1, .., vp) : cn\u3008r1..n\u3009\n[RC\u2212INVOKE]\n(v0 : cn\u3008a\n+\u3009) \u2208 \u0393 P; R;\u03d5 \u22a2type cn\u3008a+\u3009\n(t mn\u3008a+r\u2032+\u3009((ti vi)i:1..n)where \u03d50 {e}) \u2208 cn\u3008a+\u3009\n(v\u2032i : t\n\u2032\ni)i:1..n \u2208 \u0393 a\n\u2032+\u2208R \u03c1 = [r\u2032+ 7\u2192a\u2032+]\n\u03d5\u21d2\u03c1\u03d50 P; R;\u03d5 \u22a2 t\u2032i<:\u03c1 ti i = 1..n\nP;\u0393 ; R;\u03d5 \u22a2 v0.mn\u3008a+a\u2032+\u3009(v\u20321..v\u2032n) : \u03c1 t\n[RC\u2212LETR]\na = fresh()\n\u03d5\u2032 = \u03d5 \u2227\n\u2227\nr\u2032\u2208R(r\n\u2032\u0017a)\nP;\u0393 ; R\u222a{a};\u03d5\u2032 \u22a2 [r 7\u2192a]e : t\nreg(t) \u2286 R\nP;\u0393 ; R;\u03d5 \u22a2 letreg r in e : t\n\u03c1t, \u03c1\u03d5, \u03c1e region substitution on a type, a constraint, and an expression\nfresh() returns one or more new\/unused region names\nFig. 5. Region Type Checking Rules\n\u2013 P \u22a2def def denoting that a class declaration def is well-formed.\n\u2013 P;\u0393 ;R;\u03d5 \u22a2meth meth denoting that a method meth is well-defined with respect to the\nprogram P, the type environment \u0393 , the set of live regions R, and the region con-\nstraint \u03d5.\n\u2013 P;\u0393 ;R;\u03d5\u22a2e:t denoting that an expression e is well-typed with respect to the program\nP, the type environment \u0393 , the set of live regions R, and the region constraint \u03d5.\n\u2013 P; R;\u03d5 \u22a2type t denoting that a type t is well-formed, namely, the regions of the type t\nare from the set of the live regions R, and the invariant of the type t is satisfied by\nthe constraint context \u03d5.\n\u2013 P; R \u22a2constr t, \u03d5 denoting that the regions of the type t are from the set of the live\nregions R, while \u03d5 is the invariant of the type t.\n\u2013 P; R;\u03d5 \u22a2field field denoting that the type of a field field is well-formed with respect to\n\u22a2type judgment.\n\u2013 P; R;\u03d5 \u22a2 t<:t\u2032 denoting that the type t is a subtype of the type t\u2032, namely both types\nare well-formed and the region constraint of the subtyping relation (defined in\nFig. 3) is satisfied by the constraint context \u03d5.\nThe rule [RC\u2212PROG] denotes that a region-annotated program is well-typed if all\ndeclared classes are well-typed. The predicates in the premise are used to capture the\nstandard well-formedness conditions for the object-oriented programs such as no dupli-\ncate definitions of classes and no cycle in the class hierarchy; no duplicate definitions\nof fields; no duplicate definitions of methods; and soundness of class subtyping and\nmethod overriding.\nreg({})=def{} reg({v:\u03c4 \u3008r\u2217\u3009}\u222a\u0393 )=def{r\u2217}\u222areg(\u0393 )\nreg(\u03c4 \u3008r\u2217\u3009)=def{r\u2217} reg((\u03c4 \u3008r\u2217\u3009 f))=def{r\u2217}\nreg(r1\u0017r2)=def{r1, r2} reg(r1=r2)=def{r1, r2}\nreg(true)=def{} reg(\u03d51\u2227\u03d52)=defreg(\u03d51)\u222areg(\u03d52)\nfieldlist(Object\u3008r\u3009)=def[ ]\nclass cn1\u3008r1..n\u3009 extends cn2\u3008r1..m\u3009..{(ti fi)i:1..p..}\u2208P\u2032\n\u2113=fieldlist(\u03c1 cn2\u3008r1..m\u3009) \u03c1=[ri 7\u2192xi]ni=1\nfieldlist(cn1\u3008x1..n\u3009)=def\u2113++[(\u03c1 ti) fi]pi=1\nFig. 6. Auxiliary Region Checking Rules\nThe rule [RC\u2212CLASS] in-\ndicates that a class is well-\nformed if all its fields and\nmethods are well-formed, and\nthe class invariant ensures the\nnecessary lifetime relations\namong class region parame-\nters. In addition, the rule does\nnot allow the first region of\nthe class to be used by the re-\ngion types of the fields. Us-\ning the first region on a field\nwould break the object (re-\ngion) subtyping (rule [RegSub] of Fig. 3). Function reg(fieldi) returns the region vari-\nables of a field type (see Fig. 6).\nThe rule [RC\u2212METH] checks the well-formedness of a method declaration. Each\nregion type is checked to be well-formed, that means its regions are in the current set of\nlive regions and its invariant is satisfied by the current constraint context. The method\nbody is checked using the type relation for expressions such that the gathered type has\nto be a subtype of the declared type.\nOur type relation for expressions is defined in a syntax-directed fashion. Take note\nthat region constraints of the variables are not checked at their uses ([RC\u2212VAR]), but\nat their declaration sites ([RC\u2212EB]). The region invariant of an object is also checked\nwhen that object is created ([RC\u2212NEW]). In the rule for object creation ([RC\u2212NEW]), the\nfunction fieldlist(cn\u3008x1..n\u3009) returns a list comprising all declared and inherited fields of\nthe class cn\u3008x1..n\u3009 and their region types according to the regions x1..xn of the class cn\n(see Fig. 6). They are organized in an order determined by the constructor function.\nThe rule [RC\u2212INVOKE] is used to check a method call. It ensures that the method re-\ngion parameters are live regions and the method precondition is satisfied by the current\nconstraint context as \u03d5\u21d2\u03c1\u03d50. A substitution \u03c1 is computed for the method\u2019s formal re-\ngion parameters. The current arguments are also checked to be subtypes of the method\u2019s\nformal parameters.\nThe rule [RC\u2212LETR] is used to check a local region declaration. The local expression\nis checked with an extra live region a (that is a fresh region), and an extra constraint\n\u2227\nr\u2032\u2208R(r\n\u2032\u0017a) that ensures that newly introduced region is on the top of the region stack.\nThe rule uses a region substitution on the expressions. Note that the region substitutions\non expressions, constraints and types are defined as expected. The gathered region type\nof the local expression is checked to contain only live regions (from R excepting a).\nThis guarantees that the localized region a does not escape. Function reg(t) returns all\nregion variables of t (see Fig. 6).\n4 Dynamic Semantics\nIn this section we define the dynamic semantics of our region calculus. Our dynamic\nsemantics rules use runtime checks to throw an error and to abort the execution, when-\never the evaluation of a region-annotated Core-Java program tries to create a dangling\nreference. In Section 6 we prove that those runtime checks are redundant for well-typed\nprograms, namely the evaluation of a well-typed region-annotated Core-Java program\nnever creates a dangling reference. The dynamic semantics is defined as a small-step\nrewriting relation from machine states to machine states. A machine state is of the form\n\u3008\u031f,\u03a0\u3009[e], where \u031f is the heap organized as a stack of regions, \u03a0 is the variable en-\nvironment, and e is the current program. Our dynamic semantics was inspired by the\nprevious work on abstract models of memory management [18] and region-based mem-\nory management [9, 13]. The following notations are used:\nRegion Variables : r, a \u2208 RegVar\nOffset : o \u2208 Offset\nLocations : \u2113 or (r, o) \u2208 Location=RegVar\u00d7Offset\nPrimitive Values : k | null \u2208 Prim\nValues : \u03b4 \u2208 Value = Prim \u228e Location\nVariable Environment : \u03a0 \u2208 VEnv = Var \u21c0fin Value\nField Environment : V \u2208 FEnv = FieldName \u21c0fin Value\nObject Values : cn\u3008r\u2217\u3009(V) \u2208 ObjVal = ClassName \u00d7 (RegVar)n \u00d7 FEnv\nStore : \u031f \u2208 Store = [ ]|[r 7\u2192Rgn]Store\nRuntime Regions : Rgn \u2208 Region = Offset \u21c0fin ObjVal\nRegions are identified by region variables. We assume a denumerably infinite set of\nregion variables, RegVar. The store \u031f is organized as a stack, that defines an ordered\nmap from region variables, r to runtime regions Rgn. The notation [r 7\u2192Rgn]\u031f denotes a\nstack with the region r on the top, while [ ] denotes an empty store. The store can only\nbe extended with new region variables. A runtime region Rgn is an unordered finite map\nfrom offsets to object values. We assume a denumerably infinite set of offsets, Offset for\neach runtime region Rgn.\nThe set of values that can be assigned to variables and fields is denoted by Value.\nSuch a value is either a primitive value (a constant or a null value) or it is a location in\nthe store. A location consists of a pair of a region variable and an offset.\nAn object value consists of a region type cn\u3008r\u2217\u3009, and a field environment V mapping\nfield names to values. V is not really an environment since it can only be updated, never\nextended. An update of field f with value \u03b4 is written as V +{f 7\u2192\u03b4}.\nThe variable environment\u03a0 is a mapping Var \u21c0fin Value, while the type environment\n\u0393 that corresponds to the runtime variable environment is also a mapping Var \u21c0fin Type.\nTo avoid variable name duplication, we assume that the local variables of the blocks\nand the arguments of the functions are uniquely renamed in a preprocessing phase.\nNotation f : A \u21c0fin B denotes a partial function from A to B with a finite domain,\nwritten A = dom(f). We write f+{a 7\u2192 b} for the function like f but mapping a to b (if\na\u2208dom(f) and f(a)=c then (f+{a 7\u2192 b})(a)=b). The notation {} (or \u2205) stands for an un-\ndefined function. Given a function f : A \u21c0fin B , the notation f\u2212C denotes the function\nf1 : (A\u2212C ) \u21c0fin B such that \u2200x\u2208(A\u2212C )\u00b7f1(x)=f(x).\nWe require some intermediate expressions for the small-step dynamic semantics to\nfollow through. The intermediate expressions help our proof to use simpler induction\ntechniques rather than a more elaborate co-induction machinery. The syntax of inter-\nmediate expressions is thus extended from the original expression syntax, as follows:\ne ::= . . . | (r, o) | ret(v, e) | retr(r, e)\nThe expression ret(v, e) is used to capture the result of evaluating a local block, or the\nresult of a method invocation. The variable associated with ret denotes either a block\nlocal variable or a method receiver or a method parameter. This variable is popped from\nthe variable environment at the end of the block\u2019s evaluation. In the case of a method\ninvocation there are multiple nested rets which pop off the receiver and the method\nparameters from the variable environment at the end of the method\u2019s evaluation. The\nexpression retr(r, e) is used to pop off the top region, r of the store stack at the end of\nexpression e evaluation.\nDynamic semantics rules of region annotated Core-Java are shown in Fig. 7 and\nFig. 8. The evaluation judgment is of the form:\n\u3008\u031f,\u03a0\u3009[e]\u2192\u0592\u3008\u031f\u2032,\u03a0 \u2032\u3009[e\u2032]\nwhere \u031f (\u031f\u2032) denotes the store before (after) evaluation, while \u03a0 (\u03a0 \u2032) denotes the vari-\nable environment before (after) evaluation. The store \u031f organized as a stack establishes\nthe outlive relations among regions at runtime. The function ord(\u031f) returns the outlive\nrelations for a given store. The function dom(\u031f) returns the set of the store regions,\nwhile the function location dom(\u031f) returns the set of all locations from the store. They\nare defined as follows:\nord([r1 7\u2192Rgn1][r2 7\u2192Rgn2]\u031f)=def(r2\u0017r1)\u2227ord([r2 7\u2192Rgn2]\u031f)\nord([r 7\u2192Rgn]) =def true ord([ ]) =def true\ndom([r 7\u2192Rgn]\u031f)=def{r}\u222adom(\u031f) dom([r 7\u2192\u2205]\u031f)=def{r}\u222adom(\u031f) dom([ ])=def\u2205\nlocation dom(\u031f)=def{(r, o) | \u031f=\u031f1[r 7\u2192Rgn]\u031f2 \u2227 Rgn6=\u2205 \u2227 o\u2208dom(Rgn)}\nNotation \u031f(r)(o) denotes an access into the region r at the offset o, as follows:\n\u031f(r)(o)=defRgn(o) where \u031f=\u031f1[r 7\u2192Rgn]\u031f2\nWe define the meaning of no-dangling references property at runtime. The property\nrefers to two kinds of references: (1) references from variable environment to store\nlocations, and (2) references from store locations to other store locations. Note that the\nnotion of no-dangling references was introduced in Fig. 1, and a reference is formalized\nas a location (r, o).\nDefinition 1. (live location) A location (r, o) is live with respect to a store \u031f, if r \u2208\ndom(\u031f).\nDefinition 2. (no-dangling)\n1. A variable environment \u03a0 is no-dangling with respect to a store \u031f if for all v\n\u2208 dom(\u03a0),\u03a0(v) is either a primitive value, or a live location (r, o) with respect\nto \u031f.\n2. A runtime store \u031f is no-dangling if each region r1 \u2208 dom(\u031f) contains only ref-\nerences to regions older than itself, that means that for each location (r1, o) \u2208\nlocation dom(\u031f) containing an object value\u031f(r1)(o)=cn\u3008r1..n\u3009(V), that object value\nsatisfies the non-dangling requirement for a class, such that ord(\u031f)\u21d2\u2227\ni:2..n\n(ri\u0017r1)\n[D\u2212VAR]\nv \u2208 dom(\u03a0)\n\u3008\u031f,\u03a0\u3009[v]\u2192\u0592\u3008\u031f,\u03a0\u3009[\u03a0(v)]\n[D\u2212FD]\n\u03a0(v)=(r, o) \u031f=\u031f1[r 7\u2192Rgn]\u031f2 Rgn(o)=cn\u3008a+\u3009(V)\n\u3008\u031f,\u03a0\u3009[v.f]\u2192\u0592\u3008\u031f,\u03a0\u3009[V (f)]\n[D\u2212ASSGN1]\nlhs = v | v.f\n\u3008\u031f,\u03a0\u3009[e]\u2192\u0592\u3008\u031f\u2032, \u03a0 \u2032\u3009[e\u2032]\n\u3008\u031f,\u03a0\u3009[lhs = e]\u2192\u0592\u3008\u031f\u2032, \u03a0 \u2032\u3009[lhs = e\u2032]\n[D\u2212ASSGN2]\nv\u2208dom(\u03a0) \u03a0 \u2032=\u03a0+{v 7\u2192\u03b4}\n\u03b4=(r1, o1) \u2227 r1\u2208dom(\u031f)\n\u3008\u031f,\u03a0\u3009[v = \u03b4]\u2192\u0592\u3008\u031f,\u03a0 \u2032\u3009[()]\n[D\u2212ASSGN2\u2212DANGLERR]\nv \u2208 dom(\u03a0)\n\u03b4=(r1, o1) \u2227 r1 6\u2208dom(\u031f)\n\u3008\u031f,\u03a0\u3009[v=\u03b4]\u2192\u0592danglingerr\n[D\u2212ASSGN3]\n\u03a0(v)=(a, o) \u031f=\u031f1[a 7\u2192Rgn]\u031f2 Rgn(o)=cn\u3008a+\u3009(V)\nRgn\u2032=Rgn+{o7\u2192cn\u3008a+\u3009(V+{f 7\u2192\u03b4})}\u031f\u2032=\u031f1[a 7\u2192Rgn\u2032]\u031f2\n\u03b4=(r1, o1) \u2227 ord(\u031f)\u21d2(r1\u0017fieldregion(cn\u3008a+\u3009, f))\n\u3008\u031f,\u03a0\u3009[v.f = \u03b4]\u2192\u0592\u3008\u031f\u2032,\u03a0\u3009[()]\n[D\u2212ASSGN3\u2212DANGLERR]\n\u03a0(v)=(a, o) \u031f=\u031f1[a 7\u2192Rgn]\u031f2 Rgn(o)=cn\u3008a+\u3009(V)\n\u03b4=(r1, o1) \u2227 \u00ac (ord(\u031f)\u21d2(r1\u0017fieldregion(cn\u3008a+\u3009, f)))\n\u3008\u031f,\u03a0\u3009[v.f = \u03b4]\u2192\u0592danglingerr\n[D\u2212NEW]\nclass cn\u3008r1..n\u3009 extends c\u3008...\u3009 where \u03d5inv {...} \u2208 P ord(\u031f)\u21d2\u03d5inv\n\u031f=\u031f1[r1 7\u2192Rgn]\u031f2 V ={f1 7\u2192\u03a0(v1), ..., fp 7\u2192\u03a0(vp)} fieldlist(cn\u3008r1..n\u3009)=(ti fi)i:1..p\nif \u03a0(vi)=(r\u2032i, o\u2032i) then ord(\u031f)\u21d2(r\u2032i\u0017fieldregion(cn\u3008r1..n\u3009, fi)) i=1..p\no\/\u2208dom(Rgn) Rgn\u2032=Rgn+{o7\u2192cn\u3008r1..n\u3009(V)} \u031f\u2032=\u031f1[r1 7\u2192Rgn\u2032]\u031f2\n\u3008\u031f,\u03a0\u3009[new cn\u3008r1..n\u3009(v1..p)]\u2192\u0592\u3008\u031f\n\u2032,\u03a0\u3009[(r1, o)]\n[D\u2212NEW\u2212DANGLERR]\nclass cn\u3008r1..n\u3009 extends c\u3008...\u3009 where \u03d5inv {...} \u2208 P\nV ={f1 7\u2192\u03a0(v1), ..., fp 7\u2192\u03a0(vp)} fieldlist(cn\u3008r1..n\u3009)=(ti fi)i:1..p\n\u00ac(ord(\u031f)\u21d2\u03d5inv) \u2228 (\u2203i\u2208{1..p} \u00b7\u03a0(vi)=(r\u2032i, o\u2032i) \u2227\n\u00ac(ord(\u031f)\u21d2(r\u2032i\u0017fieldregion(cn\u3008r1..n\u3009, fi)))\n\u3008\u031f,\u03a0\u3009[new cn\u3008r1..n\u3009(v1..p)]\u2192\u0592danglingerr\n[D\u2212INVOKE]\n{a+, a\u2032+}\u2282dom(\u031f)\n\u03a0(v\u20320) = (a1, o) \u031f(a1)(o) = cn\u3008a\n+\u3009(V)\n(t0 mn\u3008a+r\u2032+\u3009((t v)1..p)where \u03d5 {e}) \u2208 cn\u3008a+\u3009\nni=fresh() i = 0..p \u03c1=[r\u2032+ 7\u2192a\u2032+] \u03a0 \u2032=\u03a0+{ni 7\u2192\u03a0(v\u2032i)i:0..p}\ne\u2032=ret(n0,ret(n1, ..ret(np, [this 7\u2192n0][vi 7\u2192ni]pi:1\u03c1e)))\n\u3008\u031f,\u03a0\u3009[v\u20320.mn\u3008a\n+a\u2032+\u3009(v\u20321..p)]\u2192\u0592\u3008\u031f,\u03a0\n\u2032\u3009[e\u2032]\n[D\u2212INVOKE\u2212DANGLERR]\n\u00ac(r+\u2208dom(\u031f))\n\u3008\u031f,\u03a0\u3009[v.mn\u3008r+\u3009(v\u2217)]\u2192\u0592danglingerr\nFig. 7. Dynamic Semantics for Region-Annotated Core-Java: Part I\n[D\u2212EB]\nn=fresh() \u03a0 \u2032=\u03a0+{(n 7\u2192init(t))} e\u2032=ret(n, e)\n\u3008\u031f,\u03a0\u3009[{(t v) e}]\u2192\u0592\u3008\u031f,\u03a0 \u2032\u3009[e\u2032]\n[D\u2212RET1]\n\u3008\u031f,\u03a0\u3009[e]\u2192\u0592\u3008\u031f\u2032, \u03a0 \u2032\u3009[e\u2032]\n\u3008\u031f,\u03a0\u3009[ret(v, e)]\u2192\u0592\u3008\u031f\u2032, \u03a0 \u2032\u3009[ret(v, e\u2032)]\n[D\u2212RET2]\n\u3008\u031f,\u03a0\u3009[ret(v, \u03b4)]\u2192\u0592\u3008\u031f,\u03a0\u2212{v}\u3009[\u03b4]\n[D\u2212LETR]\na=fresh()\n\u3008\u031f,\u03a0\u3009[letreg r in e]\u2192\u0592\u3008[a7\u2192\u2205]\u031f,\u03a0\u3009[retr(a, [r7\u2192a]e)]\n[D\u2212RETR1]\n\u3008\u031f,\u03a0\u3009[e]\u2192\u0592\u3008\u031f\u2032, \u03a0 \u2032\u3009[e\u2032]\n\u3008\u031f,\u03a0\u3009[retr(a, e)]\u2192\u0592\u3008\u031f\u2032, \u03a0 \u2032\u3009[retr(a, e\u2032)]\n[D\u2212RETR2]\n(\u03b4=(r, o))\u21d2(r\u2208dom(\u031f))\n\u2200v\u2208\u03a0 \u00b7 (\u03a0(v)=(r, o))\u21d2(r\u2208dom(\u031f))\n\u2200(r1, o)\u2208location dom(\u031f) \u00b7 (\u031f(r1)(o)=cn\u3008r1..n\u3009(V))\u21d2(r1..n\u2208dom(\u031f)\u2227\n\u2200f \u2208 dom(V) . V(f)=(rf , of ) \u2227 rf\u2208dom(\u031f))\n\u3008[a 7\u2192Rgn]\u031f,\u03a0\u3009[retr(a, \u03b4)]\u2192\u0592\u3008\u031f,\u03a0\u3009[\u03b4]\n[D\u2212RETR2\u2212DANGLERR]\n\u00ac(a=a1)\u2228\n\u00ac((\u03b4=(r, o))\u21d2(r\u2208dom(\u031f))) \u2228 \u00ac((\u2200v\u2208\u03a0 \u00b7 (\u03a0(v)=(r, o))\u21d2(r\u2208dom(\u031f))))\n\u2228\u00ac(\u2200(r1, o)\u2208location dom(\u031f) \u00b7 (\u031f(r1)(o)=cn\u3008r1..n\u3009(V))\u21d2(r1..n\u2208dom(\u031f)\u2227\n\u2200f \u2208 dom(V) . V(f)=(rf , of ) \u2227 rf\u2208dom(\u031f)))\n\u3008[a 7\u2192Rgn]\u031f,\u03a0\u3009[retr(a1, \u03b4)]\u2192\u0592danglingerr\n[D\u2212IF1]\n\u03a0(v)=true\n\u3008\u031f,\u03a0\u3009[if v then e1 else e2]\u2192\u0592\u3008\u031f,\u03a0\u3009[e1]\n[D\u2212IF2]\n\u03a0(v)=false\n\u3008\u031f,\u03a0\u3009[if v then e1 else e2]\u2192\u0592\u3008\u031f,\u03a0\u3009[e2]\n[D\u2212LOOP1]\n\u03a0(v)=true\n\u3008\u031f,\u03a0\u3009[while v e]\u2192\u0592\u3008\u031f,\u03a0\u3009[e ; while v e]\n[D\u2212LOOP2]\n\u03a0(v)=false\n\u3008\u031f,\u03a0\u3009[while v e]\u2192\u0592\u3008\u031f,\u03a0\u3009[()]\n[D\u2212SEQ1]\n\u3008\u031f,\u03a0\u3009[e1]\u2192\u0592\u3008\u031f\n\u2032,\u03a0 \u2032\u3009[e\u20321]\n\u3008\u031f,\u03a0\u3009[e1 ; e2]\u2192\u0592\u3008\u031f\u2032,\u03a0 \u2032\u3009[e\u20321 ; e2]\n[D\u2212SEQ2]\n\u3008\u031f,\u03a0\u3009[\u03b41 ; e2]\u2192\u0592\u3008\u031f,\u03a0\u3009[e2]\n[D\u2212NULLERR1]\n\u03a0(v)=null\n\u3008\u031f,\u03a0\u3009[v.f]\u2192\u0592nullerr\n[D\u2212NULLERR2]\n\u03a0(v)=null\n\u3008\u031f,\u03a0\u3009[v.f = \u03b4]\u2192\u0592nullerr\n[D\u2212NULLERR3]\n\u03a0(v)=null\n\u3008\u031f,\u03a0\u3009[v.mn\u3008a\u2217\u3009(u\u2217)]\u2192\u0592nullerr\nFig. 8. Dynamic Semantics for Region-Annotated Core-Java: Part II\nand the current values of the fields are either primitives or references to regions\nolder than those expected by the region type cn\u3008r1..n\u3009, as follows:\n\u2200f \u2208 dom(V) . V(f)=(rf , of ) ord(\u031f)\u21d2rf\u0017fieldregion(cn\u3008r1..n\u3009, f)\nFunction fieldregion(cn\u3008r1..n\u3009, f) computes the region type of the class field f and then\nreturns its first region where the field is expected to be stored.\nThe dynamic semantics evaluation rules may yield two possible runtime errors, namely:\nError ::= nullerr | danglingerr\nThe first error nullerr is due to null pointers (by accessing fields or methods of null\nobjects). The second error danglingerr is reported when a store updating operation\nor a variable environment updating operation creates a dangling reference. Our dynamic\nsemantics rules use runtime checks to guarantee that a danglingerr error is reported\n(and the execution is aborted) whenever the program evaluation tries to create a dan-\ngling reference. There are five situations that require no-dangling reference checks at\nruntime:\n\u2013 Creation of a new object value. Rule [D\u2212NEW] checks whether the class invariant\nholds, ord(\u031f)\u21d2\u03d5inv (mainly whether the fields regions ri:2..n outlive the region r1\nof the object). The initial value of a field is also checked to be stored in a region that\noutlives the expected region of that field r\u2032i\u0017fieldregion(cn\u3008r1..n\u3009, fi). The function\nfieldlist(cn\u3008r1..n\u3009) is defined in Fig. 6.\n\u2013 Updating of an object\u2019s field. Rule [D\u2212ASSGN3] checks whether the region r1 of\nthe new location \u03b4=(r1, o1) outlives the expected region for the object field f ,\nr1\u0017fieldregion(cn\u3008a+\u3009, f).\n\u2013 Updating a variable from the variable environment. Rule [D\u2212ASSGN2] checks whether\nthe new location \u03b4=(r1, o1) assigned to a variable is live, namely its region is in the\ncurrent store, r1\u2208dom(\u031f).\n\u2013 Deallocation of a region. Rule [D\u2212RETR2] checks whether the region a is on the\ntop of the store stack. Then it checks whether a reference to a does not escape\nneither through the value result \u03b4, nor through the program variable environment\n\u03a0 , nor through the object values of the store \u031f. Note that when a new region is\nallocated, in rule [D\u2212LETR], a fresh region name is used in order to avoid region\nname duplication in the store.\n\u2013 Calling a method. Rule [D\u2212INVOKE] checks whether the method\u2019s region argu-\nments are in the current store and then prepares the variable environment for the\nmethod\u2019s body execution.\nThe corresponding rules [D\u2212NEW\u2212DANGLERR], [D\u2212ASSGN3\u2212DANGLERR], [D\u2212ASSGN2\n\u2212DANGLERR], [D\u2212RETR2\u2212DANGLERR], and [D\u2212INVOKE\u2212DANGLERR] generate a\ndanglingerr error due to the failure of their runtime checks. In the rules [D\u2212ASSGN2],\n[D\u2212ASSGN3], and [D\u2212LOOP2] the result () denotes the singleton value of type void. Note\nthat the type void is assumed to be isomorphic to type unit. In rule [D\u2212EB], the locally\ndeclared variable is assigned, with the help of the function init, an initial value according\nto its type as follows: init(t) =def case t of\nboolean \u2192 false\nint \u2192 0\ncn\u3008r1..n\u3009 \u2192 null\n5 Extended Static Semantics\nIn this section we extend our static semantics rules from Section 3 to include the new in-\ntermediate constructions introduced by the small-step dynamic semantics rules in Sec-\ntion 4.\nFirst we define a valid program using a novel syntactic condition valid(e), that re-\nstricts the places where the intermediate constructions may occur in a program.\nDefinition 3. (valid program)\n1. A program is a valid program if all the program\u2019s classes are valid classes.\n2. A class is a valid class if all the class\u2019s methods are valid methods.\n3. A method is a valid method if the method\u2019s body e is a valid block expression such\nthat retvars(e)=\u2205 and retregs(e)=\u2205.\n4. Expression e is a valid expression if the predicate valid(e) holds, where valid(e) is\ndefined as follows:\nvalid(e) =def case e of\n{(t v) e} \u2192 retvars(e)=\u2205 \u2227 retregs(e)=\u2205\nlhs = e \u2192 retvars(e)\u2229vars(lhs)=\u2205 \u2227 valid(e)\ne1 ; e2 \u2192 retregs(e2)=\u2205 \u2227 retvars(e2)=\u2205 \u2227 valid(e1)\n\u2227retvars(e1)\u2229vars(e2)=\u2205 \u2227 retregs(e1)\u2229regs(e2)=\u2205\nif v then e1 else e2 \u2192 retregs(e1)=\u2205 \u2227 retvars(e1)=\u2205\n\u2227retregs(e2)=\u2205 \u2227 retvars(e2)=\u2205\nwhile v e | letreg r in e \u2192 retregs(e)=\u2205 \u2227 retvars(e)=\u2205\nret(v, e) \u2192 v 6\u2208 retvars(e) \u2227 valid(e)\nretr(r, e) \u2192 r 6\u2208 retregs(e) \u2227 valid(e)\notherwise \u2192 true\nThis condition does not restrict source-level region calculus, since intermediate con-\nstructions are generated during the program evaluation. A source language Core-Java\nprogram is by default a valid program since it does not contain any intermediate ex-\npression. The above condition is based on the functions vars(e), retvars(e), regs(e), and\nretregs(e) which are defined as follows:\nDefinition 4. 1. The function vars(e) computes the set of all program variables which\noccur in the expression e, excepting those variables introduced by e\u2019s block subex-\npressions, as follows:\nvars(e) =def case e of\nret(v, e) \u2192 {v} \u222a vars(e)\n{(t v) e} \u2192 vars(e) \\ {v}\nretr(r, e) | letreg r in e \u2192 vars(e)\nv.f = e | v = e | while v e \u2192 {v} \u222a vars(e)\nv.f | v \u2192 {v}\nif v then e1 else e2 \u2192 {v} \u222a vars(e1) \u222a vars(e2)\ne1 ; e2 \u2192 vars(e1) \u222a vars(e2)\nnew cn\u3008r+\u3009(v\u2217) \u2192 {v\u2217}\nv.mn\u3008v\u2217\u3009(v\u2217) \u2192 {v} \u222a {v\u2217}\notherwise \u2192 \u2205\n2. The function retvars(e) computes the set of all program variables which occur in the\nret subexpressions of the expression e, as follows:\nretvars(e) =def case e of\nret(v, e) \u2192 {v} \u222a retvars(e)\nretr(r, e) | v.f = e | v = e | {(t v) e} \u2192 retvars(e)\nwhile v e | letreg r in e \u2192 retvars(e)\ne1 ; e2 | if v then e1 else e2 \u2192 retvars(e1) \u222a retvars(e2)\notherwise \u2192 \u2205\n3. The function regs(e) computes the set of all region variables which occur in the\nexpression e, excepting those regions introduced by e\u2019s letreg subexpressions, as\nfollows:\nregs(e) =def case e of\n{(t v) e} \u2192 reg(t) \u222a regs(e)\nretr(r, e) \u2192 {r} \u222a regs(e)\nletreg r in e \u2192 regs(e) \\ {r}\nret(v, e) | v.f = e | v = e | while v e \u2192 regs(e)\n(r, o) \u2192 {r}\nif v then e1 else e2 | e1 ; e2 \u2192 regs(e1) \u222a regs(e2)\nnew cn\u3008r+\u3009(v\u2217) | v.mn\u3008r+\u3009(v\u2217) \u2192 {r+}\notherwise \u2192 \u2205\nwhere reg(t) is defined in the Figure 6.\n4. The function retregs(e) computes the set of all region variables which occur in the\nretr subexpressions of the expression e, as follows:\nretregs(e) =def case e of\nretr(r, e) \u2192 {r} \u222a retregs(e)\nret(v, e) | v.f = e | v = e | {(t v) e} \u2192 retregs(e)\nwhile v e | letreg r in e \u2192 retregs(e)\ne1 ; e2 | if v then e1 else e2 \u2192 retregs(e1) \u222a retregs(e2)\notherwise \u2192 \u2205\nIn order to describe the type of each location, we introduce a store typing. This\nensures that objects created in the store during run-time are type-wise consistent with\nthose captured by the static semantics. Store typing is conventionally used to link static\nand dynamic semantics [20]. In our case, it is denoted by \u03a3, as follows:\n\u03a3 \u2208 StoreType = RegVar\u21c0finOffset \u21c0fin Type\nThe judgments of static semantics are extended with store typing, as follows:\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : t\nFor a store typing \u03a3 : R\u21c0finO\u21c0finType, a region r, a location (r, o), and a type t we also\nintroduce the following notations:\ndom(\u03a3)=R \u03a3(r)(o)=f(o), where f=\u03a3(r)\nlocation dom(\u03a3)=def{(r, o) | r\u2208dom(\u03a3) \u2227 f=\u03a3(r) \u2227 f 6=\u2205 \u2227 o\u2208dom(f)}\n\u03a3\u2212r=def\u03a31 such that \u03a31 : (R\u2212{r})\u21c0finO\u21c0finType \u2227 \u2200r\u2032\u2208(R\u2212r) \u00b7\u03a31(r\u2032)=\u03a3(r\u2032)\n\u03a3+r=def\u03a32 such that \u03a32 : (R\u222a{r})\u21c0finO\u21c0finType \u2227\u03a32(r)=\u2205 \u2227 \u2200r\u2032\u2208R \u00b7\u03a32(r\u2032)=\u03a3(r\u2032)\n\u03a3\u2212(r, o)=def\u03a33 such that \u03a33 : R\u21c0finO\u21c0finType\n\u2227r\u2208R \u2227\u03a33(r)=\u03a3(r)\u2212{o} \u2227 \u2200r\n\u2032\u2208(R\u2212r) \u00b7\u03a33(r\n\u2032)=\u03a3(r\u2032)\n\u03a3+((r, o) : t)=def\u03a34 such that \u03a34 : R\u21c0finO\u21c0finType\n\u2227r\u2208R \u2227\u03a34(r)=\u03a3(r)+{o7\u2192t} \u2227 \u2200r\n\u2032\u2208(R\u2212r) \u00b7\u03a34(r\n\u2032)=\u03a3(r\u2032)\n[RC\u2212LOCATION]\nr\u2208R \u03a3(r)(o) = t\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 (r, o) : t\n[RC\u2212ObjVal]\nP; R;\u03d5 \u22a2type cn\u3008r1..n\u3009 fieldlist(cn\u3008r1..n\u3009) = (ti fi)i:1..p\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 V(fi) : t\u2032i P; R;\u03d5 \u22a2 t\u2032i <: ti i=1..p\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 cn\u3008r1..n\u3009(V) : cn\u3008r1..n\u3009\n[RC\u2212RET]\nv\u2208\u0393 P;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : t\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 ret(v, e) : t\n[SUBSUMPTION]\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : t\u2032 P; R;\u03d5 \u22a2 t\u2032 <: t\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : t\n[RC\u2212RETR]\na\u2208R Rt=R\u2212lreg(e)\u2212{a} \u03d5\u21d2\n\u2227\nr\u2208Rt\n(r\u0017a)\nreg(t)\u2286Rt reg(\u0393\u2212lvar(e)) \u2286 Rt P;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : t\nP;\u0393 ; R;\u03d5;\u03a3 \u22a2 retr(a, e) : t\nFig. 9. Region Type Checking Rules for Valid Intermediate Expressions\nThe judgments of the new intermediate expressions are presented in Fig. 9. They\nassume that the expressions are valid with respect to the Definition 3. The first two\nrules [RC\u2212LOCATION] and [RC\u2212ObjVal] are used to type the store, either a location or an\nobject value (i.e. a location\u2019s content). Rule [RC\u2212ObjVal] preserves the same invariants\nas those of the rule [RC\u2212NEW]. Rule [RC\u2212RET] ensures that the variable to be popped\noff, v is in the current environment \u0393 . The subsumption rule [SUBSUMPTION] simplifies\nthe next theorems and their proofs.\nRule [RC\u2212RETR] is similar to rule [RC\u2212LETR], but it takes into account the evalu-\nation of the expression retr(r, e). The first check ensures that the region to be deallo-\ncated, a is in R. The Rt denotes the regions from R which are different than a and are\nnot younger than a. Note that lreg(e) denotes the regions which are younger than a. The\nsecond check ensures that our type system uses only lexically scoped regions such that\nthe region to be deallocated, a is always on the top of the regions stack. The third and\nthe fourth check ensure that the region a and the regions younger than a do not escape\neither through the result or through the live variables of the type environment. Note that\nlvar(e) denotes the local variables of the expression e which are deallocated from the\nvariable environment during the evaluation of e.\nThe rules from Fig. 9 are using the functions lvar(e), lreg(e), and lloc(e) which are\ndefined as follows:\nDefinition 5. Using the evaluation rules from Fig. 7 and Fig. 8\n1. The function lvar(e) estimates the set of variables which may be popped off from the\nvariable environment \u03a0 during the evaluation of the valid expression e (note that\nonly ret(v, e) may affect \u03a0), as follows:\nlvar(e) =def case e of\nret(v, e) \u2192 {v} \u222a lvar(e)\nretr(r, e) | lhs = e | e ; e1 \u2192 lvar(e)\notherwise \u2192 \u2205\n2. The function lreg(e) estimates the set of regions which may be popped off from the\nstore \u031f during the evaluation of the valid expression e (note that only retr(r, e)\nmay affect \u031f), as follows:\nlreg(e) =def case e of\nretr(r, e) \u2192 {r} \u222a lreg(e)\nret(v, e) | lhs = e | e ; e1 \u2192 lreg(e)\notherwise \u2192 \u2205\n3. The function lloc(e) estimates the new location which may be created into an exist-\ning region during one evaluation step of the valid expression e (note that only new\nmay create a new location), as follows:\nlloc(e) =def case e of\nnew cn\u3008r1, .., rn\u3009(v\u2217) \u2192 {(r1, o)}\nret(v, e) | retr(r, e) | lhs = e | e ; e1 \u2192 lloc(e)\notherwise \u2192 \u2205\nwhere the offset o of the region r is the offset where the next allocation in r is done.\n6 Soundness Theorems\nIn this section we prove the soundness of our region calculus, namely that a valid pro-\ngram well-typed by our type system never creates dangling references. We use a syn-\ntactic proof method [25], based on a subject reduction theorem and a progress theorem.\nFirst we define the consistency relationship between the static and dynamic seman-\ntics, namely a relationship between what we can estimate at compile-time and what can\nhappen during run-time execution.\nDefinition 6. (consistency relationship)\nA run-time environment (\u031f,\u03a0) is consistent with a static environment (\u0393,R, \u03d5,\u03a3),\nwritten \u0393,R, \u03d5,\u03a3 \u000f \u3008\u031f,\u03a0\u3009, if the following judgment holds:\ndom(\u0393 )=dom(\u03a0) \u2200v \u2208 dom(\u03a0) \u00b7 P;\u0393 ; R;\u03d5;\u03a3 \u22a2 \u03a0(v) : \u0393 (v) reg(\u0393 )\u2286R\nlocation dom(\u03a3)=location dom(\u031f) dom(\u03a3)=dom(\u031f) R=dom(\u031f)\nord(\u031f)\u21d2\u03d5 \u2200(r, o)\u2208location dom(\u031f) \u00b7 P;\u0393 ; R;\u03d5;\u03a3 \u22a2 \u031f(r)(o) : \u03a3(r)(o)\nNote that \u031f(r)(o) returns an object value cn\u3008r\u2217\u3009(V) whose type is cn\u3008r\u2217\u3009. In our instru-\nmented operational semantics an object value and its type are stored together.\nThe subject reduction theorem ensures that the region type is preserved during the\nexecution of a valid program, as follows:\nTheorem 1. (Subject Reduction): If\nvalid(e) P;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : t\n\u0393,R, \u03d5,\u03a3 \u000f \u3008\u031f,\u03a0\u3009\n\u3008\u031f,\u03a0\u3009[e] \u2192\u0592 \u3008\u031f\u2032, \u03a0 \u2032\u3009[e\u2032]\nthen there exist \u03a3\u2032, \u0393 \u2032, R\u2032, and \u03d5\u2032, such that\n(\u03a3\u2032\u2212(lreg(e\u2032)\u2212lreg(e)))\u2212(lloc(e)\u2212lloc(e\u2032)) = \u03a3\u2212(lreg(e)\u2212lreg(e\u2032))\n\u0393 \u2032\u2212(lvar(e\u2032)\u2212lvar(e)) = \u0393\u2212(lvar(e)\u2212lvar(e\u2032))\nR\u2032\u2212(lreg(e\u2032)\u2212lreg(e)) = R\u2212(lreg(e)\u2212lreg(e\u2032))\n\u03d5\u2032\u2212(lreg(e\u2032)\u2212lreg(e)) \u21d2 \u03d5\u2212(lreg(e)\u2212lreg(e\u2032))\n\u0393 \u2032,R\u2032, \u03d5\u2032, \u03a3\u2032 \u000f \u3008\u031f\u2032,\u03a0 \u2032\u3009\nvalid(e\u2032) P;\u0393 \u2032; R\u2032;\u03d5\u2032;\u03a3\u2032 \u22a2 e\u2032 : t.\nProof: By structural induction on e. The detailed proof is in [11].\nAlthough the hypothesis of the above theorem contains an evaluation relation, the proof\ndoes not use the run-time checks associated with the evaluation rules to prove that\nthe result of the evaluation (result and dynamic environment) is well-typed, valid and\nconsistent.\nThe progress theorem guarantees that the execution of a valid program cannot gen-\nerate danglingerr errors, by proving that those run-time checks are redundant for a\nwell-typed valid program (the run-time checks are proved by the static semantics).\nTheorem 2. (Progress) If\nvalid(e) P;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : t\n\u0393,R, \u03d5,\u03a3 \u000f \u3008\u031f,\u03a0\u3009\nthen either\n\u2022 e is a value, or\n\u2022 \u3008\u031f,\u03a0\u3009[e]\u2192\u0592nullerr or\n\u2022 there exist \u031f\u2032,\u03a0 \u2032, e\u2032 such that \u3008\u031f,\u03a0\u3009[e] \u2192\u0592 \u3008\u031f\u2032, \u03a0 \u2032\u3009[e\u2032].\nProof: By induction over the depth of the type derivation for expression e. The detailed\nproof is in [11].\nWe conclude with the following soundness theorem for region annotated Core-Java.\nThe theorem states that if a valid program is well-typed and is evaluated in a run-time\nenvironment consistent with the static environment, the result of a finite number of\nreduction steps (denoted by \u2192\u0592\u2217) is (1) either an error different from a dangling error,\n(2) or a value, (3) or that the program diverges (namely after a finite number of reduction\nsteps there still exists one more reduction step). The evaluation never reports dangling\nerrors, namely the program never creates dangling references.\nTheorem 3. (Soundness) Given a well-typed valid Core-Java program P=def\u2217 and the\nmain function (void main(void){e0})\u2208P, where e0 is a well-typed valid closed term (with-\nout free regions and free variables), such that retvars(e0)=\u2205 \u2227 retregs(e0)=\u2205 and P;\u03930;\nR0;\u03d50;\u03a30 \u22a2 e0 : void, where \u03930=\u2205, R0=\u2205, \u03d50=true, and \u03a30=\u2205 . Starting from the initial\nrun-time environment \u3008\u031f0,\u03a00\u3009, where \u031f0=[ ], \u03a00=\u2205, such that\n\u03930,R0, \u03d50, \u03a30 \u000f \u3008\u031f0,\u03a00\u3009. Then either\n(1) \u3008\u031f0,\u03a00\u3009[e0] \u2192\u0592\n\u2217\nnullerr\nor there exist a store \u031f, a variable environment \u03a0 , a value \u03b4, a type environment \u0393 , a\nset of regions R, a region constraint \u03d5, a store typing \u03a3 such that\n(2) \u3008\u031f0,\u03a00\u3009[e0] \u2192\u0592\n\u2217 \u3008\u031f,\u03a0\u3009[\u03b4] \u0393,R, \u03d5,\u03a3 \u000f \u3008\u031f,\u03a0\u3009 P;\u0393 ; R;\u03d5;\u03a3 \u22a2 \u03b4 : void\nor for a store \u031f, a variable environment \u03a0 , a valid expression e, a type environment \u0393 ,\na set of regions R, a region constraint \u03d5, a store typing \u03a3 such that\n\u3008\u031f0,\u03a00\u3009[e0] \u2192\u0592\n\u2217 \u3008\u031f,\u03a0\u3009[e] \u0393,R, \u03d5,\u03a3 \u000f \u3008\u031f,\u03a0\u3009 P;\u0393 ; R;\u03d5;\u03a3 \u22a2 e : void valid(e)\nthere exist a store \u031f\u2032, a variable environment \u03a0 \u2032, an expression e\u2032, a type environment\n\u0393 \u2032, a set of regions R\u2032, a region constraint \u03d5\u2032, a store typing \u03a3\u2032 such that\n(3) \u3008\u031f,\u03a0\u3009[e] \u2192\u0592 \u3008\u031f\u2032,\u03a0 \u2032\u3009[e\u2032] \u0393 \u2032,R\u2032,\u03d5\u2032,\u03a3\u2032 \u000f \u3008\u031f\u2032,\u03a0 \u2032\u3009 P;\u0393 \u2032;R\u2032;\u03d5\u2032;\u03a3\u2032\u22a2e\u2032:void valid(e\u2032)\nProof: The proof is an induction on the number of the reduction steps. We can repeat-\nedly use the progress theorem (Theorem 2) to prove that there is a reduction step and\nthen the preservation theorem (Theorem 1) to prove that the run-time environment after\nevaluation is still well-typed and the evaluation result is valid.\n7 Conclusion\nWe have considered a region calculus consisting of an object-oriented core language\nannotated with regions. We have defined the dynamic semantics for our region calculus\nbased on a simpler small-step rewriting relation. Some of the region calculus construc-\ntions (e.g. letreg) are firstly evaluated to intermediate constructions. Therefore the\nstatic semantics must also be extended to include these new intermediate constructions.\nWe have used a novel syntactic condition (valid(e)) to restrict the places where the\nintermediate constructions may occur in a program. This condition does not restrict\nsource-level region calculus, since intermediate constructions are generated during the\nprogram evaluation. Our dynamic semantics is instrumented with runtime checks to\nguarantee that a special danglingerr error is reported whenever the program eval-\nuation tries to create a dangling reference. We have defined an important consistency\nrelationship between the static and dynamic semantics. A store typing technique is used\nto ensure that objects created in the store during run-time are type-wise consistent with\nthose captured by the static semantics. We have proven the soundness of the region cal-\nculus by using a syntactic proof method [25], based on subject reduction and progress.\nThe subject reduction theorem ensures that the region type of a valid program is pre-\nserved during the evaluation. The progress theorem guarantees that the evaluation of a\nvalid program cannot generate danglingerr errors (namely those runtime checks are\nredundant for a well-typed valid program). We have proven both theorems in a modular\nfashion using just a simple induction. This simple soundness proof adds confidence to\nour region-based memory inference and execution systems.\nReferences\n1. David F. Bacon, Perry Cheng, and V. T. Rajan. A real-time garbage collector with low\noverhead and consistent utilization. In ACM Symposium on Principles of Programming Lan-\nguages (POPL), pages 285\u2013298, 2003.\n2. L. Birkedal and M. Tofte. A constraint-based region inference algorithm. Theoretical Com-\nputer Science, 258(1\u20132):299\u2013392, 2001.\n3. G. Bollella, B. Brosgol, P. Dibble, S. Furr, J. Gosling, D. Hardin, and M. Turnbull. The\nReal-Time Specification for Java. Addison-Wesley, 2000.\n4. Gerard Boudol. Typing safe deallocation. In European Symposium on Programming (ESOP),\npages 116\u2013130, 2008.\n5. C. Boyapati, A. Salcianu, W. Beebee, and M. Rinard. Ownership Types for Safe Region-\nBased Memory Management in Real-Time Java. In ACM Conference on Programming Lan-\nguage Design and Implementation (PLDI), pages 324\u2013337, 2003.\n6. C. Calcagno. Stratified operational semantics for safety and correctness of the region calcu-\nlus. In ACM Symposium on Principles of Programming Languages (POPL), pages 155\u2013165,\n2001.\n7. C. Calcagno, S. Helsen, and P. Thiemann. Syntactic type soundness results for the region\ncalculus. Information and Computation, 173(2):199\u2013221, 2002.\n8. Wei-Ngan Chin, Florin Craciun, Shengchao Qin, and Martin C. Rinard. Region inference\nfor an object-oriented language. In ACM Conference on Programming Language Design and\nImplementation (PLDI), pages 243\u2013254, 2004.\n9. M. V. Christiansen and P. Velschow. Region-Based Memory Management in Java. Master\u2019s\nThesis, Department of Computer Science (DIKU), University of Copenhagen, 1998.\n10. Florin Craciun, Hong Yaw Goh, and Wei-Ngan Chin. A framework for object-oriented pro-\ngram analyses via Core-Java. In IEEE International Conference on Intelligent Computer\nCommunication and Processing (ICCP), pages 197\u2013205, Cluj-Napoca, Romania, 2006.\n11. Florin Craciun, Shengchao Qin, and Wei-Ngan Chin. A Formal Soundness Proof of\nRegion-based Memory Management for Object-Oriented Paradigm. Technical report,\nDepartment of Computer Science, Durham University, UK., April 2008. Available at\nhttp:\/\/www.durham.ac.uk\/shengchao.qin\/papers\/reg cal proof.pdf.\n12. Martin Elsman. Garbage collection safety for region-based memory management. In ACM\nWorkshop on Types in Language Design and Implementation (TLDI), pages 123\u2013134, 2003.\n13. D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-Based Mem-\nory Management in Cyclone. In ACM Conference on Programming Language Design and\nImplementation (PLDI), pages 282\u2013293, 2002.\n14. S. Helsen. Region-Based Program Specialization. PhD thesis, Universita\u00a8t Freiburg, 2002.\n15. Simon Helsen and Peter Thiemann. Syntactic type soundness for the region calculus. Elec-\ntronic Notes in Theoretical Computer Science, 41(3), 2000.\n16. A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A Minimal Core Calculus for Java\nand GJ. In ACM Conference on Object-Oriented Programming Systems, Languages, and\nApplications (OOPSLA), pages 132\u2013146, 1999.\n17. Gregory Morrisett. Compiling with Types. PhD thesis, Carnegie Mellon University, 1995.\n18. J. Gregory Morrisett, Matthias Felleisen, and Robert Harper. Abstract Models of Memory\nManagement. In ACM Conference Conference on Functional Programming Languages and\nComputer Architecture (FPCA), pages 66\u201377, 1995.\n19. H. Niss. Regions are imperative. Unscoped regions and control-sensitive memory manage-\nment. PhD thesis, University of Copenhagen, 2002.\n20. B. Pierce. Types and Programming Languages. The MIT Press, 2002.\n21. M. Tofte and L. Birkedal. A region inference algorithm. ACM Transactions on Programming\nLanguages and Systems (TOPLAS), 20(4):734\u2013767, 1998.\n22. M. Tofte and J. Talpin. Implementing the Call-By-Value \u03bb-calculus Using a Stack of Re-\ngions. In ACM Symposium on Principles of Programming Languages (POPL), pages 188\u2013\n201, 1994.\n23. M. Tofte and J. Talpin. Region-based memory management. Information and Computation,\n132(2):109\u2013176, 1997.\n24. Paul R. Wilson. Uniprocessor garbage collection techniques. In International Workshop on\nMemory Management (IWMM), pages 1\u201342, 1992.\n25. Andrew K. Wright and Matthias Felleisen. A Syntactic Approach to Type Soundness. Infor-\nmation Computation, 115(1):38\u201394, 1994.\n"}