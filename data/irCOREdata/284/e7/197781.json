{"doi":"10.1007\/s10009-010-0169-3","coreId":"197781","oai":"oai:lra.le.ac.uk:2381\/10037","identifiers":["oai:lra.le.ac.uk:2381\/10037","10.1007\/s10009-010-0169-3"],"title":"LTL generalized model checking revisited","authors":["Godefroid, Patrice","Piterman, Nir"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2010-09-16","abstract":"Given a 3-valued abstraction of a program (possibly generated using static program analysis and predicate abstraction) and a temporal logic formula, generalized model checking (GMC) checks whether there exists a concretization of that abstraction that satisfies the formula. In this paper, we revisit generalized model checking for linear time (LTL) properties. First, we show that LTL GMC is 2EXPTIME-complete in the size of the formula and polynomial in the model, where the degree of the polynomial depends on the formula, instead of EXPTIME-complete and quadratic as previously believed. The standard definition of GMC depends on a definition of concretization which is tailored for branching-time model checking. We then study a simpler linear completeness preorder for relating program abstractions. We show that LTL GMC with this weaker preorder is only EXPSPACE-complete in the size of the formula, and can be solved in linear time and logarithmic space in the size of the model. Finally, we identify classes of formulas for which the model complexity of standard GMC is reduced.Peer-reviewedPost-prin","downloadUrl":"www.springerlink.com.","fullTextIdentifier":"https:\/\/lra.le.ac.uk\/bitstream\/2381\/10037\/2\/main.pdf","pdfHashValue":"30942e24ff056943a1d5006928cce88932a6e33b","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n        \n            \n                oai:lra.le.ac.uk:2381\/10037<\/identifier><datestamp>\n                2012-01-24T14:38:14Z<\/datestamp><setSpec>\n                com_2381_316<\/setSpec><setSpec>\n                com_2381_9549<\/setSpec><setSpec>\n                col_2381_1116<\/setSpec>\n            <\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:doc=\"http:\/\/www.lyncode.com\/xoai\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n            \nLTL generalized model checking revisited<\/dc:title><dc:creator>\nGodefroid, Patrice<\/dc:creator><dc:creator>\nPiterman, Nir<\/dc:creator><dc:subject>\nModel checking<\/dc:subject><dc:subject>\nGeneralized model checking<\/dc:subject><dc:subject>\nAutomata<\/dc:subject><dc:subject>\nPartial kripke structures<\/dc:subject><dc:subject>\nVerification<\/dc:subject><dc:description>\nGiven a 3-valued abstraction of a program (possibly generated using static program analysis and predicate abstraction) and a temporal logic formula, generalized model checking (GMC) checks whether there exists a concretization of that abstraction that satisfies the formula. In this paper, we revisit generalized model checking for linear time (LTL) properties. First, we show that LTL GMC is 2EXPTIME-complete in the size of the formula and polynomial in the model, where the degree of the polynomial depends on the formula, instead of EXPTIME-complete and quadratic as previously believed. The standard definition of GMC depends on a definition of concretization which is tailored for branching-time model checking. We then study a simpler linear completeness preorder for relating program abstractions. We show that LTL GMC with this weaker preorder is only EXPSPACE-complete in the size of the formula, and can be solved in linear time and logarithmic space in the size of the model. Finally, we identify classes of formulas for which the model complexity of standard GMC is reduced.<\/dc:description><dc:description>\nPeer-reviewed<\/dc:description><dc:description>\nPost-print<\/dc:description><dc:date>\n2012-01-24T14:37:02Z<\/dc:date><dc:date>\n2012-01-24T14:37:02Z<\/dc:date><dc:date>\n2010-09-16<\/dc:date><dc:type>\nJournal Article<\/dc:type><dc:identifier>\nInternational Journal on Software Tools for Technology Transfer, 2011, 13 (6), pp. 571-584<\/dc:identifier><dc:identifier>\n1433-2779<\/dc:identifier><dc:identifier>\nhttp:\/\/www.springerlink.com\/content\/223ur4q1241u3073\/<\/dc:identifier><dc:identifier>\nhttp:\/\/hdl.handle.net\/2381\/10037<\/dc:identifier><dc:identifier>\n10.1007\/s10009-010-0169-3<\/dc:identifier><dc:identifier>\n1433-2787<\/dc:identifier><dc:language>\nen<\/dc:language><dc:rights>\n\u00a9 Springer-Verlag 2010.  Deposited with reference to the publisher's archiving policy available on the Journal website.  The original publication is available at www.springerlink.com.<\/dc:rights><dc:publisher>\nSpringer<\/dc:publisher>\n<\/oai_dc:dc>\n<\/metadata>\n        <\/record>","journals":[{"title":null,"identifiers":["1433-2787","issn:1433-2779","1433-2779","issn:1433-2787"]}],"language":null,"relations":[],"year":2010,"topics":["Model checking","Generalized model checking","Automata","Partial kripke structures","Verification"],"subject":["Journal Article"],"fullText":"Software Tools for Technology Transfer manuscript No.\n(will be inserted by the editor)\nLTL Generalized Model Checking Revisited\nPatrice Godefroid1, Nir Piterman2?\n1 Microsoft Research\n2 University of Leicester\nReceived: date \/ Revised version: date\nAbstract. Given a 3-valued abstraction of a program (pos-\nsibly generated using static program analysis and predicate\nabstraction) and a temporal logic formula, generalized model\nchecking (GMC) checks whether there exists a concretiza-\ntion of that abstraction that satisfies the formula. In this paper,\nwe revisit generalized model checking for linear time (LTL)\nproperties. First, we show that LTL GMC is 2EXPTIME-\ncomplete in the size of the formula and polynomial in the\nmodel, where the degree of the polynomial depends on the\nformula, instead of EXPTIME-complete and quadratic as pre-\nviously believed. The standard definition of GMC depends on\na definition of concretization which is tailored for branching-\ntime model checking. We then study a simpler linear com-\npleteness preorder for relating program abstractions. We show\nthat LTL GMC with this weaker preorder is only EXPSPACE-\ncomplete in the size of the formula, and can be solved in\nlinear time and logarithmic space in the size of the model.\nFinally, we identify classes of formulas for which the model\ncomplexity of standard GMC is reduced.\n1 Introduction\nGeneralized model checking [BG00] is a way to improve pre-\ncision when reasoning about partially defined systems. Such\nsystems can be modeled as 3-valued Kripke structures where\natomic propositions are either true , false or unknown, de-\nnoted by the third value \u22a5. Three-valued models are a natu-\nral representation of program abstractions generated automat-\nically [GHJ01,GWC06] using static program analysis and\npredicate abstraction [GS97] for software model checking [BR01].\nFor an introduction to three-valued models we refer the reader\nto [BG99,GJ03,AHL+08].\n? Supported by the UK EPSRC project Complete and Efficient Checks for\nBranching-Time Abstractions.\nGiven a 3-valued model M and a temporal-logic formula\n\u03c6, the generalized model-checking (GMC) problem is to de-\ncide whether there exists a complete system M \u2032 that is con-\nsistent with M and that satisfies the formula \u03c6. From a prac-\ntical point of view, generalized model checking can some-\ntimes [GH05,GC05] improve verification of program abstrac-\ntions. From a theoretical point of view, studying GMC is ar-\nguably interesting in its own right since GMC generalizes\nboth model checking (when the values of all propositions\nin the model are known) and satisfiability checking (when\nall proposition values are unknown), probably the two most\nstudied problems related to temporal logic and verification.\nIn this paper, we revisit GMC for linear-time temporal-\nlogic (LTL) formulas. We start by showing that LTL GMC is\n2EXPTIME-complete in the size of the formula and polyno-\nmial in the model, where the degree of the polynomial de-\npends on the formula, instead of EXPTIME-complete and\nquadratic as previously stated erroneously in [BG00]. The\ndefinition of GMC depends on the exact notion of abstrac-\ntion, and is usually tailored for branching-time model check-\ning [BG00]. We then study a simpler linear completeness pre-\norder for relating program abstractions. We show that LTL\nGMC with this weaker preorder is only EXPSPACE-complete\nin the size of the formula, and can be solved in linear time and\nlogarithmic space in the size of the model. Finally, we iden-\ntify classes of formulas for which the model complexity of\nGMC defined with the standard branching-time completeness\npreorder is reduced.\nExample 1. Consider the program P :\nprogram P() {\nx,y = 1,0;\nx,y = 2*f(x),f(y);\nx,y = 1,0;\n}\nwhere x and y denote int variables, f : int -> int\ndenotes some unknown function, and the notation \u201cx,y =\n1,0\u201d means variables x and y are simultaneously assigned\n2 Patrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited\nvalues 1 and 0, respectively. Let \u03c61 denote the LTL formula\nFpy \u2227G(px \u2228 \u00acpy) with the two predicates px : \u201cis x odd?\u201d\nand py : \u201cis y odd?\u201d, and where F means \u201ceventually\u201d while\nGmeans \u201calways\u201d, and let \u03c62 denote the LTL formulaXpy\u2227\nG(px \u2228\u00acpy), where X means\u201cnext\u201d (see the next section for\nformal definitions).\nGiven such a program and knowing the predicate of inter-\nests px and py , predicate abstraction can be used to automati-\ncally generate the following 3-valued Kripke structure M (or\n\u201cBoolean program\u201d [BR01]) abstracting P [GHJ01]:\ninitial state s0: px = true , py = false\nnext state s1: px = false , py = \u22a5\nnext state s2: px = true , py = false\nloop forever in s2\nAs shown in [GJ02] and discussed later, model checking1 \u03c61\nand \u03c62 against M returns the value \u201cunknown,\u201d while gen-\neralized model checking can prove that no concretization of\nM can possibly satisfy either \u03c61 or \u03c62, i.e., no matter how\nfunction f is implemented.\nAlthough \u03c62 = Xpy \u2227G(px \u2228\u00acpy) is an LTL safety for-\nmula and hence is within the scope of predicate-abstraction-\nbased software model checkers such as SLAM [BR01] or\nBLAST [HJMS02], these tools cannot prove that \u03c62 does not\nhold regardless of the definition of function f: this result can\nonly be obtained through generalized model checking. In-\nstead, when confronted with such a program P , these tools\nwould attempt to iteratively refine the abstraction M by an-\nalyzing the code of function f if it is available. This process\nis in general exponential in the size of the abstraction, since\nadding a single predicate in each iteration may double the size\nof the abstraction. Moreover, this process may not terminate.\nFor the above abstraction M and formula \u03c62, the expensive\nand unpredictable abstraction-refinement process can thus be\navoided thanks to GMC. Although the worst-case complexity\nof GMC is expensive in the size of the (usually short) formula\n(but so is traditional LTL model checking which is already\nPSPACE-complete), GMC can always be done in time poly-\nnomial in the size of the model (linear or quadratic in many\ncases as shown later), in contrast with abstraction refinement\nwhich is typically exponential in the (usually large) model.\nuunionsq\n2 Preliminaries\nA partial Kripke structure (PKS for short) [BG99] is M =\n\u3008S,R,L, sin\u3009where S is a nonempty set of states,R \u2286 S\u00d7S\nis a total image-finite transition relation (i.e., every state has\na non-zero finite number of immediate successor states), L :\nS \u00d7 AP \u2192 3 is a labeling of states that associates a truth\nvalue in 3 = {true,\u22a5, false} to each atomic proposition in a\nfinite set AP , and sin \u2208 S is an initial state. For a state s and\nproposition p, we say that p is true in s if L(s, p) = true , it is\nfalse in s if L(s, p) = false , and it is unknown \u22a5 otherwise.\n1 In model checking, we mean normal 3-valued model checking in the\nsense of [BG99].\nA PKS is complete if the range of L is 2 = {true, false}.\nWe call a complete PKS a Kripke Structure or KS. When we\nwant to stress that a PKS M is complete, we denote it by M .\nGiven a state s, we denote by L(s) the function \u03c3 : AP \u2192 3\nsuch that \u03c3(p) = L(s, p). We use the notations 3AP = {\u03c3 :\nAP \u2192 3} and 2AP = {\u03c3 : AP \u2192 2}. For s \u2208 S, we denote\nby (M, s) the PKS \u3008S,R,L, s\u3009.\nA computation from s0 \u2208 S is s0, s1, . . . such that forall\ni \u2265 0 we have (si, si+1) \u2208 R. A computation pi = s0, s1, . . .\ninduces a trace L(pi) = L(s0)L(s1) \u00b7 \u00b7 \u00b7 \u2208 (3AP )\u03c9 . A com-\nputation pi is called a computation of M if s0 = sin. The\nset of computations of M that start in s is denoted C(M, s)\nand the set of induced traces is denoted L(M, s). We abbrevi-\nate C(M, sin) as C(M) and L(M, sin) as L(M). In general,\nL(M, s) \u2286 (3AP )\u03c9 . Given a PKS M = \u3008S,R,L, sin\u3009, the\nunwinding ofM into a tree is the PKSM+ = \u3008S+, R\u2032, L\u2032, sin\u3009,\nwhere S+ is the set of nonempty sequences over S, R\u2032 =\n{(s1 \u00b7 \u00b7 \u00b7 sn, s1 \u00b7 \u00b7 \u00b7 sn \u00b7sn+1) \u2208 (S+\u00d7S+) | (sn, sn+1) \u2208 R},\nand L\u2032(pi \u00b7 s) = L(s). We restrict the set S+ to the set of se-\nquences reachable from sin. If M is a Kripke structure then\nso is M+.\nTo interpret temporal logic formulas on PKSs, we extend\nKleene\u2019s strong 3-valued propositional logic [Kle87]. Con-\njunction \u2227 in this logic is defined as the minimum Min of\nits arguments with respect to the truth ordering \u2264T where\nfalse \u2264T \u22a5 \u2264T true . We extend this function to sets in the\nobvious way, with Min(\u2205) = true . Negation \u00ac is defined\nusing the function \u2018Comp\u2019 that maps true to false , false to\ntrue , and \u22a5 to \u22a5. Disjunction \u2228 is defined as usual using De\nMorgan\u2019s laws: p \u2228 q = \u00ac(\u00acp \u2227 \u00acq). Propositional modal\nlogic (PML) is propositional logic extended with the modal\noperator AX (which is read \u201cfor all immediate successors\u201d).\nFormulas of PML have the following abstract syntax:\n\u03c6 ::= p | \u00ac\u03c6 | \u03c61 \u2227 \u03c62 | AX\u03c6,\nwhere p ranges over AP . The following 3-valued semantics\ngeneralizes the traditional 2-valued semantics for PML.\nDefinition 1. The value of a formula \u03c6 of 3-valued PML in\na state s of a PKS M = \u3008S,R,L, sin\u3009, written [(M, s) |= \u03c6],\nis defined inductively as follows:\n[(M, s) |= p] = L(s, p)\n[(M, s) |= \u00ac\u03c6] = Comp([(M, s) |= \u03c6])\n[(M, s) |= \u03c61 \u2227 \u03c62] = Min({[(M, s) |= \u03c6i] | i \u2208 {1, 2}})\n[(M, s) |= AX\u03c6] = Min({[(M, s\u2032) |= \u03c6] | (s, s\u2032) \u2208 R})\nWe write [M |= \u03c6] for [(M, sin) |= \u03c6]. This 3-valued logic\ncan be used to define a preorder \u0016 on PKSs that reflects their\ndegree of completeness. Let \u2264I be the information ordering\non truth values where \u22a5 is the least element and true and\nfalse are maximal uncomparable elements:\u22a5 \u2264I true, false .\nFor two PKS Mi = \u3008Si, Ri, Li, sini \u3009 with i = 1, 2 the com-\npleteness preorder is the greatest relation \u0016 \u2286 S1 \u00d7 S2 such\nthat s1 \u0016 s2 implies all the following:\n1. For every p \u2208 AP , we have L1(s1, p) \u2264I L2(s2, p).\n2. For every (s1, s\u20321) \u2208 R1, there exists (s2, s\u20322) \u2208 R2 such\nthat s\u20321 \u0016 s\u20322.\nPatrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited 3\n3. For every (s2, s\u20322) \u2208 R2, there exists (s1, s\u20321) \u2208 R1 such\nthat s\u20321 \u0016 s\u20322.\nWe say that M2 is more complete than M1, denoted M1 \u0016\nM2, if sin1 \u0016 sin2 . It can be shown that 3-valued PML logi-\ncally characterizes the completeness preorder.\nTheorem 1. [BG99] LetM1 andM2 be partial Kripke struc-\ntures, and let \u03a6 be the set of all formulas of 3-valued PML.\nThen M1 \u0016M2 iff (\u2200\u03c6 \u2208 \u03a6 : [M1 |= \u03c6] \u2264I [M2 |= \u03c6]).\nIn other words, partial Kripke structures that are \u201cmore com-\nplete\u201d with respect to\u0016 have more definite properties with re-\nspect to \u2264I , i.e., have more properties that can be established\ntrue or false by model checking. Moreover, every formula \u03c6\nof 3-valued PML that evaluates to true or false on a partial\nKripke structure has the same truth value when evaluated on\na more complete structure.\n2.1 Model Checking and Generalized Model Checking\nThe sets of LTL and CTL formulas are defined as follows.\nLTL \u03d5 ::= p | \u03d5 \u2227 \u03d5 | \u00ac\u03d5 | X\u03d5 | \u03d5U\u03d5\nCTL \u03d5 ::= p | \u03d5 \u2227 \u03d5 | \u00ac\u03d5 | AX\u03d5 | A\u03d5U\u03d5 | E\u03d5U\u03d5\nWe assume familiarity with the semantics of LTL and CTL\nand with their model checking. As usual, we denote true U\u03d5\nby F\u03d5, \u00acF\u00ac\u03d5 by G\u03d5 and \u00ac((\u00ac\u03d5)U(\u00ac\u03c8)) by \u03d5R\u03c8. The\nabove grammar includes a complete set of operators and other\noperators can be expressed in the usual way. Given a set of\npropositions AP and an LTL formula \u03d5, the language of \u03d5,\ndenoted L(\u03d5) is the set of models of \u03d5 in (2AP )\u03c9 . Formally,\nL(\u03d5) = {w \u2208 (2AP )\u03c9 | w |= \u03d5}. The 3-valued semantics of\nLTL and CTL path formulas extend Definition 1 as expected.\nPrecisely, given a 3-valued infinite wordw = a0a1a2 \u00b7 \u00b7 \u00b7 \u2208\n(3AP )\u03c9 , the 3-valued semantics of the next LTL operator is\ndefined as\n[w |= X\u03d5] = [w\u2032 |= \u03d5]\nwith w\u2032 = a1a2 \u00b7 \u00b7 \u00b7 \u2208 (3AP )\u03c9 , while the 3-valued semantics\nof the strong until LTL operator U is defined as\n[w |= \u03d51U\u03d52] =\nMax\n({\nMin\n(\n{[ai |= \u03d51] | i < k}\u222a{[ak |= \u03d52]}\n)\n| k \u2265 0})\nFor a partial Kripke structure M and a CTL formula \u03c6,\nwe denote the value of \u03c6 at state s by [(M, s) |= \u03c6] \u2208 3AP .\nLet Path(s) denote all 3-valued infinite paths starting at s.\nThe 3-valued semantics of the CTL operators AU and EU\nare then defined as\n[(M, s) |= A\u03d51U\u03d52] =\nMin({[w |= \u03d51 U\u03d52] | w \u2208 Path(s)})\nand as\n[(M, s) |= E\u03d51 U\u03d52] =\nMax({[w |= \u03d51 U\u03d52] | w \u2208 Path(s)})\nFor the initial state sin of M we denote [(M, sin) |= \u03c6]\nby [M |= \u03c6]. If M is a Kripke structure we simply write\nM, s |= \u03d5 for [(M, s) |= \u03d5] = true and M, s 6|= \u03d5 for\n[(M, s) |= \u03d5] = false . For a Kripke structure M and an LTL\nformula \u03d5, we say that M satisfies \u03d5, denoted M |= \u03d5 if\nL(M) \u2286 L(\u03d5).\nIn practice, the size of the Kripke structureM can be pro-\nhibitively expensive or even infinite. Instead, a smaller (fi-\nnite) abstraction M \u2032 can be used: if M \u2032 is generated in such\na way that M \u2032 \u0016 M , then all the properties \u03c6 that can be\nproved (true) or disproved (false) on M \u2032 will also hold on\nM , by Theorem 1. With static program analysis and predi-\ncate abstraction, generating such abstractions with respect to\nthe completeness preorder\u0016 can be done at the same compu-\ntational cost as computing standard abstractions that merely\nsimulate (over-approximate) the concrete systemM [GHJ01].\nMoreover, 3-valued model checking can itself be done at the\nsame computational cost as regular 2-valued model check-\ning [BG00].\nIn some cases, precisely characterized in [GH05] and also\nindependently studied in [GC05], all the completions of an\nabstraction M agree on the satisfaction of a formula \u03d5, yet 3-\nvalued model checking is not accurate enough to identify this\nand still returns \u22a5. For instance, this is the case for the for-\nmula p \u2228 \u00acp if p is \u22a5. This observation suggests a more pre-\ncise version of 3-valued model checking [BG00]: the value\nof a formula \u03d5 in a PKS M should be unknown only if some\ncompletions of M satisfy \u03d5 and some completions of M fal-\nsify \u03d5 [BG00]. We denote the value of \u03d5 on M according\nto this thorough semantics by [M |= \u03d5]t \u2208 3. Formally, we\nhave the following.\n[M |= \u03d5]t = true If \u2200M \u2032 . M \u0016M \u2032 \u2192M \u2032 |= \u03d5\n[M |= \u03d5]t = false If \u2200M \u2032 . M \u0016M \u2032 \u2192M \u2032 6|= \u03d5\n[M |= \u03d5]t = \u22a5 If \u2203M1,M2 . M \u0016M1, M \u0016M2,\nM1 |= \u03d5, and M2 6|= \u03d5\nGeneralized model checking (GMC) can determine the\nvalue of [M |= \u03d5]t [BG00]. Given a PKSM and a formula \u03d5,\nthe GMC problem for M and \u03d5 is to determine whether there\nexists a Kripke structure M \u2032 that completes M and satisfies\n\u03d5. Formally, we have the following.\nM |=\u0016 \u03d5 iff there exists M \u2032 \u0017M such that M \u2032 |= \u03d5\nThe value [M |= \u03d5]t can be evaluated with two GMC\nquestions. First, we check whether M |=\u0016 \u03d5. If the answer\nis no, then all completions of M do not satisfy \u03d5 and [M |=\n\u03d5]t = false . If the answer is yes, we next check whether\nM |=\u0016 \u00ac\u03d5. If that answer is no, then we know that all com-\npletions of M satisfy \u03d5 and [M |= \u03d5]t = true . Otherwise,\n[M |= \u03d5]t = \u22a5.\nIt can be shown that 3-valued model checking is sound\nwith respect to the thorough semantics.\nTheorem 2. [BG00] Let M be a PKS and \u03d5 an LTL or CTL\nformula.\n1. [M |= \u03d5] = true implies [M |= \u03d5]t = true .\n4 Patrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited\n2. [M |= \u03d5] = false implies [M |= \u03d5]t = false .\nIn this paper we revisit LTL generalized model check-\ning and show that its complexity is greater than what was\npreviously believed. We also consider specifications (both in\nLTL and CTL) for which the model complexity of general-\nized model checking is simpler than the general case.\n2.2 Automata over Infinite Words\nWe assume familiarity with the basic notions of alternating\nautomata on infinite objects, cf. [GTW02]. We formally de-\nfine automata on infinite words and refer to automata on infi-\nnite trees without a formal proof.\nFor an alphabet\u03a3, the set\u03a3\u2217 is the set of finite sequences\nof elements from \u03a3. For x \u2208 \u03a3\u2217, we denote the length of x\nby |x|. Given an alphabet \u03a3 and a set D of directions, a \u03a3-\nlabeled D-tree is a pair \u3008T, \u03c4\u3009, where T \u2286 D\u2217 is a tree over\nD and \u03c4 : T \u2192 \u03a3 maps each node of T to a letter in \u03a3. A\npath pi of a tree T is a set pi \u2286 T such that \u000f \u2208 pi and for every\nx \u2208 pi either x is a leaf in T or there exists a unique \u03b3 \u2208 D\nsuch that x \u00b7 \u03b3 \u2208 pi. For pi = \u03b31 \u00b7 \u03b32 \u00b7 \u00b7 \u00b7 , we write \u03c4(pi) for\n\u03c4(\u000f) \u00b7 \u03c4(\u03b31) \u00b7 \u03c4(\u03b31\u03b32) \u00b7 \u00b7 \u00b7 .\nFor a finite setX , letB+(X) be the set of positive Boolean\nformulas over X (i.e., Boolean formulas built from elements\nin X using \u2227 and \u2228), where we also allow the formulas true\nand false . For a set Y \u2286 X and a formula \u03b8 \u2208 B+(X), we say\nthat Y satisfies \u03b8 iff assigning true to elements in Y and as-\nsigning false to elements in X \\Y makes \u03b8 true. An alternat-\ning word automaton is A = \u3008\u03a3, Q, qin, \u03b4, \u03b1\u3009, where \u03a3 is the\ninput alphabet,Q is a finite set of states, \u03b4 : Q\u00d7\u03a3 \u2192 B+(Q)\nis a transition function, qin \u2208 Q is an initial state, and \u03b1 spec-\nifies the acceptance condition. A run ofA onw = \u03c30\u03c31 \u00b7 \u00b7 \u00b7 is\na Q-labeled D-tree, \u3008T, \u03c4\u3009, where \u03c4(\u000f) = qin and, for every\nx \u2208 T , we have {\u03c4(x \u00b7 \u03b31), . . . , \u03c4(x \u00b7 \u03b3k)} |= \u03b4(\u03c4(x), \u03c3|x|)\nwhere {x \u00b7 \u03b31, . . . , x \u00b7 \u03b3k} is the set of children of x. A run\nof A is accepting if all its infinite paths satisfy the accep-\ntance condition. For a path pi, we denote the set of automaton\nstates visited infinitely often along this path by inf(pi), i.e.,\ninf(pi) = {q | q appears infinitely often in \u03c4(pi)}. We con-\nsider the following three acceptance conditions:\n\u2013 A path pi satisfies a Bu\u00a8chi condition \u03b1 \u2286 Q iff inf(pi) \u2229\n\u03b1 6= \u2205.\n\u2013 A path pi satisfies a co-Bu\u00a8chi condition \u03b1 \u2286 Q iff inf(pi)\u2229\n\u03b1 = \u2205.\n\u2013 A path pi satisfies a parity condition \u03b1 = \u3008F0, . . . , Fk\u3009\nwhere F0, . . . Fk form a partition of Q iff for some even\ni we have inf(pi) \u2229 Fi 6= \u2205 and forall i\u2032 < i we have\ninf(pi)\u2229Fi\u2032 = \u2205. We call k the number of priorities of \u03b1.\nFor the three conditions, an automaton accepts a word iff\nthere exists a run that accepts it. We denote by L(A) the set\nof all \u03a3-words that A accepts.\nBelow we discuss some special cases of alternating au-\ntomata. The alternating automaton A is nondeterministic if\nfor all the formulas that appear in \u03b4 are disjunctions over the\nstates Q. The automaton A is deterministic if all formulas\nthat appear in \u03b4 are states from Q. For a nondeterministic au-\ntomaton we write \u03b4 : Q \u00d7 \u03a3 \u2192 2Q and for a deterministic\nautomaton we write \u03b4 : Q\u00d7\u03a3 \u2192 Q.\nWe denote each of the different types of automata by an\nacronym in {D,N,A}\u00d7{W,B,C, P}\u00d7{W,T}, where the\nfirst letter describes the branching mode of the automaton\n(deterministic, nondeterministic, or alternating), the second\nletter describes the acceptance condition (Weak,2 Bu\u00a8chi, co-\nBu\u00a8chi, or parity), and the third letter describes the object over\nwhich the automaton runs (words or trees). For example, an\nABW is an alternating Bu\u00a8chi word automata and a DPW is a\ndeterministic parity word automata.\nWe state the following well known results about automata\nand their relation to LTL.\nTheorem 3. [VW94] For every LTL formula \u03d5 of length n\nthere exist an NBW N\u03d5 with 2O(n) states such that L(N\u03d5) =\nL(\u03d5).\nTheorem 4. [Saf88,Pit07] For every NBW N with m states\nthere exists a DPWD withO((m!)2) states and 2m priorities\nsuch that L(N) = L(D).\nCorollary 1. For every LTL formula \u03d5 of length n there ex-\nists a DPW D\u03d5 with 22\nO(n logn)\nstates and 2O(n) priorities\nsuch that L(D\u03d5) = L(\u03d5).\nTheorem 5. [Jur00] Given an APW A over a 1-letter alpha-\nbet with n states and k priorities, we can decide whether\nL(A) = \u2205 in time nO(k).\nTheorem 6. [SVW87] Given two NBW N1, N2 we can de-\ncide whether L(N1) \u2286 L(N2) in space logarithmic in N1\nand polynomial in N2.\n3 LTL Generalized Model Checking\nWe show that, contrary to previous beliefs, GMC with re-\nspect to linear time logic is 2EXPTIME-complete. Our up-\nper bound combines a DPW for the LTL property with the\nPKS to get an APW over a 1-letter alphabet. The APW is not\nempty iff the GMC problem holds. For the lower bound, we\nshow a reduction from LTL realizability to generalized model\nchecking. LTL realizability is 2EXPTIME-hard [PR89] es-\ntablishing 2EXPTIME-hardness of generalized model check-\ning. The two together establish 2EXPTIME-completeness of\ngeneralized model checking for LTL.\nTheorem 7. LTL generalized model checking M |=\u0016 \u03d5 can\nbe solved in polynomial time in the size of M and double\nexponential time in the size of \u03d5.\nProof. Consider an LTL formula \u03d5. Let |\u03d5| = n. According\nto Corollary 1 there exists a DPW D\u03d5 with 22\nO(n log n)\nstates\nand 2O(n) priorities such that L(\u03d5) = L(D\u03d5).\nLet D\u03d5 = \u30082AP , Q, q0, \u03c1, \u03b1\u3009 and M = \u3008S,R,L, sin\u3009.\nConsider the following APW A over a 1-letter alphabet that\n2 We delay the definition of weak automata to Section 5.\nPatrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited 5\nis obtained from the combination of M and D\u03d5. We define\nA = \u3008{a}, Q\u00d7 S, (q0, sin), \u03b7, \u03b1\u2032\u3009 such that\n\u03b7((q, s), a) =\n\u2228\n\u03c3\u0017L(s)\n\u2227\n(s,s\u2032)\u2208R\n(\u03c1(q, \u03c3), s\u2032)\nand \u03b1\u2032 = \u3008F \u20320, . . . , F \u2032k\u3009 is obtained from \u03b1 = \u3008F0, . . . , Fk\u3009\nby setting F \u2032j = Fj \u00d7 S.\nLemma 1. A accepts a\u03c9 iff M |=\u0016 \u03d5.\nProof. Suppose that A accepts a\u03c9 . Let \u3008T, \u03c4\u3009 be an accept-\ning run of A on a\u03c9 . Consider the following Kripke struc-\nture \u3008T,R\u2032, L\u3009 where R\u2032(x, xa) for every x, xa \u2208 T and\nL : T \u2192 2AP is defined as follows. Consider a node x\nwhere \u03c4(x) = (q, s) and {xa1, . . . , xak} is the set of chil-\ndren of x. By definition of a run of A, there is a function\n\u03c3 : AP \u2192 {true, false} such that {\u03c4(xa1), . . . , \u03c4(xak)} |=\u2227\n(s,s\u2032)\u2208R(\u03c1(q, \u03c3), s\n\u2032). We define L(x) to be this function \u03c3.\nIt is easy to see that \u3008T,R\u2032, L\u3009 is a Kripke structure that\nis more complete than M . Moreover, for every path pi in\n\u3008T,R\u2032, L\u3009, the projection of \u03c4 on the states ofD\u03d5 for this path\ndefines an accepting run of D\u03d5 and implies that L(pi) |= \u03d5.\nConversely, suppose that there exists a Kripke structure\nK = \u3008S,R,L, s0\u3009 such that M \u0016 K and K |= \u03d5. Con-\nsider the unwinding K+ = \u3008S+, R\u2032, L\u2032, s0\u3009 of K. We con-\nstruct a labeling \u03c4 : S+ \u2192 Q \u00d7 S such that for every node\nx = s0s1 \u00b7 \u00b7 \u00b7 sn we have \u03c4(x) associates x to a state s of\nM such that s \u0016 sn and to a state q of D\u03d5 such that q =\n\u03c1(q0, L(s0 \u00b7 \u00b7 \u00b7 sn\u22121)). Note that q is unique for a given se-\nquence s0 \u00b7 \u00b7 \u00b7 sn\u22121 as the automatonD\u03d5 is deterministic. Ini-\ntially, \u03c4(s0) = (q0, sin). Obviously, sin \u0016 s0. Consider a\nnode x = s0s1 \u00b7 \u00b7 \u00b7 sn such that \u03c4(x) = (q, s). Let xsn+1 be a\nchild of x. Then \u03c4(xsn+1) = (q\u2032, s\u2032) where q\u2032 = \u03c1(q, L(sn))\nand as s \u0016 sn there exists a successor s\u2032 of s such that\ns\u2032 \u0016 sn+1. It is easy to see that \u3008S+, \u03c4\u3009 is a run tree of A\non a\u03c9 . By assumption every trace of K is accepted by D\u03d5.\nIt follows that every infinite path in \u3008S+, \u03c4\u3009 is labeled by an\naccepting run of D\u03d5 and that \u3008S+, \u03c4\u3009 is accepting. uunionsq\nAccording to Theorem 5 the emptiness of A can be deter-\nmined in time proportional to (22\nO(n log n)\n)2\nO(n)\n= 22\nO(n log n)\n.\nuunionsq\nNote that, if D\u03d5 was nondeterministic in the previous\nproof, it could not precisely track simultaneously different\nmatching states s such that s \u0016 sn in the proof, and there-\nfore M |=\u0016 \u03d5 would not necessarily imply that A accepts\na\u03c9 . This is in essence the error in the proof of Theorem 25\nof [BG00], which led to the overly optimistic EXPTIME upper-\nbound.\nExample 2. Consider the partial Kripke structure M in Fig-\nure 1. The structure M is an extended version of the program\ndepicted in Example 1. Consider the formula \u03d5 = F (\u00acpx \u2227\npy) \u2228 G(\u00acpy). There is a concretization of M that satisfies\n\u03d5. Indeed, if we set py = true in state s2, then both traces of\nM satisfy \u03d5. Denote this concretization by Kt. Suppose that\nD is an automaton for \u03d5. Our algorithm uses D to construct\nan APW over 1-letter alphabet that guesses the labels of Kt\nand runsD simultaneously on all traces ofKt. We demanded\nthat D be a deterministic automaton.\nConsider the NBW N\u03d5 for \u03d5 depicted in Figure 1. The\nNBWN\u03d5 is not strong enough to notice thatKt satisfies \u03d5. A\ncomposition ofN\u03d5 andM would start in state (s0, q0). Then,\nN\u03d5 reads the initial state px \u2227 \u00acpy of Kt and it has to guess\nwhether to go to state q1 or q2. That is, whether the APW will\nmove to state (s1, q1) or (s1, q2). However, there is no run of\nN\u03d5 starting from q1 that accepts the path s1, s2, s3, . . . and\nthere is no run of N\u03d5 starting from q2 that accepts the path\ns1, s4, s5, . . .. Effectively,N\u03d5 has to choose whether all paths\nof Kt satisfy G(\u00acpy) (by choosing the transition to state q1)\nor all paths of Kt satisfy F (\u00acpx \u2227 py) (by choosing the tran-\nsition to state q2). It follows that the language of an APW\nthat is obtained from the composition of Kt with N\u03d5 would\nbe empty, failing to show that M |=\u0016 \u03d5.\nConsider now the DBW D\u03d5 for \u03d5 depicted in Figure 1.\nThe ABW over 1-letter alphabet that is the result of the com-\nposition of M and D\u03d5 makes no guesses regarding the fu-\nture. Thus, an accepting run of this ABW has two paths. The\nfirst path is (s0, d0), (s1, d0), (s4, d0), (s5, d0), . . .. The sec-\nond path is (s0, d0), (s1, d0), (s2, d0), (s3, d1), . . ., where the\ntransition from (s2, d0) to (s3, d1) guesses locally that the la-\nbel of py in s2 is true. Both paths visit accepting states (d1\nand d0, respectively) infinitely often. The two paths share the\nprefix (s0, d0), (s1, d0) giving rise to a single run tree of the\nABW. uunionsq\nWe now proceed to the lower bound. We start with a def-\ninition of LTL realizability. Consider a set of propositions\nAP = I \u222a O of input and output signals, respectively. Let\nL be a language of infinite words over alphabet 2AP . The re-\nalizability problem for L is to decide whether there exists a\nstrategy f : (2I)+\u21922O such that all the computations gener-\nated by f are in L. A computation pi = (i0, o0), (i1, o1), . . .\nis generated by f if for all j \u2265 0 we have oj = f(i0i1 \u00b7 \u00b7 \u00b7 ij).\nThe realizability problem for an LTL formula \u03d5 is the realiz-\nability problem for L(\u03d5).\nTheorem 8. [PR89] The realizability problem for an LTL\nformula \u03d5 is 2EXPTIME-hard in the size of \u03d5.\nTheorem 9. LTL Generalized model checking M |=\u0016 \u03d5 is\n2EXPTIME-hard in the size of \u03d5.\nProof. We show how to solve realizability of an LTL for-\nmula using the generalized model checking problem. The idea\nbehind the reduction is that the PKS includes determined val-\nues of the inputs and undetermined values of the outputs. The\nbranching of the PKS forces all possible assignments to in-\nputs as possible successors of every state. Thus, every com-\npletion of the PKS associates an assignment to the outputs\nwith every possible assignment to inputs and is in essence\na strategy. If the completion satisfies the LTL formula, then\nso does the strategy. The PKS has 2I different states, each la-\nbeled by the appropriate assignment to the input variables and\nwith transitions between every two possible states. Formally,\nwe have the following.\n6 Patrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited\ns4\ns1\npy=f\npy=f\npx=t\npy=\u22a5\npx=f\npy=t\npx=t\ns5\npy=f\npx=t\npx=t\ns0\npy=f\npx=t\nM :\ns3s2\npy\nt\nq1\nq2\nt\n\u00acpx \u2227 py\n\u00acp\nx \u2227 p\ny\n\u00acpy\nN\u03d5:\n\u00acpy\nt\nq0\nq3 t q4\npx \u2227 py\nd0 d1\nd2\n\u00acpx \u2227 py\nt\n\u00acpy\npx \u2228 \u00acpy\nD\u03d5: \u00acpx\n\u2227 p\ny\nFig. 1. Partial Kripke Structure M showing the difference between usage of NBW N\u03d5 and DBW D\u03d5, where \u03d5 = F (\u00acpx \u2227 py) \u2228 G(\u00acpy). Transitions of\nboth automata are labeled with formulas over propositions. In particular, transitions labeled with t read all possible input letters.\nConsider the PKS M = \u3008S,R,L, sin\u3009 with S = 2I , R =\nS\u00d7S, and sin \u2208 S is chosen arbitrarily. For every proposition\ni \u2208 I we have L(s, i) = true if i \u2208 s and L(s, i) = false\notherwise. For every proposition o \u2208 O we haveL(s, o) = \u22a5.\nConsider the problem of generalized model checking of X\u03d5\non M .\nSuppose that M |=\u0016 X\u03d5. There exists M \u2032 = \u3008S\u2032, R\u2032,\nL\u2032, s\u20320\u3009 such that M \u0016 M \u2032 and M \u2032 |= X\u03d5. For every state\nt \u2208 S\u2032 and every assignment \u03c3 : I \u2192 {true, false} there\nexists a state t\u2032 \u2208 S\u2032 such that (t, t\u2032) \u2208 R\u2032 and L(t\u2032) agrees\nwith \u03c3 on all the propositions in I . For \u03c3 \u2208 2I let \u03c3(t) denote\nthis state t\u2032. It follows that every sequence \u03c31 \u00b7 \u00b7 \u00b7\u03c3k \u2208 (2I)+\ninduces a sequence s\u20321, . . . , s\n\u2032\nk such that s\n\u2032\n1 = \u03c31(s\n\u2032\n0) and\ns\u2032i+1 = \u03c3i+1(s\n\u2032\ni). Denote s\n\u2032\n1, . . . , s\n\u2032\nk by \u03c31 \u00b7 \u00b7 \u00b7\u03c3k(s\u20320) and let\nO(s\u20321, . . . , s\n\u2032\nk) denote the projection of L\n\u2032(s\u2032k) on the propo-\nsitions in O. Consider the strategy f : (2I)+\u21922O where\nfor w \u2208 (2I)+ we set f(w) = O(w(s\u20320)). Consider a com-\nputation pi = (i1, o1), . . . generated by f . By construction\n(i0, o0), (i1, o1), . . . is a computation of M where (i0, o0) =\nL\u2032(s\u20320). As M \u2032 |= X\u03d5 we conclude that pi |= \u03d5.\nSuppose that \u03d5 is realizable. There exists a strategy f :\n(2I)+ \u2192 2O such that every computation induced by f sat-\nisfies \u03d5. Consider the tree \u3008(2I)\u2217, L\u2032\u3009 where L\u2032(w \u00b7 i) =\ni \u222a f(w) and L\u2032(\u000f) agrees with L(sin) on the propositions\nin I . It is simple to see that \u3008(2I)\u2217, L\u2032\u3009 completes M and sat-\nisfies X\u03d5.\nThis construction results in an exponential PKS. It fol-\nlows, that a generalized model checking algorithm that is ex-\nponential in the input PKS would not constitute a violation to\nthe 2EXPTIME-hardness of LTL realizability. We show how\nto replace the exponential PKS with a PKS that has two states.\nThe structure uses the propositions {p, z} \u222a O. Let n = |I|.\nA state s in the structure above is represented by a sequence\ns1 . . . sn of n states. The assignment to ij is the assignment\nto p in state sj and the assignment to O is the assignment to\nO in state sn. Specifically, M = \u3008S,R,L, sp\u3009 where S =\n{sp, sp}, R = S\u00d7S, and L(sp, p) = true , L(sp, p) = false ,\nand L(s, q) = \u22a5 for s \u2208 S and q \u2208 O\u222a{z}. The proposition\nz is going to mark the beginning of a sequence of n states.\nWe now rewrite the LTL formula \u03d5 into a new LTL for-\nmula that relativizes the occurrence of an input ij in \u03d5 to the\nnew location representing the value of ij (by replacing ij by\nXj\u22121p), relativizes the occurrence of an output o in \u03d5 to the\nnew location Xn\u22121o, and relativizes the truth values of all\nother operators to the locations where z is true . Formally, we\ndefine g : LTL\u2192 LTL as follows.\n1. g(ij) = Xj\u22121p for ij \u2208 I\n2. g(o) = Xn\u22121o for o \u2208 O\n3. g(\u03d5 \u2227 \u03c8) = g(\u03d5) \u2227 g(\u03c8)\n4. g(\u00ac\u03d5) = \u00acg(\u03d5)\n5. g(X\u03d5) = Xng(\u03d5)\n6. g(\u03d5U\u03c8) = ((z \u2192 g(\u03d5))U(z \u2227 g(\u03c8)))\nFinally, let\n\u03d5z = (\u00acz \u2227Xz)\u2227\nG(z \u2192 (X(\u00acz \u2227X(\u00acz \u2227 . . . \u2227X(\u00acz \u2227X\ufe38 \ufe37\ufe37 \ufe38\nn next operators\nz))))))\nWe set \u03d5\u2032 = \u03d5z \u2227Xg(\u03d5). We note that the length of g(\u03d5) is\nlinear in |I| \u00b7 |\u03d5| and the length of \u03d5z is linear in |I|.\nWe define a transformation on words that takes a word\nover 2{p,z}\u222aO and produces a word over 2I\u222aO that matches\nthe transformation g for LTL formulas. Consider a word w =\n\u03c30\u03c31 \u00b7 \u00b7 \u00b7 \u2208 2{p,z}\u222aO. Let g(w) denote the wordw\u2032 = \u03c3\u20321 \u00b7 \u00b7 \u00b7 \u2208\n2I\u222aO such that \u03c3\u2032m(ij) = \u03c3(m\u22121)n+j(p) and \u03c3\n\u2032\nm(o) = \u03c3mn(o).\nSuppose that w |= \u03d5z . For every LTL formula \u03d5 and every\nlocation n we can show by induction on the structure of \u03d5\nthat g(w), n |= \u03d5 iff w, (m\u2212 1)n+ 1 |= g(\u03d5). 3\nSuppose that \u03d5 is realizable by strategy f . We translate\nf to a labeling of the {0, 1}\u2217 tree in the obvious way. Every\nnode x0 is labeled by \u00acp and every node x1 is labeled by\np. Every node x such that |x| is a multiple of n plus 1 is\nlabeled by z and all others are labeled by \u00acz. Every node x\nsuch that |x| is a multiple of n is labeled by the appropriate\nassignment to the propositions in O. For every other node\nx, the assignment to propositions in O is arbitrary. Consider\na path in the resulting tree. It is simple to see that the path\nsatisfies \u03d5z . As the original path satisfies \u03d5 we can show that\nthe result satisfies Xg(\u03d5) as well.\nSuppose that there is a structureK that completesM such\nthat K |= \u03d5\u2032. Consider the unwinding K+ of K. As K is\ncomplete, so is K+. Let K+ = \u3008T,R\u2032, L\u2032, sin\u3009. We abuse\nnotation and denote by K+ a pruning of K+ that includes\nfor every state t \u2208 T exactly one state t\u2032 such that (t, t\u2032) \u2208 R\u2032\nand p \u2208 L\u2032(t\u2032) and exactly one state t\u2032\u2032 such that (t, t\u2032\u2032) \u2208 R\u2032\nand p \/\u2208 L\u2032(t\u2032\u2032). In addition, we identify a sequence pi \u2208\n{0, 1}\u2217 with the state t \u2208 T such that \u000f is identified with sin\nand pi1 is identified with the successor t\u2032 of pi such that p \u2208\nL\u2032(t\u2032) and pi0 is identified with the successor t\u2032\u2032 of pi such that\np \/\u2208 L\u2032(t\u2032\u2032). Consider a letter \u03c3 \u2208 2I , we identify \u03c3 with the\nsequence in \u03b11 \u00b7 \u00b7 \u00b7\u03b1n \u2208 {0, 1}n such that \u03b1j = 1 iff ij \u2208 \u03c3.\n3 Note that w starts from location 0 and t(w) from location 1.\nPatrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited 7\nFinally, we use the same notation for sequences in (2I)\u2217. We\nare now ready to define the strategy f : (2I)\u2217 \u2192 2O. For a\nsequence pi \u2208 (2I)\u2217 we set f(pi) = L\u2032O(pi). It is simple to see\nthat every computation induced by f satisfies \u03d5.\nWe note that it is possible also to reduce the number of\npropositions used in M to three by doing a similar encod-\ning for the outputs using a single proposition q. The cycle\ninduced by z has to grow to size |I \u222a O| and in addition the\nformula has to be modified to notice just the path labeled by\np in the positions (|I|+ 1), . . . , (|I|+ |O|).\nuunionsq\nBy Theorems 7 and 9 we have the following.\nCorollary 2. LTL Generalized model checking M |=\u0016 \u03d5 is\n2EXPTIME-complete in the size of \u03d5.\n4 Linear Completeness Preorder\nThe completeness preorder \u0016 used to define the generalized\nmodel checking relation |=\u0016 is stronger than necessary for\nreasoning only about the linear behaviors of partial Kripke\nstructures. Indeed, the completeness preorder reduces to a\nbisimulation relation in the case of complete Kripke struc-\ntures, and Kripke structures that satisfy the same LTL formu-\nlas are not necessarily bisimilar.\nIn this section, we study a simpler linear completeness\npreorder \u0016L, first suggested in [BG00], that relates partial\nKripke structures using only their sets of (3-valued) traces.\nThen we show that generalized model checking |=\u0016L defined\nwith respect to this linear preorder is \u201conly\u201d EXPSPACE-\ncomplete.\nGiven two infinite 3-valued tracesw=L(s0)L(s1) \u00b7 \u00b7 \u00b7 and\nw\u2032=L(s\u20320)L(s\n\u2032\n1) \u00b7 \u00b7 \u00b7 in (3AP )\u03c9 , we writew \u2264I w\u2032 if \u2200i \u2265 0 :\n\u2200p \u2208 AP : L(si, p) \u2264I L(s\u2032i, p).\nDefinition 2. For two PKS Mi = \u3008Si, Ri, Li, sini \u3009 with i =\n1, 2, the linear completeness preorder \u0016L is the greatest re-\nlation \u0016L \u2286 S1 \u00d7 S2 such that (s1, s2) \u2208 \u0016L implies all the\nfollowing.\n1. For every w \u2208 L(M1, s1) there exists w\u2032 \u2208 L(M2, s2)\nsuch that w \u2264I w\u2032.\n2. For every w\u2032 \u2208 L(M2, s2) there exists w \u2208 L(M1, s1)\nsuch that w \u2264I w\u2032.\nIt is easy to show that 3-valued LTL logically characterizes\nthe linear completeness preorder.\nTheorem 10. For every two PKSM1 andM2, we haveM1 \u0016L\nM2 iff for every LTL formula \u03d5 we have [M1 |= \u03d5] \u2264I\n[M2 |= \u03d5].\nProof. AssumeM1 \u0016L M2 and consider an LTL formula \u03d5.\nIf [M1 |= \u03d5] = \u22a5, we always have [M1 |= \u03d5] \u2264I [M2 |= \u03d5].\nIf [M1 |= \u03d5] = true , then for all w \u2208 L(M1), [w |=\n\u03d5] = true . By point 2 of Definition 2, for every w\u2032 \u2208 L(M2)\nthere exists w \u2208 L(M1) such that w \u2264I w\u2032. But since \u2200w \u2208\nL(M1) : [w |= \u03d5] = true , we have \u2200w\u2032 \u2208 L(M2) : [w\u2032 |=\n\u03d5] = true , and hence [M2 |= \u03d5] = true .\nIf [M1 |= \u03d5] = false , then \u2203w \u2208 L(M1) : [w |= \u03d5] =\nfalse . By point 1 of Definition 2, we have \u2203w\u2032 \u2208 L(M2) :\nw \u2264I w\u2032 and hence [w\u2032 |= \u03d5] = false . Thus [M2 |= \u03d5] =\nfalse , and the first direction of the theorem holds.\nConversely, let s1 v s2 denote \u2200\u03d5 \u2208 LTL : [(M1, s1) |=\n\u03d5] \u2264I [(M2, s2) |= \u03d5]. Assume that s1 v s2 but that s1 6\u0016L\ns2: thus, either point 1 or 2 of Definition 2 is violated.\nAssume point 1 is violated: \u2203w \u2208 L(M1, s1) : \u2200w\u2032 \u2208\nL(M2, s2) : w 6\u2264I w\u2032. Let w = s01s11s21 \u00b7 \u00b7 \u00b7 with s01 = s1. Let\nS02 = {s2} and for k > 0, let Sk2 = {s \u2208 S2 | s\u2032 \u2208 Sk\u221212 \u2227\n(s\u2032, s) \u2208 R2 \u2227 (\u2200p \u2208 AP : L1(sk1 , p) \u2264I L2(s, p))}. Since\n\u2200w\u2032 \u2208 L(M2, s2) : w 6\u2264I w\u2032, then there must exist a value\nof k such that Sk2 = \u2205. In other words, the corresponding sk1\nin M1 denote the first state in M1 reachable from s1 along w\nwhose label cannot be \u201cmatched\u201d (according to the previous\nformal definition) by even one state of M2 (hence also reach-\nable in k steps from s2). We identified k such that Sks = \u2205.\nLet T k2 = {s \u2208 S2 | s\u2032 \u2208 Sk\u221212 \u2227 (s\u2032, s) \u2208 R2} (by construc-\ntion, we know Sk\u221212 6= \u2205 and since every state has at least\none successor state, T k2 is nonempty as well). Thus, for each\nstate s \u2208 T k2 , there exists a proposition p \u2208 AP such that\nL1(sk1 , p) 6\u2264I L2(s, p). Let \u03d5(s) = p if L1(sk1 , p) = false\nand let \u03d5(s) = \u00acp otherwise (i.e., when L1(sk1 , p) = true; if\nL1(sk1 , p) = \u22a5, then trivially L1(sk1 , p) \u2264I L2(s, p)). Con-\nsider the LTL formula\n\u03c8 = (\n\u2227\ni<k(X\ni(\u03d5L(si1))))\u21d2 Xk\n\u2228\ns\u2208Tk2 \u03d5(s),\nwhere \u03d5L(si1) =\n\u2227\nL(si1,p)=true\np \u2227\n\u2227\nL(si1,p)=false\n\u00acp\nWe have [(M1, s1) |= \u03c8] = false (as we know [w |= \u03c8] =\nfalse) while [(M2, s2) |= \u03c8] 6= false (since the antecedent of\nthe logical implication is true exactly for finite paths leading\nto states in Sk\u221212 and the consequent is either true or \u22a5 for\nall states in T k2 ). A contradiction with s1 v s2.\nAssume point 2 is violated: \u2203w\u2032 \u2208 L(M2, s2) : \u2200w \u2208\nL(M1, s1) : w 6\u2264I w\u2032. Using the same line of reasoning as in\nthe previous case, let sk2 denote the first state inM2 reachable\nfrom s2 along w\u2032 whose label cannot be matched by even one\nstate in Sk1 of M1 as defined above. Thus, for each state s \u2208\nSk1 , there exists a proposition p \u2208 AP such that L1(s, p) 6\u2264I\nL2(sk2 , p). Let \u03d5(s) = p if L1(s, p) = true and let \u03d5(s) =\n\u00acp otherwise. Consider the LTL formula\n\u03c8 = (\n\u2227\ni<k(X\ni(\u03d5L(si2))))\u21d2 Xk\n\u2228\ns\u2208Sk1 \u03d5(s),\nwhere \u03d5L(si2) =\n\u2227\nL(si2,p)=true\np \u2227\n\u2227\nL(si2,p)=false\n\u00acp \u2227\u2227\nL(si2,p)=\u22a5\n(p \u2227 \u00acp)\nWe have [(M1, s1) |= \u03c8] = true (since the antecedent of the\nlogical implication is either true or \u22a5 exactly for the finite\npaths leading to states in Sk\u221211 and the consequent is true\nfor all states in Sk1 ) while [(M2, s2) |= \u03c8] 6= true (since\n[w\u2032 |= \u03c8] 6= true). A contradiction with s1 v s2. uunionsq\n8 Patrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited\nGiven a PKSM and an LTL formula\u03d5, generalized model\nchecking with respect to the linear completeness preorder\u0016L\nmeans checking whether every 3-valued trace of M can be\ncompleted to a 2-valued trace that satisfies \u03d5. Formally, we\nhave the following.\nM |=\u0016L \u03d5 iff \u2200w \u2208 L(M) :\n\u2203 a complete w\u2032 such that w \u2264I w\u2032 and w\u2032 |= \u03d5\nAs observed in [GJ02], computing the value of [M |=\n\u03d5]t for an LTL formula \u03d5 can be reduced to one normal (2-\nvalued) model checking problem and one generalized model\nchecking problem, regardless of which completeness preorder\nis used. One can start by checking whether there exists a com-\npletion w\u2032 of every trace w in M such that w\u2032 6|= \u03d5. To do\nthis, one can build a Kripke structure M c that guesses all\npossible completions of labelings of states of M and thus\naccepts all the possible completions of traces of M . Then,\none checks whether M c |= \u03d5 using traditional 2-valued LTL\nmodel checking, which is a PSPACE-complete problem. If\nM c |= \u03d5, all possible completions of M satisfy \u03d5, which\nmeans [M |= \u03d5]t = true and we stop. Otherwise, one needs\nto solve a second, more expensive generalized model check-\ning problem to determine whether there exists some comple-\ntion M \u2032 of M whose traces all satisfy \u03d5.\nIf one considers the completeness preorder \u0016, checking\nfor such a completion M \u2032 \u0017M such that M \u2032 |= \u03d5, i.e., com-\nputing M |=\u0016 \u03d5, is 2EXPTIME-complete as shown in the\nprevious section. However, if one considers instead the lin-\near completeness preorder \u0016L, we now show that computing\nM |=\u0016L \u03d5 is only EXPSPACE-complete.\nTheorem 11. LTL generalized model checking M |=\u0016L \u03d5\nwith respect to the linear completeness preorder \u0016L can be\nsolved in space logarithmic in the size of M and exponential\nin the size of \u03d5.\nProof. Consider an LTL formula \u03d5. According to Theorem 3\nthere exists an NBW N\u03d5 = \u30082AP , Q, q0, \u03c1, F \u3009 where |Q| =\n2O(|\u03d5|) such that L(N\u03d5) = L(\u03d5).\nWe modify the NBW above to an NBW over the alpha-\nbet 3AP that accepts partial traces that have a completion in\nL(N\u03d5). Formally, we have the following.\nWe denote letters in 2AP by \u03c3 and letters in 3AP by \u03c4 . Let\nN \u2032 be the automaton obtained from N\u03d5 by guessing a com-\npletion of the read letter. Formally, N \u2032 = \u30083AP , Q, q0, \u03c1\u2032, F \u3009\nwhere\n\u03c1\u2032(s, \u03c4) =\n\u2228\n\u03c3\u0017\u03c4\n\u03c1(s, \u03c3)\nNow, all that we have to check is whether L(M) \u2286 L(N \u2032).\nFrom Theorem 6, we know that this problem can be solved\nin space logarithmic in M and polynomial in N \u2032. As N \u2032 is\nexponential in \u03d5, the upper bound follows. uunionsq\nExample 3. We revisit the partial Kripke structure M de-\npicted in Figure 1. Let \u03d5 = F (\u00acpx \u2227 py) \u2228 G(\u00acpy). We\nrecall that M |=\u0016 \u03d5 and validate that M |=\u0016L \u03d5. This time,\nit is sufficient to use the automaton N\u03d5 in Figure 1.\nThe construction calls for replacing a transition over \u03c3\nwith transitions over \u03c3 for every \u03c3 \u0016 \u03c3. In this case, a transi-\ntion from q2 to q3 is added reading the letter \u00acpx \u2227 (py=\u22a5).\nWith this transition in place, the run q0, q2, q2, q3, . . . accepts\nthe trace generated by s0, s1, s2, s3, . . .. Using the existing\ntransitions, the run q0, q1, q1, q1, . . . accepts the trace gener-\nated by s0, s1, s4, s5, . . .. uunionsq\nWe now show that using this definition of GMC we can\nsolve an EXPSPACE-hard tiling problem [vEB97]. In tiling\nproblems we get a finite set of different types of tiles and we\nhave to tile a floor of a given dimension. We may use as many\ntiles as we want from every given type, however, there are\nrules that tell us which tiles are allowed to be next to each\nother according to vertical and horizontal rules. There are\nmany different flavors of tiling problems with different com-\nplexities. Here we introduce the EXPSPACE version of the\ntiling problem. In order to prove the lower bound, we build\na PKS M whose traces are all the possible arrangements of\ntiles. A trace has a completion that satisfies our LTL formula\n\u03d5 if the arrangement of tiles is not valid, i.e., it violates one\nof the tiling rules. That is, M |=\u0016L \u03d5 iff all possible arrange-\nments of tiles are not valid, i.e., the tiling problem does not\nhave a solution.\nA tiling problem is \u3008T,H, V, s, t, n\u3009, where T is a finite\nset of tiles, H,V \u2286 T \u00d7 T are horizontal and vertical con-\nsistency rules, s, t \u2208 T are initial and final tiles, and n is a\nnumber (in unary). The decision problem is whether there\nexists a number m and a function f : [2n] \u00d7 [m] \u2192 T\nsuch that f(1, 1) = s, f(2n,m) = t, and forall i, j we\nhave (f(i, j), f(i + 1, j)) \u2208 H and (f(i, j), f(i, j + 1)) \u2208\nV . That is, arrange the tiles in a 2n times m rectangle such\nthat s is in the bottom left corner, t in the top right corner,\nand all neighbors (vertical\/horizontal) satisfy the horizontal\nand vertical consistency rules. This problem is EXPSPACE-\ncomplete [vEB97].\nTheorem 12. LTL generalized model checkingM |=\u0016L with\nrespect to the linear completeness preorder\u0016L is EXPSPACE-\nhard in the size of \u03d5.\nProof. We start by representing the rectangular arrangement\nof tiles by a linear sequence of tiles. An (infinite) linear se-\nquence of tiles represents a valid tiling if it starts with s, has t\nin locationm2n for somem, every adjacent locations (except\nmultiples of 2n and their successors) satisfyH , and every two\nlocations whose distance is 2n satisfy V .\nWe construct a simple system that produces all possible\nsequences of tiles. The partial propositions are going to num-\nber every tile in the sequence with a number in [0..(2n \u2212\n1)]. The LTL formula checks two things. First, that the truth\nassignments to partial propositional variables behave like a\ncounter (it is always possible to complete the values of these\npropositions in this way). Second, that every possible sequence\nof tiles contains one of the following problems: either (a) it\ndoes not start in s, or (b) all locations that are multiples of\n2n are not t, or (c) the horizontal rule is violated before t\nappears in a 2n-multiple location, or (d) the vertical rule is\nPatrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited 9\nviolated before t appears in a 2n-multiple location. If one of\nthese problems occurs, then the tiling is not valid. If all possi-\nble arrangements of tiles are not valid, then the tiling problem\ndoes not have a solution.\nSuppose that |T | = I = 2k, then the system is the I-\nclique. We have k propositions {p1, . . . , pk} and every state\nencodes one possible tile. The initial state is the state that\ncorresponds to s. We have n propositions {q1, . . . , qn} that\nencode the location of the tile modulo 2n. Finally, we have\ntwo more propositions {a, b} that are used to identify the lo-\ncation of a violation of the vertical rule. In all states of the\nsystem the value of {a, b, q1, . . . , qn} is unknown. Formally,\nlet M = \u3008S,R,L, s\u3009 where S = 2{p1,...,pk}, R = S \u00d7 S,\nL(t, pi) = true if pi \u2208 t, L(t, pi) = false if pi \/\u2208 t, L(t, q) =\n\u22a5 for q \u2208 {a, b, q1, . . . , qn}, and by abuse of notation s is the\nstate that corresponds to the initial tile s.\nThe LTL formula is \u03d5 = \u03d51 \u2227 \u03d52, where \u03d51 and \u03d52 are\ndefined below.\n1. Counter consistency \u2013 \u03d51 is conjunction of the following\nformulas.\n(a) The counter starts at 0:\nn\u2227\nj=1\n\u00acqj\n(b) The counter respects normal counting:\nG (q1 \u2194 X\u00acq1) \u2227\nG\n\uf8eb\uf8ed n\u2227\nj=2\n(( \u2227\nj\u2032<j\nqj\u2032\n)\u2192 (qj \u2194 X\u00acqj))\n\uf8f6\uf8f8 \u2227\nG\n\uf8eb\uf8ed n\u2227\nj=2\n(( \u2228\nj\u2032<j\n\u00acqj\u2032\n)\u2192 (qj \u2194 Xqj))\n\uf8f6\uf8f8\n2. The formula \u03d52 describes the possible problems in the se-\nquence of tiles. Let \u03c6e stand for (\nn\u2227\nj=1\nqj), i.e., the counter\nis 2n\u22121 and let \u03c6t stand for (\u03c6e \u2192 \u00act), i.e., if the counter\nis 2n\u2212 1 the tile is not t. The formula \u03d52 is the disjunction\nof the following formulas.\n(a) The sequence does not start with tile s: \u00acs.\n(b) Every 2n multiple is not marked with tile t: G\u03c6t.\n(c) The horizontal rule is violated somewhere that is not\nthe end of a configuration and before the appearance of\nt at the end of a configuration:(\n\u00ac\u03c6e \u2227\n( \u2227\n(p,p\u2032)\u2208H\n\u00acp \u2228X\u00acp\u2032))R\u03c6t\n(d) The propositions a and b are used to find a violation\nof the vertical rules. The disjunct of \u03d52 that expresses\na violation of the vertical rule is the conjunction of the\nfollowing:\ni. The proposition a is assigned true exactly once, and\nb is assigned true after it:\n(\u00aca)U(a \u2227XG\u00aca \u2227XFb).\nii. The proposition b is assigned true exactly once:\n(\u00acb)U(b \u2227XG\u00acb).\niii. The location where b is assigned true occurs before\na location where t marks a location that is a multiple\nof 2n \u2212 1: bR\u03c6t.\niv. The locations where a and b are true agree on the\ncounter valuation: G(a\u2192\nn\u2227\nj=1\n(qj \u2194 F (b \u2227 qj))).\nv. There is exactly one occurrence of 2n \u2212 1 between\nthe locations where a and b are assigned true: G(a\u2192\n\u00ac\u03c6eU(\u03c6e \u2227X(\u00ac\u03c6eUb)))\nvi. The locations marked by a and b violate the vertical\nconsistency:\u2227\n(p,p\u2032)\u2208V\n(F (a \u2227 p)\u2192 G(b\u2192 \u00acp\u2032))\nLemma 2. We have M |=\u0016L \u03d5 iff T does not have a solu-\ntion.\nProof. Suppose that M |=\u0016L \u03d5. It follows that for every\npossible sequence of tiles, we can find a truth assignment to\nthe propositions in {a, b, q1, . . . , qn} such that this extension\nsatisfies \u03d5. It follows that the behavior of the propositions\n{q1, . . . , qn} is completely deterministic and simulates a 2n-\ncounter. Now, one of the disjuncts of \u03d52 does not hold. It\nfollows that there is some problem with the arrangement of\ntiles. Thus, all possible sequences of tiles are not valid and\nthe tiling problem T does not have a solution.\nIn the other direction, suppose that the tiling problem T\ndoes not have a solution. Then, for every possible sequence\nor tiles there exists a problem with one of the tiling rules.\nWe add the assignment of the propositions {a, b, q1, . . . , qn}\naccording to this problem. uunionsq\nIn this construction the number of states of M is linear in\nthe number of tiles of T and it uses n propositions. We show\nhow to replace M with a system M \u2032 of a constant size that\nuses a constant number of propositions. The modifications to\nthe LTL formula \u03d5 resemble those outlined above in the proof\nof Theorem 7. We are going to use the following propositions.\n1. z \u2013 partial info \u2013 marks the location of the beginning of\nevery tile.\n2. p \u2013 full info \u2013 used to encode the name of the tile.\n3. q \u2013 partial info \u2013 used to encodes the number of a tile\nmodule 2n.\n4. a, b \u2013 partial info \u2013 mark the locations where a vertical\nrule is violated (as above).\nThe systemM \u2032 is the 2-state clique. One state is labeled p and\nthe other \u00acp. The state labeled p is initial. Formally, M \u2032 =\n\u3008S\u2032, R\u2032, L\u2032, sp\u3009, where S\u2032 = {sp, sp}, R\u2032 = S\u2032 \u00d7 S\u2032, and\nL(sp, p) = true , L(sp, p) = false , and L(s, r) = \u22a5 for s \u2208\nS and r \u2208 {q, a, b, z}. Wlog, we assume that n > i. Then,\na sequence of n states of this system encodes one tile and its\nnumber. Thus, a sequence of n states of M \u2032 corresponds to\none state of M . The value of the proposition p in the states\ni+ 1, . . . , n is not used and thus there are many traces of M \u2032\n10 Patrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited\nthat correspond to the same tiling. The case where n \u2264 i is\nsimple to construct using the same ideas.\nWe change the LTL formula \u03d5 into a new LTL formula\nthat replaces the name of a tile with reference to a sequence\nof k truth values to proposition p, relativizes the value of the\nproposition qi to the location representing the value of qi (by\nreplacing qi by Xi\u22121q, and relativizes the truth values of all\nother operators to the locations where z is true . Formally,\nthe function g : LTL\u2192 LTL is very similar to the function\ndefined in the proof of Theorem 9 and is defined as follows.\n1. Let p1, . . . , pk denote the binary encoding of the tile t.\nLet Pi be Xi\u22121p if pi is true and Xi\u22121\u00acp if pi is false. Let\ng(t) =\nk\u2227\ni=1\nPi (note that g(t) can be written with k next\noperators and not k2 as above).\n2. g(qi) be Xi\u22121q for qi \u2208 {q1, . . . , qn}\n3. g(r) = r for r \u2208 {a, b}\n4. g(\u03d5 \u2227 \u03c8) = g(\u03d5) \u2227 g(\u03c8)\n5. g(\u00ac\u03d5) = \u00acg(\u03d5)\n6. g(X\u03d5) = Xng(\u03d5)\n7. g(\u03d5U\u03c8) = ((z \u2192 g(\u03d5))U(z \u2227 g(\u03c8)))\nFinally, let\n\u03d5z = (\u00acz \u2227Xz)\u2227\nG(z \u2192 (X\u00acz \u2227X(\u00acz \u2227 . . . \u2227X(\u00acz \u2227X\ufe38 \ufe37\ufe37 \ufe38\nn next operators\nz))))\nWe set \u03d5\u2032 = \u03d5z \u2227 Xg(\u03d5). We note that the length of \u03d5\u2032 is\nlinear in n|\u03d5|.\nThe proof that M \u2032 |=\u0016L \u03d5\u2032 iff the tiling problem has no\nsolution combines the proof of Lemma 2 with the techniques\nin the proof of Theorem 9.\nuunionsq\nBy Theorems 11 and 12 we have the following.\nCorollary 3. LTL Generalized Model CheckingM |=\u0016L with\nrespect to the linear completeness preorder\u0016L is EXPSPACE-\ncomplete in the size of \u03d5.\nThe next theorem states that \u0016 is a stronger relation than\n\u0016L.\nTheorem 13. For every partial Kripke structuresM,M \u2032 and\nLTL formula \u03d5, M \u0016 M \u2032 implies M \u0016L M \u2032, and therefore\nM |=\u0016 \u03d5 implies M |=\u0016L \u03d5.\nProof. Immediate from the definitions of \u0016 and \u0016L. uunionsq\nNote that \u0016 is strictly stronger than \u0016L, as the converse\nof the theorem does not hold. To illustrate this, consider the\nLTL formula \u03d5 = (p \u2227 Xp) \u2228 (\u00acp \u2227 X\u00acp) and the partial\nKripke structure M in Figure 2. Formally, let M = \u3008{s0,\ns1, s2}, {(s0, s1), (s0, s2), (s1, s1), (s2, s2)}, L,s0\u3009 labeled\nwith a single atomic proposition p such that L(s0, p) = \u22a5,\nL(s1, p) = true and L(s2, p) = false . It is easy to see that\n[(M, s0) |= \u03d5] = \u22a5. Moreover, we have (M, s0) |=\u0016L\n\u03d5, as every 3-valued trace generated from (M, s0) can be\ncompleted by some 2-valued trace that satisfies \u03d5. However,\nM :\ns0\ns1\ns2\np=false\np=true\np=\u22a5\nFig. 2. Partial Kripke Structure showing that \u0016 is strictly stronger than \u0016L.\n(M, s0) 6|=\u0016 \u03d5 as there does not exist a completion M \u2032 such\nthat M \u0016 M \u2032 and M \u2032 |= \u03d5, as state s0 where p = \u22a5 cannot\nbe completed to a single state s such that every trace from s\nsatisfies \u03d5: if L(s, p) = true , then the trace ss\u03c92 violates \u03d5,\nand if L(s, p) = false , then the trace ss\u03c91 violates \u03d5.\n5 Model Complexity\nWe have seen that LTL generalized model checking defined\nwith the stronger branching-time preorder \u0016 is polynomial\nin the size of the model. The degree of the polynomial, how-\never, is unbounded, and depends on the deterministic automa-\nton created for the formula. Here we show that for interesting\nclasses of properties, the model complexity can be restricted\nto linear or quadratic. The resemblance pointed out between\ngeneralized model checking and realizability in the proof of\nTheorem 9 continues here. Indeed, the same classes of for-\nmulas are used to suggest tractable fractions of LTL for real-\nizability (cf. [RW89,AMPS98,PPS06]).\nWe start with a few additional definitions and known re-\nsults regarding automata. LetA = \u3008\u03a3,Q, qin, \u03b4, \u03b1\u3009 be a Bu\u00a8chi\nautomaton. We say that A is weak if there is a preorder \u2264 on\nthe state set Q such that the following two conditions hold:\n1. For every q \u2208 Q and \u03c3 \u2208 \u03a3, if q\u2032 appears in \u03b4(q, \u03c3) then\nq \u2264 q\u2032.\n2. For every q \u2208 Q, if q \u2208 \u03b1 then forall q\u2032 such that q \u2264 q\u2032\nand q\u2032 \u2264 q we have q\u2032 \u2208 \u03b1.\nWe use the acronyms mentioned previously for weak automata.\nFor instance, an AWT is an alternating weak tree automaton\nand an DWW is a deterministic weak word automaton.\nWe specialize Theorem 5 to our needs as follows.\nTheorem 14. Given an APW A over a 1-letter alphabet, we\ncan decide whether L(A) = \u2205 in linear time if A is AWW\n[KVW00] and in quadratic time if A is an ABW, ACW, or an\nAPW with three priorities [VW86,Jur00].\nConsider an LTL formula \u03d5. We say that \u03d5 is a safety\nproperty if for every word w \/\u2208 L(\u03d5) there exists a prefix\nu such that forall v\u2032 we have uv\u2032 \/\u2208 L(\u03d5). Let p and q be\nBoolean combinations of propositional formulas. Formulas\nof the form GFp or G(q \u2192 Fp) are called response prop-\nerties, and formulas of the form FGp are called persistence\nproperties [MP92]. If \u03d5 is of the form (\u03d5as\u2227\u03d5ar)\u2192 (\u03d5gs\u2227\u03d5gr)\nwhere \u03d5as and \u03d5\ng\ns are conjunctions of safety properties and\n\u03d5ar and \u03d5\ng\nr are conjunctions of response properties is called\ngeneralized reactivity[1] [KPP03]. Alternatively, we classify\nPatrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited 11\nLTL properties according to the type of deterministic automa-\nton that accepts the same language. We say that \u03d5 is a weak\nproperty if there exists a DWW that accepts the language of\n\u03d5. We say that \u03d5 is a DBW property if there exists a DBW\nthat accepts the language of \u03d5. Similarly, we say that \u03d5 is\na DCW property if there exists a DCW that accepts the lan-\nguage of \u03d5. The following theorem links the different types\nof LTL properties to the deterministic automata that accept\nthem.\nTheorem 15. 1. For every safety property \u03d5, there exists a\nDWW D such that L(D) = L(\u03d5) [MP90].\n2. For every response property \u03d5, there exists a DBW D such\nthat L(D) = L(\u03d5) [MP90].\n3. For every persistence property \u03d5, there exists a DCW D\nsuch that L(D) = L(\u03d5) [MP90].\n4. For every generalized reactivity[1] property \u03d5, there exists\na DPW D with three priorities such that L(D) = L(\u03d5)\n[KPP03].\nThe following is a consequence of Theorems 14 and 15 and\nthe proof of Theorem 7.\nCorollary 4. LTL generalized model checking M |=\u0016 \u03d5 is\nlinear in M for weak and safety properties, and quadratic\nin M for response, persistence, and generalized reactivity[1]\nproperties.\nProof. From the proof of Theorem 7 it follows that we com-\nbine a deterministic automaton for the property with the model\nto get an APW over a 1-letter alphabet. From Theorem 15 it\nfollows that if the LTL property is a safety or obligation prop-\nerty the DPW, and the resulting APW, are weak. If the LTL\nproperty is a response property, the DPW is in fact a DBW.\nIf the LTL property is a persistence property, the DPW is in\nfact a DCW. If the LTL property is a generalized reactivity[1]\nproperty, the DPW has three priorities. Recall that the APW\nis the product of the DPW and the model. Thus, the APW is\nlinear in the size of the model. The desired upper bound now\nfollows directly from Theorem 14. uunionsq\nNote that LTL GMC for persistence properties can be\nsolved in quadratic time in the size of the model, instead of\nin linear time as incorrectly stated in Theorem 5 of [GJ02].\nThe root cause of this error is the same as the one for The-\norem 25 of [BG00], as the proofs of both theorems rely on\nthe same product construction, now corrected in Theorem 7\nof this paper.\nFinally, we clarify a subtle misconception regarding gen-\neralized model checking of CTL properties. Given a CTL\nproperty, we can construct directly an NBT that is at most ex-\nponential in the size of the property that accepts all trees that\nsatisfy the property [KVW00]. Generalized model checking\ncan then be solved by combining this NBT with the model\nto obtain an ABW over a 1-letter alphabet [BG00]. Accord-\ning to Theorem 14 the emptiness of this ABW can be estab-\nlished in quadratic time. Thus, the complexity of GMC with\nrespect to CTL properties is exponential in the formula and\nquadratic in the model, which is optimal [BG00]. As with\nLTL the quadratic complexity in the model follows from the\ntype of acceptance condition used by the automaton for the\nformula. We are interested in classes of properties for which\nautomata require simpler acceptance conditions. If the CTL\nproperty can be recognized by an NWT, the complexity in\nthe size of the model reduces to linear. In the proof of Theo-\nrem 7 of [GJ02] it is assumed that if a CTL property can be\nrecognized by an NCT then it can also be recognized by an\nNWT. However, it is currently unknown whether this is the\ncase (cf. Section 7) and the proof of that theorem is therefore\nincomplete.\n6 Reducing GMC to Games\nThe proof of Theorem 9 reduces realizability of LTL to GMC.\nThe similarity actually goes in both directions. A GMC prob-\nlem can be translated to a 2-person game where the specifi-\ncation (in LTL or in branching-time logic) can be translated\nto the winning condition. In a 2-person game players veri-\nfier and refuter alternate in moving a token along the edges\nof a graph. If the infinite path made by the token satisfies\nan LTL formula, verifier wins and otherwise she loses. If the\nwinning condition is expressed in terms of branching-time\nlogic, instead of considering a path in the graph, we consider\nthe infinite unwinding of the game graph and prune the un-\nwinding so that nodes that correspond to decisions of verifier\nhave exactly one successor. Intuitively, the translation of the\nGMC problem to such a game is as follows. The game graph\nitself is similar to the model, where decisions of the refuter\ncorrespond to the branching of the original model and deci-\nsions of the verifier correspond to the values given to undeter-\nmined propositions. The formula to be checked on the model\nis translated to the winning condition in the game. Much like\nthe proofs of the lower bounds above, this straightforward\ntranslation may result in a game graph that is exponential in\nthe number of propositions whose value is unknown. We now\nformalize these notions and prove that LTL and CTL gener-\nalized model checking is linearly reducible to decision of a\ngame G. The formal exposition is more complicated than ex-\nplained above as we ensure that the size of the game graph is\nlinear in the number of unknown propositions.\nA game is G = \u3008V, V1, V2, E, L, v, \u03d5\u3009 where \u3008V,E\u3009 is a\ngraph, V1 and V2 form a partition of V to player 1 and player 2\nvertices, respectively, L : V \u2192 2AP is a labeling of nodes\nwith atomic propositions, v \u2208 V is an initial node, and \u03d5\nis a winning condition for player 1 given in either LTL or\nCTL over propositions AP . A strategy \u03c3 for player 1 is \u03c3 :\nV \u2217 \u00b7 V1 \u2192 V such that for every w \u2208 V \u2217 and v1 \u2208 V1 we\nhave (v1, \u03c3(w \u00b7 v1)) \u2208 E. A strategy \u03c4 for player 2 is defined\nsimilarly. Given a strategy \u03c3 for player 1, the outcome of \u03c3\nfrom node v, denoted out(\u03c3, v), is the tree T \u2286 V \u2217 such that\nfor everyw \u2208 V \u2217 and v1 \u2208 V1 we have \u03c3(w\u00b7v1) is the unique\nson of w \u00b7 v1 and for every w \u2208 V \u2217 and v2 \u2208 V2 the nodes\n{w \u00b7 v2 \u00b7 v\u2032 | (v2, v\u2032) \u2208 E} is the set of sons of w \u00b7 v2. Given\na strategy \u03c3 for player 1, a strategy \u03c4 for player 2, and a node\nv, the outcome of \u03c3 and \u03c4 from v, denoted out(\u03c3, \u03c4, v), is\n12 Patrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited\nthe word w = v0v1 \u00b7 \u00b7 \u00b7 \u2208 V \u03c9 such that for every i \u2265 0 we\nhave if vi \u2208 V1 then vi+1 = \u03c3(v0 \u00b7 \u00b7 \u00b7 vi) and if vi \u2208 V2 then\nvi+1 = \u03c4(v0 \u00b7 \u00b7 \u00b7 vi). Given a winning condition \u03d5, a strategy\n\u03c3 is winning for player 1 from node v if \u03d5 is in CTL and\nout(\u03c3, v) |= \u03d5 and if \u03d5 is in LTL and for every strategy \u03c4 for\nplayer 2 we have out(\u03c3, \u03c4, v) |= \u03d5. Player 1 wins G if she\nhas a winning strategy from the initial node v. We decide a\ngame G by determining whether player 1 can win the game.\nTheorem 16. LTL and CTL generalized model checkingM |=\u0016\n\u03d5 is linearly reducible to decision of a game G.\nProof. Consider the PKS M = \u3008S,R,L, sin\u3009 and the for-\nmula \u03d5. Let AP = {p1, . . . , pn}. Define the game G =\n\u3008V, V1, V2, E, L\u2032, vin, \u03d5\u2032\u3009 as follows. Let V \u2032 = S \u00d7 [n] \u00d7\n{true, false}. Given a node v = (s, i, \u03b1) \u2208 V \u2032 we say that\nv is consistent if either \u03b1 = L(s, pi) or L(s, pi) = \u22a5. The\nset of nodes V is S \u222a {v \u2208 V \u2032 | v is consistent} and V1 =\nS \u222a (V \u2229 (S \u00d7 [n\u2212 1]\u00d7{true, false})) and V2 = V \u2229 (S \u00d7\n{n}\u00d7{true, false}). The set of edgesE is defined as follows.\nFor a node s \u2208 V1 we have (s, (s, 1, \u03b2)) \u2208 E forall \u03b2 such\nthat (s, 1, \u03b2) \u2208 V . For a node v = (s, i, \u03b1) \u2208 V1 we have\n((s, i, \u03b1), (s, i+ 1, \u03b2)) \u2208 E forall \u03b2 such that (s, i+ 1, \u03b2) \u2208\nV . For a node v = (s, n, \u03b1) \u2208 V2 we have ((s, n, \u03b1), s\u2032)\nforall s\u2032 such that (s, s\u2032) \u2208 R. Finally, L\u2032 is defined over\nAP \u2032 = AP \u222a {q} where L\u2032 is defined as follows.\nL\u2032(v, r) =\n\uf8f1\uf8f4\uf8f4\uf8f2\uf8f4\uf8f4\uf8f3\ntrue If r = pi and v = (s, i, true)\nfalse If r = pi and v = (s, i, false)\nfalse If r 6= pi and v = (s, i, \u03b1)\ntrue If r = q and v \u2208 S\nSuppose that \u03d5 is an LTL formula. Then, \u03d5\u2032 is obtained\nfrom \u03d5 by replacing (recursively) pi by Xipi, replacing X\u03c8\nby q \u2227X(\u00acqU(q \u2227\u03c8)), and \u03c81U\u03c82 by (q \u2192 \u03c81)U(q \u2227\u03c82).\nSuppose that \u03d5 is a CTL formula. Then \u03d5\u2032 is obtained\nfrom \u03d5 by replacing (recursively) pi by EXipi, replacing\nEX\u03c8 by q \u2227 EXE(\u00acqU(q \u2227 \u03c8)), replacing AX\u03c8 by q \u2227\nAXA(\u00acqU(q\u2227\u03c8)), replacingE(\u03c81U\u03c82) byE((q \u2192 \u03c81)U(q\u2227\n\u03c82)), and replacing U(\u03c81U\u03c82) by A((q \u2192 \u03c81)U(q \u2227 \u03c82)).\nIn both cases it is possible to show that a winning strategy\n\u03c3 for player 1 translates to a completion M \u2032 of M such that\nM \u2032 satisfies \u03d5 and that a completion M \u2032 of M translates to a\nwinning strategy for player 1. It follows that player 1 wins iff\nGMC of M with respect to \u03d5 holds.\nThe number of nodes ofG can be further reduced to twice\nthe number of states ofM by encoding all the propositions in\nAP by one proposition p in G and augmenting \u03d5 by clauses\nthat force player 1 to leave cycles where q does not hold. uunionsq\n7 Conclusions\nWe study generalized model checking for linear time proper-\nties. We consider the classical definition of GMC and show\nthat it is 2EXPTIME-complete in the size of the formula and\npolynomial in the structure. We study a linear version of the\ncompleteness preorder and show that this preorder induces a\nGMC problem that is EXPSPACE-complete in the size of the\nformula. We then proceed to show that for interesting classes\nof properties the model complexity can be restricted to a low\norder polynomial.\nWe have presented our work in the framework of partial\nKripke structures. Other equally expressive 3-valued mod-\nels [GJ03] include Modal Transition Systems [LT88] and Kri-\npke Modal Transition Systems [HJS01]. All the complexity\nbounds given in this paper carry over to those closely related\nmodeling formalisms.\nWe have seen that for interesting classes of LTL and CTL\nproperties the complexity in term of the model can be re-\nstricted to linear or quadratic. We classify the properties ac-\ncording to deterministic word automata and nondeterministic\ntree automata that match these formulas. While most popular\ntypes of properties are covered above, characterization of the\nexact classes of formulas that can be translated to these types\nof automata is an interesting problem. That is, what are the\nexact subsets of LTL that can be translated to DWW and to\nDBW? Is there a simple syntactic way to express these sub-\nsets? The same problem for CTL (and other branching-time\nlogics) involves tree automata. For every CTL property there\nexist an NBT and an AWT recognizing the same set of trees\n[KVW00]. What CTL properties can be translated to NWT?\nIs there a syntactic way to express these subsets? We know\nthat if a word language can be recognized by a DBW and\nby a DCW, then it can be recognized by a DWW [KMM04].\nThis suggests the following natural question: Given a tree lan-\nguage that is accepted by an NCT and by an NBT, can it be\nrecognized by an NWT? From a practical point of view, it\ncould be interesting to study the specific case of CTL proper-\nties that are recognized by NCT.\nAcknowledgements. We thank Michael Huth for comments\non an earlier version and Orna Kupferman for a discussion of\nthe relative expressive power of NBT and NCT.\nReferences\n[AHL+08] A. Antonik, M. Huth, K. Larsen, U. Nyman, and A. Wa-\nsowski. 20 years of mixed and modal specifications. Bul-\nletin of the European Association for Theoretical Com-\nputer Science, 2008.\n[AMPS98] E. Asarin, O. Maler, A. Pnueli, and J. Sifakis. Controller\nsynthesis for timed automata. In IFAC Symp. on System\nStructure and Control, pages 469\u2013474. Elsevier, 1998.\n[BG99] G. Bruns and P. Godefroid. Model checking partial state\nspaces with 3-valued temporal logics. In 11th Computer\nAided Verification, pages 274\u2013287, 1999.\n[BG00] G. Bruns and P. Godefroid. Generalized model check-\ning: Reasoning about partial state spaces. In 11th Con-\ncurrency Theory, volume 1877 of Lecture Notes in Com-\nputer Science, pages 168\u2013182, 2000.\n[BR01] T. Ball and S. Rajamani. The SLAM Toolkit. In 13th\nComputer Aided Verification, volume 2102 of Lecture\nNotes in Computer Science, pages 260\u2013264, Paris, July\n2001. Springer-Verlag.\nPatrice Godefroid, Nir Piterman: LTL Generalized Model Checking Revisited 13\n[GC05] A. Gurfinkel and M. Chechik. How Thorough is Thor-\nough Enough? In 13th Correct Hardware Design and\nVerification Methods, 2005.\n[GH05] P. Godefroid and M. Huth. Model Checking Vs. Gen-\neralized Model Checking: Semantic Minimizations for\nTemporal Logics. In 20th Logic in Computer Science,\npages 158\u2013167, Chicago, June 2005.\n[GHJ01] P. Godefroid, M. Huth, and R. Jagadeesan. Abstraction-\nbased Model Checking using Modal Transition Systems.\nIn 12th Concurrency Theory, volume 2154 of Lecture\nNotes in Computer Science, pages 426\u2013440, Aalborg,\nAugust 2001. Springer-Verlag.\n[GJ02] P. Godefroid and R. Jagadeesan. Automatic Abstrac-\ntion Using Generalized Model Checking. In 14th Com-\nputer Aided Verification, volume 2404 of Lecture Notes\nin Computer Science, pages 137\u2013150. Springer-Verlag,\n2002.\n[GJ03] P. Godefroid and R. Jagadeesan. On the Expressiveness\nof 3-Valued Models. In 4th Verification, Model Check-\ning and Abstract Interpretation, volume 2575 of Lecture\nNotes in Computer Science, pages 206\u2013222, New York,\nJanuary 2003. Springer-Verlag.\n[GS97] S. Graf and H. Saidi. Construction of Abstract State\nGraphs with PVS. In 9th Computer Aided Verification,\nvolume 1254 of Lecture Notes in Computer Science,\npages 72\u201383, Haifa, June 1997. Springer-Verlag.\n[GTW02] E. Gra\u00a8del, W. Thomas, and T. Wilke. Automata, Logics,\nand Infinite Games. Lecture Notes in Computer Science\n2500. Springer-Verlag, 2002.\n[GWC06] A. Gurfinkel, O. Wei, and M. Chechik. Systematic Con-\nstruction of Abstractions for Model-Checking. In 7th\nVerification, Model Checking, and Abstract Interpreta-\ntion, volume 3855 of Lecture Notes in Computer Sci-\nence, pages 381\u2013397. Springer-Verlag, January 2006.\n[HJMS02] T. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy\nAbstraction. In 29th Principles of Programming Lan-\nguages, pages 58\u201370, 2002.\n[HJS01] M. Huth, R. Jagadeesan, and D. Schmidt. Modal Transi-\ntion Systems: a Foundation for Three-Valued Program\nAnalysis. In 10th European Symp. on Programming,\nvolume 2028 of Lecture Notes in Computer Science.\nSpringer-Verlag, 2001.\n[Jur00] M. Jurdzin\u00b4ski. Small progress measures for solving par-\nity games. In 17th Theoretical Aspects of Computer Sci-\nence, volume 1770 of Lecture Notes in Computer Sci-\nence, pages 290\u2013301. Springer-Verlag, 2000.\n[Kle87] S. C. Kleene. Introduction to Metamathematics. North\nHolland, 1987.\n[KMM04] O. Kupferman, G. Morgenstern, and A. Murano. Type-\nness for \u03c9-regular automata. In 2nd Automated Tech-\nnology for Verification and Analysis, volume 3299 of\nLecture Notes in Computer Science, pages 324\u2013338.\nSpringer-Verlag, 2004.\n[KPP03] Y. Kesten, N. Piterman, and A. Pnueli. Bridging the gap\nbetween fair simulation and trace containment. In 15th\nComputer Aided Verification, volume 2725 of Lecture\nNotes in Computer Science, pages 381\u2013393. Springer-\nVerlag, 2003.\n[KVW00] O. Kupferman, M.Y. Vardi, and P. Wolper. An automata-\ntheoretic approach to branching-time model checking.\nJournal of the ACM, 47(2):312\u2013360, 2000.\n[LT88] K. G. Larsen and B. Thomsen. A Modal Process Logic.\nIn 3rd Logic in Computer Science, pages 203\u2013210, 1988.\n[MP90] Z. Manna and A. Pnueli. A hierarchy of temporal prop-\nerties. In 9th Symposium on Principles of Distributed\nComputing, pages 377\u2013410. ACM, 1990.\n[MP92] Z. Manna and A. Pnueli. The Temporal Logic of Reactive\nand Concurrent Systems: Specification. Springer-Verlag,\nBerlin, January 1992.\n[Pit07] N. Piterman. From nondeterministic Bu\u00a8chi and Streett\nautomata to deterministic parity automata. Logical\nMethods in Computer Science, 3(3):5, 2007.\n[PPS06] N. Piterman, A. Pnueli, and Y. Saar. Synthesis of reac-\ntive(1) designs. In 7th Verification, Model Checking, and\nAbstract Interpretation, volume 3855 of Lecture Notes\nin Computer Science, pages 364\u2013380. Springer-Verlag,\n2006.\n[PR89] A. Pnueli and R. Rosner. On the synthesis of a reactive\nmodule. In 16th Principles of Programming Languages,\npages 179\u2013190, 1989.\n[RW89] P.J.G. Ramadge and W.M. Wonham. The control of dis-\ncrete event systems. IEEE Transactions on Control The-\nory, 77:81\u201398, 1989.\n[Saf88] S. Safra. On the complexity of \u03c9-automata. In\n29th Foundations of Computer Science, pages 319\u2013327,\nWhite Plains, October 1988.\n[SVW87] A.P. Sistla, M.Y. Vardi, and P. Wolper. The complemen-\ntation problem for Bu\u00a8chi automata with applications to\ntemporal logic. Theoretical Computer Science, 49:217\u2013\n237, 1987.\n[vEB97] P. van Emde Boas. The convenience of tilings. In Com-\nplexity, Logic and Recursion Theory, volume 187 of Lec-\nture Notes in Pure and Applied Mathetaics, pages 331\u2013\n363, 1997.\n[VW86] M.Y. Vardi and P. Wolper. Automata-theoretic tech-\nniques for modal logics of programs. Journal of Com-\nputer and System Science, 32(2):182\u2013221, April 1986.\n[VW94] M.Y. Vardi and P. Wolper. Reasoning about infinite com-\nputations. Information and Computation, 115(1):1\u201337,\nNovember 1994.\n"}