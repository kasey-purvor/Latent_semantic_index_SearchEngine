{"doi":"10.1109\/PIMRC.2006.254071","coreId":"69744","oai":"oai:eprints.lancs.ac.uk:22910","identifiers":["oai:eprints.lancs.ac.uk:22910","10.1109\/PIMRC.2006.254071"],"title":"Reducing Processing Time for Real-Time Mobile Hosted Location Based Services.","authors":["Gilbertson, Paul","Edwards, Reuben","Coulton, Paul"],"enrichments":{"references":[{"id":1028552,"title":"Capitalizing on the Location-Based Services","authors":[],"date":"2005","doi":null,"raw":null,"cites":null},{"id":1028839,"title":"Garmin Reports Record Fourth Quarter and Annual Results","authors":[],"date":"2005","doi":null,"raw":null,"cites":null},{"id":1029902,"title":"Geometry clipmaps: Terrain rendering using nested regular grids\u201d,","authors":[],"date":"2004","doi":"10.1145\/1015706.1015799","raw":null,"cites":null},{"id":1028280,"title":"NMEA 0183: A GPS Receiver Interface Standard.&quot;,","authors":[],"date":"2005","doi":null,"raw":null,"cites":null},{"id":1029412,"title":"Nodits: Position Triggered information and Messages\u201d, to appear ISCE","authors":[],"date":"2006","doi":null,"raw":null,"cites":null},{"id":1029134,"title":"P.Coulton, and R.Edwards, \u201cLocation Based Mobile Blogging\u201d, to appear ICTTA","authors":[],"date":"2006","doi":null,"raw":null,"cites":null},{"id":1029683,"title":"The R*-tree: an efficient and robust access method points and rectangles\u201d,","authors":[],"date":"1990","doi":"10.1145\/93605.98741","raw":null,"cites":null}],"documentType":{"type":null}},"contributors":[],"datePublished":"2006-09","abstract":"This paper presents the results of a successful development of an algorithm to reduce processing time for mobile hosted location aware software applications. It starts with a review of location based services and discusses issues surrounding various designs to place the algorithm in context. The algorithm draws on various methodologies pioneered in the high-speed 3D graphics industry to reduce processing time checking for collisions between a user and location aware data points. The algorithm and experiment are presented in a concise manner before the results are shown. The results conclude that the algorithm presents a very significant improvement over brute force methods. With a database of 100,000 data points a 99% reduction in processing time is observe","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:22910<\/identifier><datestamp>\n      2018-01-24T02:08:31Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413736<\/setSpec><setSpec>\n      74797065733D626F6F6B5F73656374696F6E<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Reducing Processing Time for Real-Time Mobile Hosted Location Based Services.<\/dc:title><dc:creator>\n        Gilbertson, Paul<\/dc:creator><dc:creator>\n        Edwards, Reuben<\/dc:creator><dc:creator>\n        Coulton, Paul<\/dc:creator><dc:subject>\n        QA76 Computer software<\/dc:subject><dc:description>\n        This paper presents the results of a successful development of an algorithm to reduce processing time for mobile hosted location aware software applications. It starts with a review of location based services and discusses issues surrounding various designs to place the algorithm in context. The algorithm draws on various methodologies pioneered in the high-speed 3D graphics industry to reduce processing time checking for collisions between a user and location aware data points. The algorithm and experiment are presented in a concise manner before the results are shown. The results conclude that the algorithm presents a very significant improvement over brute force methods. With a database of 100,000 data points a 99% reduction in processing time is observed<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:date>\n        2006-09<\/dc:date><dc:type>\n        Contribution in Book\/Report\/Proceedings<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:relation>\n        http:\/\/dx.doi.org\/10.1109\/PIMRC.2006.254071<\/dc:relation><dc:identifier>\n        Gilbertson, Paul and Edwards, Reuben and Coulton, Paul (2006) Reducing Processing Time for Real-Time Mobile Hosted Location Based Services. In: Personal, Indoor and Mobile Radio Communications, 2006 IEEE 17th International Symposium on. IEEE. ISBN 1-4244-0329-4<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/22910\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1109\/PIMRC.2006.254071","http:\/\/eprints.lancs.ac.uk\/22910\/"],"year":2006,"topics":["QA76 Computer software"],"subject":["Contribution in Book\/Report\/Proceedings","NonPeerReviewed"],"fullText":"The 17th Annual IEEE International Symposium on Personal, Indoor and Mobile Radio Communications (PIMRC'06) \n1-4244-0330-8\/06\/$20.00\uf6d92006 IEEE \n \nREDUCING PROCESSING TIME FOR REAL-TIME MOBILE  \nHOSTED LOCATION BASED SERVICES \nPaul Gilbertson Reuben Edwards Paul Coulton \nDept. Communication Systems, \nLancaster University \nDept. Communication Systems, \nLancaster University \nDept. Communication Systems, \nLancaster University \nInfoLab21, South Drive,  \nLancaster University, LA1 4YW \nInfoLab21, South Drive,  \nLancaster University, LA1 4YW \nInfoLab21, South Drive,  \nLancaster University, LA1 4YW \nUK UK UK \n   \n \nABSTRACT \nThis paper presents the results of a successful \ndevelopment of an algorithm to reduce processing time for \nmobile hosted location aware software applications. It \nstarts with a review of location based services and \ndiscusses issues surrounding various designs to place the \nalgorithm in context. \n   The algorithm draws on various methodologies \npioneered in the high-speed 3D graphics industry to \nreduce processing time checking for collisions between a \nuser and location aware data points. The algorithm and \nexperiment are presented in a concise manner before the \nresults are shown. \n   The results conclude that the algorithm presents a very \nsignificant improvement over brute force methods. With a \ndatabase of 100,000 data points a 99% reduction in \nprocessing time is observed. \n \nI. INTRODUCTION \n \nLocation Based Services are once more on the rise in the \nmobile arena. Problems associated with the granularity of \nposition information that was formerly based on network \nCell ID have been tackled with the invention of new \ntechnologies and methods. These new systems allow a \nservice to pin-point a user\u2019s position to accuracy levels \npreviously unheard of. \n   Location based products and services are currently a 10 \nbillion Euro market, and Nokia predicts a double-digit \ngrowth rate in the next ten years [1]. This can easily be \nachieved with the roll-out of location-aware mobile \ndevices and accessories to the mass market. With the \nexplosion of satellite navigation systems into the \nconsumer market [2] consumers are becoming more aware \nof the potential uses for location based data. \n   One method of obtaining position information is by \nusing a GPS receiver. Although the techniques and studies \nin this paper can be used with any system capable of \ndetermining latitude and longitude, GPS is used \nthroughout. GPS devices are becoming common, often as \nBluetooth or SDIO accessories for PDAs and mobile \nphones, and are increasingly integrated with the latest \nmobile devices from manufacturers such as Nokia, \nMotorola and Ben-Q. \n   Location aware data is simply data that is attached to a \nspecific geographic position. As an example can be \nmentioned photographs and user-created content \ncontaining information about the location covered. \nLocoBlog [3] is an example of GPS data being used to \nrecord the position a blog entry was made from, and \nallows a user to track his movements during a holiday or \nconference. \n   Section 2 of this paper looks at the structure of Location \nBased Services and the issues presented by a limited \nstorage and processor device. Formats for the storage and \npresentation of position data are briefly reviewed in \nSection 3. An algorithm to reduce processing time for \ndetecting the proximity of location aware data when in \nmotion is discussed in Section 4. Section 5 covers a series \nof experiments performed comparing the presented \nalgorithm against a brute force method and their results. \nThe paper ends with some conclusions and discussion of \nfurther improvements to be made. \n \nII. LOCATION AWARE DATA ISSUES \n \nThere are two major software designs for Location Based \nServices. The primary method is for the mobile device to \nbe merely a client to a back-end server system. In this \ndesign the mobile device simply senses the user\u2019s current \nlocation, passes this in a request to the servers and \npresents the result. All proximity checking and data \nstorage is performed by large commercial-grade databases \nand servers. In this system memory and CPU time on the \nmobile device is not severely constrained. \n   The potential for a new design has been presented by the \nexplosion of satellite navigation systems. In this design \ndata storage and processing are performed on the device, \nwith a few irregular requests to any central service for \ninformation updates. The major advantage of this system \nis that information can be easily presented in real-time \nwith no requirement for network coverage. Mobile phones \nand PDAs are constrained in both CPU speed and \navailable memory and this presents some issues. \n \nAuthorized licensed use limited to: IEEE Xplore. Downloaded on January 6, 2009 at 15:54 from IEEE Xplore.  Restrictions apply.\nThe 17th Annual IEEE International Symposium on Personal, Indoor and Mobile Radio Communications (PIMRC\u201906) \nIII. ISSUES \n \nOne potential application arising from the new design \nparadigm is that of personal and community position-\naware information access [4]. Information is stored \nattached to an active geographic area (typically a circle \naround a specific point) on the mobile device. When this \ndevice enters the active area the attached information is \npresented. \n     For this application to succeed we need to overcome a \nnumber of obstacles. First the current position of the \ndevice needs to be checked against the database frequently \nto ensure that data is presented to the user promptly. \nSecondly large data sets may need to be stored. Mobile \ndevices have constrained storage areas, so only data that is \nlikely to be required in the near future should be stored on \nthe device and transactions to a central server to retrieve \nnew information should be kept to a minimum. \n    Applications using this design may need to check the \nproximity of many individual items of data when each \nchange in position is detected. This would require a large \namount of processing power if the data set is large. For \nmobile devices where CPU time is at a premium, this is a \nsignificant issue. Reducing this processing time is a key \nobjective of any algorithm.  \n    Previous algorithms have been used to reduce the CPU \ntime required for spatial searches. The most renowned of \nthese is R-Tree [5] and its descendants. R-Tree subdivides \nthe total data space into smaller areas which contain \nproximity based subgroups of data points. These areas are \nsub divided repeatedly to form a tree. To find data within \na certain area the search algorithm only needs to traverse \nthe tree to the relevant leaves and perform collisions \nchecks on the data within those leaves. Various algorithms \nfor performing R-Tree searches have been developed. \n    R-Tree suffers from the requirement that all searches \nstart from the top of the tree, so effectively all data needs \nto be on or easily accessible to the device. This is not \nalways possible on mobile devices. \n \nIV. ALGORITHM DESIGN \n \nThe aim of any search algorithm is to reduce the amount \nof expensive calculations required to achieve a correct \nresult. For the designs discussed previously, a number of \nassumptions can be made that simplify the operation. The \nfirst is that the mobile device will not jump randomly \naround the data space. In other words each update will \noccur close to the previous update. The second assumption \nis that the active areas for the data points are going to be \nsmall compared to the entire data space. This assumption \nhas been made to reduce the need for checking points that \nare a significant distance from the current location. \n    Searches can be grouped into two categories. The first \ncategory is update searches. These searches occur when \nthe mobile device position changes and for these searches \nthere is no real need to check the entire data space, only \nnearby data points. For the second category we have full \nspace searches that are performed on start-up or when \nupdate searches are no longer viable due to the mobile \ndevice moving away from previously close points. \n    The algorithm optimises the update searches \nsignificantly, and reduces the need for expensive full \nspace searches. By reducing collision checks between the \ndevice and the active areas of various data points to only \nthose data points in vicinity of the device, we are able to \nreduce processing time significantly. \n   A lot of the design inspiration comes from work carried \nout in the high-speed graphics arena for reducing \ncomputational workload on detailed terrains [6]. In these \nsituations only the terrain close to the camera is required \nto be updated when the camera moves. Terrain far away, \nwhere the movement would not produce any visible \nchange on screen, does not require any expensive \ncomputation to be performed on it. \n \nV. ALGORITHM IMPLEMENTATION \n \n    The algorithm makes use of a series of classes that store \nand organise data based on its location. This enables the \nsoftware to restrict its comparison of the user\u2019s current \nlocation to data locations that are in the vicinity. \n \n \n \nFig 1. Initial Configuration of Data Buckets \n \n \nFig 2. Configuration of Data Buckets after Movement \nAuthorized licensed use limited to: IEEE Xplore. Downloaded on January 6, 2009 at 15:54 from IEEE Xplore.  Restrictions apply.\nThe 17th Annual IEEE International Symposium on Personal, Indoor and Mobile Radio Communications (PIMRC\u201906) \n17\n8.1\n25\n17\n8.1\n25\n19\n3.7\n5\n30\n3.1\n25\n15\n84\n.37\n5\n14\n64\n6.8\n75\n10\n3.1\n25\n24\n6.8\n75\n16\n90\n.62\n5\n16\n02\n1.8\n75 16\n45\n65\n.62\n5\n16\n25\n96\n8.7\n5\n0\n200000\n400000\n600000\n800000\n1000000\n1200000\n1400000\n1600000\n1800000\n1 10 100 1000 10000 100000\nData Points\nTi\nm\ne \n(m\ns)\nAlgorithm\nBrute Force\n \n \nFig 3. Chart Showing Relative Efficiencies of the Algorithm and Brute Force Method for Varying Data \n \n    Upon initialization data is organised into a series of five \nbuckets based on distance from the initial position. Each \nbucket contains information about the minimum and \nmaximum distances of data that it contains, and the location \nof the centre point for this circular area. As shown in Figure \n1, this creates a series of five concentric rings that represent \nthe buckets into which data is stored. The complete database \nof data positions is then queried and data is organised into the \nbuckets. Data points that fall outside the fifth bucket are \nignored at this stage. Each ring is twice as wide as the \nprevious ring. \n   When a user\u2019s position changes, the data within the inner \nmost bucket is checked for position collisions. These \ncollisions occur when the user moves within a certain \narbitrary distance of the data location. Since only the \ninnermost bucket of data is checked, this reduces the CPU \noverhead required compared to checking all data points. \n   Once a user has moved half the distance towards a bucket\u2019s \nminimum range, the bucket is invalidated. When a bucket is \ninvalidated, the distance between the user\u2019s position and the \nposition of the data within that bucket is compared to the \nbucket\u2019s minimum and maximum ranges. Data is moved \ninwards and outwards to other buckets accordingly. The \ncentral position of the bucket is reset to the user\u2019s position. \n   This way, as a user moves towards different data positions, \ndata that no longer needs to be checked moves outwards, and \nnew data moves into the inner bucket and is consequently \nchecked for collisions. When the outermost bucket is \ninvalidated, the full database is queried for data points which \nnow fall within the outer bucket. \n   The innermost bucket is invalidated each time the user \nmoves, but outer buckets are invalidated only when required. \nThe result of this is some lag in bucket central locations as \nshown in Figure 2. Five buckets and the doubling width of \neach bucket are used to keep the CPU time used by bucket \ninvalidations to a minimum. \n \nVI. EXPERIMENT DETAILS \n \nA virtual \u2018arena\u2019 is set up measuring 30 arcminutes by 30 \narcminutes and filled with a number of randomly placed data \npoints. A virtual user is then simulated to move diagonally \nacross this terrain from upper left to bottom right in one tenth \nof an arcsecond steps. Data points that come within 10 metres \nof the user are recorded.  \n   The time taken for the software to run this simulation was \nrecorded using the computer clock. Each experiment runs the \nsimulation for a specific number of points placed in the \n\u2018arena\u2019 using both the algorithm detailed above and the brute \nforce method of checking each data point at each step. The \nsame data is used for both methods and the times of five runs \nare used and averaged for comparison. \n   The software was written in C# utilising .NET 2.0 and run \non an IBM-compatible PC running Windows XP, with a 2.4 \nGHz Pentium IV processor and 512MB RAM. Such a high \nspec machine was used to reduce experiment processing time. \nMobile devices with a tenth of the processing power would \nonly scale any differences in efficiencies recorded. \n \n \nAuthorized licensed use limited to: IEEE Xplore. Downloaded on January 6, 2009 at 15:54 from IEEE Xplore.  Restrictions apply.\nThe 17th Annual IEEE International Symposium on Personal, Indoor and Mobile Radio Communications (PIMRC\u201906) \nVII. RESULTS \n \nAs can be seen in Table 1, in all but the least dense data \nconditions the above algorithm significantly outperforms the \nbrute force method. The algorithm\u2019s efficiency is most visible \nin data sets of 100,000 items as shown in Fig. 3, and early \nindications show that this trend continues as the density \nincreases. The extra overhead of maintaining the buckets is \nmore than outweighed by reduction in expensive distance \nchecks. \n \nTable 1. Results of Comparing the Proposed Algorithm to a \nBrute-Force Method over a Virtual Arena \nData Points Brute-Force \nMethod Time  \n(ms) \nAlgorithm Time  \n(ms) \n1 103.125 178.125 \n10 246.875 178.125 \n100 1,690.625 193.75 \n1,000 16,021.875 303.125 \n10,000 164,565.625 1,584.375 \n100,000 1,625,968.75 14,646.875 \n \n   The algorithm begins to show some signs of stress at \n100,000 items which is in part due to the overhead of moving \nnew data points into the outermost bucket. This can be \nimproved by developing better database search routines, as \ncurrently the algorithm brute force checks every item in the \ncollection. \nVIII. FURTHER WORK \n \nMajor improvements can be made in the way the algorithm \ndraws data into the outer bucket. The current methodology is \nto check the entire data set for data that falls within the inner \nand outer bounds. This could be improved dramatically by \nonly testing data that falls within a certain range of values. \nThis would create a bounding box around the outer bucket \nand cull all data that falls outside this box. Such tests are \ncheap compared to the range calculation. \n   Mobile devices that utilise fixed-point processors may find \npresent some quantisation issues, particularly in the range \ncalculation. However, these issues are not expected to be \nsignificant with careful programming and testing on a variety \ndevices, both \u2018PDA\u2019 and \u2018Mobile Phone\u2019 types  is planned. \n   The algorithm described utilises point based data. It is \ntrivial to modify the routines to use data of varying radii. In \nthese changes, the range used for bucketing purposes is the \ndistance between both central points minus the data point\u2019s \nradius. \n   Additional work needs to be done to adopt the algorithm for \nuse with non-circular areas. This too should be not too \ndifficult. The shapes can first, for efficiency reasons, \napproximated to one or more circles, and then a more \naccurate collision check can be performed. \n \nIX. CONCLUSIONS \n \nThe algorithm presents a vast improvement over simple \napproaches to data proximity checking for software designs \nthat need to update as the user moves. It will enable a vast \nrange of new real-time applications in the location-based \nservices and location-aware gaming arenas. Other potential \narenas include augmented reality systems and satellite \nnavigation Points of Interest databases. \n \n \nREFERENCES \n \n[0] R. B. Langley, \"NMEA 0183: A GPS Receiver Interface Standard.\",     \nGPS world, vol. 6.7, sec. 54-, 2005 \n[1] Forum Nokia, \u201cCapitalizing on the Location-Based Services Oppor-\ntunity\u201d, Nokia, March 2005. \n[2] Garmin, \u201cGarmin Reports Record Fourth Quarter and Annual Results \n2005\u201d, PR Newswire, February 2006 \n[3] W. Bamford, P.Coulton, and R.Edwards, \u201cLocation Based Mobile \nBlogging\u201d, to appear ICTTA Syria 2006. \n[4] P. Gilbertson, R. Edwards, and P. Coulton, \u201cNodits: Position Triggered \ninformation and Messages\u201d, to appear ISCE 2006 \n[5] N. Beckmann, H-P Kriegel, R. Schnieder and B. Seeger, \u201cThe R*-tree: an \nefficient and robust access method points and rectangles\u201d, ACM \nSIGMOD 1990, pp 322 \u2013 331. \n[6] F. Losasso and H. Hoppe, \u201cGeometry clipmaps: Terrain rendering using \nnested regular grids\u201d, ACM SIGGRAPH 2004, pp. 769-776. \n \n. \nAuthorized licensed use limited to: IEEE Xplore. Downloaded on January 6, 2009 at 15:54 from IEEE Xplore.  Restrictions apply.\n"}