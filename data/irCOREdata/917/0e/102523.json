{"doi":"10.1109\/TSE.2005.104","coreId":"102523","oai":"oai:epubs.surrey.ac.uk:1986","identifiers":["oai:epubs.surrey.ac.uk:1986","10.1109\/TSE.2005.104"],"title":"Resolving race conditions in asynchronous partial order scenarios","authors":["Mitchell, Bill"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2005-09-15","abstract":"<p>Scenario-based requirements specifications are the industry norm for defining communication protocols. However, such scenarios often contain race conditions. A race condition occurs when events are specified to occur in a particular order, but in practice, this order cannot be guaranteed. The paper considers UML\/MSC scenarios that can be described with standard partial order theoretic asynchronous behavioral semantics. We define these to be partial order scenarios. The paper proves there is a unique minimal generalization of a partial order scenario that is race free. The paper also proves there is a unique minimal race free refinement of the behavioral semantics of a partial order scenario. Unlike the generalization, the refinement cannot be realized in the form of a partial order scenario, although it can always be embedded in one. The paper, also proves the results can be generalized to a subclass of iterative scenarios.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1986<\/identifier><datestamp>\n      2017-10-31T14:03:55Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1986\/<\/dc:relation><dc:title>\n        Resolving race conditions in asynchronous partial order scenarios<\/dc:title><dc:creator>\n        Mitchell, Bill<\/dc:creator><dc:description>\n        <p>Scenario-based requirements specifications are the industry norm for defining communication protocols. However, such scenarios often contain race conditions. A race condition occurs when events are specified to occur in a particular order, but in practice, this order cannot be guaranteed. The paper considers UML\/MSC scenarios that can be described with standard partial order theoretic asynchronous behavioral semantics. We define these to be partial order scenarios. The paper proves there is a unique minimal generalization of a partial order scenario that is race free. The paper also proves there is a unique minimal race free refinement of the behavioral semantics of a partial order scenario. Unlike the generalization, the refinement cannot be realized in the form of a partial order scenario, although it can always be embedded in one. The paper, also proves the results can be generalized to a subclass of iterative scenarios.<\/p><\/dc:description><dc:date>\n        2005-09-15<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1986\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Mitchell, Bill  (2005) Resolving race conditions in asynchronous partial order scenarios   IEEE Transactions on Software Engineering, 31 (9).  pp. 767-784.      <\/dc:identifier><dc:relation>\n        10.1109\/TSE.2005.104<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1986\/","10.1109\/TSE.2005.104"],"year":2005,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"Resolving Race Conditions in\nAsynchronous Partial Order Scenarios\nBill Mitchell\nAbstract\u2014Scenario-based requirements specifications are the industry norm for defining communication protocols. However, such\nscenarios often contain race conditions. A race condition occurs when events are specified to occur in a particular order, but in\npractice, this order cannot be guaranteed. The paper considers UML\/MSC scenarios that can be described with standard partial order\ntheoretic asynchronous behavioral semantics. We define these to be partial order scenarios. The paper proves there is a unique\nminimal generalization of a partial order scenario that is race free. The paper also proves there is a unique minimal race free refinement\nof the behavioral semantics of a partial order scenario. Unlike the generalization, the refinement cannot be realized in the form of a\npartial order scenario, although it can always be embedded in one. The paper also proves the results can be generalized to a subclass\nof iterative scenarios.\nIndex Terms\u2014Requirements analysis, formal methods, distributed programming.\n\u0001\n1 INTRODUCTION\nPRACTITIONERS commonly specify asynchronous commu-nication protocols for distributed systems as a collection\nof scenarios. UML sequence diagrams [32], Message\nSequence Charts (MSCs) [31], and Live Sequence Charts\n(LSCs) [15] are popular for defining such scenarios. Such\nlanguages are intuitive and simple to use. Unfortunately,\nsuch languages can also beguile the overworked practi-\ntioner struggling with product deadlines.\nIn general, requirements specifications have been shown\nto be a significant source of defects. Published case studies\n[11], [19], [20], [24], [33] have shown that about a third of\nsignificant behavioral defects can be traced to requirements\nspecifications. This situation is no different for distributed\ncommunication systems that use sequence diagrams to\ndefine behavioral aspects of the system.\nScenario specification languages have become quite\nsophisticated and expressive. Despite this sophistication,\nbasic scenarios are still the mainstay of industrial specifica-\ntions. A basic scenario diagram is one whose behavioral\nsemantics can be defined in terms of a partial order\n(Definition 1) on the events in the scenario. This is the\nsemantics defined in the MSC standard [31] and now\nadopted as the core semantics for UML sequence diagrams\n[32]. The partial order restricts the order in which events\ncan occur in any system trace. This partial order is called the\ncausal ordering (Definition 4). The intuition is that the\npartial order is specifying the causality between events in a\nscenario. We refer to basic scenario diagrams as partial\norder scenarios to emphasize this point (Definition 3). It is\npossible to define other behavioral semantics for sequence\ndiagrams, for example, by constraining behavior with UML\narchitecture diagrams. This is beyond the scope of this\npaper and we only consider partial order scenarios.\nA causal order not only specifies that certain events must\nbe ordered in a particular way, but also that certain events\nare independent of one another. This can be the case even\nfor events within the same process. Therefore, a partial\norder scenario specifies separate concurrent threads of\nactivity and at what points these threads must be\nsynchronized.\nCausal orders can specify an almost arbitrary partial\nordering on events within a process. However, they may\nonly order events from different processes as a result of\nmessage passing between those processes. Hence, an\narbitrary partial order over the set of events in a scenario\ndoes not necessarily itself correspond to a partial order\nscenario.\nThere are varieties of errors that can creep into scenario-\nbased specifications. The purpose of a protocol scenario is\nto define message exchanges between processes in order for\nthem to achieve some common goal. Messages can easily be\nadded between the wrong processes, accidentally added in\nthe wrong direction, or just missed altogether. This type of\nstatic error is generally picked up by routine document\ninspections or through automated checks by software tools,\nsuch as with Telelogic\u2019s TAU G2 tool [27], and, as such, do\nnot require significant effort to resolve. However, behavior-\nal inconsistencies are more difficult to detect and resolve. In\nthis paper, we focus on one common behavioral incon-\nsistency known as a race condition. Essentially, a race\ncondition asserts a particular order of events will occur\nbecause of the causal ordering, when, in practice, this order\ncannot be guaranteed to occur. Because the standard partial\norder semantics places almost no constraint on how the\ncausal order is constructed, it is very easy to inadvertently\nintroduce race conditions into a scenario. [12], [13] give the\noriginal formal description of race conditions within the\nMSC context.\nIEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005 767\n. The author is with the Department of Computing, University of Surrey,\nGuildford, Surrey GU2 7XH, UK. E-mail: w.mitchell@surrey.ac.uk.\nManuscript received 16 Feb 2005; revised 12 June 2005; accepted 20 June\n2005; published online 15 Sept. 2005.\nRecommended for acceptance by N. Maiden.\nFor information on obtaining reprints of this article, please send e-mail to:\ntse@computer.org, and reference IEEECS Log Number TSE-0039-0205.\n0098-5589\/05\/$20.00 \u0001 2005 IEEE Published by the IEEE Computer Society\nScenarios are really best suited for describing exemplary\nbehavior rather than specifying all possible concurrent\nbehavior in a distributed system. However, practitioners\nfind them more intuitive and \u201ceasier\u201d to understand than,\nsay, state machines [29]. The standard partial order\nsemantics does not attempt to distinguish between exemp-\nlary and mandatory behavior or what can be implemented\nin practice. LSCs were introduced in an attempt to address\nthese issues, and UML 2.0 now includes many constructs\nthat permit greater expressivity in relation to message\nflows. Despite these additional constructs, the fundamental\nissue still remains: What consistent asynchronous behavior\ncan be extrapolated from a set of scenarios? Many protocols\nstart life as partial order scenarios. It is therefore useful to\naddress the issue at this level. Consistent scenarios that are\nsubsequently constructed can then be enhanced with\nappropriate constructs to describe how they should be\nused in the specification as a whole.\nIt is possible to directly analyze the causal ordering to\nautomatically detect race conditions [13]. It is also possible\nto automatically construct a system trace that describes how\na race occurs. This still leaves the onerous task of deciding\nwhat behavior is possible in practice and actually correcting\nthe specifications. Complications arise when a scenario\ncontains multiple interrelated races. Attempting to fix races\npiecemeal by examining individual error traces can be\nfrustrating when the races have a common cause that\nshould be resolved directly. Section 10 describes two such\nexamples from a proprietary industrial case study.\n1.1 Main Results of the Paper\nIn the paper, we prove there is a unique minimal general-\nization of a partial order scenario that is race free up to\nsimulation equivalence (Theorem 1). We refer to this\nscenario as the inherent causal scenario. Note that although\nthe inherent causal scenario is unique, its graphical depic-\ntion is not. Within UML and MSC, it is possible to depict the\nsame behavior in several ways due to the many constructs\nthat now exist in these languages. We also prove there is a\nunique minimal race free refinement of the behavioral\nsemantics for a partial order scenario (Theorem 3). We refer\nto this as the inherent refinement ordering. This refinement\ncannot be directly realized as a partial order scenario.\nHowever, messages can be added to the original scenario to\nrealize the behavioral refinement as a partial order scenario\n(Lemma 7), whereas the generalization can be achieved by\nintroducing greater concurrency, which does not require\nany additional messages. Race conditions are studied within\na partial order theoretic framework. Uniqueness results are\nfirst derived purely in terms of partial orders. We then\nconstruct a partial order scenario realization of each partial\norder that characterizes a uniqueness result. This is\nnecessary since an event partial order alone does not\nnecessarily correspond to a partial order scenario.\nThe paper also considers how race conditions can occur\nin iterative scenarios. These extend partial order scenarios\nby adding a loop construct. Loops can be nested, and we\nallow iterative scenarios to be weakly composed. Race\nconditions can still occur within a partial order scenario as\nbefore (which may or may not be part of an iterative\nscenario). However, they can also occur because of loop\nconstructs, which only become evident when the loops are\nunwound. We will refer to the later type of race as an\niterative race.\nThe paper defines a particular property of partial order\nscenarios that we refer to as the convergence property\n(Definition 19). The paper proves that as long as an iterative\nscenario is constructed from race free partial order scenarios\nby means of the loop construct, then it is free of iterative\nraces if and only if each of its composite partial order\nscenarios satisfies the convergence property (Theorem 5).\nFrom this, it is possible to give a constructive algorithm for\nadding finitely many messages to an iterative scenario to\nremove all iterative races and in such a way that the\nmessage flows within loops are not significantly changed.\nHence, the problem of resolving races in iterative scenarios\ncan be reduced to that of resolving them in partial order\nscenarios.\n1.2 Related Work\nThe study of partial order scenarios has been an active topic\nof research for many years. [28] contains an excellent survey\nof related work in this area, which we strongly recommend\nto the reader. [25] is another excellent survey covering\nverification of protocols specified with MSC scenarios. In\nlight of these, we will not attempt to give a complete list of\nall related work here.\nThe problem addressed in this paper is focused on one\nparticular aspect of message flows within a sequence\ndiagram. There is, of course, a wide variety of verification\nissues connected with protocol design. Verification of logical\nproperties fromMSCs andMSC-Graphs has been considered\nby [1], [14], [30], amongst others. This work addresses issues\nsuch as deadlock, livelock, and ensuring correct responses to\nrequests. Much of this work has been based on synthesizing\nfinite state automata for the purposes of model checking. [7],\n[8], [18], [23], [30] consider how to construct state machines\ndirectly from a collection of message sequence charts via\ndifferent kinds of compositional semantics. Other work has\nconsidered how to interpolate missing requirements from\nscenario based specifications [2], [3], [4], [21], [28]. This work\nis useful both in verifying a system and in synthesizing a\nmore complete specification. Alur et al. [3] introduced the\nseminal work that first considered the realizability of\ncollections of MSCs. In their work, they consider when\nMSCs composed via an MSC-Graph can collectively be\nimplemented. The issue they address is orthogonal to that\nconsidered here, as they implicitly regard race conditions as\nbenign in their examples. Research into automatic test\ngeneration from partial order scenarios is another active\nresearch area [5], [6], [9], [26].\nAn interesting variation on mainstream MSC\/UML\nscenarios is given by live sequence charts (LSCs) [15]. As\nmentioned in the introduction, these permit more expressi-\ntivity by permitting exemplary and mandatory behavior to\nbe annotated directly within a scenario. It is also possible to\nsynthesize state machines from LSCs [16]. Although both\nUML and MSC scenarios are widespread in industry, LSCs\nhave not yet achieved a large following outside of the\nacademic community.\nFrom our search of the literature, it appears that our\npaper is novel in that it proves there exists a unique optimal\n768 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\nsolution to a specific class of semantic inconsistencies for\nsequence diagrams, namely, race conditions. It also appears\nto be novel in characterizing the solution purely in partial\norder theoretic terms.\n1.3 Graphical Notation\nAlthough our results apply to any partial order scenarios,\nwe will use MSC as the graphical language for the paper.\nThe MSC standard [31] is stable and MSCs are common in\nindustry. Also, their semantics are targeted at asynchronous\nprotocols. For the type of elementary scenario we describe\nhere, the notation is almost identical for UML sequence\ndiagrams, LSCs, and MSCs. In this section, we give a terse\nand intuitive explanation of the constructs we will use. For\nformal details, the interested reader is referred to the\nstandards [31] and [32].\nConsider the MSC depicted graphically in Fig. 2. Each\nvertical line describes the time-line for a process, where\ntime increases down the page. Messages are depicted by\narrows. Each message m defines a pair of events \u00f0!m; ?m\u00de,\nwhere !m is the send event form and ?m is the receive event\nform. Messages in MSCs are always asynchronous since we\nare dealing only with asynchronous protocols.\nThe distance between two events on a time-line does not\nrepresent any literal measurement of time; only that\nnonzero time has passed. Events on the same time-line\nare ordered linearly down the page, except where they\noccur within a coregion. Within a coregion, events are not\nlocally ordered unless that is directly imposed by a general\norder construct (described below). Coregions are depicted\nwith a dashed line. For process B in Fig. 2 events ?c and ?d\nare unordered as they occur within a coregion.\nIt is possible with MSC and UML notation to describe\nmessage overtaking, as shown in Fig. 1. As is the norm, we\nrule out message overtaking in specifications. That does not\nmean we attempt to forbid message overtaking in practice,\nonly that it may not be specified as having to occur as part\nof the protocol definition.\nThe MSC and UML standards include a general ordering\nconstruct, which is a simple graphical notation that\nexplicitly forces one event to occur before another event.\nA general order construct is depicted as a dashed arrow\nbetween the events to be ordered, with arrowhead placed in\nthe middle of the arrow. For example, the MSC in Fig. 12\ncontains a general ordering construct between the ?b and !c\nevents. Where general ordering constructs span processes\nin an MSC, as in Fig. 12, the MSC is not strictly a partial\norder scenario. Events in different processes may only be\nordered by virtue of interprocess communication, as\nexplained in Definition 4. We will use the general order\nconstruct in simple MSCs to illustrate scenarios, but we\npoint out when the MSC is not a partial order scenario.\nA parallel construct in a MSC\/UML sequence diagram,\ndenoted by keyword PAR, describes a set of concurrent\nthreads that occur in the diagram. Dotted lines delineate the\ndifferent threads. Hence, events from one thread are not\ncausally ordered with respect to events from any other\nthread. Fig. 20 contains two parallel constructs. The first\nparallel construct contains messages a, b, and c in separate\nthreads, which can therefore occur in any order. The\nbounding box of a parallel construct has no effect on the\nordering of events; it solely delineates the scope of the\nconcurrent threads. For example, receive event ?a0 is\nordered before each of ?a, ?b, and ?c, even though these\nevents are not ordered with respect of one another since\nthey are in separate threads. Events within a particular\nthread are ordered in the usual way, so, for example, !c1\nmust be before !c2 in the second parallel construct.\nAn inline reference, denoted by keyword REF, is a\nplaceholder for another sequence diagram. The reference\ncan be replaced by the contents of the other sequence\ndiagram if desired. The reference is weakly composed with\nthe referring diagram when inlined. Fig. 20 contains an\ninline reference spanning processes A through D.\nMSC and UML notations allow a message to be split into\nlost and found events. This allows a message to be sent in\none scenario and received in another. The send part of the\nmessage is represented by a lost event and the receive part\nby a found event. In this paper, we will only use this\nconstruct to simplify the visual layout of scenarios. Hence,\nthe found event corresponding to a lost event always occurs\nin the same scenario. Fig. 11 gives an example where\nmessages a and c have been split into lost and found events.\nThe lost event for !a is depicted by the solid circle\nterminating the arrow midprocess. The found event for ?a\nis depicted by the empty circle that initiates an arrow into\nprocess B. In this paper, we follow the convention that the\nfound event given by a message must always occur after the\nlost event for the message. The MSC and UML standards do\nnot make any formal link between a lost event and a found\nevent; that is, they do not identify them as component parts\nof a single message. However, our convention is only used\nin simplifying the visual layout of our examples and does\nnot affect the theoretical results in any way.\n2 BASIC PARTIAL ORDER SPECIFICATIONS\nIn this section, we define the causal ordering semantics for\npartial order scenarios. We use the same message semantics\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 769\nFig. 1. Message overtaking. Fig. 2. Race hidden by coregion.\nas the MSC 2000 standard [31]. Hence, a partial order\nscenario defines a set of message exchanges between\nprocesses with asynchronous communication channels.\nDefinition 1.\n. A partial order over a set E is a binary relation < such\nthat\n. < is irreflexive, :\u00f0x < x\u00de for any x 2 E,\n. < is transitive, x < y and y < z implies x < z,\nand\n. < is asymmetric, there are no elements x; y 2 E\nsuch that x < y and y < x.\n. We write :\u00f0x < y\u00de to denote that it is not the case that\nx < y.\n. Two elements x and y of E are unordered if :\u00f0x < y\u00de\nand :\u00f0y < x\u00de.\nWhen this is the case, we write x \u00bd<\u0001Un y. We\ndefine a set to be unordered if every pair of distinct\nelements from that set are unordered.\nOften in the literature, this type of partial order is\nreferred to as a strict partial order. Virtually all the partial\norders considered in this paper are strict, so we adopt the\nconvention of taking partial orders as strict unless other-\nwise stated. A nonstrict partial order in the usual sense is\nantisymmetric rather than asymmetric. The antisymmetric\ncondition states that if x < y and y < x, then x \u00bc y.\nDefinition 2.\n. A total order over the set E is a partial order on E\nwhere, for any two distinct elements a and b, either\na < b or b < a.\n. A total extension of a partial order < is any total order\n<1 such that x < y implies x <1 y.\n. The trace of a total order <1 on the set E is the unique\nsequence of the form\ne0 \u0002 e1 \u0002 \u0002 \u0002 \u0002 en;\nwhere E \u00bc fei j 1 \u0003 i \u0003 ng and ei <1 ei\u00fe1 for each i.\n. A trace of the partial order < is the trace of any total\nextension of < .\nLet P be a set of processes. A message m between\nprocesses is a pair \u00f0!m; ?m\u00dewhere !m is the send event form\nand ?m is the receive event for m. We regard !m as\nbelonging to the sending process and ?m as belonging to the\nreceiving process. Let E be the set of all send and receive\nevents between all processes. Each event has a label, let\nl : E \u0004! L be the labeling function. For a message m,\nl\u00f0!m\u00de \u00bc l\u00f0?m\u00de. Within the MSC standard, there are many\nother kinds of events such as action boxes and condition\nsymbols, but here we only consider message events to\nsimplify proofs as much as possible. It is possible to\ngeneralize the results to include these other events.\nDefinition 3. A partial order scenario M on processes P is\n. a collection of disjoint sets E\u00f0P \u00de \u0005 E for each P 2 P\nthat defines the message events belonging to P , and\n. a set of partial orders <P , where <P is a partial order\non E\u00f0P \u00de that defines the local ordering of events for\nprocess P .\nThese local partial orders must be subject to the\nconstraint that for each send event !m in a set E\u00f0P \u00de the\ncorresponding receive event ?m occurs in some set E\u00f0Q\u00de.\nNote that messages are allowed to be sent from a process to\nitself, so we allow P \u00bc Q. We treat a partial order as a\nbinary relation that can be represented as the set of pairs\nthat are ordered by the relation. Hence, we can take the\nunion of partial orders, which is just the set theoretic union\nof the sets that represent the relevant order relations. It is\nimportant to note that the local orders are not necessarily\ntotal, but can be any partial order. In the literature, it is\nsometimes assumed basic scenario diagrams have total local\norderings, so it is worth emphasizing this does not have to\nbe the case.\nLet Msg be the set of messages defined as the set of send\nand receive event pairs:\nf\u00f0!e; ?e\u00de j !e 2 E\u00f0P \u00de and\n?e 2 E\u00f0Q\u00de for some P; Q 2 Pg:\nDefinition 4. The causal ordering <C on a partial order scenario\nis the transitive closure of the relation given by\n\u0001 [\nP2P\n\u00f0<P \u00de\n\u0002\n[Msg:\nNote that all causal orderings are irreflexive, so that\nmessages must be received after they are sent. The causal\nordering defines the set of all possible system traces that are\ngiven by the partial order scenario. A system trace is any\ntotal order extension of <C . Recall that a total order on a\nset S is a partial order < on S where, for any distinct\nelements x; y 2 S, either x < y or y < x.\nDefinition 5. The set of system traces defined by a causal\nordering <C is the set of traces for the causal order <C .\nDefinition 6. Let M be a partial order on events EM , processes\nPM , and process orders f<MP j P 2 PMg. Let N be a partial\norder on events EN , processes PN , and process orders\nf<NP j P 2 PNg. Scenario M is embedded in N if\n. PM \u0005 PN ,\n. EM \u0005 EN , and\n. for all x, y 2 EM and processes P 2 PM\nx <MP y, x <NP y:\nConsider the MSC depicted graphically in Fig. 2. The\nlocal partial orders defined by this MSC are given in Fig. 3\nwhere we draw the ordering downwards, so that !a <B !b,\nfor example. In this case, the causal ordering <C is given in\nFig. 4.\n3 RACE CONDITIONS\nFig. 2 illustrates a race condition. The causal ordering\nasserts that !b <C ?c. If this MSC is taken as a specification, it\nasserts that after C receives a it must send c so that it arrives\nafter b is sent. It is not possible for C to know for sure when\n!b occurs without querying B. Hence, it is quite possible if\nthis scenario is implemented naively that c will arrive\nbefore b is sent, contradicting the specification. This error\n770 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\ncan occur even though each of the processes locally\nimplements the specification correctly.\nDefinition 7. A partial order < on E is defined to be race free\nwhen, for every event x and message e,\nx < ?e ) \u00f0x < !e or x \u00bc !e\u00de:\nAn MSC is defined to be race free when its causal ordering\nis race free.\nThat is, < is race free if the following holds: When <\norders an event x before the receive event of some\nmessage e, then it also orders x to be before the send event\nof e. Note that Fig. 2 is not race free since !b <C ?c, but\n!b 6<C !c.\nFig. 5 shows another typical kind of race condition. This\nis a greatly simplified version of a scenario from a Motorola\ncase study. Two other examples from this case study are\nconsidered in detail in Section 10. In this scenario, A is\ntransmitting messages to C via process B. The only function\nfor B is to forward the messages. A race condition occurs\nhere between !b and ?c. The race occurs since !b <C ?c, but\n!b 6<C !c.\nIn practice, it may be that the latency of messages from A\nto B is large so that B has plenty of time to forward a before\nc is received. However, the semantics do not reflect this. As\nspecified, there is no mechanism for B to guarantee that b\ncan be sent before c is received. Such implicit assumptions\nbased on an existing system can cause problems later when\nnetworks are upgraded and the assumptions are no longer\nvalid. Scenario-based specifications are intended for proto-\ncol designs that are independent of low-level properties of\nthe underlying network. One of the useful side effects of\ncorrecting race conditions is that it tends to focus the design\nat a higher level of abstraction.\n4 PARTIAL ORDER PROCESSES\nIn this section, we define a process algebra semantics of\nsystem traces. This is a standard result for partial orders,\nbut we present it in a slightly nonstandard format for ease\nof use later in the paper. The process algebra term\ncharacterizes the system behavior up to simulation equiva-\nlence (this follows from Lemma 3). In Section 5, we describe\nthe system behavior as a finite state automaton whose states\nare the unordered subsets of E. This allows us to link the\nbehavioral description here with earlier work of [1].\nFirst, we set up some notation for defining sets of events\nthat are important in generating system and process traces.\nDefinition 8. Let < be a partial order on a set of events E. For a\nset S \u0005 E, define\nn\u00f0S;<\u00de \u00bc fx 2 E j 9 y 2 S : y < x;\nand :9 z 2 E : y < z < xg\nmin\u00f0S;<\u00de \u00bc fx 2 S j :9 y 2 S : y < xg\nmax\u00f0S;<\u00de \u00bc fx 2 S j :9 y 2 S : x < yg\ncns\u00f0a; S;<\u00de \u00bc min\u00f0\u00f0S \u0004 fag\u00de [ n\u00f0fag; <\u00de<\u00de:\nThe set n\u00f0S;<\u00de is those events that are a least upper\nbound for some element in S. The set min\u00f0S;<\u00de is just the\nset of minimal elements of S.\nNote that cns\u00f0a; S;<\u00de is always an unordered set since\nthe minimal elements of a set are themselves always\nunordered. The set cns\u00f0a; S;<\u00de defines what events may\nbe consecutive to a in a system trace, when S describes a set\nof events that are eligible to occur concurrently with a at a\ngiven point of the system execution. Suppose we have a\nsystem trace t that is a total extension of < . Let a be some\nevent in t, so that t is of the form t0 \u0002 a \u0002 t1 (where \u0002 denotes\nconcatenation). Let S be the set of minimal events from the\nset of all events not in t0 \u0002 a. Then, t1 must be of the form\nb \u0002 t2, where b 2 cns\u00f0a; S;<\u00de. We can formally prove this\nresult in the following proposition:\nLemma 1. Let < be a partial order on E, a 2 E and\nS \u00bc fx j x\u00bd<\u0001Unag.\n1. If there is a trace for < of the form t0 \u0002 a \u0002 b \u0002 t1, then b\nis an element of cns\u00f0a; S \u0004Ba;<\u00de, where Ba is the set\nof events in t0.\n2. For any b 2 S, there is some trace of the form\nt0 \u0002 a \u0002 b \u0002 t1.\nProof.\n1. Proof of 1.\nLet t be a trace of the form t0 \u0002 a \u0002 b \u0002 t1. We need\nto prove that b 2 cns\u00f0a; S \u0004Ba;<\u00de. Since a occurs\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 771\nFig. 3. Process partial orders.\nFig. 4. Causal ordering.\nFig. 5. Message forwarding race condition.\nbefore b in a trace of < , it follows that :\u00f0b < a\u00de.\nTherefore, either a < b or a\u00bd<\u0001Unb.\na. Consider the case where a < b. Since there is\na trace where b is consecutive to a, there can\nbe no event c where a < c < b. Hence,\nb 2 n\u00f0fag; <\u00de:\nIf it is not the case that\nb 2 cns\u00f0aS \u0004Ba;<\u00de;\nthen there must be some e where e < b and\ne\u00bd<\u0001Una. However, if e < b, then e must have\noccurred at some point in t0 and, hence,\ne 2 Ba. This leads to a contradiction, so we\nmust have that b 2 cns\u00f0a; S \u0004Ba;<\u00de.\nb. Consider the case where a\u00bd<\u0001Unb. Just as in the\nprevious case, if there is any e 2 Ewhere e < b\nand e\u00bd<\u0001Una, then e must occur in t0. Hence, b\nmust be an element of min\u00f0S \u0004Ba;<\u00de. So, by\ndefinition, b 2 cns\u00f0a; S \u0004Ba;<\u00de. This com-\npletes the proof of 1.\n2. Proof of 2.\nThis case is very straightforward and is\nincluded for completeness. Choose any b 2 S. Let\nX \u00bc fx 2 E j x < a or x < bg:\nLet\nY \u00bc E \u0004 fa; bg \u0004X:\nLet t0 be any trace of < restricted to X. Let t1 be\nany trace of < restricted to Y . Clearly, t0 \u0002 a \u0002 b \u0002 t1\nis a trace of < .\nThat completes the proof of the lemma. tu\nThe first element in a trace of < has to come from\nmin\u00f0E;<\u00de. Hence, we can define the system behavior for a\ncausal ordering as follows:\nDefinition 9. For a set S \u0005 E, define a recursive process algebra\nterm by\nP \u00f0S;<\u00de \u00bc\nX\nfa2Sg\na \u0002 P \u00f0cns\u00f0a; S;<\u00de; <\u00de\nand P \u00f0;; <\u00de \u00bc 0.\nWhere a \u0002 P denotes the usual sequential composition of\naction and process, and the summation is nondeterministic\nchoice (as standard in both CCS and CSP [22], [17]).\nDefinition 10. For a partial order < on events E, define the\nobservable behavior of < to be the process:\nP< \u00bc P \u00f0min\u00f0E;<\u00de; <\u00de:\nDefine the observable behavior for partial order scenario M\nwith causal ordering <C to be the process:\nP \u00f0M\u00de \u00bc P<C :\nLemma 2. Let < be a partial order on events E. The traces of\nprocess P< are exactly the traces of < .\nProof.\n. Theproof of Lemma2 is immediate fromLemma1.\nFor processes P and Q, we use the notation\nP \u0004!a Q to denote that P is strong bisimulation\nequivalent to a \u0002Q\u00fe P 0 for some process P 0. Let\na0 \u0002 a1 \u0002 \u0002 \u0002 an\nbe a trace for the partial order < .\nTo prove the lemma, it is enough to prove that\nthereareprocessesPiwherePi\u0004!ai Pi\u00fe1,P \u00f0M\u00de \u00bc P0,\nand Pn\u00fe1 \u00bc 0, where 0 is the empty process. Define\n. U\u00f0ai\u00de \u00bc fe 2 E j e\u00bd<\u0001Unaig,\n. Aj \u00bc fai j 0 \u0003 i \u0003 jg, and\n. Si\u00fe1 \u00bc cns\u00f0ai; U\u00f0ai\u00de \u0004Aj;<\u00de.\nIt follows from Lemma 2 that we may define\nPi\u00fe1 \u00bc P \u00f0Si\u00fe1; <\u00de. Note that Sn\u00fe1 \u00bc ;, so that\nPn\u00fe1 \u00bc 0. This completes the proof. tu\nIn [10], a process algebra semantics is defined for basic\nMSCs (which we refer to as partial order scenarios) that\ncharacterizes system traces. In that work, they provide an\nalgebraic semantics for each of the various constructs for\nbasic MSCs. They also define a particular form of con-\ncurrent composition that reflects the asynchronous com-\nmunication between processes defined by the MSC\nstandard [31]. This is unnecessary for our purposes. We\nonly require a process that captures the system behavior\ndirectly from the causal order. This allows us to use the\nmore elementary definitions given in this paper.\n5 AUTOMATA OF UNORDERED SETS\nFrom the definition for P \u00f0M\u00de, we can construct a finite state\nautomaton A\u00f0M\u00de that also defines the traces of the system.\nThe states of the automaton are unordered sets S \u0005 E. The\ninitial state is S0 \u00bc minE<C, and ; is the accepting state. For\neach a 2 S, there is a transition\nS \u0004!a cns\u00f0a; S;<C\u00de:\nFrom the recursive definition of P \u00f0M\u00de, we can also give a\nrecursive construction for A\u00f0M\u00de. Define Statesi and Transi\nrecursively as follows:\n. States0 \u00bc fS0g, Trans0 \u00bc ;.\n. Define Statesn\u00fe1 to be the sets cns\u00f0a; S;<C\u00de, where\nS 2 Statesn and a 2 S. Define Transn\u00fe1 to be the\ntransitions S \u0004!a cns\u00f0a; S;<C\u00de for S 2 Statesn and\na 2 S.\nThe states of A\u00f0M\u00de are the union of all the Statesi. The\ntransitions of A\u00f0M\u00de are the union of all the Transi. The\nlanguage accepted by A\u00f0M\u00de is exactly the set of traces given\nby P \u00f0M\u00de. The proof of Lemma 2 essentially defines the\ncorrespondence between the traces of the automaton and\nthe traces of the process.\nFig. 6 gives an example of the automaton for events\nfa; b; c; dg with causal order\na < c; b < c; b < d:\nThe start state in Fig. 6 is fa; bg.\n772 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\nThe automaton A\u00f0M\u00de also reflects a lattice structure on\nthe unordered sets of <C . Define a (nonstrict) partial order\n\u0006 on unordered sets as follows. Let\nS \u00bc S [ fx j 9y 2 S : x >C yg:\nDefine S1 \u0006 S2 when\nS1 \u0005 S2:\nThe order \u0006 defines a lattice structure over the\nunordered sets. It turns out that there is a transition\nS \u0004!a S0 in A\u00f0M\u00de if and only if S \u0006 S0 and there is no\nunordered set U where S \u0006 U \u0006 S0. Hence, we can construct\nthe Hasse diagram for \u0006 directly from A\u00f0M\u00de.\nFor U \u0005 E, U is referred to as an upper section if U \u00bcW\nfor some W \u0005 E. In [1], an automaton A0\u00f0M\u00de is defined\nwith states given by the upper sections of E. Transitions are\ngiven by U \u0004!a \u00f0U \u0004 fag\u00de for each a 2 min\u00f0U;<C\u00de. It turns\nout that A0\u00f0M\u00de is isomorphic to A\u00f0M\u00de. The isomorphism\nworks as follows:\nGiven a stateU inA0\u00f0M\u00de, this maps to the statemin\u00f0U;<C\u00de\ninA\u00f0M\u00de. A state S inA\u00f0M\u00demaps to S inA0\u00f0M\u00de. A transition\nS \u0004!a S0 maps to S \u0004!a S0. This gives an isomorphism since,\nfor any upper section U , U \u00bc min\u00f0U;<C\u00de. Also, for any\nunordered set S, S \u00bc min\u00f0S<C\u00de.\nIn this paper, we use unordered sets to construct the\nsystem behavior, rather than upper sections, since they give\na clearer description of possible consecutive events at each\npoint of a system trace. That gives us greater insight into\nhow races can occur, which is what we require for the\nproofs of the main results.\n6 INHERENT CAUSAL BEHAVIOR\nA partial order < on events preserves the message ordering\nwhen !e < ?e for every message e. Let <C be the causal\nordering for a partial order scenario.\nDefinition 11. The inherent causal ordering <I of <C is defined\nto be the transitive closure of the following binary relation < .\nFor every event x and message e, define:\n1. x < !e() x <C !e.\n2. !e < ?e.\nNote that, when regarding a partial order as a set of\npairs, we have\n\u00f0<I\u00de \u0005 \u00f0<C\u00de:\nFig. 7 gives a graphical depiction of the inherent ordering\nfor Fig. 2.\nThe inherent ordering is the causal order of some partial\norder scenario. This follows from the next theorem:\nTheorem 1. The inherent causal ordering <I of a partial order\nscenario with processes P is the transitive closure of the\nfollowing binary relation <0 . For every event x and message e,\ndefine:\n1. x <0 !e() 9P 2 P such that x <P !e.\n2. !e <0 ?e.\nProof. Recall that <I is the transitive closure of the binary\nrelation <1 defined by:\n1. x <1 !e() x <C !e.\n2. !e <1 ?e.\nClearly, <I is an extension of <0 so it only remains to\nprove that <I is contained in the transitive closure of\n<0 . Let <\n\u0007\n0 be the transitive closure of <0 . For a partial\norder < on E, let a <\u00fe b denote that a < b and there is no\nevent w where a < w < b.\nSuppose we have x, y 2 E, where x <I y. The proof\nnow splits depending on whether y is a send or receive\nevent.\n1. Consider the case where y \u00bc !e. In this case,\nx <I !e if and only if x <C !e.\nLet ui be events where\nx <\u00feC u1 <\n\u00fe\nC u2 \u0002 \u0002 \u0002 <\u00feC un <\u00feC !e:\nWe prove this case by induction on n.\nIf x and !e are part of the same process, we are\ndone. So, we may assume this is not the case. Let\n!e belong to process P . Let i be the minimal value\nsuch that ui also belongs to P .\nSuppose that ui \u00bc !f for some message f . By\ndefinition, ui\u00041 does not belong to P . We therefore\nhave ui\u00041 <\u00feC !f , but ui\u00fe1 and !f are on different\nprocesses. However, if for any events g and h on\ndifferent processes, we have g <\u00feC h, then h \u00bc ?k\nand g \u00bc !k for some k. Hence, ui cannot be a send\nevent.\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 773\nFig. 6. Automaton representation of partial order behavior.\nFig. 7. Inherent Ordering of Fig. 2.\nWe may then suppose that ui \u00bc ?f for some\nmessage f . It follows from what we have just said\nthat ui\u00041 \u00bc !f . We have thus constructed a\nsequence:\nx <\u00feC u1 <\n\u00fe\nC u2 \u0002 \u0002 \u0002 <\u00feC ui\u00041 \u00bc !e:\nWe may now apply the induction hypothesis\nto prove that x <\u00070 ui\u00041. By definition, we also\nhave ui\u00041 <0 ui and ui <0 !e. Hence, by transitiv-\nity, x <\u00070 !e. This completes the induction step.\nThe base case is when x <\u00feC u1 <\n\u00fe\nC !e and u1\nbelongs to P , but x does not. This can only be true\nif u1 \u00bc ?f and x \u00bc !f for some f . In which case, it\nfollows that x <\u00070 u1 <0 !e by definition. That\ncompletes the proof by induction.\n2. Consider the case where y \u00bc ?e.\nFrom the definition for <I , this can only be if\nx <I !e <I ?e:\nHence, by case 1, we are done since !e <0 ?e. tu\nIn Fig. 8, we have illustrated the inherent causal scenario\nof Fig. 2 in the form of an MSC using a parallel construct.\nWith the parallel construct, we have separated message c\ninto one concurrent thread and messages b and d into\nanother. The dotted line delineates the two threads within\nthe PAR construct. Note that, since !a is outside the parallel\nconstruct, it must still occur before both ?c and !b. The\nillustrations used in the paper for inherent causal scenarios\ncan be automatically generated from their inherent causal\norders, but we will not describe that process here, as it is a\ndistraction from the central theme of the paper.\nThe inherent causal order for Fig. 5 is shown in Fig. 9.\nThis is isomorphic as a partial order to the inherent causal\norder in Fig. 7. However, because of the partitioning of\nevents between processes the inherent causal scenario for\nFig. 5 is very different to that of Fig. 2.\nOne graphical depiction for the inherent causal scenario\nfor Fig. 5 is given in Fig. 10. In this depiction, all the events\nof process B are placed in a single coregion. This decouples\n?b and ?c, which removes the race. By placing all the events\nin a coregion, we must reintroduce desired orderings\nbetween events on that process by use of general ordering\nconstructs. Hence, there is a general order construct to\nensure ?a <I !b and another to force ?c <I !d.\nIn this particular case, it is not possible to use a parallel\nconstruct in the same way we did earlier to depict the\ninherent causal scenario. It is not as straightforward in this\nexample to separate the concurrent behavior into separate\nlinear threads.\nEach message forwarded by B is essentially treated\nindependently. Hence, the behavior of B is independent of\nthe order that messages are sent to it by A. We can emphasis\nthis more clearly, and simplify the inherent causal scenario\nat the same time, by using lost and found messages.\nFig. 11 gives an alternative depiction of the inherent\ncausal scenario for Fig. 5. It specifies exactly the same causal\norder as Fig. 10. With our convention, outlined in Section 1,\nof only using lost and found events to provide a graphical\nmeans of splitting a message, we have not lost any\ninformation by depicting a and c in this way. However,\nby splitting a and c into lost and found events, we can\nparcel up the rest of the scenario into two concurrent\nlinearly ordered threads within a parallel construct.\nVisually, this more clearly describes the concurrent struc-\nture of the inherent causal scenario than Fig. 10.\n774 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\nFig. 8. Inherent causal scenario of Fig. 2 as MSC.\nFig. 9. Inherent ordering of Fig. 5.\nFig. 10. Inherent causal scenario of Fig. 5.\nFig. 11. Alternative depiction for inherent causal scenario of Fig. 5.\n7 CANONICAL INHERENT PROCESSES\nRecall in Section 4 that we defined the observable process\nbehavior P \u00f0M\u00de of a partial order scenario M.\nDefinition 12. The inherent process behavior of a partial order\nscenario M is defined to be\nPI\u00f0M\u00de \u00bc P \u00f0min\u00f0E;<I\u00de; <I\u00de:\nLet t denote the standard simulation relation for process\nalgebras. That is, P t Q iff\n. for every transition Q \u0004!a Q0, there exists a transition\nP \u0004!a P 0 where P 0 t Q0:\nTheorem 2.\n. \u00f0<I\u00de \u0005 \u00f0<C\u00de and PI\u00f0M\u00de t P \u00f0M\u00de.\n. For any race free partial order< that preserves message\nordering, let P< \u00bc P \u00f0min\u00f0E;<\u00de; <\u00de. Then, P< t\nP \u00f0M\u00de iff \u00f0<\u00de \u0005 \u00f0<I\u00de \u0005 \u00f0<C\u00de and P< t PI\u00f0M\u00de.\nThat is, PI\u00f0M\u00de is the canonical process that simulates\nP \u00f0M\u00de and is race free. To say that \u00f0<1\u00de \u0005 \u00f0<2\u00de means that,\nfor every x and y in E, when x <1 y, then x <2 y.\nThis theorem proves that the order <I describes the\nmaximal ordering with respect to simulation equivalence\nthat is a race free weakening of <C . Hence, constructing an\nMSC that has partial order semantics given by <I defines a\nnew MSC that corrects any race conditions in M and\nweakens the causal ordering of M as little as possible. It is\nstraightforward to construct such an MSC.\nThe theorem is a consequence of the following lemmas\ntogether with Lemma 2. For any partial order < (which is\nnot necessarily race free), let T \u00f0<\u00de be the set of total\nextensions of < .\nLemma 3. For partial orders <1 and <2 , where\nP<1 t P<2 ;\nthen \u00f0<1\u00de \u0005 \u00f0<2\u00de\nProof. Note that x < y iff for every trace in T \u00f0<\u00de, x occurs\nbefore y in the trace. When P<1 t P<2 , then the set of\ntraces for P<2 is contained in the set of traces for P<1 , that\nis, T \u00f0<2\u00de \u0005 T \u00f0<1\u00de.\nx <1 y) x occurs before y in every trace of T \u00f0<1\u00de\n) x occurs before y in every trace of T \u00f0<2\u00de\n) x <2 y:\nHence, \u00f0<1\u00de \u0005 \u00f0<2\u00de, which concludes the proof. tu\nLemma 4. Given two partial orders<1 and<2 , T \u00f0<1\u00de \u0005 T \u00f0<2\u00de\niff P<1 u P<2 :\nProof. Note that T \u00f0<1\u00de \u0005 T \u00f0<2\u00de iff \u00f0<2\u00de \u0005 \u00f0<1\u00de.\nGiven \u00f0<2\u00de \u0005 \u00f0<1\u00de, to prove P<1 u P<2 , it is enough to\nprove that for any S \u0005 E and a 2 E,\ncns\u00f0a; S;<1\u00de \u0005 cns\u00f0a; S;<2\u00de: \u00f01\u00de\nLet\nm1 \u00bc min\u00f0\u00f0S \u0004 fag\u00de [ n\u00f0fag; <1\u00de; <1\u00de\nm2 \u00bc min\u00f0\u00f0S \u0004 fag\u00de [ n\u00f0fag; <2\u00de; <2\u00de:\nWe write U \u0003 V for sets U; V \u0005 E when, for each\nu 2 U , there is some v 2 V such that u \u0003 v. Note that\nsince \u00f0<2\u00de \u0005 \u00f0<1\u00de, then n\u00f0fag; <2\u00de \u0003 n\u00f0fag; <1\u00de.\nFor a contradiction, suppose that x 2 m1 and x 62 m2.\nThis implies there is some y 2 m2 such that x <2 y. First\nconsider if y 2 S \u0004 fag. Then, x <1 y 2 S \u0004 fag, hence,\nx 62 m1. This is a contradiction, hence, we must have\ny 2 n\u00f0fag; <2\u00de.\nSince n\u00f0fag; <2\u00de \u0003 n\u00f0fag; <1\u00de, there is some y0 2\nn\u00f0fag; <1\u00de such that x <2 y <1 y0. Therefore,\nx <1 y\n0 2 n\u00f0fag; <1\u00de;\nand so x 62 m1. Again, a contradiction as required to\ncomplete the proof of (1). The proof that T \u00f0<1\u00de \u0005 T \u00f0<2\u00de\nimplies P<1 u P<2 , is completed once we note that\nminE<1 \u0005 minE<2.\nThe converse implication for the lemma is straightfor-\nward. It is true for any processes P and Q that, if P t Q,\nthen the set of traces of Q is contained in the set of traces\nfor P . Since the traces of P<i are exactly T \u00f0<i\u00de, the result\nis then immediate. That completes the proof of the\nlemma. tu\nLemma 5. For a partial order < that preserves message ordering\nand is race free,\n\u0001\n\u00f0<\u00de \u0005 \u00f0<C\u00de\n\u0002\n)\n\u0001\n\u00f0<\u00de \u0005 \u00f0<I\u00de \u0005 \u00f0<C\u00de\n\u0002\n:\nProof. For this it is enough to prove that, whenever x < y,\nthen x <I y. The proof splits into cases depending on\nwhether y is a receive or send event.\n. First, suppose that y \u00bc !e for some message e.\nThen, x < !e implies x <C !e since \u00f0<\u00de \u0005 \u00f0<C\u00de. By\ndefinition of <I , x <C !e implies x <I !e.\n. The other case is where y \u00bc ?e for some message\ne. Since < is race free, x < ?e implies that x < !e.\nAs above, this implies x <I !e. The ordering <I\npreserves message ordering and, hence, x <I ?e.\nThis completes the proof of the lemma. tu\n8 INHERENT REFINEMENT BEHAVIOR\nIn this section, we define the inherent refinement ordering.\nThis is the dual of the inherent causal order in that it\ncharacterizes the minimal refinement of a causal order that\nis race free. This is proved by Theorem 3, which is the dual\nresult of Theorem 2. However, it is not the case that we can\nprove the dual result to Theorem 1. That is, the inherent\nrefinement ordering cannot necessarily be defined as the\ncausal order for some partial order scenario. In Lemma 6,\nwe give a counter example and prove that the refinement\norder of this example can never be the causal order of a\npartial order scenario. In Lemma 7, we prove that every\nrefinement order can at least always be embedded in a race\nfree partial order scenario.\nDefinition 13. The inherent refinement ordering <R of a causal\nordering <C is defined to be the transitive closure of the\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 775\nfollowing binary relation < . For every event x and message e,\ndefine:\n. x < !e() x <C ?e.\n. !e < ?e.\nFirst note that <R is race free. Since it is clear from the\ndefinition that x <R ?e implies that x <R !e or x \u00bc !e. Also,\nnotice that the refinement order only extends <C by forcing\nparticular send events to be delayed so that other events\nmay occur first and, hence, is implementable.\nIf the partial order scenario is represented as an MSCM,\nthen the inherent refinement ordering can be constructed by\nadding suitable general orderings toM. These general order\nconstructs cause appropriate send events to wait until the\nrelevant receive events have occurred.\nFor example, the MSC in Fig. 12 describes the inherent\nrefinement order for the partial order scenario in Fig. 2.\nNote that Fig. 12 is not a partial order scenario. The general\norder construct here acts across processes and not within a\nsingle process. The causal order for a partial order scenario\ncan impose an arbitrary ordering within a process, but\nevents in separate processes can only be ordered because of\ninter-process communication. The general ordering in\nFig. 12 is clearly not the result of any interprocess\ncommunication. In fact, we prove in Lemma 6 that the\nrefinement order for Fig. 2 can never be the causal order for\na partial order scenario.\nLemma 6. Let <0R be the refinement order of the partial order\nscenario given by the MSC in Fig. 2. Then, there is no partial\norder scenario whose causal order is an extension of <0R .\nProof. Recall from Definition 4 that the causal order for a\npartial order scenario is defined as the transitive closure\nof the relation given by\n\u0001 [\nP2P\n\u00f0<P \u00de\n\u0002\n[Msg;\nwhere <P are the various process orders for the\nscenario. The process orders for A, B, and C inferred\nby <0R are just those defined by Fig. 3. Any partial order\nscenario that extends <0R has to be the result of\nextending the process partial orders <A , <B , and <C .\nNote that <A and <C are total orders and so cannot\nbe extended any further. Hence, any causal order that is\nan extension of <0R must extend <B .\nHowever, it is clear that no extension of <B can cause\n!b to be ordered before !c in the resulting causal order.\nThat is, there are no extensions of <A , <B , and <C that\nresult in a causal order that extends <0R as required to\ncomplete the proof. tu\nAlthough the inherent refinement order is not a true\ncausal order, we can embed it within a race free partial\norder scenario. That is, it is possible to add messages to a\npartial order scenario so that the resultant scenario is race\nfree. In addition, when restricted to the events of the\noriginal scenario, the new scenario defines exactly the same\nprocess orders and its causal order is exactly the inherent\nrefinement ordering of the original scenario. This is\nprecisely stated in Lemma 7.\nLemma 7. Let M be a partial order scenario on events E, with\nprocesses P and process ordering <P for each P 2 P. Let <R\nbe the inherent refinement order for M.\nThere is a race free partial order scenario Mm on events\nEm, with processes P, process orderings <mP for each P 2 P,\nand causal order <mC such that\n1. For each P 2 P, E\u00f0P \u00de \u0005 Em\u00f0P \u00de.\n2. For each P 2 P and each x, y 2 E\u00f0P \u00de\nx <P y() x <mP y:\n3. For each x, y 2 E\nx <R y() x <mC y:\nProof.We initializeMm to beM and add new messages and\nmodify the process ordering as follows:\nRecall that the refinement order is defined by adding\nx <R !e whenever x <C ?e.\nFor each such pair where x 2 P1 and !e 2 P2, we\ndefine a new message mxe , where we add !m\nx\ne to E\nm\u00f0P1\u00de\nand ?mxe to E\nm\u00f0P2\u00de.\nThe set Em consists of E together with all such new\nevents.\nFor each such pair, add x <mP1 !m\nx\ne and ?m\nx\ne <\nm\nP2\n!e.\nThe causal order for Mm restricted to E is exactly <R\nand the process orders forMm restricted to E are exactly\nthe same as for M, as required. tu\nFig. 13 shows one way in which the refinement order for\nFig. 2 can be embedded in a partial order scenario. This\nscenario is given by the construction outlined in the proof of\nLemma 7.\nThe refinement order itself is the unique minimal race\nfree refinement of a causal order, as proved below in\nTheorem 3. However, the choice of embedding for the\nrefinement order is not unique. The UML and MSC\nstandards contain other constructs that could be used to\nembed the refinement ordering in a scenario. In this paper,\nwe do not further address the problem of choosing how to\nembed a refinement order within a scenario. Such a choice\nis best left to system designers who will want to use\nconstructs suited to their particular circumstances.\nLemma 8.\n\u00f0<C\u00de \u0005 \u00f0<R\u00de:\nProof. To prove this, suppose x <C y. The proof is split into\ntwo cases depending on whether y is a send or receive\n776 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\nFig. 12. Inherent refinement ordering of Fig. 2 as MSC.\nevent. If y \u00bc !e for some e, then y <C ?e. Hence, from the\ndefinition, x <C ?e, and, hence, x <R !e. That is, x <R y.\nWhen y \u00bc ?e, then x <R !e. Also, !e <R ?e, hence, by\ntransitive closure, x <R ?e \u00bc y. This completes the proof\nof the lemma. tu\nLemma 9. For any race free transitive partial order < that\npreserves messages and where \u00f0<C\u00de \u0005 \u00f0<\u00de, then\n\u00f0<C\u00de \u0005 \u00f0<R\u00de \u0005 \u00f0<\u00de:\nProof. To prove this, first consider an event x and message e\nwhere x 6\u00bc ?e and x <C ?e. Therefore, x <R !e. Since\n\u00f0<C\u00de \u0005 \u00f0<\u00de, we have x < ?e. Since < is race free, we have\nx < !e. Hence, if x <R !e, then x < !e. Since < preserves\nmessages, it trivially follows that !e <R ?e implies\n!e < ?e. Hence, as < is transitive, we have proven that\n\u00f0<R\u00de \u0005 \u00f0<\u00de. tu\nGiven the lemmas already proven in Section 7, we have\nthus proven the following theorem, which is the dual to\nTheorem 2.\nTheorem 3. Let PR\u00f0M\u00de \u00bc P \u00f0minE<R;<R\u00de, then\n. \u00f0<C\u00de \u0005 \u00f0<R\u00de and P \u00f0M\u00de t PR\u00f0M\u00de:\n. For any race free partial order< that preserves message\nordering, let P< \u00bc P \u00f0min\u00f0E;<\u00de; <\u00de. Then, P \u00f0M\u00de t\nP< iff \u00f0<C\u00de \u0005 \u00f0<R\u00de \u0005 \u00f0<\u00de and PR\u00f0M\u00de t P<:\nHence, <R is the canonical refinement of the causal\norder that corrects all race conditions in the specification.\n9 INLINE ITERATION\nIn this section, we extend the notion of partial order\nscenarios with weak compositional iteration. Iterative\nscenarios cannot be characterized by a single partial order\nscenario and instead define a set of partial order scenarios.\nThis set can be infinite if the iteration is unbounded. The\nsemantics defined here is the same as the MSC\/UML\nsemantics for iterative scenarios.\nFirst, we define inline composition of partial order\nscenarios. Let E1 and E2 be disjoint sets of events and let\nl : E1 [E2 \u0004! L be the labeling function. LetM1 be a partial\norder scenario defined over E1 consisting of processes P1\nand M2 be a partial order scenario over E2 consisting of\nprocesses P2. Note that there is no particular relationship\nbetween P1 and P2, i.e., they do not have to be identical and\nmay even be distinct. Although the event sets are distinct\nthe events can have the same labels. Let <iP denote the local\norder for process P in scenario Mi.\nDefinition 14. For partial orders <1 on S1 \u0005 E1 and <2 on\nS2 \u0005 E2, define the ordering \u00f0<1;<2\u00de to be the transitive\nclosure of:\n. For a; b 2 Si, a\u00f0<1;<2\u00deb iff a <i b:\n. For all a 2 S1 and b 2 S2, a\u00f0<1;<2\u00deb:\nDefinition 15. The inline composition M \u00bcM1; M2 is defined\nto be the partial order scenario consisting of events E1 [E2\nand processes P1 [ P2.\nThe local order <P for M splits into the following cases:\n. For P 2 P1 \u0004 P2, \u00f0<P \u00de \u00bc \u00f0<1P \u00de.\n. For P 2 P2 \u0004 P1, \u00f0<P \u00de \u00bc \u00f0<2P \u00de.\n. For P 2 P1 \\ P2, \u00f0<P \u00de \u00bc \u00f0<1P ;<2P \u00de.\nWe write M;M to denote the inline composition of\ntwo copies of M where we have renamed all the events in\nthe second copy to be distinct from the first copy, while\npreserving the local orderings and labels. The expressionMn\nis defined to be n copies ofM composed inline:M;M; . . . ;M.\nIt is important to realize that the causal order forM1; M2,\nin general, is not \u00f0<C1 ;<C2\u00de. The inline composition of\ntwo partial order scenarios represents the graphical intui-\ntion of concatenating two scenarios by visually attaching\none after the other, as can be seen by examining the MSC\nexample shown in Fig. 14.\nIteration will be specified in terms of sets of partial order\nscenarios. Hence, we need to extend the definition of\ncomposition to cater for this.\nDefinition 16. An extended scenario S is defined to be a finite set\nof partial order scenarios. Define the traces of S to be the union\nof the traces for the partial order scenarios contained in S .\nDefinition 17. Let S 1 and S 2 be extended scenarios. Define\nS 1; S 2 to be\nf\u00f0M1; M2\u00de jM1 2 S 1; M2 2 S 2g:\nWe can now define inline iteration for extended\nscenarios as follows:\nDefinition 18. The nth iteration for extended scenario S is\ndefined to be the set\nS n \u00bc fMi1 ; . . . ;Min jMij 2 Sg:\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 777\nFig. 13. Refinement ordering embedded in partial order scenario. Fig. 14. M1, M2, and \u00f0M1;M2\u00de.\nDefine the inline iterative loop construct loophm;ni\u00f0S \u00de to be\nthe union\n[i\u00bcn\ni\u00bcm\nS i:\nlooph0;1iS denotes the union of all finite iterations of S .\nNote that this is an infinite set of partial order scenarios\nand so not an extended scenario.\nFor a partial order scenario M, we will adopt the\nconvention of writing loophm;ni\u00f0M\u00de as short hand for\nloophm;ni\u00f0fMg\u00de. When m and n are finite, loophm;ni\u00f0M\u00de is\nalso finite.When resolving races for loophm;ni\u00f0M\u00de, we could\nsimply resolve the races in each separate iteration Mk. The\nresultmay no longer be a simple iteration, depending on how\nthe races are resolved.However, the result is still an extended\nscenario. Therefore, from a theoretical perspective, resolving\nraces in bounded loops does not pose a serious problem since\nit can be reduced to resolving races in a finite set of partial\norder scenarios. An unbounded loop looph0;1i\u00f0M\u00de denotes\nan iteration that can occur any finite number of times, but\nwhere it is not known in advance how many times. For\nexample, unbounded loops can be used to represent \u201cdo\nuntil\u201d iterations. This type of iteration could occur for\nexample where a base station is attempting to reestablish a\ndropped connection and is repeatedly sending a connect\nrequest. It will continue to send the request until it gets an\nacknowledgement. The question that remains for the rest of\nthe section is how to resolve races in unbounded loops.\nFig. 15 gives the graphical depiction for looph0;1i\u00f0M\u00de\nwhenM contains only a single message x between processA\nand B. In this example, note that M2 will contain a race. As\nwe now have distinct messages that can have the same label,\nwe are no longer free to identify a message with its label as\nwe did in earlier examples. In this example, let there be\nevents ?e1 and ?e2 with l\u00f0e1\u00de \u00bc l\u00f0e2\u00de \u00bc x. Then, ?e1 <C ?e2,\nbut :\u00f0?e1 <C !e2\u00de, which defines a race. ForMn, there will be\nn consecutive copies of the message x from A to B, resulting\nin n\u00f0n\u0004 1\u00de=2 race conditions. This example illustrates that\neven when a basic scenario is race free the iteration of the\nscenario may well not be.\nDefinition 19. An iterative scenario is defined recursively as\n. any partial order scenario, or\n. any scenario of the form S 1; looph1;1i\u00f0S 2\u00de; S 3,\nwhere S 1, S 2 and S 3 are iterative scenarios.\nFor brevity,wewillwriteS1 as shorthand for looph1;1i\u00f0S \u00de\nfrom now on.\nNotice that, since S 1, S 2, or S 3 could be the empty set in\nthis definition, we are free to combine extended scenarios\nby adding infinite loops whenever we wish. This definition\nrestricts those infinite sets of partial order scenarios we\nwish to consider so that they must be the result of the loop\nconstruct. Note that we constrain unbounded loops so that\nthey iterate at least once. This is done to avoid unnecessary\ndetail in the proofs and can be done without loss of\ngenerality.\nLemma 10. There is no generalization of the iterative scenario in\nFig. 15 that is race free.\nProof. In this case, it is only possible to generalize the\niteration by generalizing the body of the loop. Clearly,\nthe loop body can not be any further generalized. The\nonly partial order weaker than !x < ?x is the unordered\nset f!x; ?xg. This, however, is not a partial order scenario.\nSuch scenarios must preserve message ordering; hence,\nthere is no generalization possible for the iteration. tu\nThis lemma proves that the idea of weakening an\niterative scenario to remove races is not possible in general.\nThe problem stems from the fact that iteration semantics are\ndefined via weak composition of the iterations of the loop\nbody. Therefore, the events for a process P in iteration n\nare, by definition, always ordered before the events of P in\niteration n\u00fe 1. However, to resolve races between events\nfrom different iterations by generalization requires some\nway to specify a weakening of the local process orders\nacross these different iterations. In order to proceed further,\nwe need to characterize race conditions in iterative\nscenarios in a manner that can be easily checked.\nDefinition 20. Let M be a partial order scenario over events E\nand causal order <C .\nFor x 2 E, let x \u00bc fxg [ fy 2 E j x <C yg and let\nx \u00bc fxg [ fy 2 E j y <C xg. For an event x, let P \u00f0x\u00de be the\nprocess P , where x 2 E\u00f0P \u00de. For a set of events S \u0005 E, let\nP \u00f0S\u00de be fP \u00f0x\u00de j x 2 Sg.\nDefine M to be convergent if whenever there are events e\nand ?x, where P \u00f0?x\u00de 2 P \u00f0e\u00de, then\nP \u00f0!x\u00de \\ P \u00f0e\u00de 6\u00bc ;:\nNotice that the definition of convergence is constructive.\nHence, it is straightforward to check if a scenario is\nconvergent or not. The notion of convergence has simila-\nrities with the notion of boundedness defined in [1], [3],\n[21]. For a partial order scenario M, define a graph G that\nhas nodes given by the processes in M. Define an edge\nbetween nodes P and Q exactly when there is a message\nfrom P to Q.M is bounded if G is strongly path connected.\nThat is, there are paths between any two nodes in both\ndirections. In [1], property checking for an arbitrary\niterative message sequence chart (MSC) is proved to be\nundecidable. They prove that when the body of every\niterative loop in an MSC is bounded then property checking\nbecomes decidable.\nAlthough the convergent and bounded definitions have\nsimilarities, they define distinct sets of partial order\nscenarios. Fig. 16 shows a partial order scenario that is not\nconvergent, but is bounded. It is not convergent since we\nhave P \u00f0!b\u00de \\ P \u00f0!d\u00de \u00bc ; but P \u00f0?b\u00de 2 P \u00f0!d\u00de. Fig. 17 shows a\npartial order scenario that is convergent, but is not\nbounded.\n778 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\nFig. 15. Unbounded iterative loop.\nTheorem 4. LetM be a race free partial order scenario. Then, M\nis convergent if and only if M1 is race free.\nProof. First, we prove that, if M is convergent, then M1 is\nrace free. Fora contradiction, suppose thatM is convergent\nand there is a race inM1. For an event e 2 E, wewill write\nen to denote the occurrence of e in the nth iteration of the\nloop. We use the notation\nen <1C h\nn\u00fem\nto denote that event e in the nth iteration is less than h in\nthe \u00f0n\u00fem\u00deth iteration according to the causal order for\nMn\u00fem.\nIf M1 has a race (since M is race free), there must be\nevents e and ?x such that en <1C \u00f0?xn\u00fem\u00de and :\u00f0en <1C\n\u00f0!xn\u00fem\u00de\u00de for some m > 0.\nConsider any events u and v, where :\u00f0u <C v\u00de and\nun <1C v\nn\u00fe1. Then, there must be events u1 and v1 where\nu <C u1, v1 <C v, and P \u00f0u1\u00de \u00bc P \u00f0v1\u00de. This is exactly the\ncondition that P \u00f0u\u00de \\ P \u00f0v\u00de 6\u00bc ;.\nSince en <1C \u00f0?xn\u00fem\u00de, there must be some g 2 E where\nen <1C g\nn\u00fem\u00041 <1C \u00f0?xn\u00fem\u00de:\nConsider if gn\u00fem\u00041 <1C \u00f0!xn\u00fem\u00de. Then, trivially, there is\nno race between e and ?x, which is a contradiction.\nTherefore, :\u00f0gn\u00fem\u00041 <1C \u00f0!xn\u00fem\u00de\u00de. That is, gn\u00fem\u00041 and\n!xn\u00fem are in a race. In which case, we must also have\nthat g1 and !x2 are in a race. This last deduction is not\nvital for the proof, but it makes the notation much less\ncumbersome as we proceed.\nLet ?x belong to process P . Consider if P 62 P \u00f0g\u00de.\nThen, there must be a process Q and events h1,\nh2 2 E\u00f0Q\u00de, where g <C h1 and h2 <C ?x. Since there is a\nrace between g1 and !x2, we have that h2 6<C !x. Therefore,\nwe have constructed a race between h2 and ?x. This is a\ncontradiction as M is race free. Therefore, P 2 P \u00f0g\u00de.\nSince M is convergent, this implies P \u00f0!x\u00de \\ P \u00f0g\u00de 6\u00bc ;.\nFrom our earlier observation, this can only be true when\ng1 <1C \u00f0!x2\u00de. This contradicts that there is a race between\ng and ?x, which in turn contradicts that there is a race\nbetween e and ?x. Hence, we have proved that, if M is\nconvergent, then M1 is race free.\nTo prove the converse, we prove that if M is not\nconvergent, then there is a race in M1. Suppose that\nwe have events e and ?x where P \u00f0?x\u00de 2 P \u00f0e\u00de but\nP \u00f0!x\u00de \\ P \u00f0e\u00de \u00bc ;.\nSince P \u00f0?x\u00de 2 P \u00f0e\u00de, we have that e1 <1C \u00f0?x2\u00de. As we\nobserved earlier in the proof, un <1C v\nn\u00fe1 if and only if\nP \u00f0u\u00de \\ P \u00f0v\u00de 6\u00bc ;. Therefore P \u00f0!x\u00de \\ P \u00f0e\u00de \u00bc ; can only be\ntrue if e1 6<C \u00f0!x2\u00de. Hence, we have a race between e and\n?x in M1. This concludes the proof. tu\nThis result gives us a precise characterization of when a\nloop will generate a race purely in terms of the causal\nordering for the body of the loop. Theorem 4 will enable us\nto resolve races that occur as a result of iteration solely by\nmodifying the body of the loop. This can usually be done by\nadding suitable messages to the loop body to ensure the\nresult is convergent, as we shall demonstrate in the\nremainder of the section. First, we extend the notion of\nconvergence.\nDefinition 21. LetM andN be partial order scenarios. We define\nM to be convergent with respect toN when, for every e 2 E\u00f0M\u00de\nand ?x 2 E\u00f0N\u00de, if P \u00f0?x\u00de 2 P \u00f0e\u00de, then P \u00f0!x\u00de \\ P \u00f0e\u00de 6\u00bc ;.\nThis version of convergence precisely captures when the\ncomposition of two race free partial order scenariosM;N is\nalso race free. WhenM is not convergent with respect to N ,\nthenusually it is possible to embedM in someM 0 so thatM 0 is\nthen convergent with respect to N and soM 0;N is race free.\nLemma 11. When M and N are race free partial order scenarios,\nthen M;N is race free if and only if M is convergent with\nrespect to N .\nThe proof of this lemma is immediate from the definition\nof the causal order for M;N .\nDefinition 22. Let M be a partial order scenario with events E\nand causal order <C . We define f!mi 2 E j 1 \u0003 i \u0003 ng to be a\nvirtual lower cycle when:\n. !mi 2 min\u00f0E<C\u00de for 1 \u0003 i \u0003 n,\n. ?mi 2 minE\u00f0P \u00f0?mi\u00de\u00de<C for 1 \u0003 i \u0003 n,\n. P \u00f0?mi\u00de \u00bc P \u00f0!mi\u00fe1\u00de for 1 \u0003 i \u0003 n\u0004 1, and\n. P \u00f0?mn\u00de \u00bc P \u00f0!m1\u00de.\nWe define f!mi 2 E j 1 \u0003 i \u0003 ng to be a virtual upper cycle\nwhen:\n. !mi 2 max\u00f0E<C\u00de for 1 \u0003 i \u0003 n,\n. ?mi 2 maxE\u00f0P \u00f0?mi\u00de\u00de<C for 1 \u0003 i \u0003 n,\n. P \u00f0?mi\u00de \u00bc P \u00f0!mi\u00fe1\u00de for 1 \u0003 i \u0003 n\u0004 1, and\n. P \u00f0?mn\u00de \u00bc P \u00f0!m1\u00de.\nScenario M contains no virtual cycles when it contains no\nupper or lower virtual cycles.\nFig. 19 shows an example of a partial order scenario that\ncontains a lower and upper virtual cycle, both given by !a,\n!b, and !c. Let U be the scenario in Fig. 19. The virtual cycle\nmeans there is no race free partial order scenario that we\ncan embed U into. To make progress we will need to avoid\nsuch scenarios.\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 779\nFig. 16. Bounded and not convergent scenario.\nFig. 17. Convergent and not bounded scenario.\nLemma 12. LetM andN be race free partial order scenarios. IfN\ncontains no virtual lower cycles, then we can embed M in a\nrace free scenario M # N which is convergent with respect to\nN . Hence,\n\u00f0M # N\u00de;N\nis race free.\nIf M contains no virtual upper cycles, then we can embed\nN in a race free scenario M \" N so that M is convergent with\nrespect to M \" N . Hence,\nM; \u00f0M \" N\u00de\nis race free.\nProof.We will proveM # N exists by construction. Let <M\nbe the causal order forM and <N be the causal order for\nN . Let EM be the events for M and EN be the events for\nN . Define a pair ?x 2 EN and e 2 EM to be divergent\nwhen P \u00f0?x\u00de 2 P \u00f0e\u00de but P \u00f0!x\u00de \\ P \u00f0e\u00de \u00bc ;.\nWe initialize M # N to be M and add messages as\nfollows: Let ?x 2 EN and e 2 EM be a divergent pair. Let\nu 2 maxEM<M , where e <M u. Let P \u00f0!x\u00de \u00bc P and\nP \u00f0u\u00de \u00bc Q. Add a new message w to M # N , where !w 2\nE\u00f0Q\u00de and ?w 2 E\u00f0P \u00de. It may be necessary to add P to\nPM if this is not already present. Modify the process\nordering in M # N for P so that u <P !w.\nBy adding ?w to P , we have forced e < !x, where < is\nthe causal order for \u00f0M # N\u00de;N . However, we may have\nnow introduced a race since it is possible that there is\nsome ?x1 2 minP<N . If this is so, we must introduce\nanother message w1 to M # N . Add !w1 to P and add\n?w < !w1. Also, add ?w1 to process P \u00f0!x1\u00de. This removes\nthe race between ?x1 and ?w. However, there may be\n?x2 2 minE\u00f0P \u00f0!x1\u00de\u00de<N . In which case, we have intro-\nduced a race between ?w1 and ?x2. We continue to add\nextra messages wi until all such races are removed. Since\nN has no virtual lower cycles, there will be some value k\nsuch that, after the addition of wk, we do not introduce\nfurther races. Notice that all the new messages wi are\nadded to the end ofM, so that a <M b if and only if a < b\nfor every a, b 2 EM .\nFor each divergent pair, add new messages to M # N\nas described. The final scenario is by construction\nconvergent with respect to N . Also by construction, M\nhas been embedded in M # N .\nThe construction forM \" N is dual to the construction\nof M # N . Initialize M \" N to N . Let ?x and e be a\ndivergent pair. Let u 2 minEN<N where u <N !x. Add a\nnew message wwhere !w is added to process P \u00f0e\u00de and ?w\nis added to process P \u00f0!x\u00de \u00bc P . Change the process order\nin M \" N so that ?w <P !x. As before, we may have\nadded a race condition in introducing this new message.\nJust as before, we repeatedly add new messages wi until\nno new races are introduced. SinceM contains no virtual\nupper cycles, this process is guaranteed to terminate. By\nadding new messages in this way for each divergent\npair, we construct M \" N as required. tu\nLemma 12 gives us the construction we need to resolve\nall races within an iterative scenario, provided it has no\nvirtual cycles.\nTheorem 25. Let S be an iterative scenario composed of race free\npartial order scenarios that contain no virtual cycles. Then we\ncan resolve all race conditions in S by embedding each\ncomposite partial order scenario within a convergent scenario.\nProof. The proof is by recursion. Suppose we cannot write S\nin the form M1; S\n0;M2 for some partial order scenarios\nM1,M2 and iterative scenario S\n0. In that case, S can only\nbe of the formM1 orM for some partial orderM. When\nS is a partial order scenario, then we can replace it by an\nembedding of the refinement causal order. Consider the\ncase S \u00bcM1. By the hypothesis, M contains no virtual\ncycles. Therefore,M #M is convergent with respect toM.\nThat is,M #M is convergent in the sense of Definition 20.\nHence, \u00f0M #M\u00de1 is race free by Theorem 4. That\ncompletes the proof for the base case.\nConsider the casewhere S is of the form S 1; S\n1\n2 ; S 3 and\neach S i is race free. Write S 1 \u00bc S 01;M1 and S 3 \u00bcM3; S 03.\nSuppose S 2 \u00bc N1; S 02;N2. Then,\nS 01; \u00f0M1 # \u00f0N1 \" N2\u00de\u00de;\n\u00f0\u00f0N1 \" N2\u00de; S 02;N2\u00de1;\n\u00f0N2 \"M3\u00de; S 03\nis a race free resolution for S . If S 2 \u00bcM1, then we can\nassume M is convergent without loss of generality. In\nthis case,\nS 01; \u00f0M1 #M\u00de;M1; \u00f0M \"M3\u00de; S 03\nis race free. This completes the proof. tu\nNotice that we do not claim this resolution is canonical.\nThis is still an active area of research and it is not yet clear\nwhat will be the optimal resolution for races that are caused\nby iteration of partial order scenarios. Fig. 18 illustrates one\nexample of a convergent embedding for Fig. 16.\n780 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\nFig. 18. Convergent embedding of Fig. 16.\nFig. 19. Virtual cycle.\n10 INDUSTRIAL CASE STUDY EXAMPLES\nIn collaboration with Motorola Research Labs, we have\nbeen conducting a number of case studies [5], [23] into\nautomating pathology detection in MSC telecommunication\nspecifications. The two examples examined in this section\ncome from a proprietary study involving roughly one\nhundred UML 2.0 sequence diagrams. These formed part of\nthe specification for a High Speed Downlink Packet Access\n(HSPDA) protocol stack.\nThere were approximately fifteen diagrams containing\nmultiple race conditions found in the study. Of these, five\ncontained multiple race conditions caused by iterative\nloops. The two examples included in this section contained\nthe most complex race conditions from the study. As a\nresult of the positive feedback from the case studies,\nMotorola is planning to incorporate the research presented\nhere into a prototype tool suitable for larger scale evalua-\ntions with engineering groups and to conduct further\nresearch into extending the results to more general UML\nsequence diagrams.\nFig. 20 is an anonymized example from the Motorola\ncase study, which contains multiple race conditions. The\noriginal diagram is a UML 2.0 sequence diagram that\ndescribes traffic channel allocation and activation between\nvarious processes for the HSPDA protocol. Process A has\ndelegated the task of determining what resource to allocate\nto process B. The inline reference in the MSC is a linear\nordering of some events not shown here. These events can\nbe ignored for the purposes of the example because they are\nlinearly ordered.\nIn total, we have the following six race conditions in\nFig. 20. Event ?a1 is in a race with !b and also with !c.\nEvent ?c2 is in a race with !a and also with !b. Also, event ?b2\nis in a race with !a and also with !c. It may be that the\nauthors implicitly assumed the downlink latency from B is\nmuch shorter than the uplink latency for the other\nprocesses. If this were true, it may be possible in practice\nfor the specification to be realizable. However, it is far safer\nto rewrite the specification without these race conditions.\nOne way to remove these races would be to regroup the\nmessages within a single parallel construct. Messages a and\na1 could be grouped within the same thread of a parallel\nconstruct. Similarly b, b1, b2, and the inline reference could\nbe grouped in a second thread. Finally c, c1, and c2 could be\ngrouped in the third thread. Fig. 21 depicts this solution. It\nseems reasonable to suppose this will not contradict what\nthe authors originally intended.\nFig. 21 is exactly the inherent causal scenario of Fig. 20. In\nthis case, the inherent causal order for Fig. 20 would seem to\nrepresent the specification intended by the authors, rather\nthan the causal order of Fig. 20 itself.\nFig. 22 describes a second anonymized example from a\ncase study where several race conditions were contained in\na single scenario. This example can be viewed as multiple\ninteracting threads that represent different features within\none scenario.\nAltogether, there are seven races in the scenario. Receive\nevent ?f is in a race with each of ?a, !b, !c, and !d. The\nremaining three races occur between each of ?b, ?i, and ?j.\nThis example illustrates the value of resolving all the race\nconditions in a single global solution. For example,message f\nis independent of d (in that it can be sent at any time after ?e,\nand e is one of the initial messages in the scenario). Resolving\nthis race by itself would not resolve the races between ?f and\n?a, !b, and !c. Rather, it would complicate the process of\nidentifying a solution to the other races. The inherent causal\norder for this scenario separates a, b, c, and d into one\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 781\nFig. 20. UML 2.0 case study example with multiple race conditions.\nconcurrent thread and messages e and f into a different\nthread. Adding this concurrent region resolves all four races\nsimultaneously. One graphical depiction for the inherent\ncausal scenario of Fig. 22 is given in Fig. 23. We have again\nused lost and found events as a graphical convenience to\nsimplify the diagram.\nFinally, we provide an embedding of the refinement\norder for Fig. 22 into a partial order scenario. This\ncharacterizes the minimal strengthening of Fig. 22 that can\nbe achieved by adding new messages in order to impose the\nrefinement ordering. In this depiction, we have resolved the\nrace conditions by introducing three new messages. These\nare x from process B to C, y from processD to B, and z from\nD to G. The embedding is given in Fig. 24. Message x has\nresolved the races between ?f and ?a, !b, !c, and !d.\nMessage x ensures that process C is informed when B has\nsent messages !b, !c, and !d and that it is now safe to send f .\nWe include a coregion around ?x and ?e in order to avoid\nintroducing new race conditions into the scenario.\nMessages y and z resolve the races between ?b, ?i, and ?j.\nMessage y ensures that b has been received before message i\nis sent and z ensures that i is received before j is sent. Note\nthat we have to place y in a concurrent thread separate from\nc, d, e, f , and x or else we would be introducing several new\nrace conditions into the scenario. Similarly, we include a\ncoregion around ?z and ?h for the same reason.\nThe inherent causal ordering and the refinement order-\ning provide the practitioner with useful insight into the\nsemantically consistent behavior that can be extrapolated\nfrom the scenario. However, the practitioner may decide to\ncombine the two orderings in some bespoke way to\nconstruct a solution that fits their own circumstances.\nIn this example, it is possible that a combination of Fig. 23\nand Fig. 24 give the appropriate solution to the race\nconditions in the original scenario. In the original scenario,\nit could be that e and f are meant to be in a separate thread\nto a, b, c, and d. However, the races between b, i, and j could\nbe the omission of coordinating messages which should\nhave been included. Deciding which parts of the inherent\ncausal and refinement orderings the author intended to\n782 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\nFig. 21. Inherent Causal Scenario for Fig. 20 as MSC.\nFig. 22. Second industrial case study example.\ncombine is not something that can be automated. Providing\nthe practitioner with both solutions allows them to under-\nstand with greater clarity what semantically consistent\nbehavior is captured by the specification.\n11 CONCLUSION\nThe paper has proven that there is a canonical solution for\ncorrecting all race conditions within a partial order scenario\nby weakening the causal relationship. The inherent causal\nordering that defines the solution can also be presented in\nMSC or UML format by use of coregion, parallel, and\ngeneral ordering constructs.\nThe paper has also proven the dual result, that there is a\ncanonical refinement of the specifications that corrects all\nrace conditions. This is the inherent refinement ordering.\nUnlike the inherent causal order, the inherent refinement\nordering cannot be represented by a partial order scenario.\nHowever, we can embed it within a partial order scenario,\nalthough the embedding is not unique. Together, these\ninherent orderings provide a useful insight into the\nsemantically consistent specifications that are possible for\na distributed system. The construction of the inherent\nrefinement ordering is based on the premise that additional\nmessages are required to coordinate concurrent threads.\nWhereas the inherent causal ordering construction is based\non the premise that concurrent threads have been synchro-\nnized at a given point when this should not occur.\nBoth the inherent causal and inherent refinement order-\nings can be automatically generated within a scenario\nauthoring tool, particularly one that supports UML 2.0\nMITCHELL: RESOLVING RACE CONDITIONS IN ASYNCHRONOUS PARTIAL ORDER SCENARIOS 783\nFig. 23. Inherent Causal Scenario for Fig. 22 as MSC.\nFig. 24. Embedding of refinement order for Fig. 22 as MSC.\nsequence diagrams. The graphical depiction of a partial order\nscenario is not unique and, so, there is great choice in\ndeciding how to automate the construction of the inherent\ncausal scenario. The paper has used illustrations, which can\nbe automatically generated, that emphasize the concurrency\nwithin the inherent scenarios by maximizing the use of\ncoregions and parallel constructs. It is also possible to\nautomate the construction for the embedding of the refine-\nment order into some partial order scenario. It is not yet clear\nif there is a canonical way to achieve this. Note that this is a\ndifferent problem than representing the refinement order as a\nUML\/MSC sequence diagram. In that case, the representa-\ntion is straightforward to automate since we are free to use\ngeneral order constructs across processes as necessary.\nInherent and refinement orderings are likely to be of\nmost use in complex scenarios that contain several race\nconditions that have a common cause, such as the examples\nin Section 10. Practitioners are not intended to view the\ninherent and refinement orderings as prescriptive. The\nintention is that, by providing these solutions to the\npractitioner, they will be able to appreciate what semanti-\ncally consistent behavior can be extrapolated from their\nspecifications. In the case study, the most useful aspect of\nthe inherent and refinement orderings from the practi-\ntioners perspective was that they clearly illustrated what\nwas possible in an asynchronous distributed environment\nand helped to identify where constraints would be needed\nto realize their intended design. Generating error traces that\nidentify individual race conditions would not have pro-\nvided this overview because of the complex interrelation-\nships between the race conditions.\nREFERENCES\n[1] R. Alur and M. Yannakakis, \u201cModel checking of Message\nSequence Charts,\u201d Proc. 10th Int\u2019l Conf. Concurrency Theory, 1999.\n[2] R. Alur, K. Etessami, and M. Yannakakis, \u201cInference of Message\nSequence Charts,\u201d Proc. 22nd Int\u2019l Conf. Software Eng., pp. 304-313,\n2000.\n[3] R. Alur, K. Etessami, and M. Yannakakis, \u201cRealizability and\nVerification of MSC Graphs,\u201d Proc. 28th Int\u2019l Colloquium Automata,\nLanguages, and Programming, pp. 797-808, 2001.\n[4] H. Ben-Abdhallah and S. Leue, \u201cSyntactic Detection of Process\nDivergence and Non-Local Choice in Message Sequence Charts,\u201d\nProc. Third Int\u2019l Conf. Tools and Algorithms for the Construction and\nAnalysis of Systems, pp. 259-274, 1997.\n[5] P. Baker, P. Bristow, C. Jervis, D. King, and B. Mitchell,\n\u201cAutomatic Generation of Conformance Tests from Message\nSequence Charts,\u201d Proc. Third SAM Workshop 2002, The Broader\nApplicability of MSC and SDL, pp. 170-198, 2002.\n[6] M. Beyer, W. Dulz, and F. Zhen, \u201cAutomated TTCN-3 Test Case\nGeneration by Means of UML Sequence Diagrams and Markov\nChains,\u201d Proc. 12th Asian Test Symp., 2003.\n[7] Y. Bontemps and P.-Y. Schobbens, \u201cSynthesis of Open Reactive\nSystems from Scenario-Based Specifications,\u201d Proc. Int\u2019l Conf.\nApplication of Concurrency to System Design, 2003.\n[8] Y. Bontemps and P. Heymens, \u201cTurning High-Level Live\nSequence Charts into Automata,\u201d Proc. Scenarios and State\nMachines: Models Algorithms and Tools, 24th Int\u2019l Conf. Software\nEng., May 2002.\n[9] S. Chung, H.S. Kim, H.S. Bae, Y.R. Kwon, and B.S. Lee, \u201cTesting of\nConcurrent Programs Based on Message Sequence Charts,\u201d Proc.\nInt\u2019l Symp. Software Eng. Parallel and Distributed Systems, pp. 72-82,\n1999.\n[10] T. Gehrke, M. Hilhn, and H. Wehrkeim, \u201cAn Algebraic Semantics\nfor Message Sequence Chart Documents,\u201d Proc. FORTE\/PSTV\u201898,\npp. 3-18, 1998.\n[11] T. Gilb, Principles of Software Engineering Management. Addison\nWesley Longman, 1988.\n[12] G.J. Holzmann and D.A. Peled, \u201cMessage Sequence Chart\nAnalyzer,\u201d United States Patent, 5,812,145, 1993.\n[13] G.J. Holzmann, D.A. Peled, and M.H. Redberg, \u201cAn Analyzer for\nMessage Sequence Charts,\u201d Software Concepts and Tools, vol. 17,\nno. 2, 1996.\n[14] E. Gunter, A. Muscholl, and D. Peled, \u201cCompositional Message\nSequence Charts,\u201d Proc. Int\u2019l Conf. Tools and Algorithms for the\nConstruction and Analysis of Systems, 2001.\n[15] D. Harel, \u201cWerner Damm LSCs: Breathing Life into Message\nSequence Charts,\u201d Formal Methods in System Design, vol. 19, pp. 45-\n80, 2001.\n[16] D. Harel and H. Kugler, \u201cSynthesizing State-Based Object Systems\nfrom LSC Specifications,\u201d Proc. Fifth Int\u2019l Conf. Implementation and\nApplication of Automata, 2000.\n[17] C.A. R. Hoare, Communicating Sequential Processes. Prentice Hall,\n1985.\n[18] S. Leue, L. Mehrmann, and M. Rezai, \u201cSynthesizing Software\nArchitecture Descriptions from Message Sequence Chart Specifi-\ncations,\u201d Proc. 13th IEEE Int\u2019l Conf. Automated Software Eng., 1998.\n[19] R. Lutz, \u201cTargeting Safety-Related Errors During Software\nRequirements Analysis,\u201d Proc. First ACM SIGSOFT Symp. Founda-\ntions of Software Eng., 1993.\n[20] R. Lutz, \u201cAnalyzing Software Requirements Errors in Safety-\nCritical, Embedded Systems,\u201d Proc. IEEE Int\u2019l Symp. Requirements\nEng., pp. 126-133, 1993.\n[21] M. Lohrey, \u201cSafe Realizability of High-Level Message Charts,\u201d\nProc. 13th Int\u2019l Conf. Concurrency Theory, 2002.\n[22] R. Milner, Communication and Concurrency. Prentice Hall, 1989.\n[23] B. Mitchell, R. Thomson, and C. Jervis, \u201cPhase Automaton for\nRequirements Scenarios,\u201d Feature Interactions in Telecomm. and\nSoftware Systems VII, pp. 77-84, 2003.\n[24] M. Nelson, J. Clark, and M.A. Spurlock, Curing the Software\nRequirements And Cost Estimating Blues, PM: Nov.-Dec. 1999.\n[25] D. Peled, \u201cSpecification and Verification Using Message Sequence\nCharts,\u201d Proc. IFIP Int\u2019l Conf. Formal Description Techniques for\nDistributed Systems and Communication Protocols, 2000, and\nElectronic Notes in Theoretical Computer Science, vol. 65, no. 7, 2002.\n[26] E. Rudolph, I. Schieferdecker, and J. Grabowski, \u201cDevelopment of\na MSC\/UML Test Format,\u201d Formale Beschreibungstechniken fur\nverteilte Systeme, pp. 153-164, Verlag Shaker, 2000.\n[27] Telelogic, Tau Documentation, http:\/\/www.telelogic.com, 2005.\n[28] S. Uchitel, J. Kramer, and J. Magee, \u201cIncremental Elaboration of\nScenario-Based Specifications and Behavior Models Using Implied\nScenarios,\u201d ACM Trans. Software Eng. and Methodology, vol. 13,\nno. 1, pp. 37-85, 2004.\n[29] J. Whittle, J. Saboo, and R. Kwan, \u201cFrom Scenarios to Code: An Air\nTraffic Control Case Study,\u201d Proc. 25th Int\u2019l Conf. Software Eng.,\n2003.\n[30] J. Whittle and J. Schumann, \u201cGenerating Statechart Designs from\nScenarios,\u201d Proc. 22nd Int\u2019l Conf. Software Eng., 2000.\n[31] Z.120 (11\/99)ITU-T Recommendation\u2014Message Sequence Chart\n(MSC), 1999.\n[32] Object Management Group (OMG), Unified Modeling Language\n(UML): Superstructure, Version 2.0, http:\/\/www.omg.org, 2003.\n[33] E. Wong, J.R. Horgan, W. Zage, D. Zage, and M. Syring,\n\u201cApplying Design Metrics to a Large-Scale Software System,\n(Motorola),\u201d Proc. Ninth Int\u2019l Symp. Software Eng. Reliability, Nov.\n1998.\nBill Mitchell received the PhD degree from\nManchester University in 1987. He lectured\nthere in computer science until 1999. After four\nyears at Motorola Research Labs, he is now a\nlecturer at the University of Surrey in the\nComputing Department.\n. For more information on this or any other computing topic,\nplease visit our Digital Library at www.computer.org\/publications\/dlib.\n784 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 31, NO. 9, SEPTEMBER 2005\n"}