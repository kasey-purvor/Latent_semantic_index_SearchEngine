{"doi":"10.1007\/s10817-005-9007-9","coreId":"66337","oai":"oai:dro.dur.ac.uk.OAI2:1911","identifiers":["oai:dro.dur.ac.uk.OAI2:1911","10.1007\/s10817-005-9007-9"],"title":"Backdoor sets for DLL subsolvers.","authors":["Szeider, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2005-10","abstract":"We study the parameterized complexity of detecting small backdoor sets for instances of the propositional satisfiability problem (SAT). The notion of backdoor sets has been recently introduced by Williams, Gomes, and Selman for explaining the \u2018heavy-tailed\u2019 behavior of backtracking algorithms. If a small backdoor set is found, then the instance can be solved efficiently by the propagation and simplification mechanisms of a SAT solver. Empirical studies indicate that structured SAT instances coming from practical applications have small backdoor sets. We study the worst-case complexity of detecting backdoor sets with respect to the simplification and propagation mechanisms of the classic Davis\u2013Logemann\u2013Loveland (DLL) procedure. We show that the detection of backdoor sets of size bounded by a fixed integer k is of high parameterized complexity. In particular, we determine that this detection problem (and some of its variants) is complete for the parameterized complexity class W[P]. We achieve this result by means of a generalization of a reduction due to Abrahamson, Downey, and Fellows","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66337.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/1911\/1\/1911.pdf","pdfHashValue":"7896ff1b73ee22b0c0700de7e0c0284d875ad5d2","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:1911<\/identifier><datestamp>\n      2011-08-10T15:33:50Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Backdoor sets for DLL subsolvers.<\/dc:title><dc:creator>\n        Szeider, S.<\/dc:creator><dc:description>\n        We study the parameterized complexity of detecting small backdoor sets for instances of the propositional satisfiability problem (SAT). The notion of backdoor sets has been recently introduced by Williams, Gomes, and Selman for explaining the \u2018heavy-tailed\u2019 behavior of backtracking algorithms. If a small backdoor set is found, then the instance can be solved efficiently by the propagation and simplification mechanisms of a SAT solver. Empirical studies indicate that structured SAT instances coming from practical applications have small backdoor sets. We study the worst-case complexity of detecting backdoor sets with respect to the simplification and propagation mechanisms of the classic Davis\u2013Logemann\u2013Loveland (DLL) procedure. We show that the detection of backdoor sets of size bounded by a fixed integer k is of high parameterized complexity. In particular, we determine that this detection problem (and some of its variants) is complete for the parameterized complexity class W[P]. We achieve this result by means of a generalization of a reduction due to Abrahamson, Downey, and Fellows. <\/dc:description><dc:subject>\n        satisfiability - unit propagation - pure literal elimination - backdoor sets - parameterized complexity - W[P]-completeness.<\/dc:subject><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Journal of automated reasoning, 2005, Vol.35(1-3), pp.73-88 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2005-10<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:1911<\/dc:identifier><dc:identifier>\n        issn:0168-7433<\/dc:identifier><dc:identifier>\n        issn: 1573-0670<\/dc:identifier><dc:identifier>\n        doi:10.1007\/s10817-005-9007-9<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/1911\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/doi:10.1007\/s10817-005-9007-9<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/1911\/1\/1911.pdf<\/dc:identifier><dc:rights>\n        The original publication is available at www.springerlink.com\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn: 1573-0670","0168-7433"," 1573-0670","issn:0168-7433"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2005,"topics":["satisfiability - unit propagation - pure literal elimination - backdoor sets - parameterized complexity - W[P]-completeness."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n14 October 2008\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nSzeider, S. (2005) \u2019Backdoor sets for DLL subsolvers.\u2019, Journal of automated reasoning., 35 (1-3). pp. 73-88.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/doi:10.1007\/s10817-005-9007-9\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n Use policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without \nprior permission or charge, for personal research or study, educational, or not-for-profit purposes \nprovided that : \n \n\u0083 a full bibliographic reference is made to the original source \n\u0083 a link is made to the metadata record in DRO \n\u0083 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright \nholders.  \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nDurham Research Online \n Deposited in DRO:\n14 October 2008\nVersion of attached file:\nAccepted\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nSzeider, S. (2005) 'Backdoor sets for DLL subsolvers.', Journal of automated reasoning., 35 (1-3), pp.\u000073-88.\nFurther information on publishers website:\nhttp:\/\/dx.doi.org\/doi:10.1007\/s10817-005-9007-9\nPublishers copyright statement:\nThe original publication is available at www.springerlink.com\u0000\u0000\nBackdoor Sets for DLL Subsolvers\nStefan Szeider\nDepartment of Computer Science\nDurham University\nDH1 3LE Durham, England, UK\nAbstract\nWe study the parameterized complexity of detecting small backdoor sets\nfor instances of the propositional satisfiability problem (SAT). The notion\nof backdoor sets has been recently introduced by Williams, Gomes, and\nSelman for explaining the \u2018heavy-tailed\u2019 behavior of backtracking algo-\nrithms. If a small backdoor set is found, then the instance can be solved\nefficiently by the propagation and simplification mechanisms of a SAT\nsolver. Empirical studies indicate that structured SAT instances com-\ning from practical applications have small backdoor sets. We study the\nworst-case complexity of detecting backdoor sets with respect to the sim-\nplification and propagation mechanisms of the classic Davis-Logemann-\nLoveland (DLL) procedure. We show that the detection of backdoor sets\nof size bounded by a fixed integer k is of high parameterized complex-\nity. In particular, we determine that this detection problem (and some\nof its variants) is complete for the parameterized complexity class W[P].\nWe achieve this result by means of a generalization of a reduction due to\nAbrahamson, Downey, and Fellows.\nKeywords: Satisfiability, unit propagation, pure literal elimination, back-\ndoor sets, parameterized complexity, W[P]-completeness.\n1 Introduction\nThe propositional satisfiability problem (SAT) is the first problem shown to be\nNP-complete. It holds a central role in the theory of computational complex-\nity and is of practical relevance for applied areas like verification or planning.\nSAT instances with n variables can be solved by brute force, checking all 2n\ntruth assignments; no algorithm is known that runs in time 2o(n) in the worst\ncase. However, SAT instances arising from applications often impose a \u201chid-\nden structure\u201d which allow significantly faster SAT decision than by brute force\nsearch.\nOne example of such hidden structure is based on the concept of backdoor\nsets of variables, recently introduced by Williams, Gomes, and Selman [11, 12].\nA weak backdoor set of a SAT instance is a set B of variables such that for at least\none truth assignment to the variables in B, simplifying the instance according to\nthat assignment yields a satisfiable instance that can be decided in polynomial\ntime by a \u201csubsolver.\u201d A subsolver is an incomplete polynomial-time algorithm\nthat uses the propagation and simplification mechanisms of a SAT-solver. A\n1\nstrong backdoor set of a SAT instance is a set B of variables such that for every\ntruth assignment to the variables in B, the resulting simplified SAT instance\ncan be decided by the subsolver (exact definitions are given in Sections 2 and\n3 below). As reported by Williams, Gomes, and Selman [12], highly structured\nproblem instances have small weak backdoor sets; for example, for a logistics\nplanning benchmark instance with about 7000 variables, a weak backdoor set\nof size 12 could be found. However, the minimum size of backdoor sets of\nnon-structured instances, like random 3-SAT, appears to be a constant fraction\n(about 30%) of the total number of variables (Interian [7]). The dependency\namong the variables of minimal weak backdoor set is studied by Ruan, Kautz,\nand Horvitz [10]. It is observed that SAT-solvers may heuristically be quite\ncapable of exploiting the existence of small weak backdoor sets in practice,\nwithout necessarily identifying the backdoor sets explicitly [12, 10].\nIn the sequel we address the worst-case time complexity of deciding whether\na given SAT instance has a weak or strong backdoor set of size bounded by\nsome integer k. We study this problem with respect to subsolvers of the stan-\ndard Davis-Logemann-Loveland (DLL) algorithm. That is, subsolvers that are\nbased on unit propagation and pure literal elimination, or on one of these two\nprinciples.\nWe can detect a weak\/strong backdoor set of size at most k by considering\nall sets B of k or fewer variables of the given instance, and by checking whether\none\/all of the 2|B| assignments to the variables in B yields an instance that can\nbe decided by the subsolver under consideration. Thus a backdoor set can be\ndetected in time O(2knk+\u03b1) where O(n\u03b1) is the worst-case time complexity of\nthe subsolver. However, such a trivial approach becomes impractical for large\nn even if the parameter k, the maximum size of a backdoor set, is chosen small.\nIn this paper we tackle the question of whether, in general, a small backdoor\nset can be found significantly faster than by brute force search.\nThe framework of Parameterized Complexity (Downey and Fellows [5]) pro-\nvides an excellent framework for studying this question. A parameterized prob-\nlem is a set L \u2286 \u03a3\u2217 \u00d7 \u03a3\u2217 for some fixed alphabet \u03a3. For a problem instance\n(x, k) \u2208 L, we refer to x as the main part, and to k as the parameter. Typi-\ncally (and for all problems considered in the sequel), the parameter is a positive\ninteger (presented in unary). XP denotes the class of parameterized problems\nwhich can be solved in polynomial time whenever the parameter is considered as\na constant; the above considerations show that the detection of a backdoor set is\nin XP. If a parameterized problem L can be solved in time O(f(k)nc) where f is\nany computable function of the parameter and c is a constant (independent from\nk), then L is called fixed-parameter tractable; FPT denotes the class of all fixed-\nparameter tractable problems. Parameterized complexity classes are defined as\nequivalence classes of parameterized problems under a certain parameterized\nreduction. This parameterized reduction is an extension of the polynomial-time\nmany-one reduction where a parameter for one problem maps into a parameter\nfor another. More specifically, a parameterized problem L reduces to a param-\neterized problem L\u2032 if we can transform an instance (x, k) of L into an instance\n(x\u2032, g(k)) of L\u2032 in time f(k) \u00b7 |x|O(1) (f, g are arbitrary computable functions),\nsuch that (x, k) is a yes-instance of L if and only if (x\u2032, g(k)) is a yes-instance\nof L\u2032. The class XP contains a hierarchy of parameterized complexity classes\nFPT \u2286 W[1] \u2286 W[2] \u2286 . . . \u2286 W[P] \u2286 XP.\n2\nAll inclusions are assumed to be proper; FPT 6= XP is known [5]. The higher\na problem is located in this hierarchy, the more unlikely it is fixed-parameter\ntractable. The canonical W[P]-complete problem is the following (cf. [5]).\nweighted circuit satisfiability\nInput: A decision circuit D.\nParameter: A positive integer k.\nQuestion: Does D accept an input assignment of weight k?\nIf a W[P]-complete problem turns out to be fixed-parameter tractable, then\nthe n-variable SAT problem can be solved in time 2o(n) (Abrahamson, Downey\nand Fellows [1]); a recent treatment of the relationship between parameterized\ncomplexity classes and SAT upper bounds can be found in Flum and Grohe [6].\nThe parameterized problem weighted monotone circuit satisfiability\narises from weighted circuit satisfiability by restricting the instances to\nmonotone circuits. Surprisingly, weighted monotone circuit satisfiabil-\nity remains W[P]-hard [1, 5]. Furthermore, the problems remain W[P]-complete\nif we ask for an accepted input assignment of weight at most k (see Section 1).\nIn this paper we completely classify the parameterized complexity of the\nproblem of whether a SAT instance has a weak or strong backdoor set of size\nnot exceeding a parameter k w.r.t. subsolvers that arise from the DLL proce-\ndure. In particular, we determine that detection of weak and strong backdoor\nsets is W[P]-complete for the considered subsolvers. Thus we provide strong\ntheoretical evidence that these problems are not fixed-parameter tractable. We\ngeneralize the proof technique used by Abrahamson, Downey, and Fellows [1] for\nk-induced satisfiability and other problems by introducing a certain param-\neterized problem on cyclic monotone circuits (see, e.g., Malik [8]). We show that\nthis new problem, cyclic monotone circuit activation, is W[P]-complete.\nParameterized reductions of this problem provide the base for our W[P]-hard-\nness results. We think that cyclic monotone circuit activation is in-\nteresting on its own as its W[P]-hardness proof is conceptually simple, and it\nprovides a means for several other W[P]-hardness proofs.\nNotation and Preliminaries\nWe assume an infinite supply of propositional variables. A literal is a variable\nx with an assigned parity \u03b5 \u2208 {0, 1} and is denoted by x\u03b5. We also write x = x1\nand x = x0. A set S of literals is tautological if it contains both x and x for some\nvariable x. A clause is a finite non-tautological set of literals. We consider a\nfinite set of clauses as a CNF formula (or formula, for short). Clauses of size one\nare called unit clauses. The set of variables occurring (negated or unnegated)\nin a formula F is denoted by var(F ). A literal x\u03b5 is a pure literal of a formula\nF if x \u2208 var(F ) and no clause of F contains x1\u2212\u03b5.\nA truth assignment (or assignment, for short) is a map \u03c4 : X\u03c4 \u2192 {0, 1}\ndefined on some set X\u03c4 of variables. If X\u03c4 is a singleton {x} with \u03c4(x) = \u03b5,\nthen we denote \u03c4 simply by x = \u03b5. An assignment \u03c4 is total for a formula F\nif X\u03c4 = var(F ). For x \u2208 X\u03c4 we define \u03c4(x) = 1 \u2212 \u03c4(x). For an assignment \u03c4\nand a formula F , F [\u03c4 ] denotes the formula obtained from F by removing all\nclauses which contain a literal x with \u03c4(x) = 1 and removing literals y with\n\u03c4(y) = 0 from the remaining clauses. An assignment \u03c4 satisfies a formula\n3\nF if F [\u03c4 ] = \u2205. A formula is satisfiable if it is satisfied by some assignment;\notherwise it is unsatisfiable. Let F be a formula and (x, \u03b5) \u2208 var(F )\u00d7{0, 1}. If\nF contains the unit clause {x\u03b5} (or x\u03b5 is a pure literal of F ), then we say that\nthe assignment x = \u03b5 can be inferred (in one step) by unit propagation (or pure\nliteral elimination, respectively). If both x = 0 and x = 1 can be inferred, then\nF is unsatisfiable (F contains both {x} and {x}).\nA decision circuit (or circuit, for short) D is a triple (G, E, \u03bb) where (G, E)\nis an acyclic digraph (the underlying digraph of D) and \u03bb is a mapping from G\nto {and,or,not}. The elements of G are the gates and the elements of E are\nthe lines of D. A gate g \u2208 G is called \u03bb(g)-gate. D is monotone if it contains\nno not-gates. The fanin (fanout) of a gate g \u2208 G is its in-degree (out-degree)\nin the underlying digraph. We assume that not-gates have fanin 1 and that\nand\/or-gates have fanin at least one. Gates with fanin 2 are binary gates. If\nE contains the line (g, h) then we say that g is a predecessor of h and that h\nis a successor of g. Gates with fanin 0 are the input gates of the circuit and\ngates with fanout 0 are the output gates of the circuit. We assume that every\ncircuit has exactly one output gate. If the underlying digraph of a circuit D is\na tree, then D can be identified with a boolean formula. An input assignment\n\u03bd for a circuit D is a mapping from the set of input gates to {0, 1}. An input\nassignment \u03bd propagates through the circuit in the natural way, e.g., for an\nand-gate g with predecessors g1, . . . , gn, we have \u03bd(g) = min\nn\ni=1 \u03bd(gi). A circuit\nD accepts an input assignment \u03bd if \u03bd(u) = 1 holds for the output gate u of\nD. The weight of an input assignment is the number of input gates that are\nassigned to 1.\nNote that a monotone circuit with n input gates accepts an input assignment\nof weight at most k for some k \u2264 n if and only if it accepts an input assignment\nof weight exactly k. If D is non-monotone, then we can still obtain in polynomial\ntime a circuit D\u2032 with nk input gates such that D accepts an input assignment\nof weight at most k if and only if D\u2032 accepts an input assignment of weight\nexactly k (D\u2032 can be obtained from D by adding an or-gate of fanin k in front\nof each input gate). Furthermore, by means of a standard construction, we can\ntransform a circuit D into a circuit D2 (D2 has the same input gates as D) by\nreplacing gates of fanin greater than 2 by several binary gates. The construction\nof D2 from D can be carried out in polynomial time, and both circuits accept\nthe same input assignments.\n2 Subsolvers\nThe Davis-Putnam (DP) procedure [4] and the related Davis-Logemann-\nLoveland (DLL) procedure [3] are certainly the best known complete algorithms\nfor solving the satisfiability problem. Complete state-of-the-art SAT-solvers are\ntypically based on variants of the DLL procedure. A concise description of these\nprocedures can be found in Cook and Mitchell [2]. Both procedures, DP and\nDLL, search for a satisfying assignment, applying first unit propagation and pure\nliteral elimination as often as possible. Then, DLL makes a case distinction on\nthe truth value of a variable, and DP eliminates a variable x by replacing the\nclauses in which x occurs by all the clauses that can be obtained by resolving\non x. The DLL procedure is sketched in Fig. 1.\nIf we use only unit propagation and pure literal elimination, then we get an\n4\nProcedure DLL(F )\nInput: A CNF formula F .\nOutput: Either a truth assignment which satisfies F or \u201cunsatisfiable\u201d.\n1. Trivial Decision: If F = \u2205, then return the empty satisfying\nassignment; if F contains the empty clause, then return \u201cunsat-\nisfiable.\u201d\n2. Unit Propagation: If F contains a unit clause {x\u03b5}, then call\nDLL(F [x = \u03b5]). If a satisfying assignment \u03c4 for F [x = \u03b5] is re-\nturned, then return \u03c4\u222a{x = \u03b5}; otherwise return \u201cunsatisfiable.\u201d\n3. Pure Literal Elimination: If F contains a pure literal x\u03b5, then\ncall DLL(F [x = \u03b5]). If a satisfying assignment \u03c4 for F [x = \u03b5] is\nreturned, then return \u03c4 \u222a {x = \u03b5}; otherwise return \u201cunsatisfi-\nable.\u201d\n4. Branching: Choose a variable x \u2208 var(F ).\n(a) Call DLL(F [x = 0]). If a satisfying assignment \u03c4 for F [x =\n0] is returned, then return \u03c4 \u222a {x = 0}.\n(b) Otherwise, call DLL(F [x = 1]). If a satisfying assignment\n\u03c4 for F [x = 1] is returned, then return \u03c4 \u222a {x = 1}.\n(c) Otherwise return \u201cunsatisfiable.\u201d\nFigure 1: The Davis-Logemann-Loveland (DLL) procedure\nincomplete algorithm which decides satisfiability for a subclass of CNF formulas.\n(Whenever the algorithm reaches the branching step, it halts and outputs \u201cgive\nup\u201d.) This incomplete algorithm is an example of a \u201csubsolver\u201d as considered\nby Williams, et al. [11]; a polynomial-time algorithm S is called a subsolver if\nit either correctly decides satisfiability of the given formula F or it gives up.\nMoreover, it is required that if the subsolver S decides that F is satisfiable,\nit also returns a satisfying assignment, and that S satisfies the following basic\nconditions: first, that it decides the empty formula as being satisfiable and a\nformula containing the empty clause as being unsatisfiable, and second, that if\nit decides the satisfiability of a formula F , then it does so for F [x = \u03b5] for any\n(x, \u03b5) \u2208 var(F )\u00d7 {0, 1}.\nThe DLL procedure gives rise to three non-trivial subsolvers: up+pl (unit\npropagation and pure literal elimination are available), up (only unit propaga-\ntion is available), pl (only pure literal elimination is available).\n3 Backdoor Sets\nThe power of a subsolver can be enhanced by taking an assignment \u03c4 to a few\nvariables of the given formula F and inputting F [\u03c4 ] to the subsolver. This idea\nleads to the concept of backdoor sets (cf. [11, 12]).\nA set B of variables is a weak backdoor set of a formula F w.r.t. a subsolver\nS if B \u2286 var(F ) and there exists an assignment \u03c4 : B \u2192 {0, 1} such that S\nreturns a satisfying assignment for the input F [\u03c4 ]; we also say that B is a weak\nS-backdoor set. The set B is a strong backdoor set of F w.r.t. S if B \u2286 var(F )\nand for every assignment \u03c4 : B \u2192 {0, 1}, the subsolver S decides whether F [\u03c4 ]\n5\nis satisfiable or not; we also say that B is a strong S-backdoor set.\nSimilarly one can define backdoor sets with respect to a class C of formulas\nwhere membership in C and satisfiability of formulas in C can be decided in\npolynomial time.\nNote that by definition, unsatisfiable formulas do not have weak backdoor\nsets, and that B = var(F ) is always a weak backdoor set of any satisfiable\nformula F . Moreover, if F is satisfiable, then every strong backdoor set of F is\nalso a weak backdoor set of F w.r.t. any subsolver S, but the converse does not\nhold in general.\nFor a subsolver S we consider the following two parameterized problems.\nweak S-backdoor\nInput: A formula F .\nParameter: A positive integer k.\nQuestion: Does F have a weak S-backdoor set B of size at most k?\nstrong S-backdoor\nInput: A formula F .\nParameter: A positive integer k.\nQuestion: Does F have a strong S-backdoor set B of size at most k?\nIn the next section we formulate an intermediate problem on cyclic monotone\ncircuits which will allow us to determine the complexity of backdoor set detection\nfor the nontrivial subsolvers up+pl, up, and pl.\n4 Cyclic Monotone Circuits\nA cyclic monotone circuit is a monotone circuit whose underlying digraph may\ncontain directed cycles. Cyclic circuits have been considered by several authors,\nsee, e.g., Malik [8] for references. We assume that a cyclic monotone circuit may\nhave no input or output gates.\nConsider a set A of gates of a cyclic monotone circuit D (we think of the\ngates in A to be activated). The successor set s(A) of A contains all gates g of\nD for which at least one of the following holds:\n\u2022 g \u2208 A;\n\u2022 g is an and-gate and all predecessors of g are in A;\n\u2022 g is an or-gate and at least one predecessor of g is in A.\nIf we take iteratively successor sets of A (i.e., we compute a sequence of sets\nA0 \u2286 A1 \u2286 A2 \u2286 . . . with A0 = A and Ai+1 = s(Ai)) then we end up with\na set A\u2217 such that s(A\u2217) = A\u2217. We call A\u2217 the closure of the starting set A.\nSince Ai \u2286 s(Ai) holds always by monotonicity, the closure of A for a cyclic\nmonotone circuit D with n gates is obtained after at most n iterations. We say\nthat A activates D if the closure A\u2217 contains all gates of D.\nConsider, for example, the cyclic monotone circuit exhibited in Fig. 2.\nThe set {g1} activates the circuit, since we have s(s({g1})) = s({g1, g2}) =\n{g1, g2, g3}. However, the set {g2} does not activate the circuit, since s({g2}) =\n{g2} = {g2}\u2217 6= {g1, g2, g3}.\nWe are interested in finding a small set of gates that activates a given cyclic\nmonotone circuit. To this end, we define the following parameterized problem.\n6\nand and\nor\ng1\ng2\ng3\nFigure 2: A cyclic monotone circuit.\ncyclic monotone circuit activation\nInstance: A cyclic monotone circuit D.\nParameter: A positive integer k.\nQuestion: Does some starting set A containing at most k gates\nactivate D?\nLemma 1. cyclic monotone circuit activation is W[P]-complete. The\nproblem remains W[P]-complete for instances without input or output gates.\nProof. We show membership in W[P] by reducing the problem to weighted\ncircuit satisfiability. Given a cyclic monotone circuit D with n gates, we\nconstruct an acyclic monotone circuit C as follows. For every \u25e6-gate g of D,\n\u25e6 \u2208 {and,or}, with predecessors g1, . . . , gr and 0 \u2264 t \u2264 n, we add a gate g[t]\nto C as follows. For t = 0, the gate g[0] is an input gate of C, and for t > 0, we\nput\ng[t] = g[t\u2212 1] \u2228 (\u00a9ri=1gi[t\u2212 1]).\nFinally, we add the output gate\nu =\n\u2227\ng\u2208D\ng[n].\nIt is straightforward to verify that C accepts a weight k input assignment if\nand only if some starting set of size k activates D. Hence cyclic monotone\ncircuit activation is in W[P].\nTo show W[P]-hardness, we reduce from weighted monotone circuit\nsatisfiability, using ideas from Abrahamson, Downey, and Fellows [1]. Let C\nbe a monotone circuit with n input gates x1, . . . , xn and the output gate u. We\nconstruct a cyclic monotone circuit D as follows. We take k +1 copies of C, say\nC[1], . . . , C[k + 1], and denote the copy of a gate g in C[j] by g[j]. We add n\nidentical and-gates h1, . . . , hn, each defined by\nhi =\nk+1\u2227\nj=1\nu[j].\nWe \u2018feed-back\u2019 the gates hi to the input gates of the circuits C[1], . . . , C[k + 1],\nadding all the lines (hi, xi[j]) for j = 1, . . . , k+1 and i = 1, . . . , n. This concludes\nthe construction of D. Observe that D has no input or output gates.\nWe show that C accepts an input assignment of weight at most k if and only\nif a starting set of size at most k activates D.\nAssume that C accepts an input assignment \u03bd of weight k. We take A =\n{hi : 1 \u2264 i \u2264 n, \u03bd(xi) = 1 } and put A0 = A and Ai = s(Ai\u22121) for i > 0.\n7\nLet d be the length of a longest path in the underlying digraph of C from\nsome input gate xi to the output gate u (i.e., d is the \u2018depth\u2019 of C). Since\nC accepts \u03bd, it follows that after d + 1 iterations all output gates u[j] are\nactivated, i.e., {u[1], . . . , u[k + 1]} \u2286 Ad+1. Hence {h1, . . . , hn} \u2286 Ad+2. In\nthe next step all input gates of the circuits C[i] are activated. After d more\niterations, going through the circuits C[i] a second time, finally all gates of D\nbelong to A2d+2 = A\u2217. Hence A activates D.\nConversely, assume that a starting set A of size at most k activates D, but C\naccepts no input assignment of weight at most k (we aim to get a contradiction).\nSince |A| \u2264 k, there must be at least one C[j], j \u2208 {1, . . . , k + 1}, such that A\ndoes not contain any gate of C[j]. Since A activates D, u[j] \u2208 A\u2217. Let t be the\nsmallest integer such that u[j] \u2208 At. Since no gate of C[j] is in the starting set\nA, some of the input gates of C[j] are activated at some later step such that the\nactivation of the input gates propagates through C[j] to u[j]. In other words,\nwe have X \u2032 \u2286 {x1[j], . . . , xn[j]} \u2208 As for some s < t such that C[j] accepts\nthe input assignment \u03bd\u2032 of C[j] with \u03bd\u2032(xi[j]) = 1 if and only if xi[j] \u2208 As. By\nassumption, |X \u2032| > k follows. Consequently, |{h1, . . . , hn} \u2229 As| > k. This is\nonly possible if all u[i], 1 \u2264 i \u2264 n, are in As\u22121. In particular, u[j] \u2208 As\u22121 and\nso t \u2264 s\u2212 1, a contradiction to s < t. Hence C accepts some input assignment\nof weight at most k. This completes the proof of the lemma.\nIt is easy to verify that some starting set of size k activates a cyclic monotone\ncircuit D if and only if some starting set of size k activates the corresponding\ncircuit D2 that contains only binary gates (see Section 1). Consequently, cyclic\nmonotone circuit activation remains W[P]-hard for cyclic monotone cir-\ncuits that contain only binary gates.\n5 Backdoor Sets for Non-trivial Subsolvers\nLemma 2. weak S-backdoor is in W[P] for any S \u2208 {up+pl,up, pl}.\nProof. We reduce weak up+pl-backdoor to weighted circuit satisfi-\nability. Let F be an instance of up+pl-backdoor with n variables. We\nconstruct an acyclic circuit C with 2n input gates that accepts a weight k input\nassignment if and only if F has a weak up+pl-backdoor set of size k.\nWe describe C as consisting of n + 1 layers, L0, . . . , Ln. Each layer Lt\nhas input gates x0[t] and x1[t] for every x \u2208 var(F ). We think of the values\nof x0[t] and x1[t] under some assignment \u03bd as representing the value of the\nvariable x under some assignment \u03c4 of F after t propagation steps. That is,\n\u03bd(x0[t]) = \u03bd(x1[t]) = 0 means that \u03c4(x) is not defined at step t; \u03bd(x\u03b5[t]) = 1\nmeans that \u03c4(x) = \u03b5 at step t. The construction of C will guarantee that\n\u03bd(x0[t]) = \u03bd(x1[t]) = 1 cannot be the case for any input assignment \u03bd accepted\nby C. The input gates of the first layer are the input gates of the whole circuit C.\nA layer Lt, t < n, contains gates that are connected to the input gates of the\nnext layer Lt+1. The last layer Ln defines the output gate u of C. Next we\ndescribe the construction of C in detail.\n8\nFor x \u2208 var(F ), \u03b5 \u2208 {0, 1}, and t \u2208 {0, . . . , n\u2212 1}, we put\nx\u03b5[t + 1] = x\u03b5[t] \u2228 (1)\uf8eb\n\uf8ed \u2227\nC\u2208F with x1\u2212\u03b5\u2208C\n\uf8eb\n\uf8ed \u2228\ny\u03b7\u2208C\ny\u03b7[t]\n\uf8f6\n\uf8f8\n\uf8f6\n\uf8f8 \u2228 (2)\n\uf8eb\n\uf8ed \u2228\nC\u2208F with x\u03b5\u2208C\n\uf8eb\n\uf8ed \u2227\ny\u03b7\u2208C\\{x\u03b5}\ny1\u2212\u03b7[t]\n\uf8f6\n\uf8f8\n\uf8f6\n\uf8f8 . (3)\nThe disjunctive term in (1) ensures that once an assignment to a variable is\nmade it is not changed at a later step. The circuits defined in (2) express pure\nliteral elimination: we set x\u03b5 to 1 at step t + 1 if all clauses that contain the\ncomplementary literal x1\u2212\u03b5 are satisfied at step t. The circuits defined in (3)\nexpress unit propagation: we set x\u03b5 to 1 at step t+1 if there is some clause in F\ncontaining x\u03b5 and all other literals in the clause are set to 0 at step t. It remains\nto ensure that two input gates x\u03b5[t] and x1\u2212\u03b5[t], representing complementary\nliterals, are never both set to 1, and that finally, at step n, all clauses of F are\nsatisfied. Hence we define the output gate u as\nu =\n\uf8eb\n\uf8ec\uf8ec\uf8ec\uf8ed\n\u2227\nx \u2208 var(F )\n0 \u2264 t \u2264 n\n\u00ac(x\u03b5[t] \u2227 x1\u2212\u03b5[t])\n\uf8f6\n\uf8f7\uf8f7\uf8f7\uf8f8 \u2227\n\u2227\nC\u2208F\n\u2228\ny\u03b7\u2208C\ny\u03b7[n].\nIt is straightforward to verify that C accepts an input assignment of weight\nk if and only if F has a weak up+pl-backdoor set of size k. Hence weak\nup+pl-backdoor is in W[P]. For the problems weak up-backdoor and\nweak pl-backdoor we proceed similarly, omitting the constructions (2) or\n(3), respectively.\nLemma 3. strong S-backdoor is in W[P] for any S \u2208 {up+pl,up, pl}.\nProof. We reduce strong up+pl-backdoor to weighted circuit satisfi-\nability, extending the construction of the proof of Lemma 2. Let F be an\ninstance of strong up+pl-backdoor with n variables. We construct a cir-\ncuit D with 2kn input gates that accepts a weight 2kk input assignment if and\nonly if F has a strong up+pl-backdoor set of size k.\nFor i = 1, . . . , 2k we construct circuits Di as in the proof of Lemma 2; each\nDi consists of n + 1 layers and has input gates x\n\u03b5\ni [t] for \u03b5 \u2208 {0, 1}, x \u2208 var(F ),\nand t \u2208 {0, . . . , n}. The layers of Di consist of gates as defined in (2) and (3).\nThe output gate ui of Di is defined by\nui =\n\uf8eb\n\uf8ed \u2227\nx\u2208var(F )\n\u00ac(x\u03b5[0] \u2227 x1\u2212\u03b5[0])\n\uf8f6\n\uf8f8 \u2227\n\uf8eb\n\uf8ec\uf8ec\uf8ec\uf8ed\n\u2227\nC\u2208F\n\u2228\ny\u03b7\u2208C\ny\u03b7[n] \u2228\n\u2228\nC\u2208F\n\u2227\ny\u03b7\u2208C\ny1\u2212\u03b7 [0] \u2228\n\u2228\nx \u2208 var(F )\n1 \u2264 t \u2264 n\n(x\u03b5[t] \u2227 x1\u2212\u03b5[t])\n\uf8f6\n\uf8f7\uf8f7\uf8f7\uf8f8 .\n9\nThe difference to the construction in the proof of Lemma 2 is that we also\nallow the detection of unsatisfiability. We use the fact that unsatisfiability of a\nformula can be detected by unit propagation and pure literal elimination if and\nonly if the formula contains the empty clause, or both x = 0 and x = 1 can be\ninferred.\nWe combine the circuits D1, . . . , D2k and define the output gate u of D by\nsetting\nu =\n2k\u2227\ni=1\nui \u2227 (4)\n\uf8eb\n\uf8ed \u2227\n1\u2264i<j\u22642k\n\u2228\nx\u2208var(F )\nx0i [0] 6\u2261 x\n0\nj [0]\n\uf8f6\n\uf8f8 \u2227 (5)\n\uf8eb\n\uf8ec\uf8ec\uf8ec\uf8ed\n\u2227\nx \u2208 var(F )\n1 \u2264 i < j \u2264 2k\n(x0i [0] \u2228 x\n1\ni [0]) \u2261 (x\n0\nj [0] \u2228 x\n1\nj [0])\n\uf8f6\n\uf8f7\uf8f7\uf8f7\uf8f8 (6)\nwhere p 6\u2261 q abbreviates (p \u2227 \u00acq) \u2228 (\u00acp \u2227 q), and p \u2261 q abbreviates (p \u2227 q) \u2228\n(\u00acp\u2227\u00acq). Part (4) ensures that all the circuits Di accept the input assignment.\nPart (5) ensures that the input assignment to different copies Di, Dj , for i 6= j,\ndiffer in at least one position. Part (6) ensures that all circuits Di, 1 \u2264 i \u2264 2k,\nreceive input assignments that correspond to the same set B of variables of F .\nWe claim that F has a strong up+pl-backdoor set B of size k if and only if D\naccepts an input assignment of weight k.\nAssume that B \u2286 var(F ) is a strong up+pl-backdoor set of F with |B| = k.\nLet {\u03c41, . . . , \u03c42k} be the set of all assignments \u03c4i : B \u2192 {0, 1}. We define an\ninput assignment \u03bd of D by setting for all (x, \u03b5) \u2208 var(F )\u00d7 {0, 1}\n\u03bd(x\u03b5i [0]) =\n{\n1 if x \u2208 B and \u03c4i(x) = \u03b5;\n0 otherwise.\nWe observe that for each Di, \u03c4 sets exactly k input gates to 1, hence the weight\nof \u03c4 is 2kk. Since B is a strong up+pl-backdoor set, it follows by construction\nof D that D accepts \u03bd.\nConversely, assume that D accepts an input assignment \u03bd of weight 2kk. For\ni = 1, . . . , 2k let Bi = {x \u2208 var(F ) : \u03bd(x0i [0]) = 1 or \u03bd(x\n1\ni [0]) = 1) } and define\nan assignment \u03c4i : Bi \u2192 {0, 1} such that \u03c4i(x) = 1 if and only if \u03bd(x\n1\ni [0]) = 1.\nPart (6) of the definition of D implies Bi = Bj for all 1 \u2264 i < j \u2264 2k, and part\n(5) implies |{\u03c41, . . . , \u03c42k}| = 2\nk. Thus \u03c41, . . . , \u03c42k are all possible assignments\nfor the set B = B1 = . . . = B2k . Since D accepts \u03bd, it follows that for every\ni \u2208 {1, . . . , 2k}, the up+pl-subsolver decides whether F [\u03c4i] is satisfiable or not.\nIn summary, B is a strong up+pl-backdoor set of size k.\nHence we have shown that strong up+pl-backdoor is in W[P]. This\nholds as well for strong up-backdoor and strong pl-backdoor, as we\ncan modify the above construction by omitting (2) or (3), respectively, in the\ndefinitions of the circuits Di.\n10\nLemma 4. The problems weak up+pl-backdoor and weak up-backdoor\nare W[P]-hard. The problems remain W[P]-hard for CNF formulas that have\nexactly one satisfying total assignment.\nProof. We reduce cyclic monotone circuit activation. Let D = (G, E, \u03bb)\nbe a cyclic monotone circuit without input or output gates. We may assume\nthat all gates of D are binary (cf. the discussion at the end of Section 4).\nFor each gate g \u2208 G we define a set Fg of clauses, and we obtain a formula\nF by taking the union of all sets Fg with g \u2208 G. For an and-gate g = x1 \u2227 x2,\nthe set Fg contains the clauses\n{x1, y1}, {x1, y1}, {x1, y1},\n{x2, y2}, {x2, y2}, {x2, y2},\n{x1, y1, x2, y2, g};\nthe variables y1, y2 are new variables not occurring outside of these 7 clauses\n(we call the variables y1, y2 private). Similarly, for an or-gate g = x1 \u2228 x2, the\nset Fg contains the clauses\n{x1, y1}, {x1, y1}, {x1, y1},\n{x2, y2}, {x2, y2}, {x2, y2},\n{x1, y1, z}, {x2, y2, g};\nagain, y1, y2 are private variables. By construction, G \u2286 var(F ), and since D\nhas no input gates, var(F ) \\G is the set of all private variables of F . Evidently,\neach Fg is satisfied by assigning 1 to all its variables; however, if 0 is assigned\nto at least one variable, at least one clause of Fg is not satisfied. Hence the\nassignment \u03c41 that sets all variables to 1 is the only satisfying total assignment\nof F . Consequently, for any subsolver S, a set B \u2286 var(F ) is a weak S-backdoor\nset of F if and only if S extends the assignment \u03c40 : B \u2192 {1} to the satisfying\nassignment \u03c41.\nFrom yi = 1 for a private variable yi we can infer xi = 1 by means of\nunit propagation, since the clause {xi, yi} is contained in F . Consequently,\nif B is a weak up-backdoor set of F , then replacing private variables yi of B\nwith xi, yields a weak up-backdoor set B\n\u2032 \u2286 G with |B\u2032| \u2264 |B|. Moreover, unit\npropagation on a set Fg behaves exactly as the activation process on the gate g in\nD. For example, consider Fg for an and-gate g = x1\u2227x2. By unit propagation,\nwe infer from x1 = 1 and x2 = 1 the assignments y1 = 1 and y2 = 1, and, in\nturn, g = 1. (However, setting g = 1 does not propagate \u2018upward\u2019 to yi or xi.)\nThus, a set B of gates of D activates D if and only if for \u03c40 : B \u2192 {1}, all\nclauses of F [\u03c40] can be satisfied using several steps of unit propagation; that is,\nB is a weak up-backdoor set of F . Hence we have shown that some starting set\nof size at most k activates D if and only if F has a weak up-backdoor set of size\nat most k. Consequently, W[P]-hardness of weak up-backdoor follows from\nLemma 1.\nNext we show that W[P]-hardness also holds for weak up+pl-backdoor\nby proving that every weak up+pl-backdoor set of F is a weak up-backdoor\nset. Consider \u2205 6= B \u2286 var(F ) and \u03c40 : B \u2192 {1}. First we observe that\nfor any variable x \u2208 var(F ), the negative literal x cannot be pure in F [\u03c40],\nsince otherwise we could infer x = 0 by means of pure literal elimination, but\n11\nthen F [\u03c40] would be unsatisfiable. Since the circuit D has no output gates,\nevery variable of F occurs as xi or yi in some set Fg . However, for every pair\nof variables xi, yi, some Fg contains the binary clauses {xi, yi} and {xi, yi}.\nThus, for xi being a pure literal of F [\u03c40], yi \u2208 B must prevail. Then, however,\nF [\u03c40] contains the unit clause {xi}, and so xi = 1 can be inferred by unit\npropagation, and pure literal elimination is not needed. Similarly, if yi is a pure\nliteral of F [\u03c40], then F [\u03c40] contains the unit clause {yi}, and again yi = 1 can\nbe inferred by unit propagation. We conclude that pure literal elimination is\nredundant for F [\u03c40]. Thus, it follows by induction on |var(F ) \\ B| that B is a\nweak up+pl-backdoor set of F if and only if B is a weak up-backdoor set of F .\nHence weak up+pl-backdoor is W[P]-hard.\nLemma 5. The problems strong up+pl-backdoor and strong up-back-\ndoor are W[P]-hard.\nProof. Let S \u2208 {up+pl,up}. We reduce weak S-backdoor. Let F be a\nformula with exactly one satisfying total assignment \u03c4 ; w.l.o.g., we assume that\n\u03c4 assigns 1 to each variable of F . We obtain a formula F \u2217 from F by taking for\nevery x \u2208 var(F ) a new variable x\u2217 and adding the clauses {x, x\u2217} and {x, x\u2217}\nto F . Note that \u03c4 also satisfies F \u2217 and that every satisfying assignment \u03c4 \u2217 of\nF \u2217 extends \u03c4 .\nWe show that F has a weak S-backdoor set of size at most k if and only if\nF \u2217 has a strong S-backdoor set of size at most k.\nLet B be a weak S-backdoor set of F . Thus, with input F [\u03c40], \u03c40 : B \u2192 {1},\nthe subsolver S finds the assignment \u03c4 that satisfies F . Since the presence of\nclauses {x, x\u2217} and {x, x\u2217} does not prevent any application of unit propagation\nor pure literal elimination, the subsolver S finds the assignment \u03c4 also with input\nF \u2217[\u03c40]. Hence B is a weak S-backdoor set of F \u2217. The set B\u2217 = {x\u2217 : x \u2208 B }\nis evidently a weak S-backdoor set of F \u2217 and we have |B| = |B\u2217|. However, B\u2217\nis also a strong S-backdoor set of F \u2217, since, by symmetry, it does not matter\nwhether a variable x\u2217 is set to 0 or set to 1.\nConversely, let B\u2217 be a strong S-backdoor set of F \u2217. Since F \u2217 is satisfiable,\nB\u2217 is also a weak S-backdoor set of F \u2217; thus S extends \u03c4\u22170 : B\n\u2217 \u2192 {1} to a\nsatisfying assignment of F \u2217. Since {x, x\u2217} \u2208 F \u2217, x\u2217 = 1 yields x = 1 by unit\npropagation. Hence we can replace each x\u2217 \u2208 B\u2217 by x and still have a weak\nS-backdoor set B := {x \u2208 var(F ) : x \u2208 B\u2217 or x\u2217 \u2208 B\u2217 } with |B| \u2264 |B\u2217|. Thus,\nthe subsolver S extends \u03c40 : B \u2192 {1} to a satisfying assignment of F \u2217. The\nclauses in F \u2217 \\ F are irrelevant for such extension, since as early as a variable\nx \u2208 var(F ) gets the value 1 under some extension of \u03c40, the clauses {x, x\u2217} and\n{x, x\u2217} are removed. Consequently B is also a weak S-backdoor set of F .\nLemma 6. weak pl-backdoor is W[P]-hard and remains W[P]-hard for CNF\nformulas which have exactly one satisfying total assignment.\nProof. We reduce cyclic monotone circuit activation as in Lemma 4.\nAgain, let D = (G, E, \u03bb) be a cyclic monotone circuit without input or output\ngates and where all gates are binary. For each gate g \u2208 G we define a set of\nclauses Fg , and we obtain a formula F by taking the union of all sets Fg with\n12\ng \u2208 G. For an and-gate g = x1 \u2227 x2, the set Fg contains the clauses\n{x1, y1}, {x1, y1},\n{x2, y1}, {x2, y1},\n{y1, g};\nfor an or-gate g = x1 \u2228 x2, the set Fg contains the clauses\n{x1, x2, y1},\n{x1, x2, y1},\n{y1, g};\nthe variables yi are private variables. We have G \u2286 var(F ), and since D has no\ninput gates, var(F ) \\ G is the set of private variables. We show that F has a\nweak pl-backdoor set of size at most k if and only if some starting set of size at\nmost k activates D. As in the proof of Lemma 4 it follows from the definition of\nthe sets Fg that the only satisfying total assignment of F sets all variables to 1.\nPure literal elimination on Fg behaves exactly as the activation process on the\ncorresponding gate: e.g., for an and-gate g = x1 \u2227 x2, if \u03c40(x1) = \u03c40(x2) = 1,\nthen the clauses {x1, y1}, {x1, y1}, {x2, y1}, and {x2, y1} are removed from the\nformula and g becomes a pure literal, thus g = 1 follows. Hence a set B \u2286 G of\ngates activates D if and only if B is a weak pl-backdoor set of F . By replacing\nprivate variables yi by xi, we can find for every weak pl-backdoor set B of F a\nweak pl-backdoor set B\u2032 \u2286 G with |B\u2032| \u2264 |B|. Hence F has a weak pl-backdoor\nset of size at most k if and only if some starting set of size at most k activates\nD. Thus we have reduced cyclic monotone circuit activation to weak\npl-backdoor, and the lemma follows.\nLemma 7. The problem strong pl-backdoor is W[P]-hard.\nProof. We reduce weak pl-backdoor. Let F be a formula with exactly one\nsatisfying total assignment \u03c4 ; w.l.o.g., we assume that \u03c4 assigns 1 to each vari-\nable of F . We obtain a formula F \u2217 from F by adding the unit clause {x} for\nevery variable x of F ; i.e.,\nF \u2217 = F \u222a { {x} : x \u2208 var(F ) }.\nEvidently, \u03c4 is also the unique satisfying total assignment of F \u2217. Let \u2205 6= B \u2286\nvar(F ) and \u03c40 : B \u2192 {1}. We observe that a variable is pure in F [\u03c40] if and\nonly if it is pure in F \u2217[\u03c40]. Hence, it follows by induction on |var(F ) \\ B| that\nB is a weak pl-backdoor set of F if and only if B is a weak pl-backdoor set of\nF \u2217. On the other hand, let \u03c4 \u20320 : B \u2192 {0, 1} be any assignment different from\n\u03c40. There is at least one x \u2208 var(F ) such that \u03c4 \u20320(x) = 0. Since {x} \u2208 F\n\u2217,\nF \u2217[\u03c4 \u20320] contains the empty clause, and so the unsatisfiability of F\n\u2217[\u03c4 \u20320] can be\ndecided by any subsolver. Thus, if B is a weak pl-backdoor set of F , B is also\na strong pl-backdoor set of F . Since F \u2217 is satisfiable, every strong pl-backdoor\nset of F \u2217 is also a weak pl-backdoor set of F \u2217. In summary, F has a weak\npl-backdoor set of size at most k if and only if F \u2217 has a strong pl-backdoor set\nof size at most k. Hence W[P]-hardness of strong pl-backdoor follows from\nLemma 6.\n13\nIn view of the above lemmas we conclude that all the considered problems\nare W[P]-complete.\nTheorem 1. The problems weak S-backdoor and strong S-backdoor\nare W[P]-complete for each subsolver S \u2208 {up+pl,up, pl}.\n6 Final Remarks\nIn this paper we have determined the parameterized complexity of the backdoor\nset detection problem for subsolvers that arise from the DLL\/DP procedures.\nOur results indicate that these problems are computationally hard; it is very\nunlikely that, in the worst case, smallest backdoor sets for DLL subsolvers can\nbe found more efficiently than by brute force search. Complementary to the\nfindings of the present paper are the results of Nishimura, Ragde, and Szeider\n[9] on the parameterized complexity of backdoor set detection with respect to the\nsyntactically defined classes HORN and 2-CNF. It turns out that, although weak\nbackdoor set detection with respect to these classes is W[2]-hard, the detection of\nstrong backdoor sets is fixed-parameter tractable! The identification of further\npolynomial-time classes of SAT instances that allow fixed-parameter tractable\nbackdoor set detection is a challenging new direction of research. For example, it\nwould be interesting to know whether the detection of strong backdoor sets w.r.t.\nthe class RHORN of renamable Horn formulas is fixed-parameter tractable. It\nis well known that RHORN properly contains the class of all Horn formulas,\nand RHORN is itself a proper subclass of the class of formulas decidable by unit\npropagation.\nReferences\n[1] K. A. Abrahamson, R. G. Downey, and M. R. Fellows. Fixed-parameter\ntractability and completeness. IV. On completeness for W[P] and PSPACE\nanalogues. Annals of Pure and Applied Logic, 73(3):235\u2013276, 1995.\n[2] S. A. Cook and D. G. Mitchell. Finding hard instances of the satisfiability\nproblem: a survey. In Satisfiability problem: theory and applications (Pis-\ncataway, NJ, 1996), pages 1\u201317. American Mathematical Society, 1997.\n[3] M. Davis, G. Logemann, and D. Loveland. A machine program for theorem-\nproving. Comm. ACM, 5:394\u2013397, 1962.\n[4] M. Davis and H. Putnam. A computing procedure for quantification theory.\nJournal of the ACM, 7(3):201\u2013215, 1960.\n[5] R. G. Downey and M. R. Fellows. Parameterized Complexity. Monographs\nin Computer Science. Springer Verlag, 1999.\n[6] J. Flum and M. Grohe. Parameterized complexity and subexponential time.\nBulletin of the European Association for Theoretical Computer Science,\n84:71\u2013100, 2004.\n[7] Y. Interian. Backdoor sets for random 3-SAT. In Sixth International Con-\nference on Theory and Applications of Satisfiability Testing, S. Margherita\n14\nLigure, Portofino, Italy, May 5\u20138, 2003, (SAT 2003), informal proceedings,\npages 231\u2013238, 2003.\n[8] S. Malik. Analysis of cyclic combinatorial circuits. IEEE Transactions on\nComputer Aided Design, 13(7):950\u2013956, 1994.\n[9] N. Nishimura, P. Ragde, and S. Szeider. Detecting backdoor sets with re-\nspect to Horn and binary clauses. In H. Hoos and D. G. Mitchell, editors,\nSeventh International Conference on Theory and Applications of Satisfi-\nability Testing, 10\u201313 May, 2004, Vancouver, BC, Canada (SAT 2004),\ninformal proceedings, pages 96\u2013103, 2004.\n[10] Y. Ruan, H. A. Kautz, and E. Horvitz. The backdoor key: A path to\nunderstanding problem hardness. In D. L. McGuinness and G. Ferguson,\neditors, Proceedings of the 19th National Conference on Artificial Intelli-\ngence, 16th Conference on Innovative Applications of Artificial Intelligence,\npages 124\u2013130. AAAI Press \/ The MIT Press, 2004.\n[11] R. Williams, C. Gomes, and B. Selman. Backdoors to typical case complex-\nity. In G. Gottlob and T. Walsh, editors, Proceedings of the Eighteenth In-\nternational Joint Conference on Artificial Intelligence, IJCAI 2003, pages\n1173\u20131178. Morgan Kaufmann, 2003.\n[12] R. Williams, C. Gomes, and B. Selman. On the connections between back-\ndoors, restarts, and heavy-tailedness in combinatorial search. In Sixth In-\nternational Conference on Theory and Applications of Satisfiability Testing,\nS. Margherita Ligure, Portofino, Italy, May 5-8, 2003 (SAT 2003), infor-\nmal proceedings, pages 222\u2013230, 2003.\n15\n"}