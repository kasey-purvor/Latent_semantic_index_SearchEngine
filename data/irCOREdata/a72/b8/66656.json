{"doi":"10.1109\/TSE.2003.1232289","coreId":"66656","oai":"oai:dro.dur.ac.uk.OAI2:611","identifiers":["oai:dro.dur.ac.uk.OAI2:611","10.1109\/TSE.2003.1232289"],"title":"Moral dominance relations for program comprehension.","authors":["Shaw,  S. C.","Goldstein,  M.","Munro,  M.","Burd,  E."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2003-09","abstract":"Dominance trees have been used as a means for reengineering legacy systems into potential reuse candidates. The dominance relation suggests the reuse candidates which are identified by strongly directly dominated subtrees. We review the approach and illustrate how the dominance tree may fail to show the relationship between the strongly directly dominated procedures and the directly dominated procedures. We introduce a relation of generalized conditional independence which strengthens the argument for the adoption of the potential reuse candidates suggested by the dominance tree and explains their relationship with the directly dominated vertices. This leads to an improved dominance tree, the moral dominance tree, which helps aid program comprehension available from the tree. The generalized conditional independence relation also identifies potential reuse candidates that are missed by the dominance relation","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66656.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/611\/1\/611.pdf","pdfHashValue":"cf2f892b7c0ef1a2c954ceba9247e6bc0b90c87d","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:611<\/identifier><datestamp>\n      2011-06-15T15:50:33Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Moral dominance relations for program comprehension.<\/dc:title><dc:creator>\n        Shaw,  S. C.<\/dc:creator><dc:creator>\n        Goldstein,  M.<\/dc:creator><dc:creator>\n        Munro,  M.<\/dc:creator><dc:creator>\n        Burd,  E.<\/dc:creator><dc:description>\n        Dominance trees have been used as a means for reengineering legacy systems into potential reuse candidates. The dominance relation suggests the reuse candidates which are identified by strongly directly dominated subtrees. We review the approach and illustrate how the dominance tree may fail to show the relationship between the strongly directly dominated procedures and the directly dominated procedures. We introduce a relation of generalized conditional independence which strengthens the argument for the adoption of the potential reuse candidates suggested by the dominance tree and explains their relationship with the directly dominated vertices. This leads to an improved dominance tree, the moral dominance tree, which helps aid program comprehension available from the tree. The generalized conditional independence relation also identifies potential reuse candidates that are missed by the dominance relation. <\/dc:description><dc:subject>\n        Dominance trees<\/dc:subject><dc:subject>\n         Reengineering<\/dc:subject><dc:subject>\n         Legacy systems.<\/dc:subject><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        IEEE transactions on software engineering, 2003, Vol.29(9), pp.851-863 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2003-09<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:611<\/dc:identifier><dc:identifier>\n        issn:0098-5589<\/dc:identifier><dc:identifier>\n        doi:10.1109\/TSE.2003.1232289<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/611\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/TSE.2003.1232289<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/611\/1\/611.pdf<\/dc:identifier><dc:rights>\n        \u00ae 2003 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:0098-5589","0098-5589"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2003,"topics":["Dominance trees","Reengineering","Legacy systems."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 October 2008\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nShaw, S. C. and Goldstein, M. and Munro, M. and Burd, E. (2003) \u2019Moral dominance relations for program\ncomprehension.\u2019, IEEE transactions on software engineering., 29 (9). pp. 851-863.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/TSE.2003.1232289\nPublisher\u2019s copyright statement:\n2003 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nMoral Dominance Relations for\nProgram Comprehension\nSimon C. Shaw, Michael Goldstein, Malcolm Munro, and Elizabeth Burd, Member, IEEE\nAbstract\u2014Dominance trees have been used as a means for reengineering legacy systems into potential reuse candidates. The\ndominance relation suggests the reuse candidates which are identified by strongly directly dominated subtrees. We review the\napproach and illustrate how the dominance tree may fail to show the relationship between the strongly directly dominated procedures\nand the directly dominated procedures. We introduce a relation of generalized conditional independence which strengthens the\nargument for the adoption of the potential reuse candidates suggested by the dominance tree and explains their relationship with the\ndirectly dominated vertices. This leads to an improved dominance tree, the moral dominance tree, which helps aid program\ncomprehension available from the tree. The generalized conditional independence relation also identifies potential reuse candidates\nthat are missed by the dominance relation.\nIndex Terms\u2014Directed graphical model, generalized conditional independence, dominance tree, program comprehension,\nreengineering, reuse candidate, reverse engineering, testing.\n\u0001\n1 INTRODUCTION\nFOR many companies, software drives the business andprovides the only true description of their operations.\nAs businesses evolve, so should the software. Thus, it is\nnecessary to perform software maintenance, \u201cthe modifica-\ntion of software products after delivery to correct faults, to\nimprove performance or other attributes, or to adapt the\nproduct to a changed environment,\u201d [18]. Program com-\nprehension, in this setting, involves acquiring knowledge\nabout programs, as well as any remaining documentation\nand operating procedures. We aim both to understand the\nsoftware through visualization and to identify areas of the\ncode which may be remodularized as a means of aiding\nmaintenance by localizing the impacts of change. Further,\nthese identified modules are potential reuse candidates.\nIn this paper, we are concerned with functional abstrac-\ntions through aggregation based upon the calling structure\nof a piece of code. To restrict the discussion to a manageable\nlength, we thus consider only persistent data such as files or\ntables and regard the program as consisting of a database,\nD, and a collection of procedures which may be called and\nwhich operate on the database. The database is viewed as\nencoding the state of the program. We shall expand upon\nthis description in Section 3. The separate modules we\ndiscuss are coarse-grained persistent objects as opposed to\nfine-grained volatile objects. As Cimitile et al. [11] point out,\nthis is more appropriate when considering potential reuse;\nthey also provide a good review of work on fine-grained\nvolatile objects.\nThe potential reuse candidates are obtained from\nsubtrees on the dominance tree, an abstraction of the calling\nstructure. Various authors [6], [7], [9], [10], [11], [12] have\nworked on the identification of potential reuse candidates\nfrom the dominance tree and, in Section 2, we review the\ntechniques. Mu\u00a8ller et al. ([23]) have also worked on the\nidentification of reuse candidates. Canfora et al. ([8]) talk of\nthe balance between \u201cthe ability to simply partition a legacy\nsystem into objects versus the ability to abstract an\narchitecture (i.e., relations between objects).\u201d In the exam-\nples in Section 2, we highlight some limitations of the\ndominance tree in its failure to both develop an architecture\nand, in certain simple cases, failure to highlight potential\nreuse candidates. In Section 3, we introduce an alternative\nrelation on the call graph, that of generalized conditional\nindependence (g.c.i.). In Section 4, we show how the\nadoption of the g.c.i. relation gives a formal underpinning\nfor the selection of reuse candidates from a modified form\nof the dominance tree. The theory is illustrated by a series of\nsimple examples.\n2 PROGRAM COMPREHENSION USING\nDOMINANCE TREES\nIn this section, we review current approaches to program\ncomprehension using the dominance tree derived from the\ncall graph. Through a series of examples, we illustrate the\nmethodology and suggest a number of potential problems\nwith the current practice. In Sections 3 and 4, we introduce a\nformal approach, based around the g.c.i. relation, to address\nthese problems.\nIEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 29, NO. 9, SEPTEMBER 2003 851\n. S.C. Shaw and M. Goldstein are with the Department of Mathematical\nSciences, University of Durham, Science Laboratories, South Road,\nDurham, DH1 3LE, UK.\nE-mail: {S.C.Shaw, Michael.Goldstein}@durham.ac.uk.\n. M. Munro and E. Burd are with the Research Institute in Software\nEvolution, Department of Computer Science, University of Durham,\nScience Laboratories, South Road, Durham, DH1 3LE, UK.\nE-mail: {malcolm.munro, Liz.Burd}@durham.ac.uk.\nManuscript received 19 Dec. 2001; revised 8 Oct. 2002; accepted 27 May\n2003.\nRecommended for acceptance by G. Canfora.\nFor information on obtaining reprints of this article, please send e-mail to:\ntse@computer.org, and reference IEEECS Log Number 115590.\n0098-5589\/03\/$17.00 \u0001 2003 IEEE Published by the IEEE Computer Society\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\n2.1 The Call Graph\nThe call structure of a piece of code provides a high-level\ndescription of the flow of the program. This structure\ndescribes the procedural units and the relationships\nbetween them. Examples of procedural units are functions\nin the language C, paragraphs in COBOL, and methods in\nJava. In this paper, we use the generic term \u201cprocedure\u201d\nand the relationships between procedures are termed\n\u201ccalls.\u201d No attempt is made to introduce other relationships\nthat may, for example, enable data flow analysis. The\ncalling structure may be visualized by presenting it as a\ngraph. We follow the notation and terminology of Lauritzen\n[20] so that a graph is a pair G \u00bc \u00f0V ;E\u00de, where V is a finite\nset of vertices and E is the set of edges, a subset of V \u0001 V\nthe set of ordered pairs of distinct vertices. An edge \u00f0f; g\u00de 2\nE is directed, denoted f ! g, if \u00f0f; g\u00de 2 E ^ \u00f0g; f\u00de =2 E. We\nterm f a parent of g and g a child of f . The full collection of\nparents of g are denoted by paG\u00f0g\u00de while chG\u00f0f\u00de denotes the\nfull collection of children of f . An edge \u00f0f; g\u00de 2 E is\nundirected, denoted f \u0002 g, if \u00f0f; g\u00de 2 E ^ \u00f0g; f\u00de 2 E. If\n\u00f0f; g\u00de =2 E, we write f 6! g and if \u00f0f; g\u00de =2 E ^ \u00f0g; f\u00de =2 E, we\nwrite f 6\u0002 g. If all edges on the graph are directed then the\ngraph is said to be directed, whereas it is undirected if all\nedges are undirected. A path of length n from f to g is a\nsequence f \u00bc f0, f1; . . . ; fn \u00bc g such that \u00f0fi\u00031; fi\u00de 2 E 8i\n\u00bc 1; . . . ; n. We write f 7! g. If both f 7! g and g 7! f , then f\nand g are said to connect and we write f \u00d0 g. If either f 7! g\nor g 7! f , we state that there is a direct path between f and\ng. There is an undirected path between f and g if there is a\nsequence f \u00bc f0, f1; . . . ; fn \u00bc g such that either \u00f0fi\u00031; fi\u00de 2 E\nor \u00f0fi; fi\u00031\u00de 2 E for all i \u00bc 1; . . . ; n. A directed graph is\nweakly connected if there is an undirected path between\nany pair of vertices and strongly connected if there is a\ndirected path between every pair of vertices. If f 7! g and\ng 67!f , then f is an ancestor of g and g a descendent of f . The\ncomplete collection of ancestors of g are denoted by anG\u00f0g\u00de\nwhile the complete collection of descendents of f are\ndenoted by deG\u00f0f\u00de. An n-cycle is a path of length n from f to\nitself. If the graph G contains no cycles, then it is said to be\nacyclic. An acyclic connected undirected graph is termed a\ntree; a rooted tree is a directed acyclic graph (DAG)\nobtained from a tree by choosing a vertex as a root and\ndirecting all edges away from this vertex. For VS \u0004 V , we\nmay obtain the subgraph GS \u00bc \u00f0VS; ES\u00de, where ES is\nobtained from G by keeping the edges with both endpoints\nin VS . A cycle thus generates a strongly connected\nsubgraph.\nDefinition 1. A call graph is a directed graph, GC \u00bc \u00f0VC;EC\u00de.\nThe finite set of vertices, VC , consists of the procedures which\nare either called or call other procedures in the program. For\nany two procedures f , g 2 V if there is a call to g by f , then the\nedge \u00f0f; g\u00de appears on the graph. The complete collection of\nedges is denoted by EC .\nSome languages permit direct or indirect recursion and\nso the call graph may be cyclical. As Cimitile and Visaggio\n[12] highlight, \u201cthe existence of recursions among proce-\ndures is in fact indicative of the implementation of a\nfunctionality through a recursive algorithm\u201d and suggest\nthat two or more procedures in such a recursive call\nrelationship exhibit a high level of coupling and may be\nconsidered as a single module. By collapsing every strongly\nconnected subgraph into a single vertex, we may convert\nthe call graph into a DAG. This remodularization will also\nsimplify the visualization by reducing the number of\nvertices and edges without damaging the architecture of\nthe system, as calls from and to the procedures in the cycle\nare maintained on the modified call graph. We proceed by\nassuming that such a remodularization has been performed\non the call graphs we consider, so that we deal only with\nDAGs. Notice that, by virtue of containing no cycles, DAGs\nmust have at least one vertex that has no parents: If G \u00bc\n\u00f0V ;E\u00de is a DAG, then there exists f 2 V such that for all\ng 2 V ; \u00f0g; f\u00de =2 E. Thus, in terms of the call graph, f is a\nprocedure which is not called by any other procedure. Such\nprocedures are often called entry points; in this paper, we\nterm them root nodes.\nFig. 1a shows an example of a very simple call graph; it\nhas a single root node A000. It is straightforward to\nunderstand the calling structure of the program. For\nexample, once D000 has been called, the execution of the\nprogram exists purely in the collection D\u0005 \u00bc fD000; D100;\nD200; D110g until D000 is exited. Similarly, once B000 has\nbeen called, execution exists purely in the collection B\u0005 \u00bc\nfB000; B100; B200g until B000 is exited. Notice that,\nfollowing a call to C000, execution does not exist purely\nin the collection C\u0005 \u00bc fC000; C100; C200; C110g since C000\ncalls B000 and, so, execution may switch to B\u0005. However,\nexecution cannot switch to D\u0005. Observe that, by removing\nthe procedure A000 and the three calls it makes from the\ncall graph, we are left with a subgraph that consists of two\ndisconnected subgraphs, B\u0005 [ C\u0005 and D\u0005. Intuitively, it\nseems that B\u0005 and D\u0005 can be considered as reuse candidates\nwith D\u0005 being accessed by A000 and B\u0005 by A000 and C000.\nA more formal approach is required to both strengthen the\nintuitive argument for this example and to handle call\ngraphs with many thousands of procedures and calls. The\nmost familiar approach is to make a further abstraction of\nthe call structure by converting the call graph into a rooted\ntree using the dominance relation; the rooted tree is termed\nthe dominance tree.\n2.2 The Dominance Tree\nThe dominance tree aims to assist program comprehension\nby reducing information overload during the early stages\nof comprehension and by identifying collections of proce-\ndures which may be remodularized into single modules.\nThe dominance tree is a rooted tree whose root is a root\nnode of the call graph GC \u00bc \u00f0VC;EC\u00de and is constructed\nusing the relations of direct dominance and strong direct\ndominance, [17].\nDefinition 2. If f 2 VC is a root node of the call graph GC and\ndeC\u00f0f\u00de the descendents of f on GC , then we construct the\nsubgraph GCf \u00bc \u00f0f\u0005; ECf \u00de, where f\u0005 \u00bc ffg [ deC\u00f0f\u00de. For\nprocedures g; h 2 f\u0005, g dominates h on GCf if and only if\nevery path f 7! h on GCf intersects g. We say that g directly\n852 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 29, NO. 9, SEPTEMBER 2003\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\ndominates h on GCf if and only if all procedures that dominate\nh on GCf dominate g on GCf . g strongly directly dominates h\non GCf if and only if g directly dominates h on GCf and is the\nonly procedure in f\u0005 that calls h.\nThe root node, f , trivially dominates all procedures h 2\ndeC\u00f0f\u00de and the direct dominance relation identifies, for each\nh, a single procedure from the collection of dominators of h.\nDefinition 3. The dominance tree corresponding to a root node, f ,\nis the graph GDf \u00bc \u00f0f\u0005; EDf \u00de formed from GCf \u00bc \u00f0f\u0005; ECf \u00de, the\nsubgraph of the call graph GC\u00bc \u00f0VC;EC\u00de, where f\u0005 \u00bc ffg\n[ deC\u00f0f\u00de and EDf \u00bcf\u00f0g; h\u00de8g; h 2 f\u0005 : g directly dominates\nh on GCfg. The vertex h is shaded if g only directly dominates h\non GCf .\nEach root node of GC \u00bc \u00f0VC;EC\u00de will generate its own\ndominance tree. If GC has a single root node, f , then f\u0005 \u00bc VC\nand GCf \u00bc GC and we denote the dominance tree by\nGD \u00bc \u00f0VC;ED\u00de. The call graph in Fig. 1a has a single root\nnode and the sole corresponding dominance tree, GD, is\nshown in Fig. 1c. Vertices which are not strongly directly\ndominated are shaded. For example, D000 strongly directly\ndominates D100, while D110 is only directly dominated by\nD000. Procedures that are only directly dominated have\nbecome disinherited from some, possibly all, of the\nprocedures which called them: They had at least two\ncalling vertices and may not be directly dominated by any\nof them. In Fig. 1c, D110 is directly dominated by D000, but\nD000 does not call D110 in Fig. 1a. Thus, ED 6\u0004 EC : The\ndominance tree is not merely the call graph with some\nedges removed. Procedures which are only directly\ndominated indicate a more complex relationship in the call\ngraph than that shown on the dominance tree and so\ninformation is lost in the abstraction from the call graph to\nthe dominance tree at the shaded vertices. Intuitively, the\ngreater the proportion of shaded vertices, the more\nproblematic program comprehension may be from the\ndominance tree.\nOne benefit of the dominance tree to program compre-\nhension is that it reduces the complexity of the visualization\nof the call graph and the layout is straightforward. In\ncommercial applications, see, for example [6], procedures\nhave been found to call or be called by over 100 procedures\nand so a reduction to a single edge on the dominance tree\ngreatly increases the readability of the graphic. It is with\nsuch large complex problems in mind that, in Definition 3,\nwe follow the convention of, for example, [2], [3], [4], [5] in\ndistinguishing between strong direct dominance and direct\ndominance by vertex shading as opposed to the dashed and\nsolid edged approach adopted in, for example, [9], [12], [11],\nas this improves the visual representation. As an illustration\nSHAW ET AL.: MORAL DOMINANCE RELATIONS FOR PROGRAM COMPREHENSION 853\nFig. 1. (a) A simple call graph. Procedure A000 calls procedures B000, C000, and D000. Procedure C000 calls procedures B000, C100, and C200,\nand so on. (b) A second simple call graph. (c) The dominance tree corresponding to both the call graph in (a) and that in (b). (d) The moral\ndominance tree resulting from the call graph of (a). (e) The moral dominance tree resulting from the call graph of (b).\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\nof this, the dominance tree in Fig. 2 of [2] contains 230\nprocedures and it is easy to identify whether subtrees\nwithin the dominance tree contain shaded vertices whereas\nthe scale would make it hard to distinguish between dashed\nand solid edges.\nIn addition to visualization, dominance trees have been\nused to identify potential reuse candidates within the code\nwhich may then be reengineered into separate modules.\nThis modularization helps make the code more flexible\nand maintainable. Burd and Munro [4] write that \u201cthe\ndirectly dominates and strongly directly dominates rela-\ntions define where remodularization can occur. For\ninstance, where directly dominates relations are identified,\nthis means that calls are made to other vertices within the\nbranch of the tree.\u201d For example, on the dominance tree in\nFig. 1c, C110 is only directly dominated which indicates\nthat it must be called by at least one of C100 or C200. We\ndo not know whether C000 calls it. From the call graph in\nFig. 1a, we can confirm that both C100 and C200 call C110\nand C000 does not.\n2.3 \u201cSingle Call In\u201d and \u201cMultiple Calls In\u201d Subtrees\nFor a dominance tree GDf and any procedure h 2 VDf , we\nare interested in the subtree consisting of the collection of\nprocedures h\u0006 \u00bc fhg [ deDf \u00f0h\u00de, the procedure h and all of its\ndescendents on GDf . The dominance relation means that the\nonly calls from VDf n h\u0006 to h\u0006 on the call graph GC are to h\nitself. If h is strongly directly dominated by g 2 VDf n h\u0006,\nthen this is the only call to h from the procedures in VDf n h\u0006\non the call graph and this call may be deduced from GDf ;\nGDf illustrates how h\u0006 is accessed by the other procedures,\nVDf n h\u0006. Consequently, we introduce the term \u201csingle call\nin\u201d subtree to describe h\u0006.\nIf, however, h is only directly dominated by g 2 VDf n h\u0006,\nthen the limit of the information given by the dominance\ntree is that we only know there is a call from at least one\nprocedure, ~g 2 deDf \u00f0g\u00de n h\u0006, to h on the call graph. We do\nnot know whether g itself calls h or indeed how many such\n~g there are. In this case, we introduce the term \u201cmultiple\ncalls in\u201d subtree to describe h\u0006. \u201cMultiple calls in\u201d subtrees\nlead to a lack of uniqueness of the dominance tree: Different\ncall graphs lead to the same dominance tree. For example,\nthe same tree is produced by setting paCf \u00f0h\u00de \u00bc g\u0006 n h\u0006 rather\nthan the actuality of paCf \u00f0h\u00de \u0004 g\u0006 n h\u0006. The lack of unique-\nness becomes more apparent the larger g\u0006 n h\u0006 is. Without\nrecourse to the call graph, this could lead to difficulties in\nidentifying reuse candidates and assessing the impact of\nchange by mapping ripple effects, the changes that become\nnecessary to make due to maintenance on another part of\nthe code.\nAs an illustration, consider the call graph in Fig. 1b. The\ncorresponding dominance tree is identical to the dominance\ntree for the call graph in Fig. 1a. B000 is only directly\ndominated by A000 and, so, any call graph corresponding to\nthe dominance tree in Fig. 1c must contain at least one call\nfrom C000\u0006[D000\u0006 to B000. For the call graph in Fig. 1a,\nthere is a solitary procedure, C000 2 C000\u0006 [D000\u0006, while,\nin the call graph in Fig. 1b, there are two procedures, C110\nand D110, in C000\u0006 [D000\u0006 which call B000. Notice that\nA000 does not call B000 on the call graph in Fig. 1b. The two\ncall graphs have very different structure; in particular, notice\nthat for the call graph in Fig. 1b, B000\u0006 is contained in the set\nof descendents for every other procedure and, so, a change to\nB000 could ripple through all of C000\u0006 and D000\u0006. Even for\nthese very simple examples, a comprehension based purely\non the shared dominance tree in Fig. 1c will fail to capture the\ndifferences between the two call graphs.\nCurrent practice is to use the subtrees which we term\n\u201csingle call in\u201d subtrees as the basis for identifying potential\nreuse candidates. Consider a dominance tree, GDf , where\nthe procedure g strongly directly dominates procedures\nh1; . . . ; hn and [ni\u00bc1 \u00bc chDf \u00f0g\u00de, the children of g on GDf . Burd\nand Munro [3] identify the individual subtrees h\u0006i for each\ni \u00bc 1; . . . ; n as potential reuse candidates. There are no calls\nbetween the h\u0006i on the call graph GC . Once execution enters\nh\u0006i , it cannot switch to any other procedure ~g =2 h\u0006i until hi is\nexited. If, however, there exists a procedure hn\u00fe1 such that\nhn\u00fe1 is only directly dominated by g on GDf , then there is at\nleast one h\u0006j such that execution can switch from h\n\u0006\nj to h\n\u0006\nn\u00fe1.\nThis is the case with the dominance tree in Fig. 1c. C000\u0006,\nD000\u0006 are \u201csingle call in\u201d subtrees strongly directly\ndominated by A000. Execution cannot switch between\nC000\u0006 and D000\u0006. However, B000\u0006 is a \u201cmultiple calls in\u201d\nsubtree directly dominated by A000 and, so, execution\ncould switch from either C000\u0006 to B000\u0006 or from D000\u0006 to\nB000\u0006. For the call graph in Fig. 1a, it is C000\u0006 to B000\u0006\nwhile, for that in Fig. 1b, it is both C000\u0006 to B000\u0006 andD000\u0006\nto B000\u0006. For the call graph in Fig. 1a, see Section 2.1, we\nmight suggest the reuse candidates to be B000\u0006 [ C000\u0006 and\nD000\u0006 with B000\u0006 a separate module within the module\nB000\u0006 [ C000\u0006. This isolation is not apparent on the\ndominance tree. For the call graph in Fig. 1b, we might\nargue that B000\u0006 was a separate module used by the\nmodules C000\u0006 and D000\u0006. While the dominance tree,\nFig. 1c, identifies that, for both call graphs (in Figs. 1a and\n1b), execution cannot switch between C000\u0006 and D000\u0006,\nthere is no automated way we can link these collections\ncorrectly with B000\u0006: The relationship differs in the two call\ngraphs. As Burd and Munro [4] point out, \u201cthis represents a\nfailure to properly isolate candidates at an appropriate level\nof granularity.\u201d In addition to the relationship between\n\u201csingle call in\u201d branches and \u201cmultiple calls in\u201d branches,\ndiffering relations between the \u201csingle call in\u201d branches are\nnot visible on the call graph. For example, consider the\n\u201csingle call in\u201d branches C000\u0006 and D000\u0006 on the\ndominance tree in Fig. 1c. C000 and D000 have no shared\ndescendents on the call graph in Fig. 1a, while for that in\nFig. 1b, the set B000\u0006 is contained in the set of descendents\nof both C000 and D000. We would like a means of\nrecognising whether, and how, the branches on the\ndominance tree are related.\n2.4 Further Problems with Dominance Trees\nThe problem of multiple root nodes. The dominance\nrelation is determined from a specific root node of the call\ngraph. When a call graph has multiple root nodes, multiple\ndominance trees must be generated and the same proce-\ndures may appear on different dominance trees. Burd and\nMunro [4, Section 4] found this problem in case studies of\n854 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 29, NO. 9, SEPTEMBER 2003\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\nC code. They write that \u201cwithin the case studies, the largest\nnumber of dominance trees identified from a single code\nfile was 41 ... The fact that multiple dominance trees are\ngenerated can be problematic if procedures are shared\nbetween individual dominance trees. In all cases identified\nthrough the case study, this was found to be the case.\u201d It is\nnot clear how to assess the relationship between multiple\ndominance trees.\nFailure to capture potential reuse candidates. Consider\nthe call graph inFig. 2a. Its structure is similar to that of Fig. 1b\nand we could argue that the collections C\u0005 \u00bc fC001; C000;\nC100; C200; C110g andD\u0005\u00bcfD001; D000; D100; D200; D110g\nform two separate modules which access the module\nB\u0005 \u00bc fB000; B100; B200g. The corresponding dominance\ntree is shown in Fig. 2b. Only B\u0005 appears as a subtree on\nthe dominance tree while both C\u0005 and D\u0005 collapse: Of the\n10 procedures in C\u0005 [D\u0005, only four are strongly directly\ndominated. Excluding A000\u0006, the \u201csingle call in\u201d subtrees all\ncontain a single procedure. For this example, the dominance\ntree provides a poor representation of the call graph and is\nnot helpful for program comprehension.\nThe dominance relation, see Definition 2, may be viewed\nas a graph separation property. For a graph G \u00bc \u00f0V ;E\u00de, a\nsubset G \u0004 V is said to be an \u00f0f; h\u00de-separator if all paths\nfrom f to g intersect G. Thus, for a directed graph, for each\npath f 7! h, there exists g 2 G such that f 2 anG\u00f0g\u00de and\nh 2 deG\u00f0g\u00de. If F , G, and H are nonoverlapping subsets of V ,\nthen G is said to separate F from H if G is an\nSHAW ET AL.: MORAL DOMINANCE RELATIONS FOR PROGRAM COMPREHENSION 855\nFig. 2. (a) A third call graph. (b) The corresponding dominance tree. (c) The modified call graph obtained by merging vertices in the cliques on the call\ngraph in (a). (d) The moral dominance tree corresponding to the modified call graph.\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\n\u00f0f; h\u00de-separator for every f 2 F , h 2 H. Thus, g dominates h\non GCf if and only if g separates f from h on GCf , that is, g is\nan \u00f0f; h\u00de-separator. The separation property may be applied\nto any three collections of vertices whereas the dominance\nrelation applies to only three vertices, one of which is a root\nnode and, in particular, only a single vertex is considered\nfor the separator set. For the call graph in Fig. 2a, it is this\nsearch for a single vertex that causes the collections C\u0005, D\u0005\nto collapse for A000 is separated from fC100; C200; C110g\nby fC001; C000g, while fD001; D000g separates A000 from\nfC100; C200; C110g. By considering separations of indivi-\ndual vertices rather than collections of vertices on the\noriginal call graph, we may fail to identify potential reuse\ncandidates and comprehend the calling structure. Indeed,\nby lifting the restriction of graph separation away from a\nroot node, we can identify the differences between the call\ngraphs in Figs. 1a and 1b. In the former, C000\u0006 and D000\u0006\nare separated by the empty set; in the latter, C000\u0006 and\nD000\u0006 are separated by B000. This discussion suggests that\nan approach based upon more general graph separations\nrather than the dominance relation will be a more fruitful\napproach to program comprehension and we now develop\nsuch an approach.\n3 g.c.i. REPRESENTATIONS FOR\nTHE CALLING STRUCTURE\nIn this section, we show how we can formalize the\nrelationship between any collection of procedures on the\ncall graph. To achieve this, we use the calculus of g.c.i.\nproperties, a relation on triples of uncertain quantities, W ,\nX, Y , which identifies whether given information on W ,\ninformation on X has a bearing on the uncertainty about Y .\n3.1 Procedures and Uncertainty in\nthe Calling Structure\nFor simplicity of exposition, we regard a piece of code as\nconsisting of a database, D, which encodes the state of the\nprogram (for example, the variables), and a collection of\nprocedures which may be called and which operate on the\ndatabase. Having been called, each procedure is viewed as\nprocessing an input in order to perform an action. Upon\ncompletion of the action, control of the program returns to\nthe procedure which made the call. For example, the action\nmay be to read an item in the database or to write to the\ndatabase. The result of the action is, thus, dependent upon\nthe state of the database immediately prior to the call\nbeing made.\nTo formalize this, let GC \u00bc \u00f0VC;EC\u00de be a call graph with\ng, h 2 VC . Suppose a call is made to h by g with input a and\nthat, immediately prior to this call, the state of the database\nis Da. The expected outcome, having processed the input, is\nthat the result of the action is hDa\u00f0a\u00de and the state of the\ndatabase is Dh\u00f0a\u00de. However, we actually observe ~hDa\u00f0a\u00de and\nD ~h\u00f0a\u00de. There is uncertainty as to whether the procedure\nhas performed the action correctly, that is, whether\n~hDa\u00f0a\u00de \u00bc hDa\u00f0a\u00de, and also whether the database has been\nleft in the desired state, that is, whether D ~h\u00f0a\u00de \u00bc Dh\u00f0a\u00de.\nDefinition 4. The procedure h is said to work for input a if, for\nall possible database states, Da, we have ~hDa\u00f0a\u00de \u00bc hDa\u00f0a\u00de and\nD ~h\u00f0a\u00de \u00bc Dh\u00f0a\u00de. If the two conditions do not both hold, then the\nprocedure h is said to be in error for a.\nThe error is specific to the procedure; the procedure\nshould be able to cope with any given state of the database\nand any given input. For instance, if a procedure fails to\nleave the database in the desired state, a later procedure\naccessing the database will not be in error if it can handle\nthis error. As an example, suppose a piece of code operates\nan accounts system for a bank. Procedure h has the function\nof adding a given amount, x, to a specific account y (so the\ninput is a \u00bc \u00f0x; y\u00de). It does this by adding x to every\naccount. h performs its action correctly but does not leave\nthe database in the desired state. h is in error for a. If\nprocedure i is now called to read the amount in account z,\nalthough the incorrect amount is present in z, iwill not be in\nerror if it correctly reads the amount present (and leaves the\ndatabase unchanged).\nDefinition 5. The procedure h is said to work if it works for each\ninput a 2 A, where A is the set of possible inputs. If there is an\ninput a such that the procedure h is in error for a, then the\nprocedure is said to not work.\nDefinition 5 allows us to consider the potential propaga-\ntion of errors. Suppose that GC \u00bc \u00f0VC;EC\u00de is a call graph\nwith f , g, h 2 VC and \u00f0f; g\u00de, \u00f0g; h\u00de 2 EC . Suppose g is called\nby f with input ~a and that, in order to process this action, g\ncalls h with input a. If h is in error for a, then an error is\npresent when control is returned to g and, thus, when\ncontrol returns from g to f : g is in error for ~a. The error has\npropagated from h to g and then to f (as the return from f\nwill contain an error). The dependence on the database state\nimmediately prior to the call being made (see Definition 4)\nmeans that the only way for errors to propagate is in the\nreverse order to calls on the call graph. In general, the error\nmay only propagate from, on the call graph, child to parent:\nIt depends upon whether the parent calls the child with an\ninput for which the child is in error. This propagation of\nerrors, in the reverse order to the calls, leads us to make the\nfollowing definition.\nDefinition 6. For a call graph GC \u00bc \u00f0VC;EC\u00de with g, h 2 VC , we\nconstruct the error propagation graph ~GC \u00bc \u00f0VC;ER\u00de, where\nER \u00bc f\u00f0h; g\u00de : \u00f0g; h\u00de 2 ECg.\n~GC is thus the call graph with the edges reversed and it\nmaps the potential propagation of errors, as defined by\nDefinition 5. Notice that, while we talk here about error\npropagation, we are interested in actions where a change in\nthe child on the call graph could cause a change in the\nparent. We view ripple effects as being such an action. Each\nprocedure may be viewed as a random quantity having two\npossible states: 1 if the procedure works and 0 if the\nprocedure does not work.\nViewing the procedures in this way enables us to\nformalize a relationship between the procedures. We may\nconsider whether learning the state of a given procedure is\n856 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 29, NO. 9, SEPTEMBER 2003\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\ninformative about the state of another procedure of interest.\nThis may help us distinguish between call graphs where the\ndominance tree fails to detect a difference. Consider the call\ngraphs in Figs. 1a and 1b and suppose that we learn that\nC000 does not work. In both call graphs, this could have\nbeen caused by an error propagating from B000 and, so, we\nwould now believe the chance of B000 not working to be\ngreater than before. There is a relationship between B000\nand C000 in both cases, but this is not shown on the\ndominance tree, Fig. 1c. In Fig. 1b, an error in B000 could\npropagate to D\u0005 \u00bc fD000; D100; D200; D110g and, so, learn-\ning about C000 influences D\u0005. However, in Fig. 1a, this is\nnot the case. Notice that, if we already knew the state of\nB000 for the call graph in Fig. 1b, say that it worked, then\nlearning that C000 does not work no longer provides any\ninformation about D\u0005 as we know the error in C000 has not\npropagated from B000. Knowledge of the state of B000\nseparates the uncertainty, in terms of whether the proce-\ndures are working, between C000 and D\u0005. We may\nrepresent such separations using the concept of g.c.i., as\nwe now explain.\n3.2 Generalized Conditional Independence Property\nSmith [25], [26] defined a tertiary relation, \u00f0\u0007? \u0007\u00dej \u0007 , on all\ntriples W , X, Y of uncertain quantities, that is quantities\nwhose state is currently unknown to us, as follows:\nDefinition 7. Any tertiary relation \u00f0\u0007? \u0007\u00dej \u0007 satisfying the\nfollowing three properties:\n1: \u00f0W?X\u00dejX [ Y ; \u00f01\u00de\n2: \u00f0W?X\u00dejY if and only if \u00f0X?W \u00dejY ; \u00f02\u00de\n3: \u00f0W?X [ Y \u00dejZ if and only if \u00f0W? Y \u00dejZ;\u00f0W?X\u00dejY [ Z;\n\u0001\n\u00f03\u00de\nfor any collections W , X, Y , Z of uncertain quantities is\ntermed a generalized conditional independence (g.c.i.) prop-\nerty. \u00f0W?X\u00dejY is read as \u201cW is independent of X given Y .\u201d\nEquation (1) is that \u201conce X is known (along with\nanything else Y ), then no further information can be gained\nabout X by observing W .\u201d Equation (2) is the symmetry\nrelation: \u201cIf once Y is known, W is uninformative for X,\nthen X is uninformative for W , having observed Y .\u201d\nEquation (3) is \u201cif having observed Z, W is uninformative\nfor both X and Y , then equivalently, having observed Z, W\nis uninformative about Y and, having observed Y and Z,W\nconveys no information about X.\u201dW?X is a shorthand for\n\u00f0W?X\u00dej;, where ; is the empty set.\nThe most familiar g.c.i. property is when the collections\nrepresent random quantities and \u00f0\u0007? \u0007\u00dej \u0007 is taken to be\nprobabilistic conditional independence. For random vectors\nX, Y , Z, we say that X is probabilistically conditionally\nindependent of Y given Z, written \u00f0X? Y \u00dejZ, if p\u00f0x; yjz\u00de \u00bc\np\u00f0xjz\u00dep\u00f0yjz\u00de, or equivalently if p\u00f0xjy; z\u00de \u00bc p\u00f0xjz\u00de, where p\u00f0\u0007\u00de\ndenotes the probability density function; if Z \u00bc ;, then we\nsay that X and Y are probabilistically independent. Dawid\n[14], [15] developed probabilistic conditional independence\nas a basic intuitive concept with its own axioms. The work\nof Smith is a generalization of this to other inference\nsystems which do not require full probability specifications.\nFor example, Goldstein [16] constructs a tertiary property\nsatisfying properties (1), (2), and (3) based on the partial\nquantitative specification of beliefs. Smith [25] writes that\n\u201cin a Bayesian statistical or decision analysis it is common\nto be told that, given certain information W , a variable X\nwill have no bearing on another Y . It is often quite easy to\nascertain this type of information from a client for various\ncombinations of variables. Such information can be gath-\nered before it is necessary to quantify subjective probabil-\nities which, in contrast, are often very difficult to elicit with\nany degree of accuracy.\u201d Pearl [24] agrees, arguing that \u201cthe\nnotions of relevance and dependence are far more basic to\nhuman reasoning than the numerical values attached to\nprobability judgements.\u201d By asserting properties (1), (2),\nand (3), the g.c.i. relation may be applied qualitatively\nwithout the need for explicit numerical specifications. The\neasiest way to do this is to represent the g.c.i. relation\ngraphically using a directed graph as we now explain.\n3.3 Belief Separation via the Moral Graph\nA collection of g.c.i. relations may be represented graphi-\ncally. The vertices of the graph are random quantities;\nvertices are joined by directed arrows if there is a possible\ndirect dependency between them.\nDefinition 8. A DAG, G \u00bc \u00f0V ;E\u00de, is a directed graphical model\n(DGM) if, for any Xi 2 V and any Xj =2 deG\u00f0Xi\u00de, the\ndescendents of Xi on G, we have\n\u00f0Xi?Xj\u00dejpaG\u00f0Xi\u00de; \u00f04\u00de\nwhere \u00f0\u0007? \u0007\u00dej \u0007 is a g.c.i. property and paG\u00f0Xi\u00de denotes the set\nof parents of Xi on G.\nThere are a number of equivalent definitions of a DGM,\nfor example, see Theorem 5.14 of [13]. The most familiar\ntype of DGM, the Bayesian graphical model (BGM), occurs\nwhen \u00f0\u0007? \u0007\u00dej \u0007 represents probabilistic conditional indepen-\ndence. [29] introduces BGMs into the problem of software\ntesting, while [1] show how fault trees can be mapped into\nBGMs.\nDefinition 8 shows that a DGM may be formed by the\nexplicit statement of the parent sets for each vertex.\nHowever, the given g.c.i. statements are not the sole g.c.i.\nstatements in the model because we may use properties (1),\n(2), and (3) to determine further g.c.i. statements. Indeed, to\nfully understand the g.c.i. structure of the model, we would\nlike to be able to ask whether, for any three subsets W1, W2,\nW3 \u0004 V on the DGM, we have \u00f0W1?W2\u00dejW3. The answer\nlies by linking g.c.i. with graph separation on an associated\nundirected graph; graph separation satisfies properties (1),\n(2), and (3) (see Pearl [24, Section 3.1]) and so itself acts as a\ng.c.i. property. The required graph is the moral graph\nassociated with W1, W2, W3 as introduced by Lauritzen and\nSpiegelhalter [22].\nDefinition 9. For the DAG G \u00bc \u00f0V ;E\u00de and any three subsets\nW1, W2, W3 \u0004 V , the moral graph associated with W1, W2,\nSHAW ET AL.: MORAL DOMINANCE RELATIONS FOR PROGRAM COMPREHENSION 857\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\nW3 is the undirected graph GM\u00f0[3i\u00bc1Wi\u00de \u00bc \u00f0VM\u00f0[3i\u00bc1Wi\u00de,\nEM\u00f0[3i\u00bc1Wi\u00de\u00de, where\nVM\u00f0[3i\u00bc1Wi\u00de \u00bc [3i\u00bc1fWi [ anG\u00f0Wi\u00deg;\nEM\u00f0[3i\u00bc1Wi\u00de \u00bc fff \u0002 g8f; g 2 VM\u00f0[3i\u00bc1Wi\u00de : \u00f0f; g\u00de 2 Eg\n[ ff \u0002 h8f; g; h 2 VM\u00f0[3i\u00bc1Wi\u00de : f\u00f0f; g\u00de; \u00f0h; g\u00deg\n\u0004 E ^ \u00f0f; h\u00de; \u00f0h; f\u00de =2 Egg;\nand anG\u00f0Wi\u00de denotes the collection of ancestors of Wi on G. If\nVM\u00f0[3i\u00bc1Wi\u00de \u00bc V , then we write GM\u00f0[3i\u00bc1Wi\u00de \u00bc GM and term\nthis the full moral graph.\nLess formally, we construct the subgraph of G whose\nvertices are W1, W2, W3 and all of their ancestors. For each\nindividual vertex of the subgraph, we \u201cmarry\u201d all of its\nparents (join them with an edge if not already joined) and\nthen drop all arrows to form the moral graph GM\u00f0[3i\u00bc1Wi\u00de.\nSince all the parents are \u201cmarried,\u201d Lauritzen and Spiegel-\nhalter [22] coined the term moral graph. The following\ntheorem, see [21], [27], shows that it is straightforward to\nuse GM\u00f0[3i\u00bc1Wi\u00de to determine whether \u00f0W1?W2\u00dejW3 on G.\nTheorem 1. For any three subsets W1, W2, W3 \u0004 V on a DGM,\nG \u00bc \u00f0V ;E\u00de, we have \u00f0W1?W2\u00dejW3 wheneverW1 andW2 are\nseparated by W3 on GM\u00f0[3i\u00bc1Wi\u00de, the moral graph associated\nwith W1, W2, W3.\nTheorem 1 is often termed the moralization criterion. An\nalternative process to establish whether any three subsets\nW1, W2, W3 satisfy \u00f0W1?W2\u00dejW3 on a DGM, using the\nconcept of d-separation on the original DGM, was devel-\noped by Pearl [24]. Lauritzen et al. [21] shows this approach\nis equivalent to Theorem 1. The aim of Pearl [24, p. 81] as to\n\u201cwhether assertions equivalent to those made about\nprobabilistic dependencies can be derived logically without\nreference to numerical quantities,\u201d may be met using\nTheorem 1. If W1 and W2 are separated by W3 on\nGM\u00f0[3i\u00bc1Wi\u00de, then they are separated by any g.c.i. property\nthat quantifies the network, for example, probabilistic\nconditional independence. For a collection of quantities of\ninterest, V , we may assert a DGM over V and identify the\nindependence structure of the model via Theorem 1. If we\nthen wish to specify a full probability distribution over V ,\nany distribution satisfying (4) will have the same indepen-\ndence structure irrespective of the actual numerical speci-\nfications. Such distributions are easy to find: If (4) is to hold,\nthen the joint distribution over all the random quantities in\nV has the form p\u00f0x1; . . . ; xn\u00de \u00bc\nQn\ni\u00bc1 p\u00f0xijpaG\u00f0xi\u00de\u00de (see, for\nexample, Jensen [19, p. 20]).\n3.4 Using the Call Graph to Create a DGM\nIn this section, we shall argue that the error propagation\ngraph, see Definition 6, may be viewed as a DGM. First, we\nremark that the call graph, with the procedures viewed as\nthe random quantities expressing whether the procedure\nworks or not, does not constitute a DGM. Consider the call\ngraph with vertices f , g, h and edges \u00f0f; g\u00de and \u00f0f; h\u00de.\nSuppose that f is known not to be working. This could have\nresulted from an error propagating from either g or h or\nfrom an error in f itself. If we now learn that g works, then\nthis will increase the belief that h is in error; procedures g\nand h are dependent given f . This violates property (4)\nwhich requires \u00f0g? h\u00dejf .\nWe now argue that property (4) is met on the error\npropagation graph. We consider vertices g; h 2 VC and show\nthat \u00f0g? h\u00dejpa~GC \u00f0g\u00de whenever h =2 de~GC \u00f0g\u00de. From (1), this is\nimmediate if h 2 pa~GC \u00f0g\u00de. Consider h 2 an~GC \u00f0g\u00de n pa~GC \u00f0g\u00de. h\nand g are dependent: An error in h can propagate from h to\ng. Any path h 7! g on ~GC must intersect some ~g 2 pa~GC \u00f0g\u00de. If\nthe state of each ~g is known, then knowledge of the state of h\nis uninformative for g. For example, if each ~g is observed to\nwork and we now observe that h is in error, then this gives\nus no new information: We already know from the state of ~g\nthat the error does not propagate to pa~GC \u00f0g\u00de and, hence,\ncannot propagate to g.\nWe now restrict h to the collection VC n ffgg [ an~GC \u00f0g\u00de [\nde~GC \u00f0g\u00deg and let A \u00bc an~GC \u00f0g\u00de \\ an~GC \u00f0h\u00de. If A \u00bc ;, then g and\nh are independent. For example, learning that h does not\nwork increases our belief that errors are contained in\nan~GC \u00f0h\u00de, but errors in an~GC \u00f0h\u00de cannot propagate to g. Note\nthat, letting B \u00bc de~GC \u00f0g\u00de \\ de~GC \u00f0h\u00de, we may have B 6\u00bc ;.\nConsider some ~g 2 B. Learning about h is informative about\n~g, but this does not influence g as although a potential error\nin h could result in ~g calling g with the wrong input, or with\nthe wrong database configuration, all that is relevant is\nwhether g copes with these correctly. If pa~GC \u00f0g\u00de is now\nknown, g and h remain independent since, as A \u00bc ;,\nan~GC \u00f0pa~GC \u00f0g\u00de\u00de \\ an~GC \u00f0h\u00de \u00bc ;.\nIf A 6\u00bc ;, then g and h are dependent. For example, if we\nlearn that h does not work, then this error could have\npropagated from procedures contained in A, increasing our\nbelief for the procedures in A not working. Errors in A may\nalso propagate to g increasing our belief in g not working.\nThe dependence is via the collection A \u0004 an~GC \u00f0g\u00de. Arguing\nsimilarly to when g 2 an~GC \u00f0g\u00de shows that, if pa~GC \u00f0g\u00de is\nknown, information about A is irrelevant to g and tracing\nthe passage of knowledge from h to g we see that\nknowledge about h is now irrelevant to g. This discussion\nis summarized as follows:\nLemma 1. The error propagation graph ~GC \u00bc \u00f0VC;ER\u00de is a\nDGM. If G, H, F are three sets of procedures on G and F\nseparates G from H on ~GM\u00f0G;H; F \u00de, then \u00f0G?H\u00dejF .\nWe term ~GM\u00f0G;H; F \u00de the associated moral graph to the\ncall graph for collections G;H; F . For the call graph in\nFig. 1a, the associated moral graph ~GM\u00f0VC nA000\u00de is\nobtained by deleting A000 and the three calls it makes in\nFig. 1a, adding the edges B100 \u0002 B200 (as they are\nunmarried parents of B000 on the error propagation graph)\nand C100 \u0002 C200 and then dropping all arrows. As was\nintimated in Section 2.1, B\u0005 [ C\u0005 are separated from D\u0005 by\nthe empty set and, so, B\u0005 [ C\u0005?D\u0005. We now explore the\ng.c.i. properties of the error propagation graph to strength-\nen our analysis of the dominance tree.\n858 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 29, NO. 9, SEPTEMBER 2003\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\n4 PROGRAM COMPREHENSION USING\nTHE g.c.i. RELATION\n4.1 Strongly Directly Dominated Subtrees:\n\u201cSingle Call In\u201d\nIn Section 2, we reviewed current practice in using the\ndominance tree to select potential reuse candidates. \u201cSingle\nCall In\u201d subtrees, that is, subtrees whose root was strongly\ndirectly dominated, have been identified as possible sites of\nremodularization. In this section, we formalize the relation-\nship between \u201csingle call in\u201d subtrees which share a\ncommon strongly direct dominator. This enables us to\nstrengthen the argument for the adoption of the reuse\ncandidates, while also helping to explain the relationship of\nthe candidates with the directly dominated vertices. The\napproach utilizes the g.c.i. relation discussed in Section 3.\nWe have the following theorem; the proof is in the\nAppendix.\nTheorem 2. Suppose GC \u00bc \u00f0VC;EC\u00de is a call graph and consider\nany collection of vertices h1; h2; . . . ; hm with the property that,\nfor any hi 6\u00bc hj, there is no direct path between hi and hj\non GC . Let H \u00bc [lk\u00bc1fdeC\u00f0hi\u00de \\ deC\u00f0hjk\u00deg. For any i 2\nf1; . . . ;mg and any 1 \b l \b m, 1 \b j1 \b j2 \b \u0007 \u0007 \u0007 \b jl \b m,\njk 6\u00bc i, with h\u0005 \u00bc fhg [ deC\u00f0h\u00de for any h 2 VC ,\n\u00f0h\u0005i? [lk\u00bc1 h\u0005jk\u00dejH: \u00f05\u00de\nIf two vertices are both strongly directly dominated by\nthe same vertex on a dominance tree, then there is no path\nbetween them on a call graph. Moreover, with h\u0006 \u00bc\nfhg [ deDf \u00f0h\u00de, h\u0006 \u0004 h\u0005 and, so, we may link Theorem 2 to\nthe reuse candidates generated by the \u201csingle call in\u201d\nsubtrees on a dominance tree GDf via the following\ncorollary.\nCorollary 1. Suppose GC \u00bc \u00f0VC;EC\u00de is a call graph and f is a\nroot node of GC . Additionally, consider a vertex g on GDf which\nstrongly directly dominates the vertices h1; . . .hm on GCf . Let\nH \u00bc [lk\u00bc1fdeC\u00f0hi\u00de \\ deC\u00f0hjk\u00deg. For any i 2 f1; . . . ;mg and\nany 1 \b l \b m, 1 \b j1 \b j2 \b \u0007 \u0007 \u0007 \b jl \b m, jk 6\u00bc i, with\nh\u0006 \u00bc fhg [ deDf \u00f0h\u00de for any h 2 VDf ,\n\u00f0h\u0006i? [lk\u00bc1 h\u0006jk\u00dejH: \u00f06\u00de\nProof. Since h\u0006i n hi forms the set of vertices dominated by hi\non GDf , then fh\u0006i n hig \u0004 deC\u00f0hi\u00de. The reduction of the sets\nh\u0005i to h\n\u0006\ni follows by the g.c.i. property (3). tu\nCorollary 1 thus provides us with the relationship\nbetween \u201csingle call in\u201d subtrees whose roots share the\nsame parent on the dominance tree. The subtrees are\nindependent if they do not share any descendents on the\ncall graph, so that H \u00bc ;, and conditionally independent if\nthey do share descendents, that is H 6\u00bc ;. These shared\ndescendents are thus present in \u201cmultiple calls in\u201d\nsubtrees on the dominance tree and, so, provide a\nconnection between \u201csingle call in\u201d and \u201cmultiple calls\nin\u201d subtrees. Consider the dominance tree in Fig. 1c and\nthe \u201csingle call in\u201d subtrees C000\u0006 and D000\u0006. In the call\ngraph in Fig. 1a, C000 and D000 do not share descendents\nand so, from Corollary 1, we have C000\u0006?D000\u0006. How-\never, for the call graph in Fig. 1b, C000 and D000 do share\ndescendents: B000\u0005. In this case, applying Corollary 1\nyields \u00f0C000\u0006?D000\u0006\u00dejB000\u0005. The difference in these two\nstatements illustrates an advantage of the g.c.i. relation\nover the dominance relation and helps explain why we can\ncapture the relationship between subtrees on the dom-\ninance tree. The dominance relation is only concerned with\ncalls to a procedure while the g.c.i. relation also takes\naccount of calls made by a procedure. This difference is\ncrucial if one wishes to examine ripple effects as Figs. 1a\nand 1b illustrate.\n4.2 Relations around \u201cIsolated\u201d Subtrees\nTheorem 2 and, thus, Corollary 1 stress the importance of\nshared descendents of \u201csingle call in\u201d subtrees. For the\ncall graph in Fig. 1a, since C000\u0005 \u00bc B000\u0005 [ C000\u0006 and\nD000\u0005 \u00bc D000\u0006, then, from Theorem 2, B000\u0005 [ C000\u0006?\nD000\u0006. In this case, D000 dominates all of its descendents\nand, hence, does not call any other subtree on the\ndominance tree.\nIf, for any hu 2 VDf , we have deC\u00f0hu\u00de \u00bc deDf \u00f0hu\u00de, then the\nsubtree h\u0006u \u00bc h\u0005u does not call any other subtree on GDf . We\nintroduce the term \u201cisolated\u201d subtree to describe h\u0006u. In\nterms of the call graph, this means that, once hu has been\ncalled, execution remains solely in the subtree h\u0006u until hu is\nexited. This suggests that we may wish to consider this\nsubtree as a single unit. Notice that this may include\nsubtrees where multiple procedures call the root hu. We\nshall term subtrees that make calls to other subtrees on the\ndominance tree \u201cnonisolated\u201d subtrees. We have the\nfollowing theorem; the proof is in the Appendix.\nTheorem 3. Suppose that GC \u00bc \u00f0VC;EC\u00de is a call graph and\nhu 2 VC is such that deC\u00f0hu\u00de \u00bc deDf \u00f0hu\u00de for some dominance\ntree GDf \u00bc \u00f0VDf ; EDf \u00de. If g1; . . . ; gm are any collection of\nvertices on GDf with the property that, for each i, there is no\ndirect path between each gi and hu on G, then\nh\u0006u? [mi\u00bc1 g\u0005i : \u00f07\u00de\nIf fg1; . . . ; gmg\u0004fanC\u00f0hu\u00de\\VDfg, withGynhyu\u00bc [mi\u00bc1g\u0005i\n\u0002 \u0003nh\u0006u,\nthen\n\u00f0deDf \u00f0hu\u00de? Gy n hyu\n\u0002 \u0003\u00dejhu: \u00f08\u00de\nTheorem 3 shows us that \u201cisolated\u201d subtrees are either\nindependent or conditionally independent of the other\nvertices on the call graph. It is irrelevant whether the root of\nthe \u201cisolated\u201d subtree is strongly directly or just directly\ndominated on the dominance tree. Note that, on the\ndominance tree in Fig. 1c, B000\u0006 \u00bc B000\u0005 for both the call\ngraph in Fig. 1a and that in Fig. 1b. For Fig. 1a, we have that\nD000\u0006 \u00bc D000\u0005 and, so, from relation (7), B000\u0006?D000\u0006.\nC000 is an ancestor of B000 on the call graph and, from\nrelation (8), we find that \u00f0fB100; B200g ? C000\u0006\u00dejB000.\nOn the call graph in Fig. 1b, both C000 and D000 are\nancestors of B000 and, so, from relation (8), we find that\n\u00f0fB100; B200g? C000\u0006 [D000\u0006\u00dejB000.\nSHAW ET AL.: MORAL DOMINANCE RELATIONS FOR PROGRAM COMPREHENSION 859\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\nAssessing whether deDf \u00f0hu\u00de \u00bc deC\u00f0hu\u00de is simple; identi-\nfying these subtrees on the dominance tree enables it to\nprovide more information about the calling structure\nwithout altering its layout. First, there will be a reduction\nin the number of call graphs that can produce a given\ndominance tree, while, second, there will be an added\nability of the dominance tree to represent more detailed\ninformation. For example, a \u201csingle call in\u201d \u201cisolated\u201d\nsubtree is independent of its neighboring subtrees.\n4.3 Modifying the Dominance Tree to Highlight\n\u201cIsolated\u201d Subtrees: The Moral Dominance Tree\nThe shading of vertices on the dominance tree enables us to\nidentify easily \u201csingle call in\u201d and \u201cmultiple calls in\u201d\nsubtrees. The shading also shows where parental loss has\noccurred in the abstraction of the calling structure from call\ngraph to dominance tree. Strongly directly vertices have the\nsame, unique parent on both graphs while the directly\ndominated vertices had at least two parents on the call\ngraph of which at most one can be a parent on the\ndominance tree. We may modify the shading to indicate\nwhether directly dominated vertices are dominated by one\nof their parents from the call graph or by an ancestor.\nWithout altering the layout of the tree, so that Corollary 1\nremains applicable, such a modification provides more\ninformation about the calling structure.\nTheorem 3 shows the importance of \u201cisolated\u201d or\n\u201cnonisolated\u201d subtrees when determining the relationships\nbetween subtrees on the dominance tree; such subtrees are\nnot highlighted on the dominance tree but may be formally\nidentified by determining whether, for each h 2 VDf ,\ndeDf \u00f0h\u00de \u00bc deC\u00f0h\u00de. Thus, if h 2 VDf is the root of a \u201cnon-\nisolated\u201d subtree, then the abstraction of the call graph\nresults in h losing some of its descendents: deDf \u00f0h\u00de \t deC\u00f0h\u00de.\nIn an analogous way to using vertex shading to highlight\nloss of parents in the abstraction, we may use differing\nvertex shapes on the dominance tree to represent those\nvertices for which chC\u00f0h\u00de 6\u0004 chDf \u00f0h\u00de, chC\u00f0h\u00de \u0004 chDf \u00f0h\u00de only,\nor deC\u00f0h\u00de \u00bc deDf \u00f0h\u00de. We propose modifying the dominance\ntree into the moral dominance tree.\nDefinition 10. The moral dominance tree corresponding to a root\nnode, f , is the graph GDf\u00bc\u00f0f\u0005;EDf\u00de formed from GCf\u00bc\u00f0f\u0005;ECf\u00de,\nthe subgraph of the call graph GC \u00bc \u00f0VC;EC\u00de, where\nf\u0005 \u00bc ffg [ deC\u00f0f\u00de. For any two vertices g, h 2 f\u0005, \u00f0g; h\u00de 2\nEDf if g directly dominates h on GCf . If g strongly directly\ndominates h on GCf , then the vertex h is unshaded and h is\nshaded if g only directly dominates it. Two shadings are used to\ndistinguish vertices directly dominated by one of their parents\non GCf and those directly dominated by a nonparent. If\ndeC\u00f0h\u00de \u00bc deDf \u00f0h\u00de, then the vertex is a rectangular box with\nrounded corners. If only chC\u00f0h\u00de \u0004 chDf \u00f0h\u00de, then the vertex is\nan ellipse. If neither of these occur, then the vertex is a\nrectangular box.\nThe moral dominance tree has the same layout as the\ndominance tree, see Definition 3; it differs in the shape\nand shading of the vertices. Figs. 1d and 1e show the\nrespective moral dominance trees for the call graphs in\nFigs. 1a and 1b. Notice that, unlike the corresponding\ndominance tree (Fig. 1c), the two call graphs lead to\ndifferent moral dominance trees. In Fig. 1d, D000\u0006 is an\n\u201cisolated\u201d subtree: D000 is unshaded and is a rectangular\nbox with rounded corners. We immediately deduce that\nD000\u0006?B000\u0006 [ C000\u0006. However, in Fig. 1e, D000\u0006 is not\nan \u201cisolated\u201d subtree: It makes calls to other subtrees. As\nD000 appears in an ellipse, we infer that these calls are\nmade by procedures in deDf \u00f0D000\u00de and not by D000. The\ndiffering vertex shapes introduce more of the calling\nstructure into the visual summary without destroying the\ntree representation. The same is true with the vertex\nshadings which help illustrate how \u201cmultiple calls in\u201d\nsubtrees are accessed by \u201cnonisolated\u201d subtrees: Compare\nthe shading of B000 in Figs. 1d and 1e.\nThe results of Sections 4.1 and 4.2 provide a formal\nrelationship between different types of subtrees on the\ndominance tree. The dominance relation identifies \u201csingle\ncall in\u201d subtrees which are either independent or condi-\ntionally independent to adjoining \u201csingle call in\u201d subtrees\ndependent upon whether they share descendents (present\nin \u201cmultiple calls in\u201d subtrees). We modify the vertex\nshading to illustrate whether the parent of the root of a\n\u201cmultiple calls in\u201d subtree is also a parent on the call graph.\nTheorem 3 shows that we should also consider whether\nsubtrees \u201ccall out\u201d to other subtrees on the dominance tree;\nwe add this information to the graphic using differing\nvertex shapes.\n4.4 Additional Benefits of the g.c.i. Relation\nThe problem of multiple root nodes. The power of the g.c.i.\nrelation is that it can be used to assess the relationship\nbetween any collections of vertices by constructing the\ncorresponding moral graph. It can, for example, determine\nthe relationship between different root nodes of a call\ngraph, a facet that the dominance relation is unable to do.\nRelationships obtained from the moral graph are valid for\nthe entire graphical model. Contrast this to the dominance\nrelation for call graphs with multiple root nodes. Here,\nmultiple dominance trees are constructed and procedures\nmay appear on many dominance trees. Relationships\nobtained on one dominance tree may not hold on the call\ngraph; procedures can be strongly dominated on one tree\nand only directly dominated on another, they may have\ndifferent direct dominators on different dominance trees.\nFailure to capture potential reuse candidates. In Fig. 2b,\nC001 and D001 are the only \u201csingle call in\u201d subtrees\ndominated by A000 and Theorem 2 may be used to deduce\nthat \u00f0C\u0005?D\u0005\u00dejB\u0005. The moral dominance tree does not alter\nthe shape of the dominance tree and the conditional\nindependence of C\u0005 and D\u0005 is thus not apparent on the\nmoral dominance tree corresponding to Fig. 2a. We now\nexplore whether we can modify the call graph to better\ncapture its structure on the moral dominance tree.\nConsider the collection of vertices fA000, D001, D000g.\nEach pair of vertices in the collection are joined by an edge.\nIf we try to add any other vertex to the collection, then this\nis no longer the case. For example, if we add D200, then we\nhave A000 6\u0002 D200. The collection fA000; D001; D000g is\n860 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 29, NO. 9, SEPTEMBER 2003\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\ntermed a clique. To quote Whittaker [28, p. 59], \u201ca graph or\nsubgraph is complete if all vertices are joined with either\ndirected or undirected edges. A clique is a subset of\nvertices which induce a complete subgraph but for which\nthe addition of a further vertex renders the induced\nsubgraph incomplete.\u201d Cliques are central to the study of\nconditional independencies because any vertex in a clique\non the moral graph is dependent upon all of the other\nvertices in the clique. Suppose that the graph G \u00bc \u00f0V ;E\u00de is\na DAG and the collection G \u0004 V forms a clique on G. There\nis a unique g 2 G such that \u00f0g; h\u00de 2 E for all h 2 Gy, where\nGy \u00bc G n fgg. We term g the clique-parent of G. For\nexample, in the clique fA000; D001; D000g on the call\ngraph in Fig. 2a, the clique-parent is A000. Note that any\nclique on the call graph is also a clique on the error\npropagation graph. The dominance relation may struggle\nwith a clique on a call graph because of the dependence\nwithin the clique. A natural extension of the dominance\nrelation is to seek the collection of vertices, H, for which,\nfor all h 2 H, Gy is an \u00f0f; g\u00de-separator, where f is a root\nnode on the call graph. If G comprises of just two vertices,\nthen Gy is a single vertex, gy say, and H comprises the set\nof procedures gy dominates on GDf . This provides a formal\nway of extending the separator set from a single vertex to a\ncollection of vertices. Indeed, in a similar way to how\ncycles are collapsed on the call graph, we may consider\nrecursively collapsing all cliques on the call graph to just\ntwo vertices: g and Gy before creating the dominance tree.\nTo illustrate this, consider the call graph in Fig. 2a. We\nexamine cliques with at least three vertices. There are\ntwo such cliques which have A000 as a clique-parent:\nfA000; C001; C000g and fA000; D001; D000g. We merge\nC001 and C000 into a single vertex fC001; C000g whose\nchildren are the combined children of C001 and C000. We\nsimilarly merge D001 and D000 together; the merged\nvertex having as children the union of the children of D001\nand D000. On the resultant call graph, fD001; D000g is the\nclique-parent of the clique ffD001; D000g; D100; D200g\nand, so, D100, D200 may be merged to a single vertex. All\nother cliques on the call graph contain just two vertices.\nThe modified call graph and moral dominance tree are\nshown in Fig. 2c and Fig. 2d respectively. Notice that there\nare only two out of 11 shaded vertices in Fig. 2d compared\nwith the seven out of 14 in Fig. 2b which, intuitively,\nsuggests the usefulness of Fig. 2d over Fig. 2b for program\ncomprehension of the original call graph, Fig. 2a. The\nmerging of the vertices in Fig. 2c enables the dominance\nrelation to obtain the three subsets B\u0005, C\u0005, D\u0005 discussed in\nSection 2.4. The subtrees C\u0005 and D\u0005 have a different shape\non Fig. 2d reflecting the g.c.i. property \u00f0C100? C200\u00dejC110,\nwhereas D100 and D200 are dependent. This contrasts with\nthe scenario in Fig. 2b. The similarity in structure between\nFigs. 1b and 2a is now apparent. Indeed, removing the\ncliques in Fig. 1b results in merging the vertices D100 and\nD200 so that the resultant call graph has the same shape as\nthat in Fig. 2c.\n5 CONCLUSION\nDominance tree analysis may be used to identify subtrees\nwhich may be considered as potential reuse candidates. The\nsubtrees considered are those we termed \u201csingle call in\u201d\nsubtrees. The dominance tree does not explain the relation\nbetween \u201csingle call in\u201d subtrees and vertices who are only\ndirectly dominated.\nTo address this, we introduce a g.c.i. relation over the\ncall graph. This supports the argument for the potential\nreuse candidates obtained from the dominance tree by\nidentifying \u201csingle call in\u201d subtrees as being either\nindependent or conditionally independent of other \u201csingle\ncall in\u201d subtrees. The conditional independence occurred\nwhen \u201csingle call in\u201d subtrees made calls to the same\n\u201cmultiple call in\u201d subtrees. The \u201cmultiple call in\u201d subtrees\nhave a root which is only directly dominated and, so, the\nconditional independence relation not only supports the\ndominance tree analysis, but strengthens it by explaining\nthe relationship between the strongly directly and directly\ndominated vertices.\nWe argue that it is not just \u201csingle call in\u201d subtrees that\nshould be highlighted as potential reuse candidates, but\nalso \u201cisolated\u201d subtrees, subtrees which make no calls to\nany other subtree on the dominance tree. As such, we\npropose modifying the dominance tree to the moral\ndominance tree which provides a greater understanding\nof the relationships between individual branches and also\nhighlights areas where further investigation, in particular,\nthe \u201cnonisolated\u201d \u201cmultiple calls in\u201d subtrees, using the\ng.c.i. relation is required.\nThe g.c.i. relation is a tool for investigating any\ncollection of vertices. It provides a formal theoretical\nframework for the previous heuristic approach, thus\nenhancing the argument for the adoption of potential\nreuse candidates and developing a formal relationship\nbetween the candidates. Additionally, we are able to\nunderstand collections where the dominance relation\nexhibited a lack of understanding. We also considered\nhow the dominance relation could be improved so that it\ncould handle cliques. Combining the dominance tree\nanalysis with the g.c.i. relation provides us with a more\ndetailed understanding of the relationships within the\ncalling structure and, thus, our level of comprehension.\nAPPENDIX\nPROOFS OF THEOREMS\nProof of Theorem 2. Note that for any h 2 VC , h\u0005 is also\nthe collection of h and its ancestors on the error\npropagation graph. From Lemma 1, to show (5), we\nconstruct the associated moral graph ~GM\u00f0h\u0005 [H\u0005\u00de,\nwhere H\u0005 \u00bc [lk\u00bc1h\u0005jk and consider separations on this\ngraph. Notice that VM\u00f0h\u0005i [H\u0005\u00de \u00bc h\u0005i [H\u0005. Let A \u00bc\n[lk\u00bc1fdeC\u00f0hi\u00de \\ deC\u00f0hjk\u00deg, B \u00bc [lk\u00bc1fdeC\u00f0hi\u00de \\ decC\u00f0hjk\u00deg,\nand C \u00bc [lk\u00bc1fdecC\u00f0hi\u00de \\ deC\u00f0hjk\u00deg; A, B, and C are\nmutually incompatible.\nIf A \u00bc ;, then the subgraphs h\u0005i and H\u0005 are uncon-\nnected on GC and, thus, on ~GC . If they are connected on\nSHAW ET AL.: MORAL DOMINANCE RELATIONS FOR PROGRAM COMPREHENSION 861\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\n~GM\u00f0h\u0005i [H\u0005\u00de, the path must have been formed by the\nmarriage of some hi1 2 deC\u00f0hi\u00de and some h\u00051 2 [lk\u00bc1\ndeC\u00f0hjk\u00de. Since A\u00bc;, deC\u00f0hi\u00de\u00bcB, and [lk\u00bc1deC\u00f0hjk\u00de \u00bc C.\nIf A 6\u00bc ;, then the subgraphs h\u00051 and H\u0005 are connected\non GC and, thus, on ~GC . The connecting vertices are A.\nThere is no arc between any hi1 2 B and any h\u00051 2 C\n(and vice versa). Any path between B and C which does\nnot pass through an element of A must evolve through\nthe marriage of some hi1 2 B and some h\u00051 2 C.\nIn either case, we require the addition of an arc\nbetween some hi1 2 B and some h\u00051 2 C. This will occur,\nsee Definition 9, if there exists h2 2 h\u0005i [H\u0005 such that\nf\u00f0hi1; h2\u00de; \u00f0h\u00051; h2\u00deg \u0004 ER or, equivalently, f\u00f0h2; hi1\u00de;\n\u00f0h2; h\u00051\u00deg \u0004 EC . If h2 2 A, then fhi1; h\u00051g \t A: a contra-\ndiction. If h2 2 h\u0005i nA, then h\u00051 2 deC\u00f0hi\u00de: a contradiction.\nIf h2 2 H\u0005 nA, then hi1 2 [lk\u00bc1deC\u00f0hjk\u00de: a contradiction.\nThus, there is no such h2 2 h\u0005i [H\u0005 and the results\nfollow. tu\nProof of Theorem 3. Once more, for any h 2 V , we let\nh\u0005 \u00bc h [ deC\u00f0h\u00de. Let G\u0005 \u00bc [mi\u00bc1g\u0005i . From Lemma 1, we\nneed to consider separations on ~GM\u00f0h\u0005u [G\u0005\u00de. Notice that\nVM\u00f0h\u0005u [G\u0005\u00de \u00bc h\u0005u [G\u0005. Since deC\u00f0hu\u00de \u00bc deDf \u00f0hu\u00de, then\nthe only calls from VDf n h\u0005u to h\u0005u on GC are to hu only.\nIf there is no direct path between each gi and hu, then\neach gi 2 VDf n h\u0005u and hu =2 deC\u00f0gi\u00de. Thus, g\u0005i \\ h\u0005u \u00bc ; and\nthe subgraphs h\u0005u and G\n\u0005 are unconnected on GC and,\nthus, on ~GC . For them to be connected on ~GM\u00f0h\u0005u [G\u0005\u00de,\nthe path must have been formed by the marriage of some\nhu1 2 h\u0005u and some g\u00051 2 G\u0005. We may show this cannot\noccur in an identical way to the proof of Theorem 2.\nProperty (7) thus follows.\nProperty (8) also follows by observing that, if each\ngi 2 anC \\ VDf , then the subgraphs h\u0005u and G\u0005 are\nunconnected on GC , but only at hu. Following the proof\nof Theorem 2, we show that there can be no marriage\nbetween some hu1 2 h\u0005u and some g\u00051 2 H\u0005 n h\u0005u. tu\nACKNOWLEDGMENTS\nThis work was supported by grant GR\\M76775 from the\nUK Engineering and Physical Sciences Research Council.\nREFERENCES\n[1] A. Bobbio, L. Portinale, M. Minichino, and E. Ciancamerla,\n\u201cImproving the Analysis of Dependable Systems by Mapping\nFault Trees into Bayesian Networks,\u201d Reliability Eng. and System\nSafety, vol. 71, no. 3, pp. 249-260, 2001.\n[2] E. Burd and M. Munro, \u201cEnriching Program Comprehension for\nSoftware Reuse,\u201d Proc. Fifth Int\u2019l Workshop Program Comprehension,\npp. 130-137, 1997.\n[3] E. Burd and M. Munro, \u201cA Method for the Identification of\nReusable Units through the Reengineering of Legacy Code,\u201d\nJ. Systems and Software, vol. 44, no. 2, pp. 121-134, 1998.\n[4] E. Burd and M. Munro, \u201cEvaluating the Use of Dominance Trees\nfor C and COBOL,\u201d Proc. 1999 Int\u2019l Conf. Software Maintenance,\npp. 401-410, 1999.\n[5] E. Burd and M. Munro, \u201cSupporting Program Comprehension\nUsing Dominance Trees,\u201d Annals Software Eng., vol. 9, pp. 193-213,\n2000.\n[6] E. Burd, M. Munro, and C. Wezeman, \u201cAnalysing Large COBOL\nPrograms: The Extraction of Reusable Modules,\u201d Proc. 1996 Int\u2019l\nConf. Software Maintenance, pp. 238-243, 1996.\n[7] E. Burd, M. Munro, and C. Wezeman, \u201cExtracting Reusable\nModules from Legacy Code: Considering Issues of Module\nGranularity,\u201d Proc. Third Working Conf. Reverse Eng., pp. 189-197,\n1996.\n[8] G. Canfora, A. Cimitile, A. De Lucia, and G.A. Di Lucca,\n\u201cDecomposing Legacy Systems into Objects: An Eclectic Ap-\nproach,\u201d Information and Software Technology, vol. 43, no. 6, pp. 401-\n412, 2001.\n[9] G. Canfora, A. De Lucia, G.A. Di Lucca, and A.R. Fasolino,\n\u201cRecovering the Architectural Design for Software Comprehen-\nsion,\u201d Proc. Third Workshop Program Comprehension (WPC \u201994),\npp. 30-38, 1994.\n[10] A. Cimitile, A. De Lucia, G.A. Di Lucca, and A.R. Fasolino,\n\u201cIdentifying Objects in Legacy Systems,\u201d Proc. Fifth Int\u2019l Workshop\nProgram Comprehension, pp. 138-147, 1997.\n[11] A. Cimitile, A. De Lucia, G.A. Di Lucca, and A.R. Fasolino,\n\u201cIdentifying Objects in Legacy Systems Using Design Metrics,\u201d\nJ. Systems and Software, vol. 44, no. 3, pp. 199-211, 1999.\n[12] A. Cimitile and G. Visaggio, \u201cSoftware Salvaging and the Call\nDominance Tree,\u201d J. Systems and Software, vol. 28, no. 2, pp. 117-\n127, 1995.\n[13] R.G. Cowell, A.P. Dawid, S.L. Lauritzen, and D.J. Spiegelhalter,\nProbabilistic Networks and Expert Systems. Springer, 1999.\n[14] A.P. Dawid, \u201cConditional Independence in Statistical Theory\n(with Discussion),\u201d J. Royal Statistics Soc. B, vol. 41, no. 1, pp. 1-31,\n1979.\n[15] A.P. Dawid, \u201cConditional Independence for Statistical Opera-\ntions,\u201d Annals of Statistics, vol. 8, no. 3, pp. 598-617, 1980.\n[16] M. Goldstein, \u201cInfluence and Belief Adjustment (with Discus-\nsion),\u201d Influence Diagrams, Belief Nets and Decision Analysis,\nR.M. Oliver and J.Q. Smith, eds., pp. 143-174, Wiley, 1990.\n[17] M.S. Hecht, Flow Analysis of Computer Programs. Amsterdam:\nNorth-Holland, 1977.\n[18] IEEE, IEEE Standard Glossary of Software Engineering Terminology.\nNew York: IEEE Press, 1983.\n[19] F.V. Jensen, An Introduction to Bayesian Networks. London: UCL\nPress 1996.\n[20] S.L. Lauritzen, Graphical Models. Oxford Science Publications,\n1996.\n[21] S.L. Lauritzen, A.P. Dawid, B.N. Larsen, and H.-G. Leimer,\n\u201cIndependence Properties of Directed Markov Fields,\u201d Networks,\nvol. 20, no. 5, pp. 491-505, 1990.\n[22] S.L. Lauritzen and D.J. Spiegelhalter, \u201cLocal Computations with\nProbabilities on Graphical Structures and Their Application to\nExpert Systems (with Discussion),\u201d J. Royal Statistics Soc. B, vol. 50,\nno. 2, pp. 157-224, 1988.\n[23] H.A. Mu\u00a8ller, M.A. Orgun, S.R. Tilley, and J.S. Uhl, \u201cA Reverse-\nEngineering Approach to Subsystem Structure Identification,\u201d\nJ. Software Maintenance: Research and Practice, vol. 5, no. 4, pp. 181-\n204, 1993.\n[24] J. Pearl, Probabilistic Inference in Intelligent Systems. San Mateo,\nCalif.: Morgan Kaufman, 1988.\n[25] J.Q. Smith, \u201cInfluence Diagrams for Statistical Modelling,\u201d Annals\nof Statistics, vol. 17, no. 2, pp. 654-672, 1989.\n[26] J.Q. Smith, \u201cStatistical Principles on Graphs (with Discussion),\u201d\nInfluence Diagrams, Belief Nets and Decision Analysis, R.M. Oliver\nand J.Q. Smith, eds., pp. 89-120, Wiley, 1990.\n[27] D.J. Spiegelhalter, \u201cDiscussion on \u2018Statistical Principles on\nGraphs\u2019 by Smith,\u201d Influence Diagrams, Belief Nets and Decision\nAnalysis, R.M. Oliver and J.Q. Smith, eds., pp. 113-116, Wiley,\n1990.\n[28] J. Whittaker, Graphical Models in Applied Multivariate Statistics.\nChichester: Wiley, 1990.\n[29] D.A. Wooff, M. Goldstein, and F.P.A. Coolen, \u201cBayesian Graphical\nModels for Software Testing,\u201d IEEE Trans. Software Eng., vol. 28,\nno. 5, pp. 510-525, May 2002.\n862 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 29, NO. 9, SEPTEMBER 2003\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\nSimon C. Shaw is a research associate in the\nStatistics and Probability Group in the Depart-\nment of Mathematical Sciences, University of\nDurham, United Kingdom. His research inter-\nests include Bayes (linear) methods and Baye-\nsian methods for software testing. He is\nparticularly concerned with the analysis of\ncollections of (second-order) exchangeable se-\nquences where the sequences may be infinite\nor finite; uses of (generalized) conditional\nindependence and graphical models.\nMichael Goldstein is a professor of statistics in\nthe Department of Mathematical Sciences, Uni-\nversity of Durham, United Kingdom. His research\ninterests are concerned with foundations, meth-\nodology, and applications of the Bayesian ap-\nproach to statistics and decision analysis. In\nparticular, he has developed applications of the\nBayesian approach for uncertainty analysis for\ncomputer models of large scale physical systems\nand for assessing software reliability through\nefficient test design, for each of which he has received both commercial\nand UK Engineering and Physical Sciences Research Council support.\nMalcolm Munro is a professor of software\nengineering in the Department of Computer\nScience at the University of Durham, United\nKingdom. His main research focus is software\nvisualization, software maintenance and evolu-\ntion, and program comprehension. The concern\nof the research is to establish how legacy\nsystems evolve over time and to discover\nrepresentations (visualizations) of those sys-\ntems to enable better understanding of change.\nHe has been actively involved with the IEEE International Conference on\nSoftware Maintenance and the International Workshop on Program\nComprehension. He has led a number of UK EPSRC funded projects\nincluding Release (Reconstruction of Legacy Systems), VVSRE\n(Visualising Software in a Virtual Reality Environment), GUSTT (Guided\nSlicing and Targeted Transformation), and Jigsaw (Distributed and\nDynamic Visualisation Generation). He is also involved in research in\nSaaS (Software as a Service) and the application of Bayesian Networks\nto software testing and program comprehension.\nElizabeth Burd received the PhD degree in\nsoftware engineering. She is a senior lecturer in\nthe Research Institute of Software Evolution at\nthe University of Durham, United Kingdom. Her\nresearch interests are in the areas of software\nevolution, software reuse, maintenance and\nreverse engineering. She is currently serving\nas a committee member of a number of internal\nconferences in these areas. She has collabo-\nrated with a number of industrial companies\nduring the process of her research including British Telecommunication,\nBAe, and Logica. She has also been an active researcher within an\nESPRIT consortium. She is a member of the IEEE and the IEEE\nComputer Society.\n. For more information on this or any computing topic, please visit\nour Digital Library at http:\/\/computer.org\/publications\/dlib.\nSHAW ET AL.: MORAL DOMINANCE RELATIONS FOR PROGRAM COMPREHENSION 863\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 09:26 from IEEE Xplore.  Restrictions apply.\n"}