{"doi":"10.1142\/S0219265907002016","coreId":"65471","oai":"oai:dro.dur.ac.uk.OAI2:5742","identifiers":["oai:dro.dur.ac.uk.OAI2:5742","10.1142\/S0219265907002016"],"title":"Distributed algorithms for building Hamiltonian cycles in k-ary n-cubes and hypercubes with faulty links.","authors":["Stewart,  I. A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-09-01","abstract":"We derive a sequential algorithm Find-Ham-Cycle with the following property. On input: k and n (specifying the k-ary n-cube Q(n,k); F, a set of at most 2n-2 faulty links; and v, a node of Q(n,k), the algorithm outputs nodes v+ and v- such that if Find-Ham-Cycle is executed once for every node v of Q(n,k) then the node v+ (resp. v-) denotes the successor (resp. predecessor) node of v on a fixed Hamiltonian cycle in Q(n,k) in which no link is in F. Moreover, the algorithm  Find-Ham-Cycle runs in time polynomial in n and log k. We also obtain a similar algorithm for an n-dimensional hypercube with at most n-2 faulty links. We use our algorithms to obtain distributed algorithms to embed Hamiltonian cycles k-ary n-cubes and hypercubes with faulty links; our hypercube algorithm improves on a recently-derived algorithm due to Leu and Kuo, and our k-ary n-cube algorithm is the first distributed algorithm for embedding a Hamiltonian cycle in a k-ary n-cube with faulty links","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65471.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/5742\/1\/5742.pdf","pdfHashValue":"f94f581d3acc81cbc2462d8002d0ce35b03902a1","publisher":"World Scientific","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:5742<\/identifier><datestamp>\n      2015-03-03T14:49:14Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Distributed algorithms for building Hamiltonian cycles in k-ary n-cubes and hypercubes with faulty links.<\/dc:title><dc:creator>\n        Stewart,  I. A.<\/dc:creator><dc:description>\n        We derive a sequential algorithm Find-Ham-Cycle with the following property. On input: k and n (specifying the k-ary n-cube Q(n,k); F, a set of at most 2n-2 faulty links; and v, a node of Q(n,k), the algorithm outputs nodes v+ and v- such that if Find-Ham-Cycle is executed once for every node v of Q(n,k) then the node v+ (resp. v-) denotes the successor (resp. predecessor) node of v on a fixed Hamiltonian cycle in Q(n,k) in which no link is in F. Moreover, the algorithm  Find-Ham-Cycle runs in time polynomial in n and log k. We also obtain a similar algorithm for an n-dimensional hypercube with at most n-2 faulty links. We use our algorithms to obtain distributed algorithms to embed Hamiltonian cycles k-ary n-cubes and hypercubes with faulty links; our hypercube algorithm improves on a recently-derived algorithm due to Leu and Kuo, and our k-ary n-cube algorithm is the first distributed algorithm for embedding a Hamiltonian cycle in a k-ary n-cube with faulty links.<\/dc:description><dc:subject>\n        Interconnection networks<\/dc:subject><dc:subject>\n         k-ary n-cubes; hypercubes<\/dc:subject><dc:subject>\n         Fault-tolerance<\/dc:subject><dc:subject>\n         Hamiltonian cycles<\/dc:subject><dc:subject>\n         Distributed algorithms<\/dc:subject><dc:subject>\n         Embeddings.<\/dc:subject><dc:publisher>\n        World Scientific<\/dc:publisher><dc:source>\n        Journal of interconnection networks, 2007, Vol.8(3), pp.253-284 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2007-09-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:5742<\/dc:identifier><dc:identifier>\n        issn:0219-2659<\/dc:identifier><dc:identifier>\n        issn: 1793-6713<\/dc:identifier><dc:identifier>\n        doi:10.1142\/S0219265907002016<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/5742\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1142\/S0219265907002016<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/5742\/1\/5742.pdf<\/dc:identifier><dc:rights>\n        Electronic version of an article published as Journal of interconnection networks, 8, 3, 2007, pp. 253-284, http:\/\/dx.doi.org\/10.1142\/S0219265907002016, \u00a9 World Scientific Publishing Company, http:\/\/www.worldscinet.com\/join\/join.shtml<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn: 1793-6713"," 1793-6713","issn:0219-2659","0219-2659"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2007,"topics":["Interconnection networks","k-ary n-cubes; hypercubes","Fault-tolerance","Hamiltonian cycles","Distributed algorithms","Embeddings."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n25 August 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nStewart, I. A. (2007) \u2019Distributed algorithms for building Hamiltonian cycles in k-ary n-cubes and hypercubes\nwith faulty links.\u2019, Journal of interconnection networks., 8 (3). pp. 253-284.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1142\/S0219265907002016\nPublisher\u2019s copyright statement:\nElectronic version of an article published as Journal of interconnection networks, 8, 3, 2007, pp. 253-284,\nhttp:\/\/dx.doi.org\/10.1142\/S0219265907002016, World Scientific Publishing Company,\nhttp:\/\/www.worldscinet.com\/join\/join.shtml\nAdditional information:\nAn extended abstract of this paper appeared in: Proc. of 12th International Conference on Parallel and Distributed\nSystems (ICPADS 2006), IEEE Computer Society Press (2006) 308-318.\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n,  \n \nDurham Research Online \n \nDeposited in DRO: \n24 August 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status of attached file: \nAccepted for publication \n \nCitation for published item: \nStewart, I. A. (2007) 'Distributed algorithms for building Hamiltonian cycles in k-ary n-cubes \nand hypercubes with faulty links.', Journal of interconnection networks., 8 (3). pp. 253-284. \n \nFurther information on publisher\u2019s website: \nhttp:\/\/dx.doi.org\/10.1142\/S0219265907002016 \n \nPublisher\u2019s statement: \nElectronic version of an article published as Journal of interconnection networks, 8, 3, 2007, \npp. 253-284, http:\/\/dx.doi.org\/10.1142\/S0219265907002016, \u00a9 World Scientific Publishing \nCompany, http:\/\/www.worldscinet.com\/join\/join.shtml \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nDistributed algorithms for building\nHamiltonian cycles in k-ary n-cubes and\nhypercubes with faulty links\nIain A. Stewart\nDepartment of Computer Science, Durham University,\nScience Labs, South Road, Durham DH1 3LE, U.K.\nAbstract\nWe derive a sequential algorithm Find-Ham-Cycle with the following property. On input:\nk and n (specifying the k-ary n-cube Qkn); F , a set of at most 2n \u2212 2 faulty links; and\nv, a node of Qkn, the algorithm outputs nodes v\n+ and v\u2212 such that if Find-Ham-Cycle is\nexecuted once for every node v of Qkn then the node v\n+ (resp. v\u2212) denotes the successor\n(resp. predecessor) node of v on a fixed Hamiltonian cycle in Qkn in which no link is in\nF . Moreover, the algorithm Find-Ham-Cycle runs in time polynomial in n and log k. We\nalso obtain a similar algorithm for an n-dimensional hypercube with at most n \u2212 2 faulty\nlinks. We use our algorithms to obtain distributed algorithms to embed Hamiltonian cycles\nk-ary n-cubes and hypercubes with faulty links; our hypercube algorithm improves on a\nrecently-derived algorithm due to Leu and Kuo, and our k-ary n-cube algorithm is the first\ndistributed algorithm for embedding a Hamiltonian cycle in a k-ary n-cube with faulty links.\nKeywords: interconnection networks; k-ary n-cubes; hypercubes; fault-tolerance; Hamilto-\nnian cycles; distributed algorithms; embeddings.\n1 Introduction\nNumerous interconnection networks have been proposed as underlying topologies for\nparallel computers. As to which network is chosen depends upon a number of factors\nrelating to the topological, algorithmic and communication properties of the network\nand the types of problems to which the resulting computer is to be applied. One of the\nmost popular interconnection networks is undoubtedly the n-dimensional hypercube\nQn. Some of its pleasing properties, with regard to parallel computation, include: it\nis node- and link-symmetric; it is Hamiltonian; it has diameter n; it has a recursive\ndecomposition; and it contains, or \u201cnearly\u201d contains (as subgraphs), almost all inter-\nconnection networks currently vogue in parallel computing (see [29] for these results\nand more on the hypercube). Some of the commercial machines whose underlying\ntopology is based on the hypercube are the Cosmic Cube [37], the Ametek S\/14 [8],\nthe iPSC [21,22], the Ncube [14,22] and the CM-200 [15].\nHowever, every node of Qn has degree n, and consequently, as n increases so does\nthe degree of every node. High degree nodes in interconnection networks can lead to\n1\ntechnological problems in parallel computers whose underlying topology is that of the\nsaid interconnection network. One method of circumventing this problem, so as to still\nretain a \u201chypercube-like\u201d interconnection network, is to build parallel computers so\nthat the underlying topology is the k-ary n-cube Qkn. The k-ary n-cube Q\nk\nn is similar\nin essence to the hypercube, but by a judicious choice of k and n we can include\na large number of nodes yet keep the degree of each node fixed. For example, the\nhypercube Q12 has 4096 nodes and every node has degree 12. However, Q\n16\n3 has 4096\nnodes and every node has degree 6. Of course, one usually loses out in some other\nrespect (for example, in terms of diameter) but often this loss is not too catastrophic.\nThe k-ary n-cube Qkn has not been investigated to the same extent as the hypercube,\nbut it is known to have the following properties (amongst many others): it is node-\nand link-symmetric [7]; it is Hamiltonian [9,12]; it has diameter n\u230ak\/2\u230b [9,12]; it has\na recursive decomposition; and it contains many important interconnection networks\nsuch as cycles (of certain lengths) [7], meshes (of certain dimensions) [9] and even\nhypercubes (of certain dimensions) [12]. Machines whose underlying topology is based\non a k-ary n-cube include the Mosaic [38], the iWARP [11], the J-machine [32], the\nCray T3D [26] and the Cray T3E [5].\nIn parallel computers which have a large number of processors, it is not uncom-\nmon for nodes or links between nodes to fail. This experience has motivated inves-\ntigations into how able different interconnection networks are to cope with a lim-\nited number of node and\/or link faults. Most investigations have focussed on the\nresulting communication capabilities or embeddability of faulty interconnection net-\nworks, e.g., whether a certain network is still connected or whether certain guest\nnetworks can still be embedded in certain host networks, given a limited number\nof faults. Also, most research has centered around hypercubes; see, for example,\n[10,13,14,16\u201319,24,27,28,30,31,34\u201336,39\u201346] for recent work. The k-ary n-cube has\nnot been considered to such a great extent although there is some existing research;\nsee, for example, [1\u20134,6, 20].\nIn this paper, we are primarily interested in the distributed embedding of a Hamil-\ntonian cycle in a k-ary n-cube when some of the links are faulty, and secondarily in a\nhypercube with faulty links. The existence of a Hamiltonian cycle in an interconnec-\ntion network is extremely useful as, for one thing, it facilitates all-to-all broadcasts,\nwith messages being \u201cdaisy-chained\u201d around the cycle. Also, the existence of a Hamil-\ntonian path between two nodes enables algorithms designed for linear arrays to be\nsimulated in the (faulty) k-ary n-cube. It is well known that Qn and Q\nk\nn possess\nfault-free Hamiltonian cycles in the presence of at most n\u2212 2 and 2n\u2212 2 faulty links,\nrespectively; indeed, under the additional modest assumption that a node in Qn or\nQkn is incident with at least 2 healthy links, there are still Hamiltonian cycles in Qn\nand Qkn when there are 2n\u2212 5 [16] and 4n\u2212 5 [6] faulty links, respectively, and these\nresults are optimal. However, the existence of a Hamiltonian cycle is not necessar-\nily sufficient for algorithmic viability as the cycle needs to be constructed, and not\nby a centralized algorithm which necessarily takes time exponential in n, but by a\ndistributed algorithm which hopefully will run in polynomial-time and have minimal\nmessage-passing overhead.\nOur main result is the derivation of a sequential algorithm Find-Ham-Cycle with\nthe following property. On input: k and n (specifying the k-ary n-cube Qkn); F , a\nset of at most 2n\u2212 2 faulty links; and v, a node of Qkn, the algorithm outputs nodes\n2\nv+ and v\u2212 such that if Find-Ham-Cycle is executed once for every node v of Qkn\nthen the node v+ (resp. v\u2212) denotes the successor (resp. predecessor) node of v on\na fixed Hamiltonian cycle in Qkn in which no link is in F . Moreover, the algorithm\nFind-Ham-Cycle runs in time polynomial in n and log k. We also obtain a similar\nalgorithm for an n-dimensional hypercube with at most n\u2212 2 faulty links. Note that\nexecuting our algorithms at each node of a distributed-memory multiprocessor whose\nunderlying topology is a k-ary n-cube or a hypercube results in an embedding of a\nfault-free Hamiltonian cycle, assuming that each node has complete knowledge of all\nfaulty links but where no message passing is required. Consequently, in order to use\nour algorithms in a distributed fashion, all we need to do is to disseminate knowledge\nof which links are faulty, which is a problem that has been well studied.\nIn Section 2, we give the basic definitions relating to the content of this paper,\nbefore outlining and commenting on related work in Section 3. In Section 4, we\ndevelop our main algorithm for k-ary n-cubes, and in Section 5 we show how this\nalgorithm can be adapted for hypercubes. Finally, we show how our algorithms can\nbe applied in Section 6.\n2 Basic definitions\nThe k-ary n-cube Qkn, for k \u2265 2 and n \u2265 2, has k\nn nodes indexed by {0, 1, . . . , k\u22121}n,\nand there is a link ((x1, x2, . . . , xn), (y1, y2, . . . , yn)) if, and only if, there exists j \u2208\n{1, 2, . . . , n} such that min{|xj \u2212 yj |, k \u2212 |xj \u2212 yj |} = 1, and xi = yi, for every\ni \u2208 {1, 2, . . . , n} \\ {j} (for example, Qk2 is a k \u00d7 k mesh with wrap-around). When\nk = 2, Q2n is the hypercube of dimension n and we denote it simply Qn. When k \u2265 3,\nQkn can be thought of as the direct (graph) product of n cycles of length k, or the\nCayley graph of the finitely generated group \u3008g1, g2, . . . , gk : g\nk\ni = 1, g\n\u22121\ni g\n\u22121\nj gigj =\n1, for all i, j = 1, 2, . . . , k\u3009 [9].\nEach component of an n-tuple describing the nodes of Qkn is called a dimension,\nand Qkn can be partitioned over a dimension i by regarding it as consisting of k disjoint\ncopies of Qkn\u22121, where the jth copy is induced by the nodes of Q\nk\nn in which the value\nof the ith component is fixed at j \u2208 {0, 1, . . . , k \u2212 1} (corresponding nodes of these\nk copies of Qkn\u22121 are joined by a link, if k = 2, and joined in a cycle of length k,\nif k \u2265 3). We denote the nodes of Qkn in bold type, e.g., x, so as to reflect their\nrepresentation as n-tuples. The Lee distance between two nodes x and y of Qkn is\ndefined as\nn\u2211\ni=1\nmin{|xi \u2212 yi|, k \u2212 |xi \u2212 yi|}\n(so, two nodes are joined in Qkn if, and only if, the Lee distance between them is 1).\nA faulty link , or simply fault , in Qkn is a link which can be considered as missing.\nWe assume that the nodes incident with a faulty link are fully cognisant that this\nlink is faulty, and that the fault does not affect the nodes\u2019 performance. Any link\nthat is not faulty is healthy . An oriented graph in an undirected graph is a subgraph\nwhere each link has had an orientation imposed so as to transform it into a directed\nsubgraph.\n3\n3 Related work\nThe problem of developing a feasible distributed algorithm for the algorithmic con-\nstruction of a Hamiltonian cycle in a faulty hypercube was first tackled in [17]. In this\npaper, Chan and Lee obtain a distributed algorithm for a distributed-memory multi-\nprocessor whose underlying interconnection network is an n-dimensional hypercube,\nwhich builds a cycle of size at least 2n \u2212 2f in the hypercube when f \u2264 \u230a(n + 1)\/2\u230b\nnodes are faulty. They assume that initially each node has only local knowledge of\nwhich nodes are faulty; that is, each node is aware only of which of its neighbours\nare faulty (all links are assumed to be healthy). After construction of the cycle,\neach node on the cycle knows its successor and predecessor on the cycle. Chan and\nLee do not explicitly define their model of computation but only say how their own\nparticular algorithm is executed on this model. Their model is such that initially a\ngiven source node is active. This source node computes and then activates, at some\nappropriate point, some of its neighbours and these neighbours begin to compute.\nThese neighbours then activate some of their neighbours, and so forth. Nodes can be\nactivated at some future point even if they have already been activated. Chan and\nLee\u2019s algorithm essentially simultaneously executes 2f \u2212 1 cycle-building algorithms\neach of which is based on a distinct (binary-reflected) Gray code. Chan and Lee do\nnot concern themselves with a complexity analysis but one can easily see that their\nalgorithm involves \u2126((2n \u2212 2f)(2f \u2212 1)) node activations and also has the (severe)\ndrawback that \u2126(2n) space is required (and consequently \u2126(2n) time) at each node\n(in order to compute and store a Gray code).\nChan and Lee mention in their conclusion that there is a possibility of deriving\na similar distributed algorithm for the situation where the hypercube has at most\n\u230a(n + 1)\/2\u230b faulty links and where the resulting cycle will be Hamiltonian. They\nhint that this might be accomplished by using link-disjoint Hamiltonian cycles in a\nhypercube although they leave as open the question of whether this can actually be\ndone. Following their suggestions would almost surely result in a distributed algorithm\nwhich, like Chan and Lee\u2019s faulty-node algorithm, requires \u2126(2n) space at each node.\nLatifi, Zheng and Bagherzadeh [27,28] tackle the question posed by Chan and Lee\nand develop a centralized sequential algorithm which builds a Hamiltonian cycle in\nan n-dimensional hypercube when at most n \u2212 2 links are faulty. We use the term\ncentralized in order to convey the fact that all faults are known a priori to the algo-\nrithm. What they do is to develop an O(n2) time algorithm which on being given a\nset of at most n \u2212 2 faulty links produces a characterization of a fault-free Hamilto-\nnian cycle. This characterization is a permutation of {1, 2, . . . , n} which encodes the\nconstruction of a Gray code, i.e., a Hamiltonian cycle in the hypercube. Of course, in\norder to obtain the actual Hamiltonian cycle, the permutation needs to be expanded,\nwhich takes \u2126(2n) time. So, although Latifi, Zheng and Bagherzadeh\u2019s algorithm\ncan be used to construct a Hamiltonian cycle in a hypercube with faulty links, in a\ndistributed fashion, full knowledge of all faulty links must be acquired by each node\nand the subsequent expansion of the characterization of the cycle by each node takes\n\u2126(2n) time.\nSignificant progress was made in [30] where Leu and Kuo develop a distributed\nalgorithm for a distributed-memory multiprocessor whose underlying interconnection\nnetwork is an n-dimensional hypercube, which builds a Hamiltonian cycle in the\n4\nhypercube when at most n\u2212 2 links are faulty. They assume that initially each node\nhas global knowledge of which links are faulty but remark that even if each node\nonly has knowledge of the links incident with it which are are faulty, a broadcast\nalgorithm due to Park and Bose [33] can be used to distribute this local knowledge so\nthat every node acquires global knowledge of all the faulty links in the network. Leu\nand Kuo\u2019s algorithm works by incrementally joining appropriate cycles so as to avoid\nfaulty links and ultimately obtain a fault-free Hamiltonian cycle. Their algorithm\nruns in polynomial-time. However, it requires message-passing between nodes in the\nconstruction of the cycle (once global fault knowledge has been acquired by each\nnode) which should, in theory, be avoidable. Wang, Leu and Kuo extend the research\nin [30] when in [43] they embed not only Hamiltonian cycles in hypercubes but also\nother topologies.\nIn this paper, we develop distributed algorithms to construct Hamiltonian cycles\nin a distributed-memory multiprocessor whose underlying interconnection network is\na k-ary n-cube or an n-dimensional hypercube when there is a limited number of\nfaulty links. Our approach extends and improves that adopted by Leu and Kuo,\nabove, with the result that we obtain an improved hypercube algorithm and a new\nk-ary n-cube algorithm. As far as we are aware, ours is the first feasible distributed\nalgorithm for constructing Hamiltonian cycles in k-ary n-cubes with faulty links.\n4 Finding Hamiltonian cycles\nThroughout this section, k \u2265 3 and n \u2265 2 unless otherwise stated. We detail a\nsequential algorithm Find-Ham-Cycle with the following property. The algorithm\nhas input variables:\n\u2022 k and n, which specify Qkn;\n\u2022 F , a set of at most 2n\u2212 2 faulty links in Qkn; and\n\u2022 v, a node of Qkn,\nand output variables:\n\u2022 v+ and v\u2212, nodes of Qkn,\nand is such that if Find-Ham-Cycle(k,n,F,v;v+,v\u2212) is executed once for every\nnode v ofQkn (with the same set of faults F each time) then the node v\n+ (resp. v\u2212) de-\nnotes the successor (resp. predecessor) node of v on a fixed, oriented Hamiltonian cy-\ncle inQkn in which no link is in F (we already know that such a Hamiltonian cycle exists\nby [6], although our analysis and constructions yield an alternative proof of this fact).\nMoreover, the algorithm Find-Ham-Cycle runs in time polynomial in n and log k.\nConsequently, if we were to execute the algorithm Find-Ham-Cycle(k,n,F ,v;v+,v\u2212)\nat every node v of a machine whose underlying topology is that of the k-ary n-cube\nQkn and in which there are at most 2n\u22122 faulty links (thus we assume that every node\nhas global knowledge relating to the set of faults) then after termination, every node\nwould know its successor and predecessor nodes on a (fault-free) oriented Hamiltonian\ncycle, and this information would have been obtained in polynomial time (in n and\nlog k) and without sending any messages amongst nodes.\n5\n4.1 Basic construction\nLet Qkn have at most 2n \u2212 2 faults, for some n \u2265 3, which we denote by the set F .\nThe basic structure of our algorithm is as follows, although, as we shall see, there are\nsome subtleties.\n\u2022 Partition Qkn over some dimension d so as to obtain k copies, Q0, Q1, . . ., Qk\u22121,\nof Qkn\u22121 in which the total number of faults, summing over all copies of Q\nk\nn\u22121,\nis at most 2(n\u2212 1)\u2212 2.\n\u2022 Superimpose all the faults in Q0, Q1, . . ., Qk\u22121 onto one copy of Q\nk\nn\u22121; call it\nP (thus there are at most 2(n\u2212 1)\u2212 2 faults in P ).\n\u2022 Recursively find a Hamiltonian cycle C in P .\n\u2022 The Hamiltonian cycle C in P is also a Hamiltonian cycle Ci in Qi, for i =\n0, 1, . . . , k \u2212 1. Join these cycles together using links in dimension d so as to\nobtain a Hamiltonian cycle in Qkn (which avoids all the faults).\nBy \u201cjoin\u201d, above, we mean the following. Choose two distinct links (x,y) and\n(x,y\u2032) of the Hamiltonian cycle C. These links correspond to the links (xi,yi) and\n(xi,y\n\u2032\ni) of Ci, for i = 0, 1, . . . , k \u2212 1, and there are links (xi,xi+1), (yi,yi+1) and\n(y\u2032i,y\n\u2032\ni+1) in a healthy Q\nk\nn, for i = 0, 1, . . . , k \u2212 1 with addition modulo k (of course,\nin our faulty Qkn some of these links may be faulty, but more of this later). We add\nand remove links as follows.\n\u2022 For each i \u2208 {1, 2, . . . , k\u22122}, remove the links (xi,yi) and (xi,y\n\u2032\ni) from Ci, and\nremove the link (x0,y\n\u2032\n0) from C0. If k \u2212 1 is even (resp. odd) then remove the\nlink (xk\u22121,yk\u22121) (resp. (xk\u22121,y\n\u2032\nk\u22121)) from Ck\u22121.\n\u2022 For even i \u2208 {0, 1, . . . , k \u2212 2}, include the links (xi,xi+1) and (y\n\u2032\ni+1,y\n\u2032\ni). For\nodd i \u2208 {0, 1, . . . , k \u2212 2}, include the links (xi,xi+1) and (yi+1,yi).\nThe construction can be visualized as in Fig. 1, where k is odd and where we have\nprovided an orientation on the links so that a directed cycle results.\n...\n... ...\n...\nx0\ny0\ny0'\nxi-1\nyi-1\nyi-1'\nxi\nyi\nyi'\nxi+1\nyi+1\nyi+1'\nxk-1\nyk-1\nyk-1'\nC0 Ci+1 Ck-1CiCi-1\nFigure 1. Joining the cycles C0, C1, . . ., Ck\u22121 (where k \u2212 1 is even).\n6\nThus, we obtain a Hamiltonian cycle in Qkn. However, as we have just mentioned,\nin a faulty k-ary n-cube Qkn we must ensure that we can find two links (x,y) and\n(x,y\u2032) in C so that none of the links in dimension d used to join the Hamiltonian\ncycles C0, C1, . . ., Ck\u22121 are faulty. Also, we need to deal separately with the base\ncase of the recursion, when n = 2.\nApart from the above consideration, deriving an algorithm would be easy if we\nwere not concerned that the algorithm should run in polynomial time (in n and log k).\nAs any (sequential) algorithm which finds a Hamiltonian cycle in a k-ary n-cube Qkn\nnecessarily runs in time \u2126(kn), we seek a (parallel) algorithm which we can run (in\npolynomial time) at every node of a machine whose underlying topology is that of our\nfaulty k-ary n-cube Qkn so that a Hamiltonian cycle is found but where every node\nonly has local knowledge of this Hamiltonian cycle. Of course, this local knowledge\nis enough for us to utilize the Hamiltonian cycle for message routing and so on.\nFurthermore, in such a distributed algorithm we must also ensure that orientations\nof recursively-constructed cycles are monitored when these oriented cycles are joined\ntogether to former a larger oriented cycle.\nAt first glance, it might appear relatively straightforward to obtain such an algo-\nrithm. However, consider the final act of joining together the cycles C0, C1, . . ., Ck\u22121\nin Qkn. Suppose that a decision as to which links (x,y) and (x,y\n\u2032) of C are chosen\n(over which to join the cycles C0, C1, . . ., Ck\u22121) is deferred until after the recursive\ncalls which build C. Each node v only has local knowledge of C and consequently\nonly knows for sure that the links (v\u2212,v) and (v,v+) are links of C. If node v decides\nto join the cycles over these two links (or, more precisely, if in the execution of the\nalgorithm at node v we decide to join the cycles over these two links), how does some\nother node u of Qkn know to do likewise, given that u only has local knowledge of the\nHamiltonian cycle C? Also, it is not obvious as to how the links (x,y) and (x,y\u2032) of\nC can be decided upon before preforming the recursive calls which build C; as how\ncan we be sure that any chosen links will end up being in the resulting Hamiltonian\ncycle C?\nWhat we do is to find a node z of P with the property that no matter which two\nof its neighbours are the successor and predecessor on an oriented Hamiltonian cycle\nwithin C, it will be possible to join the resulting cycles C0, C1, . . ., Ck\u22121 using the\ntwo links corresponding to those involving z and its predecessor and successor.\n4.2 Joining cycles\nConsider our k-ary n-cube Qkn in which there is a set F of at most 2n\u2212 2 faults. Let\nd be the dimension in which most faults of F occur. Partition Qkn over dimension d\nto obtain k copies, Q0, Q1, . . ., Qk\u22121, of Q\nk\nn\u22121. Note that the total number of faults,\nsumming over Q0, Q1, . . ., Qk\u22121, is at most 2(n \u2212 1) \u2212 2, if n \u2265 3, or at most 1, if\nn = 2. Let P be a copy of Qkn\u22121 in which all the faults in Q0, Q1, . . ., Qk\u22121 have\nbeen superimposed. For each fault (a,b) of F (in Qkn), if (a,b) is in dimension d then\ndenote by proj((a,b), d) the node (of Qkn\u22121)\n(a1, . . . , ad\u22121, ad+1, . . . , an) (= (b1, . . . , bd\u22121, bd+1, . . . , bn)),\nand if (a,b) is not in dimension d then denote by proj((a,b), d) the link (of Qkn\u22121)\n((a1, . . . , ad\u22121, ad+1, . . . , an), (b1, . . . , bd\u22121, bd+1, . . . , bn)).\n7\nLet D be the set (of nodes of P ) of such projections of all faults in dimension d.\nHence, |D| \u2264 2n \u2212 2, if n \u2265 3. We shall use the related operation expand later: if\nu = (u1, u2, . . . , un\u22121) \u2208 {0, 1, . . . , k\u22121}\nn\u22121, w \u2208 {0, 1, . . . , k\u22121} and d \u2208 {1, 2, . . . , n}\nthen expand(u, w, d) is the node (u1, . . . , ud\u22121, w, ud, . . . , un\u22121) of Q\nk\nn.\nFix n \u2265 3 until further notice. We wish to choose canonical links (x,y) and\n(x,y\u2032) of the recursively built Hamiltonian cycle C of P so that {x,y,y\u2032} \u2229D = \u2205.\nIn particular, we look for a node x \u2208 P \\D none of whose neighbours in P is in D.\nWe now verify that such a node x exists.\nA simple counting argument proves the existence of x in most cases. Suppose that\nsuch a node x did not exist. Thus, every node of P must be adjacent to a node of D.\nThe number of nodes adjacent to a node of D is at most (2n \u2212 2)2(n \u2212 1). Hence,\n(2n \u2212 2) + (2n \u2212 2)2(n \u2212 1) = (2n \u2212 2)(2n \u2212 1) \u2265 kn\u22121. This yields a contradiction\nwhenever (k \u2265 5 and n \u2265 3) or (k = 4 and n \u2265 4) or (k = 3 and n \u2265 5), i.e., whenever\n(k, n) 6\u2208 {(3, 3), (3, 4), (4, 3)}. So, in these cases x exists, and an algorithm to find x\ncan be constructed which examines O(n2) nodes of P .\nHowever, we can do better (and this constructive affirmation will result in an\nimproved algorithm to find such a node x which need only examine O(n) nodes of\nP ). Suppose that k \u2265 5 and n \u2265 5. Define the set of nodes S of P as follows.\nS = {(a1, a2, . . . , an\u22122, 0) : (ai, ai+1) = (1, 2), for some i \u2208 {1, 2, . . . , n\u2212 3},\nand aj = 0, for j \u2208 {1, 2, . . . , n\u2212 2} \\ {i, i+ 1}} \u222a {(2, 0, . . . , 0, 1, 0)}\n\u222a {(a1, a2, . . . , an\u22122, 1) : (ai, ai+1) = (2, 1), for some i \u2208 {1, 2, . . . , n\u2212 3},\nand aj = 0, for j \u2208 {1, 2, . . . , n\u2212 2} \\ {i, i+ 1}} \u222a {(1, 0, . . . , 0, 2, 1)}\n\u222a {(3, 3, . . . , 3, 3), (4, 4, . . . , 4, 4), (0, 0, . . . , 0, 2)}.\nSuppose that k \u2265 5 and n = 4. Define the set of nodes S of P as follows.\nS = {(0, 0, 0), (1, 2, 0), (2, 4, 0), (4, 3, 0), (3, 1, 0), (2, 2, 2), (3, 3, 3)}.\nSuppose that k \u2265 5 and n = 3. Define the set of nodes S of P as follows.\nS = {(0, 0), (1, 2), (2, 4), (4, 3), (3, 1)}.\nSuppose that k = 4 and n \u2265 4. Define the set of nodes S of P as follows.\nS = {(a1, a2, . . . , an\u22121) : (ai, ai+1) = (1, 2), for some i \u2208 {1, 2, . . . , n\u2212 2},\nand aj = 0, for j \u2208 {1, 2, . . . , n\u2212 1} \\ {i, i+ 1}} \u222a {(2, 0, . . . , 0, 1)}\n\u222a {(a1, a2, . . . , an\u22121) : (ai, ai+1) = (2, 1), for some i \u2208 {1, 2, . . . , n\u2212 2},\nand aj = 3, for j \u2208 {1, 2, . . . , n\u2212 1} \\ {i, i+ 1}} \u222a {(1, 3, . . . , 3, 2)}\n\u222a {((0, 0, . . . , 0)}.\nSuppose that k = 3 and n \u2265 5. Define the set of nodes S of P as follows.\nS = {(a1, a2, . . . , an\u22122, 1) : (ai, ai+1) = (1, 2), for some i \u2208 {1, 2, . . . , n\u2212 3},\nand aj = 0, for j \u2208 {1, 2, . . . , n\u2212 2} \\ {i, i+ 1}} \u222a {(2, 0, . . . , 0, 1, 1)}\n\u222a {(a1, a2, . . . , an\u22122, 2) : (ai, ai+1) = (2, 1), for some i \u2208 {1, 2, . . . , n\u2212 3},\nand aj = 0, for j \u2208 {1, 2, . . . , n\u2212 2} \\ {i, i+ 1}} \u222a {(1, 0, . . . , 0, 2, 2)}\n\u222a {(0, 0, . . . , 0, 0), (1, 1, . . . , 1, 0), (2, 2, . . . , 2, 0)}.\n8\nIn particular, in all cases |S| = 2n\u22121 and the Lee distance between any two nodes\nof S is at least 3. Thus, as |D| \u2264 2n\u2212 2, there must exist at least one node, x, of S\nthat is adjacent to no node of D. Furthermore, we can easily devise an algorithm, call\nit Find-x, which, on being given k and n, where n and k fall into one of the above\ncases, and also a set of nodes D, finds such a node x by searching the nodes of S in a\ncanonical, pre-determined order. It is straightforward to see that this algorithm can\nbe implemented to run in O(n3 log k) time.\nNow consider the case when n = 2 and there are 2 faulty links; we need to deal\nwith the \u2018base case\u2019 of our forthcoming recursive algorithm. Suppose further that\nk \u2265 4 (it is trivial to derive a Hamiltonian cycle for the case when n = 2 and k = 3\nand when there are 2 faulty links). Without loss of generality, either both faults lie\nin dimension 1, or one lies in dimension 1 and one in dimension 2; moreover, we may\nassume (by link-symmetry) that one dimension 1 fault, f1, is the link ((0, 0), (k\u22121, 0)).\nConsequently, the other fault, f2, is of the form ((i\n\u2032, j\u2032), (i\u2032 + 1, j\u2032)) (a dimension 1\nfault) or of the form ((i\u2032, j\u2032), (i\u2032, j\u2032 + 1)) (a dimension 2 fault).\nIf f2 is a dimension 1 fault then we can join the dimension 2 cycles just as we did\nearlier, as depicted in Fig. 1, ensuring that we avoid the fault f2, which is possible as\nk \u2265 4 (note that the fault f1 is not used to join cycles regardless). If f2 is a dimension\n2 fault then we need to join k \u2212 1 cycles and one path (each of which lies within\ndimension 2). We do this exactly as we did earlier except that we ensure that f2 is\none of the links omitted in our construction, as depicted in Fig. 1.\n4.3 Implementation details\nWe can now present our algorithm. Recall that this algorithm is only to describe the\nresulting oriented Hamiltonian cycle in a localized fashion. As expected, all addition\nand subtraction of values from {0, 1, . . . , k \u2212 1} is modulo k.\nFind-Ham-Cycle(input variables\nk, n : parameters of Qkn\nF : set of at most 2n\u2212 2 link faults\nv : node at which this algorithm is executed\noutput variables\nv+ : successor of v on the Hamiltonian cycle\nv\u2212 : predecessor of v on the Hamiltonian cycle)\nbegin\n\/* Deal with the base cases of the recursion. *\/\nif (n = 3 and (k = 3 or k = 4)) or (n = 4 or k = 3) then\nreturn the successor and predecessor nodes on a\ncanonical Hamiltonian cycle\nelse\nif n = 2 then\nreturn v+ and v\u2212 from Find-Ham-Cycle-n=2(k,F,v;v+,v\u2212)\n\/* Find the dimension d in which most faults lie. *\/\n9\nif there are no faults in F then\nd := 1\nelse\nlet d be the dimension containing most faults\n\/* Partition over dimension d to obtain k-ary (n\u2212 1)- *\/\n\/* cubes Q0, Q1, . . ., Qk\u22121, and superimpose the faults *\/\n\/* in Q0, Q1, . . ., Qk\u22121 on a k-ary (n\u2212 1)-cube P to *\/\n\/* obtain the fault set G. Build the set of nodes D. *\/\n\/* Recall, if (y, z) is in dimension d then proj((y, z), d) *\/\n\/* is the node (y1, . . . , yd\u22121, yd+1, . . . , yn); otherwise *\/\n\/* proj((y, z), d) is the link ((y1, . . . , yd\u22121, yd+1, . . . , yn), (z1, *\/\n\/* . . . , zd\u22121, zd+1, . . . , zn)). *\/\nG := \u2205 \/* will consist of at most 2n\u2212 4 faults of Qkn\u22121 *\/\nD := \u2205 \/* will consist of at most 2n\u2212 2 nodes of Qkn\u22121 *\/\nfor every (y, z) \u2208 F do\nif (y, z) is in dimension d then\nput the node proj((y, z), d) in D\nelse\nput the link proj((y, z), d) in G\n\/* Obtain a node x of P so that the resulting cycles C0, C1, *\/\n\/* . . ., Ck\u22121 are to be joined over two links incident with x. *\/\nFind-x(k,n\u2212 1,D;x)\n\/* Recursively find a Hamiltonian cycle C in P. *\/\nu := proj(v, d) and w := dth component of v\nFind-Ham-Cycle(n\u2212 1,k,G,u;u+,u\u2212)\n\/* Obtain v+ and v\u2212. Recall, expand(u, w, d) is (u1, . . . , ud\u22121, w, *\/\n\/* ud, . . . , un\u22121). *\/\nv+ := expand(u+, w, d) and v\u2212 := expand(u\u2212, w, d)\n\/* Reverse the direction of the cycles C0, C2, C4, . . . *\/\nif w is even then swap v+ and v\u2212\n\/* Join the cycles C0, C1, . . ., Ck\u22121. *\/\nif u = x then\nif w 6= 0 and w 6= k \u2212 1 then\nv+ := expand(u, w + 1, d) and v\u2212 := expand(u, w \u2212 1, d)\nif w = 0 then v+ := expand(u, 1, d)\n10\nif w = k \u2212 1 then v\u2212 := expand(u, k \u2212 2, d)\nelse\nif u+ := x then\nif w 6= 0 then v+ := expand(u, w \u2212 1, d)\nelse\nif u\u2212 := x then\nif w 6= k \u2212 1 then v\u2212 := expand(u, w + 1, d)\nend\nAssuming that Find-Ham-cycle-n=2(k,F,v;v+,v\u2212) finds an oriented Hamilto-\nnian cycle in a k-ary 2-cube, the algorithm Find-Ham-Cycle essentially follows the\nconstruction as described in Sections 4.1 and 4.2 and as depicted in Fig. 1. With refer-\nence to Fig. 1 and the final part of the algorithm, nodes for which u = x are coloured\nwhite, nodes for which u+ = x are coloured grey, and nodes for which u\u2212 = x are\ncoloured black. We remark that the \u201ccanonical Hamiltonian cycle\u201d for the cases when\n(n, k) \u2208 {(3, 3), (3, 4), (4, 3)} exists (by [6], for example) and can be derived by hand\nor using a simple computer program.\nFind-Ham-Cycle-n=2(input variables\nk : parameter of Qk2\nF : set of at most 2 faults\nv : node at which this algorithm is executed\noutput variables\nv+ : successor of v on the Hamiltonian cycle\nv\u2212 : predecessor of v on the Hamiltonian cycle)\nbegin\nif k = 3 then\nreturn the successor and predecessor nodes on a\ncanonical Hamiltonian cycle\n\/* Reorient the k-ary 2-cube if necessary. *\/\nif dimension 2 has more faults than dimension 1 then\nswap dimensions via a transformation \u03c3 (so that now\ndimension 1 has most faults)\nif dimension 1 has at least 1 fault then\nrename nodes via a transformation \u03c4 so that one of the\ndimension 1 faults is ((0, 0), (k \u2212 1, 0))\n\/* So apart from possibly ((0, 0), (k \u2212 1, 0)), there is at most *\/\n\/* one other fault f, either of the form ((i\u2032, j\u2032), (i\u2032, j\u2032 + 1)) *\/\n\/* or ((i\u2032, j\u2032), (i\u2032 + 1, j\u2032)). *\/\nsuppose that v = (i, j)\n\/* Initialize successor and predecessor nodes. *\/\n11\nif i is even then\nv+ := (i, j \u2212 1) and v\u2212 := (i, j + 1)\nelse\nv+ := (i, j + 1) and v\u2212 := (i, j \u2212 1)\n\/* Find links over which to join the dimension 2 cycles\/paths *\/\n\/* so as to avoid faults. *\/\nif f = ((i\u2032, j\u2032), (i\u2032, j\u2032 + 1)) then\nif w = k \u2212 1 and w is odd then\nx := j\u2032 + 1\nelse\nx := j\u2032\nelse\nif f = ((i\u2032, j\u2032), (i\u2032 + 1, j\u2032)) then x := j\u2032 + 2\n\/* Join the cycles\/paths. *\/\nif j = x then\nif i 6= 0 and i 6= k \u2212 1 then v+ := (i+ 1, j) and v\u2212 := (i\u2212 1, j)\nif i = 0 then v+ := (i+ 1, j)\nif i = k \u2212 1 then v\u2212 := (i\u2212 1, j)\nelse\nif j = x\u2212 1 then\nif i 6= k \u2212 1 is even then\nv\u2212 := (i+ 1, x\u2212 1)\nelse\nif i is odd then v+ := (i\u2212 1, x\u2212 1)\nelse\nif j = x+ 1 then\nif i 6= 0 is even then\nv+ := (i\u2212 1, x+ 1)\nelse\nif i 6= k \u2212 1 is odd then v\u2212 := (i+ 1, x+ 1)\n\/* Un-reorient the k-ary 2-cube if necessary. *\/\nif \u03c4 was performed earlier then perform \u03c4\u22121\nif \u03c3 was performed earlier then perform \u03c3\u22121\nend\nIn the algorithm Find-Ham-Cycle-n=2, the reorientation \u03c4 of Qk2 is easily per-\nformed by adding appropriate offsets to the components of nodes (and subtracting\nthe same offsets in order to perform \u03c4\u22121); the same offsets apply for every node.\nOtherwise, the algorithm essentially implements the construction as described in Sec-\ntions 4.1 and 4.2 and as depicted in Fig. 1, except where cycles\/paths to be joined\nlie in dimension 2 in Qk2 . Note that the choice of x always ensures that if there is a\nfault in dimension 2 then the construction is such that this fault is not used in the\n12\nresulting Hamiltonian cycle.\nThe algorithm Find-Ham-Cycle-n=2 trivially has time complexity O(log k) and\napart from the recursive call, the time complexity of Find-Ham-Cycle is O(n3 log k)\n(which is the time complexity of Find-x). Hence, the time complexity f(n, k) of\nFind-Ham-Cycle satisfies the recurrence\nf(n, k) \u2264 f(n\u2212 1, k) + \u03b1n3 log k,\nfor some constant \u03b1, and so f(n, k) = O(n4 log k). Hence, we have the following\nresult.\nTheorem 1 The algorithm Find-Ham-Cycle takes as input the parameters n and\nk of Qkn, a set F of at most 2n \u2212 2 faulty links in Q\nk\nn and a node v of Q\nk\nn and\noutputs two nodes v+ and v\u2212 of Qkn. If we fix the parameters n, k and F and we run\nFind-Ham-Cycle once for every node v of Qkn as input then:\n\u2022 the oriented graph induced by the directed links {(v,v+) : v \u2208 Qkn} is an oriented\nHamiltonian cycle in Qkn in which no faulty link appears; and\n\u2022 the oriented graph induced by the directed links {(v,v\u2212) : v \u2208 Qkn} is the same\nHamiltonian cycle but oriented in the opposite direction.\nFurthermore, the algorithm Find-Ham-Cycle has time complexity O(n4 log k).\n5 The hypercube\nThe algorithm Find-Ham-Cycle can be adapted so that it similarly gives a Hamil-\ntonian cycle in an n-dimensional hypercube Qn with at most n \u2212 2 faulty links,\nwhere n \u2265 3. This adaptation, which we outline here, is conceptually simpler than\nFind-Ham-Cycle. (Recall that Chan and Lee have already shown that a Hamiltonian\ncycle exists in Qn in the presence of n\u2212 2 link faults [16].)\nThe basic structure of our algorithm Find-Ham-Cycle-Hyper for our faulty Qn\nis identical to that of Find-Ham-Cycle. We begin by partitioning Qn over some\ndimension d in which there is at least 1 fault (or over any dimension if there are no\nfaults), and then superimpose the faults not in dimension d on an (n\u22121)-dimensional\nhypercube P so that P has at most n\u2212 3 faulty links. We also project all faulty links\nin dimension d so as to obtain a set D of nodes of P of size at most n\u2212 2, as before.\nWe then determine a node x of P such that x 6\u2208 D and nor is any of its neighbours\n(our counting argument, as used earlier, verifies that such an x always exists). After\nrecursively finding a Hamiltonian cycle C in P , we obtain two isomorphic Hamiltonian\ncycles, C0 and C1, in the two \u201chalves\u201d of our original faulty Qn, joined by links in\ndimension d. We then join C0 and C1 using the links in dimension d whose projections\nare x and one of its neighbours in C, just as we did before.\nThe following corollary follows from the preceding analysis.\nCorollary 2 There is an algorithm Find-Ham-Cycle-Hyper which takes as input the\nparameter n \u2265 3 of Qn , a set F of at most n \u2212 2 faulty links in Qn and a node\nv \u2208 Qn and outputs two nodes v\n+ and v\u2212 of Qn. If we fix the parameters n and F\nand we run Find-Ham-Cycle-Hyper once for every node v of Qn as input then:\n13\n\u2022 the oriented graph induced by the directed links {(v,v+) : v \u2208 Qn} is an oriented\nHamiltonian cycle in Qn in which no faulty link appears; and\n\u2022 the oriented graph induced by the directed links {(v,v\u2212) : v \u2208 Qn} is the same\nHamiltonian cycle but oriented in the opposite direction.\nFurthermore, the algorithm Find-Ham-Cycle-Hyper has time complexity O(n4).\n6 Applying our algorithms\nAs stated earlier, our intention is to develop an algorithm for a distributed-memory\nmultiprocessor whose underlying interconnection network is, primarily, the k-ary n-\ncube or, secondarily, the n-dimensional hypercube, so that after execution of the\nalgorithm, every node knows its successor and a predecessor on a Hamiltonian cycle\nwithin the underlying network, even when at most 2n\u2212 2 links are faulty in the case\nof the k-ary n-cube or at most n\u2212 2 links are faulty in the case of the n-dimensional\nhypercube. Moreover, we should assume that each node only has local knowledge of\nwhich of its incident links are faulty. Clearly, we are almost done as all we need to\ndo is to arrange for all fault information to be disseminated throughout the network\nprior to execution of our algorithm. Luckily, considerable work as been done on this\nproblem.\nOne simple way of disseminating the fault information is to obtain a spanning tree\n(which contains only healthy links) of depth d. In a multi-port model, where nodes\ncan both transmit and receive messages to and from any number of neighbours in one\nstep, the time taken to disseminate all fault information is 2d. We are assuming, quite\nreasonably, that information relating to more than one fault can be bundled together\ninto one message, given that there are at most 2n \u2212 2 faults in the k-ary n-cube\nand the description of each fault can be squeezed into only n\u2308log(k)\u2309 + \u2308log(n)\u2309 + 1\nbits (the situation is even more favourable for the hypercube). In a one-port model,\nwhere in any one step any node can transmit at most one message to a neighbour\nand receive at most one message from a neighbour, the time taken is easily seen to\nbe at most 2d\u2206, where \u2206 is the maximal degree of any node of the tree (note that\na tree can be edge-coloured using at most \u2206 colours and this edge-colouring allows\nus to send messages along every bi-directional link in \u2206 steps). The above is only a\nvery rudimentary method for disseminating the fault information but is sufficient for\nour needs (this paper\u2019s main concern is with building Hamiltonian cycles rather than\nperforming all-to-all broadcasts).\nIn [23], it is shown that a k-ary n-cube has at least 2n link-disjoint spanning trees\nof depth at most n\u230ak\n2\n\u230b+k\u22121, and in [25] it is shown that an n-dimensional hypercube\nhas at least n link-disjoint spanning trees of depth at most n + 1. Hence, we have\nour distributed algorithms as described above. Note that our hypercube algorithm\nis vastly superior to that of Chan and Lee\u2019s (when incorporated within their model\nof computation) and also improves upon that of Leu and Kuo (as once we have\ndisseminated the fault information, we do not need to send any further messages).\nOf course, our distributed algorithm for the k-ary n-cube is the first such feasible\nalgorithm (irrespective of the underlying model of computation).\n14\nReferences\n[1] B. Almohammad and B. Bose, Fault-tolerant communication in toroidal net-\nworks, IEEE Trans. Parallel Distrib. Syst. 10 (1999) 976\u2013983.\n[2] J. Al-Sadi, K. Day and M. Ould-Khaoua, Unsafety vectors: a fault-tolerant\nrouting for k-ary n-cubes, Microprocess. Microsys. 25 (2001) 239\u2013246.\n[3] J. Al-Sadi, K. Day and M. Ould-Khaoua, Probability vectors: a new fault-\ntolerant routing algorithm for k-ary n-cubes, Proc. of. ACM Symp. on Applied\nComputing , ACM Press (2002) 830\u2013834.\n[4] J. Al-Sadi, K. Day and M. Ould-Khaoua, A new probabilistic approach for fault-\ntolerant routing in k-ary n-cubes, Proc. of 9th Int. Conf. on Parallel and Dis-\ntributed Systems, IEEE Press (2002) 509\u2013516.\n[5] E. Anderson, J. Brooks, C. Grassl and S. Scott, Performance of the Cray T3E\nmultiprocessor, Proc. of ACM\/IEEE Confrence on Supercomputing , ACM Press\n(1997) 1\u201317.\n[6] Y.A. Ashir and I.A. Stewart, Fault-tolerant embeddings of Hamiltonian circuits\nin k-ary n-cubes, SIAM J. Disc. Math. 15 (2002) 317\u2013328.\n[7] Y.A. Ashir and I.A. Stewart, On embedding cycles in k-ary n-cubes, Parallel\nProcess. Lett. 7 (1997) 49\u201355.\n[8] W.C. Athas and C.L. Seitz, Multicomputers: message-passing concurrent com-\nputers, Computer 21 (1988) 9\u201324.\n[9] S. Bettayeb, On the k-ary hypercube, Theoret. Comput. Sci. 140 (1995) 333\u2013339.\n[10] F. Bao, Y. Igarashi and R. O\u00a8hring, Reliability of hypercubes for broadcasting\nwith random faults, IEICE Trans. Inf. Syst. E79-D (1996) 22\u201328.\n[11] S. Borkar, R. Cohen, G. Cox, S. Gleason, T. Gross, H.T. Kung, M. Lam, B.\nMoore, C. Peterson, J. Pieper, L. Rankin, P.S. Tseng, J. Sutton, J. Urbanski\nand J. Webb, iWarp: An integrated solution to high-speed parallel computing,\nProc. of Supercomputing \u201988, IEEE Press (1988) 330\u2013339.\n[12] B. Bose, B. Broeg, Y. Kwon and Y. Ashir, Lee distance and topological properties\nof k-ary n-cubes, IEEE Trans. Computers 44 (1995) 1021\u20131030.\n[13] J. Bruck, On optimal broadcasting in faulty hypercubes, Disc. Applied Maths.\n53 (1994) 3\u201314.\n[14] Y. Bruck, R. Cypher and C.-T. Ho, Efficient fault-tolerant mesh and hypercube\narchitectures, Proc. of 22nd Int. Symp. on Fault-Tolerant Computing , IEEE\nPress (1992) 162\u2013169.\n[15] J.-P. Brunet and S.L. Johnsson, All-to-all broadcast and applications on the\nconnection machine, Int. J. Supercomput. Applications 6 (1992) 241\u2013256.\n15\n[16] M.Y. Chan and S.-J. Lee, On the existence of Hamiltonian circuits in faulty\nhypercubes, SIAM J. Disc. Maths. 4 (1991) 511\u2013527.\n[17] M.Y. Chan and S.-J. Lee, Distributed fault-tolerant embeddings of rings in hy-\npercubes, J. Parallel Dist. Comput. 11 (1991) 63\u201371.\n[18] S.-C. Chau and A. W.-C. Fu, An optimal (d\u2212 1)-fault-tolerant all-to-all broad-\ncasting scheme for d-dimensional hypercubes, Proc. of 3rd Int. Conf. on Parallel\nand Distributed Computing, Applications and Technologies, IEICE (2002) 351\u2013\n356.\n[19] G. Chiu, A fault-tolerant broadcasting algorithm for hypercubes, Inform. Process\nLett. 66 (1998) 93\u201399.\n[20] K. Day, The conditional node connectivity of the k-ary n-cube, J. Interconnect.\nNetworks 5 (2004) 13\u201326.\n[21] R. Duncan, A survey of parallel computer architectures, Computer 23 (1990)\n5\u201316.\n[22] T.H. Duncan, Performance of the Intel iPSC\/860 and Ncube 6400 hypercubes,\nParallel Comput. 17 (1991) 1285\u20131302.\n[23] P. Fraigniaud and C. Laforest, Disjoint spanning trees of small depth, Proc.\nof Parallel Computing : Trends and Application (G. Joubert, D. Trystram, F.\nPeters, D.Evans, eds.), Elsevier (1994) 105-112.\n[24] J. Fu, Fault-tolerant cycle embedding in the hypercube, Parallel Comput. 29\n(2003) 821\u2013832.\n[25] S.L. Johnsson and C.T. Ho, Optimum broadcasting and personalized communi-\ncation in hypercubes, IEEE Trans. Comput. 38 (1989) 1249\u20131268.\n[26] R.E. Kessler and J.L. Schwarzmeier, CRAY T3D: a new dimension for Cray\nresearch, Proc. of 38th IEEE Computer Society Int. Conf., IEEE Press (1993)\n176\u2013182.\n[27] S. Latifi, S.Q. Zheng and N. Bagherzadeh, Optimal ring embedding in hypercubes\nwith faulty links, Proc. of 22nd Int. Symp. on Fault-Tolerant Computing , IEEE\nPress (1992) 178\u2013184.\n[28] S. Latifi, S.Q. Zheng and N. Bagherzadeh, Hamiltonian path and cycle in hy-\npercubes with faulty links, Proc. of 5th IEEE Int. Conf. on Algorithms and\nArchitectures for Parallel Processing, IEEE Press (2002) 178\u2013184.\n[29] F.T. Leighton, Introduction to Parallel Algorithms and Architectures: Arrays.\nTrees. Hypercubes, Morgan Kaufmann (1992).\n[30] Y. Leu and S. Kuo, Distributed fault-tolerant ring embedding and reconfiguration\nin hypercubes, IEEE Trans. Comput. 48 (1999) 81\u201388.\n[31] T. Li, C. Tsai, J. Tan and L. Hsu, Bipanconnectivity and edge-fault-tolerant\nbipanciclicity of hypercubes, Inform. Process Lett. 87 (2003) 107-110.\n16\n[32] M.D. Noakes, D.A. Wallach and W.J. Dally, The J-machine multicomputer: an\narchitectural evaluation, Proc. of 20th Ann. Int. Symp. on Computer Architec-\nture, IEEE Press (1993) 224\u2013235.\n[33] S. Park and B. Bose, Broadcasting in hypercubes with link\/node failures, Proc.\nof 4th Symp. on Frontiers of Massively Parallel Computation, IEEE Press (1992)\n286\u2013290.\n[34] S. Park and B. Bose, All-to-all broadcasting in faulty hypercubes, IEEE Trans.\nComput. 46 (1997) 749\u2013755.\n[35] D. Peleg, A note on optimal time broadcast in faulty hypercubes, J. Parallel\nDist. Comput. 26 (1995) 132\u2013135.\n[36] C.S. Raghavendra and M.A. Sridhar, Dimension ordering and broadcast algo-\nrithms in faulty SIMD hypercubes, J. Parallel Dist. Comput. 35 (1996) 57\u201366.\n[37] C.L. Seitz, The Cosmic Cube, Comm. Assoc. Comput. Mach. 28 (1985) 22\u201333.\n[38] C.L. Seitz, W.C. Athas, C.M. Flaig, A.J. Martin, J. Scizovic, C.S. Steele and\nW.-K. Su, Submicron systems architecture project semiannual technical report,\nCalifornia Inst. of Technology Tech. Rep. Caltec-CS-TR-88-18 (1988).\n[39] A. Sengupta, On ring embedding in hypercubes with faulty nodes and links,\nInform. Process Lett. 68 (1998) 207\u2013214.\n[40] C. Tsai, J. Tan, T. Liang and L. Hsu, Fault-tolerant hamiltonian laceability of\nhypercubes, Inform. Process Lett. 83 (2002) 301\u2013306.\n[41] C. Tsai, Linear array and ring embeddings in conditional faulty hypercubes,\nTheoret. Comput. Sci. 314 (2004) 431\u2013443.\n[42] Y. Tseng, Embedding a ring in a hypercube with both faulty links and faulty\nnodes, Inform. Process Lett. 59 (1996) 217\u2013222.\n[43] S.-C. Wang, Y.-R. Leu and S.-Y. Kuo, Distributed fault-tolerant embedding of\nseveral topologies in hypercubes, J. Inf. Sci. Eng. 20 (2004) 707\u2013732.\n[44] J. Wu, An optimal fault-tolerant nonredundant broadcasting scheme in injured\nhypercubes, J. Parallel Distrib. Comput. 22 (1994) 295\u2013313.\n[45] J. Wu, Optimal broadcasting in hypercubes with link faults using limited global\ninformation, J. Syst. Architect. 42 (1996) 367\u2013380.\n[46] J.-M. Xu, Z.-Z. Du and M. Xu, Edge-fault-tolerant bipancyclicity of hypercubes,\nInform. Process Lett. 96 (2005) 146-150.\n17\n"}