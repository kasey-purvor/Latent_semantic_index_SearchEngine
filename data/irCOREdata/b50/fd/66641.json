{"doi":"10.1109\/SCAM.2004.21","coreId":"66641","oai":"oai:dro.dur.ac.uk.OAI2:645","identifiers":["oai:dro.dur.ac.uk.OAI2:645","10.1109\/SCAM.2004.21"],"title":"Some notes on interprocedural program slicing.","authors":["Gallagher,  K. B."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2004-09","abstract":"Weiser's algorithm for computing interprocedural slices has a\\ud\nserious drawback: it generates spurious criteria which are not\\ud\nfeasible in the control flow of the program.  When these extraneous\\ud\ncriteria are used the slice becomes imprecise in that it has\\ud\nstatements that are not relevant to the computation.  Horwitz, Reps\\ud\nand Binkley solved this problem by devising the System Dependence\\ud\nGraph with an associated algorithm that produced more precise\\ud\ninterprocedural slices.  We take a ``step backward'' and show how to\\ud\ngenerate exactly the interprocedural slicing criteria needed, using\\ud\nthe program's call graph or a stack. This technique can also be used\\ud\non a family of program dependence graphs that represent all procedures\\ud\nin a program and are not interconnected by a system dependence graph. Then\\ud\nwe show how to use the Horwitz, Reps and Binkley interprocedural\\ud\nslicing algorithm to generate criteria and show that the criteria so\\ud\ngenerated are equal to those generated by the call-graph\/stack\\ud\ntechnique.  Thus we present alternative, equivalent ways to generate\\ud\nprecise slicing criteria across procedure boundaries.  And finally we\\ud\nshow that under certain circumstances, Weiser's technique for slicing\\ud\nacross procedures is a bit ``too strong,'' for it always generates\\ud\nsufficient criteria to obtain the entire program as a slice on any\\ud\ncriteria","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66641.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/645\/1\/645.pdf","pdfHashValue":"e6d73e6ca6d1127ec628df59a8f28feb7e14d7a6","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:645<\/identifier><datestamp>\n      2011-06-15T15:55:50Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Some notes on interprocedural program slicing.<\/dc:title><dc:creator>\n        Gallagher,  K. B.<\/dc:creator><dc:description>\n        Weiser's algorithm for computing interprocedural slices has a\\ud\nserious drawback: it generates spurious criteria which are not\\ud\nfeasible in the control flow of the program.  When these extraneous\\ud\ncriteria are used the slice becomes imprecise in that it has\\ud\nstatements that are not relevant to the computation.  Horwitz, Reps\\ud\nand Binkley solved this problem by devising the System Dependence\\ud\nGraph with an associated algorithm that produced more precise\\ud\ninterprocedural slices.  We take a ``step backward'' and show how to\\ud\ngenerate exactly the interprocedural slicing criteria needed, using\\ud\nthe program's call graph or a stack. This technique can also be used\\ud\non a family of program dependence graphs that represent all procedures\\ud\nin a program and are not interconnected by a system dependence graph. Then\\ud\nwe show how to use the Horwitz, Reps and Binkley interprocedural\\ud\nslicing algorithm to generate criteria and show that the criteria so\\ud\ngenerated are equal to those generated by the call-graph\/stack\\ud\ntechnique.  Thus we present alternative, equivalent ways to generate\\ud\nprecise slicing criteria across procedure boundaries.  And finally we\\ud\nshow that under certain circumstances, Weiser's technique for slicing\\ud\nacross procedures is a bit ``too strong,'' for it always generates\\ud\nsufficient criteria to obtain the entire program as a slice on any\\ud\ncriteria.  <\/dc:description><dc:subject>\n        Algorithm<\/dc:subject><dc:subject>\n         System dependence graph.<\/dc:subject><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        4th IEEE International Workshop on Source Code Analysis and Manipulation : SCAM-4, Chicago, Illinois, 15-16 September 2004 [Conference proceedings]<\/dc:source><dc:date>\n        2004-09<\/dc:date><dc:type>\n        Conference item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:645<\/dc:identifier><dc:identifier>\n        doi:10.1109\/SCAM.2004.21<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/645\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/SCAM.2004.21<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/645\/1\/645.pdf<\/dc:identifier><dc:rights>\n        \u00a92004 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2004,"topics":["Algorithm","System dependence graph."],"subject":["Conference item","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n27 May 2008\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nGallagher, K. B. (2004) \u2019Some notes on interprocedural program slicing.\u2019, 4th IEEE International Workshop\non Source Code Analysis and Manipulation : SCAM-4. Chicago, Illinois, 15-16 September 2004.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/SCAM.2004.21\nPublisher\u2019s copyright statement:\n2004 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nSome Notes on Interprocedural Program Slicing\nK. B. Gallagher\u2217\nComputer Science Department\nUniversity of Durham\nSouth Road\nDurham DH1 3LE, UK\nk.b.gallagher@durham.ac.uk\nAbstract\nWeiser\u2019s algorithm for computing interproce-\ndural slices has a serious drawback: it gen-\nerates spurious criteria which are not fea-\nsible in the control flow of the program.\nWhen these extraneous criteria are used the\nslice becomes imprecise in that it has state-\nments that are not relevant to the computa-\ntion. Horwitz, Reps and Binkley solved this\nproblem by devising the System Dependence\nGraph with an associated algorithm that pro-\nduced more precise interprocedural slices. We\ntake a \u201cstep backward\u201d and show how to gen-\nerate exactly the interprocedural slicing crite-\nria needed, using the program\u2019s call graph or\na stack. This technique can also be used on\na family of program dependence graphs that\nrepresent all procedures in a program and are\nnot interconnected by a system dependence\ngraph. Then we show how to use the Horwitz,\nReps and Binkley interprocedural slicing al-\ngorithm to generate criteria and show that\nthe criteria so generated are equal to those\ngenerated by the call-graph\/stack technique.\nThus we present alternative, equivalent ways\nto generate precise slicing criteria across pro-\ncedure boundaries. And finally we show that\nunder certain circumstances, Weiser\u2019s tech-\nnique for slicing across procedures is a bit\n\u201ctoo strong,\u201d for it always generates suffi-\ncient criteria to obtain the entire program as\na slice on any criteria.\n\u2217On leave from Loyola College in Maryland\n1 Introduction\nProgram slicing is a pretty simple idea. It\u2019s fun-\ndamental concepts are easily grasped by novices. It\u2019s\na good idea because it applies to many problem do-\nmains; who doesn\u2019t want help in restricting a compli-\ncated problem to the relevant focus of inquiry?\nWe are so familiar with the concepts and arcana\nof program slicing that we are liable to forget that\nthere are some deep and sophisticated concepts \u201cun-\nder the hood;\u201d when it comes to actually construct-\ning algorithms, data structures and especially writing\na program slicer, significant difficulties arise. (Note:\nhow many production quality slicers do you know of?\nAnd as soon as you know of one you ask: \u201cDoes it\nwork on language \/ dialect X?\u201d The answer to the\nsecond question is usually negative.) The problems\nare myriad: getting the language to an invertible rep-\nresentation, so that the statements not in the slice are\nelided; implementing slicing algorithms on the repre-\nsentation; consideration of parameter passing, object\ncreation and aliasing. . . . Then we move on to im-\nproved algorithms, better data structures; it seems\nevery technical conference has an \u201cImproved Slicing\u201d\npaper. Indeed, the Source Code and Manipulation\nConference (SCAM) is one of the venues in which one\ncan discuss these sophisticated ideas without the ne-\ncessity of a fully functioning slicing system and an\napplication on which it can be applied.\nThis paper is the result of a series lectures that\nthe author gave at the University of Durham, enti-\ntled \u201cProgram Slicing.\u201d The audience was third (final)\nyear students in Computer Science and Software En-\ngineering. The initial lectures were as above: This is\na slice (Everybody understands.) Here is how to com-\npute one. The fog of confusion rolls in. (Followed by\nthe question: \u201cAre you going to make us write one?\u201d)\nThe following lecture approach was used. Use the\nsimple data-flow control-flow approach outlined by\nWeiser, so that the computational concepts were un-\nderstood; followed by the Program Dependence \/ Sys-\ntem Dependence Graph (PDG\/SDG) approach to im-\nprove the algorithms and address weaknesses of the\ndata-flow control-flow method. The results from the\nearly method could be used to check solutions and\ncompare for accuracy with the SDG approach.\nThe particular problem was interprocedural pro-\ngram slicing. The ideas for this paper came while\npreparing and giving the lectures and as such do not\noffer any improved technique for computing slices. It\nwas in trying to explain these concepts that some in-\nsights and simplifications came that connected some\nheretofore unnoticed concepts. These connections\nhelped the students understand the central point of\nthe lectures: how to compute an interprocedural pro-\ngram slice.\nFirst, we show how to generate exactly the inter-\nprocedural slicing criteria needed, using the call graph.\nThen we show how to use the Horwitz, Reps and\nBinkley[2] interprocedural slicing algorithm (hereafter\nreferred to as the \u201cHRB algorithm\u201d or just \u201cHRB\u201d)\ncan also be used to generate criteria and show that the\ncriteria so generated are equal to those generated by\nthe call-graph technique. Thus we present an alterna-\ntive, equivalent way to generate precise slicing crite-\nria across procedure boundaries. And finally we show\nthat under certain circumstances, Weiser\u2019s technique\nfor slicing across procedures is a bit \u201ctoo strong,\u201d for it\nalways generates sufficient criteria to obtain the entire\nprogram as a slice on any criteria.\n2 Background\nWieser\u2019s paper on program slicing [4] has a method\nfor going through procedure calls.\nFor each criterion C for a procedure P,\nthere is a set of criteria UP0(C) which are\nthose needed to slice callers of P and a\nset DOWN0(C) which are those needed to\nslice procedures called by P . . . UP0(C) and\nDOWN0(C) can be extended by functions\nUP and DOWN which map sets of criteria\ninto sets of criteria. Let CC be any set of\ncriteria. Then\nUP(CC) =\n\u22c3\nC\u2208CC\nUP0(C)\nmain {\nsum := 0;\ni := 1;\nwhile (i < 11) do\ncall A( sum, i);\nod;\nend\nA (x, y) {\ncall Add(x,y);\ncall Increment(y);\nreturn;\n}\nAdd (a, b) {\na = a + b;\nreturn;\n}\nIncrement ( z ) {\nCall Add ( z, 1);\nreturn;\n}\nFigure 1: Interprocedural program from [2] used for\nillustration.\nDOWN(CC) =\n\u22c3\nC\u2208CC\nDOWN0(C)\nThe union and transitive closure are de-\nfined in the usual way for relations.\n(UP\u222aDOWN)\u2217 will map any set of criteria\ninto all those necessary to to complete the\ncorresponding slices through all calling and\ncalled routines. The complete interprocedu-\nral slice for criterion C is then just the union\nof the interprocedural slices for each criterion\nin (UP\u222aDOWN)\u2217(C).\nThe noted problem with Weiser\u2019s method is the\ngeneration of too many criteria which are extraneous\nto the program\u2019s feasible call graph. Criteria are gen-\nerated which has a procedure returning from one other\nthan the one from which it was called. An inspection\nof the call graph of Figure 2 shows what the problem\nis: When slicing from procedure Increment a criterion\nis generated that goes DOWN into Add; from there a\ncriterion is generated that goes UP into A. It is this\ncriterion that does not respect the feasibility of return\nFigure 2: Call graph of the program of Figure 1.\nfrom Increment through A.\nHorwitz, et al., [2] present a thorough discussion of\nthis problem:\nUsing Weiser\u2019s algorithm to slice this pro-\ngram with respect to the the variable z and\nthe return statement of procedure Incre-\nment, we obtain everything from the origi-\nnal program. . . . The reason these compo-\nnents are included in the slice computed by\nWeiser\u2019s algorithm is as follows: The initial\ncrite-\nrion \u201c<end of procedure Increment, z >\u201d is\nmapped by the DOWN relation to a slicing\ncriteria \u201c<end of procedure Add, a >.\u201d The\nlatter criterion is then mapped by the UP\nrelation to two slicing criteria \u2014 correspond-\ning to all the sites that call Add \u2014 the\ncriterion \u201c<call on Add in Increment, z >\u201d\nand the (irrelevant) criterion\n\u201c<call on Add in A, x >.\u201dWieser\u2019s\nalgorithm does not produce as precise a\nslice as possible because transitive closure\nfails to account for the calling context\n(Increment) of a called procedure (Add)\nand thus generates a spurious criterion\n(<call on Add in Increment, z >).\n. . . The chief difficulty in interprocedural slic-\ning is correctly accounting for the calling con-\ntext of a called procedure.\nRecall that the HRB language is a simple but suf-\nficient reduction of production languages, and that in\ntheir model, parameters are passed by value result.\nWe will use a <ProcedureName.VariableName,\npoint> form to refer to criteria. For example,\nthe criteria used in the HRB example will now be\nnoted <Increment.z, return>. When a criterion\nis placed in a code sample the point will be omitted:\n<Increment.z>. Only the variable of interest will be\nnoted as the point of interest is precisely where the\ncriterion is inserted.\n3 Generating Accurate Interprocedu-\nral Criteria\nThe problem of extraneous criteria arose from the\ngeneration of a criterion from a return back through\nan uncalled procedure; we want to eliminate this cri-\nterion. That is, we only want criteria that are on\nfeasible call paths. The feasible call sequences can be\nobtained from an inspection of a slightly modified call\ngraph, described next.\nThe call graph of Figure 3 has the same informa-\ntion as that of Figure 2, albeit in a different form. In\nFigure 3 each call to Add is noted explicitly. Using this\ngraph it is relatively straightforward to get the precise\ncriteria. Starting with the criteria <Increment.z,\nreturn>, we go DOWN into procedure Add and get\ncriteria <Add.a, return>. Once we have gone back-\nward across Add we go back UP into Increment with\ncriteria <Increment.z, Call Add>. We have con-\ncluded slicing across Increment and now go UP into\nA with criteria <A.y, Call Increment>. Proceeding\nbackward, we go DOWN into Add again with criteria\n<Add.b, return> (collecting no statements as vari-\nable Add.b is not defined) and come back UP with cri-\nteria <A.y, Call Add>, and so on. Figure 4 shows\nthe program of Figure 1 with the criteria inserted as\nthey were produced in this discussion.\nWhat we have done here is to \u201cslow down\u201d the\ngeneration of criteria and insert them only as needed\nfrom the context. Weiser\u2019s UP\/DOWN relations, in\nan attempt to generate complete criteria early in the\nslicing process, generate the infeasible criteria. The\nabove method is akin to the Weiser\u2019s original approach\nof adding referenced variables to the original slicing\ncriterion as they were needed. For instance, when\na statement was determined to be in the slice, all\nvariables referenced in all controlling predicates were\nadded to the current slicing criteria. Of course, this\nonly works in the iterative data-flow control-flow tech-\nnique that Weiser used. This method is not suited to\nthe PDG\/SDG of HRB in which slices can be taken\nonly where a variable is defined or referenced, unless\nthe structure is augmented. It does, however, help the\nstudents grasp what is going on as an inter-procedural\nslice is computed. And it helps the student grasp some\nof subtlety of the HRB technique.\nThis procedure can also be done without explicit\nreference to the modified call graph. A stack with a\ncan be used to keep track of the calling context. The\nintuitive mapping of the DOWN operations to push\nand the UP operations to pop fails. Consider the ex-\nample of Figure 4 in which there is one DOWN fol-\nlowed by two UPs. A simple generalization of UP\nand DOWN to ENTER and LEAVE, regardless of\nthe UP\/DOWN direction suffices nicely. We EN-\nTER a procedure, without regard to direction (UP\nor DOWN), slice through the procedure and LEAVE\nit, without regard to the direction. If, while slicing\nthrough a procedure, we ENTER another procedure,\nwe will get a corresponding LEAVE. Now we map EN-\nTER and LEAVE to push and pop and the problem\nof popping an empty stack goes away. This is similar\nto the realizable path (balanced parentheses) approach\nused in [3].\nThis still leaves the problem of recursive calls,\nwhich fortunately can be easily addressed by using a\nset to guard the insertion of criteria. More precisely,\nregard each criterion as an element of a set. Then,\nbefore each ENTER (push) operation, we determine\nif the new candidate criterion is in the set of criteria.\nIf it is not, we continue as above; if it is in the set, do\nnothing.\nBy using a call graph or a stack, we have accounted\nfor the calling context and give an accessible solution\nto the spurious criterion problem. To reiterate, the\npoint of this section is to show students how slicing\ncriteria can be accurately generated in a data-flow\ncontrol-flow environment. Once they understand this,\nit is easier for them to comprehend the SDG approach.\n4 Using SDG\u2019s to Generate Slicing\nCriteria\nThis section shows a few ways to use SDG\u2019s to gen-\nerate the same criteria that were derived in the previ-\nous section. This can be done by noting that the SDG\nhas a call graph embedded in it. The call graph is\nembedded in the call-enter portion of the SDG. See\nFigure 5. Since we know how to use the call graph to\ngenerate criteria, we can use this embedded call graph\nto generate criteria. This is not a typical use of the\nSDG!\nFigure 3: Call graph of the program of Figure 1 with\neach procedure call\/return made explicit.\n4.1 Linkage Grammars\nA linkage grammar is used in HRB to compute the\ntransitive dependence due to procedure calls. The\nlinkage grammar is an attribute grammar. The at-\ntributes of the linkage grammar are used the obtain\nthe in\/out variable flow across procedure boundaries;\nits context free part is used to determine the calling\nstructure (the call graph). This context free part to\ngenerates a call tree. This is also similar to the realiz-\nable path approach used in [3]. Once we have the call\ntree in place, we proceed as previously outlined.\nThe HRB algorithm may also be used to emit crite-\nria. The HRB algorithm proceeds in two phases. The\nfirst phase delivers the slice that is above the proce-\ndure of interest; that is it \u201cidentifies veritices that can\nreach [variable] s [in procedure P], and are either in\nP itself or a procedure that calls P. . . \u201d[2]. The sec-\nond phase does the other half of the work: it follows\n(transitively) the flows that reach s when called by P.\nThis gives an alternative (explanatory) names to\nsome of the edges added to PDG\u2019s to create an\nSDG. The parameter-out edges are the not-followed-\nin-phase-1 edges. (Why this is so makes a good\nexam question.) Similarly, the parameter-in and call\nedges are not-followed-in-phase-2 edges. (Another\ngood exam question!)\n4.2 A Combined Method\nSo, in the middle of the System Dependence Graph\nlecture (as the students\u2019 eyes are clouding over, trying\nmain {\nsum := 0;\ni := 1;\nwhile (i < 11) do\ncall A( sum, i);\nod;\nend\nA (x, y) {\n\/* 6. < A.y >\nUP from Add *\/\ncall Add(x,y);\n\/* 4. < A.y >\nUP from Increment *\/\ncall Increment(y);\nreturn;\n}\nAdd (a, b) {\na = a + b;\nreturn;\n\/* 2. < Add.a >\nDOWN from INCREMENT\nusing the call graph *\/\n\/* 5. < Add.b >\nthis time DOWN from Add *\/\n}\nIncrement ( z ) {\n\/* 3. < Increment.z >\ncoming UP from Add *\/\nCall Add ( z, 1);\nreturn;\n\/* 1. <Increment.z> *\/\n}\nFigure 4: Program from [2] and Figure 1 with criteria\ninserted as C comments and showing the order in which\nthey were inserted.\nto keep all the new edge and vertex types in their\nheads) I ask \u201cCan we do this with out the System\nDependence Graph?\u201d. It turns out that the answer is\n\u201cyes.\u201d\nInstead of building the SDG, we build only a named\nfamily of PDG\u2019s, joined by a call-graph. Starting at\nthe relevant point in the procedure of interest, we\nchase the edges in each procedure\u2019s PDG. Crossing\nover a Call we match up the parameters and gener-\nate a new criteria for the called procedure, F . Slice\nacross that and so on. Then when slicing across F is\nconcluded, map the parameters from F back to the\ncaller. When an enter node is traversed in the PDG,\ngenerate new criteria for each procedure that calls,\nand continue.\nThis is the same approach as outlined in section 3.\nThis is a one-pass linear time method. It is one pass\nbecause we are using the as-needed technique for cri-\nteria generation and one-pass because we are using the\nPDG.\n4.3 Are They The Same Criteria?\nThe argument the emitted criteria are the same\ncomes from the observation that they are generated\nfrom the (perhaps embedded) call-graph and not from\nthe SDG\/PDG or the control-flow graph. As we pass\nup or down marking the calling sequence, the form\nfrom which the criteria are generated is moot.\nNote that this uses SDG\u2019s to generate the criteria,\nnot the slice.\n5 Concurrent Assignments\nThere is one more observation to be made in rela-\ntion to slicing across procedure boundaries. Reps, et\nal. [3] note:\nA procedure call is treated like a mul-\ntiple [concurrent] assignment statement\n\u201cv1, v2, . . . , vn := x1, x2, . . . , xm[sic]\u201d, where\nthe vi are the set of variables that might be\nmodified by the call, and the xj are the set\nof variables that might be used by the call.\nThus, the value of every vi is assumed to de-\npend on the value of of every xj before the\ncall. This may lead to an overly conserva-\ntive slice (i.e., one that includes extra com-\nponents. . . )\nIn Weiser\u2019s slicing method, we then have that the\nDEF\u2019ed set of the above statement is {v1, v2, . . . , vn}\nwhile the REF\u2019ed set is {x1, x2, . . . , xm}. This would\nmean that when any of the xi are REF\u2019ed, all of the\nvi are DEF\u2019ed. A program slice in a language that\nuses value-result parameter passing, as in HRB, must\nproceed carefully when slicing across concurrent as-\nsignment statements. In this context, if a concurrent\nassignment is used to map actuals to formals, then\nwhen any actual parameter is passed, all formal pa-\nrameters are captured. This is clearly too strong and\nwould lead to the entire procedure being included in\nthe slice, along with all calling and called procedures:\nthe whole program! (If a procedure were not in such\na slice, it would be dead code.)\nThis situation can be easily remedied by serializing\nthe concurrent assignment as described in [1], chapter\n3.\n6 Conclusion\nInterprocedural slicing is an interesting problem.\nGetting the criteria correct across calls and returns\nrequires careful attention to detail. Attending to the\nfeasible calling sequences adds another layer of partic-\nulars. The System Dependence Graph and its associ-\nated algorithms solve all of these problem all at once.\nThis is why is it is a superior representation.\nTrying to learn about interprocedural program slic-\ning is another matter. It helps the novice to have the\nboth the issues and their respective solutions broken\ninto more accessible concepts. Once these individual\nproblems and solutions are discussed, the true power\nand beauty of the SDG representation can be fully\nappreciated. This paper has given some direction on\nhow to do that.\nThanks to Liz Burd, for reminding me that call-\ngraphs are different from control-flow graphs, and the\nreferees, for improving the presentation.\nReferences\n[1] J. Gannon, J. Purtilo, and M. Zelkowitz. Software\nSpecification: A Comparison of Formal Methods.\nAblex, 1994.\n[2] S. Horwitz, T. Reps, and D. Binkley. Interprocedu-\nral slicing using dependence graphs. ACM Trans-\nactions on Programming Languages and Systems,\n12(1):35\u201346, January 1990.\n[3] T. Reps, S. Horwitz, M. Sagiv, and G. Rosay.\nSpeeding up slicing. In Proceedings of the Sec-\nond ACM SIGSOFT Symposium on Foundations\nof Software Engineering, pages 11\u201320, 1994. Pub-\nlished in ACM SIGSOFT Notes v19 n4.\n[4] M. Weiser. Program slicing. IEEE Transactions\non Software Engineering, 10:352\u2013357, July 1984.\n\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\nENTER Main\nsum := 0 i := 1 while i < 11\ncall A\nFinalUse(sum) FinalUse(i)\nx_in := sum y_in := i sum := x_out i := y_out\nENTER A\ncall Addx := x_in y := y_in call Inc x_out := x y_out := y\na_in := x b_in := y x := a_out y := b_out z_in := y y := z_out\nENTER Inc\nz := z_in call Add z_out := z\na_in := z b_in := 1 z := a_out\nENTER Add\na := a_in b := b_in a := a + b a_out := a b_out := b\nEdge Key\ncontrol\nintraprocedural flow\n(loop-independent)\n| intraprocedural flow(loop-carried)\ninterprocedural flow\ncall,parameter-in,parameter-out\n\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\nExample system\u2019s system dependence graph. Control dependences, shown unlabeled, are represented using\nmedium-bold arrows; intraprocedural flow dependences are represented using arcs; transitive interprocedural flow\ndependences (corresponding to subordinate characteristic graph edges) are represented using heavy bold arcs; call\nedges, parameter-in edges, and parameter-out edges (which connect program and procedure dependence graphs togeth-\ner) are represented using dashed arrows.\nFigure 5: System Dependence Graph of Figure 1.\nUsed by permission.\n"}