{"doi":"10.1007\/978-3-642-04761-9_14","coreId":"65308","oai":"oai:dro.dur.ac.uk.OAI2:6241","identifiers":["oai:dro.dur.ac.uk.OAI2:6241","10.1007\/978-3-642-04761-9_14"],"title":"Memory usage verification using Hip\/Sleek.","authors":["He, G.","Qin, S.","Luo, C.","Chin , W.-N."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Liu, Z.","Ravn, A. P."],"datePublished":"2009-10-01","abstract":"Embedded systems often come with constrained memory footprints. It is therefore essential to ensure that software running on such platforms fulfils memory usage specifications at compile-time, to prevent memory-related software failure after deployment. Previous proposals on memory usage verification are not satisfactory as they usually can only handle restricted subsets of programs, especially when shared mutable data structures are involved. In this paper, we propose a simple but novel solution. We instrument programs with explicit memory operations so that memory usage verification can be done along with the verification of other properties, using an automated verification system Hip\/Sleek developed recently by Chin et al.[10,19]. The instrumentation can be done automatically and is proven sound with respect to an underlying semantics. One immediate benefit is that we do not need to develop from scratch a specific system for memory usage verification. Another benefit is that we can verify more programs, especially those involving shared mutable data structures, which previous systems failed to handle, as evidenced by our experimental results","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65308.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6241\/1\/6241.pdf","pdfHashValue":"ad4849a11d54cfcb1b3e4cbe2760ec03a56b77f2","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6241<\/identifier><datestamp>\n      2015-03-31T11:45:58Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Memory usage verification using Hip\/Sleek.<\/dc:title><dc:creator>\n        He, G. <\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Luo, C.<\/dc:creator><dc:creator>\n        Chin , W.-N.<\/dc:creator><dc:description>\n        Embedded systems often come with constrained memory footprints. It is therefore essential to ensure that software running on such platforms fulfils memory usage specifications at compile-time, to prevent memory-related software failure after deployment. Previous proposals on memory usage verification are not satisfactory as they usually can only handle restricted subsets of programs, especially when shared mutable data structures are involved. In this paper, we propose a simple but novel solution. We instrument programs with explicit memory operations so that memory usage verification can be done along with the verification of other properties, using an automated verification system Hip\/Sleek developed recently by Chin et al.[10,19]. The instrumentation can be done automatically and is proven sound with respect to an underlying semantics. One immediate benefit is that we do not need to develop from scratch a specific system for memory usage verification. Another benefit is that we can verify more programs, especially those involving shared mutable data structures, which previous systems failed to handle, as evidenced by our experimental results.<\/dc:description><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Liu, Z. & Ravn, A. P. (Eds.). (2009). Automated technology for verification and analysis : 7th International Symposium, ATVA 2009, 14-16 October, 2009, Macao, China ; proceedings. Berlin: Springer, pp. 166-181, Lecture notes in computer science(5799)<\/dc:source><dc:contributor>\n        Liu, Z.<\/dc:contributor><dc:contributor>\n        Ravn, A. P.<\/dc:contributor><dc:date>\n        2009-10-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6241<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/978-3-642-04761-9_14<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6241\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/978-3-642-04761-9_14<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6241\/1\/6241.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/978-3-642-04761-9_14<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2009,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nHe, G. and Qin, S. and Luo, C. and Chin , W.-N. (2009) \u2019Memory usage verification using Hip\/Sleek.\u2019, in\nAutomated technology for verification and analysis : 7th International Symposium, ATVA 2009, 14-16\nOctober, 2009, Macao, China ; proceedings. Berlin: Springer, pp. 166-181. Lecture notes in computer science.\n(5799).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/978-3-642-04761-914\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nHe, G. and Qin, S. and Luo, C. and Chin , W.-N. (2009) 'Memory usage verification using \nHip\/Sleek.', in Automated technology for verification and analysis : 7th International \nSymposium, ATVA 2009, 14-16 October, 2009, Macao, China ; proceedings. Berlin: \nSpringer, pp. 166-181. Lecture notes in computer science. (5799). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/978-3-642-04761-9_14 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nMemory Usage Verification Using Hip\/Sleek\nGuanhua He1, Shengchao Qin1, Chenguang Luo1, and Wei-Ngan Chin2\n1 Durham University, Durham DH1 3LE, UK\n2 National University of Singapore\n{guanhua.he,shengchao.qin,chenguang.luo}@durham.ac.uk,\nchinwn@comp.nus.edu.sg\nAbstract. Embedded systems often come with constrained memory\nfootprints. It is therefore essential to ensure that software running on\nsuch platforms fulfils memory usage specifications at compile-time, to\nprevent memory-related software failure after deployment. Previous pro-\nposals on memory usage verification are not satisfactory as they usually\ncan only handle restricted subsets of programs, especially when shared\nmutable data structures are involved. In this paper, we propose a simple\nbut novel solution. We instrument programs with explicit memory op-\nerations so that memory usage verification can be done along with the\nverification of other properties, using an automated verification system\nHip\/Sleek developed recently by Chin et al. [10,19]. The instrumen-\ntation can be done automatically and is proven sound with respect to\nan underlying semantics. One immediate benefit is that we do not need\nto develop from scratch a specific system for memory usage verification.\nAnother benefit is that we can verify more programs, especially those\ninvolving shared mutable data structures, which previous systems failed\nto handle, as evidenced by our experimental results.\n1 Introduction\nUbiquitous embedded systems are often supplied with limited memory and com-\nputation resources due to various constraints on, e.g., product size, power con-\nsumption and manufacture cost. The consequences of violating memory safety\nrequirements can be quite severe because of the close coupling of these systems\nwith the physical world; in some cases, they can put human lives at risk. The\nMars Rover\u2019s anomaly problem was actually due to a memory leak error and it\ntook fifteen days to fix the problem and bring the Rover back to normal [21]. For\napplications running on resource-constrained platforms, a challenging problem\nwould be how to make memory usage more predictable and how to ensure that\nmemory usage fulfils the restricted memory requirements.\nTo tackle this challenge, a number of proposals have been reported on mem-\nory usage analysis and verification, with most of them focused on functional\nprograms where data structures are mostly immutable and thus easier to han-\ndle [1,2,5,7,15,23]. Memory usage verification for imperative\/OO languages can\nbe more challenging due to mutability of states and object sharing. Existing so-\nlutions to this are mainly type-based [11,12,16]. Instead of capturing all aliasing\nZ. Liu and A.P. Ravn (Eds.): ATVA 2009, LNCS 5799, pp. 166\u2013181, 2009.\nc\u00a9 Springer-Verlag Berlin Heidelberg 2009\nMemory Usage Verification Using Hip\/Sleek 167\ninformation, they impose restrictions on object mutability and sharing. There-\nfore, they can only handle limited subsets of programs manipulating shared\nmutable data structures.\nThe emergence of separation logic [17,22] promotes scalable reasoning via ex-\nplicit separation of structural properties over the memory heap where recursive\ndata structures are dynamically allocated. Since then, dramatic advances have\nbeen made in automated software verification via separation logic, e.g. the Small-\nfoot tool [3] and the Space Invader tool [6,13,24] for the analysis and verification\non pointer safety (i.e. shape properties asserting that pointers cannot go wrong),\nthe Hip\/Sleek tool [10,18,19] for the verification of more general properties in-\nvolving both structural (shape) and numerical (size) information, the verification\non termination [4], and the verification for object-oriented programs [9,14,20].\nGiven these significant advances in the field, a research question that we post\nto ourselves is: can we make use of some of these state-of-the-art verification tools\nto do a better job for memory usage verification, without the need of construct-\ning a memory usage verifier from scratch? This paper addresses this question\nby proposing a simple but novel mechanism to memory usage verification using\nthe Hip\/Sleek system developed by Chin et al. [10,19]. Separation logic offers\na powerful and expressive mechanism to capture structural properties of shared\nmutable data structures including aliasing information. The specification mech-\nanism in Hip\/Sleek leverages structural properties with numerical information\nand is readily capable for the use of memory usage specification.\nApproach and contributions.Memory usage occur in both the heap and stack\nspaces. While heap space is used to store dynamically allocated data structures,\nstack memory is used for local variables as well as return addresses of method\ncalls. On the specification side, we assume that two special global variables heap\nand stk of type int are reserved to represent respectively the available heap\nand stack memory in the pre-\/post-conditions of each method. On the program\nside, we instrument the program to be verified with explicit operations over vari-\nables heap and stk using rewriting rules. We call the instrumented programs\nas memory-aware programs. The memory usage behaviour of the original pro-\ngram is now mimicked and made explicit in its memory-aware version via the\nnewly introduced primitive operations over heap and stk. We also show that\nthe original program and its memory-aware version are observationally equiva-\nlent modulo the behaviour of the latter on the special variables heap and stk\nas well as a fixed memory cost for storing the two global variables. Instead of\nconstructing and implementing a fresh set of memory usage verification rules for\nthe original program, we can now pass to Hip\/Sleek as inputs the correspond-\ning memory-aware program together with the expected memory specification for\nautomated memory usage verification.\nIn summary, this paper makes the following contributions:\n\u2013 We propose a simple but novel solution to memory usage verification based on\na verification tool Hip\/Sleek by first rewriting programs to their memory-\naware counterparts.\n168 G. He et al.\n\u2013 We demonstrate that the syntax-directed rewriting process is sound in the\nsense that the memory-aware programs are observationally equivalent to their\noriginal programs with respect to an instrumented operational semantics.\n\u2013 We have integrated our solution with Hip\/Sleek and conducted some initial\nexperiments. The experimental results confirm the viability of our solution\nand show that we can verify the memory safety of more programs compared\nwith previous type-based approaches.\nThe rest of the paper is structured as follows. We introduce our programming\nand specification languages in Section 2. In Section 3 we present our approach\nto memory usage verification in Hip\/Sleek . Section 4 defines an underlying\nsemantics for the programming language and formulates the soundness of our\napproach w.r.t. the semantics. Experimental results are shown in Section 5,\nfollowed by related work and concluding remarks afterwards.\n2 Language and Specifications\nIn this section, we first introduce a core imperative language we use to demon-\nstrate the work, and then depict the general specification mechanism used by\nHip\/Sleek and show how memory usage specifications can be incorporated in.\n2.1 Programming Language\nTo simplify presentation, we focus on a strongly-typed C-like imperative lan-\nguage in Figure 1.\nA program P in our language consists of user-defined data types tdecl, global\nvariables gVar and method definitions meth. The notation datat stands for the\nstandard data type declaration used in programs, for example as below:\ndata node { int val; node next }\ndata node2 { int val; node2 prev; node2 next }\ndata node3 { int val; node3 left; node3 right; node3 parent }\nThe notation spred denotes a user-defined predicate which may be recursively\ndefined and can specify both structural and numerical properties of data struc-\ntures involved. The syntax of spred is given in Figure 2.\nP ::= tdecl\u2217 gVar\u2217 meth\u2217 tdecl ::= datat | spred\ndatat ::= data c { field\u2217 } field ::= t v t ::= c | \u03c4\n\u03c4 ::= int | bool | void gVar ::= t v\nmeth ::= t mn (([ref] t v)\u2217) mspec {e}\ne ::= null | k\u03c4 | v | v.f | v:=e | v1.f :=v2 | new c(v\u2217) | free(v)\n| e1; e2 | t v; e | mn(v\u2217) | if v then e1 else e2\nFig. 1. A Core (C-like) Imperative Language\nMemory Usage Verification Using Hip\/Sleek 169\nNote that a parameter can be either pass-by-value or pass-by-reference, dis-\ntinguished by the ref before a parameter definition. The method specification\nmspec, written in our specification language in Figure 2, specifies the expected\nbehaviour of the method, including its memory usage behaviour. Our aim is to\nverify the method body against this specification. Our language is expression-\noriented, so the body of a method is an expression composed of standard instruc-\ntions and constructors of an imperative language. Note that the instructions new\nand free explicitly deal with memory allocation and deallocation, respectively.\nThe term k\u03c4 denotes a constant value of type \u03c4 . While loops are transformed to\ntail-recursive methods in a preprocessing step.\n2.2 Specification Language\nOur specification language is given in Figure 2. Note spred defines a new sep-\naration predicate c in terms of the formula \u03a6 with a given pure invariant \u03c0.\nSuch user-specified predicates can be used in the method specifications. The\nmethod specification requires \u03a6pr ensures \u03a6po comprises a precondition \u03a6pr and\na postcondition \u03a6po.\nThe separation formula \u03a6, which appears in the predicate definition spred or\nin the pre-\/post-conditions of a method, is in disjunctive normal form. Each\ndisjunct consists of a \u2217-separated heap constraint \u03ba, referred to as heap part,\nand a heap-independent formula \u03c0, referred to as pure part. The pure part does\nnot contain any heap nodes and is restricted to pointer equality\/disequality \u03b3\nand Presburger arithmetic \u03c6. As we will see later, \u03b3 is used to capture the alias\ninformation of pointers during the verification, and \u03c6 is to record the numerical\ninformation of data structures, such as length of a list or height of a tree. Fur-\nthermore, \u0394 denotes a composite formula that could always be normalized into\nthe \u03a6 form [19].\nThe formula emp represents an empty heap. If c is a data node, the formula\np::c\u3008v\u2217\u3009 represents a singleton heap p \u0005\u2192[(f : v)\u2217] with f\u2217 as fields of data decla-\nration c. For example, p::node\u30080, null\u3009 denotes that p points to a node structure\nin the heap, whose fields have values 0 and null, respectively. If c is a (user-\nspecified) predicate, p::c\u3008v\u2217\u3009 stands for the formula c(p, v\u2217) which signifies that\nspred ::= root::c\u3008v\u2217\u3009 \u2261 \u03a6 inv \u03c0\nmspec ::= requires \u03a6pr ensures \u03a6po\n\u03a6 ::=\n\u2228\n(\u2203v\u2217\u00b7\u03ba\u2227\u03c0)\u2217 \u03c0 ::= \u03b3\u2227\u03c6\n\u03b3 ::= v1=v2 | v=null | v1 \u0007=v2 | v \u0007=null | \u03b31\u2227\u03b32\n\u03ba ::= emp | v::c\u3008v\u2217\u3009 | \u03ba1 \u2217 \u03ba2\n\u0394 ::= \u03a6 | \u03941\u2228\u03942 | \u0394\u2227\u03c0 | \u03941\u2217\u03942 | \u2203v\u00b7\u0394\n\u03c6 ::= b | a | \u03c61\u2227\u03c62 | \u03c61\u2228\u03c62 | \u00ac\u03c6 | \u2203v \u00b7 \u03c6 | \u2200v \u00b7 \u03c6\nb ::=true | false | v | b1=b2 a ::=s1=s2 | s1\u2264s2\ns ::= kint | v | kint\u00d7s | s1+s2 | \u2212s | max(s1,s2) | min(s1,s2)\nFig. 2. The Specification Language\n170 G. He et al.\nthe data structure pointed to by p has the shape c with parameters v\u2217. As an\nexample, one may define the following predicate for a singly linked list with\nlength n:\nroot::ll\u3008n\u3009\u2261(root=null\u2227n=0)\u2228(\u2203i,m, q \u00b7 root::node\u3008i, q\u3009\u2217q::ll\u3008m\u3009\u2227n=m+1) inv n\u22650\nThe above definition asserts that an ll list either can be empty (the base case\nroot=null where root is the \u201chead pointer\u201d pointing to the beginning of the\nwhole structure described by ll), or consists of a head data node (specified\nby root::node\u3008i, q\u3009) and a separate tail data structure which is also an ll list\n(q::ll\u3008m\u3009 saying that q points to an ll list with length m). The separation con-\njunction \u2217 introduced in separation logic signifies that two heap portions are\ndomain-disjoint. Therefore, in the inductive case of ll\u2019s definition, the separa-\ntion conjunction ensures that the head node and the tail ll reside in disjoint\nheaps. A default invariant n\u22650 is specified which holds for all ll lists. Existential\nquantifiers are for local values and pointers in the predicate, such as i, m and q.\nA slightly more complicated shape, a doubly linked-list with length n, is de-\nscribed by:\nroot::dll\u3008p, n\u3009\u2261(root=null\u2227n=0)\u2228(root::node2\u3008 , p, q\u3009\u2217q::dll\u3008root, n\u22121\u3009) inv n\u22650\nThe dll predicate has a parameter p to represent the prev field of the root\nnode of the doubly linked list. This shape includes node root and all the nodes\nreachable through the next field starting from root, but not the ones reachable\nthrough prev from root. Here we also can see some shortcuts that underscore\ndenotes an anonymous variable, and non-parameter variables in the right hand\nside of the shape definition, such as q, are implicitly existentially quantified.\nAs can be seen from the above, we can use \u03ba to express the shape of heap\nand \u03c6 to express numerical information of data structures, such as length. This\nallows us to specify data structures with sophisticated invariants. For example,\nwe may define a non-empty sorted list as below:\nroot::sortl\u3008n, min\u3009 \u2261 (root::node\u3008min, null\u3009\u2227n=1 \u2228\n(root::node\u3008min, q\u3009\u2217q::sortl\u3008m, k\u3009\u2227n=m+1\u2227min\u2264k) inv n\u22650\nThe sortedness property is captured with the help of an additional parameter min\ndenoting the minimum value stored in the list. The formula min\u2264k ensures the\nsortedness. With the aforesaid predicates, we can now specify the insertion-sort\nalgorithm as follows:\nnode insert(node x, node vn)\nrequires x::sortl\u3008n, min\u3009 \u2217 vn::node\u3008v, \u3009\nensures res::sortl\u3008n+1, min(v, min)\u3009;\n{\u00b7 \u00b7 \u00b7 }\nnode insertion sort(node y)\nrequires y::ll\u3008n\u3009 \u2227 n>0\nensures res::sortl\u3008n, \u3009;\n{\u00b7 \u00b7 \u00b7 }\nwhere a special identifier res is used in the postcondition to denote the result\nof a method. The postcondition of insertion sort shows that the output list\nis sorted and has the same number of nodes. We can also specify that the input\nMemory Usage Verification Using Hip\/Sleek 171\nand output lists contain the same set of values by adding another parameter to\nthe sortl predicate to capture the bag of values stored in the list [10].\nThe semantics of our specification formula is similar to the model given for\nseparation logic [22] except that we have extensions to handle user-defined shape\npredicates. We assume sets Loc of memory locations, Val of primitive values, with\n0 \u2208 Val denoting null, Var of variables (program and logical variables), and\nObjVal of object values stored in the heap, with c[f1 \u0005\u2192\u03bd1, .., fn \u0005\u2192\u03bdn] denoting an\nobject value of data type c where \u03bd1, .., \u03bdn are current values of the corresponding\nfields f1, .., fn. Let s, h |= \u03a6 denote the model relation, i.e. the stack s and heap\nh satisfy \u03a6, with h, s from the following concrete domains:\nh \u2208 Heaps =df Loc \u21c0fin ObjVal s \u2208 Stacks =df Var \u2192 Val\u222aLoc\nNote that each heap h is a finite partial mapping while each stack s is a total\nmapping, as in the classical separation logic [17,22]. The detailed definitions of\nthe model relation can be found in Chin et al. [10].\n2.3 Memory Usage Specification\nTo incorporate memory usage into the specification mechanism of Hip\/Sleek,\nwe employ two global variables heap and stk to represent the available heap\nand stack memory (in bytes). The memory requirement of a method can then\nbe specified as a pure constraint over heap and stk in the precondition of the\nmethod. The remaining memory space upon the return from a method call can\nalso be exhibited using a pure formula over heap\u2032 and stk\u2032 in the postcondition.1\nDue to perfect recovery of stack space upon return from a method call, stk\u2032 in\na method\u2019s postcondition will always be the same as its initial value stk. As an\nexample, the method new list(int n), which creates a singly linked list with\nlength n, is given as follows together with its memory usage specification:\nnode new list(int n)\nrequires heap\u22658 \u2217 n \u2227 n\u22650 \u2227 stk\u226512 \u2217 n+4\nensures res::ll\u3008n\u3009 \u2227 heap\u2032=heap\u22128 \u2217 n \u2227 stk\u2032=stk\n{ node r := null; if (n>0) { r := new list(n\u22121); r := new node(n, r)}; r }\nwhere the node was declared earlier in Sec 2.1. We assume that we use a 32-bit\narchitecture; therefore, one node requires 8 bytes of memory. This assumption\ncan be easily changed for a different architecture. The precondition specifies\nthat the method requires at least 8 \u2217 n bytes of heap space and 12 \u2217 n+ 4 stack\nspace before each execution with n denoting the size of the input.2 After method\n1 A primed variable x\u2032 in a specification formula denotes the latest value of variable\nx, with x representing its initial value.\n2 When a new local variable r is declared, 4 bytes of stack memory is consumed. Later\nwhen the method new list is invoked recursively, its parameters, return address\nand local variables are all placed on top of the stack. This is why it requires at least\n12 \u2217 n+4 bytes of stack space.\n172 G. He et al.\nexecution, 8 \u2217 n bytes of heap memory is consumed by the returned list, but\nthe stack space is fully recovered. This is reflected by the formula (heap\u2032 =\nheap\u2212 8 \u2217 n \u2227 stk\u2032 = stk) in the postcondition.\nAs another example, the following method free list deallocates a list:\nvoid free list(node2 x)\nrequires x::dll\u3008n\u3009 \u2227 heap\u22650 \u2227 stk\u226512 \u2217 n\nensures emp \u2227 heap\u2032=heap+12 \u2217 n \u2227 stk\u2032=stk\n{ if (x \u0007= null) { node t := x; x := x.next; free(t); free list(x) } }\nWe can see that 12 \u2217 n bytes of heap space is expected to be claimed back\nby the method as signified in the postcondition. Notice here the stack and heap\nmemory are specified in terms of the logical variable n denoting the length of the\nlist x, showing the possible close relation between the separation (shape and size)\nspecification and the memory specification. Next we will show how to rewrite\nthe program to its memory-aware version by using the two global variables heap\nand stk to mimic the memory behaviour, so that Hip\/Sleek can step in for\nmemory usage verification.\n3 Memory Usage Verification\nIn this section, we first present the instrumentation process which converts pro-\ngrams to be verified to memory-aware programs. We then briefly introduce the\nautomated verification process in Hip\/Sleek.\n3.1 The Instrumentation Process\nThe instrumentation process makes use of primitive operations over the global\nvariables heap and stk to simulate the memory usage behaviour of the original\nprogram. It is conducted via the rewriting rules given in Figure 3.\nThese rewriting rules form a transformerM which takes in a program and re-\nturns its memory-aware version. Note thatM conducts identical rewriting except\nfor the following four cases: (1) heap allocation new c(v\u2217); (2) heap deallocation\nfree(v); (3) local block {t v; e}; (4) method declaration t0 mn(t1 v1, .., tn vn){e}.\nM(E) ::= E where E \u2208 {null, k\u03c4 , v, v.f, v1.f :=v2, mn(v\u2217)}\nM(new c(v\u2217)) ::= dec hp(ssizeof(c)); new c(v\u2217)\nM(free(v)) ::= free(v); inc hp(ssizeof(type(v)))\nM({t v; e}) ::= dec stk(sizeof(t)); {t v; M(e)}; inc stk(sizeof(t))\nM(v:=e) ::= v:=M(e)\nM(e1; e2) ::= M(e1);M(e2)\nM(if v then e1 else e2) ::= if v then M(e1) else M(e2)\nM(t0 mn(t1 v1, .., tn vn){e}) ::= t0 mn(t1 v1, .., tn vn){\ndec stk(sizeof(t0, t1, .., tn)+4);M(e); inc stk(sizeof(t0, t1, .., tn)+4)}\nFig. 3. Rewriting Rules for Instrumentation\nMemory Usage Verification Using Hip\/Sleek 173\nTo simulate the memory effect of new c(v\u2217), we employ a primitive method\nover variable heap, called dec hp, which is subject to the specification:\nvoid dec hp(int n) requires heap\u2265n \u2227 n\u22650 ensures heap\u2032=heap\u2212n\nTo successfully call dec hp(n), the variable heap must hold a value no less than\nthe non-negative integer n at the call site. Upon return, the value of heap is\ndecreased by n.\nTo simulate the memory effect of free(v), we employ a primitive method over\nheap, called inc hp:\nvoid inc hp(int n) requires n\u22650 ensures heap\u2032=heap+n\nThememory effect of local blocks andmethod bodies can be simulated in a similar\nway, and the difference is that they count on the stack instead of heap. For code\nblocks, we employ dec stk to check the stack space is sufficient for the local variable\nto be declared, and decrease the stack space;meanwhile, at the end of the block, we\nrecover such space by inc stk due to the popping out of the local variables. As for\nmethod body, stack space is initially acquired (and later recovered) for method\nparameters and return address (four bytes), as the last rewriting rule suggests.\nThe specifications for these two primitive methods are as follows:\nvoid dec stk(int n) requires stk\u2265n \u2227 n\u22650 ensures stk\u2032=stk\u2212n\nvoid inc stk(int n) requires n\u22650 ensures stk\u2032=stk+n\nNote that two different functions sizeof and ssizeof are used in the rewriting rules:\nsizeof is applied to both primitive and reference types, while ssizeof is applied\nto (user-defined) data types, by summing up the sizes of all declared fields\u2019\ntypes obtained via sizeof. For example, sizeof(int) = 4, sizeof(node) = 4, and\nssizeof(node) = 8, since the node data structure (defined in Section 2) contains\nan int field and a reference to another node. We also abuse these functions by\napplying them to a list of types, expecting them to return the sum of the results\nwhen applied to each type.\nWe present below the memory-aware versions for the two examples given in\nSection 2.\nnode new list(int n)\nrequires emp \u2227 heap\u22658 \u2217 n\u2227\nn\u22650 \u2227 stk\u226512 \u2217 n+ 4\nensures res::ll\u3008n\u3009 \u2227 stk\u2032=stk\u2227\nheap\u2032=heap\u22128 \u2217 n;\n{ dec stk(4);\nnode r := null;\nif (n > 0) {\ndec stk(8); r := new list(n\u22121);\ninc stk(8); dec hp(8);\nr := new node(n, r) };\ninc stk(4); r }\nFig. 4. Example 1\nvoid free list(node2 x)\nrequires x::dll\u3008p, n\u3009 \u2227 heap\u22650\u2227\nstk\u226512 \u2217 n\nensures emp \u2227 stk\u2032=stk \u2227\nheap\u2032=heap+12 \u2217 n;\n{ if (x \u0007= null) {\ndec stk(4);\nnode2 t := x; x := x.next;\nfree(t); inc hp(12);\ndec stk(8); free list(x);\ninc stk(8); inc stk(4) }\n}\nFig. 5. Example 2\n174 G. He et al.\nNote that thememory effect is simulated via explicit calls to the afore-mentioned\nfour primitive methods over heap and stk, which are highlighted in bold.\nAs one more example, we show in Figure 6 a program with more complicated\nmemory usage behaviour. The program translates a doubly linked list (node2)\ninto a singly linked list (node), by deallocating node2 x and then creating a\nsingly linked list with the same length and content. A heap memory of 4 \u2217 n\nbytes is reclaimed back since each node2 object has one more field (which takes\n4 bytes) than a node object.\nnode dl2sl(node2 x)\nrequires x::dll\u3008 , n\u3009 \u2227 stk\u226520\u2217n \u2227 heap\u22650\nensures res::ll\u3008n\u3009 \u2227 stk\u2032=stk \u2227 heap\u2032=heap+4\u2217n;\n{ dec stk(4); node r := null;\nif (x \u0007= null) { dec stk(4); int v := x.val; dec stk(4);\nnode2 t := x; x := x.next; free(t); inc hp(12);\ndec stk(8); r := dl2sl(x); inc stk(8);\ndec hp(8); r := new node(v, r); inc stk(4); inc stk(4) };\ninc stk(4); r }\nFig. 6. Example 3\nThe instrumented programs are then passed to Hip\/Sleek for automated\nverification.\n3.2 The Hip\/Sleek Automated Verification System\nHIP: Hoare-style \nForward Verifier\nSLEEK: Entailment\nProver\nProgram\nCode\nUser Supplied Items\nAutomated Verification System\nPre\/Post ShapePredicates\nFig. 7. The Hip\/Sleek Verification System\nAn overview of the\nHip\/Sleek auto-\nmated verification\nsystem is given\nin Figure 7. The\nfront-end of the sys-\ntem is a standard\nHoare-style forward\nverifier Hip, which\ninvokes the entail-\nment prover Sleek.\nThe Hip verifier\ncomprises a set of forward verification rules to systematically check that the\nprecondition is satisfied at each call site, and that the declared postcondition\nis successfully verified (assuming the given precondition) for each method\ndefinition. The forward verification rules are of the form \f {\u03941} e {\u03942} which\nexpect the symbolic abstract state \u03941 to be given before computing \u03942. Given\ntwo separation formulas \u03941 and \u03942, the entailment prover Sleek attempts\nto prove that \u03941 entails \u03942; if it succeeds, it returns a frame R such that\n\u03941 \f \u03942 \u2217 R. More details of the Hip and Sleek provers can be found in Chin\net al. [10].\nMemory Usage Verification Using Hip\/Sleek 175\n4 Soundness\nThis section presents the soundness of our approach with respect to an underly-\ning operational semantics given in Figure 8. Note that we instrument the state\nwith memory size information, so a program state is represented by \u3008s, h, \u03c3, \u03bc, e\u3009,\nwhere s, h denote respectively the current stack and heap state as mentioned ear-\nlier, \u03c3 (\u03bc) represents current available stack (heap) memory in bytes, and e is\nthe program code to be executed. If the execution leads to an error, we denote\nthe error state as er1 if it is due to memory inadequacy, or as er2 for all other\nerrors (e.g. null pointer dereference). Note also that an intermediate construct\nret(v\u2217, e) is introduced to denote the return value of call invocation and local\nblocks as in Chin et al. [10]. Later, we use \u21aa\u2192\u2217 to denote the composition of any\nnon-negative number of transitions, and \u2191 for program divergence.\n\u3008s, h, \u03c3, \u03bc, v\u3009\u21aa\u2192\u3008s, h, \u03c3, \u03bc, s(v)\u3009 \u3008s, h, \u03c3, \u03bc, k\u3009\u21aa\u2192\u3008s, h, \u03c3, \u03bc, k\u3009\n\u3008s, h, \u03c3, \u03bc, v:=k\u3009\u21aa\u2192\u3008s[v \u0005\u2192k], h, \u03c3, \u03bc, ()\u3009 \u3008s, h, \u03c3, \u03bc, (); e\u3009\u21aa\u2192\u3008s, h, \u03c3, \u03bc, e\u3009\ns(v) \u2208 dom(h)\n\u3008s, h, \u03c3, \u03bc, v.f\u3009\u21aa\u2192\u3008s, h, \u03c3, \u03bc, h(s(v))(f)\u3009\ns(v) \/\u2208 dom(h)\n\u3008s, h, \u03c3, \u03bc, v.f\u3009\u21aa\u2192er2\n\u3008s, h, \u03c3, \u03bc, e1\u3009\u21aa\u2192\u3008s1, h1, \u03c31, \u03bc1, e3\u3009\n\u3008s, h, \u03c3, \u03bc, e1; e2\u3009\u21aa\u2192\u3008s1, h1, \u03c31, \u03bc1, e3; e2\u3009\n\u3008s, h, \u03c3, \u03bc, e\u3009\u21aa\u2192\u3008s1, h1, \u03c31, \u03bc1, e1\u3009\n\u3008s, h, \u03c3, \u03bc, v:=e\u3009\u21aa\u2192\u3008s1, h1, \u03c31, \u03bc1, v:=e1\u3009\ns(v)=true\n\u3008s, h, \u03c3, \u03bc, if v then e1 else e2\u3009\u21aa\u2192\u3008s, h, \u03c3, \u03bc, e1\u3009\ns(v)=false\n\u3008s, h, \u03c3, \u03bc, if v then e1 else e2\u3009\u21aa\u2192\u3008s, h, \u03c3, \u03bc, e2\u3009\ns(v1) \u2208 dom(h) r = h(s(v1))[f \u0005\u2192s(v2)] h1 = h[s(v1)\u0005\u2192r]\n\u3008s, h, \u03c3, \u03bc, v1.f := v2\u3009\u21aa\u2192\u3008s, h1, \u03c3, \u03bc, ()\u3009\ns(v1) \/\u2208 dom(h)\n\u3008s, h, \u03c3, \u03bc, v1.f := v2\u3009\u21aa\u2192er2\ns(v)\u0005\u2192l \u2208 h h1=h\\[s(v)\u0005\u2192l] \u03bc1=\u03bc+ssizeof(type(v))\n\u3008s, h, \u03c3, \u03bc, free(v)\u3009\u21aa\u2192\u3008s, h1, \u03c3, \u03bc1, ()\u3009\ns(v) \/\u2208 dom(h)\n\u3008s, h, \u03c3, \u03bc, free(v)\u3009\u21aa\u2192er2\ndata c {t1 f1, .., tn fn}\u2208P \u03b9\/\u2208dom(h)\n\u03bc\u2265ssizeof(c) \u03bc1=\u03bc\u2212ssizeof(c) r=c[fi \u0005\u2192s(vi)]ni=1\n\u3008s, h, \u03c3, \u03bc, new c(v\u2217)\u3009\u21aa\u2192\u3008s, h+[\u03b9 \u0005\u2192 r], \u03c3, \u03bc1, \u03b9\u3009\n\u03bc<ssizeof(c)\n\u3008s, h, \u03c3, \u03bc, new c(v\u2217)\u3009\u21aa\u2192er1\n\u3008s, h, \u03c3, \u03bc, ret(v1, .., vn, k)\u3009\u21aa\u2192\u3008s\u2212{v1, .., vn}, h, \u03c3+sizeof(type(v1), .., type(vn)), \u03bc, k\u3009\n\u3008s, h, \u03c3, \u03bc, e\u3009\u21aa\u2192\u3008s1, h1, \u03c31, \u03bc1, e1\u3009\n\u3008s, h, \u03c3, \u03bc, ret(v\u2217, e)\u3009\u21aa\u2192\u3008s1, h1, \u03c31, \u03bc1, ret(v\u2217, e1)\u3009\n\u03c3\u2265sizeof(t) \u03c31=\u03c3\u2212sizeof(t)\n\u3008s, h, \u03c3, \u03bc, {t v; e}\u3009\u21aa\u2192\u3008s+[v \u0005\u2192\u22a5], h, \u03c31, \u03bc, ret(v, e)\u3009\n\u03c3<sizeof(t)\n\u3008s, h, \u03c3, \u03bc, {t v; e}\u3009\u21aa\u2192er1\ns1=s+[wi \u0005\u2192s(vi)]ni=m\n\u03c3\u2265\u03a3ni=msizeof(ti) \u03c31=\u03c3\u2212\u03a3ni=msizeof(ti)\nt0 mn((ref ti wi)\nm\u22121\ni=1 , (ti wi)\nn\ni=m) {e}\n\u3008s, h, \u03c3, \u03bc,mn(v1, .., vn)\u3009 \u21aa\u2192\n\u3008s1, h, \u03c31, \u03bc, ret({wi}ni=m, [vi\/wi]m\u22121i=1 e)\u3009\n\u03c3<\u03a3ni=msizeof(ti)\n\u3008s, h, \u03c3, \u03bc,mn(v\u2217)\u3009\u21aa\u2192er1\nFig. 8. Underlying Semantics\n176 G. He et al.\nAs shown in the transition rule, a successful execution of free(v) increases\nthe heap size \u03bc by ssizeof(type(v)). Note that we use h \\ [s(v)\u0005\u2192l] to erase s(v)\nfrom h\u2019s domain. The execution of new c(v\u2217) first checks if the current heap\nspace is sufficient for the allocation; if it succeeds, the heap size is decreased by\nssizeof(c). Here we adds \u03b9 \u0005\u2192 r into h by the notation h + [\u03b9 \u0005\u2192 r].\nThe stack space may be changed when the program enters into or exits from\na local block {t v; e}, or invokes a method, or returns from a method call.\nUpon exit from a block or a method call, all local variables are popped out\nfrom the stack (s\u2212 {v1, .., vn}) and the corresponding stack space is recov-\nered (\u03c3+sizeof(type(v1), .., type(vn))). Conversely, entering a block or invoking\na method may require some stack space to store newly declared local variables\nor returning address of the method. So the relevant semantic rule first checks\nwhether the stack space is sufficient to cater for a new block or a method invo-\ncation, if so, the program state is transformed. Otherwise a memory inadequacy\nerror is reported.\nDue to the recording of memory size information in program state, we need\nan extended model to link the underlying semantics with the separation formula,\nwhich is defined as follows:\ns, h, \u03c3, \u03bc |= \u03a6 =def s, h |= [\u03c3\/stk\u2032, \u03bc\/heap\u2032]\u03a6\nwhere s, h |= \u03a6 was defined in Chin et al. [10].\nNext, we show that the instrumented programM(e) is observationally equiv-\nalent to the original program e w.r.t. the semantics in Figure 8.\nTheorem 1 (Observational Equivalence). For any stack s, heap h, stack\nsize \u03c3, heap size \u03bc, and program e and its instrumented version M(e), one and\nonly one of the following cases holds:\n1. \u2203s1, h1, \u03c31, \u03bc1 \u00b7 \u3008s, h, \u03c3, \u03bc, e\u3009 \u21aa\u2192\u2217 \u3008s1, h1, \u03c31, \u03bc1, \u03bd\u3009 \u21d0\u21d2 \u3008s[stk\u0005\u2192\u03c3, heap \u0005\u2192\u03bc],\nh, \u03c3, \u03bc,M(e)\u3009 \u21aa\u2192\u2217 \u3008s1[stk\u0005\u2192\u03c31, heap\u0005\u2192\u03bc1], h1, \u03c31, \u03bc1, \u03bd\u3009 where value \u03bd is the\nevaluation result of e;\n2. \u3008s, h, \u03c3, \u03bc, e\u3009 \u21aa\u2192\u2217 er1 \u21d0\u21d2 \u3008s[stk\u0005\u2192\u03c3, heap\u0005\u2192\u03bc], h, \u03c3, \u03bc,M(e)\u3009 \u21aa\u2192\u2217 er1;\n3. \u3008s, h, \u03c3, \u03bc, e\u3009 \u21aa\u2192\u2217 er2 \u21d0\u21d2 \u3008s[stk\u0005\u2192\u03c3, heap\u0005\u2192\u03bc], h, \u03c3, \u03bc,M(e)\u3009 \u21aa\u2192\u2217 er2;\n4. \u3008s, h, \u03c3, \u03bc, e\u3009 \u2191 \u21d0\u21d2 \u3008s[stk\u0005\u2192\u03c3, heap\u0005\u2192\u03bc], h, \u03c3, \u03bc,M(e)\u3009 \u2191.\nNote that the stack mapping s[stk\u0005\u2192\u03c3, heap\u0005\u2192\u03bc] is the same as s except that it\nmaps stk to \u03c3 and heap to \u03bc.\nProof. By structural induction over e. \u0002\nWe assume that the global variables, such as heap and stk, reside in the top\nframe of the run-time stack when a program starts to run. Note that invoca-\ntions of the four primitive methods, namely inc hp(\u00b7), inc stk(\u00b7), dec hp(\u00b7) and\ndec stk(\u00b7), modify only the values of heap and stk, but not the rest of the stack.\nEach invocation of these methods requires eight bytes of stack space, which is\nimmediately recovered after the invocation.3\n3 Because of this, a memory-aware program may require an additional stack space of\n8 bytes. For simplicity, we assume this has been taken into account implicitly.\nMemory Usage Verification Using Hip\/Sleek 177\nFinally, the following theorem ensures the soundness of our memory usage\nverification:\nTheorem 2. For any method t mn (([ref] t v)\u2217) requires \u03a6pr ensures \u03a6po {e},\nif we can verify M(e) against specification (\u03a6pr, \u03a6po), then we have \u2200s, h, \u03c3, \u03bc \u00b7\n(s, h, \u03c3, \u03bc |= \u03a6pr \u2227 \u3008s, h, \u03c3, \u03bc, e\u3009\u21aa\u2192\u2217\u3008s1, h1, \u03c31, \u03bc1, \u03bd\u3009) =\u21d2 s1, h1, \u03c31, \u03bc1 |= \u03a6po.\nProof. It follows from Theorem 1 and the soundness of the Hip\/Sleek veri-\nfication process given in Chin et al. [10]. \u0002\n5 Experimental Results\nWe have implemented our proposal and integrated it with the Hip\/Sleek sys-\ntem to support memory usage verification. We have evaluated the system using\na number of benchmarks, by first converting them to memory-aware programs\nand then passing them to the Hip\/Sleek system for memory usage verification\n(which is done as one pass along with the verification of other safety properties).\nOne set of programs that we have tested are taken from Nguyen et al. [19]. De-\nspite of small-size, these programs are composed of methods manipulating shared\nmutable data structures, such as (doubly) linked lists, cyclic linked lists, binary\nsearch trees, most of which cannot be handled by previous type-based memory\nusage verifiers. Another set of programs that we have tested are taken from the\nOlden Benchmark Suite [8]. These programs are of medium-size and quite of-\nten contain sophisticated memory usage behaviour. For all programs, we have\nmanually supplied their memory specifications which are precise when validated\nthrough some sample runs. The initial experimental results have shown that the\nmemory usage specification is expressive and the memory usage verification via\nHip\/Sleek is powerful, especially in dealing with mutable data structures with\nsophisticated sharing.\nPrograms Code (lines) Verified Methods Verification (in sec.)\nBenchmark programs from Nguyen et al. [19]\nsingly linked list 72 4\/4 0.42\ndoubly linked list 104 4\/4 1.20\nbinary search tree 62 2\/2 0.32\ncyclic linked list 78 2\/2 0.48\nOlden Benchmark suite\ntreeadd 195 4\/4 0.58\nbisort 340 6\/6 2.80\nem3d 462 20\/20 1.52\nmst 473 22\/22 1.64\ntsp 545 9\/9 3.44\nhealth 562 15\/15 7.35\npower 765 19\/19 5.17\nFig. 9. Experiment Results\n178 G. He et al.\nFigure 9 summarises some statistics obtained during the experimental study.\nThe statistics shows that our approach is general enough to handle many inter-\nesting data structures such as single linked lists, double linked lists, trees and\ncyclic linked lists. Column 4 shows the CPU times used (in seconds) for the ver-\nification. Our experiments were done under Linux platform on Intel Core Quad\n2.66 GHz with 8 GB main memory. All programs take under 10 seconds to verify,\neven for medium-sized programs with sophisticated memory usage behaviour.\n6 Related Work\nPrevious research on memory usage analysis and verification [1,2,5,7,15] mainly\nfocuses on functional programs where data structures are mostly immutable\nand easier to deal with. Amadio et al. [1] define a simple stack machine for a\nfirst-order functional language and discuss the performance of type, size and\ntermination verifications at bytecode level of the machine. Their contribution is\nto verify a system of annotations for the bytecode at loading time, and ensure\nboth time and space resource bound required by its execution. Their work only\ntakes into account stack bounds but not heap memory. Another related work\nis the research in the MRG (Mobile Resource Guarantees) project [2,5], which\nfocuses on building a proof-carrying code system to guarantee that bytecode\nprograms are free from run-time violations of resource bounds. The analysis\nis developed for a linearly typed bytecode language which is compiled from a\nfirst-order functional language, where the bounds are restricted to a linear form.\nHofmann and Jost [15] present a mechanism to obtain linear bounds on the\nheap space usage of first-order functional programs. It uses an amortised analysis\nby assigning hypothetical amounts of free space to data structures in proportion\nto their sizes. The analysis relies on a type system with resource annotations, and\ntakes space reuse by explicit deallocation. With this approach, memory recovery\ncan be supported within each function, but not across functions unless the dead\nobjects are explicitly passed. Their analysis does not consider stack usage and\nis limited to a linear form without disjunction. Recently, Campbell [7] gives a\ntype-based approach to stack space analysis. It uses the depth of data structures\nand adds extra structures to typing contexts to describe the form of the bounds.\nHeap memory is not considered in his work.\nPrevious works on memory usage verification [11,12,16] for imperative\/OO\nprogramming languages mainly use type-based approaches. Chin et al. [12] pro-\npose a modular memory usage verification system for object-oriented programs.\nThe system can check whether a certain amount of memory is adequate for safe\nexecution of a given program. However, the verification framework requires alias\ncontrol mechanism to overcome the mutability and sharing problems. Therefore,\nit can only handle restricted subsets of programs manipulating shared mutable\ndata structures. Recently, Chin et al. [11] propose a memory bound analysis sys-\ntem for low-level programs. The system tries to infer both stack and heap space\nbounds, using fixpoint analyses for recursive methods and loops. However, the\nsystem does not handle shared objects. Hofmann and Jost [16] propose a type-\nbased heap space analysis for Java style OO programs with explicit deallocation.\nMemory Usage Verification Using Hip\/Sleek 179\nIt uses an amortised analysis, and a potential is assigned to each datum accord-\ning to its size and layout. Heap memory usage is calculated by an LP-solver\nbased on function inputs during the type inference.\nDifferent from previous works which try to build a memory usage verification\nsystem, we re-use a general-purpose verification system Hip\/Sleek for mem-\nory usage verification, where shape, size and alias information can be readily\nobtained from the specifications given in separation logic. With this tool, we\ncan verify quite a number of programs that can not be handled by previous\napproaches, such as doubly linked lists, cyclic linked lists and binary trees.\n7 Conclusion\nIn this paper we have proposed an approach to memory usage verification, by\nresorting to a general-purpose verification system Hip\/Sleek based on separa-\ntion logic, where memory usage specifications can be depicted using two special\nvariables heap and stk. Given a program to verify against its memory usage\nspecifications, instead of constructing and implementing verification rules to\nconduct the verification, we rewrite the program to its memory-aware version\nwhere memory usage behaviours are mimicked by explicit operations over vari-\nables heap and stk. The obtained memory-aware program can then be passed to\nHip\/Sleek for automated verification. Due to the fact that the memory-aware\nprogram is observationally equivalent to its original program, the memory safety\nfor the original program follows directly from the memory safety proof of the\ninstrumented program. We have implemented the rewriting process and inte-\ngrated it with Hip\/Sleek. Our initial experimental study shows that we can\nverify quite a number of programs which can not be handled by previous mem-\nory usage verification systems mainly due to the manipulation of sophisticated\nshared mutable data structures.\nAs for future work, we aim to automatically infer memory usage specifications,\nwhere possible, to reduce the burden on users and also improve the level of\nautomation for memory usage verification. We have just started another EPSRC-\nfunded project aiming to automatically infer method specifications and loop\ninvariants in a combined separation and numerical domain, which would benefit\nour memory usage analysis and verification.\nAcknowledgement. This work was supported in part by the EPSRC projects\n[EP\/E021948\/1, EP\/G042322\/1] and the A*STAR grant R-252-000-233-305.\nReferences\n1. Amadio, R.M., Coupet-Grimal, S., Dal Zilio, S., Jakubiec, L.: A Functional Sce-\nnario for Bytecode Verification of Resource Bounds. In: Marcinkowski, J., Tarlecki,\nA. (eds.) CSL 2004. LNCS, vol. 3210, pp. 265\u2013279. Springer, Heidelberg (2004)\n180 G. He et al.\n2. Aspinall, D., Gilmore, S., Hofmann, M., Sannella, D., Stark, I.: Mobile resource\nguarantees for smart devices. In: Barthe, G., Burdy, L., Huisman, M., Lanet, J.-L.,\nMuntean, T. (eds.) CASSIS 2004. LNCS, vol. 3362, pp. 1\u201326. Springer, Heidelberg\n(2005)\n3. Berdine, J., Calcagno, C., O\u2019Hearn, P.W.: Smallfoot: Modular automatic asser-\ntion checking with separation logic. In: de Boer, F.S., Bonsangue, M.M., Graf,\nS., de Roever, W.-P. (eds.) FMCO 2005. LNCS, vol. 4111, pp. 115\u2013137. Springer,\nHeidelberg (2006)\n4. Berdine, J., Cook, B., Distefano, D., O\u2019Hearn, P.W.: Automatic termination proofs\nfor programs with shape-shifting heaps. In: Ball, T., Jones, R.B. (eds.) CAV 2006.\nLNCS, vol. 4144, pp. 386\u2013400. Springer, Heidelberg (2006)\n5. Beringer, L., Hofmann, M., Momigliano, A., Shkaravska, O.: Automatic certifica-\ntion of heap consumption. In: Baader, F., Voronkov, A. (eds.) LPAR 2004. LNCS\n(LNAI), vol. 3452, pp. 347\u2013362. Springer, Heidelberg (2005)\n6. Calcagno, C., Distefano, D., O\u2019Hearn, P.W., Yang, H.: Compositional shape anal-\nysis by means of bi-abduction. In: ACM POPL, pp. 289\u2013300 (2009)\n7. Campbell, B.: Amortised memory analysis using the depth of data structures. In:\nESOP. LNCS, vol. 5502, pp. 190\u2013204. Springer, Heidelberg (2009)\n8. Carlisle, M.C., Rogers, A.: Software caching and computation migration in Olden.\nACM SIGPLAN Notices 30(8), 29\u201338 (1995)\n9. Chin, W.-N., David, C., Nguyen, H.H., Qin, S.: Enhancing modular oo verification\nwith separation logic. In: ACM POPL, pp. 87\u201399 (2008)\n10. Chin, W.-N., David, C., Nguyen, H.H., Qin, S.: Automated verification\nof shape, size and bag properties via user-defined predicates in separation\nlogic. Under Consideration by Science of Computer Programming (2009),\nhttp:\/\/www.dur.ac.uk\/shengchao.qin\/papers\/SCP-draft.pdf\n11. Chin, W.-N., Nguyen, H.H., Popeea, C., Qin, S.: Analysing memory resource\nbounds for low-level programs. In: International Symposium on Memory Man-\nagement (ISMM), pp. 151\u2013160. ACM Press, New York (2008)\n12. Chin, W.-N., Nguyen, H.H., Qin, S., Rinard, M.: Memory usage verification for\noo Programs. In: Hankin, C., Siveroni, I. (eds.) SAS 2005. LNCS, vol. 3672,\npp. 70\u201386. Springer, Heidelberg (2005)\n13. Distefano, D., O\u2019Hearn, P.W., Yang, H.: A local shape analysis based on separa-\ntion logic. In: Hermanns, H., Palsberg, J. (eds.) TACAS 2006. LNCS, vol. 3920,\npp. 287\u2013302. Springer, Heidelberg (2006)\n14. Distefano, D., Parkinson, M.J.: jStar: towards practical verification for Java. In:\nACM OOPSLA, pp. 213\u2013226 (2008)\n15. Hofmann, M., Jost, S.: Static prediction of heap space usage for first order func-\ntional programs. In: ACM POPL, January 2003, pp. 185\u2013197 (2003)\n16. Hofmann, M., Jost, S.: Type-based amortised heap-space analysis. In: Sestoft,\nP. (ed.) ESOP 2006. LNCS, vol. 3924, pp. 22\u201337. Springer, Heidelberg (2006)\n17. Ishtiaq, S., O\u2019Hearn, P.W.: BI as an assertion language for mutable data structures.\nIn: ACM POPL, January 2001, pp. 14\u201326 (2001)\n18. Nguyen, H.H., Chin, W.-N.: Enhancing program verification with lemmas. In:\nGupta, A., Malik, S. (eds.) CAV 2008. LNCS, vol. 5123, pp. 355\u2013369. Springer,\nHeidelberg (2008)\n19. Nguyen, H.H., David, C., Qin, S., Chin, W.-N.: Automated verification of shape\nand size properties via separation logic. In: Cook, B., Podelski, A. (eds.) VMCAI\n2007. LNCS, vol. 4349, pp. 251\u2013266. Springer, Heidelberg (2007)\n20. Parkinson, M.J., Bierman, G.M.: Separation logic, abstraction and inheritance. In:\nACM POPL, pp. 75\u201386 (2008)\nMemory Usage Verification Using Hip\/Sleek 181\n21. Reeves, G., Neilson, T., Litwin, T.: Mars exploration rover spirit vehicle anomaly\nreport. Jet Propulsion Laboratory Document No. D-22919 (July 2004)\n22. Reynolds, J.: Separation logic: a logic for shared mutable data structures. In: IEEE\nLICS, July 2002, pp. 55\u201374 (2002)\n23. Xi, H.: Imperative programming with dependent types. In: IEEE LICS, June 2000,\npp. 375\u2013387 (2000)\n24. Yang, H., Lee, O., Berdine, J., Calcagno, C., Cook, B., Distefano, D., O\u2019Hearn,\nP.W.: Scalable shape analysis for systems code. In: Gupta, A., Malik, S. (eds.)\nCAV 2008. LNCS, vol. 5123, pp. 385\u2013398. Springer, Heidelberg (2008)\n"}