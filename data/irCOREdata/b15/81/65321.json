{"doi":"10.1109\/SEW.2006.22","coreId":"65321","oai":"oai:dro.dur.ac.uk.OAI2:6225","identifiers":["oai:dro.dur.ac.uk.OAI2:6225","10.1109\/SEW.2006.22"],"title":"Integrating probability with time and shared-variable concurrency.","authors":["Zhu, H.","Qin, S.","He, J.","Bowen, J."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2006-04-01","abstract":"Complex software systems typically involve features like time, concurrency and probability, where probabilistic computations play an increasing role. It is challenging to formalize languages comprising all these features. In this paper, we integrate probability, time and concurrency in one single model, where the concurrency feature is modelled using shared-variable based communication. The probability feature is represented by a probabilistic nondeterministic choice, probabilistic guarded choice and a probabilistic version of parallel composition. We formalize an operational semantics for such an integration. Based on this model we define a bisimulation relation, from which an observational equivalence between probabilistic programs is investigated and a collection of algebraic laws are explored. We also implement a prototype of the operational semantics to animate the execution of probabilistic program","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65321.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6225\/1\/6225.pdf","pdfHashValue":"1eaed09d4e319c5a7fbc4e1c39719367b1c3a3d1","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6225<\/identifier><datestamp>\n      2010-11-08T12:07:13Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Integrating probability with time and shared-variable concurrency.<\/dc:title><dc:creator>\n        Zhu, H.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        He, J.<\/dc:creator><dc:creator>\n        Bowen, J.<\/dc:creator><dc:description>\n        Complex software systems typically involve features like time, concurrency and probability, where probabilistic computations play an increasing role. It is challenging to formalize languages comprising all these features. In this paper, we integrate probability, time and concurrency in one single model, where the concurrency feature is modelled using shared-variable based communication. The probability feature is represented by a probabilistic nondeterministic choice, probabilistic guarded choice and a probabilistic version of parallel composition. We formalize an operational semantics for such an integration. Based on this model we define a bisimulation relation, from which an observational equivalence between probabilistic programs is investigated and a collection of algebraic laws are explored. We also implement a prototype of the operational semantics to animate the execution of probabilistic programs <\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        (2006). 30th Annual IEEE\/NASA Software Engineering Workshop, SEW-30, 24-28 April 2005, Columbia, Maryland ; proceedings. Los Alamitos, CA: IEEE, pp. 179-189<\/dc:source><dc:date>\n        2006-04-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6225<\/dc:identifier><dc:identifier>\n        doi:10.1109\/SEW.2006.22<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6225\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/SEW.2006.22<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6225\/1\/6225.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2006 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2006,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nZhu, H. and Qin, S. and He, J. and Bowen, J. (2006) \u2019Integrating probability with time and shared-variable\nconcurrency.\u2019, in 30th Annual IEEE\/NASA Software Engineering Workshop, SEW-30, 24-28 April 2005,\nColumbia, Maryland ; proceedings. Los Alamitos, CA: IEEE, pp. 179-189.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/SEW.2006.22\nPublisher\u2019s copyright statement:\n2006 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nIntegrating Probability with Time and Shared-Variable Concurrency \u2217\nHuibiao Zhu\nSoftware Engineering Institute\nEast China Normal University\nhbzhu@sei.ecnu.edu.cn\nShengchao Qin\nDepartment of Computer Science\nUniversity of Durham\nshengchao.qin@durham.ac.uk\nJifeng He\nSoftware Engineering Institute\nEast China Normal University\njifeng@sei.ecnu.edu.cn\nJonathan P. Bowen\nCentre for Applied Formal Methods\nLondon South Bank University\nbowenjp@lsbu.ac.uk\nAbstract\nComplex software systems typically involve features like\ntime, concurrency and probability, where probabilistic com-\nputations play an increasing role. It is challenging to for-\nmalize languages comprising all these features. In this pa-\nper, we integrate probability, time and concurrency in one\nsingle model, where the concurrency feature is modelled us-\ning shared-variable based communication. The probabil-\nity feature is represented by a probabilistic nondeterminis-\ntic choice, probabilistic guarded choice and a probabilis-\ntic version of parallel composition. We formalize an op-\nerational semantics for such an integration. Based on this\nmodel we define a bisimulation relation, from which an ob-\nservational equivalence between probabilistic programs is\ninvestigated and a collection of algebraic laws are explored.\nWe also implement a prototype of the operational semantics\nto animate the execution of probabilistic programs.\n1 Introduction\nAs probabilistic computations play an increasing role in\nsolving various problems [21], various proposals on proba-\nbilistic languages have been reported [5, 6, 8, 14, 13, 15, 18,\n19, 20]. Complex software systems typically involve impor-\ntant features like real-time, probability and shared-variable\nconcurrency. Therefore, system designers would expect a\nformal model that incorporates all these features to be avail-\nable for them to use. However, to the best of our knowledge,\nno one has integrated all these features in one model. In\nthis paper we tackle this challenging problem by proposing\na formal model for a language equipped with probability,\n\u2217Partially supported by National Basic Research Program of China (No.\n2002CB312001 and No. 2005CB321904) and the 211 project of The Min-\nistry of Education of China.\ntime and shared-variable concurrency. Our model is meant\nto facilitate the specification of complex software systems.\nThe shared-variable mechanism is typically used for\ncommunications among components running in parallel.\nAlthough shared-variable concurrency can be seen in many\nlanguages (e.g. the Java programming language, the Verilog\nhardware description language), it proves to be challenging\nto formalize it [11, 23, 24], not to mention other orthogonal\nfeatures like probability and time. In this paper we success-\nfully tackle this challenge by integrating time, probability\nand shared-variable concurrency in one model. The proba-\nbility feature is reflected by the probabilistic nondeterminis-\ntic choice, probabilistic guarded choice and the probabilistic\nscheduling of actions from different concurrent components\nin a program.\nAs advocated in Hoare and He\u2019s Unifying Theories of\nProgramming (UTP) [12], three different styles of mathe-\nmatical representations are normally used: operational, de-\nnotational, and algebraic ones, amongwhich the operational\nstyle is the most intuitive one. In order to elaborate more on\nthe intuition behind the proposed language and to formally\ndefine the behaviour of its programs, we start with the oper-\national semantics in this paper. Upon the operationalmodel,\nwe define a bisimulation relation, from which a collection\nof algebraic laws are derived. The completeness of the al-\ngebraic laws and the Galois connection between the oper-\national and algebraic theories are beyond the scope of this\npaper and would be addressed in future work.\nMuch related work has investigated the semantics for\nprobabilistic processes. Morgan and his colleagues ex-\nplored the abstraction and refinement for probabilistic pro-\ncesses using the weakest precondition (wp) approach [13,\n14, 15]. Hartog and her colleagues have studied the equiv-\nalence between operational and denotational semantics for\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\na variety of probabilistic processes [5, 6, 7, 8] using Ba-\nnach Space approach [4]. Nu\u00b4n\u02dcez extended Henessey\u2019s\n\u201ctesting semantics\u201d for a variety of probabilistic processes\n[18, 19, 20]. As an extension of the guarded command lan-\nguage, a simple probabilistic guarded command language\nwas formalized in [10] under the UTP framework. A set of\nalgebraic laws were then explored based on the denotational\nmodel.\nThe rest of this paper is organized as follows. Section 2\npresents our language equipped with probability, time and\nshared-variable concurrency. Section 3 is devoted to the op-\nerational semantics. A bisimulation relation is then defined\nin Section 4 and used for the basis of a set of algebraic laws\nin Section 5. Section 6 gives a prototype animation of the\noperational semantics and Section 7 concludes the paper.\n2 Probabilistic Language PTSC\nIn this paper we propose a probabilistic language\nPTSC (Probability, Time and Shared-variable Concur-\nrency), which involves the integration of probability, time\nand shared-variable concurrency. Apart from the concur-\nrency feature that exists in many conventional languages,\nprobability and time are the other two main features of our\nlanguage. The synchronization of different parallel com-\nponents is based on time controls. Overall, our language\nconsists of the following main features:\n(1) Probabilistic behaviour: This can be represented by\nprobabilistic nondeterminism, probabilistic guarded\nchoice or probabilistic parallel composition.\n(2) Timed behaviour: This can be reflected by event guard\n@ b (wait until b is satisfied) and time-delay command.\n(3) Shared-variable concurrency: The concurrency model\nemploys a shared-variable based communication\nmechanism.\nThe PTSC language has the following syntactical elements:\nP ::= Skip | x := e | if b then P else P\n| while b do P | @b P |#n P | P ; P\n| P \u0003 P | P \u0003p P | P \u2016p P\nNote that:\n(1) x := e is the atomic assignment. Skip behaves the\nsame as x := x.\n(2) Regarding @b P , when the Boolean condition b is sat-\nisfied, process P can have the chance to be sched-\nuled. As we consider models for closed systems, the\nprogram @b P can only let time advance when the\nBoolean condition b is not met. For #n P , after n\ntime units elapse, process P can be scheduled.\n(3) Similar to a conventional programming language,\nif b then P else P stands for the conditional,\nwhereas while b do P stands for the iteration.\n(4) The mechanism for parallel composition P \u2016p Q is\na shared-variable interleaving model with probability\nfeature. If process P can perform an atomic action,\nP \u2016p Q has conditional probability p to do that atomic\naction. On the other hand, if process Q can perform\nan atomic action, P \u2016p Q has conditional probability\n1\u2212p to perform that action.\n(5) \u0003 stands for the nondeterministic choice, where \u0003p\nstands for the probabilistic nondeterministic choice.\nP \u0003p Q indicates that the probability for P \u0003p Q to\nbehave as P is p, where the probability for P \u0003p Q to\nbehave as Q is 1\u2212p.\nIn order to facilitate algebraic reasoning, we enrich our\nlanguage with a guarded choice in our language. As our\nparallel composition has probability feature, the guarded\nchoice also shares this feature. Guarded choice is classi-\nfied into five types:\n(1) []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)}\n(2) []i\u2208I{@bi Pi}\n(3) []{#1 R}\n(4) []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)}\n[][]k\u2208K{@bk Qk}\n(5) []i\u2208I{@bi Pi}[]{#1 R}\nRegarding []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)}\nin the guarded choice type (1) and (4), it should satisfy the\nfollowing healthiness conditions:\n(a) \u2200i \u2022 (\u2228j\u2208Ji bij = true) and\n(\u2200j1, j2\u2022(j1 \u0006= j2) \u21d2 ((bij1\u2227bij2 ) = false))\n(b) +i\u2208I pi = 1\nThe first type is composed of a set of assignment-\nguarded components. The condition (a) indicates that\nfor any i \u2208 I , the Boolean conditions bij from\n\u201cchoicej\u2208Ji(bij&(xij := eij)Pij)\u201d are complete and dis-\njoint. Therefore, there will be exactly one component\nbij&(xij := eij)Pij selected among all j \u2208 Ji. Fur-\nthermore, for any i \u2208 I , the possibility for a component\n(xij := eij)Pij (where bij is met) to be scheduled is pi and\nit should satisfy the second healthiness condition.\nThe second type is composed of a set of event-guarded\ncomponents. If one guard is satisfied, the subsequent be-\nhaviour for the whole process will be followed by its subse-\nquent behaviour of the satisfied component.\nThe third type is composed of one time delay component.\nInitially, it cannot do anything except letting time advance\none unit.\nThe fourth type is the guarded choice composition of the\nfirst and second type of guarded choice. If there exists one\nbk (k \u2208 K) being satisfied currently, then the event @ bk is\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\nfired and the subsequent behaviour is Qk. If there is no sat-\nisfied bk, the behaviour of the fourth type of guarded choice\nis the same as that of the first type.\nThe fifth type is the compound of the second and third\ntype of guarded choice. Currently, if there exists i (i \u2208 I)\nsuch that bi is satisfied, then the subsequent behaviour of the\nwhole guarded choice is as Pi. On the other hand, if there\nis no i (i \u2208 I) such that bi is satisfied currently, then the\nwhole guarded choice cannot do anything initially except\nletting time advance one unit. The subsequent behaviour is\nthe same as the behaviour of R.\nAs the first type of guarded choice does not have time\nadvancing behavior, there is no type of guarded choice com-\nposing of the first and third type of guarded choice.\n3 Operational Semantics\nThe operational semantics of a language models the be-\nhaviour of a program in terms of execution steps, which\nare represented by transition relations. In our operational\nmodel, the transitions are expressed in the form of Plotkin\u2019s\nStructural Operational Semantics (SOS) [22]:\n\u3008P, \u03c3\u3009 \u03b2\u2212\u2192 \u3008P \u2032, \u03c3\u2032\u3009\nwhere, P stands for the program text that remains to be ex-\necuted. \u03c3 is the current state of the program.\nThe transitions can be classified into four kinds:\n(1) The first kind of transitions models an atomic action\nwith certain probability. In this paper, we consider as-\nsignment as an atomic action.\n\u3008P, \u03c3\u3009 c\u2212\u2192p \u3008P \u2032, \u03c3\u2032\u3009\nwhere, p stands for the probability for program P to\nperform the execution.\n(2) The second type models the transition of a time delay.\nTime advances in unit steps.\n\u3008P, \u03c3\u3009 1\u2212\u2192 \u3008P \u2032, \u03c3\u2032\u3009\n(3) The third type models the selection of the two compo-\nnents for non-deterministic choice. It can be expressed\nas:\n\u3008P, \u03c3\u3009 \u03c4\u2212\u2192 \u3008P \u2032, \u03c3\u3009\n(4) The fourth type models the triggered case of event @ b:\n\u3008P, \u03c3\u3009 v\u2212\u2192 \u3008P \u2032, \u03c3\u3009\nIn what follows, we shall present the operational rules for\nsequential programs, probabilistic guarded choice, and con-\ncurrent programs.\n3.1 Sequential Process\nA sequential program comprising a single assignment\nperforms an atomic action with probability 1. It cannot per-\nform any other types of transitions.\n\u3008x := e, \u03c3\u3009 c\u2212\u21921 \u3008\u03b5, \u03c3[e\/x]\u3009\nwhere, \u03b5 stands for the empty process.\nFor the conditional statement if b then P elseQ , the con-\ntrol flow will be passed to P with probability 1 if b is satis-\nfied, otherwise it will be passed to Q with probability 1.\n\u3008if b then P else Q , \u03c3\u3009 c\u2212\u21921 \u3008P, \u03c3\u3009, if b(\u03c3)\n\u3008if b then P else Q , \u03c3\u3009 c\u2212\u21921 \u3008Q, \u03c3\u3009, if \u00acb(\u03c3)\nHere b(\u03c3) returns the value of b in the state \u03c3.\nThe transitions for iteration are similar to conditional.\n\u3008while b do P, \u03c3\u3009 c\u2212\u21921 \u3008P ; while b do P, \u03c3\u3009, if b(\u03c3)\n\u3008while b do P, \u03c3\u3009 c\u2212\u21921 \u3008\u03b5, \u03c3\u3009, if \u00acb(\u03c3)\nTime delay can advance time in unit steps. It cannot do any\nother types of transitions.\n\u3008#n, \u03c3\u3009 1\u2212\u2192 \u3008#(n\u2212 1), \u03c3\u3009, where n > 1.\n\u3008#1, \u03c3\u3009 1\u2212\u2192 \u3008\u03b5, \u03c3\u3009\nThe event @b in @b P is satisfied if Boolean condition b\nis currently satisfied, otherwise it will let time advance one\nunit. We use \u201c v\u2212\u2192\u201d to model the event-triggered transition\ninstead of \u201c c\u2212\u2192\u2019.\n\u3008@b P, \u03c3\u3009 v\u2212\u2192 \u3008P, \u03c3\u3009, if b(\u03c3)\n\u3008@b P, \u03c3\u3009 1\u2212\u2192 \u3008@b P, \u03c3\u3009, if \u00acb(\u03c3)\nThe selection of process P or Q from P \u0003 Q is nondeter-\nministic.\n\u3008P \u0003Q, \u03c3\u3009 \u03c4\u2212\u2192 \u3008P, \u03c3\u3009\n\u3008P \u0003Q, \u03c3\u3009 \u03c4\u2212\u2192 \u3008Q, \u03c3\u3009\nFor the probabilistic nondeterministic choice P \u0003p Q, the\nprobability of the selection of P is p and the probability of\nthe selection of Q is 1\u2212 p.\n\u3008P \u0003p Q, \u03c3\u3009 c\u2212\u2192p \u3008P, \u03c3\u3009\n\u3008P \u0003p Q, \u03c3\u3009 c\u2212\u21921\u2212p \u3008Q, \u03c3\u3009\nThe process P ; Q will behave like P initially. After P ter-\nminates, Q will be executed.\nif \u3008P, \u03c3\u3009 \u03b2\u2212\u2192 \u3008\u03b5, \u03c3\u2032\u3009, then \u3008P ;Q, \u03c3\u3009 \u03b2\u2212\u2192 \u3008Q, \u03c3\u2032\u3009\nif \u3008P, \u03c3\u3009 \u03b2\u2212\u2192 \u3008P \u2032, \u03c3\u2032\u3009, then \u3008P ;Q, \u03c3\u3009 \u03b2\u2212\u2192 \u3008P \u2032;Q, \u03c3\u2032\u3009\nwhere \u03b2\u2212\u2192 can be \u03c4\u2212\u2192, v\u2212\u2192, c\u2212\u2192p and 1\u2212\u2192\n3.2 Probabilistic Guarded Choice\nIn order to investigate algebraic properties for parallel\ncomposition, we enrich the language with guarded choice.\nA guarded choice construct may perform transitions de-\npicted in the following five cases.\n(1) Let P = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)}.\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\n\u3008P, \u03c3\u3009 c\u2212\u2192pi \u3008Pij , \u03c3[eij\/xij ]\u3009, if bij(\u03c3)\nFor any i \u2208 I , there is only one j \u2208 Ji such that\nbij(\u03c3) = true. This indicates that program P can execute\nassignment xij := eij with probability pi when the corre-\nsponding condition bij(\u03c3) = true.\n(2) Let P = []i\u2208I{@bi Pi}.\n\u3008P, \u03c3\u3009 v\u2212\u2192 \u3008Pi, \u03c3\u3009, if bi(\u03c3)\n\u3008P, \u03c3\u3009 1\u2212\u2192 \u3008P, \u03c3\u3009, if \u2227i\u2208I bi(\u03c3) = false\nIf there exists i (i \u2208 I) such that bi(\u03c3) is satisfied, the\nevent @bi is enabled, thus Pi is followed, as depicted in the\nfirst rule. If \u2200i \u2022 bi(\u03c3) = false, no events are enabled, only\ntime can advance, as indicated in the second rule.\n(3) Let P = []{#1R}.\n\u3008P, \u03c3\u3009 1\u2212\u2192 \u3008R, \u03c3\u3009\nProcess P can only do time advancing transition because\nit only contains time-delay component. The subsequent be-\nhaviour after one time unit elapses is just the behaviour of\nprocess R.\n(4) Let P = []i\u2208I{[pi] choicej\u2208J (bij&(xij := eij)Pij)}\n[][]k\u2208K{@ck Qk}\n\u3008P, \u03c3\u3009 v\u2212\u2192 \u3008Qk, \u03c3\u3009, if ck(\u03c3) = true\n\u3008P, \u03c3\u3009 c\u2212\u2192pi \u3008Pij , \u03c3[eij\/xij ]\u3009,\nif bij(\u03c3) \u2227 (\u2200k \u2022 ck(\u03c3) = false).\nFor any k \u2208 K , if ck(\u03c3) = true, then the event \u201c@ck\u201d is\nfired. The first transition reflects this fact. For any i \u2208 I , if\nbij(\u03c3) = true and \u2200k \u2022 ck(\u03c3) = false, then process P can\nperform the corresponding assignment \u201cxij := eij\u201d. Now\nconsider the special case \u201cck(\u03c3) = true\u201d and bij(\u03c3) =\ntrue, we only allow event \u201c@ck\u201d to be fired and do not al-\nlow process P to perform assignment xij := eij . This fact\nis shown in the first transition and reflected by the additional\ncondition \u201c\u2200ck \u2022 ck(\u03c3) = false\u201d in the second transition.\n(5) Let P = []i\u2208I{@bi Pi}[]{#1R}.\n\u3008P, \u03c3\u3009 v\u2212\u2192 \u3008Pi, \u03c3\u3009 if bi(\u03c3)\n\u3008P, \u03c3\u3009 1\u2212\u2192 \u3008R, \u03c3\u3009 if\u2227i\u2208I bi(\u03c3) = false\nThe first transition indicates that event \u201c@bi\u201d is fired if\nbi(\u03c3) = true. However, if all bi(\u03c3) are evaluated to false,\nthen only time-advance branch can be selected.\n3.3 Parallel Process\nFor brevity of presentation, we first define the following\nfunction to represent intermediate processes:\npar(P,Q, p1) =df\n\u23a7\u23aa\u23aa\u23aa\u23aa\u23a8\n\u23aa\u23aa\u23aa\u23aa\u23a9\nP \u2016p1 Q if P \u0006= \u03b5 and Q \u0006= \u03b5\nP if P \u0006= \u03b5 and Q = \u03b5\nQ if P = \u03b5 and Q \u0006= \u03b5\n\u03b5 if P = \u03b5 and Q = \u03b5\nThis intermediate format can reduce the number of transi-\ntions for parallel composition by representing several cases\nin one single rule.\nNow we define two functions:\nstable(\u3008P, \u03c3\u3009) =df \u00ac( \u3008P, \u03c3\u3009 \u03c4\u2212\u2192 ) and\nstableE(\u3008P, \u03c3\u3009) =df \u00ac( \u3008P, \u03c3\u3009 v\u2212\u2192 )\nThe notation stable(\u3008P, \u03c3\u3009) indicates that process P cannot\nperform the transition representing nondeterministic choice\nunder state \u03c3, while stableE(\u3008P, \u03c3\u3009) indicates that process\nP cannot perform event-triggered transitions under state \u03c3.\nA probabilistic parallel composition may perform transi-\ntions of the following forms:\n(1) (a) If \u3008P, \u03c3\u3009 \u03c4\u2212\u2192 \u3008P \u2032, \u03c3\u3009 and stable(\u3008Q, \u03c3\u3009),\nthen \u3008P \u2016p1 Q, \u03c3\u3009 \u03c4\u2212\u2192 \u3008par(P \u2032, Q, p1), \u03c3\u3009.\n\u3008Q \u2016p1 P, \u03c3\u3009 \u03c4\u2212\u2192 \u3008par(Q,P \u2032, p1), \u03c3\u3009.\n(b) If \u3008P, \u03c3\u3009 \u03c4\u2212\u2192 \u3008P \u2032, \u03c3, \u3009 and\n\u3008Q, \u03c3\u3009 \u03c4\u2212\u2192 \u3008Q\u2032, \u03c3\u3009,\nthen \u3008P \u2016p1 Q, \u03c3\u3009 \u03c4\u2212\u2192 \u3008par(P \u2032, Q\u2032, p1), \u03c3\u3009\n(2) (a) If \u3008P, \u03c3\u3009 v\u2212\u2192 \u3008P \u2032, \u03c3\u3009 and stable(\u3008Q, \u03c3\u3009)\nand stableE(\u3008Q, \u03c3\u3009),\nthen \u3008P \u2016p1 Q, \u03c3\u3009 v\u2212\u2192 \u3008par(P \u2032, Q, p1), \u03c3\u3009.\n\u3008Q \u2016p1 P, \u03c3\u3009 v\u2212\u2192 \u3008par(Q,P \u2032, p1), \u03c3\u3009.\n(b) If \u3008P, \u03c3\u3009 v\u2212\u2192 \u3008P \u2032, \u03c3\u3009 and\n\u3008Q, \u03c3\u3009 v\u2212\u2192 \u3008Q\u2032, \u03c3\u3009,\nthen \u3008P \u2016p1 Q, \u03c3\u3009 v\u2212\u2192 \u3008par(P \u2032, Q\u2032, p1), \u03c3\u3009\n(3) If \u3008P, \u03c3\u3009 c\u2212\u2192p2 \u3008P \u2032, \u03c3\u2032\u3009 and\nstable(\u3008x, \u03c3\u3009) and stableE(\u3008x, \u03c3\u3009) (x = P, Q),\nthen \u3008P \u2016p1 Q, \u03c3\u3009 c\u2212\u2192p1\u00d7p2 \u3008par(P \u2032, Q, p1), \u03c3\u2032\u3009\n\u3008Q \u2016p1 P, \u03c3\u3009 c\u2212\u2192(1\u2212p1)\u00d7p2 \u3008par(Q,P \u2032, p1), \u03c3\u2032\u3009\n(4) If \u3008P, \u03c3\u3009 1\u2212\u2192 \u3008P \u2032, \u03c3\u2032\u3009 and \u3008Q, \u03c3\u3009 1\u2212\u2192 \u3008Q\u2032, \u03c3\u2032\u3009\nand\nstable(\u3008x, \u03c3\u3009) and stableE(\u3008x, \u03c3\u3009) (x = P, Q),\nthen \u3008P \u2016p1 Q, \u03c3\u3009 1\u2212\u2192 \u3008par(P \u2032, Q\u2032, p1), \u03c3\u2032\u3009.\nTransition (1)(a) stands for the case that one component\nmakes nondeterministic choice and another component is\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\nstable. The whole process also makes a nondeterministic\nchoice under this case. However, if both components make\nnondeterministic choice, then the whole process can make\nnondeterministic choice and the subsequent behaviour is the\nparallel composition of the remaining components. Transi-\ntion (1)(b) reflects this situation.\nThe second type stands for the event-fired case. The\nanalysis is similar to the transitions of type (1). Transition\n(3) covers the case of performing an atomic action. If pro-\ncess P can perform an atomic action with probability p2,\nthen process P \u2016p1 Q and Q \u2016p1 P can also perform the\nsame atomic action with probability p1\u00d7p2 and (1\u2212p1)\u00d7p2\nrespectively.\nIf both components can perform a time-advancing tran-\nsition, then the whole parallel process can also let time ad-\nvance. The aspect is reflected in transition (4).\n4 Bisimulation\nIn operational semantics the behaviour of programs is\nrepresented in terms of execution steps. A computation\nis thus composed of a sequence of transitions. Two syn-\ntactically different programs may have the same observa-\ntional behaviour. This means that we need to define pro-\ngram equivalence (conventionally denoted \u2248) based on a\nreasonable abstraction. In considering the equivalence of\nthe programs for our language, bisimulation is a useful ap-\nproach. It will also be applied in exploring algebraic laws\nof our language.\nIn what follows we shall give several auxiliary defini-\ntions before we present the definition for bisimulation.\nDefinition 1 We define the transition relation id=\u21d2p as fol-\nlows:\n\u3008P, \u03c3\u3009 id=\u21d2p \u3008P \u2032, \u03c3\u3009\n=df either P \u2032 = P and p = 1\nor\n\u2203n, P1, p1, . . . , Pn, pn \u2022\n\u3008P, \u03c3\u3009 \u03b21\u2212\u2192p1 \u3008P1, \u03c3\u3009 . . . \u03b2n\u2212\u2192pn \u3008Pn, \u03c3\u3009\nand Pn = P \u2032 and p = p1 \u00d7 . . .\u00d7 pn\nwhere \u03b2i\u2212\u2192pi can be of the forms c\u2212\u2192pi , \u03c4\u2212\u2192 and v\u2212\u2192. We\nassume pi = 1 in the latter two cases.\nNote that transition relation \u201c id=\u21d2p\u201d represents a se-\nquence of transitions which keep the program state un-\nchanged.\nDefinition 2 We define the following two transition rela-\ntions:\n(1) \u3008P, \u03c3\u3009 c=\u21d2p \u3008P \u2032, \u03c3\u2032\u3009\n=df \u2203P1 \u2022 \u3008P, \u03c3\u3009 id=\u21d2p1 \u3008P1, \u03c3\u3009 and\n\u3008P1, \u03c3\u3009 c\u2212\u2192p2 \u3008P \u2032, \u03c3\u2032\u3009 and\np = p1 \u00d7 p2\n(2) \u3008P, \u03c3\u3009 1=\u21d2p \u3008P \u2032, \u03c3\u3009\n=df \u2203P1 \u2022 \u3008P, \u03c3\u3009 id=\u21d2p \u3008P1, \u03c3\u3009 and\n\u3008P1, \u03c3\u3009 1\u2212\u2192 \u3008P \u2032, \u03c3\u3009\nNote that the relation c=\u21d2p is actually a composition of\nid=\u21d2p1 and c\u2212\u2192p2 (p = p1\u00d7p2), while 1=\u21d2p is a composition\nof id=\u21d2p and 1\u2212\u2192. These two auxiliary relations will help\nus to present our bisimulation relation in a more abstract\nmanner with respect to atomic actions and time-advancing.\nDefinition 3 If a transition \u3008P, \u03c3\u3009 \u03b2=\u21d2p1 \u3008P \u2032, \u03c3\u2032\u3009 is\nduplicated n times, we denote it as\n\u3008P, \u03c3\u3009 \u03b2=\u21d2n,p1 \u3008P \u2032, \u03c3\u2032\u3009\nwhere \u03b2=\u21d2p1 can be of the form c=\u21d2p1 or 1=\u21d2p1 .\nDefinition 4 A symmetric relation R is a bisimulation if\nand only if \u2200 \u3008P, \u03c3\u3009R\u3008Q, \u03c3\u3009\n(1) If \u3008P, \u03c3\u3009 x\u2212\u2192 \u3008P \u2032, \u03c3\u3009,\nthen \u2203Q\u2032 \u2022 \u3008Q, \u03c3\u3009 ( \u03c4\u2212\u2192 \u2228 v\u2212\u2192)\u2217 \u3008Q\u2032, \u03c3\u3009 and\n\u3008P \u2032, \u03c3\u3009R\u3008Q\u2032, \u03c3\u3009.\nwhere, x\u2212\u2192 can be of the transition type \u03c4\u2212\u2192 or v\u2212\u2192.\n(2) If \u3008P, \u03c3\u3009 c=\u21d2n1,p1 \u3008P \u2032, \u03c3\u2032\u3009,\n(2-1) if \u03c3 \u0006= \u03c3\u2032, then \u2203Q\u2032, n2, p2 \u2022\n\u3008Q, \u03c3\u3009 c=\u21d2n2,p2 \u3008Q\u2032, \u03c3\u2032\u3009 and\n\u3008P \u2032, \u03c3\u2032\u3009R\u3008Q\u2032, \u03c3\u2032\u3009 and\nn1 \u00d7 p1 = n2 \u00d7 p2.\n(2-2) if \u03c3 = \u03c3\u2032, then\neither\n\u3008P \u2032, \u03c3\u2032\u3009R\u3008Q, \u03c3\u2032\u3009 and n1 \u00d7 p1 = 1\nor \u2203Q\u2032, n2, p2 \u2022\n\u3008Q, \u03c3\u3009 c=\u21d2n2,p2 \u3008Q\u2032, \u03c3\u2032\u3009 and\n\u3008P \u2032, \u03c3\u2032\u3009R\u3008Q\u2032, \u03c3\u2032\u3009 and\nn1 \u00d7 p1 = n2 \u00d7 p2.\n(3) If \u3008P, \u03c3\u3009 1=\u21d2n1,p1 \u3008P \u2032, \u03c3\u3009,\nthen \u2203Q\u2032, n2, p2 \u2022\n\u3008Q, \u03c3\u3009 1=\u21d2n2,p2 \u3008Q\u2032, \u03c3\u3009 and\n\u3008P \u2032, \u03c3\u3009R\u3008Q\u2032, \u03c3\u3009 and\nn1 \u00d7 p1 = n2 \u00d7 p2.\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\nTwo configurations should have the same interface when\nstudying their equivalence; i.e., their state parts should be\nthe same. Our bisimulation relation is based on three dif-\nferent kinds of observations: a \u03c4 transition or a v-transition\n(triggered by an event), atomic action, and time advancing.\nNote that (2-2) in the above definition models the case\nthat if a process performs an atomic action without any con-\ntribution to the program state change, then its bisimilar pro-\ncess may or may not perform an atomic action with similar\neffect. This partly reflects the concept of weak bisimulation\n[16, 17].\nLemma 1 If S1 and S2 are bisimulations, then the follow-\ning relations are also bisimulations:\n(1) Id (2)S1 \u25e6 S2 (3) S1 \u222a S2\nwhere, Id is the identity relation and S1 \u25e6 S2 stands for the\nrelational composition of S1 and S2.\nDefinition 5\n(1) Two configurations \u3008P1, \u03c3\u3009 and \u3008P2, \u03c3\u3009 are bisimilar,\nwritten as \u3008P1, \u03c3\u3009 \u2248 \u3008P2, \u03c3\u3009, if there exists a bisimulation\nrelation R such that \u3008P1, \u03c3\u3009 R \u3008P2, \u03c3\u3009.\n(2) Two processes P and Q are bisimilar, denoted as P \u2248\nQ, if for any state \u03c3\n\u3008P, \u03c3\u3009 \u2248 \u3008Q, \u03c3\u3009\nLemma 2 \u2248 is an equivalence relation.\nTheorem 3 \u2248 is a congruence.\nProof We can proceed the proof by structural induction.\nThe detailed proof is left in Appendix B. \u0002\nThis theorem indicates that bisimilar relation\u2248 is preserved\nby all operators.\n5 Algebraic Laws\nOperational semantics can be used to deduce interesting\nproperties of programs. In this section we investigate the\nalgebraic laws of our timed language with probability and\nshared-variable concurrency.\nFor assignment, conditional, iteration, nondeterminis-\ntic choice and sequential composition, our language enjoys\nsimilar algebraic properties as those reported in [9, 12]. In\nwhat follows, we shall only focus on novel algebraic prop-\nerties with respect to time, probabilistic nondeterministic\nchoice and parallel composition.\nTwo consecutive time delays can be combined into a sin-\ngle one, where the length of the delay is the sum of the\noriginal two lengths.\n(delay-1) #n; #m = #(n + m)\nProbabilistic nondeterministic choice is idempotent.\n(prob-1) P \u0003p P = P\nHowever, it is not purely symmetric and associative. Its\nsymmetry and associativity rely on the change of the asso-\nciated probabilities:\n(prob-2) P \u0003p1 Q = Q \u00031\u2212p1 P\n(prob-3) P \u0003p (Q \u0003q R) = (P \u0003x Q) \u0003y R\nwhere x = p\/(p+ q\u2212p\u00d7 q) and y = p+ q\u2212p\u00d7 q\nSequential composition also distributes through probabilis-\ntic nondeterministic choice.\n(prob-4) P ; (Q \u0003p1 R) = (P ;Q) \u0003p1 (P ;R)\n(prob-5) (P \u0003p1 Q);R = (P ;R) \u0003p1 (Q;R)\nThe proof for law (prob-3) is given in Appendix C. Other\nproofs are similar and omitted.\nProbabilistic parallel composition is also not purely sym-\nmetric and associative. Its symmetry and associativity rely\non the change of the associated probabilities as well.\n(par-1) P \u2016p Q = Q \u20161\u2212p P\n(par-2) P \u2016p (Q \u2016q R) = (P \u2016x Q) \u2016y R\nwhere, x = p\/(p+q\u2212p\u00d7q) and y = p+q\u2212p\u00d7q\nIn what follows we give a collection of parallel expan-\nsion laws, which enable us to expand a probabilistic parallel\ncomposition to a guarded choice construct. As mentioned\nearlier, there exist five types of guarded choice. To take\ninto account a parallel composition of two arbitrary guarded\nchoices, we end up with fifteen different expansion laws.\nThe first five laws we shall discuss are with respect\nto parallel composition of assignment-guarded choice with\nany other choices. For brevity, we assume the first compo-\nnent is an assignment-guarded choice. In what follows, we\nshall list three laws, with the rest two left in Appendix A.\nIf the second component is also an assignment-guarded\nchoice, the scheduling rule is that any assignment could\nbe scheduled with the associated probability provided that\nits Boolean condition is satisfied. Suppose the assignment\nguard from the first component is scheduled, the subsequent\nbehaviour is the parallel composition of the remaining pro-\ncess of the first component with the whole second compo-\nnent. Law (par-3-1) below depicts this case.\n(par-3-1) Let\nP = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)} and\nQ = []k\u2208K{[qk] choicel\u2208Lk(bkl&(xkl := ekl)Pkl)}\nThen\nP \u2016r Q\n= []i\u2208I{[r \u00d7 pi] choicej\u2208Ji(bij&(xij := eij)\npar(Pij , Q, r)}\n[][]k\u2208K{[(1\u2212 r) \u00d7 qk] choicel\u2208Lk(bkl&(xkl := ekl)\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\npar(P,Qkl, r)}\nIf the second component is an event-guarded choice, the\nbehaviour of the parallel composition can be described as\nthe guarded choice of a set of assignment-guarded compo-\nnents and a set of event-guarded components. If an assign-\nment guard (from the first component) is scheduled first, the\nsubsequent behaviour is the parallel composition of the re-\nmaining part of the first component (Pij) with the second\ncomponent (Q); if an event guard is triggered, the subse-\nquent behaviour is the parallel composition of the first com-\nponent (P ) with the remaining part of the second compo-\nnent (Qk). This is presented in law (par-3-2).\n(par-3-2) Let\nP = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)}\nand\nQ = []k\u2208K{@ck Qk}\nThen\nP \u2016r Q\n= []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)par(Pij , Q, r)}\n[][]k\u2208K{@ck par(P,Qk, r)}\nIf the second component is a time delay construct, then\nonly assignment guards can be scheduled initially. For the\nwhole parallel composition, the subsequent behaviour fol-\nlowing the scheduled assignment guard is the parallel com-\nposition of the remaining part of the first component (Pij )\nwith the time delay component. The whole process does not\nhave time delay component. This case is expressed in law\n(par-3-3).\n(par-3-3) Let\nP = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)} and\nQ = []{#1 R}\nThen\nP \u2016r Q\n= []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)par(Pij , Q, r))}\nIn what follows, we consider parallel compositions\nwhere the first component is an event-guarded choice, while\nthe second component can be of any form. We shall present\nthree laws (law (par-3-6) to (par-3-8)) with the rest listed in\nAppendix A.\nIf the second component is also an event-guarded\nchoice, there are several scenarios. If one guard from\nthe first component is triggered but no guards from the\nsecond component are triggered, the subsequent behaviour\nis the parallel composition of the remaining part of the\nfirst component with the second component. If two guards\nfrom both components are triggered simultaneously, the\nsubsequent behaviour is the parallel composition of the\nremaining processes of both sides. This is illustrated in law\n(par-3-6).\n(par-3-6) Let P = []i\u2208I{@bi Pi} and\nQ = []j\u2208J{@cj Qj}\nThen\nP \u2016r Q\n= []i\u2208I{@(bi \u2227 \u00acc) par(Pi, Q, r)}\n[][]j\u2208J{@(cj \u2227 \u00acb) par(P,Qj , r)}\n[][]i\u2208I\u2227j\u2208J{@(bi \u2227 cj) par(Pi, Qj, r)}\nwhere, b = \u2228i\u2208I bi and c = \u2228j\u2208J cj\nIf the second component is a time delay construct, the\nwhole process will wait for some events to be triggered.\nThe whole process can also let time advance. Law (par-3-7)\nexpresses this case.\n(par-3-7) Let P = []i\u2208I{@bi Pi} and Q = []{#1 R}\nThen\nP \u2016r Q = []i\u2208I{@bi par(Pi, Q, r)}[]{#1 par(P,R, r)}\nIf the second component is the guarded choice of a set of\nassignment-guarded components and a set of event-guarded\ncomponents, any assignment guard can be scheduled. As\nboth components have event-guard components, there\nare also three possibilities for the guards to be triggered,\nas discussed in (par-3-6). This case is described in law\n(par-3-8).\n(par-3-8) Let P = []i\u2208I{@bi Pi} and\nQ = []j\u2208J{[qj ] choicek\u2208Kj (bjk&(xjk := ejk)Qjk)}\n[][]l\u2208L{@cl Rl}\nThen\nP \u2016r Q\n= []j\u2208J{[qj ] choicek\u2208Kj (bij&(xjk := ejk)par(Pjk , Q, r))}\n[][]i\u2208I{@(bi \u2227 \u00acc) par(Pi, Q, r)}\n[][]l\u2208L{@(cl \u2227 \u00acb) par(P,Rl, r)}\n[][]i\u2208I\u2227l\u2208L{@(bi \u2227 cl) par(Pi, Ql, r)}\nwhere, b = \u2228i\u2208I bi and c = \u2228l\u2208L cl\nWe shall next consider the parallel composition where\nthe first component is a time-delay guarded construct. We\npresent one law (par-3-10) below with the other two listed\nin Appendix A.\nThe following law captures the case where the second\ncomponent is also a time-delay guarded construct. The\nwhole process performs a time delay and then behaves as\nthe parallel composition of the remaining parts from both\nsides:\n(par-3-10) Let P = []{#1 R} and Q = []{#1 T }}\nThen\nP \u2016r Q = []{#1 par(R, T, r)}\nWe now move to the parallel composition where the\nfirst component comprises both assignment-guarded com-\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\nponents and event-guarded components. The following law\n(par-3-14) captures the scenario where the second com-\nponent consists of both event-guarded choices and time-\ndelays:\n(par-3-14) Let\nP = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)}\n[][]k\u2208K{@bk Rk}\nand Q = []l\u2208L{@cl Ql}[]{#1 T }\nThen\nP \u2016r Q\n= []i\u2208I{[pi] choicej\u2208J (bij&(xij := eij)par(Pij , Q, r))}\n[][]k\u2208K{@(bk \u2227 \u00acc) par(Rk, Q, r)}\n[][]l\u2208L{@(cl \u2227 b) par(P,Ql, r)}\n[][]k\u2208K\u2227l\u2208L{@(bk \u2227 cl) par(Rk, Ql, r)}\nwhere, b = \u2228k\u2208K bk and c = \u2228l\u2208L cl\nAnother similar law (par-3-13) is left in Appendix A.\nThe following law (par-3-15) is about the parallel com-\nposition of two guarded choices composing of both event-\nguarded components and time delay components.\n(par-3-15) Let P = []i\u2208I{@bi Pi}[]{#1 R} and\nQ = []j\u2208J{@cj Qj}[]{#1 T }\nThen\nP \u2016r Q\n= []k\u2208K{@(bi \u2227 \u00acc) par(Pi, Q, r)}\n[][]j\u2208J{@(cj \u2227 \u00acb) par(P,Qj , r)}\n[][]j\u2208J{@(bi \u2227 cj) par(Pi, Qj , r)}\n[]{#1 par(R, T, r)}\nwhere, b = \u2228i\u2208I bi and c = \u2228j\u2208J cj\n6 Animation of Operational Semantics\nOperational semantics provides a set of transition rules\nthat models how a program performs step by step. If we\ncan have an executed version of operational semantics, the\ncorrectness of operational semantics can be checked from\nvarious test results. This means that a simulator for the op-\nerational semantics of our proposed language is highly de-\nsirable.\nTransition rules for the operational semantics can be\ntranslated into Prolog logic programming clauses [3]. Pro-\nlog has been successfully applied in rapid-prototyping, in-\ncluding [1, 2]. Building on this, for the development of the\nsimulator of PTSC, we have selected Prolog as our program-\nming language.\nThe configuration in a transition can be expressed as a\nlist (indicated by square brackets) in Prolog:\n[P, Sigma ]\nwhere state Sigma can also be implemented as a list that\ncontains values for program variables.\nThe transitions for the operational semantics can be di-\nrectly translated into Prolog clauses. For some individual\nspecific transitions, there may be several transitions for that\nkind of transition expressed in Prolog because it covers sev-\neral different cases. For example, for the transition (3) of\nparallel composition (see page 4):\nIf \u3008P, \u03c3\u3009 c\u2212\u2192p2 \u3008P \u2032, \u03c3\u2032\u3009 and\nstable(\u3008x, \u03c3\u3009) and stableE(\u3008x, \u03c3\u3009) (x = P, Q),\nthen \u3008P \u2016p1 Q, \u03c3\u3009 c\u2212\u2192p1\u00d7p2 \u3008par(P \u2032, Q, p1), \u03c3\u2032\u3009.\n\u3008Q \u2016p1 P, \u03c3\u3009 c\u2212\u2192(1\u2212p1)\u00d7p2 \u3008par(Q,P \u2032, p1), \u03c3\u2032\u3009 .\nThis transition can be translated into Prolog clauses shown\nas below. Every clause can represent the specific individual\ncase.\n[ S1, Sigma ] \u2014[\u2032c\u2032, Y ] \u2212\u2192 [ epsilon, Sigma1 ] \u2227 stableB(S1, S2, Sigma)\n[ S1|X|S2, Sigma ] \u2014[\u2032c\u2032, X \u2217 Y ] \u2212\u2192 [S2, Sigma1 ]\n[ S1, Sigma ] \u2014[\u2032c\u2032, Y ] \u2212\u2192 [ epsilon, Sigma1 ] \u2227 stableB(S1, S2, Sigma)\n[ S2|X|S1, Sigma ] \u2014[\u2032c\u2032, (1 \u2212X) \u2217 Y ] \u2212\u2192 [S2, Sigma1 ]\n[ S1, Sigma ] \u2014[\u2032c\u2032, Y ] \u2212\u2192 [ S11, Sigma1 ] \u2227\nS11 \u223c= epsilon \u2227 stableB(S1, S2, Sigma)\n[ S1|X|S2, Sigma ] \u2014[\u2032c\u2032, X \u2217 Y ] \u2212\u2192 [ S11|X|S2, Sigma1 ]\n[ S1, Sigma ] \u2014[\u2032c\u2032, Y ] \u2212\u2192 [ S11, Sigma1 ] \u2227\nS11 \u223c= epsilon \u2227 stableB(S1, S2, Sigma)\n[ S2|X|S1, Sigma ] \u2014[\u2032c\u2032, (1 \u2212X) \u2217 Y ] \u2212\u2192 [ S2|X|S11, Sigma1 ]\nwhere,\nstableB(P,Q,\u03c3) =df stable(\u3008P,\u03c3\u3009) \u2227 stableE(\u3008P,\u03c3\u3009) \u2227\nstable(\u3008Q,\u03c3\u3009) \u2227 stableE(\u3008Q,\u03c3\u3009).\nHere, we use \u201cS1 |X |S2\u201d to represent \u201cS1 \u2016X S2\u201d and\n\u201c\u2014[\u2032c\u2032, X ] \u2212\u2192\u201d to represent \u201c c\u2212\u2192X\u201d in the Prolog clauses.\nMeanwhile, \u201cepsilon\u201d stands for the empty process \u03b5 and\n\u223c= stands for \u0006=.\nNext we use the example below to demonstrate how the sim-\nulator works. Consider the program (x := x + 1 ; x :=\nx + 2) \u20160.4 (x := 2 ; x := 4). From the execution based\non the simulator, we know there are six execution sequences\nleading the program to the terminating state, where the tran-\nsitions contain their own specific probability 1.\n? \u2212 track [ (x := x + 1; x := x + 2) |0.4| (x := 2; x := 4), [x = 0] ]. (1)\n1 \u2014[0, 0.4] \u2212\u2192 [ x = x + 2 |0.4| x = 2; x = 4, [x = 1] ] (2)\n2 \u2014[0, 0.4] \u2212\u2192 [ x = 2; x = 4, [x = 3] ] (3)\n3 \u2014[0, 1] \u2212\u2192 [ x = 4, [x = 2] ] (4)\n4 \u2014[0, 1] \u2212\u2192 [ epsilon, [x = 4] ] (5)\n2 \u2014[0, 0.6] \u2212\u2192 [ x = x + 2 |0.4| x = 4, [x = 2] ] (6)\n3 \u2014[0, 0.4] \u2212\u2192 [ x = 4, [x = 4] ] (7)\n4 \u2014[0, 1] \u2212\u2192 [ epsilon, [x = 4] ] (8)\n3 \u2014[0, 0.6] \u2212\u2192 [ x = x + 2, [x = 4] ] (9)\n4 \u2014[0, 1] \u2212\u2192 [ epsilon, [x = 6] ] (10)\n1 \u2014[0, 0.6] \u2212\u2192 [ x = x + 1; x = x + 2 |0.4| x = 4, [x = 2] ] (11)\n2 \u2014[0, 0.6] \u2212\u2192 [ x = x + 1; x = x + 2, [x = 4] ] (12)\n3 \u2014[0, 1] \u2212\u2192 [ x = x + 2, [x = 5] ] (13)\n4 \u2014[0, 1] \u2212\u2192 [ epsilon, [x = 7] ] (14)\n2 \u2014[0, 0.4] \u2212\u2192 [ x = x + 2 |0.4| x = 4, [x = 3] ] (15)\n3 \u2014[0, 0.4] \u2212\u2192 [ x = 4, [x = 5] ] (16)\n4 \u2014[0, 1] \u2212\u2192 [ epsilon, [x = 4] ] (17)\n3 \u2014[0, 0.6] \u2212\u2192 [ x = x + 2, [x = 4] ] (18)\n4 \u2014[0, 1] \u2212\u2192 [ epsilon, [x = 6] ] (19)\n1The notation [X,Y ] in the displayed execution sequence indicates that\nX is the duration of the transition and Y is the probability of the transi-\ntion. Meanwhile, \u201ctrack\u201d is the command in the simulator to display the\nexecution sequence.\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\nIn total, there are six execution sequences leading the orig-\ninal program to the terminating state, where each transition\nstep contains probability either 0.4, 0.6 or 1. These six exe-\ncution sequences are:\n(1)(2)(3)(4)(5) (1)(2)(6)(7)(8)\n(1)(2)(6)(9)(10) (1)(11)(12)(13)(14)\n(1)(11)(15)(16)(17) (1)(11)(15)(18)(19)\nwhere (i) stands for row i (given at the end of row i).\nIn summary, the simulator can display the execution se-\nquences of programs based on the operational semantics. It\nprovides an animation tool for our operational semantics.\nFrom various test examples including those above, the re-\nsults displayed give us additional confidence concerning the\nvalidity of the operational semantics.\n7 Conclusion\nIn this paper we integrated probability with a timed\nconcurrent language. The probability was added into\nnon-deterministic choice, parallel composition and guarded\nchoice. Parallel processes communicate with each other via\nshared variables. We formalized a structural operational\nsemantics for the language which incorporates time, con-\ncurrency and probability. On top of the operational model,\nan abstract bisimulation relation was defined and a rich set\nof algebraic laws have been derived for program equiva-\nlence. A prototype was also built for the animation of the\nexecution of probabilistic programs. As an immediate fu-\nture work, it would be interesting to work out a denota-\ntional model and investigate the consistency between oper-\national and denotational models. We would like to explore\nan observation-oriented model as advocated in UTP [12],\nwhich, we believe, would make the linking theory easier to\nbuild.\nReferences\n[1] J. P. Bowen. Combining operational semantics, logic pro-\ngramming and literate programming in the specification\nand animation of the Verilog Hardware Description Lan-\nguage. In Proc. IFM 2000: 2nd International Confer-\nence on Integrated Formal Methods, volume 1945 of Lec-\nture Notes in Computer Science, pages 277\u2013296. Springer-\nVerlag, November 2000.\n[2] J. P. Bowen, He Jifeng, and Xu Qiwen. An animatable oper-\national semantics of the Verilog Hardware Description Lan-\nguage. In Proc. ICFEM 2000: 3rd IEEE International Con-\nference on Formal Engineering Methods, pages 199\u2013207.\nIEEE Computer Society Press, September 2000.\n[3] W. F. Clocksin and C. S. Mellish. Programming in Prolog.\nSpringer-Verlag, 5th edition, 2003.\n[4] J. de Bakker and E. de Vink. Control Flow Semantics. The\nMIT Press, 1996.\n[5] J. den Hartog. Probabilistic Extensions of Semantic Models.\nPhD thesis, Vrije University, The Netherlands, 2002.\n[6] J. den Hartog and E. de Vink. Mixing up nondeteminism\nand probability: A premliminary report. In Proc PROB-\nMIV\u201998: Workshop on Probabilistic Methods in Verification,\nJune, 1998, volume 22 of Electronic Notes in Theoretical\nComputer Science. Elsevier, 1999.\n[7] J. den Hartog and E. de Vink. Verifying probabilistic pro-\ngrams using a Hoare like logic. International Journal of\nFoundations of Computer Science, 40(3):315\u2013340, 2002.\n[8] J. den Hartog, E. de Vink, and J. de Bakker. Metrix seman-\ntics and full abstractness for action refinement and proba-\nbilistic choice. In Proc MFCSIT: 1st Irish Conference on\nthe Mathematical Foundation of Computer Science and In-\nformation Technology, July, 2000, volume 40 of Electronic\nNotes in Theoretical Computer Science. Elsevier, 2001.\n[9] He Jifeng. Provably Correct Systems: Modelling of Com-\nmunication Languages and Design of Optimized Compil-\ners. The McGraw-Hill International Series in Software En-\ngineering, 1994.\n[10] He Jifeng, K. Seidel, and A. McIver. Probabilistic models\nfor the guarded command language. Science of Computer\nProgramming, 28(2-3):171\u2013192, 1997.\n[11] He Jifeng and Zhu Huibiao. Formalising Verilog. In Proc.\nICECS 2000: IEEE International Conference on Electron-\nics, Circuits and Systems, pages 412\u2013415. IEEE Computer\nSociety Press, December 2000.\n[12] C. A. R. Hoare and He Jifeng. Unifying Theories of Pro-\ngramming. Prentice Hall International Series in Computer\nScience, 1998.\n[13] A. McIver and C. Morgan. Partial correctness for proba-\nbilistic demonic programs. Theoretical Computer Science,\n266(1-2):513\u2013541, 2001.\n[14] A. McIver and C. Morgan. Abstraction, Refinement and\nProof of Probability Systems. Monographs in Computer Sci-\nence. Springer, October 2004.\n[15] A. McIver, C. Morgan, and K. Seidel. Probabilistic predi-\ncate transformers. ACM Transactions on Programming Lan-\nguages and Systems, 18(3):325\u2013353, 1996.\n[16] R. Milner. Communication and Concurrency. Prentice Hall\nInternational Series in Computer Science, 1990.\n[17] R. Milner. Communication and Mobile System: \u03c0-calculus.\nCambridge University Press, 1999.\n[18] M. Nu\u00b4n\u02dcez. Algebraic theory of probabilistic processes. The\nJournal of Logic and Algebraic Programming, 56:117\u2013177,\n2003.\n[19] M. Nu\u00b4n\u02dcez and D. de Frutos-Escrig. Testing semantics\nfor probabilistic LOTOS. In Proc FORTE\u201995: IFIP TC6\nEighth International Conference on Formal Description\nTechniques, Montreal, Canada, October 1995, volume 43 of\nIFIP Conference Proceedings, pages 367\u2013382. Chapman &\nHall, 1996.\n[20] M. Nu\u00b4n\u02dcez, D. de Frutos-Escrig, and L. F. L. D\u0131\u00b4az. Ac-\nceptance trees for probabilistic processes. In Proc CON-\nCUR\u201995: 6th International Conference on Concurrency,\nPhiladelphia, PA, USA, August, 1995, volume 962 of Lec-\nture Notes in Computer Science. Springer, 1995.\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\n[21] S. Park, F. Pfenning, and S. Thrun. A probabilistic language\nbased upon sampling functions. In Proc POPL 2005: 32nd\nACM SIGPLAN-SIGACT Symposium on Principles of Pro-\ngramming Languages, pages 171\u2013182. ACM, January 2005.\n[22] G. D. Plotkin. A structural approach to operational seman-\ntics. Technical Report 19, University of Aarhus, Denmark,\n1981. Also published in The Journal of Logic and Algebraic\nProgramming, volumes 60\/61:17\u2013139, 2004.\n[23] Zhu Huibiao. Linking the Semantics of a Multithreaded Dis-\ncrete Event Simulation Language. PhD thesis, London South\nBank University, UK, February 2005.\n[24] Zhu Huibiao and He Jifeng. A semantics of Verilog us-\ning Duration Calculus. In Proc. International Conference\non Software: Theory and Practice, pages 421\u2013432, August\n2000.\nAppendix\nA. More Parallel Expansion Laws\n(par-3-4) Let\nP = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)} and\nQ = []k\u2208K{[qk] choicel\u2208Lk(bkl&(xkl := ekl)Qkl)}\n[][]m\u2208M{@cm Rm}\nThen\nP \u2016r Q\n= []i\u2208I{[r \u00d7 pi] choicej\u2208Ji(bij&(xij := eij)\npar(Pij , Q, r))}\n[][]k\u2208K{[(1\u2212 r)\u00d7 qk] choicel\u2208Lk(bkl&(xkl := ekl)\npar(P,Qkl, r)}\n[][]m\u2208M{@ck par(P,Rm, r)}\n(par-3-5) Let\nP = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)} and\nQ = []l\u2208L{@cl Ql}[]{#1 R}\nThen\nP \u2016r Q\n= []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)par(Pij , Q, r))}\n[][]l\u2208L{@cl par(P,Ql, r)}\n(par-3-9) Let P = []i\u2208I{@bi Pi} and\nQ = []j\u2208J{@cj Qj}[]{#1 R}\nThen\nP \u2016r Q\n= []i\u2208I{@(bi \u2227 \u00acc) par(Pi, Q, r)}\n[][]j\u2208J{@(cj \u2227 \u00acb) par(P,Qj , r)}\n[][]i\u2208I\u2227j\u2208J{@(bi \u2227 cj) par(Pi, Qj, r)}\n[]{#1 par(P,R, r)}\nwhere, b = \u2228i\u2208I bi and c = \u2228j\u2208J cj\n(par-3-11) Let\nP = []{#1 T } and\nQ = []i\u2208I{[qi] choicej\u2208Ji(bjk&(xij := eij)Qij)}\n[][]k\u2208K{@ck Rk}\nThen\nP \u2016r Q\n= []i\u2208I{[qi] choicej\u2208Ji(bij&(xij := eij)par(P,Qij , r))}\n[][]k\u2208K{@ck par(P,Rk, r)}\n(par-3-12) Let P = []{#1 T } and\nQ = []i\u2208I{@bi Qi}[]{#1 R}\nThen\nP \u2016r Q = []i\u2208I{@bi par(P,Qi, r)}[]{#1 par(T,R, r)}\n(par-3-13) Let\nP = []i\u2208I{[pi] choicej\u2208Ji(bij&(xij := eij)Pij)}\n[][]k\u2208K{@bk Rk}\nand\nQ = []l\u2208L{[ql] choicem\u2208Ml(clm&(xlm := elm)Plm)}\n[][]n\u2208N{@cn Tn}\nThen\nP \u2016r Q\n= []i\u2208I{[r \u00d7 pi] choicej\u2208Ji(bij&(xij := eij)par(Pij , Q, r))}\n[][]l\u2208L{[(1\u2212 r)\u00d7 ql] choicem\u2208Ml(clm&(xlm := elm)\npar(P,Qlm, r))}\n[][]k\u2208K{@(bk \u2227 \u00acc) par(Rk, Q, r)}\n[][]n\u2208N{@(cn \u2227 \u00acb) par(Rk, Q, r)}\n[][]k\u2208K\u2227n\u2208N{@(bk \u2227 cn) par(Rk, Qn, r)}\nwhere, b = \u2228k\u2208K bk and c = \u2228n\u2208N cn\nB. Proof of Theorem 3: \u2248 is a congruence.\nAssume P \u2248 Q. We know for any state \u03c3,\n\u3008P, \u03c3\u3009 \u2248 \u3008Q, \u03c3\u3009. This means there exists a bisimula-\ntion S\u03c3 such that \u3008P, \u03c3\u3009 \u2248 \u3008Q, \u03c3\u3009. Let S = \u222a\u03c3 S\u03c3. We\nknow S is also a bisimulation.\n(1) For the proof of P ; R \u2248 Q ; R, let\nS1,1 =df Id\u222a{ (\u3008P ;R, \u03c3\u3009, \u3008Q;R, \u03c3\u3009) | \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009 }\nFor the proof of R ; P \u2248 R ; Q, let\nS1,2 =df S\u222a{ (\u3008R;P, \u03c3\u3009, \u3008R;Q, \u03c3\u3009) | \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009 }\n(2) For the proof of\nif b then P else R \u2248 if b then P elseR,\nlet\nS2,1 =df Id \u222a S\u222a\n{ (\u3008if b then P else R, \u03c3\u3009, \u3008if b then Q else R, \u03c3\u3009\n| \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009 },\nFor the proof of\nif b then R else P \u2248 if b then R else Q,\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\nlet\nS2,2 =df Id \u222a S\u222a\n{ (\u3008if b then R else P, \u03c3\u3009, \u3008if b then R else Q, \u03c3\u3009)\n| \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009 }\n(3) For the proof of while b do P \u2248 while b do Q, let\nS3\n=df Id\u222a\n{ (\u3008while bdoP, \u03c3\u3009, \u3008while bdoQ, \u03c3\u3009)\n| \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009 }\u222a\n{ (\u3008U ;while bdoP, \u03c3\u3009, \u3008V ;while bdoQ, \u03c3\u3009)\n| \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009 \u2227 \u3008U, \u03c3\u3009S \u3008V, \u03c3\u3009 }\n(4) For the proof of P \u0003R \u2248 Q \u0003R, let\nS4,1 =df Id \u222a S \u222a\n{(\u3008P \u0003R, \u03c3\u3009, \u3008Q \u0003R, \u03c3\u3009) | \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009}\nFor the proof of R \u0003 P \u2248 R \u0003Q, let\nS4,2 =df Id \u222a S \u222a\n{(\u3008R \u0003 P, \u03c3\u3009, \u3008R \u0003Q, \u03c3\u3009) | \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009}\n(5) For the proof of P \u0003p R \u2248 Q \u0003p R, let\nS5,1 =df Id \u222a S \u222a\n{(\u3008P \u0003p R, \u03c3\u3009, \u3008Q \u0003p R, \u03c3\u3009) | \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009}\nFor the proof of R \u0003p P \u2248 R \u0003p Q, let\nS5,2 =df Id \u222a S \u222a\n{(\u3008R \u0003p P, \u03c3\u3009, \u3008R \u0003p Q, \u03c3\u3009) | \u3008P, \u03c3\u3009S \u3008Q, \u03c3\u3009}\n(6) For the proof of the probabilistic guarded choice,\nwithout loss of generality, we only consider the first type of\nguarded choice here. Let\nT1 = []{[p] choice(b&(x := e)P, G1), G2} and\nT2 = []{[p] choice(b&(x := e)Q, G1), G2}\nIn order to consider the proof of T1 \u2248 T2, let\nS6\n=df Id \u222a S \u222a\n{(\u3008T1, \u03c3\u3009, \u3008T2, \u03c3\u3009) | \u3008P, \u03c3\u3009, S \u3008Q, \u03c3\u3009}\n(7) For the proof of P \u2016p R \u2248 Q \u2016p R, let\nS7,1\n=df Id \u222a S \u222a\n{(\u3008P \u2016p R, \u03c3\u3009, \u3008Q \u2016p R, \u03c3\u3009) | \u3008P, \u03c3\u3009S\u3008Q, \u03c3\u3009}\nFor the proof of R \u2016p P \u2248 R \u2016p Q, let\nS7,2\n=df Id \u222a S \u222a\n{(\u3008R \u2016p P, \u03c3\u3009, \u3008R \u2016p P, \u03c3\u3009) | \u3008P, \u03c3\u3009S\u3008Q, \u03c3\u3009}\nWe can show that each Si,j (or Si)is a bisimulation. \u0002\nC. Proof of Law (prob-3)\nNow we give the proof for the algebraic law (prob-3)\n(see page 6).\nLet\nS =df { ( \u3008P \u0003p1 (Q \u0003p2 R), \u03c3\u3009, \u3008(P \u0003x Q) \u0003y R), \u03c3\u3009 )\n| P,Q,R are programs \u2227 \u03c3 \u2208 \u03a3 \u2227 p1, p2 \u2208 (0, 1) }\nwhere, (1) x = p1\/(p1 + p2 \u2212 p1 \u00d7 p2),\ny = p1 + p2 \u2212 p1 \u00d7 p2\n(2) \u03a3 denaotes the set containing all the states.\nFurther, let T =df Id \u222a S \u222a S\u22121.\nNow we need to prove that T is a bisimulation relation.\n(1) From the transitions of \u0003p, we know that both\n\u3008P \u0003p1 (Q \u0003p2 R), \u03c3\u3009 and \u3008(P \u0003x Q) \u0003y R), \u03c3\u3009 cannot do\ntransition of type \u03c4\u2212\u2192 and v\u2212\u2192. This indicates that we don\u2019t\nneed to check the first item of bisimulation definition.\n(2) Now we need to prove the item (2) of bisimulation\nrelation for T .\n(a) If \u3008P, \u03c3\u3009 c=\u21d2n\u20321,p\u20321 \u3008P \u2032, \u03c3\u2032\u3009,\nthen \u3008P \u0003p1 (Q \u0003p2 R), \u03c3\u3009 c=\u21d2n\u20321,p1\u00d7p\u20321 \u3008P \u2032, \u03c3\u2032\u3009\nand\n\u3008(P \u0003x Q) \u0003y R, \u03c3\u3009 c=\u21d2n\u20321,u1 \u3008P \u2032, \u03c3\u2032\u3009\nwhere, u1 = y \u00d7 x\u00d7 p\u20321.\nFrom x and y, we know u1 = p1 \u00d7 p\u20321.\n(b) If \u3008Q, \u03c3\u3009 c=\u21d2n\u20322,p\u20322 \u3008Q\u2032, \u03c3\u2032\u3009,\nthen \u3008P \u0003p1 (Q \u0003p2 R), \u03c3\u3009 c=\u21d2n\u20322,(1\u2212p1)\u00d7p2\u00d7p\u20322 \u3008P \u2032, \u03c3\u2032\u3009\nand\n\u3008(P \u0003x Q) \u0003y R, \u03c3\u3009 c=\u21d2n\u20322,u2 \u3008P \u2032, \u03c3\u2032\u3009\nwhere, u2 = y \u00d7 (1\u2212 x)\u00d7 p\u20322.\nFrom x and y, we know that u2 = (1\u2212 p1)\u00d7 p2 \u00d7 p\u20322\n(c) If \u3008R, \u03c3\u3009 c=\u21d2n\u20323,p\u20323 \u3008R\u2032, \u03c3\u2032\u3009,\nthen\n\u3008P \u0003p1 (Q \u0003p2 R), \u03c3\u3009 c=\u21d2n\u20321,(1\u2212p1)\u00d7(1\u2212p2)\u00d7p\u20323 \u3008P \u2032, \u03c3\u2032\u3009\nand\n\u3008(P \u0003x Q) \u0003y R, \u03c3\u3009 c=\u21d2n\u20323,u3 \u3008P \u2032, \u03c3\u2032\u3009\nwhere, u3 = (1\u2212 y)\u00d7 p\u20323.\nFrom x and y, we know u3 = (1\u2212p1)\u00d7(1\u2212p2)\u00d7p\u20323.\nThe above analysis leads to the satisfactory of the item\n(2) of bisimulation definition for the pair of configurations\n( \u3008P \u0003p1 (Q \u0003p2 R), \u03c3\u3009, \u3008(P \u0003x Q) \u0003y R ), \u03c3\u3009).\n(3) The proof of item (3) of bisimulation relation for T is\nsimilar to the above proof of item (2). \u0002\nProceedings of the 30th Annual IEEE\/NASA Software Engineering Workshop SEW-30 (SEW'06)\n0-7695-2624-1\/06 $20.00  \u00a9 2006\n"}