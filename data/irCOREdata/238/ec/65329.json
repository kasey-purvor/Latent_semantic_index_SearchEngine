{"doi":"10.1007\/11576280_6","coreId":"65329","oai":"oai:dro.dur.ac.uk.OAI2:6224","identifiers":["oai:dro.dur.ac.uk.OAI2:6224","10.1007\/11576280_6"],"title":"The semantics and tool support of OZTA.","authors":["Dong, J. S.","Hao, P.","Qin, S.","Zhang, X."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Lau, K.-K.","Banach, R."],"datePublished":"2005-11-01","abstract":"In this work, we firstly enhance OZTA, a combination of Object-Z and Timed Automata, by introducing a set of timed patterns as language constructs that can specify the dynamic and timing features of complex real-time systems in a systematic way. Then we present the formal semantics in Unifying Theories of Programming for the enhanced OZTA. Furthermore, we develop an OZTA tool which can support editing, type-checking of OZTA models as well as projecting OZTA models into TA models so that we can utilize TA model checkers, e.g., Uppaal for verification","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65329.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6224\/1\/6224.pdf","pdfHashValue":"8d644fff0083bbf07e0a78860b018865c4ac0d69","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6224<\/identifier><datestamp>\n      2015-03-31T11:52:46Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        The semantics and tool support of OZTA.<\/dc:title><dc:creator>\n        Dong, J. S.<\/dc:creator><dc:creator>\n        Hao, P.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Zhang, X.<\/dc:creator><dc:description>\n        In this work, we firstly enhance OZTA, a combination of Object-Z and Timed Automata, by introducing a set of timed patterns as language constructs that can specify the dynamic and timing features of complex real-time systems in a systematic way. Then we present the formal semantics in Unifying Theories of Programming for the enhanced OZTA. Furthermore, we develop an OZTA tool which can support editing, type-checking of OZTA models as well as projecting OZTA models into TA models so that we can utilize TA model checkers, e.g., Uppaal for verification.<\/dc:description><dc:subject>\n        Timed patterns<\/dc:subject><dc:subject>\n         Semantics<\/dc:subject><dc:subject>\n         Tool and verification. <\/dc:subject><dc:publisher>\n        Springer <\/dc:publisher><dc:source>\n        Lau, K.-K. & Banach, R. (Eds.). (2005). Formal methods and software engineering : 7th International Conference on Formal Engineering Methods, ICFEM 2005, 1-4 November, 2005, Manchester, UK ; proceedings. Berlin: Springer , pp. 66-80, Lecture notes in computer science(3785)<\/dc:source><dc:contributor>\n        Lau, K.-K.<\/dc:contributor><dc:contributor>\n        Banach, R.<\/dc:contributor><dc:date>\n        2005-11-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6224<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/11576280_6<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6224\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/11576280_6<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6224\/1\/6224.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/11576280_6<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2005,"topics":["Timed patterns","Semantics","Tool and verification."],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nDong, J. S. and Hao, P. and Qin, S. and Zhang, X. (2005) \u2019The semantics and tool support of OZTA.\u2019, in\nFormal methods and software engineering : 7th International Conference on Formal Engineering Methods,\nICFEM 2005, 1-4 November, 2005, Manchester, UK ; proceedings. Berlin: Springer , pp. 66-80. Lecture notes\nin computer science. (3785).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/115762806\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nDong, J. S. and Hao, P. and Qin, S. and Zhang, X. (2005) 'The semantics and tool support \nof OZTA.', in Formal methods and software engineering : 7th International Conference on \nFormal Engineering Methods, ICFEM 2005, 1-4 November, 2005, Manchester, UK ; \nproceedings. Berlin: Springer , pp. 66-80. Lecture notes in computer science. (3785). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/11576280_6 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nThe Semantics and Tool Support of OZTA\nJ.S. Dong1 P. Hao?1 S.C. Qin2 X. Zhang1\n1 National University of Singapore\n{dongjs,haoping,zhangxi5}@comp.nus.edu.sg\n2 University of Durham, UK\nshengchao.qin@durham.ac.uk\nAbstract. In this work, we firstly enhance OZTA, a combination of Object-Z and\nTimed Automata, by introducing a set of timed patterns as language constructs\nthat can specify the dynamic and timing features of complex real-time systems in\na systematic way. Then we present the formal semantics in Unifying Theories of\nProgramming for the enhanced OZTA. Furthermore, we develop an OZTA tool\nwhich can support editing, type-checking of OZTA models as well as projecting\nOZTA models into TA models so that we can utilize TA model checkers, e.g.,\nUppaal for verification.\nKeywords: Timed Patterns, Semantics, Tool and Verification\n1 Introduction\nThe specification of complex real-time systems requires powerful mechanisms for mod-\nelling state, concurrency and real-time behavior. Integrated formal methods are well\nsuited for presenting complete and coherent requirement models for complex systems.\nThis research area has been active for a number of years (e.g. [4, 3]) with a particular\nfocus on integrating state based and event based formalisms (e.g. [9, 17]). However, the\nchallenge is how to provide a systematical semantic model for the integrated formal\nlanguages, and how to analyze and verify these models with tool support? For the first\nissue, we believe UTP [13] is particularly well suited for giving formal semantics for\nthe integrated specification languages and it has been used to define other integrated for-\nmalisms[12, 13]. For the second issue, we believe one effective approach is to project\nthe integrated requirement models into multiple domains so that existing specialized\ntools in these corresponding domains can be utilized to perform the checking and ana-\nlyzing tasks.\nOZTA [6] is an integrated formal language which builds on the strengths of Object-\nZ(OZ) [8, 16] and Timed Automata(TA) [1, 18] in order to provide a single notation\nfor modelling the static, dynamic and timing aspects of complex systems as well as\nfor verifying system properties by reusing Timed Automata\u2019s tool support. One novel\naspect of OZTA is its communication mechanism which supports partial and sometime\nsynchronization [6].\n? author for correspondence: haoping@comp.nus.edu.sg\nThe basic OZTA notation has been briefly described in an introductory paper [6] and\nthis paper enhances the OZTA notation by extending its automaton part with time pat-\ntern structures. However the main purpose of this paper is to formalize the semantics\nof OZTA and present an OZTA tool we developed for its editing, type-checking and\nprojection.\nThe rest of the paper is organized as follows, section 2 presents syntax of OZTA with\nextension of timed patterns; section 3 provides semantics of OZTA; section 4 shows the\ntool support of OZTA; and lastly section 5 gives the conclusion.\n2 Extending OZTA with Timed Patterns\nOZTA specifications are combinations of Object-Z schemas with Timed automatons.\nTimed Automata, with powerful mechanisms for designing real-time models using mul-\ntiple clocks, has well developed automatic tool support. However, if TA is considered\nto be used to capture real-time requirements, then one often need to manually cast those\ntiming patterns into a set of clock variables with carefully calculated clock constraints,\nwhich is a process that is close to design rather than specification. In our previous\npaper [7], we studied time automata patterns and found that a set of common timed\npatterns, such as deadline, timeout, waituntil, can be used to facilitate TA design in a\nsystematic way. In this paper before presenting the semantics of OZTA, we firstly give a\nfull version of the OZTA syntax, in which the automaton part of the the OZTA notation\nis extended with timed pattern structures. The enhanced specification of OZTA syntax\nwith the notion of timed patterns is presented as follows:\nSpecification ::= CDecl; ...; CDecl\nCDecl ::=\u00b9 Visiblist; InheritC; StateSch; INIT; StaOp; [TADecl]\nVisiblist ::= VisibAttr; VisibOp\nInheritC ::= InheritCName\nStateSch ::= CVarDecl\nCVarDecl ::= v : T\nStaOp ::= \u2206(AttrName | ActName),CVarDecl \u2022 Pred(u, v\u2032)\nTADecl ::= ClockDecl; TA\nClockDecl ::= x : Clock\nTA ::= State | State \u2022 Inv(x, n) | [(Event)][(Reset(x))][(Guard(x, n))] \u2022 TA | Wait (x, n)\n| TA \u2022 Deadline (x, n) | TA \u2022 WaitUntil (x, n) | TA \u2022 Timeout(x, n) \u2022 TA\n| TA; TA | TA 2 TA | TA u TA | \u00b5X \u2022 TA(X) | TA1 \u2016 TA2 \u2022 S\nState ::= StaOp | StaCtr\nEvent ::= Event | Event! | Event?\nReset ::= ( := )\u3008\u3008Clock \u00d7 N\u3009\u3009\nGuard ::= ( <= )\u3008\u3008Clock \u00d7 N\u3009\u3009 | ( >= )\u3008\u3008Clock \u00d7 N\u3009\u3009 | ( < )\u3008\u3008Clock \u00d7 N\u3009\u3009\n| ( > )\u3008\u3008Clock \u00d7 N\u3009\u3009 | ( \u2227 )\u3008\u3008\u03a6\u00d7 \u03a6\u3009\u3009 | true\nInvar ::= ( <= )\u3008\u3008Clock \u00d7 N\u3009\u3009 | ( < )\u3008\u3008Clock \u00d7 N\u3009\u3009 | true\nS ::= { 7\u2194 }\u3008\u3008Event \u00d7 Event\u3009\u3009 | { \u2194 }\u3008\u3008Event \u00d7 Event\u3009\u3009 | { \u2192 }\u3008\u3008Event \u00d7 Event\u3009\u3009\nin which, the argument x represents a certain clock, and n is a natural number; StaCtr\nrepresents a control state and StaOp is an operation state corresponding to an Object-\nZ operation; State \u2022 Inv(x, n) specifies a state with a local invariant; Event, Reset(x),\nGuard(x, n) are transition labels, which respectively specifies event (Event! is an output\nevent, Event? is an input event), clock reset and clock constraint; the three branches of\nS respectively represent the construct of handshaking synchronization, partial synchro-\nnization and sometime synchronization; the rest of the TA expressions are the timed\nautomata patterns which can be directly utilized to construct timed automata.\n2.1 The Pattern Structure\nEach of the pattern expressions has a graphic presentation. Some TA patterns are pre-\nsented in Figure 1 - 4, the rest can be found in [7]. In these graphical TA patterns, an\nautomaton A is abstracted as a triangle, the left vertex of this triangle or a circle attached\nto the left vertex represents the initial state of A, and the right edge represents the ter-\nminal state of A. For example, Figure 1 demonstrates how two timed automatons can\nA1 A2\nFig. 1. Sequential Composition \u2018;\u2019\nx :=0\nA\nx<=t\nFig. 2. Deadline \u2018Deadline(x, t)\u2019\nA2\nA1\nFig. 3. External Choice \u20182\u2019\n0ss\nA\nFig. 4. Recursion\u2018u s0 \u2022 A(s0)\u2019\nbe sequentially composed. By linking the terminal state of A1 with the initial state of\nA2, the resultant automaton passes control from A1 to A2 when A1 goes to its terminal\nstate. Figure 2 shows one of the common timing constraint patterns \u2013 deadline. There is\na single clock x. When the system switches to the automaton A, the clock x gets reset to\n0. The local invariant x <= t covers each state of the timed automaton A and specifies\nthe requirement that a switch must occur before t time unit for every state of A. Thus\nthe timing constraint expressed by this automaton is that A should terminate no later\nthan t time units. Figure 3 shows the external choice pattern of two timed automatons\nA1 and A2 which share an initial state, and the environment has the choice to trigger\none of them by different external events. Figure 4 illustrates the recursion pattern of a\ntimed automaton A, s0 is the fixed point, The recursion is achieved by diverting all the\ntransitions from pointing to s0 to the initial state of A.\n2.2 An Example: Frog Puzzle Game\nA traditional frogs puzzle game is that: given seven stones, three white frogs at left\nfacing right and three black frogs at right facing left.\nA frog can move in the direction it is facing to an empty stone, which is adjacent or is\nreached by jumping over a frog on an adjacent stone. To complex the puzzle, we add\n some timing constraints to the moves of frogs, i.e., each frog takes at least 1 time units\nbut no more than 2 time units to move to its next position. We define that the puzzle is\nsolved if a sequence of moves can be found that will exchange the positions of the black\nand white frogs within 30 time units. The OZTA model of this frog puzzle is given as\nfollow,\nPosn == 1..7\nPuzzle\nwf , bf : PPosn\nnf : Posn\nwin : B\n#wf = 3 \u2227 #bf = 3\nINIT\nwf = {1, 2, 3} \u2227 bf = {5, 6, 7}\nnf = 4\nBlackMove\n\u2206(bf , nf )\n\u00ac(bf = {1, 2, 3} \u2227 wf = {5, 6, 7}\n\u2227 nf = 4) \u2227 nf \u2032 rightb nf\nbf \u2032 = bf \u222a {nf} \u2212 {nf \u2032}\nLose1\n\u2206(win)\nwin\u2032 = false\nWin\n\u2206(win)\nbf = {1, 2, 3} \u2227 wf = {5, 6, 7} \u2227\nnf = 4\nwin\u2032 = true\nWhiteMove\n\u2206(wf , nf )\n\u00ac(bf = {1, 2, 3} \u2227 wf = {5, 6, 7} \u2227\nnf = 4)\nnf \u2032 leftw nf\nwf \u2032 = wf \u222a {nf} \u2212 {nf \u2032}\nLose2\n\u2206(win)\nnf 6\u2208 rightb(| bf |) \u2227 nf 6\u2208 leftw(| wf |)\nwin\u2032 = false\nx, y : clock\nBlackMove\ny<=2\ns1\nWin\nLose_1\ns0\nWhiteMove\ny<=2\nLose_2\nx:=0 count\nx<=30\ny:=0\nx<30\ny>=1\nx>30\ny:=0\nx<30\ny<=1\nrightb : Posn \u2194 Posn\n\u2200 i, j : Posn \u2022\ni rightb j \u21d4 i = j + 1 \u2228 i = j + 2\nleftw : Posn \u2194 Posn\n\u2200 i, j : Posn \u2022\ni leftw j \u21d4 i = j\u2212 1 \u2228 i = j\u2212 2\nIn this model, we define the empty stone also as a frog object nf . BlackMove captures the\nposition exchanges between the black frogs and the empty stone; same for WhiteMove;\nWin defines the situation when the puzzle is solved. The game begins with a count\nevent after its initial state; player will lose the game when the time is out as described\nby (x > 30) \u2022 Lose1 or whenever the frogs are all jammed by each other in the middle\nway as described by Lose2. The graphical TA part of the model can be derived from the\nfollowing textual specification according to the sequential composition, external choice,\ndeadline, waituntil, and recursion patterns:\nTA =\u0302 \u00b5 Y \u2022 (x := 0)(count) \u2022\n\u00b5 X \u2022 ((x < 30) \u2022 BlackMove \u2022 Deadline(y, 2) \u2022 WaitUntil(y, 1); X)\n2 ((x < 30) \u2022 WhiteMove \u2022 WaitUntil(y, 1) \u2022 Deadline(y, 2); X)\n2 ((x <= 30) \u2022 Win; Y) 2 ((x > 30) \u2022 Lose1; Y) 2 (Lose2; Y)\nTo illustrate the synchronization mechanism of OZTA, we consider several puzzle-\nsolving systems:\nThe handshaking synchronization operator \u2194 indicates\nthat the two switches labelled count in the objects of p0,\np1 were identical, i.e., the automata must synchronize on\nthese switches, as illustrated in Figure 5(1). The product\nof the two timed automata effectively ensures that the two\npuzzles start at same time point in the competition while\noperate independently and concurrently.\nPuzzleC1\np0, p1 : Puzzle\n(p0 \u2016 p1) \u2022 {p0.count \u2194 p1.count}\nThe partial synchronization operator \u2192 indicates that\nwhenever the p0.count is taken, then there must be syn-\nchronization with the switch p1.count. However, the switch\np1.count can occur independent of the switch p0.count.\nThe partial synchronization between p0 and p1 is illus-\ntrated in Figure 5(2).\nPuzzleC2\np0, p1 : Puzzle\n(p0 \u2016 p1) \u2022 {p0.count \u2192 p1.count}\nThe sometime synchronization operator 7\u2194 indicates that\nwhen any of the switches p0.count or p1.count is taken\nthere may or may not be synchronization with the switch\np1.count or p0.count respectively. The sometime synchro-\nnization between p0 and p1 is illustrated in Figure 5(3).\nPuzzleC3\np0, p1 : Puzzle\n(p0 \u2016 p1) \u2022 {p0.count 7\u2194 p1.count}\np0.s0 p0.s1\np1.s0 p1.s1\np0.s0 p0.s1\np1.s0 p1.s1\np0.s0 p0.s1\np1.s0 p1.s1\ncount\ncount\n(1)\ncount\n(2)\ncount\np1.count\np0.count\ncount\ncount\np1.count\n(3)\nFig. 5. Handshaking, Partial and Sometime Synchronization\n3 The Semantics of OZTA\nBefore building the semantic model for OZTA, we need to choose an appropriate model\nof time. There are two typical time models: a discrete model and a continuous model.\nThe current semantic model for OZTA [6] is a primitive operational semantics based\non continuous time without pattern features. To make our model with the extension of\ntimed patterns and more apt for exploration of algebraic refinement laws, we choose the\ndiscrete model. The discrete time model has also been adopted by the Sherif and He\u2019s\nwork [14] on the semantics for time Circus [12] and Qin, Dong and Chin\u2019s work [13]\non the semantics for TCOZ.\n3.1 The Automata Model\nThe following meta variables are introduced in the alphabet of the observations of the\nOZTA automata behavior, some of which are similar to those in the previous UTP\nsemantic frameworks [13]. The key difference is that we now take consideration of\nclock variable updates.\n\u2013 ok, ok\u2032: Boolean. These two variables are introduced to denote the observations of\nautomaton initiation and termination. ok records the observation that the automa-\nton has started. When ok is false, the automaton has not started, so no observation\ncan be made. ok\u2032 records the observation that the automaton has terminated or has\nreached an intermediate stable state. The automaton is deadlock when ok\u2019 is false.\n\u2013 wait, wait\u2032: Boolean. When wait is true, it states that the automaton starts in an\nintermediate state. When wait\u2032 is true, the automaton has not terminated; when it is\nfalse, it indicates a final observation.\n\u2013 state, state\u2032: Var \u2192 Value. In order to record the state of data variables(class at-\ntributes and local variables) that occur in an automaton, these two variables are\nintroduced to map each variable to a value in the corresponding observations.\n\u2013 tr, tr\u2032: seq(seq Event \u00d7 PEvent). The two variables are introduced to record the\nsequence of observations on the interactions between an automaton and its envi-\nronment. tr records the observations that occurred before the automaton starts and\ntr\u2032 records the final observation. Each element of the sequence represents an obser-\nvation over one time unit. Each observation element is composed of a tuple, where\nthe first element of the tuple is the sequence of events that occurred during the time\nunit, and the second one is the associated set of refusals at the end of the same time\nunit. The set Event denotes all possible communicating events.\n\u2013 trace: seq Event. This variable is used to record a sequence of events that take place\nso far since the last observation. It can be derived from tr, tr\u2032 as the following:\nflat(tr)a trace = flat(tr\u2032)\nwhere a is a concatenation operator and flat :\nseq(seq(Event \u00d7 PEvent)\u2192 seq Event\nflat(\u3008\u3009) =\u0302 \u3008\u3009 flat(\u3008(es, ref )\u3009a tr) =\u0302 esa flat(tr)\n\u2013 cval, cval\u2032: Clock \u2192 N\u222a{NULL}. Among which Clock denotes all clock variables;\nN is the set of natural number; NULL is a number of no meaning, denoting the\nsituation that the clock has not been enabled yet.\nSome other definitions are given to facilitate the description of OZTA semantics.\n\u2013 The predicate no interact(trace) denotes that there are no communication events\nrecorded in trace.\nno interact(s) =\u0302 s = \u3008\u3009\n\u2013 The operator \u25e6 is the composition of two sequentially made observations. For two\nobservation predicate P(v, v\u2032), Q(v, v\u2032), where v, v\u2032 represents respectively the ini-\ntial and final versions of all observation variables, the composition of them is:\nP(v, v\u2032) \u25e6 Q(v, v\u2032) =\u0302 \u2203 v0 \u2022 P(v, v0) \u2227 Q(v0, v\u2032)\n\u2013 A binary relation \u00b9 is the ordinary subsequence relation between sequences of the\nsame type.\n\u2013 The predicate clock update(x, n) denotes that the value of clock variable x is up-\ndated to a natural number n.\nclock update(x, n) =\u0302 cval\u2032 = cval\u2295 {x 7\u2192 n}\n3.2 The Semantics of Automata with Patterns\nIn this section, the observation model for OZTA automata is developed. We use TA to\nstand for the semantics of an automaton TA instead of the term [[TA]] in UTP. Before\nwe go into the detail of the semantics for each Automata expressions, A healthiness\ncondition R must be satisfied by the semantics predicate TA for any automaton, which\nis defined as,\nR(TA) =\u0302 TA = (TA \u2227 tr t\u00b9 tr\u2032)\ntr\nt\u00b9 tr\u2032 states that, given two timed traces, tr and tr\u2032, tr\u2032 is an expansion of tr [13].\nState and Control Operation\n\u2013 State Operation\nStaOp =\u0302 \u2206(b), a : T \u2022 Pred(u, v\u2032) =\u0302 ok\u2032 \u2227 \u00ac wait\u2032 \u2227 no interact(trace) \u2227 (\u2200 x :\ndom cval | cval(x) 6= NULL \u2022 clock update(x,#tr\u2032 \u2212#tr)) \u2227 ((\u2203 val1 \u2022 state\u2032 =\nstate\u2295{a 7\u2192 val1})\u25e6(\u2203 val \u2022 state\u2032 = state\u2295{a 7\u2192 val} \u2227 Pred(state(u), state\u2032(v\u2032))))\nIn an operation state, time may progress, no event occurs, state will be updated.\nNULL means the clock has no value, and it has not been initialized yet.\n\u2013 Control Operation\nStaCtr =\u0302 ok\u2032 \u2227 \u00ac wait\u2032 \u2227 no interact(trace) \u2227 (\u2200 x : dom cval | cval(x) 6=\nNULL \u2022 clock update(x,#tr\u2032 \u2212#tr))\nIn a control state, time may progress, no event occurs and no state updates.\n\u2013 Urgent state\nStaU =\u0302 (StatOP \u2228 StaCtr) \u2227 #tr\u2032 = #tr\nThe semantics of an urgent state is that the automaton will pass the control from\nthe urgent state to a next state without delay.\n\u2013 Init State\nStaI =\u0302 ok\u2032 \u2227 \u00acwait\u2032 \u2227 tr = \u3008\u3009 \u2227 no interact(trace) \u2227 \u2200 x : dom cval \u2022 cval(x) =\nNULL)\nThe sequence of observations of an OZTA model starts from an initial state. The\nvalue of each clock variable is initially set to NULL.\nLocal Invariant In verification tools, e.g. Uppaal, local invariants are often restricted\nto constraints that are downwards closed, i.e., in the form: x < n or x \u2264 n, where n is\nnatural number.\nState \u2022 (x < n) =\u0302 x \u2208 dom cval \u2227 (State \u2227 (cval(x) + #tr\u2032 \u2212 #tr) < n \u2227 (\u2200 c :\ndom cval | cval(c) 6= NULL \u2022 clock update(x, cval(c) + #tr\u2032 \u2212#tr)) \u2228 Stop)\nState \u2022 (x <= n) =\u0302 x \u2208 dom cval \u2227 (State \u2227 (cval(x) + #tr\u2032 \u2212 #tr) \u2264 n \u2227 (\u2200 c :\ndom cval | cval(c) 6= NULL \u2022 clock update(x, cval(c) + #tr\u2032 \u2212#tr)) \u2228 Stop)\nClock Reset Reset(x) =\u0302 ok\u2032 \u2227 \u00acwait\u2032 \u2227 #tr\u2032 = #tr \u2227 state\u2032 = state \u2227 x \u2208\ndom cval \u2227 clock update(x, 0)\nIt can also be described in this way,\nReset(x) \u2022 TA =\u0302 Reset(x); TA\nConsecutive clock reset operations are combined into one atomic reset operation.\nEvent Event =\u0302 ok\u2032 \u2227 \u00acwait\u2032 \u2227 trace = \u3008Event\u3009 \u2227 state\u2032 = state \u2227 #tr\u2032 = #tr\nIt can also be described in this way,\nEvent \u2022 TA =\u0302 Event; TA\nClock Constraint An automaton can be guarded by clock constraints. The clock-\nguarded automaton Guard(x, n) \u2022 TA behaves as TA if the condition Guard(x, n) is\ninitially satisfied.\nGuard(x, n) \u2022 TA =\u0302 (\u2203 x : Clock \u2022 x \u2208 dom cval) \u2227 (Guard(x, n) \u2227 TA \u2228 \u00ac Guard(x, n)\n\u2227 Stop)\nIt enjoys the following properties:\n\u2013 false \u2022 TA = Stop\n\u2013 true \u2022 TA = TA\n\u2013 Guard(x, n) \u2022 Stop = Stop\n\u2013 Guard1(x1, n1) \u2022 (Guard2(x2, n2) \u2022 TA) =\n(Guard1(x1, n1) \u2227 Guard2(x2, n2)) \u2022 TA\n\u2013 Guard(x, n) \u2022 (TA1; TA2) = (Guard(x, n) \u2022 TA1); \u2022 TA2\nWait The Wait construct specifies an automaton in which time idles for n time units\nthen terminates.\nWait(x, n) =\u0302 ok\u2032 \u2227 \u00ac wait\u2032 \u2227 #tr\u2032 \u2212 #tr = n \u2227 (\u2200 i : #tr\u2032 < i < #tr \u2022\nno interact(pi1(tr\u2032(i))))\nIt is subjected to the following laws.\n\u2013 WAIT n1; WAIT n2 = WAIT(n1 + n2)\n\u2013 STOP \u2022 Timeout(x, n) \u2022 TA = WAIT n; TA\nDeadline The Deadline construct TA \u2022 Deadline imposes a timing constraint on a\ntimed automaton, which requires that TA should terminate no later than n time units.\nTA \u2022 Deadline(x, n) =\u0302 (ok \u2227 x \u2208 dom cval \u2227 clock update(x, 0))\u25e6(TA \u2227 #tr\u2032\u2212#tr \u2264\nn)\nWaitUntil The WaitUntil construct TA \u2022 WaitUntil(x, n) constrains automation TA to\nfinish its process no less than n time units.\nTA \u2022 WaitUntil(x, n) =\u0302 (TA \u2227 (#tr\u2032 \u2212#tr \u2265 n)) \u2228 ((\u2203 tro \u2022 tr \u00b9 tro \u00b9 tr\u2032 \u2227 #tro \u2212\n#tr < n) \u2227 ((ok \u2227 x \u2208 dom cval \u2227 clock update(x, 0))\u25e6TA[tro\/tr\u2032, true\/ok\u2032, false\/wait\u2032]\u25e6\nWait(x, n\u2212 (#tro \u2212#tr))[tro\/tr]))\nTimeout The Timeout construct TA1 \u2022 Timeout(x, n) \u2022 TA2 specifies that if no tran-\nsition has been triggered for n time units in timed automaton TA1, then TA1 will be\ntimeout and the control will be passed to TA2.\nTA1 \u2022 Timeout(x, n) \u2022 TA2 =\u0302 (ok \u2227 x \u2208 dom cval \u2227 clock update(x, 0)) \u25e6 ((TA1 \u2227\nno interact(trace) \u2227 #tr\u2032 \u2212#tr \u2264 n) \u2228 (\u2203 k : #tr < k \u2264 tr + n,\u2203 tro \u2022 pi1(tr\u2032(k)) 6=\n\u3008 \u3009 \u2227 tr \u00b9 tro \u2227 #tro\u2212#tr = k \u2227 (\u2200 i : #tr < i < #tr+k \u2022 no interact(pi1(tr\u2032(i))) \u2227\ntro(i) = tr\u2032(i)) \u2227 TA1[tro\/tr]) \u2228 (\u2203 tro \u2022 tr \u00b9 tro \u2227 #tro \u2212#tr = n \u2227 (\u2200 i : #tr < i <\n#tr + n \u2022 no interact(pi1(tr\u2032(i))) \u2227 tro(i) = tr\u2032(i)) \u2227 TA2[tro\/tr]))\nRecursion We define the semantics of recursion same as [13],\n\u00b5X \u2022 TA(X) =\u0302 u{X | X w TA(X)}, where X is the fixed point.\nParallel Composition The parallel composition of two automatons represents all the\npossible behaviors of both automatons which are synchronized on a specific set of\nevents and on the time when the events occur.\nIn addition to the handshake synchronization, OZTA also supports other two synchro-\nnization mechanisms, namely, partial synchronization and sometime synchronization.\nGiven a parallel composition TA1 |[E]| TA2 \u2022 S, where E denotes the set of events that\nTA1 and TA2 will communicate with, and S contains elements of the form a \u2192 b, a 7\u2194 b\n(E \u2229 event(S) = \u2205), the notation a \u2192 b \u2208 S simply indicates that event a from TA1\nmust be synchronized with event b from TA2, but event b can occur independently of a.\nGiven a 7\u2194 b \u2208 S, it indicates that event a from TA1 and b from TA2 may synchronize\nwith each other, or occur independently.\nThis parallel composition is defined in terms of the general parallel merge operator \u2016M\nin UTP [10]:\nA1 |[E]| A2 \u2022 S =\u0302 (((A1; idle) \u2016M A2) \u2228 (A1 \u2016M (A2; idle)));\n((ok \u21d2 SKIP) \u2227 (\u00acok \u21d2 tr t\u00b9 tr\u2032))\nTake note that SKIP is a semantic predicate which preserves the observations, that is,\nSKIP =\u0302 (obs\u2032 = obs), where obs denotes all observables.\nAn idle process, which may either wait or terminate, follows after each of the two\nautomatons. This is to allow each of the automatons to wait for its partner to terminate.\nidle =\u0302 ok\u2032 \u2227 no interact(trace) \u2227 state\u2032 = state\nThe merge predicate M is defined as,\nM =\u0302 ok\u2032 = (0.ok \u2227 1.ok) \u2227 wait\u2032 = (0.wait \u2228 1.wait) \u2227 state\u2032 = (0.state\u22951.state) \u2227\ntr\u2032 \u2208 syn(0.tr, 1.tr,E, S) \u2227 #tr\u2032 = #0.tr = #1.tr \u2227 cval\u2032 = 0.cval\u2295 1.cval\nGiven two timed traces tr1, tr2, and a set of events E, and a set of pairs of partial\/sometime\nsynchronizations S, the set syn(tr1, tr2,E, S) is defined inductively as follows.\nsyn(tr1, tr2,E,\u2205) =\u0302 syn(tr2, tr1,E,\u2205)\nsyn(\u3008\u3009, \u3008\u3009,E, S) =\u0302 {\u3008\u3009}\nsyn(\u3008(t, r)\u3009, \u3008\u3009,E, S) =\u0302 {\u3008(t\u2032, r)\u3009 | t\u2032 \u2208 (t \u2016\nE S\n\u3008\u3009)}\nsyn(\u3008\u3009, \u3008(t, r)\u3009,E, S) =\u0302 {\u3008(t\u2032, r)\u3009 | t\u2032 \u2208 (\u3008\u3009 \u2016\nE S\nt)}\nsyn(\u3008(t1, r1)\u3009a tr1, \u3008(t2, r2)\u3009a tr2,E, S) =\u0302\n{\u3008(t\u2032, r\u2032)\u3009a u | t\u2032 \u2208 (t1 \u2016\nE S\nt2) \u2227 r\u2032 = r1 \u222a r2 \u2227\nu \u2208 syn(tr1, tr2,E, S)}\ns \u2016\nE S\nt is used to merge untimed traces s and t into one untimed trace, where E is the set\nof events to be synchronized, S is the set of partial\/sometime synchronization pairs.\nIn the following clauses, e, e1 are representative elements of E (events), x, x1 represent\ncommunication events not residing in E or S, a \u2192 b, a1 \u2192 b1 are representative partial\nsynchronization pairs from S, while c 7\u2194 d, c1 7\u2194 d1 are representative sometime\nsynchronization pairs from S. Let y, y1, y2 \u2208 {x, x1, b, b1, c, d, c1, d1}.\nLet z, z1, z2 \u2208 {e, a, e1, a1}. Moreover, we use k(a, b) to denote the synchronization of\na and b.\ns \u2016\nE \u2205\nt =\u0302 t \u2016\nE \u2205\ns \u3008\u3009 \u2016\nE S\n\u3008\u3009 =\u0302 {\u3008\u3009}\n\u3008z\u3009 \u2016\nE S\n\u3008\u3009 =\u0302 \u3008\u3009 \u2016\nE S\n\u3008z\u3009 =\u0302 {}\n\u3008y\u3009 \u2016\nE S\n\u3008\u3009 =\u0302 \u3008\u3009 \u2016\nE S\n\u3008y\u3009 =\u0302 {\u3008y\u3009}\n\u3008y\u3009as \u2016\nE S\n\u3008z\u3009at =\u0302 {\u3008y\u3009al | l\u2208(s \u2016\nE S\n\u3008z\u3009at)}, z\u2192y6\u2208S\n\u3008z\u3009as \u2016\nE S\n\u3008y\u3009at =\u0302 {\u3008y\u3009al | l\u2208(\u3008z\u3009as \u2016\nE S\nt)}, z\u2192y6\u2208S\n\u3008e\u3009as \u2016\nE S\n\u3008e\u3009at =\u0302 {\u3008e\u3009al | l \u2208 (s \u2016\nE S\nt)}\n\u3008z1\u3009as \u2016\nE S\n\u3008z2\u3009at =\u0302 {}, where z1 6= z2\n\u3008y1\u3009as \u2016\nE S\n\u3008y2\u3009at =\u0302 {\u3008y1\u3009al | l \u2208 (s \u2016\nE S\n\u3008y2\u3009at)}\u222a\n{\u3008y2\u3009al | l \u2208 (\u3008y1\u3009as \u2016\nE S\nt)}, where y1 7\u2194 y2 6\u2208 S\n\u3008a\u3009as \u2016\nE S\n\u3008b\u3009at =\u0302 {\u3008k(a, b)\u3009al | l \u2208 (s \u2016\nE S\nt)}\u222a\n{\u3008b\u3009al | l \u2208 (\u3008a\u3009as \u2016\nE S\nt)}\n\u3008b\u3009as \u2016\nE S\n\u3008a\u3009at =\u0302 {\u3008k(a, b)\u3009al | l \u2208 (s \u2016\nE S\nt)}\u222a\n{\u3008b\u3009al | l \u2208 (s \u2016\nE S\n\u3008a\u3009at)}\n\u3008c\u3009as \u2016\nE S\n\u3008d\u3009at =\u0302 {\u3008k(c, d)\u3009al | l \u2208 (s \u2016\nE S\nt)}\u222a\n{\u3008c\u3009al | l \u2208 (s \u2016\nE S\n\u3008d\u3009at)} \u222a {\u3008d\u3009al | l \u2208 (\u3008c\u3009as \u2016\nE S\nt)}\nA network of timed automata is the parallel composition A1 \u2016 A2 \u2016 ... \u2016 An of a set of\ntimed automata A1,A2, ...,An.\n3.3 The Semantics of Class\nOZTA has two kinds of classes, active and passive ones. The behavior of (an object of)\nan active class can be specified by a record of its continuous interactions with its envi-\nronment via its time automaton specifications, whereby any update on its data state is\nhidden. Passive class does not have its own thread of control and its state and operations\n(processes) are available for use by its controlling object.\nIn order to address issues like class encapsulation and dynamic typing that are essential\nfor object-orientation, a class model is established which is very similar with [13, 11]\nexcept that the TCSP operations are replaced with timed automatons. More detailed\ninformation on the semantics of class model can be referred to [13].\n4 OZTA Tool\nThis section introduces the tool OZTA we developed for OZTA notation.\nOZTA is a tool for modelling, type-checking and projecting complex real-time systems.\nIt mainly consists of four components, i.e., a GUI editor, a type checker, a LATEX code\ngenerator and an Uppaal translator. The input language is based on the syntax and se-\nmantics we presented in the previous sections. The output of OZTA can either be an\nXML representation of OZTA models or LATEX source files of OZTA models; OZTA\ncan also generate projections of OZTA models which is ready to be taken as input for\nsimulation and verification in Uppaal.\nFigure 6 provides an overview of OZTA:\nX\rM\rL\r \rP\ra\rr\rs\re\rr\r\n \rE\rd\ri\rt\ro\rr\r\nO\rZ\rT\rA\r\nX\rM\rL\r \rD\ro\rc\ru\rm\re\rn\rt\r\nL\ra\rT\re\rx\r \rD\ro\rc\ru\rm\re\rn\rt\r\nX\rM\rL\r\nS\rc\rh\re\rm\ra\r\nO\rZ\rT\rA\r\nX\rM\rL\r \rD\ro\rc\ru\rm\re\rn\rt\r\nU\rs\re\rr\r \rE\rd\ri\rt\r\nL\ra\rt\re\rx\r\nT\rr\ra\rn\rs\rf\re\rr\r\nC\rh\re\rc\rk\re\rr\r\nA\rD\rT\r\nG\rr\ra\rp\rh\ri\rc\ra\rl\r \rU\rs\re\rr\r \rI\rn\rt\re\rr\rf\ra\rc\re\r\nE\rr\rr\ro\rr\r \rR\re\rp\ro\rr\rt\r\nS\rc\ra\rn\rn\re\rr\r\nU\rp\rp\ra\ra\rl\r\nT\rr\ra\rn\rs\rl\ra\rt\re\rr\r\nU\rp\rp\ra\ra\rl\r \rX\rM\rL\r\nD\ro\rc\ru\rm\re\rn\rt\r\nFig. 6. Class Diagram of OZTA\n4.1 GUI Editor with pattern support\nThe graphical editor has a main editing panel which consists of a schema editing part\nand a timed automaton editing part. Implemented with the timed patterns, the editor\ncan support a more systematic design of timed automata. Automatons are generated in\na top-down way. Firstly an abstracted default automatonA of an external choice pattern\nis automatically generated on the TA editing panel according to its established schema\npart of the model. Each branch of A is also an abstracted automaton and respectively\nrepresents one of the operation schemas defined on the schema editing panel. The de-\nsigner can later embody these branches by recursively applying certain patterns until\nthe behavior of the automaton meets its requirements.\n4.2 Type Checker\nThe major functionalities of our OZTA type checker are to check syntax errors and to\ncheck static semantic errors in the OZTA specification. A full set of type checking rules\ncan be found in our technical report [5].\n4.3 LATEX Code Generator\nThis generator outputs the LATEX source file and EPS files for an OZTA model, which\ncan be directly complied and viewed in LATEX tools such as WinEdt.\n4.4 Translator\nAn Uppaal translator is developed and integrated with OZTA. It extracts TA and state\nvariables information from OZTA notation and generates an XML representation of\nUppaal model for further embodiment and verification.\nOZTA to Uppaal Uppaal is a useful integrated tool for modelling, simulation and veri-\nfication of real-time systems. The simulation in Uppaal enables examination of possible\ndynamic executions of a system during early design (or modelling) stages and thus pro-\nvides an inexpensive mean of fault detection prior to verification by the model checker\nwhich covers the exhaustive dynamic behavior of the system. Its model checker is to\ncheck invariant and bounded liveness properties by exploring the symbolic state space\nof a system, i.e., reachability analysis in terms of symbolic states represented by con-\nstraints. The description language of Uppaal is a timed automaton extended with a set\nof locally declared clocks, variables and constants. By projecting an OZTA model to a\nTA model, we can reuse Uppaal to simulate the dynamic behaviors the OZTA model\nand verify its various kinds of properties.\nCoupled with operation schema predicates and data structures, the semantics of oper-\nation states in the TA part of an OZTA model is slightly different from those of states\nin Uppaal. However, the main structure of the OZTA automata model is still consistent\nwith that of Uppaal model by regarding the OZTA operation states as abstracted au-\ntomatons which need further implementation. This gap between the OZTA\u2019s TA model\nand Uppaal\u2019s TA model can be remedied by some manual work on the operation states,\nnamely, to further embody these abstracted automatons by adding the data information.\nFor example, in the frog puzzle game, we map the state variables bf ,wf , nf of its\nOZTA model to the Uppaal model as global int variables bf [3],wf [3], nf . Due to the\nlimited expressiveness for data manipulation in Uppaal, we need to respectively ex-\npand BlackMove and WhiteMove into three branches. The predicates in the operation\nschemas of the OZTA model are projected as guards on the corresponded transitions.\nThe final Uppaal model can be generated in this way as shown in Figure 7.\nAlthough our projection can handle most of the TA information of an OZTA model, one\nlimitation needed to be pointed out is that, there is no verification tool yet which can\nsupport checking the properties related with the partial synchronization and sometime\nsynchronization due to the novelty of this concept.\nModel-Checking OZTA models To find the solution of this frog puzzle, we can check\nthe following property in Uppaal.\nE <> P.Win\nwhich means that there exists a sequence of moves that will exchange the positions of\nthe black and white frogs within 30 time units.\nUppaal verified that this property actually holds for this given model. Solutions of the\npuzzle can be visualized in Uppaal\u2019s simulator by running its diagnostics trace.\ns0\ns1\nWf1\ny<=2\nWf2\ny<=2\nWf3\ny<=2\nBf1\ny<=2\nBf2\ny<=2\nBf3\ny<=2\nWin\nLose_1\nLose_2\nx:=0,wf[0]:=1,wf[1]:=2,wf[2]:=3,\nbf[0]:=5,bf[1]:=6,bf[2]:=7,nf:=4\ny:=0,temp:=nf\nnf==wf[1]+1,\nwf[0]+wf[1]+wf[2]!=18,\nx<30\ny:=0,temp:=nf\nnf==wf[2]+1,\nwf[0]+wf[1]+wf[2]!=18,\nx<30\ny:=0,temp:=nf\nnf==wf[0]+1,\nwf[0]+wf[1]+wf[2]!=18,\nx<30\ny:=0,temp:=nf\nnf==bf[1]-1,\nbf[0]+bf[1]+bf[2]!=6,\nx<30\ny:=0,temp:=nf\nnf==bf[2]-1,\nbf[0]+bf[1]+bf[2]!=6,\nx<30\ny:=0,temp:=nf\nnf==bf[0]-1,\nbf[0]+bf[1]+bf[2]!=6,\nx<30\nx<=30,nf==4,\nwf[1]+wf[2]+wf[0]==18\ny>=1\nnf:=wf[1],wf[1]:=temp\ny>=1\nnf:=wf[2],wf[2]:=temp y>=1\nnf:=wf[0],wf[0]:=temp\ny>=1\nnf:=bf[1],bf[1]:=temp\ny>=1\nnf:=bf[2],bf[2]:=temp\ny>=1\nnf:=bf[0],bf[0]:=temp\nwin:=1\nnf==wf[1]+2,\nwf[0]+wf[1]+wf[2]!=18,\nx<30\ny:=0, temp:=nf\nnf==wf[2]+2,\nwf[0]+wf[1]+wf[2]!=18,\nx<30\ny:=0,temp:=nf\nnf==wf[0]+2,\nwf[0]+wf[1]+wf[2]!=18,\nx<30\ny:=0,temp:=nf\nnf==bf[1]-2,\nbf[0]+bf[1]+bf[2]!=6,\nx<30\ny:=0,temp:=nf\nnf==bf[2]-2,\nbf[0]+bf[1]+bf[2]!=6,\nx<30\ny:=0,temp:=nf\nnf==bf[0]-2,\nbf[0]+bf[1]+bf[2]!=6,\nx<30\ny:=0,temp:=nf\nx>=30\nwin:=0\nnf!=bf[0]-1,nf!=bf[0]-2,\nnf!=bf[1]-1,nf!=bf[1]-2,\nnf!=bf[2]-1,nf!=bf[2]-2,\nnf!=wf[0]+1,nf!=wf[0]+2,\nnf!=wf[1]+1,nf!=wf[1]+2,\nnf!=wf[2]+1,nf!=wf[2]+2win:=0\nFig. 7. Frog Puzzle Model in Uppaal\n5 Conclusion\nThe contributions of the paper are listed as follows:\n\u2013 We enhanced OZTA notation by introducing a set of timed patterns as language\nconstruct that can specify the dynamic and timing features of complex real-time\nsystems in a systematic way.\n\u2013 We presented a semantic model of OZTA in Unifying Theories of Programming\nwhich provides the semantic foundation for language understanding, reasoning and\ntool construction.\n\u2013 We constructed an OZTA tool which can support editing, type-checking OZTA\nmodels as well as transforming OZTA models into TA models so that we can utilize\nTA model-checkers, e.g., Uppaal for verification.\nIn our future work, we plan to further enhance our OZTA tool by extending the current\nset of TA patterns into a dynamic pattern library so that new patterns can be defined by\nsystem designers and added into the pattern library for future reuse. We are also inter-\nested to study other projections, e.g., OZTA to Alloy, so that various properties of an\nOZTA model can be analyzed in the projected domains. Another future research work\nwould be, based on our UTP semantics, to extend and link some proof systems [15] of\nObject-Z for reasoning about OZTA models.\nAcknowledgement\nWe would like to thank Chen Qian, and He Kang for their part of work on the coding\nof the OZTA tool.\nReferences\n1. R. Alur and D. L. Dill. A theory of timed automata. Theoretical Computer Science, 126:183\u2013\n235, 1994.\n2. K. Araki, A. Galloway, and K. Taguchi, editors. IFM\u201999: Integrated Formal Methods, York,\nUK. Springer-Verlag, June 1999.\n3. E. Boiten, J. Derrick, and G. Smith, editors. IFM\u201904: Integrated Formal Methods, Lect.\nNotes in Comput. Sci. Springer-Verlag, April 2004.\n4. M. Butler, L. Petre, and K. Sere, editors. IFM\u201902: Integrated Formal Methods, Lect. Notes\nin Comput. Sci. Springer-Verlag, October 2002.\n5. J. S. Dong, P. Hao, S. C. Qin, and X. Zhang. OZTA. Technical report TRC6\/05, School of\nComputing, National University of Singapore, 2005.\nhttp:\/\/nt-appn.comp.nus.edu.sg\/fm\/ozta.\n6. J.S. Dong, R. Duke, and P. Hao. Integrating Object-Z with Timed Automata. In The 10th\nIEEE International Conference on Engineering of Complex Computer System, Shanghai,\nChina, 2005.\n7. J.S. Dong, P. Hao, S.C. Qin, J. Sun, and W. Yi. Timed Patterns: TCOZ to Timed Automata.\nIn The 6th IEEE International Conference on Formal Engineering Methods, Seattle, USA,\n2004.\n8. R. Duke and G. Rose. Formal Object Oriented Specification Using Object-Z. Cornerstones\nof Computing. Macmillan, March 2000.\n9. C. Fischer and H. Wehrheim. Model-Checking CSP-OZ Specifications with FDR. In Araki\net al. [2].\n10. C.A.R. Hoare and J. He. Unifying Theories of Programming. Prentice-Hall, 1998.\n11. Z. Liu J. He and X. Li. A relational model for specification of object-oriented systems.\nTechnical report 262, UNU\/IIST, 2002.\n12. A. Cavalcanti J. Woodcock. The Semantics of Circus. In The 2th International Conference\non Z and B, LNCS 2272, pages 184\u2013203. Springer-Verlag, 2002.\n13. S. C. Qin, J. S. Dong, and W. N. Chin. A Semantic Foundation of TCOZ in Unifying Theory\nof Programming. In Formal Methods(FM\u201903), LNCS 2805, pages 321\u2013340. Springer-Verlag,\n2003.\n14. A. Sherif and J. He. Towards a Timed Model for Circus. In The 2th IEEE International\nConference on Formal Engineering Methods, Shanghai, China, 2002.\n15. G. Smith. Reasoning about Object-Z specifications. In the Proceedings of Asia-Pacific\nSoftware Engineering Conference (APSEC \u201995), pages 794\u2013804. IEEE Computer Society\nPress, 1995.\n16. G. Smith. The Object-Z Specification Language. Advances in Formal Methods. Kluwer\nAcademic Publishers, 2000.\n17. J. Woodcock and A. Cavalcanti. The Semantics of Circus. In 2nd International Conference\non Z and B, volume 2272 of Lect. Notes in Comput. Sci., pages 184\u2013203. Springer-Verlag,\n2002.\n18. X.Nicollin, J.Sifakis, and S.Yovine. Compiling Real-time Specifications into Extended Au-\ntoamta. In IEEE TSE Special Issue on Real-Time Systems, volume 18(9), pages 794\u2013804,\n1999.\n"}