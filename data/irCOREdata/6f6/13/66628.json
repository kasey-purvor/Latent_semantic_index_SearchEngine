{"doi":"10.1007\/978-3-540-45236-2_19","coreId":"66628","oai":"oai:dro.dur.ac.uk.OAI2:662","identifiers":["oai:dro.dur.ac.uk.OAI2:662","10.1007\/978-3-540-45236-2_19"],"title":"A semantic foundation for TCOZ in unifying theories of programming.","authors":["Qin,  S.","Dong,  J. S.","Chin,  W. N."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2003-09","abstract":"Unifying Theories of Programming (UTP) can provide a formal semantic foundation not only for programming languages but also for more expressive specification languages. We believe UTP is particularly well suited for presenting the formal semantics for integrated specification languages which often have rich language constructs for state encapsulation, event communication and real-time modeling. This paper uses UTP to formalise the semantics of Timed Communicating Object Z (TCOZ) and captures some TCOZ new features for the first time. In particular, a novel unified semantic model of the channel based synchronisation and sensor\/actuator based asynchronisation in TCOZ is presented. This semantic model will be used as a reference document for developing tools support for TCOZ and as a semantic foundation for proving soundness of those tools","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66628.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/662\/1\/662.pdf","pdfHashValue":"1e15574a7702c1b7a71b83ec023d61803116790b","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:662<\/identifier><datestamp>\n      2015-03-31T11:48:25Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        A semantic foundation for TCOZ in unifying theories of programming.<\/dc:title><dc:creator>\n        Qin,  S.<\/dc:creator><dc:creator>\n        Dong,  J. S.<\/dc:creator><dc:creator>\n        Chin,  W. N.<\/dc:creator><dc:description>\n        Unifying Theories of Programming (UTP) can provide a formal semantic foundation not only for programming languages but also for more expressive specification languages. We believe UTP is particularly well suited for presenting the formal semantics for integrated specification languages which often have rich language constructs for state encapsulation, event communication and real-time modeling. This paper uses UTP to formalise the semantics of Timed Communicating Object Z (TCOZ) and captures some TCOZ new features for the first time. In particular, a novel unified semantic model of the channel based synchronisation and sensor\/actuator based asynchronisation in TCOZ is presented. This semantic model will be used as a reference document for developing tools support for TCOZ and as a semantic foundation for proving soundness of those tools. <\/dc:description><dc:subject>\n        UTP<\/dc:subject><dc:subject>\n         Semantics<\/dc:subject><dc:subject>\n         Integrated formal specifications.<\/dc:subject><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n         FME 2003 : formal methods : International Symposium of Formal Methods Europe, 8-14 September 2003, Pisa, Italy: proceedings. Berlin: Springer, pp. 321-340, Lecture notes in computer science(2805)<\/dc:source><dc:date>\n        2003-09<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:662<\/dc:identifier><dc:identifier>\n        doi:10.1007\/978-3-540-45236-2_19<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/662\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/978-3-540-45236-2_19<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/662\/1\/662.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/978-3-540-45236-2_19<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2003,"topics":["UTP","Semantics","Integrated formal specifications."],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nQin, S. and Dong, J. S. and Chin, W. N. (2003) \u2019A semantic foundation for TCOZ in unifying theories of\nprogramming.\u2019, in FME 2003 : formal methods : International Symposium of Formal Methods Europe, 8-14\nSeptember 2003, Pisa, Italy: proceedings. Berlin: Springer, pp. 321-340. Lecture notes in computer science.\n(2805).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/b13229\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nA Semantic Foundation for TCOZ\nin Unifying Theories of Programming\nShengchao Qin , Jin Song Dong , and Wei-Ngan Chin\nSingapore-MIT Alliance, National University of Singapore\nSchool of Computing, National University of Singapore\nqinsc,dongjs,chinwn @comp.nus.edu.sg\nAbstract. Unifying Theories of Programming (UTP) can provide a formal se-\nmantic foundation not only for programming languages but also for more ex-\npressive specification languages. We believe UTP is particularly well suited for\npresenting the formal semantics for integrated specification languages which of-\nten have rich language constructs for state encapsulation, event communication\nand real-time modeling. This paper uses UTP to formalise the semantics of Timed\nCommunicating Object Z (TCOZ) and captures some TCOZ new features for the\nfirst time. In particular, a novel unified semantic model of the channel based syn-\nchronisation and sensor\/actuator based asynchronisation in TCOZ is presented.\nThis semantic model will be used as a reference document for developing tools\nsupport for TCOZ and as a semantic foundation for proving soundness of those\ntools.\nKeywords: UTP, semantics, integrated formal specifications\n1 Introduction\nFormal semantics of specification languages provide foundations for language under-\nstanding, reasoning and tools construction. Various formal specification languages are\noften integrated for modeling large and complex systems. The development of the for-\nmal semantics for those integrated formal specifications provides some challenges due\nto the richness of the language constructs that facilitate complex states encapsulation,\ncommunication and real-timemodeling. Hoare andHe\u2019s Unifying Theories of Program-\nming (UTP) [6] can present formal semantics not only for programming languages but\nalso for specification languages. We believe UTP is particularly well suited for giv-\ning formal semantics for the integrated specification languages. One integrated formal\nnotation namely Timed Communicating Object Z (TCOZ) [8] builds on the strengths\nof Object-Z [4, 16] and Timed CSP [13, 2] notations in order to provide a single nota-\ntion for modeling both the state and process aspects of complex systems. In addition to\nCSP\u2019s channel-based communication mechanism (where messages represent discrete\nsynchronisations between processes), TCOZ has recently been extended with asyn-\nchronous interface inspired by process control theory, sensors and actuators [7]. Based\non the infinite failure model of Timed CSP, an enhanced semantics for TCOZ has been\nproposed [9] where the process behavioural aspects are focused. However, other im-\nportant aspects of TCOZ were left out. In particular, it does not cover the semantics of\nthe asynchronous communication mechanism of sensors and actuators. It is difficult to\nextend that semantics to cover sensors and actuators because the meta framework used\nis based on events (channel), which is incompatible with the shared-variable nature of\nsensors and actuators.\nThis paper demonstrates howUTP can be used for constructing a formal observation-\norientedmodel for TCOZ. In particular, a novel unified semantic model for both channel\nand sensors\/actuators based communications is presented. This UTP model not only\ncovers the TCOZ communication and process aspects, but also other features, such\nas class encapsulation, inheritance, dynamic binding and extended TCOZ timing con-\nstructs (deadline and waituntil commands), which have not been covered by the previ-\nous semantics. This semantic model will be used as a reference document and a seman-\ntic foundation for developing sound tools support for TCOZ. Our philosophy on tools\nsupport for integrated formal methods is to reuse\/link existing tools especially graphical\ntools as much as possible. For example, one approach is to develop transformation rules\nfrom TCOZ to Timed Automata (TA) so that existing TA tools can be used to model\ncheck TCOZ timing properties, or to Message Sequence Chart (MSC) so that MSC\ntools can be used to analyse TCOZ\u2019s message passing and interaction behaviour. The\nproof of the soundness of those transformation rules can be based on this UTP semantic\nframework.\nThe remainder of the paper is organised as follows. Section 2 outlines the TCOZ\nsyntax with a simple example. Section 3 starts with a brief introduction to UTP then\npresents the UTP observation model with meta variables. Section 4 develops the UTP\nsemantics for TCOZ operations and processes. Section 5 presents the UTP semantics\nfor TCOZ classes. Section 6 addresses related works with a conclusion and points out\nsome future directions.\n2 The TCOZ\u2019s Syntax and Example\nThe abstract syntax of TCOZ is given as follows.\nSpecification CDecl CDecl\nCDecl VisibList InheritC StateSch INIT StaOp ProOp MAIN\nVisibList VisibAttr VisibOp\nVisibAttr AttrName\nVisibOp OpName\nInheritC Inherits CName\nStateSch VarDecl ChanDecl SenDecl ActDecl\nVarDecl v T\nChanDecl ch chan\nSenDecl sv T sensor\nActDecl sv T actuator\nStaOp AttrName ActName VarDecl Pred u,v\u2019\nProOp VarDecl Process\nMAIN Process\nProcess Skip Stop Chaos primitives\nStaOp state update Comm Process communication\nb Process state guard Process t Process timeout\nWAIT t wait Process DEADLINE t deadline\nProcess WAITUNTIL t waituntil\nProcess Process sequential composition\nProcess Process external choice\nProcess Process internal choice\nProcess E Process parallel composition\nProcess E hiding X Process recursion\nComm ch!e chan. ouput b ch?x chan. input b sv?x sensor read\nwhere b is a boolean condition, t is a time expression, E is a finite set of communication\nevents, e is a message, and x is a variable.\nLet us use a simple timed message queue system to illustrate the TCOZ notation.\nThe behaviour of the following timed message queue system is that it can receive a\nnew message (of type MSG ) through an input channel \u2018in\u2019 within a time duration\n\u2018Tj\u2019 or remove a message and send it through an output channel \u2018out\u2019 within a time\nduration \u2018Tl\u2019. If there is no interaction with environment within a certain time \u2018T o\u2019, then\na message will be removed from the current list but stored in a (window like) actuator\nlist (lost) so that other objects (un-specified) with a sensor \u2018lost\u2019 can read it at any time.\nThe message queue has a FIFO property.\nTimedQueue\nitems seqMSG\nin out chan\nlost seqMSG actuator\nTl Tj To\nINIT\nitems lost\nRecLost\nlost\nlost head items lost\nAdd\nitems\ni MSG\nitems items i\nDel\nitems\ni MSG\nitems items i items\nitems items\nJoin i MSG in i Add DEADLINETj\nLeave items out head items Del DEADLINETl\nMAIN Q Join Leave To RecLost Del DEADLINETl Q\n3 The UTP Observation Model\nIn the Unifying Theories of Programming (UTP), the relational\/predicate calculus is\nadopted as a fundamental basis for unifying various programming theories across three\ndimensions: different computational paradigms, different levels of abstraction, and dis-\ntinct mathematical representations. For each programming paradigm, specifications, de-\nsigns, and programs are all interpreted as relations between an initial observation and\na subsequent (intermediate stable or final) observation of the behaviour of their execu-\ntions. Program correctness and refinement calculus can be represented by inclusion of\nrelations. All the laws in a relational calculus are also valid in reasoning about correct-\nness in all theories and languages.\nFormal theories differ from one another by their alphabet, signature, and healthiness\nconditions. The alphabet of a theory is just a set of names used to record external obser-\nvations of the behaviour. The names for initial observations are undecorated, whereas\nthe names for subsequent observations are primed. The signature gives the way to rep-\nresent the elements of the theory by taking primitives directly as elements and using\noperations to construct elements in an inductive manner. The healthiness conditions\nhelp filter out required elements for a sub-theory from those of a larger theory in which\nit is embedded. For example, in a top-down design process, programs are just a subset\nof intermediate designs, while designs are a subset of specifications.\nTo give a semantic model for the timed communicating language TCOZ, we need\nto choose an appropriate model of time. There are two typical models: a discrete model\nand a continuous one. The continuous model is very expressive and closer to the nature\nof real time. However, it is difficult to implement exactly for digital computer systems.\nOn the other hand, the discrete model is implementable and closer to an untimed model.\nTimed CSP has a denotational semantics based on continuous time [2], and the exist-\ning semantics for TCOZ also adopts the continuous model [9]. However, to follow the\nobjective of making our model simple and apt for exploration of algebraic refinement\nlaws, we choose the discrete model. The discrete time model has also been adopted by\nthe Sherif and He\u2019s work [14] on the semantics for timed Circus [17], which naturally\nextends Woodcock and Cavalcanti\u2019s semantics for Circus [18]. Although the general\napproach of the timed Circus semantics is adopted in our UTP semantic model for\nTCOZ processes, our semantic model contains many new aspects especially the formal\ntreatment of both channel and sensor\/actuator communication interfaces.\n3.1 The Meta Process Model and Variables\nTCOZ is mainly used to specify complex reactive systems. The behaviour of such a\nsystem can be modeled by observations of two kinds. The initial observation reflects\nthe state of the system when the system starts to run. The follow-up observation records\nthe state of the system when the system reaches a stable state. A stable state is either a\ntermination state, in which the system terminates and the corresponding observation is\ncalled the final observation, or an intermediate waiting state, in which the system has\nno interaction with its environment and does not have infinite internal active events (not\ndivergent) [6].\nThe process model starts with the above observations: at the initial and final (or in-\ntermediate stable) states of the system. Due to the timing feature of TCOZ, the observa-\ntions on the interactions with the environment are enriched by adding time information.\nThe existing model for Timed CSP and TCOZ attaches an explicit time stamp on each\nobservation. The discrete model of time allows us to add time information implicitly.\nThe interactions of a system with its environment are recorded as a sequence of tuples,\neach element of the sequence representing the observations over a single time unit. The\nfirst component of the tuple is a sequence of communication events or shared-variable\nupdates which occur during a time unit. The second component represents a set of re-\nfused events (refusal) at the end of the time unit.\nThe following meta variables are introduced in the alphabet of the observations of\nthe TCOZ process behaviour, some of them are similar to those in the previous UTP\nsemantic frameworks [6, 14, 18]. The key difference is that timed trace has now been\nencoded with a set of shared-variable updates (due to sensors\/actuators).\n\u2013 ok ok Boolean. In order to analyse explicitly the phenomena of process initia-\ntion and termination, these variables are introduced to denote these observations.\nok records the observation that the process has started. When ok is false, the process\nhas not started, so no observation can be made.\nok records the observation that the process has terminated or has reached an inter-\nmediate stable state. The process is divergent when ok is false.\n\u2013 wait wait Boolean. Because of the requirement for synchronisation, an ac-\ntive process will usually engage in alternate periods of internal activity (computa-\ntion) and periods of quiescence or stability, while it is waiting for a reaction or an\nacknowledgement from its environment. We therefore introduce a variable wait ,\nwhich is true just when a process is waiting in such quiescent periods. Its main\npurpose is to distinguish intermediate observations from the observations made on\ntermination. wait is used in the initial observation, which is true when the process\nstarts in an intermediate state.\n\u2013 state state Var Value. In order to record the state of data variables (class\nattributes\/local variables) that occur in a process, these two variables are introduced\nto associate resp. every variable with its value in the corresponding observations.\n\u2013 tr tr seq seq Event Update Event . Each of these two variables records\na sequence of observations on the process\u2019s interactions with its environment. tr\nrecords the observations that occur before the process starts, and tr records the\nobservations that take place so far. Each element of the sequence denotes the ob-\nservations over one time unit, which is specified by a tuple. The first component\nof the tuple is the sequence of communication events or updates on sensor-actuator\nvariables that occur during the time unit, the second is an associated set of refusals\nat the end of the time unit.\nThe set Event denotes all possible communicating events. The set Update, defined\nas Update df SV Value Tag , represents the set of all possible up-\ndates (states) of all sensor-actuator variables (SV). The binary set Tag df\nshows which process is making the current update: indicates that current update\nis made by the current process, whereas indicates that current update is due to an\nenvironmental process.\n\u2013 trace seq Event Update . This variable is used to record a sequence of\nevents\/updates that take place so far since the last observation. It can be derived\nfrom tr tr by taking their difference as follows:\nflat tr trace flat tr where is the concatenation operator, and\nflat seq seq Event Update Event seq Event Update\nflat df flat es ref tr df es flat tr\nTwo auxiliary functions cs trace ds trace are adopted to extract resp. the sub-\nsequences of communication events and shared-variable states from the sequence\ntrace. The function cs is defined as\ncs df cs e tail df e cs tail if e Eventcs tail otherwise.\nThe function ds can be defined similarly.\n\u2013 gs SV Value. This variable is used to hold the latest updated state of all shared\nsensor-actuator variables.\nIn our semantics model, the observation-based semantics for a TCOZ process will\nbe described by a predicate whose alphabet contains the above variables [6].\nA binary relation t is defined over two sequences of observations as follows.\ntr\nt\ntr df front tr tr last tr tr tr\nwhere is the ordinary subsequence relation between sequences of the same type.\nfront tr is the initial part of tr obtained by dropping those observations recorded in\nlast time unit. last tr gets the last element of the sequence tr. tup returns the first\ncomponent of the tuple tup. tr is the number of elements in tr, while tr n returns the\nnth element.\nThis definition states that, given two timed traces, tr and tr , tr is an expansion of\ntr , if the initial part of tr is a subsequence of tr , and the untimed traces recorded at\nthe last time unit of tr is a subsequence of the untimed traces at the same time in tr .\nSince the execution of a process can never undo any action performed previously,\neach trace can only get longer. The current value of tr must therefore always be an\nexpansion of its initial value. Hereby, the semantics predicateP for any process P should\nsatisfy the healthiness condition R defined as follows:\nR P df P P tr\nt\ntr\n3.2 The Class Model\nTCOZ has two kinds of classes, active and passive ones. The behaviour of (an object\nof) an active class can be specified by a record of its continuous interactions with its en-\nvironment via its MAIN process, whereby any update on its data state is hidden. Passive\nclass does not have its own thread of control and its state and operations (processes) are\navailable for use by its controlling object. We model an active class as a predicate with\nan assumption and a commitment (also known as design in [6]), and a passive class as\na service provider, which provides a set of services to its environment.\nIn order to address issues like class encapsulation and dynamic typing that are es-\nsential for object-orientation, the following TCOZ features are considered in the UTP\nmodel.\n1. An object-oriented specification contains not only variables of simple types but also\nobjects. To ensure a legal access to a variable, the model is equipped with a set of\nvisible attributes\/operations.\n2. Due to the subclass mechanism, an object can lie in a subclass of its originally\ndeclared one. Therefore, the behaviour of its operations will depend on its current\ntype. To support such a dynamic binding mechanism for operation calls, our model\nkeeps track of the dynamic type for each object. This enables us to validate opera-\ntions in a framework where the type of each variable is properly recorded.\n3. A value of an object variable is a finite tuple, which may record the current type of\nthe object, and the values of its attributes. Since an object may contain attributes of\nobject types, its value is often defined with nested recursions.\nIn order to address the above issues clearly, the following meta variables are intro-\nduced to keep track of the class information.\n\u2013 CN and super are used to record the contextual information on classes and their\nrelationships. CN is the set of classes already declared, super is a partial func-\ntion which maps a class to the set of its direct superclasses. For example, C\nsuper C states that C is a direct superclass of C . C is a superclass of C if there\nexists a finite sequence of classes C Cn, such that C Cn and C C and\nCi super Ci for all i n. We use the set super C to denote all su-\nperclasses of C, and super C to present all superclasses of C and itself. Note that\nsuper C df super C C .\n\u2013 For each class C CN, we use the following notations to denote its structure and\nrecord different variables involved in its specification.\nThe set of state attributes of class C, attr C a T am Tm ,\ncomprises both the attributes declared in C and those that C inherits from its\nsuperclasses, where Ti stands for the type of attribute ai of class C, and will be\nreferred by type C ai . The set of channels declared in class C is denoted by\nchan C ch chn chan .\nThe set of operations declared or inherited by C, op C ops C opp C . It\nis composed of a set of state operations (ops C ) and a set of process operations\n(opp C ).\nsenvar, actvar: the set of sensor and actuator variables declared in current class\nor inherited from its superclasses. They provide an interface between the con-\ntrol system and its controlled system.\nlocvar: the set of local definitions, v T vm Tm ;\nvisibattr, visibop: the set of visible state attributes and visible operations.\nFor notational convenience,we assume the following four sets of names are pairwise\ndisjoint: classes, attributes, operations and (local or shared) variables.\nA state binds variables to their current values. A variable of a primitive data type can\ntake any value of that type. The value of an object variable is composed of the values of\nits attributes together with its current type (as in [5]):\na value a attr C myclass C\nIn what follows, we investigate the observation-based semantics of TCOZ pro-\ncesses, and as well explore some associated algebraic laws. After that, we formalise\nthe TCOZ class semantics. Following the notation style in UTP [6], we adopt the italic\nformat to represent semantic notations (e.g., predicates), whereas we use the sans serif\nformat to denote syntactic notations (e.g., specifications) in this paper. For instance, the\nsemantics of a process P is simply represented by a predicate P, rather than P .\n4 Process Semantics\nIn this section, the observation model for TCOZ processes is developed. Some process\nmodels that are similar to [14] are moved to the Appendix.\n4.1 Communication\nThis subsection is devoted to communications. Other primitives Chaos, Skip and Stop\nare presented in the Appendix.\nA synchronisation ch.e can take place only if an output event ch!e is ready, an input\nevent b ch?x is also ready, and the message to be passed satisfies the condition b.\nIn order to describe the behaviour of these two primitives, we introduce two auxil-\niary predicates, com blk ch and com syn ch , to represent the waiting behaviour for\ncommunication and the synchronised communication respectively.\ncom blk ch df ok wait no interact trace not ref tr tr ch\ncom syn ch e df ok wait trace ch e tr tr\nNote that predicate not ref tr tr ch is true if any events with respect to channel ch do\nnot occur in the refusals of the observations recorded from tr to tr .\nnot ref tr tr ch df n tr n tr ch tr n\nThe predicate no interact trace denotes that there are no communication events recorded\nin trace, while the shared-variable updates recorded in trace (if any) are due to the en-\nvironmental process. That is, for any s seq Event Update ,\nno interact s df cs s u ds s u\nAn output primitive ch!e stays in a waiting state before some other process becomes\nready to receive a message via the channel ch, or finishes the communication instanta-\nneously once the receiver is ready.\nch e df com blk ch com blk ch com syn ch e state state\nwhere the operator is the composition of two sequentially made observations. For two\nobservation predicates P v v Q v v , where v v represent respectively the initial\nand final versions of all observation variables, the composition of them is\nP v v Q v v df v P v v Q v v\nNote that the final observation from P coincides with the initial observation from Q.\nFor the input primitive b ch?x, if the message to be passed does not satisfy the\ncondition b, it results in deadlock. Once this communication occurs, the value passed\nalong the channel will be assigned to the variable x and recorded in the state.\nb ch x df com blk ch com blk ch\nb e x com syn ch e state state x e\nb e x Stop\nThe guarded sensor read command b(x) sv?x is defined in terms of the following\nrecursive process. Intuitively, it consecutively reads values from the sensor (once per\ntime unit) until the sensed value meets the guard.\nb(x) sv?x df X sv?x b(x) Skip b(x) WAIT X\nwhere the simple read sv?x obtains the latest value of the sensor-actuator variable sv.\nsv x df ok wait tr tr state state x gs sv\nThe simple prefix process Comm P is explained as a sequential composition of\nthe communication behaviour and the behaviour of the process that follows.\nComm P df Comm P\nSemantics for sequential composition is presented in the Appendix.\n4.2 State Operation\nThere are two kind of state operations, one only updates the local state of the current\nclass, whereas the other updates the global state, i.e., the sensor-actuator variables that\nit is in charge of.\nLocal State Update A local state operation y x T Pred u v\u2019 enlarges the state\nwith its local definitions and updates the state afterwards.\ny x T Pred u v df ok wait no interact trace\nval state state x val\nval state state v val Pred state u state v\nActuator Update An actuator update operation sv x T Pred u sv sv\u2019 specifies\nthat expected values can be assigned to the sensor-actuator variables sv.\nsv x T Pred u sv sv df ok wait tr tr\nval gs gs sv val val state state x val\nPred state u gs sv gs sv trace gs\nwhere gs and gs indicate the value of the variable gs resp. before and after the update.\nIn our model, consecutive actuator update operations are combined into one atomic\nupdate operation. Therefore, the above update list can be a list of actuator variables.\n4.3 Timeout Process\nThe timeout process P t Q behaves as P if P has no interaction with the environment\nat all but terminates within time t, or it reacts to the environment within time t, otherwise\nit behaves as Q.\nP t Q df P no interact trace tr tr t\nk tr k tr t tr tr k tr tr tr tr k\ni tr i tr k no interact tr i tr i tr i P tr tr\ntr tr tr tr tr t\ni tr i tr t no interact tr i tr i tr i Q tr tr\nIf P is ready to react to the environment exactly when it has waited for time t, the timeout\nprocess chooses P or Q non-deterministically.\nThe following are some algebraic laws that can be derived from our semantic defi-\nnition. For simplicity, the proofs are omitted.\nT1. P t P P\nT2. Skip t P Skip\nT3. a P t b P a Skip t b Skip P\nT4. P t Q R P t Q P t R\nT5. P Q t R P t R Q t R\n4.4 Wait\nThe process WAIT t just waits for t time units to pass before terminating immediately.\nIt can be defined as follows in terms of timeout construct defined in section 4.3.\nWait t df Stop t Skip\nIt is subject to the following laws.\nW1. WAIT t WAIT t WAIT t t\nW2. WAIT t E WAIT t WAIT max t t\nW3. Stop t P WAIT t P\n4.5 Deadline\nThe Deadline construct P DEADLINE t imposes a timing constraint on a specification\nP, which requires the computation of P to be finished within time t.\nP Deadline t df P tr tr t\nIt enjoys the following properties.\nD1. P DEADLINE t DEADLINE t P DEADLINE min t t\nD2. P Q DEADLINE t P DEADLINE t Q DEADLINE t\n4.6 WaitUntil\nIn case that P terminates within time t, the WaitUntil construct P WAITUNTIL t has\nto keep waiting after the termination of P until t time units have passed.\nP WaitUntil t df tr tr tr tr tr tr t\nP tr tr true ok false wait\nWait t tr tr tr tr P tr tr t\nIt enjoys the following properties.\nU1. P WAITUNTIL t WAITUNTIL t P WAITUNTIL max t t\nU2. P Q WAITUNTIL t P WAITUNTIL t Q WAITUNTIL t\n4.7 State-Guarded Process\nThe state-guarded process b P behaves as P if the condition b is initially satisfied,\notherwise it waits for ever (like the process Stop).\nb P df b P b Stop\nIt satisfies the following properties.\nG1. false P Stop\nG2. true P P\nG3. b Stop Stop\nG4. b c P b c P\nG5. b P Q b P Q\n4.8 Parallel Composition\nThe parallel composition of two processes represents all the possible behaviours of\nboth processes which are not only synchronised on a specific set of events and on the\ntime when these events occur, but also coincide with each other on the state of sensor-\nactuator variables at each update. The overall process will terminate when both compo-\nnent processes do.\nThe parallel composition is defined in terms of the general parallel merge operator\nM in UTP [6], where the predicateM denotes the way to merge two observations.\nIn the following definition, our new merge predicate M E is in charge of both\nchannel based communications and shared-variable updates, due to the existence of\ntwo distinct communication mechanisms (channel and sensor\/actuator) in TCOZ.\nP E Q df P idle M E Q P M E Q idle\nok Skip ok tr\nt\ntr\nAn idle process, which may either wait or terminate, follows after each of the two\nprocesses. This is to allow each of the processes to wait for its partner to terminate.\nidle df ok no interact trace state state\nThe merge predicateM E is defined as\nM E df ok ok ok wait wait wait\nstate state state\ntr syn tr tr E tr tr tr\ni tr tr consistent ds tr i ds tr i\nGiven two timed traces tr tr , and a set of events E, the set syn tr tr E is de-\nfined inductively as follows.\nsyn tr tr E df syn tr tr E\nsyn E df\nsyn t r E df t r t t\nE U\nsyn t r tr t r tr E df\nt r u t t\nE U\nt r r r u syn tr tr E\nThe predicate consistent s s specifies that two sequences of updates on shared vari-\nables are consistent. It is used in the above definition to ensure that two individual\nrecords of shared-variable updates coincide with each other in every time unit.\nconsistent s s df s s i s s i s i\ns i s i\ns\nE U\nt is used to merge untimed traces s and t into one untimed trace, where E is the set\nof events to be synchronised, U is the set of possible shared-variable updates. In com-\nparison to Roscoe\u2019s model for the parallel merge of untimed traces [12], the following\ndefinition is more sophisticated as it also captures the shared variable communications.\nIn the following clauses, e e e are representative elements of E (events), u u u\nare representative elements of U (updates), whereas x x x represent communication\nevents not residing in E.\ns\nE U\nt df t\nE U\ns\nE U\ndf e\nE U\ndf\nu\nE U\ndf x\nE U\ndf x\nx s\nE U\ne t df x l l s\nE U\ne t\ne s\nE U\ne t df e l l s\nE U\nt\ne s\nE U\ne t df where e e\nu s\nE U\nu t df\nif consistent u u\nu l join u u u l s\nE U\nt otherwise\nx s\nE U\nu t df x l l s\nE U\nu t\ne s\nE U\nu t df\nx s\nE U\nx t df x l l s\nE U\nx t x l l x s\nE U\nt\nThe predicate join s s s merges two consistent sequences of updates (s and s )\ninto one overall sequence (s).\njoin s s s df consistent s s s s\ni s s i s i\ns i s i s i\nThe following are some properties that parallel composition owns.\nP1. Chaos E P Chaos\nP2. Stop E P Stop\nP3. P E Q Q E P\nP4. P E Q E R P E Q E R\nP5. P E Q R P E Q P E R\nDefinitions for sequential composition, internal\/external choices, recursion, and\nhiding are presented in the Appendix, which are similar to the definitions in [14].\n5 Class Semantics\nThis section aims to deal with class declarations, their well-definedness and their com-\nposition.\nGiven a class declaration cdecl as follows.\nC\nVisibAttr VisibOp\nInherits C\nlv T\na Ta\nch chan\nsv Ts sensor\nsv Ts actuator\nINIT\nb\nm\ny x Tp Pred u v\nmk\nyk xk T\np\nk Pred uk vk\nmk+ [xk+ T\np\nk+ ] Pk+\nmn [xn Tpn] Pn\nMAIN P\nwhere\n\u2013 C is the name of the class which is declared as a direct subclass of classes C .\n\u2013 The names of visible attributes and operations are listed in VisibList(resp. in Visi-\nbAttr and VisibOp).\n\u2013 m mn are operations declared in C. y i states that only attributes (or ac-\ntuators) yi can be modified by mi. xi T\np\ni are the parameters of the operation m i.\nThe set of operations is divided into two parts, the first part, m mk, called\nstate operations, represent operations in Object-Z style, where the body is speci-\nfied by a predicate. The second part, mk mn, called process operations, are\noperations in process style, where the body is specified by a process.\n\u2013 the MAIN operation is optional. If it is present in the definition, the class is called\nan active class. Otherwise, it is called a passive class.\nWe first discuss the passive class where the MAIN operation is absent. A passive\nclass declaration cdecl is well-defined, denoted by cdecl , if it satisfies the fol-\nlowing conditions: (1) C is distinct from C , (2) the following names are distinct: local\nvariables, state attributes, channels, sensors, actuators, operations, operation parame-\nters, (3) each state operation can only modify the attributes or actuators in its -list,\n(4) the VisibAttr and VisibOp are resp. subsets of the attributes and operations declared\nin the current class or inherited from its superclasses, (5) each -list in state opera-\ntions should be names of attributes or actuators (declared in current class or inherited\nfrom superclasses), (6) the set of sensors and the set of actuators should also include\nthose inherited from superclasses. The last three conditions cannot be tested based on\nan individual class declaration, but can be checked at the end of all class declarations.\nFormally, the well-definedness of the above class declaration given for C is defined by\nthe following predicate.\ndf\nC C type a Ta a Ta type lv T lv T\ntype sv Ts sv Ts type sv Ts sv Ts\ni dif lv a ch sv sv m mn xi\nxi T\np\ni i k vi yi xi\nwhere dif e en df i j n i j ei ej.\nThe class declaration cdecl provides the structural information of class C to the state\nof the system, and its role is specified by the following design.\ncdecl df\nlocvar C lv T CN C\nsuper C Ci Ci C\u2019\nvisibattr C VisibAttr\nvisibop C VisibOp attr C a Ta\nsenvar C sv Ts\nactvar C sv Ts\nchan C ch op ops opp\nops C m x Tp y Pred u v\nmk xk T\np\nk yk Pred uk vk\nopp C mk+ xk+ Tpk+ Pk+\nmn xn Tpn Pn\nThe design P Q df ok P ok Q as in UTP [6].\nThe above environment generated by an individual class declaration cdecl, only\nrecords the names of those variables, attributes and operations. The complete informa-\ntion will be generated at the end of the class declaration section when class dependen-\ncies are also available.\nThe well-definedness of the operation bodies can not be determined by the individ-\nual class declaration itself, and it will be defined at the end of all class declarations.\nAs a result, the logic variable op C binds each operation m i to its body rather than its\nmeaning. The meaning of m i will be calculated at the end of the declarations.\nWe now turn our attention to active classes. The MAIN operation is used to de-\ntermine the behaviour of objects of an active class after initialisation. Objects of an\nactive class have their own thread of control and their mutable state attributes and oper-\nation definitions are fully encapsulated. This condition should be reflected in the well-\ndefinedness of the definition of an active class.\nSuppose the MAIN process is present in the above definition cdecl for class C. The\nwell-definedness is specified by\ncdecl df VisibAttr VisibOp MAIN\nwhere the predicate is defined as above.\nThe MAIN operation part: MAIN b P should be added into the value of the\nlogic variable opp C in the above definition of the design cdecl, where b is the condition\ndeclared in INIT schema. However, when we calculate the set of process operations for\na class later, MAIN is implicitly removed from the set of process operations of any of\nits active superclass, since TCOZ does not allow MAIN process to be inherited.\n5.1 Composing Class Declarations\nAll class definitions cdecls for a specification is a composition of a number of class\ndeclarations\ncdecls df cdecl cdeclk\nBased on these complete definitions, we derive the whole context information for the\nspecification by composing all the class declarations. This is done by simply adding up\nthe contents of the current environment generated by the component class declarations\nprovided that there is no redefinition of a class in its scope. It is also defined by the\nparallel merge operator:\ncdecl cdecl df cdecl M cdecl\nwhere the merge predicateM is defined as the following design\nM df CN CN\nCN CN CN\nsuper super super\nvisibattr visibattr visibattr\nvisibop visibop visibop\nlocvar locvar locvar\nsenvar senvar senvar\nactvar actvar actvar\nattr attr attr op ops opp\nops ops ops opp opp opp\n5.2 Well-Definedness of the Class Declarations\nA sequence of class declarations for a specification is well-defined if the contents of the\nenvironment it has generated meet the following well-definedness conditions:\n\u2013 The visible attributes (resp. operations) declared in a class should be members of\nthe state attributes (resp. operations) in the current class or in any of its superclasses.\ndf C CN VisibAttr C attr super C\nVisibOp C op super C\nwhere super C is composed of all superclasses of C and C itself as before, and\nattr C Cn df i n attr Ci op C Cn df i n op Ci\n\u2013 Multiple inheritances are allowed in TCOZ. However, distinct direct superclasses\nof any class are not permitted to have any common process operations (i.e. process\noperations with the same name and signature).\ndf C CN super C C C super C\nC C dom opp super C dom opp super C\nran opp super C ran opp super C\n\u2013 The -list in each state operation can only comprise attributes or actuator variables\ndeclared in the current class or inherited from any superclass.\ndf C CN m ops C ran m attr super C\nran m actvar super C\n\u2013 No parallel process operation is allowed to update any actuator variable in more\nthan one component.\ndf C CN P E En- Pn opp C\ni j n i j avar Pi avar Pj\nwhere avar P is the set of actuators employed by P.\n\u2013 In addition, other well-definedness conditions, such as the inheritance relation does\nnot contain circularity, are omitted here, since similar conditions have been dis-\ncussed in He, Liu and Li\u2019s work [5] for Java-like object-oriented languages.\n5.3 Formalising the Behaviour of Class Operations\nThe dynamic behaviour of class operations is defined as the least fixed point of a set\nof recursive equations due to the inheritance (dependency) relation among the declared\nclasses. We deal with the state operations and the process operations separately, since\nthe former follow the inheritance rules of Object-Z, whereas the latter do not.\nState Operations For each class C CN and every state operation m ops C\nC super C , it contains an equationD C.m f D , which is defined with respect\nto the following cases.\nCase (1):m is newly introduced, i.e., it is declared in C, but not in any superclasses.\nSuppose the declaration of m is y x T Pred u v\u2019 .\nD C.m df y x T Pred u v\nThe right-hand side is the semantic predicate defined in section 4.2.\nCase (2): m is not declared in C but in its \u201cnearest\u201d superclasses, C Cr, i.e.,\nm ops C i r m ops Ci Ci super C\nWe can always assume none of these classes is a superclass of others, i.e., C i\nsuper Cj , for any i j r. Otherwise, we remove C i from the list if Ci super Cj .\nWe also assume that each Ci is the nearest one to C that defines m in the corresponding\ndependence path, i.e.,\ni r C\u2019 C\u2019 super C Ci super C\u2019 m ops C\u2019\nThe equation for D C.m is\nD C.m i r D Ci m\nCase (3): m is defined in class C as y x T Pred u v\u2019 , but also defined in\nsome \u201cnearest\u201d superclasses, C Cr, i.e.,\nm ops C i r m ops Ci Ci super C\nUsing the same assumption as in case (2), the equation for D C.m is\nD C.m y x T Pred u v i r D Ci m\nProcess Operations Given a class name C, and a process operation m, there are two\ncases to deal with.\nCase (1). The process is not defined in C, but in a superclass C\u2019 of C. Then simply\nD C.m D C\u2019.m\nCase (2). The process operation is defined inC. Its dynamic behaviour is captured by\nits body and the environment in which it is executed. The designD C.m is thus subject\nto the equationD C.m body C.m . is used to pass the actual parameters to their\ncorresponding formal parameters, and generate the semantics predicate afterwards, as\ndiscussed in section 4.\nThe function distributes over operators and is inductively defined as:\nP opP df P op P where op E t\nP DEADLINE t df P Deadline t\nP WAITUNTIL t df P WaitUntil t\nX P df X P P E df P E\nx x f e f e\nwhere f can be any legal arithmetic operator ( ), logical connector\n( ), or set operator ( ).\nAn operation invocation o.m is mapped by to\no.m(val) df o myclass C\u2019 m visibop C\u2019 D C\u2019.m val x\nwhere x is the parameters of the operation C\u2019.m.\n5.4 The Behaviour of Active Classes\nThis subsection is devoted to formalising the behaviour of active classes. The behaviour\nof a system specified in TCOZ is determined by the MAIN processes of active classes.\nGiven a sequence of class declarations cdecls df cdecl cdecln, where cdecln\nis an active class of interest which may depend on (inherit from) the other classes. The\nbehaviour of (any objects of) this active class is defined as the following predicate:\ncdecls initial D cdecln MAIN\nThe design initial performs the following tasks: (1) to check the well-definedness of\nthe complete declaration section; (2) to derive the final values of the logical variables;\n(3) to define the dynamic behaviour of every operation.\ninitial df i i\nsuper super CN CN C CN\nlocvar C locvar super C attr C attr super C\nsenvar C senvar super C actvar C actvar super C\nops C m x T y D C.m Pred\nm x T y Pred ops C C super C\nopp C m x T D C.m P\nm x T P opp C C super C\nvisibattr C attr super C visibattr C C CN\nvisibop C op super C visibop C C CN\nwhere i is the well-definedness condition discussed in section 5.2.D C.m discussed\nin last section defines the dynamic behaviour of the operation m of class C.\n6 Related Work, Conclusion and Future Work\nThe semantics of Object-Z has been investigated earlier. For example, Object-Z has a\nfully abstract semantics [3, 15]. Timed CSP\u2019s semantics has also been well studied [2,\n10, 11]. The process model used by TCOZ [9] presented a conservative extension to the\nbasic timed failures model [10]. The semantic model of TCOZ in this paper is based\non the UTP framework. The most closely related works are the UTP timed [14] and\nuntimed [18] semantic models of Circus and the UTP semantic model [5] of object-\noriented programming languages. A significant contribution of this paper is the unified\nsemantic model for both channel and sensor\/actuators based communications in TCOZ.\nThis new model is far more complete. It not only covers the communication and pro-\ncess aspects of TCOZ, but also other features, such as class encapsulation, inheritance,\ndynamic binding and extended TCOZ timing constructs (deadline and waituntil com-\nmands), which have not been covered by the previous result [9].\nThis paper also demonstrates that UTP can provide a formal semantic foundation\nnot only for programming languages but also for much more expressive specification\nlanguages. In particular, UTP is well suited for capturing formal semantics for inte-\ngrated specification languages (i.e., TCOZ) which often have rich language constructs\nfor state encapsulation, event communication and real-time modeling. Our semantic\nmodel will be used as a reference document for developing tools support for TCOZ. For\nexample, in the semantic model, the well formed rules can be used as precise require-\nments for developing a type checking system. Various laws for the language constructs\ncan be encoded as theorems to support a reasoning system.\nThe semantic model presented in this paper is a discrete time model which can\nreadily be connected to an untimed model, so that model checker like FDR [12] can\nalso be used to check untimed properties of TCOZ. For checking timing properties,\nwe have recently developed transformation rules from TCOZ to Timed Automata (TA)\nso that various TA tools, i.e. UPPAAL [1], can be applied to check timing properties.\nWe plan to give a UTP semantic model for TA, and to prove the soundness of our\ntransformation rules based on UTP semantics for both TCOZ and TA.\nAnother further research work would be to develop operational and data refinement\ntechniques for TCOZ and to look into transforming TCOZ to object-oriented program-\nming languages, e.g., Java. This work should be achievable given that UTP semantics\nfor Java-like language has already been formulated in [5].\nAcknowledgement\nWe would like to thank Jifeng He for helpful comments and inspiring related work. We are also\ngrateful to anonymous referees for many helpful comments.\nReferences\n1. J. Bengtsson, K. Larsen, F. Larsson, P. Pettersson, and Y. Wang. UPPAAL - a Tool Suite for\nAutomatic Verification of Real-Time Systems. Hybrid Systems, LNCS 1066, pages 232\u2013243.\nSpringer-Verlag, 1996.\n2. J. Davies and S. Schneider. A brief history of Timed CSP. Theoret. Comput. Sci., 138:243\u2013\n271, 1995.\n3. D. Duke and R. Duke. Towards a semantics for Object-Z. In D. Bj\u00f8rner, C.A.R. Hoare, and\nH. Langmaack, eds., VDM\u201990: VDM and Z!, LNCS 428, pages 242\u2013262. Springer-Verlag,\n1990.\n4. R. Duke and G. Rose. Formal Object Oriented Specification Using Object-Z. Cornerstones\nof Computing Series. Macmillan, March 2000.\n5. J. He, Z. Liu, and X. Li. A relational model for specification of object-oriented systems.\nTechnical Report 262, UNU\/IIST, October 2002.\n6. C.A.R. Hoare and J. He. Unifying Theories of Programming. Prentice-Hall, 1998.\n7. B. Mahony and J. S. Dong. Sensors and Actuators in TCOZ. In J. Wing, J. Woodcock, and\nJ. Davies, eds., FM99: World Congress on Formal Methods, LNCS 1709, pages 1166\u20131185,\n1999.\n8. B. Mahony and J. S. Dong. Timed Communicating Object Z. IEEE Transactions on Software\nEngineering, 26(2):150\u2013177, February 2000.\n9. B. Mahony and J. S. Dong. Overview of the semantics of TCOZ. In K. Araki, A. Galloway,\nand K. Taguchi, eds, IFM\u201999: Integrated Formal Methods, pages 66\u201385. Springer-Verlag,\n1999.\n10. M. Mislove, A. Roscoe, and S. Schneider. Fixed Points Without Completeness. Theoret.\nComput. Sci., 138:273\u2013314, 1995.\n11. G. Reed and A. Roscoe. A timed model for communicating sequential processes. Theoret.\nComput. Sci., 58:249\u2013261, 1988.\n12. A.W. Roscoe. The Theory and Practice of Concurrency. Prentice-Hall, 1998.\n13. S. Schneider, J. Davies, D. Jackson, G. Reed, J. Reed, and A. Roscoe. Timed CSP: Theory\nand practice. Real-Time: Theory in Practice, LNCS 600, pages 640\u2013675. Springer-Verlag,\n1992.\n14. A. Sherif and J. He. Towards a timed model for circus. In C. George and H. Miao,\neds., ICFEM\u201902 Formal Methods and Software Engineering, LNCS 2495, pages 613\u2013624.\nSpringer-Verlag, 2002.\n15. G. Smith. A fully abstract semantics of classes for Object-Z. Formal Aspects of Computing,\n7(3):289\u2013313, 1995.\n16. G. Smith. The Object-Z Specification Language. Kluwer Academic Publishers, 2000.\n17. J. Woodcock and A. Cavalcanti. Circus: a concurrent refinement language. Technical report,\nOxford University Computing Laboratory, Oxford OX1 3QD, UK, July 2001.\n18. J. Woodcock and A. Cavalcanti. The Semantics of Circus. In D. Bert, J. Bowen, M. Henson\nand K. Robinson, eds., 2nd International Conference on Z and B, LNCS 2272, pages 184\u2013\n203. Springer-Verlag, 2002.\nAppendix\nThe semantics for the process constructs (e.g., primitives, internal\/external choices, etc.) that are\nsimilar to Sherif and He\u2019s work[14] are listed here.\nSkip df ok wait tr tr state state\nStop df ok wait state state no interact trace\nChaos df R true\nP Q df P false ok P wait P true false ok wait Q\nP Q df P Q\nP Q df P Q wait trace\nP Q ok wait trace state state Skip\nwait tr tr trace P Q Skip\nX F(X) df X X F(X)\nP E df tr P tr tr k tr k tr\ntr k tr Event E\ntr k tr k E Skip\n"}