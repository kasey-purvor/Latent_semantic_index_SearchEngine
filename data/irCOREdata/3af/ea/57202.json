{"doi":"10.1007\/s10270-004-0054-1","coreId":"57202","oai":"oai:eprints.lincoln.ac.uk:41","identifiers":["oai:eprints.lincoln.ac.uk:41","10.1007\/s10270-004-0054-1"],"title":"Supporting the reconciliation of models of object behaviour","authors":["Spanoudakis, George","Kim, Hyoseob"],"enrichments":{"references":[{"id":18432494,"title":"A Mathematical Theory of Evidence,","authors":[],"date":"1976","doi":"10.2307\/2529769","raw":"Shafer G (1976), A Mathematical Theory of Evidence, Princeton University Press.","cites":null},{"id":18432495,"title":"An Algorithm for Detecting Overlaps between Models of Object Interactions,","authors":[],"date":"2000","doi":null,"raw":"Spanoudakis  G  (2000),  An  Algorithm  for  Detecting  Overlaps  between  Models  of  Object  Interactions, Technical Report Series, TR-2000\/03, ISSN 1364-4009, Department of Computing, City University.","cites":null},{"id":18432483,"title":"An Integrated Formal Model of Scenarios Based on Statecharts,","authors":[],"date":"1995","doi":"10.1007\/3-540-60406-5_19","raw":"Glinz M (1995), An Integrated Formal Model of Scenarios Based on Statecharts, In Proc. of the 5 th European Software Engineering Conference, LNCS 989, Springer-Verlag, 254-271.","cites":null},{"id":18432485,"title":"Automated Consistency Checking Requirements Specifications,","authors":[],"date":"1996","doi":"10.1145\/234426.234431","raw":"Heitmeyer C, Jeffords R, Kiskis D (1996), Automated Consistency Checking Requirements Specifications, ACM Transactions on Software Engineering and Methodology, 5(3): 231-261.","cites":null},{"id":18432487,"title":"Combinatorial Optimisation: Algorithms and Complexity,","authors":[],"date":"1982","doi":"10.1137\/1025101","raw":"Papadimitriou C, Steiglitz K (1982), Combinatorial Optimisation: Algorithms and Complexity, Prentice-Hall Inc.","cites":null},{"id":18432484,"title":"Completeness and Consistency in Hierarchical State-Based Requirements,","authors":[],"date":"1996","doi":"10.1109\/32.508311","raw":"Heimdahl  M.P.E,  Leveson  N  (1996),  Completeness  and  Consistency  in  Hierarchical  State-Based Requirements, IEEE Transactions in Software Engineering, 22(6): 363-377.","cites":null},{"id":18432480,"title":"Consistency Analysis on Lifecycle Model and Interaction Model,","authors":[],"date":"1998","doi":"10.1007\/978-1-4471-0895-5_26","raw":"Cheung K, Chow K, Cheung T (1998), Consistency Analysis on Lifecycle Model and Interaction Model, Proc. of the 7 th Int. Conference on Object-Oriented Information Systems, 427-441.","cites":null},{"id":18432490,"title":"Elaborating Analogies from Conceptual Models,","authors":[],"date":"1996","doi":"10.1002\/(sici)1098-111x(199611)11:11<917::aid-int4>3.0.co;2-1","raw":"Spanoudakis  G,  Constantopoulos  P  (1996),  Elaborating  Analogies  from  Conceptual  Models,  International Journal of Intelligent Systems, 11(11): 17-974.","cites":null},{"id":18432493,"title":"Finkelstein A","authors":[],"date":"2000","doi":"10.1109\/iwssd.2000.891135","raw":"Zisman A, Emmerich W, Finkelstein A (2000), Using XML to Specify Consistency Rules for Distributed Documents, Proc. of 10 th Int. Workshop on Software Specification and Design.","cites":null},{"id":18432481,"title":"Handling Conflict between Domain Descriptions with","authors":[],"date":"1991","doi":"10.1016\/1042-8143(91)90007-a","raw":"Easterbrook  S  (1991),  Handling  Conflict  between  Domain  Descriptions  with  Computer-Supported Negotiation, Knowledge Acquisition, 3: 255-289.","cites":null},{"id":18432479,"title":"Identifying Quality Requirements Conflicts,","authors":[],"date":"1996","doi":"10.1109\/icre.1996.491448","raw":"Boehm B, In H (1996), Identifying Quality Requirements Conflicts, IEEE Software, 25-35.","cites":null},{"id":18432482,"title":"Inconsistency Handling In MultiPerspective Specifications,","authors":[],"date":"1994","doi":"10.1109\/32.310667","raw":"Finkelstein A., Gabbay D, Hunter, A, Kramer, J, and Nuseibeh, B (1994), Inconsistency Handling In MultiPerspective Specifications, IEEE Transactions on Software Engineering, 20(8): 569-578.","cites":null},{"id":18432492,"title":"Managing Conflicts in Goal-Driven Requirements Engineering,","authors":[],"date":"1998","doi":"10.1109\/32.730542","raw":"Lamsweerde A, Darimont R, Letier E (1998), Managing Conflicts in Goal-Driven Requirements Engineering, IEEE Transactions on Software Engineering, 24(11): 908-926.","cites":null},{"id":18432489,"title":"MENTOR: A Computer Aided Requirements Engineering Environment,","authors":[],"date":"1996","doi":"10.1007\/3-540-61292-0_2","raw":"Si-Said  S,  Rolland  C,  Grosz  G  (1996),  MENTOR:  A  Computer  Aided  Requirements  Engineering Environment, Proc. of the 8 th International Conference on Advanced Information Systems Engineering, 22-43.","cites":null},{"id":18432486,"title":"Modeling Language Specification (Action Semantics) -","authors":[],"date":null,"doi":"10.3403\/30193744","raw":"OMG,  Unified  Modeling  Language  Specification  (Action  Semantics)  -  V.  1.4.  Available  from: http:\/\/www.omg.org\/technology\/documents\/modeling_spec_catalog.htm .","cites":null},{"id":18432491,"title":"Reconciling requirements: a method for managing interference, inconsistency and conflict,","authors":[],"date":"1997","doi":null,"raw":"Spanoudakis G, and Finkelstein A (1997), Reconciling requirements: a method for managing interference, inconsistency  and  conflict,  Annals  of  Software  Engineering,  Special  Issue  on  Software  Requirements Engineering, 3: 459-475.","cites":null},{"id":18432488,"title":"Supporting Multi-Perspective Requirements Engineering,","authors":[],"date":"1994","doi":"10.1109\/icre.1994.292383","raw":"Robinson, W. and Fickas S (1994), Supporting Multi-Perspective Requirements Engineering, In Proc. of the IEEE Conference on Requirements Engineering, IEEE Computer Society Press, 206-215.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2004-12","abstract":"This paper presents Reconciliation+, a method which identifies overlaps between models of software systems behaviour expressed as UML object interaction diagrams (i.e., sequence and\/or collaboration diagrams), checks whether the overlapping elements of these models satisfy specific consistency rules and, in cases where they violate these rules, guides software designers in handling the detected inconsistencies. The method detects overlaps between object interaction diagrams by using a probabilistic message matching algorithm that has been developed for this purpose. The guidance to software designers on when to check for inconsistencies and how to deal with them is delivered by enacting a built-in process model that specifies the consistency rules that can be checked against overlapping models and different ways of handling violations of these rules. Reconciliation+ is supported by a toolkit. It has also been evaluated in a case study. This case study has produced positive results which are discussed in the paper","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/57202.pdf","fullTextIdentifier":"http:\/\/eprints.lincoln.ac.uk\/41\/1\/sosym04.pdf","pdfHashValue":"4dad972d7498091d5c3824211a5c0d4dcfb06ace","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lincoln.ac.uk:41<\/identifier><datestamp>\n      2013-03-13T08:21:45Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D6A6163735F47:6A6163735F47343030<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/eprints.lincoln.ac.uk\/41\/<\/dc:relation><dc:title>\n        Supporting the reconciliation of models of object behaviour<\/dc:title><dc:creator>\n        Spanoudakis, George<\/dc:creator><dc:creator>\n        Kim, Hyoseob<\/dc:creator><dc:subject>\n        G400 Computer Science<\/dc:subject><dc:description>\n        This paper presents Reconciliation+, a method which identifies overlaps between models of software systems behaviour expressed as UML object interaction diagrams (i.e., sequence and\/or collaboration diagrams), checks whether the overlapping elements of these models satisfy specific consistency rules and, in cases where they violate these rules, guides software designers in handling the detected inconsistencies. The method detects overlaps between object interaction diagrams by using a probabilistic message matching algorithm that has been developed for this purpose. The guidance to software designers on when to check for inconsistencies and how to deal with them is delivered by enacting a built-in process model that specifies the consistency rules that can be checked against overlapping models and different ways of handling violations of these rules. Reconciliation+ is supported by a toolkit. It has also been evaluated in a case study. This case study has produced positive results which are discussed in the paper.<\/dc:description><dc:publisher>\n        Springer<\/dc:publisher><dc:date>\n        2004-12<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/eprints.lincoln.ac.uk\/41\/1\/sosym04.pdf<\/dc:identifier><dc:identifier>\n          Spanoudakis, George and Kim, Hyoseob  (2004) Supporting the reconciliation of models of object behaviour.  Software and systems modelling, 3  (4).   pp. 273-293.  ISSN 16191366  <\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1007\/s10270-004-0054-1<\/dc:relation><dc:relation>\n        10.1007\/s10270-004-0054-1<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/eprints.lincoln.ac.uk\/41\/","http:\/\/dx.doi.org\/10.1007\/s10270-004-0054-1","10.1007\/s10270-004-0054-1"],"year":2004,"topics":["G400 Computer Science"],"subject":["Article","PeerReviewed"],"fullText":"1Supporting the Reconciliation of Models of\nObject Behaviour1\nGEORGE SPANOUDAKIS AND HYOSEOB KIM2\nDepartment of Computing,\nCity University,\nNorthampton Square, London EC1V 0HB, UK\nE\u2013mail: gespan@soi.city.ac.uk\n                                                          \n1 This article is an extended version of the article \"Reconciliation of Object Interaction Models\" that\nappeared in the proceedings of the 7th International Conference on Object Oriented Information\nSystems.\n2 This article reports on research that was carried out while the second author was affiliated with the\nDepartment of Computing of City University.\nAbstract: This paper presents Reconciliation+, a method which identifies overlaps between models of\nsoftware systems behaviour expressed as UML object interaction diagrams (i.e., sequence and\/or\ncollaboration diagrams), checks whether the overlapping elements of these models satisfy specific\nconsistency rules and, in cases where they violate these rules, guides software designers in handling the\ndetected inconsistencies. The method detects overlaps between object interaction diagrams by using a\nprobabilistic message matching algorithm that has been developed for this purpose. The guidance to\nsoftware designers on when to check for inconsistencies and how to deal with them is delivered by\nenacting a built-in process model that specifies the consistency rules that can be checked against\noverlapping models and different ways of handling violations of these rules. Reconciliation+ is\nsupported by a toolkit. It has also been evaluated in a case study. This case study has produced positive\nresults which are discussed in the paper.\nKeywords: consistency management, software design models, object interaction diagrams\n1 Introduction\nThe specification of software system behaviour using multiple object interaction\ndiagrams (i.e., sequence and\/or collaboration diagrams) creates the potential of\nconflicting specifications of messages, objects and operations in these models. This is\nbecause different object interaction diagrams may, by virtue of the exchanges of\nmessages that they specify and other elements in the specifications of these messages,\nimply different behaviours for the same objects and operations.\nConsider, for example, an object model for a library system that includes the object\ninteraction diagrams I1 and I2 of Figure 1 and the class diagram of Figure 2. The\ndiagrams I1 and I2 specify interactions, which occur when the library system is used to\nsearch for items in the library either by keywords which refer to the author of an item\n(I1) or  by keywords which refer to the title of an item (I2). The class diagram of Figure\n22 specifies the classes of the objects that participate in the interactions of I1 and I2.\nAccording to I1 and I2, the library system: (i) gets search keywords from a UI\ncomponent (see messages 11:getText() in I1 and 8:getText() in I2); (ii)\nformulates a database query (see message 9:formulateQuery() in I2); and (iii)\nexecutes the query (see messages 12:executeQuery(SQLStatement)in I1 and\n10:executeQuery(SQLSt) in I2).\nFigure 1: Object interaction diagrams SearchByAuthor (I1) and SearchByTitle (I2)\nIn this example, it is plausible to assume that the messages\n10:actionPerformed(ActionEvent) in I1 and\n7:actionPerformed(ActionEvent) in I2 overlap since (in the current state of\nthe models) they both appear to invoke the operation\nactionPerformed(e:ActionEvent) of the class\nDatabaseActionListener in Figure 2. If, however,  this assumption is correct\nthen the specifications of the behaviour of the operation\nactionPerformed(e:ActionEvent) which are implied by I1 and I2 are\nconflicting. This is because according to I2 (but not I1) the execution of the operation\nactionPerformed(e:ActionEvent) leads to the dispatch of the message\n9:formulateQuery() and therefore the execution of the operation\nformulateQuery() of the class Manager.\nConflicts of this form need to be detected and reconciled in the design phase of a\nsystem development project in order to eliminate ambiguities that could be more\nexpensive to resolve at the implementation phase.\nIn this paper, we describe a tool-supported method, called Reconciliation+, that we\nhave developed to support software designers to detect and handle conflicts in\nbehavioural specifications in models of object interactions which are expressed as\nsequence (or collaboration) diagrams in UML [9]. This method is a newly developed\nI2 - SearchByTitle\nm : \nManager\nsefo : \nSearchForm\n : TextField  : \nButton\n : \nDBHandler\n1: new(m)\n8: getText()\n2: TextField(\"book-title\")\n4: Button(\"search\")\n10: executeQuery(SQLSt)\n6: setVisible(True)\n3: addActionListener(m)\n5: addActionListener(m)\n7: actionPerformed(ActionEvent)\n9: formulateQuery( )\nI1 - SearchByAuthor\no1 : \nManager\nc1 : SearchByAuthor f1 : SearchForm tf : TextField bt : \nButton\n : Panel  : \nDBHandler\n1: create(o1)\n2: new(o1)\n10: actionPerformed(ActionEvent)\n11: getText()\n3: TextField(\"author_name\")\n4: Button(\"search\")\n5: Panel( )\n6: add(bt, pos2)\n7: add(f1,pos3)\n12: executeQuery(SQLStatement)\n9: actionPerformed(e)\n8: addActionListener(f1)\n3extension of a method for managing modelling discrepancies in structural object\nmodels that is discussed in [15].\nFigure 2: Model of classes of object interaction diagrams of Figure 1\nConflicts in Reconciliation+ are detected as violations of consistency rules. A\nconsistency rule sets the conditions that should be satisfied by overlapping messages\nin different object interaction diagrams. In the above example of the library system,\nfor instance, the conflict in the specifications of the behaviour of the operation\nactionPerformed(e:ActionEvent) implied by I1 and I2 could be detected as a\nviolation of the following consistency rule:\nCR1: If a message mi overlaps with a message mj then for every message mk\nthat is dispatched by mi (mj) there must exist a message mw dispatched\nby mj (mi) such that mk and mw overlap.\nCR1 in this case would be violated by the message 9:formulateQuery() that is\ndispatched by the message 7:actionPerformed(ActionEvent) in I2 and has no\noverlapping counterpart in the messages which are dispatched by the message\n10:actionPerformed(ActionEvent) in I1 that overlaps with it.\nOverlaps in Reconciliation+ are defined as relations between messages which are\nlikely to signify the invocation of operations with the same implementation and are\ndetected by a probabilistic message matching algorithm. This algorithm can detect\noverlaps between messages which are not identically modelled if certain parts of their\nspecifications provide strong evidence to believe that the messages signify the\ninvocation of operations with the same implementation. Thus, for example, it may\ndetect an overlap relation between two messages mi and mj that have different\nsignatures if they are sent to objects which are instances of the same class and dispatch\nthe same messages (e.g. message 12:executeQuery(SQLStatement) in I1 and\nmessage 10:executeQuery(SQLSt)in I2).\nEventListener\n<<Interface>>\nSearchByAuthor\nformulateQuery()\n<<constructor>> create(m : Manager)\nSearchForm\n<<constructor>> new(m : Manager)\ngetData()\nDBHandler\nexecuteQuery(statement : String)\nManager\nformulateQuery()\nButton\nprocessEvent(e : AWTEvent)\nPanel\nPanel()\nPanel(layout : LayoutManager)\naddNotify() : void\nTextField\nprocessEvent(e : AWTEvent)\nActionListener\nactionPerformed(e : ActionEvent) : void\n<<Interface>>\nTextComponent\nContainer\nComponent\nprocessEvent(e : AWTEvent)\nDatabaseActionListener\nactionPerformed(e : ActionEvent) : void\nactionPerformed(e : ActionEvent) : void\n4Reconciliation+ incorporates a set of pre-defined consistency rules that should be\nsatisfied by overlapping messages and alternative ways of handling violations of these\nrules. The method guides software designers in selecting which of these consistency\nrules to check and how to handle their violations. This guidance is delivered by\nenacting a built-in process model that specifies the consistency rules that can be\nchecked against overlapping messages, and different ways of handling the violations\nof these rules. The method is extensible as software designers can extend its built-in\nprocess model by specifying new consistency rules, and new ways of handling\nviolations of new or existing rules.\nThe rest of this paper is structured as follows. In Section 2, we describe the algorithm\nthat Reconciliation+ deploys for detecting overlapping messages in different\ninteraction diagrams. In Section 3, we describe the specification and enactment of the\nprocess model of the method that is used for guiding designers in reconciling object\ninteraction diagrams. In Section 4, we describe the specification of consistency rules\nusing the process model of the method and the mechanism for detecting violations of\nthese rules. In Section 5, we describe the scheme for specifying and executing\ndifferent ways of handling inconsistencies. In Section 6, we present an overview of the\nprototype toolkit we have developed to support Reconciliation+. In Section 7, we\npresent the results of a case study that we have conducted to evaluate the method.\nFinally, in Section 8 we overview related work and, in Section 9, we summarise the\nmethod and outline ongoing work on it.\n2 Detection of overlaps\n2.1 Basic algorithmic formulation\nOverlaps in Reconciliation+ are defined as relations between messages which are\nlikely to signify the invocation of operations with the same implementation. The\ndetection of these relations is formulated as an instance of the weighted bipartite\ngraph matching problem [10]. More specifically, assuming a pair of interaction\ndiagrams Ii and Ij, we construct a weighted interaction overlap graph: IOG(Ii, Ij) = (Vi\n\u222a Vj, E(Vi,Vj)). This graph has two sets of disjoint vertices, Vi and Vj, which\nassuming that Ii has more messages than Ij, are defined as:\nVi \u2261 Messages(Ii) and Vj \u2261 Messages(Ij) \u222a DVk\nwhere\n\u008c Messages(Ii) is the set of messages of the interaction diagram Ii;\n\u008c Messages(Ij) is the set of messages of the interaction diagram Ij; and\n\u008c DVk is a set of k special vertices representing dummy messages (k = |Messages(Ii)|\n\u2212 |Messages(Ij)|).\nThe set of the edges E(Vi,Vj) includes all the possible edges between the messages of\nIi and the messages of Ij, or formally:\nE(Vi,Vj) = {(ni ,nj, b0(\u00acov(ni,nj))) | (ni \u2208 Vi) and (nj \u2208 Vj)}\n5An edge (ni ,nj, b0(\u00acov(ni,nj))) in E(Vi,Vj) designates the assumption that the messages\nrepresented by the nodes ni and nj overlap and is weighted by the measure\nb0(\u00acov(ni,nj)). This measure is defined as the degree of belief in the falsity of the\noverlap assumption expressed by the edge, and is computed according to the following\nfunction:\nb0(\u00acov(ni,nj)) = \u03a3U\u2286{1,\u2026,6}(\u22121)|U|+1{\u03a0u\u2208U bu(\u00acov(ni,nj))}\n  if  ni \u2208 Messages(Ii) and nj \u2208 Messages(Ij) (I)\nb0(\u00acov(ni,nj)) = 1 if nj \u2208 DVk\nThe functions b1,\u2026,b6 used in (I) compute partial beliefs in the existence\/absence of\nan overlap between two messages. The computation of these partial beliefs is based on\nheuristic criteria for assessing the equivalence of the functional roles and\nimplementations of the operations invoked by the messages, and the functional\ncontexts in which these operations are invoked. These belief functions and the criteria\nunderpinning them are discussed in detail in Section 2.2.\nAfter computing the beliefs b0 for all the edges of IOG(Ii, Ij), the most likely overlaps\nbetween the messages in Ii and Ij are detected in two steps. In the first step, the most\nlikely candidate overlaps are identified by selecting a subset O(Vi,Vj) of E(Vi,Vj)\nwhich is a total morphism between Vi and Vj and minimises the function3:\n\u03a3(nu, nw, b0(\u00acov(nu,nw))) \u2208 O(Vi,Vj)  b0(\u00acov(nu,nw)) (II)\nIn the second step, O(Vi,Vj) is restricted to include only the edges\n(nu,nw,b0(\u00acov(nu,nw)) whose belief does not exceed a threshold value bt, (i.e., edges for\nwhich b0(\u00acov(nu,nv)) \u2264 bt).\n2.2 Criteria of overlap and partial belief functions\nBeliefs in favour of, or against a hypothesis that two messages overlap are computed\nbased on six criteria. These criteria indicate the equivalence of the functional roles and\nimplementations of the operations which are invoked by the messages, and the\nequivalence of the contexts in which these operations are invoked.\n2.2.1 Equivalence of functional roles of invoked operations\nBeliefs in the equivalence of the functional roles of the operations which are invoked\nby two messages are computed using two criteria, namely the criterion of the most\ngeneric overridden operation and the criterion of the operation stereotypes.\nThe criterion of most generic overridden operation\nTwo operations are assumed to have equivalent functional roles if they override the\nsame most general operation in an object model.\nAccording to this criterion, the operations processEvent(e: AWTEvent) which\nare defined in the classes Button and TextField in Figure 2, for example, are\n                                                          \n3\n The morphism O(Vi,Vj) is selected using the Hungarian method [10].\n6considered to have equivalent functional roles. This is because both of them override\nthe same most generic operation in the class model of the figure, namely the operation\nprocessEvent(e:AWTEvent) of Component. In this example, the classes\nButton and TextField override the latter operation that they inherit from\nComponent in order to introduce the different functionality which is required for\nprocessing events of two different types: action events by Button and text events by\nTextField [20]. Despite of the differences in their exact functionality, however, the\nfunctional role of the operations processEvent(AWTEvent e) in Button and\nTextField is the same, that is to enable the instances of these classes to handle\nevents related to them.\nNote that, while in single inheritance hierarchies an operation always overrides a\nsingle most generic operation (which may trivially be itself4), in multiple inheritance\ngraphs there is a potential for ambiguity. Such an ambiguity arises in cases where two\nsuperclasses of a class C, which are not directly or implicitly related by a\ngeneralisation relation themselves, define operations that have the same signature as\nan operation that is defined in C.\nTo cope with ambiguities of this form, we introduce the following function that\nmeasures the degree of belief in the existence (absence) of an overlap relation between\ntwo messages based on the criterion of the most generic overridden operations:\nDefinition 1: The degree of belief in the existence (absence) of an overlap relation\nbetween two messages mi and mj based on the criterion of the most generic operations\noverridden by the operations invoked by mi and mj is computed according to the\nfunction:\nb1(\u00acov(mi,mj)) =  \u03b11 \u00d7 d1(mi,mj)    and    b1(ov(mi,mj)) =  0\nwhere\n\u008c d1(mi,mj) = (|Os(oi)\u2212Os(oj)|+|Os(oj)\u2212Os(oi)|)\/|Os(oi)\u222aOs(oj)|\nif Os(oi) \u2260 \u2205 and Os(oj) \u2260 \u2205\n\u008c d1(mi,mj)=1\nif Os(oi) = \u2205 or Os(oj) = \u2205\n\u008c oi is the operation invoked by mi and oj is the operation invoked by mj\n\u008c Os(oi) (Os(oj)) is a set of operations which are defined in the superclasses of the\nclass that defines oi (oj), have the same signature with it, and do not override any\nother operation with the same signature.\n\u008c \u03b11 is the expected ratio of messages that invoke operations which do not override the\nsame most generic operation and do not overlap (0 \u2264 \u03b11 \u2264 1)\nExamples\nThe belief produced by b1 in the absence of an overlap relation between the messages\n7:actionPerformed(ActionEvent) and\n10:actionPerformed(ActionEvent)) in the interaction diagrams I1 and I2 of\nFigure 1 is 0. This is because, according to the class model of Figure 2, both these\nmessages invoke the same operation, that is\nDatabaseActionListener.actionPerformed(e:ActionEvent), and\n                                                          \n4\n As in the case of the operation formulateQuery() of the class Manager in Figure 2.\n7therefore the same most general overridden operation (i.e.,\nActionListener.actionPerformed(e:ActionEvent)). Thus, the d1\ndistance between these messages is 0.\nNote, however, that the belief in the absence of an overlap relation between the\nmessages 9:actionPerformed(e) in I1 and\n7:actionPerformed(ActionEvent) in I2 that is generated by b1 is 0.4\n(assuming that \u03b11 = 0.4). This is because the former message invokes the operation\nSearchForm.actionPerformed(e: ActionEvent) and the latter message\ninvokes the operation DatabaseActionListener.actionPerformed(e:\nActionEvent) in Figure 2. And as these two operations override different most\ngeneral operations in the relevant class model (i.e., the operation\nSearchForm.actionPerformed(e: ActionEvent) and the operation\nActionListener.actionPerformed(e:ActionEvent), respectively), the\ndistance between the above messages is 1. As a result, b1 assumes that the functional\nroles of SearchForm.actionPerformed(e: ActionEvent)  and\nDatabaseActionListener.actionPerformed(e: ActionEvent) are\ndifferent and, therefore, it generates the maximum possible belief against the existence\nof an overlap relation between 9:actionPerformed(e) and\n7:actionPerformed(ActionEvent).\nThe criterion of operation stereotypes\nThe second criterion for assessing the equivalence of the functional roles of two\noperations is based on operation stereotypes. According to this criterion, the functional\nroles of two operations are considered equivalent if the operations have the same\nstereotype(s). This criterion is used since, in UML, operation stereotypes are used to\ndesignate groups of functionally similar operations. The belief function associated\nwith this criterion is defined as follows:\nDefinition 2: The degree of belief in the existence (absence) of an overlap relation\nbetween two messages mi and mj based on the criterion of the stereotypes of the\noperations that mi and mj invoke is computed according to the function:\nb4(\u00acov(mi,mj)) =  \u03b14 \u00d7 d4(mi,mj)    and    b4(ov(mi,mj)) =  0\nwhere\n\u008c d4(mi,mj) = (|St(oi)\u2212St(oj)|+|St(oj)\u2212St(oi)|)\/|St(oi)\u222aSt(oj)| if St(oi)\u2260\u2205 and St(oj)\u2260\u2205\n\u008c d4(mi,mj) = 1 if St(oi)=\u2205 or St(oj)=\u2205\n\u008c oi is the operation invoked by mi and oj is the operation invoked by mj\n\u008c St(oi) and St(oj) are the sets of the stereotypes of oi and oj\n\u008c \u03b14 is the expected ratio of operations with different stereotypes which do not\noverlap (0 \u2264 \u03b14 \u2264 1)\nThe functional form of b4 covers cases where an operation may belong to different\nstereotype groups. In these cases, d4 measures the likelihood of the operations invoked\nby two messages not having a common stereotype.\n8Examples\nThe d4 distance between the messages 1:create(o1) in I1 and  1:new(m) in I2 is\n0. This is because the operations SearchByAuthor.create(o:Manager) and\nSearchForm.new(o:SearchByAuthor) which are invoked by these messages,\nare both stereotyped as constructor-operations in the class diagram of Figure 2. Thus,\nb4 is also 0 in this case. For any other pair of messages in Figure 1, however, since the\nstereotypes of the operations invoked by them are not defined (see Figure 2) the d4\ndistance is 1 and thus it generates a b4 belief equal to \u03b14.\n2.2.2 Equivalence of the functional contexts of operations\nThe assessment of the equivalence of the functional contexts of two messages is based\non three criteria. The first of these criteria is whether the messages are sent by\ninstances of the same class or, equivalently in terms of UML, they have the same\nsenders. The second criterion is whether the messages are received by instances of the\nsame class or, in terms of UML, they have the same receivers. The third criterion is\nwhether the messages are dispatched by the same message or, in terms of UML, have\nthe same activator.\nThe criterion of message senders\nAccording to this criterion, the functional contexts in which two messages are\ndispatched are considered to be different if the messages are sent by objects which are\ninstances of different classes. The belief function that is associated with this criterion\nis defined as:\nDefinition 3: The degree of belief in the existence (absence) of an overlap relation\nbetween two messages mi and mj based on the criterion of message senders is\ncomputed according to the function: \nb2(\u00acov(mi,mj)) =  \u03b12 \u00d7 d2(si, sj)    and    b2(ov(mi,mj)) = 0\nwhere\n\u008c si and sj are the classes of the objects that send mi and mj, respectively\n\u008c d2(si, sj) is a function measuring the generalisation distance between si and sj defined\nas:\n\u2212 d2(si, sj) = \u2211 x\u2208NCSij SD(x)-1 \/ \u2211 y\u2208ASSij SD(y)-1 if si and si are specified\nd2(si, sj) = 1 if si or si is not specified\n\u2212 NCSij = ((si.Isa* \u222a {si}) \u2212 (sj.Isa* \u222a {sj})) \u222a ((sj.Isa* \u222a {sj}) \u2212 (si.Isa* \u222a {si}))\n\u2212 ASSij = ((si.Isa* \u222a {si }) \u222a (sj.Isa* \u222a {sj }))\n\u2212 SD(x) is the length of the longest path connecting a class x with its most general\nsuperclass, called specialisation depth of x\n\u2212 si.Isa* (sj.Isa*) is the transitive closure of the superclasses of class si(sj)\n\u008c \u03b12 is the expected ratio of non overlapping messages with different senders (0 \u2264 \u03b12 \u2264\n1)\nThe assumption underpinning the definition of the belief function b2 is that the identity\nof class names is not necessarily an accurate indicator of the identity of classes,\nespecially if classes are specified in two independently constructed models of the same\n9system. Thus, b2 computes a belief in class identity based not only on the classes\nthemselves but also on their superclasses. According to its definition, the more the\nnon-common superclasses of two classes ci and cj the stronger the belief that ci and cj\nare not identical.\nEach of the non-common superclasses of two classes ci and cj produces evidence of\ndifferent strength for the assumption that ci and cj are not identical. The strength of\nthis evidence is measured as the inverse of the specialisation depth (i.e., the length of\nthe longest path connecting a class with its most general superclasses) of a superclass\nin the generalisation graph of the model(s). According to this measure, non common\nsuperclasses which appear in relatively low levels of generalisation graphs and, by\nvirtue of their position, introduce fine-grain specialisations of more general classes\nprovide weaker evidence than classes which appear in higher positions [14].\nExamples\nGiven the class model of Figure 2, the d2 distance between the classes Manager and\nSearchByAuthor that send the messages 2:new(o1) and 1:new(m) in the\ninteraction diagrams I1 and I2 is 0.21. Thus, assuming that \u03b12  = 0.1, the belief in the\nabsence of an overlap relation between these messages that b2 generates is 0.021.\nThe criterion of message receivers\nAccording to this criterion, the functional contexts of two messages are not considered\nto be equivalent if the messages are received by objects which are instances of\ndifferent classes or, equivalently in terms of UML, if they have different receivers.\nThe belief function that is associated with this criterion is defined as:\nDefinition 4: The degree of belief in the existence (absence) of an overlap relation\nbetween two messages mi and mj based on the criterion of message receivers is\ncomputed according to the function:\nb3(\u00acov(mi,mj)) =  \u03b13 \u00d7 d2(ri, rj)    and    b3(ov(mi,mj)) =  0\nwhere\n\u008c ri and rj are the classes of the objects that receive mi and mj, respectively\n\u008c d2 is as defined in Definition 3\n\u008c \u03b13 is the expected ratio of messages with different receivers which do not overlap\n(0 \u2264 \u03b13 \u2264 1)\nThe rational for using the above function for measuring belief in the absence\/existence\nof an overlap relation between the receivers of two messages is the same as that used\nin the case of the function b2.\nThe criterion of message activators\nThe third criterion for calculating belief in the equivalence of the functional contexts\nof two messages mi and mj is whether these messages are sent by messages which\noverlap themselves (these messages are called activators in UML). The belief function\nassociated with this criterion of message activators is defined as follows:\n10\nDefinition 5: The degree of belief in the existence (absence) of an overlap relation\nbetween two messages mi and mj based on the criterion of their message activators is\ncomputed according to the function: \nb5(\u00acov(mi,mj)) = \u03b15 \u00d7 \u03a3U\u2286{1,\u2026,4}(\u20131)|U|+1{\u03a0u\u2208Ubu(\u00acov(mk,ml))} if mk \u2260 nil & ml \u2260 nil\nb5(\u00acov(mi,mj)) = \u03b15 \u00d7 1   if mk = nil or ml = nil\nb5(ov(mi,mj)) = 0\nwhere\n\u008c mk and ml are the activators of the messages mi and mj, respectively\n\u008c b1,\u2026, b4 are the belief functions defined definitions 1-4\n\u008c \u03b15 is the expected ratio of messages with different activators which do not overlap (0\n\u2264 \u03b15 \u2264 1)\nAccording to Definition 5, the criteria used for computing beliefs in the absence of an\noverlap relation between the activators of two messages include the criteria of most\ngeneric overridden operation, operation stereotypes, message senders and message\nreceivers but excludes the criteria of message activators and message activations (see\nSection 2.2.3). The reason for not using the criterion of message activators in the\ncomputation of b5 beliefs is to avoid recursive computations in the transitive closure of\nthe activators of the messages. Similarly, the reason for excluding the criterion of\nmessage activations when calculating beliefs in the existence and absence of an\noverlap relation between the activators of two messages mi and mj is that their\ninclusion would lead to a non terminating recursion in the computations, since it\nwould require the computation of the belief in the absence of an overlap between mi\nand mj again (see definition of belief function b6 below).\nExamples\nAssuming that the parameters \u03b11, \u03b12 , \u03b13 , \u03b14 , \u03b15, \u03b16  take the values .4, .1, .2, .1, .2, and\n.4, respectively, the b5 belief in the absence of an overlap relation between the\nmessages 3:TextField(\"author_name\") in I1 and 2:\nTextField(\"book_title\")in I2 is 0.02. This is because there is weak evidence\nfrom the model against the existence of an overlap relation between the activators of\nthese messages (these are the messages 2:new(o1) and 1:new(m), respectively) .\nMore specifically, in this case we have that:\n\u03a3U\u2286{1,\u2026,4}(\u20131)|U|+1{\u03a0u\u2208Ubu(\u00acov(2:new(o1), 1:new(m)))} = 0.1\n2.2.3 Equivalence of the implementations of operations\nThe criterion of message activations\nThe final criterion for computing a partial belief in the existence\/absence of an overlap\nrelation between two messages mi and mj is whether the messages that mi and mj\ndispatch messages which overlap themselves or, in terms of UML, they have the same\nactivations. This criterion is used since the dispatch of non-overlapping messages by\ntwo messages mi and mj implies that the operations which are invoked by mi and mj\nhave different implementations. The belief function associated with this criterion is\ndefined as follows:\n11\nDefinition 6: The degree of belief in the existence (absence) of an overlap relation\nbetween two messages mi and mj based on the criterion of message activations is\ncomputed according to the function: \nb6(\u00acov(mi,mj)) =  \u03b16 \u00d7 d6(mi,mj)    and    b6(ov(mi,mj)) =  0\nwhere\n\u008c d6(mi,mj) = (min X\u2208Morphisms(i,j) (\u2211(mu,mv)\u2208Xbo(\u00acov(mu,mv)) + max(|Ai|\u2212|Aj|,\n|Aj|\u2212|Ai|)) \/ max(|Ai|, |Aj|) if Ai \u2260 \u2205 and Aj \u2260 \u2205\nd6(mi,mj) = 1 if Ai = \u2205 or Aj = \u2205\n\u008c Ai and Aj are the sets of messages which are dispatched by mi and mj, respectively.\n\u008c Morphisms(i,j) is the set of all the total morphisms from the messages in Ai to the\nmessages in Aj if |Ai| \u2264 |Aj| or onto morphisms from the messages in Ai to the\nmessages in Aj if |Aj| < |Ai|.\n\u008c b0(\u00acov(mu,mv)) is computed as defined by formula (I).\n\u008c \u03b16 is the expected ratio of messages with different activations which do not overlap\n(0 \u2264 \u03b16 \u2264 1)\nAccording to Definition 6, the computation of b6 beliefs for two messages mi and mj\nleads recursively to the identification of the most likely overlaps between all the\nmessages which are directly or transitively dispatched by them (this is because d6 is\ndefined in terms of b0 which, according to formula (I), is defined in terms of b6). This\nrecursive computation is terminated whenever the messages under comparison in the\ntransitive closures of the activations of mi and mj dispatch no further messages. In\ncases where any of the messages under comparison dispatches no messages, d6 returns\na belief equal to one. This belief reflects the hypothesis that in the absence of any\nevidence about the additional operations that two operations o1 and o2 invoke o1 and o2\ncan be assumed to have different implementations.\nExamples\nThe b6 beliefs in the absence of an overlap relation between the messages 1:new(m)\nand 2:new(o1) and between the messages\n7:actionPerformed(ActionEvent) and\n10:actionPerformed(ActionEvent) in the interaction diagrams of Figure 1\nare .88 and .61, respectively. These beliefs are computed assuming that the parameters\n\u03b11, \u03b12 , \u03b13 , \u03b14 , \u03b15, \u03b16  take the values .4, .1, .2, .1, .2, and .4, respectively.\nThe above b6 beliefs reflect the facts that\n(a) The activations of 1:new(m) and 2:new(o1)have only one pair of overlapping\nmessages, that is the pair formed by the messages 2:TextField(\"book-\ntitle\") and 3:TextField(\"author-name\"), and four messages without\noverlapping counterparts, namely the messages 3:addActionListener(m),\n4:Button(\"search\"), 5:addActionListener(m), and\n6:setVisible(True) in the activation of 1:new(m).\n(b) The activations of 7:actionPerformed(ActionEvent) and\n10:actionPerformed(ActionEvent) have two pairs of overlapping\nmessages (these are pairs formed by the messages 8:getText() and\n12\n11:getText(), and the messages 10:executeQuery(SQLSt) and\n12:executeQuery(SQLStatement)), and one message without an\noverlapping counterpart, namely the message 9:formulateQuery().\n2.3 Example of detecting an overlap morphism\nThe algorithm specified in Sections 2.1 and 2.2 detects the following overlapping\nmessages in the interaction diagrams of Figure 1:\n(i) message 2:new(o1) in I1 and message 1:new(m) in I2\n(ii) message 3:TextField(\"author_name\") in I1 and message\n2:TextField(\"book-title\") in I2\n(iii) message 4:Button(\"search\") in I1 and message\n4:Button(\"search\") in I2\n(iv) message 10:actionPerformed(ActionEvent) in I1 and message\n7:actionPerformed(ActionEvent) in I2\n(v) message 11:getText() in I1 and message 8:getText() in I2\n(vi) message 12:executeQuery(SQLStatement) in I1 and message\n10:executeQuery(SQLSt)in I2\nMessages Beliefs\nb1 b2 b3 b4 b5 b6 bo\n(2, 1) 0 0.214 0 0 1 0.928 0.507\n(3, 2) 0 1 0 0 0.52 1 0.516\n(4, 4) 0 1 0 0 0.52 1 0.516\n(10, 7) 0 0.612 0.214 0 0.479 0.616 0.388\n(11, 8) 0 0.214 0 0 0.1 1 0.424\n(12, 10) 0 0.214 0 0 0.1 1 0.424\nTable 1: Beliefs against the overlaps detected between the messages of I1 and I2\nThe beliefs in the absence of overlaps between the above messages are shown in Table\n1 and were computed after setting the parameters \u03b11, \u03b12, \u03b13, \u03b14, \u03b15, \u03b16 and bt to 0.4,\n0.1, 0.2, 0.1, 0.2, 0.4, and 0.65, respectively. The rows of the table designate the above\npairs of messages by using the numbers that indicate the order of their dispatch in each\ndiagram. For example, the overlapping messages 11:getText()and\n8:getText()are  signified in Table 1 as the pair (11, 8).\nThe values selected for the parameters \u03b11\u2212\u03b16 in this example were empirically\ndetermined after considering models that incorporated generalisation graphs and\nobject interactions specified at varying degrees of completeness and elaboration.\nReconciliation+ assumes that designers should decide which are the appropriate values\nfor the parameters \u03b11\u2212\u03b16 and bt. These decisions should be based on an assessment of\nhow accurate is as an indicator of overlaps each of the criteria that underpin the belief\nfunctions b1\u2212b6. This assessment can be formed based on the form and level of\nelaboration of different parts of the involved design model(s). If a model uses no\n13\nstereotypes, for instance, \u03b14 should be set to 0. Similarly, for models that do not\nincorporate elaborate class generalisation graphs \u03b12 should be set to a low value.\n2.4 Properties of the belief functions\nAs proved in [21], the functions b1\u2212b6 are all distance metrics and satisfy the axioms\nof Dempster-Shafer basic probability assignments [19]. The functional form of b0 is\nderived from the combination of the belief functions b1, \u2026,b6 using the rule of the\northogonal sum of the Dempster-Shafer theory, and measures the belief that is jointly\ncommitted to \u00acov(mi,mj) by b1\u2212b6. b0 is also a distance metric (see [21] for a proof).\nThese characteristics of b0 guarantee the following intuitive properties for its outputs:\n\u008c for any three messages mi, mj and mk we have, due to the triangularity of distance\nmetrics, that: b0(\u00acov(mi,mk)) \u2264 b0(\u00acov(mi,mj)) + b0(\u00acov (mj,mk))\n\u008c for any two messages mi and mj we have, due to the symmetry of distance metrics,\nthat: b0(\u00acov(mi,mj)) = b0(\u00acov(mj,mi))\n\u008c for any two messages mi and mj we have, due to axiomatic foundation of\nDempster-Shafer basic probability assignments [19], that: b0(\u00acov(mi,mj) \u2227\nov(mj,mi)) = 0\n3 The Reconciliation+ process: specification and\nenactment\nAs we discussed in Section 1, Reconciliation+ guides software designers through the\nactivity of reconciling their models by enacting a built-in process model. This model\nspecifies consistency rules that may be checked against overlapping messages and\nalternative ways of handling violations of these rules. In this section, we introduce the\nscheme that is used by the method to specify this process model, and the mechanism\nthat is used to enact it.\n3.1 A UML profile for specifying reconciliation processes\nThe process of Reconciliation+ is specified as a graph of contexts following a\ndecision-oriented approach to software process modelling [11]. A context represents a\ndecision that may be taken in a given situation. This situation is specified as a\ncondition over the state of the software models which are being manipulated by the\nprocess (i.e., the interaction diagrams which are being reconciled in the case of\nReconciliation+). Contexts are distinguished into:\n(1) executable contexts \u2212 these are contexts which represent decisions to take actions\nthat change the state of the software model;\n(2) plan contexts \u2212 these are contexts which represent decisions that can be realised by\na set of sub-decisions which must be made in a specific order; and\n14\n(3) choice contexts \u2212 these are contexts which represent decisions that may be realised\nby two or more other alternative decisions.\nFigure 3: A UML profile for specifying Reconciliation+ processes\nThe process models that can be formulated using this process modelling approach are\nessentially AND\/OR graphs of decisions which are guarded by specific conditions.\nFigure 3 presents a UML profile that we have defined for specifying model\nreconciliation processes in UML using the contextual process modelling approach\ndescribed above5.\nProfiles in UML are user-defined extensions of the meta-model of the language which\nare introduced to support the construction of models for specific purposes and\ndomains. Typically, a UML profile consists of: (i) a set of stereotypes that define\nadditional kinds of modelling elements which are required to construct models for the\nparticular domain, (ii) tag definitions that introduce additional meta-attributes for the\nmodel elements that may be classified under the stereotypes of the profile, and (iii)\nconstraints which are associated with the stereotypes of the profile and apply to all the\nelements classified under them [9].\nThe Reconciliation+ process specification profile that we have developed is\nrepresented by the UML class diagram shown in Figure 3. This diagram has been\nconstructed according to the following representation conventions:\n                                                          \n5 The introduction of a UML profile for the specification of the reconciliation processes of our method\nwas motivated by the need to have both software models and the processes that reconcile them\nexpressed in a single representational framework as this would facilitate the implementation of tool\nsupport for the method (see Section 6).\nInternalActionContext\nInternal\n1..1\n1..*\n+executes\nActionOperation\n1..1\n+operation\n0..1\norder\n+next\nModificationOperation\nfeature : String\nelementtype : String ExternalAction\naction_script : String\nExternalActionContext\n+executes\nExecutableContext\nPlanContext ChoiceContext\n1..1\n+continueFrom\nSituation\nUnarySetOperation\nModelElement\nelement_type : String\nContext\n+descendant\n0..*\n1..*\n+choiceContext\n+option\nalternatives\n1..1+situation\nBinarySetOperation\nQueryingSetOperation\nopname : String\n1..1+operation\n+situation\nSaveOperation\nwithname : String\ninpackage : String\nAddOperation\nDeleteOperation\nModelElementSet\n+arg1\n0..*\n+element\n+validFor\n+arg2 +arg1+result\n+saves\n+adds\n+deletes\nUpdateOperation\nnewvalue : String\nConsistencyCheckContext\nInconsistencyHandlingContext\n15\n(i) Classes represent the stereotypes of the profile. The class ChoiceContext,\nfor example, designates the stereotype that represents choice contexts in the\nprocess modelling approach outlined above.\n(ii) A named association end in Figure 3 designates a tag defined for the stereotype\nthat is represented by the class that is attached to the opposite end of the relevant\nassociation. For example, situation is a tag defined for the stereotype\nContext. The type of this tag is the stereotype Situation and its\nmultiplicity is 1..1.\n(iii) An attribute in Figure 3 designates a tag defined for the stereotype that is\nrepresented by the class incorporating it. Attributes represent tags whose type is\na data type. For example, feature is a tag defined for the stereotype\nModificationOperation whose type is String.\n(iv) A generalisation relation in Figure 3 designates a generalisation relation between\nthe stereotypes represented by the classes that it connects. For example,\nChoiceContext is a special kind of Context.\nAs shown in Figure 3, our profile, includes stereotypes that represent the basic\nconstructs for specifying reconciliation processes, including contexts, situations and\nactions.\nFigure 4: Part of the Reconciliation+ process model\nIdentifyMessagesWithoutCounterparts\n(from Action_IdentifyMessagesWithoutCounterparts)\n<<InternalAction>>\n?NonIdenticalActivations\n(from Sit_?InconsistentActivations)\n<<Situation>>\nCheck_For_Messages_Without_Counterparts_Dispatched_By\n(from Contexts)\n<<Consis tencyCheckContext>>\n+executes\n?OverlapMorphismExists\n(from Situations)\n<<Situation>>\nNoExtraConditions\n<<Situation>>\n+situation\nCallOverlapDetector\naction_script = c:\\research\\reconciliation\\s im ilarity\\dsd2_v2_4.ebs\n<<ExternalAction>>\n?DispatchedWithoutCounterpart\n(from Sit_?DispatchedByMes2WithoutCounterparts)\n<<Situation>>\nReconcile_Non_Identical_Activations_Of\n<<ChoiceContext>>\n+situation\n+option\n+continueFrom\nRecord_Message_Without_Counterpart\n(from Contexts)\n<<Incons is tencyHandlingContext>>+situation\nReconcile_Overlapping_Messages_In\n<<ChoiceContext>>\n+situation\n+option\nFind_Overlaps_Between_Sequence_Diagrams_In\n<<ExecutableContext>>\n+situation\n+executes\nHandle_Message_Without_Counterpart\n(from Contexts)\n<<ChoiceContext>>\n+situation\n+option\n+option\nAddMessage\n(from Action_AddMessage)\n<<InternalAction>>\nReconcile_Sequence_Diagrams_In\n<<ChoiceContext>>\n+option+option\n+continueFrom\nAdd_Counterpart_For\n(from Contexts)\n<<Incons is tencyHandlingContext>>\n+option\n+executes\n+continueFrom\n?SameOperation\n(from Sit_?SameOOperation)\n<<Situation>>\n+situation\n16\nA part of the Reconciliation+ process model that is specified according to the above\nprofile is shown in Figure 4. This part includes, for example, the choice context\nReconcile_Overlapping_Messages_In which represents the decision to\nstart the process of reconciling overlapping messages. The situation of this context,\n?OverlapMorphismExists, checks whether an overlap morphism between the\ninteraction diagrams to be reconciled has been identified. Thus, the context\nReconcile_Overlapping_Messages_In can be selected only if the overlaps\nbetween two interaction models have been identified.\n3.2 Specification of situations\nIn Reconciliation+, a situation is specified as a query defined by an ordered sequence\nof querying set operations. A querying set operation is either a\nUnarySetOperation or a BinarySetOperation.\nUnary set operations are used to retrieve elements of a UML model which are\nassociated with a given element e of it via any of the different kinds of associations or\nattributes defined for the type of e. A unary set operation is associated with two sets:\nthe arg1 set and the result set. The former set includes all the elements of a UML\nmodel that the operation should be applied to.  The latter set is used to store the union\nof the elements which are retrieved for each of the elements of arg1 following the\napplication of the operation. An example of a unary set operation is the operation\nimwnc-o2 in Figure 6. This operation is stereotyped as a GetActivation\noperation, that is a unary set operation which retrieves the messages which are directly\ndispatched by the messages which belong to its arg1 set. Additional examples of\nunary set operations are given in Section 4.\nBinary set operations are associated with three sets: the arg1, arg2 and result\nset. There are three different types of such operations in our process specification\nprofile for computing the union, intersection and set-difference of given sets. Similarly\nto unary operations, the result of a binary set operation is saved in its result set. An\nexample of a binary set operation is the operation imwnc-o7 in Figure 6. This\noperation is stereotyped as a SetDifference operation and, therefore, it computes\nthe set difference of the sets of messages imwnc-o6-s1 and imwnc-o4-s1 (i.e.,\nimwnc-o6-s1 \u2212 imwnc-o4-s1) and inserts the elements of this set difference in\nimwnc-o7-s1.\nThe operations that define the query of a situation s are ordered through the\nassociation order6 (see Figure 3) and may take as an argument any of the sets which\nare generated by operations preceding them in s. A situation is satisfied if the result\nset of the last of its operations is not empty. Examples of specifications of situations\nare given in Section 5.\n                                                          \n6 The association end next of this association denotes the next operation in a local operation\nsequence.\n17\n3.3 Specification of actions\nIn our process specification profile, each executable context must have an action that\ncan be either an external or internal action (see the action stereotypes\nExternalAction and InternalAction in Figure 3).\nExternal actions are used to specify the invocation of external tools during the\nenactment of a Reconciliation+ process. An example of an external action is the action\nCallOverlapDetector in the process model of Figure 4. This action is associated\nwith the context Find_Overlaps_Between_Sequence_Diagrams_In and is\nexecuted when this context is selected. The execution of this action invokes the\noverlap detection tool of Reconciliation+ (a pointer to the executable file of this tool is\nspecified as the value of the attribute action_script of the action as shown in\nFigure 4).\nInternal actions are used to specify consistency rules and ways of handling\ninconsistencies. These actions are specified as sequences of action operations. An\naction operation may be a querying, model modification, or save operation. Querying\noperations are the same as those used in the specification of situations. Modification\noperations are operations which are used to modify the state of the software models\nbeing manipulated by the process. Save operations are used to store the results of\nquerying operations in the trace of the enactment of a process model so as to make\nthem available in subsequent stages of this enactment. Action operations are ordered in\ninternal actions and executed similarly to sequences of querying operations in\nsituations. Examples of specifications of internal actions and the different types of\noperations that may be used in them are given in Sections 4 and 5.\n3.4 Process enactment\nThe Reconciliation+ process model is enacted by an engine which functions as a\nmodel interpreter [13]. The algorithm underpinning the operation of this engine is\nspecified in Figure 5. According to this algorithm, the enactment of a process model\nstarts from the root context of the process model (a process model must have a single\nroot context that should be a choice context). The situation of the root context of a\nprocess model (and any other context that is encountered as the enactment engine\ntraverses it) is evaluated by executing the set querying operations that define it. If the\nset which results from the execution of the last of these operations (called situation\nset) is not empty, the situation of the context is considered to have been satisfied. In\nthis case, the enactment engine generates different possible decisions from the context,\none for each of the elements in the situation set.\nMore specifically, a decision is defined as a pair:\n<contexti, situation_set_elementj>\nwhere\n\u008c contexti\n \nis the context whose situation is satisfied, and\n18\n\u008c situation_set_elementj\n \nis an element of the situation set of contexti.\nFigure 5: Process enactment algorithm\nThe situation ?NonIdenticalActivations in the process model of Figure 4, for\nexample, retrieves all the pairs of overlapping messages of two interaction diagrams\nthat have non identical activations. In the case of the interaction diagrams I1 and I2,\nthese pairs of messages are:\n(2:new(o1), 1:new(m))\n(10:actionPerformed(ActionEvent), 7:actionPerformed(ActionEvent))\nThus, the possible decisions that may be generated from the context\nReconcile_Non_Identical_Activations_Of of this situation when\nreconciling I1 and I2 are:\nAlgorithm: EnactProcess (CurContext, Argument, Trace)\nIn: CurContext\nArgument \/\/ model element that the input Context was instantiated for\nIn\/Out: Trace \/\/ list of pairs <context, argument>\nIf CurContext \u2260 nil  Then\nEvaluateSituation(CurContext.Situation, Argument, ResultSet);\nFor each model element e in ResultSet Do\nOptions = Options \u222a {< CurContext, e >}\nEnd For\nOptions = Options \u222a {< Tactical Guidance, nil >} \u222a {< Abort Process, nil >};\n\/\/ Options is a set of pairs of the form <context, argument>\nIf Options is not empty Then\nSelectedOption = User\u2019s selection from available options;\nIf SelectedOption.context = Tactical Guidance Then\nLastChoice = last <context, argument> pair in Trace before CurContext whose context\nis a choice context; \/\/ if no such context exists LastChoice becomes <nil, nil>\nNextContext = LastChoice.context;\nNextArgument = LastChoice.argument;\nEnactProcess(NextContext, NextArgument, Trace);\nElse If SelectedOption.context = Abort Process Then\nNextContext = nil;\nNextArgument = nil;\nEnactProcess(NextContext, NextArgument, Trace);\nElse\ninsert(SelectedOption.context, SelectedOption.argument, Trace);\nIf SelectedOption.context is an executable context Then\nExecute(SelectedOption.context);\nNextContext = SelectedOption.context.continueFrom;\nNextContextAncestor = last <context, argument> pair in Trace before NextContext;\nNextArgument = NextContextAncestor.argument;\nEnactProcess(NextContext, NextArgument, Trace);\nElse \/\/ SelectedOption.context is a choice context\nAlternatives = CurContext.alternatives\nFor each context c in Alternatives Do\nEvaluateSituation(c, SelectedOption.argument, ResultSet);\nFor each model element e in ResultSet Do\nOptions = Options \u222a {< c, e >}\nEnd For\nEnd For\nOptions = Options \u222a {<TacticalGuidance,nil>} \u222a {<AbortProcess,nil>};\nSelectedOption = User\u2019s selection from available options\nEnactProcess(SelectedOption.context, SelectedOption.argument, Trace);\nEnd If\nEnd If\nEnd If\nEnd If\n19\n(1) <Reconcile_Non_Identical_Activations_Of, (2:new(o1),\n1:new(m))>\n(2) <Reconcile_Non_Identical_Activations_Of,\n(10:actionPerformed(ActionEvent),\n7:actionPerformed(ActionEvent)) >\nA designer may select one of the different possible decisions which are generated from\na context, ask for tactical guidance or terminate the process. If a decision\n<contexti,situation_set_elementj> is selected, it is recorded in the trace\nof the enacted process model and subsequently:\n\u2022 If contexti is a choice context, the enactment engine: (1) retrieves the option\ncontexts associated with it, (2) inserts the situation_set_elementj in the\narg1 set of the initial querying set operation of each of these contexts, (3) evaluates\nthe situation of each of these contexts, (4) generates the possible decisions for each\nof these contexts, and (5) prompts the designer to make a new selection.\n\u2022 If contexti is an external action context, the enactment engine executes the file\nspecified by the attribute action_script of it and continues the enactment of the\nprocess model from the context associated with contexti\n \nvia the association end\ncontinueFrom (see Figure 3).\n\u2022 If contexti is an internal action context, the enactment engine executes the\nsequence of the operations in its internal action and continues the enactment of the\nprocess model as in the case of external action contexts.7\nIn cases where the designer asks for tactical guidance, the enactment engine identifies\nthe decision before the last decision recorded in the process trace and resumes\nexecution from the context of it. The designer may also abort the execution of the\nprocess model at any point.\nIn the following, we describe how the process specification profile of our method can\nbe used to specify consistency rules and actions to handle their violations.\n4 Detection of inconsistencies\nIn Reconciliation+, a consistency rule is defined as an internal action of a consistency\ncheck context (i.e., a special kind of executable contexts as shown in Figure 3). This\naction is essentially a query which retrieves the model elements that violate the\nconditions required by the rule. Thus, the specification of consistency rules is\nprocedural. The consistency check context which incorporates the internal action that\ndefines a consistency rule represents the decision to check the rule. It also specifies the\nconditions under which this decision may be made. These conditions are specified by\nthe situation of the context.\n                                                          \n7 Plan contexts are not used in the current process model of Reconciliation+ and therefore the\ndescription of their enactment is beyond the scope of this paper.\n20\nFurthermore, the internal actions of consistency check contexts are restricted not to\ninclude any modification operations. This restriction guarantees that the execution of a\nconsistency rule will not modify the contents of the underlying models. Also, the last\noperation of such actions must be a save operation that records the model elements\nwhich violate the rules (see stereotype SaveOperation in Figure 3) in order to\nmake them available to subsequent stages of the enactment of the reconciliation\nprocess.\nFigure 6 shows the internal action IdentifyMessagesWithoutCounterparts\nthat defines the consistency rule CR1. As discussed in Section 1, CR1 requires that if a\nmessage mi overlaps with a message mj then for each message x activated by mi there\nmust be a message y activated by mj that overlaps with x and vice versa. The\nspecification of this internal action assumes that message overlap relations are\nrepresented by overlap objects in the trace of the Reconcilication+ process which point\nto the overlapping messages and store the beliefs in their overlap (see the object\n10:actionPerformed(ActionEvent)\u21947:actionPerformed(ActionEvent)\nin Figure 7).\nFigure 6: Specification of the internal action IdentifyMessagesWithoutCounterparts\nTo implement CR1, IdentifyMessagesWithoutCounterparts retrieves the\nmessages in the activations of two overlapping messages which do not have\noverlapping counterparts through the execution of the following operations:\nIdentifyM essagesWithoutCounterparts\n<<InternalAction>>\nimwnc-o1-s1\n<<ModelElementSet>>\nimwnc-o5\nendname = message1\n<<GetEndClassesWithName>>\n+arg1\nimwnc-o5-s1\n<<ModelElementSet>>+result\nimwnc-o1-s2\n<<ModelElementSet>>\nimwnc-o1\nendname = message2\n<<GetEndClassesWithName>>\n+operation\n+result\n+arg1\ninwnc-o3-s1\n<<ModelElementSet>>\nimwnc-o4\nendname = message1\n<<GetEndClassesWithName>>\n+arg1\n+next\nimwnc-o6\n<<GetActivation>>\n+next +arg1\nimwnc-o6-s1\n<<ModelElementSet>>\n+result\nimwnc-o4-s1\n<<ModelElementSet>>\n+result\nimwnc-o8-s1\n<<ModelElementSet>>\nimwnc-o8\nendname = mapping\n<<GetEndClassesWithName>>\n+arg1\n+result\nimwnc-o2\n<<GetActivation>> +arg1\n+next\nimwnc-o3\nendname = mapping\n<<GetEndClassesWithName>>\n+result\n+next\n+next\nimwnc-o7\n<<SetDifference>>\n+next +arg1\n+next\n+arg2 imwnc-o9\nendname = message2\n<<GetEndClassesWithName>>\n+arg1\n+next\nimwnc-o9-s1\n<<ModelElementSet>>\n+result\nimwnc-o2-s2\n<<ModelElementSet>>\n+result\n+arg1\nimwnc-o7-s1\n<<ModelElementSet>>\n+result\nimwnc-o10\n<<SetDifference>>\n+next\n+arg2\n+arg1\nimwnc-o12\nwithname : type = DMWNC_mes_set\ninpackage : type = ExecutionClasses\n<<SaveOperation>>\nimwnc-o11-s1\n+saves\nimwnc-o10-s1\n<<ModelElementSet>>\n+result\nimwnc-o11\n<<SetUnion>>\n+arg1\n+next\n+next\n+result\n+arg2\n21\n(1) imwnc-o18 \u2212 this operation retrieves one of the messages that is pointed to by\nthe selected overlap object (message2).\n(2) imwnc-o2 \u2212 this is an operation which, by virtue of its stereotype (i.e., a\nGetActivation operation), finds the messages which are directly dispatched\nby a message (message2 of the selected overlap object in this case).\n(3) imwnc-o3 and imwnc-o4 \u2212 these operations find the messages that overlap\nwith the messages dispatched by message2 and inserts them in set imwnc-o4-\ns1.\n(4) imwnc-o5 and imwnc-o6 \u2212 these operations find the messages which are\ndirectly dispatched by the other message that is pointed to by the selected overlap\nobject (i.e., message1) and insert them in set imwnc-o6-s1.\n(5) imwnc-o7 \u2212 this operation finds the messages which are dispatched by\nmessage1 and have no counterparts in the set of messages dispatched by\nmessage2 by computing the difference between set imwnc-o6-s1 and set\nimwnc-o4-s1.\n(6) imwnc-o8, imwnc-o9, and imwnc-o10 \u2212 similarly to steps 4-5 these\noperations identify the messages which are dispatched by message2 and have\nno counterparts in the set of messages dispatched by message1.\n(7) imwnc-o11 \u2212 this operation takes the union of the messages which are\ndispatched by message1 and message2 and have no overlapping\ncounterparts.\n(8) imwnc-o12 \u2212 this operation saves the messages which are dispatched by\nmessage1 and message2 and have no overlapping counterparts as elements\nof the set DMWNC_mes_set.\nFigure 7: Overlap objects - objects that represent overlap relations\nIdentifyMessagesWithoutCounterparts is specified as the internal action\nof the consistency check context\n                                                          \n8 imwnc-o1 is an operation stereotyped as GetEndClassesWithName. Operations of this\nstereotype retrieve the objects which are related to the elements in their arg1 set via the association\nend named by their attribute endname.\n39969BC20051\ntype : string = SequenceDiagram\nOwnerNam e : string = 39EEDBEC01B3\n3996B7680213\nOw nerNam e : string = 39969BC20051\ntype : string = Message\n10:actionPerformed(ActionEvent)<->7:actionPerformed(ActionEvent)_(a)\ntype : string = Mapping\nused_by_sim Analyser : boolean = True\nused_by_overlapAssesser : boolean\nb1 = 0\nb4 = 0\nb3 = 0.2142857\nb2 = 0.6129032\nb5 = 0.4798658\nb6 = 0.7238937\nBo = 0.388\n+message2\n+mapping\n3AF70CF4028E\nOw nerNam e : string = 39969BAD00F1\ntype : string = Message\n+mapping\n+message1\n39969BAD00F1\nOwnerNam e : string = 39EECE560266\ntype : string = SequenceDiagram\nOptimalM orphism\ntype : string = Morphism\ndsd = 0.7402988\n+mapping\n+diagram1\n+diagram2\n22\nCheck_For_Messages_Without_Counterparts_Dispatched_By (see\nFigure 4). Thus, to check the consistency rule CR1 against a pair of overlapping\nmessages, a designer has to decide to apply this context to this pair. Note, however,\nthat Check_For_Messages_Without_Counterparts_Dispatched_By\nmay be applied only in certain parts of the reconciliation process and if the situation\nassociated with it is satisfied. More specifically, according to the process model of\nFigure 4, this context can be applied to a pair of overlapping messages only after a\ndesigner has selected:\n1) the executable context\nFind_Overlaps_Between_Sequence_Diagrams_In to detect overlaps\nin the interaction diagrams to be reconciled;\n2) the choice context Reconcile_Overlapping_Messages_In to start the\nreconciliation of the overlapping messages detected in these interaction\ndiagrams; and\n3) the choice context Reconcile_Non_Identical_Activations_Of to\nstart the reconciliation of the overlapping messages with the non-identical\nactivations.\nThe selection and application of the consistency check context\nCheck_For_Messages_Without_Counterparts_Dispatched_By to the\noverlap object of  Figure 7 (that is the object\n10:actionPerformed(ActionEvent)\u21947:actionPerformed(ActionE\nvent)) leads to the execution of the internal action\nIdentifyMessagesWithoutCounterparts which retrieves and saves in the\nprocess trace the following set of messages without overlapping counterparts:\nDMWNC_mes_set = {9:formulateQuery()}\n5 Handling inconsistencies\nThe ways of handling inconsistencies in Reconciliation+ are specified as internal\nactions of a special kind of executable contexts, called inconsistency handling contexts\n(see stereotype InconsistencyHandlingContext in Figure 3).\nA consistency rule is associated with one or more inconsistency handling contexts\nwhich specify alternative ways of handling its violations. These contexts are grouped\nas options of a choice context which, by virtue of the definition of its situation,\nbecomes selectable only if there is a record of violations of the particular consistency\nrule in the trace of the reconciliation process. The alternative inconsistency handling\ncontexts which are available as options of this context are associated with situations\nwhich define the particular conditions under which the alternative inconsistency\nhandling options may be applied.\nIn the following, we discuss how the situations and the actions of inconsistency\nhandling contexts can be specified using the process modelling profile of\n23\nReconciliation+. Our discussion is based on inconsistency handling contexts that the\nprocess model of Reconciliation+ incorporates to deal with inconsistencies which arise\nas violations of the rule CR1.\nFigure 8: Specification of situation ?DispatchedWithoutCounterparts\nA violation of CR1 can be handled in different ways. One possibility, for instance, is\nto delete the messages without counterparts from the relevant message activation. A\nsecond possibility is to add the missing messages in the relevant activation. A third\npossibility is to modify the software models so that overlapping messages that\ndispatch messages without counterparts will no longer be considered as overlapping\nmessages. A fourth possibility is to record the inconsistency and postpone its\nresolution.\nThe process model shown in Figure 4 includes the contexts\nAdd_Counterpart_For and Record_Message_Without_Counterpart,\nwhich correspond to the 2nd and 4th of the above options. As shown in Figure 4, these\ncontexts are grouped as options of the choice context\nHandle_Message_With_No_Counterpart.  The latter context, due to the\ndefinition of its situation  ?DispatchedWithoutCounterparts (see Figure 8),\nbecomes available only if there are messages that violate CR1. This is because,\naccording to Figure 8, ?DispatchedWithoutCounterparts is satisfied only if\nthere is a non empty set called DMWNC_mes_set that has as elements the messages\nin the activations of two overlapping messages that violate CR19 (recall from Section\n4 that DMWNC_mes_set is generated by the action of the context\nCheck_For_Messages_Without_Counterparts_Dispatched_By).\nHandle_Message_Without_Counterpart can be applied to any of the\nmessages in DMWNC_mes_set. These alternative applications are generated as\ndecisions by the process enactment engine as described in Section 3.4 and are\nproposed to the designer. In the case of the overlap relation between the messages\n10:actionPerformed(ActionPerformed) and\n                                                          \n9 The set DMWNC_mes_set is represented as an object that is associated with all its elements and\nexists in a special package called ExecutionClasses of the repository of the Reconciliation+ toolkit.\nActivationsOfMes2WithNoCounterparts\n<<ModelElementSet>>\ndbm2nc-o5-s1\n<<ModelElementSet>>\ndbm2nc-o6\nendname = element\n<<GetEndClassesWithName>>\n+arg1\n+result\ndbm2nc-o4-s1\n<<ModelElementSet>>\ndbm2nc-o5\nfeature = name\nroperator = equal_to\nvalue = DMWNC_mes2_set\nelementtype = Class\n<<SelectOperation>>\n+arg1\n+result\n+next\ndbm2nc-o3-s1\n<<ModelElementSet>>\ndbm2nc-o4\n<<GetPackageClasses>>\n+arg1\n+result\n+next\ndbm2nc-o2-s1\n<<ModelElementSet>>\ndbm2nc-o3\nfeature = name\nroperator = equal_to\nvalue = ExecutionClasses\nelementtype = Package\n<<SelectOperation>>\n+arg1\n+result\n+next\n?DispatchedWithoutCounterpart\n<<Situation>>\ndbm2nc-o2\n<<GetModelPackages>> +result\n+next\ndbm2nc-o1-s1\n<<ModelElementSet>>\ndbm2nc-o1\n<<SetUnion>>\n+operation\n+next\n+arg1\n+arg2\n+result\n24\n7:actionPerformed(ActionEvent) of the interaction diagrams I1 and I2 the\nonly decision generated from Handle_ Message_Without_Counterpart is:\n<Handle_Message_Without_Counterpart, 9:formulateQuery()>\nFigure 9: Specification of situation ?SameOperation\nIf this decision is selected, the process enactment engine checks the situations of the\ntwo alternative contexts for handling this particular kind of inconsistencies, namely\nRecord_Message_Without_Counterpart and Add_Counterpart_For\nto establish if they can be applied in the case of 9:formulateQuery() .\nIf applicable, Record_Message_Without_Counterpart can be activated to\nmake a persistent record of the inconsistency (i.e., a record saved after the end of the\nreconciliation process). This context can be selected under any circumstances as its\nsituation contains no conditions in addition to those set by its ancestor context in the\nprocess model.\nAdd_Counterpart_For can be selected to create a copy of a message that does\nnot have an overlapping counterpart and add it to the activation of the message that\noverlaps with its activator. Note, however, that this way of resolving the inconsistency\nmakes sense only if the overlapping messages that gave rise to it indeed invoke the\nsame operation in the object model. Thus, the situation of Add_Counterpart_For\n(i.e., the situation ?SameOperation shown in Figure 9) is specified so as to check\nwhether this is the case. More specifically, the unary set operation so-op2 in\n?SameOperation retrieves the activator m1 of the message that caused the\nviolation of CR1  (i.e., 9:formulateQuery()in our example) and the message m2\nthat m1 overlaps with and checks if m1 and m2 have been declared in the models to\ninvoke the same operation (the operations invoked by m1 and m2 are identified\nthrough the evaluation of the path expressions\nactivator.mapping.message1.action.operation and\nactivator.mapping.message2.action.operation10). If that is the case,\n                                                          \n10 The evaluation of the sub-paths activator.mapping.message1(2)in these path expressions\nlocate the overlapping messages in the activations of which the message without the counterpart was\nencountered. These sub-paths assume the representation of overlap morphisms and relations by the\ntool that we have built to support Reconciliation+ (shown in Figure 7). The remaining sub-paths\n?SameOperation\n<<Situation>>\nso-op2-s1\n<<ModelElementSet>>\nso-op2-s2\n<<ModelElementSet>>\nso-op2\nfeature = activator.mapping.message1.action.operation\nroperator = equal_to\nvalue = activator.mapping.message2.action.operation\nelementtype = message\n<<SelectOperation>>\n+arg1\n+result\nso-op1-s1\n<<ModelElementSet>>\nso-op1\n<<SetUnion>>\n+operation\n+result\n+next\n+arg1\n+arg2\n25\n?SameOperation is satisfied and, therefore, Add_Counterpart_For can be\nselected for the message 9:formulateQuery().\nFigure 10: Specification of action AddMessage\nThe creation of a copy of this message is the result of executing the internal action\nAddMessage of Add_Counterpart_For. The specification of this action is\nshown in Figure 10. According to this specification, to execute AddMessage, the\nprocess enactment engine first locates the interaction diagram of the overlapping\nmessage of the activator of the message that Add_Counterpart_For was\nselected for (i.e., the diagram I1 in our example) by executing the operations ama-o2\nto ama-o6, and then adds  to the set of the messages of this diagram a copy of this\nmessage by executing the operation ama-o7.\n6 Tool support\nReconciliation+ is supported by a toolkit which incorporates: (a) a tool that detects\noverlaps between object interaction models, and (b) an engine which enacts the\nprocess model of the method to drive the activity of reconciling interaction diagrams.\nThis toolkit has been implemented as an add-on utility for Rational Rose (a CASE tool\nsupporting UML) using the API of this tool [21].\nThe architecture of the Reconciliation+ toolkit is shown in Figure 11. As shown in this\nfigure, the toolkit stores the models to be reconciled as collections of UML class\nmodels and sequence diagrams in a model repository that is accessible through the\nAPI of Rose. The overlap morphisms which are detected by the overlap detection tool,\n                                                                                                                                                                      \n(*.action.operation) assume the standard representation for UML models that is established\nby the UML meta-model [9].\n+resultama-o2-s1\n<<ModelElementSet>>\nAddMessage\n<<InternalAction>>\nama-o2\n<<GetModelPackages>>\nama-o3-s1\n<<ModelElementSet>>ama-o3\nfeature = name\nroperator = equal_to\nvalue = ExecutionClasses\nelementtype = Package\n<<SelectOperation>>\n+next\n+arg1\n+result\nama-o1\nopname : type = SetUnion\n<<SetUnion>>\n+operation\n+next\nama-o4\n<<GetPackageClasses>>\n+arg1\n+next ama-o4-s1\n<<ModelElementSet>>\n+result\nama-o1-s1\n<<ModelElementSet>>+arg1\n+arg2\n+result\nama-o5\nfeature = name\nroperator = equal_to\nvalue = OptimalMorphism\nelementtype = Class\n<<SelectOperation>>\n+next\n+arg1\nama-o6-s1\n<<ModelElementSet>>\nama-o7\nfeature = message\nelementtype = SequenceDiagram\n<<AddOperation>>\n+adds\n+modifies\nama-o5-s1\n<<ModelElementSet>>\n+result\nama-o6\nendname = diagram1\n<<GetEndClassesWithName>>\n+next\n+result\n+next\n+arg1\n26\nthe process model of the method, and the trace of the enactment of this model are also\nrepresented and stored as UML object models in the same repository.\nFigure 11: Architecture of the Reconciliation+ toolkit\nFigure 12 shows a snapshot of the overlap detection tool following its invocation to\nidentify overlaps between the interaction diagrams of Figure 1.\nFigure 12: Overlap Detector \u2212 detection of overlap morphism between I1 and I2\nFigure 13 shows a snapshot of the process enactment engine of the toolkit. This\nsnapshot shows a point in the enactment of the Reconciliation + process model where\nthe consistency check context\nToolkit\nProcess Enactment Engine\nProcess\nModel(s)\nUML\nModel(s)\nProcess Enactment\nTrace\nOverlap Detection Tool\nRose model repository\nRose API\n27\nCheck_For_Messages_Without_Counterparts_Dispatched_By may\nbe selected to check for violations of the rule CR1 by messages in the activations of\nthe overlapping pair of messages: 10:actionPerformed(ActionEvent), and\n7:actionPerformed(ActionEvent) of the diagrams of Figure 1. As shown in\nFigure 13, the process enactment engine gives a designer the options of: (a) applying\nany of the contexts which become available at the current point in the enactment of the\nprocess model (see list Next Decision), and (b) asking for tactical guidance or\nequivalently go back to the previous decision point in the enactment of the process\nmodel. Note also that the enactment engine keeps a record of the decisions that have\nbeen made up to the current point in the enactment of a process (process trace) and\npresents them to the designer (see the list Decisions made so far).\nFigure 13: Process Enactment Engine\n7 Case study\nTo evaluate Reconciliation+ we have carried out a case study. The objectives of this\nstudy were to:\n(i) measure the performance of the overlap detection algorithm that is deployed by\nthe method in terms of recall (i.e., the ability to detect overlap relations that\nhumans would identify), and precision (i.e., the ability to detect correct overlap\nrelations);\n(ii) assess the sensitivity of the overlap detection algorithm against the granularity of\nthe models it is applied to; and\n28\n(iii) investigate the diversity of the ways that may be used to handle inconsistencies,\nand assess whether the process model of the method could support the\nspecification of inconsistency handling contexts to implement these ways.\nIn this case study, we used 5 UML models built by MSc students at City University.\nThese models had been constructed to specify a system supporting banking\ntransactions through the use of ATM machines.\n7.1 Recall and precision of overlap detection algorithm\nTo evaluate the recall and precision of the overlap detection algorithm of\nReconciliation+, we performed 50 comparisons of pairs of UML interaction diagrams\ndrawn from the models of our case study.\nFollowing a manual identification of overlap relations between these interaction\ndiagrams, we detected overlap relations between them using the algorithm specified in\nSection 2, and subsequently measured the recall and the precision of the algorithm\naccording to the following formulas:\nPrecision = | AOij \u2229 MOij|     and     Recall =  | AOij \u2229 MOij|\n                  | AOij |                  | MOij|\nwhere\n\u008c AOij is the set of the overlap relations that were detected by the overlap detection\nalgorithm between the messages of two interaction diagrams i and j; and\n\u008c MOij\n \nis the set of the manually identified overlap relations between the messages\nof two interaction diagrams i and j.\nModel | MO \u222a AO | #ID-Pairs Recall Precision\nMean St. Dev. Mean St. Dev.\n1 77 10 1.00 0 1.00 0\n2 60 11 0.86 0.20 0.99 0.03\n3 74 6 0.92 0.20 0.90 0.2\n4 231 15 0.87 0.08 0.98 0.05\n5 87 8 0.91 0.06 1.00 0\nAll 529 50 0.91 0.13 0.98 0.08\nTable 2: Recall and precision of overlap detection algorithm\nTable 2 shows the average and standard deviation of the recall and precision measures\nthat we obtained for pairs of diagrams drawn from each of the five object models used\nin our experiments, and from all of the models (these results were obtained for the\nvalues of parameters \u03b11\u2212\u03b16 and bt used in Section 2.3). It also shows the number of the\npairs of interaction diagrams that were compared in each model (i.e., #ID-Pairs) and\nthe total number of the overlap relations detected by the overlap algorithm and the\noverlap relations that were manually identified between them in each case (i.e., |MO \u222a\nAO|). The object models that we used in our experiments and the overlap relations\nidentified manually by the experts and the overlap detection algorithm are available\nfrom: http:\/\/www.soi.city.ac.uk\/~gespan\/imoosd_case_studies.html\n29\nAs shown in Table 2, the overlap detection algorithm had very high precision (0.98 on\naverage across all models) and relatively high recall (0.91 on average across models).\nAlso there was a low variation in these measures across different pairs of interaction\ndiagrams and models (the standard deviation of the recall and precision measures\nacross all models were 0.13 and 0.07, respectively). Although preliminary, the above\nresults indicate that the overlap detection algorithm has a very low probability of\nproducing false overlaps and is capable of detecting a high proportion of the overlaps\nindicated by human designers.\n7.2 Effect of model granularity on overlap detection\nTo explore the effect of model granularity on our overlap detection algorithm, we also\ncarried out a correlation analysis of the obtained recall and precision measures against\nthe following measures of model granularity:\n(i) the number of classes in a model (#CL) \u2212 this measure was expected to affect the\nbeliefs b3 and b4,\n(ii) the average number of superclasses of a class in a model (#Isa*) \u2212 this measure\nwas expected to affect directly the beliefs b2 and b3 and implicitly b5,\n(iii) the average degree of operation overriding in a model (i.e., the ratio of classes\nwhich inherit an operation but override it \u2212 #OO) \u2212 this measure was expected to\naffect directly the beliefs b1 and implicitly b5, and\n(iv) the average number of dispatched messages in message activations (#AC) \u2212 this\nmeasure was expected to affect the beliefs b6.\nModel #Cl #Isa* #OO #AC\n1 697 0.014 1 3.685\n2 200 0.420 0.305 1.288\n3 55 0.309 0.584 2.722\n4 702 0.017 0.772 1.030\n5 696 0.012 0.696 1.911\nCorrelation Coefficients\nRecall 0.29 \u22120.28 0.76 0.96\nPrecision 0.74 \u22120.74 0.24 \u22120.16\nTable 3: Model granularity measures and correlation with recall and precision\nTable 3 presents the above granularity measures for the five models of our case study\nand their correlation with the recall and precision measures obtained for these models.\nAs shown in the table, recall had strong positive correlations with  #OO and #AC. This\nwas expected as the weights of the d1 and d6 distances, which were directly affected by\n#OO and #AC, in establishing beliefs in overlaps were relatively higher than the\nweights of the other four distances of our algorithm (see values of a1 and a6 in Section\n2.3). The observed negative correlation of recall with the average number of\nsuperclasses (#Isa*) is likely to have been the result of the small number of\nsuperclasses that the senders and receivers of messaged had in the considered models.\nIt should also be noted that only the positive correlation of #AC with recall (i.e., 0.96)\nwas statistically significant (at \u03b1=0.10).\n30\nIn the case of precision, positive correlations were detected only for #CL and #OO and\nnone of the obtained correlations was statistically significant at \u03b1=0.10. This may be\nattributed to the fact that precision was very high across all models and therefore the\ndifferences in model granularity did not have any significant effect on it.\nThe results of the above correlation analysis indicate that the overlap detection\nalgorithm is not over-sensitive to the degree of completeness and elaboration of design\nmodels. This was expected due to the use of six different criteria that focus on\ndifferent parts of software design models for detecting overlaps. Clearly, however, our\nresults are only preliminary and need to be confirmed by additional experiments.\n7.3 Diversity of inconsistency handling options\nThe third objective of our case study was to investigate the diversity of the ways that\nmay be used to handle inconsistencies, and to assess whether the process model of the\nmethod could support the specification of inconsistency handling contexts to\nimplement these ways.  In this part of the study, we selected 4 consistency rules to\ncheck against the overlapping messages that were detected by the overlap detection\nalgorithm in the first part of the study. The selected rules were:\n\u008c CR1 \u2212 this was the rule specified in Sections 1 and 4;\n\u008c CR2 \u2212 this was a rule that required the operations invoked by two overlapping\nmessages to have the same name;\n\u008c CR3 \u2212 this was a rule that required the operations invoked by two overlapping\nmessages to be defined in the same class; and\n\u008c CR4 \u2212 this was a rule that required the operations invoked by two overlapping\nmessages to have the same number and types of parameters.\nThe above rules were selected since they capture the main forms of possible\ndiscrepancies in the specifications of operations which are invoked by overlapping\nmessages.\nCR1 CR2 CR3 CR4\nViolations 40 3 2 23\nNo need to be resolved 10 0 1 9\nNeed to be resolved 29 3 1 14\nAlternative resolutions 6 2 1 4\nTable 4: Inconsistencies and alternative ways of handling them\nTable 4 shows the number of the detected violations of each of these rules, the number\nof the cases where we found that it was necessary to resolve the detected\ninconsistency, and the number of the different alternative ways that we advocated for\nresolving the inconsistencies of the same rule. As it may be seen from the figures of\nthis table,  some diversity was indeed observed in the ways of handling violations of\nthe same rule. However, due to the size of our experiments these results cannot be\ngeneralised. Nevertheless, the case study has given rise to some interesting\nobservations that we discuss in the following.\n31\nMore specifically,\n\u008c In some cases, following the violation of a consistency rule, it was realised that the\noverlap relation detected by the method and checked against the rule was wrong.\nIn such cases, it was not necessary to take any inconsistency resolution action. The\nway that was adopted to handle such inconsistencies was to record them along\nwith an annotation that the overlap relation that gave rise to them were wrong.\n\u008c There were cases, where the violation of a consistency rule should be tolerated as\nthe relevant rule should not be satisfied by particular pairs of overlapping\nmessages. This was, for instance, the case with some of the violations of rule CR1\nin which two overlapping messages were dispatching messages with the same\nsignature but different activations which had not themselves been detected as\noverlapping messages. In these cases, the non overlapping messages were\ninvoking polymorphic operations (i.e., operations defined in different classes with\nthe same signature and different implementations as, for example, the operations\nSearchForm.actionPerformed(e: ActionEvent) and\nDatabaseActionListened.actionPerformed(e: ActionEvent)\nin Figure 2) and  therefore the resolution of the inconsistency was not necessary.\nTo deal with such cases, it is, in principle, possible either to amend the conditions\nof the relevant rule so as to ignore non overlapping messages that invoke\npolymorphic operations, or to add inconsistency handling contexts for the rule that\nignore its violations by such messages. Although both these strategies can be\naccommodated by the method, Reconciliation+ does not incorporate at its current\nstage of development criteria for helping designers to decide which of the two\noptions is more appropriate in specific circumstances.\n\u008c The selection of the best inconsistency handling strategy in a given situation may\ndepend on the satisfiability (or unsatisfiability) of more than one rules. The\nviolation of both rule CR1 and CR2, for instance, in some cases led to the\nrealisation that the overlap relation that gave rise to the inconsistencies was wrong.\nIn these cases, the relevant inconsistencies were ignored. In other cases, however,\nwhere CR3 was violated but CR1 was satisfied the inconsistencies were resolved\nby changing the name of one of the overlapping messages. In Reconciliation+,\ncases like these could be handled by specifying the situations of the inconsistency\nhandling contexts for a specific rule so as to check if the pair of the overlapping\nmessages that violated the rule has also violated another rule.\n8 Related work\nA considerable body of research has been concerned with the problem of detecting\ninconsistencies in software models and documentation. This work has generated\ntechniques for detecting inconsistencies in structured and text-based [1][3][4][12]\nobject-oriented [2][6][15][18] state-based [7][8], and formal software models [5][17].\nSome of the proposed techniques focus on object-oriented models. Glinz [6], for\nexample, has developed a technique that checks behavioural software models\nexpressed as statecharts for deadlocks, reachability and mutual exclusiveness of states.\n32\nCheung et al [2] have developed a technique that checks whether the sequence of the\nexecution of operations that is implied by a UML statechart diagram is compliant with\nthe sequence of the executions of operations implied by a UML sequence diagram.\nZisman et al [18] have developed a consistency link generator which checks whether\nUML software models satisfy specific consistency rules. These rules are expressed in\nXML and the consistency checking is performed using a tool developed using an\nXML development platform. A critical survey of all the above techniques may be\nfound in [16].\n9 Conclusions and further work\nIn this paper, we have presented Reconciliation+, a method that guides designers in\nreconciling object interaction diagrams specified as part of software design models.\nThe method detects overlaps between messages in interaction diagrams, checks\nconsistency rules that overlapping messages must satisfy, and provides ways of\nhandling violations of these rules. The rules and the ways of handling inconsistencies\nare specified as parts of a process model that is enacted by the method to drive the\nreconciliation activity. Reconciliation+ can be applied at the design phase of software\ndevelopment following the specification of, at least, partial object-oriented software\ndesign models defining the basic class structure and interactions of a system. The\nmethod can be used in conjunction with development approaches which require the\ndevelopment of design models prior to implementation and approaches that advocate\nan incremental development of such models and\/or software systems.\nWe have evaluated Reconciliation+ in a case study the objectives of which were to\nmeasure the recall and precision of the overlap detection algorithm deployed by the\nmethod, investigate its sensitivity to variations of model granularity, and investigate\nthe diversity of the strategies that may be needed in  handling inconsistencies. This\ncase study has shown positive preliminary results regarding the recall and precision of\nthe overlap detection algorithm of the method, and has demonstrated some diversity in\nthe nature of inconsistency handling strategies which can be accommodated by the\nmethod. It has also shown that the overlap detection algorithm is not prohibitively\nsensitive to the degree of elaboration and completeness of the models it is applied to.\nThus, Reconciliation+ can be applied to models specified at varying levels of\ncompleteness.\nFurther experimentation is, however, required to confirm these findings. Furthermore,\nit is necessary to evaluate the method against some usability criteria including the\ndifficulty in extending its process model with new consistency rules and ways of\nhandling their violations, as well as with intermediate decisions (choice contexts) to\nguide software designers in selecting amongst alternative inconsistency handling\noptions. Currently, we are evaluating the method along these lines.\nAcknowledgements\nThe work presented in this paper has been partially funded by the EPSRC grant no.\nGR\/M57422.\n33\nReferences\n[1] Boehm B, In H (1996), Identifying Quality Requirements Conflicts, IEEE Software, 25-35.\n[2] Cheung K, Chow K, Cheung T (1998), Consistency Analysis on Lifecycle Model and Interaction Model, Proc.\nof the 7th Int. Conference on Object-Oriented Information Systems, 427-441.\n[3] Easterbrook S (1991), Handling Conflict between Domain Descriptions with Computer-Supported\nNegotiation, Knowledge Acquisition, 3: 255-289.\n[4] Emmerich W, Finkelstein F, Montangero C, Antonelli S, Armitage S (1999), Managing Standards\nCompliance,  IEEE Transactions on Software Engineering, 25(6): 836-851.\n[5] Finkelstein A., Gabbay D, Hunter, A, Kramer, J, and Nuseibeh, B (1994), Inconsistency Handling In Multi-\nPerspective Specifications, IEEE Transactions on Software Engineering, 20(8): 569-578.\n[6] Glinz M (1995), An Integrated Formal Model of Scenarios Based on Statecharts, In Proc. of the 5th European\nSoftware Engineering Conference, LNCS 989, Springer-Verlag, 254-271.\n[7] Heimdahl M.P.E, Leveson N (1996), Completeness and Consistency in Hierarchical State-Based\nRequirements, IEEE Transactions in Software Engineering, 22(6): 363-377.\n[8] Heitmeyer C, Jeffords R, Kiskis D (1996), Automated Consistency Checking Requirements Specifications,\nACM Transactions on Software Engineering and Methodology, 5(3): 231-261.\n[9] OMG, Unified Modeling Language Specification (Action Semantics) \u2212 V. 1.4. Available from:\nhttp:\/\/www.omg.org\/technology\/documents\/modeling_spec_catalog.htm .\n[10] Papadimitriou C, Steiglitz K (1982), Combinatorial Optimisation: Algorithms and Complexity, Prentice-Hall\nInc.\n[11] Pohl K (1996), Process-Centred Requirements Engineering, Advanced Software Development Series, J.\nKramer (ed), Research Studies Press Ltd., ISBN 0-86380-193-5, London.\n[12] Robinson, W. and Fickas S (1994), Supporting Multi-Perspective Requirements Engineering, In Proc. of the\nIEEE Conference on Requirements Engineering, IEEE Computer Society Press, 206-215.\n[13] Si-Said S, Rolland C, Grosz G (1996), MENTOR: A Computer Aided Requirements Engineering\nEnvironment, Proc. of the 8th International Conference on Advanced Information Systems Engineering, 22-43.\n[14] Spanoudakis G, Constantopoulos P (1996), Elaborating Analogies from Conceptual Models, International\nJournal of Intelligent Systems, 11(11): 17-974.\n[15] Spanoudakis G, and Finkelstein A (1997), Reconciling requirements: a method for managing interference,\ninconsistency and conflict, Annals of Software Engineering, Special Issue on Software Requirements\nEngineering, 3: 459-475.\n[16] Spanoudakis G, Zisman A. (2001), Inconsistency Management in Software Engineering: Survey and Open\nResearch Issues, Handbook of Software Engineering and Knowledge Engineering, (ed) Chang S. K, World\nScientific Publishing Co, 329-380.\n[17] Lamsweerde A, Darimont R, Letier E (1998), Managing Conflicts in Goal-Driven Requirements Engineering,\nIEEE Transactions on Software Engineering, 24(11): 908-926.\n[18] Zisman A, Emmerich W, Finkelstein A (2000), Using XML to Specify Consistency Rules for Distributed\nDocuments, Proc. of 10th Int. Workshop on Software Specification and Design.\n[19] Shafer G (1976), A Mathematical Theory of Evidence, Princeton University Press.\n[20] http:\/\/java.sun.com\/j2se\/1.3\/docs\/guide\/awt\/\n[21] Spanoudakis G (2000), An Algorithm for Detecting Overlaps between Models of Object Interactions,\nTechnical Report Series, TR-2000\/03, ISSN 1364-4009, Department of Computing, City University.\n[22] http:\/\/www.rational.com\/products\/rose\/index.jsp.\n"}