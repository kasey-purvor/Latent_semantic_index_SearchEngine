{"doi":"10.1016\/j.entcs.2008.04.051","coreId":"65304","oai":"oai:dro.dur.ac.uk.OAI2:6245","identifiers":["oai:dro.dur.ac.uk.OAI2:6245","10.1016\/j.entcs.2008.04.051"],"title":"Separation logic for multiple inheritance.","authors":["Luo, C.","Qin, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Chen, Y.","Zhang, G.-Q.","Panangaden, P."],"datePublished":"2008-04-30","abstract":"As an extension to Floyd-Hoare logic, separation logic has been used to facilitate reasoning about imperative programs manipulating shared mutable data structures. Recently, it has also been extended to support modular reasoning in Java-like object-oriented languages where only single inheritance is allowed. In this paper we propose an extension of separation logic to support also the reasoning for multiple inheritance in C++ -like languages. To cater for multiple inheritance, we modified the standard storage model for separation logic in a way that the correct reference to a field or a method can be easily determined. On top of this storage model, a set of proof rules are proposed. Our verification system also provides basic support for behavioral subtyping","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65304.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6245\/1\/6245.pdf","pdfHashValue":"d7e471bc1c6728ab290d781e80054c9a7e786ebe","publisher":"Elsevier","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6245<\/identifier><datestamp>\n      2011-12-02T16:16:58Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Separation logic for multiple inheritance.<\/dc:title><dc:creator>\n        Luo, C.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:description>\n        As an extension to Floyd-Hoare logic, separation logic has been used to facilitate reasoning about imperative programs manipulating shared mutable data structures. Recently, it has also been extended to support modular reasoning in Java-like object-oriented languages where only single inheritance is allowed. In this paper we propose an extension of separation logic to support also the reasoning for multiple inheritance in C++ -like languages. To cater for multiple inheritance, we modified the standard storage model for separation logic in a way that the correct reference to a field or a method can be easily determined. On top of this storage model, a set of proof rules are proposed. Our verification system also provides basic support for behavioral subtyping.<\/dc:description><dc:subject>\n        Multiple Inheritance<\/dc:subject><dc:subject>\n         Separation Logic<\/dc:subject><dc:subject>\n         Verification.<\/dc:subject><dc:publisher>\n        Elsevier<\/dc:publisher><dc:source>\n        Electronic notes in theoretical computer science, 2008, Vol.212, pp.27-40 [Peer Reviewed Journal]<\/dc:source><dc:contributor>\n        Chen, Y.<\/dc:contributor><dc:contributor>\n        Zhang, G.-Q.<\/dc:contributor><dc:contributor>\n        Panangaden, P.<\/dc:contributor><dc:date>\n        2008-04-30<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6245<\/dc:identifier><dc:identifier>\n        issn:1571-0661<\/dc:identifier><dc:identifier>\n        doi:10.1016\/j.entcs.2008.04.051<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6245\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1016\/j.entcs.2008.04.051<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6245\/1\/6245.pdf<\/dc:identifier><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["1571-0661","issn:1571-0661"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2008,"topics":["Multiple Inheritance","Separation Logic","Verification."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n04 January 2010\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nLuo, C. and Qin, S. (2008) \u2019Separation logic for multiple inheritance.\u2019, Electronic notes in theoretical\ncomputer science., 212 . pp. 27-40.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1016\/j.entcs.2008.04.051\nPublisher\u2019s copyright statement:\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n04 January 2010 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nLuo, C. and Qin, S. (2008) 'Separation logic for multiple inheritance.', Electronic notes in \ntheoretical computer science., 212 . pp. 27-40. \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1016\/j.entcs.2008.04.051 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nFICS 2008\nSeparation Logic for Multiple Inheritance\nChenguang Luo1\nDepartment of Computer Science\nDurham University\nDurham DH1 3LE, United Kingdom\nShengchao Qin2\nDepartment of Computer Science\nDurham University\nDurham DH1 3LE, United Kingdom\nAbstract\nAs an extension to Floyd-Hoare logic, separation logic has been used to facilitate reasoning about imperative\nprograms manipulating shared mutable data structures. Recently, it has also been extended to support\nmodular reasoning in Java-like object-oriented languages where only single inheritance is allowed. In this\npaper we propose an extension of separation logic to support also the reasoning for multiple inheritance\nin C++ -like languages. To cater for multiple inheritance, we modified the standard storage model for\nseparation logic in a way that the correct reference to a field or a method can be easily determined. On top\nof this storage model, a set of proof rules are proposed. Our verification system also provides basic support\nfor behavioral subtyping.\nKeywords: Multiple Inheritance, Separation Logic, Verification\n1 Introduction\nObject-oriented programming languages offer a significant means to create software\nin a modular way. The mechanisms of inheritance and encapsulation allow program\nmodules to provide sufficient information for others to make use of them, meanwhile\nhiding implementation details. This characteristic is excellent for code reuse and\nmanagement, but it also calls for new formal approaches to reasoning about and\nverifying these OO programs.\nSeparation logic [14,3,15] has been proved to be an effective way to reason about\npointer- and heap-related imperative programs. It brought forward a new concept\nin the runtime storage model, viz. the heap, and enhanced the expressiveness of\nHoare logic over this model. The new logic operators it has introduced, separation\n1 Email: chenguang.luo@durham.ac.uk\n2 Email: shengchao.qin@durham.ac.uk\nThis paper is electronically published in\nElectronic Notes in Theoretical Computer Science\nURL: www.elsevier.nl\/locate\/entcs\nC. Luo and S. Qin\nconjunction and implication, not only specify explicitly that some part of the heap is\ndisjoint from another part, but also allow local reasoning about pointers and heaps.\nThis feature provides great support for modular reasoning, since each module\u2019s\nbehavior can be held in the variables that it accesses (its so-called \u201cfootprint\u201d). As\na result, separation logic is an excellent tool for OO program verification.\nDue to the fair properties of separation logic for OO verification, in this paper\nwe propose an extension of separation logic to reason about programs written in a\nC++ -like object-oriented language with multiple inheritance. To achieve this ob-\njective, there are two main issues to deal with. The first is to extend the syntax and\nsemantics of separation logic with method definitions and invocations, and (mul-\ntiple) class inheritance, since the classical separation logic concentrates mostly on\nsimple process-based languages. The second is to treat class inheritance and object\npolymorphism appropriately in the extension so as to cope with inherited classes and\noverridden methods. This paper\u2019s contribution mainly resides in the first aspect,\nthat is, it introduces the syntactical constructs and related semantics of multiple\ninheritance into a modularized separation logic, and formalizes the assertions and\nverification rules accordingly. For the second aspect, we follow Liskov\u2019s behavioral\nsubtyping ([4,7]) directly to make our work form a whole verification system for OO\nprograms with multiple inheritance.\nThe remainder of this paper is organized as follows. Next section sets up the\nsyntax of the C++ -like language used throughout this paper, and its semantics of\nclass inheritance and method overriding in a syntactical way. Then the separation\nlogic for this language is introduced, with the storage model expressing the program\nstates, the assertion language and its semantics, and the verification rules. After\nthat our approach of forcing behavioral subtyping is brought out, followed by an\nexample to illustrate this model for multiple inheritance verification, and the last\nsection summarizes the paper with related and future works.\n2 An OO language with multiple inheritance\n2.1 A core C++\nPrevious works on separation logic for object-oriented languages were mainly about\nlanguages supporting single inheritance, such as Java. This section\u2019s aim is to\nprovide a kernel part of C++ which supports multiple inheritance of classes.\nFirst we exhibit this core of C++ for verification. Any s means a (possibly\nempty) sequence of s.\nprog := cdef;\ncdef := class C : C\u2032{fdef mdef}\nmdef := [virtual] C \u2217m(C1 \u2217 x1, . . . ,Cn \u2217 xn){s return x; }\nfdef := C \u2217 f ;\ne := x | x\u2192C::f | null | this\ns := x=y\u2192C::f ; | x=(C\u2217)y; | x=new C(); | delete x; | x\u2192C::f=e; |\nx=y\u2192C::m(e); | C \u2217 x; | {s} | ; | if (e == e) s else s\nThis core language includes features such as class definitions, multiple inher-\n2\nC. Luo and S. Qin\nitance, polymorphism and method overriding. Other features comprise field and\nvariable definitions, the initialization and recycling of objects, variable assignment,\nand conditional constructs.\nTo keep the formalism simple, we leave out other C++ features that are of less\ninterest. Since separation logic is mainly about the aliases and mutation of pointers\nto heap, all the variables in this core are assumed to be pointers. Arithmetic\nexpressions and some other language constructs are also omitted. These features\nare to be added to our concern step by step in our future works towards practical\nimplementation of this system.\nSome of C++\u2019s original semantics is also changed. For any field or variable x,\nas we do not focus on dangling pointers in this paper, it is assumed that x = null\nif x is initially defined or later deleted. This aspect will be explored later.\nAt last are some conventions for the remainder of the paper. To traverse the\nclass names, we use C and D with proper subscripts. For class fields and methods,\nf and m are used respectively. For general variables x (and sometimes y) is used.\nAnd for any tuple a, we denote a.i as the i-th component of a.\n2.2 Semantics for inheritance\nBefore the introduction of the semantics for program\u2019s execution, this section will\nbring about the semantics for multiple inheritance of our core C++ in a syntactical\nway, as a foundation of further runtime semantics.\nAs is in C++, the inheritance of classes is expressed in the class definition\nclass C : C1, C2, . . . , Cn{fdef mdef}\ncarrying the meaning that C is a subclass of C1, C2, . . . , Cn. In this case we denote\nC \u227a Ci and it is clear that they form a partial order among these classes. There is a\nsynonym of this inheritance relationship that, assuming C has a fields list f1, . . . , fm\ndefined in its body, and each Ci has a fields list fi,1, . . . , fi,mi , then C\u2019s complete\nfields list is f1, . . . , fm, C1::f1,1, . . . , C1::f1,m1 , . . . , Cn::fn,mn . And this situation also\napplies to method inheritance.\nThis multiple inheritance, like C++, does not require all fields\u2019 and methods\u2019\nnames are distinct. Actually identical names of fields and methods are the very way\nto promote dynamic polymorphism. However, it can also cause ambiguity when\nwe refer to some fields of an object. For this issue we take the former inheritance\nclass C : C1, . . . , Cn and an object x typed C to describe the following cases:\n\u2022 A field named f which is only defined in C1. Then the reference x\u2192f is equal\nto x\u2192C1::f . And any other class indirectly inheriting C1, without f defined, can\nrefer to x\u2192f equally as x\u2192C1::f .\n\u2022 A field named f which is defined only in both C and C1. Then the references x\u2192f\nand x\u2192C1::f might be distinct. This is similar as the case in single inheritance.\n\u2022 A field named f which is defined only in both C1 and C2. Then the reference x\u2192f\nis invalid, and the two f \u2019s that are overridden must be referred to with explicit\nspecification x\u2192C1::f and x\u2192C2::f . This also applies to other classes (indirectly)\ninheriting C. This case is unique in multiple inheritance and analogous as C++.\n3\nC. Luo and S. Qin\n\u2022 A field named f which is defined only in C,C1 and C2. Then all the references\nx\u2192f, x\u2192C1::f and x\u2192C2::f are distinct. This is also the C++ case, unique in\nmultiple inheritance.\nThese rules are applicable for methods overriding as well, except for two issues.\nFirst, both the method names and the parameter types are criteria to judge \u201ciden-\ntical names\u201d of methods. Second, unlike fields, only virtual methods (defined with\nprefix \u201cvirtual\u201d) can be overridden.\nFollowed is the semantics of access to indirectly inherited fields and methods.\nAssume we have a chain of inheritance relationship C \u227a D1 \u227a D2 \u227a \u00b7 \u00b7 \u00b7 \u227a Dn, and\na field f is defined in Dn. Then for an object x of C, f can be referred to with\nthe expression x\u2192D1::D2:: . . . ::Dn::f , where we modify the C++ syntax slightly to\nexplicitly specify the inheritance chain instead of casting x.\nWith the semantics above, the rules to specify a unique field for x\u2192f can be\nsummarized as a function over the syntactical constructs of our language. Consider\nx as an object of class C and {Dn} is the set of all superclasses of C. When we try\nto access the field x\u2192f , its syntactical meaning is as follows:\ninh(x\u2192f) =df\n\uf8f1\uf8f4\uf8f4\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4\uf8f4\uf8f4\uf8f3\nx\u2192 Dim\u22121 ::Dim\u22122 :: . . . ::Dik ::f, if there is a set D = {Dij |\nDij \u227a Dij\u22121 , j = 1 . . . m,C = Dim} and f is in Dik\nand for any D \u2208 {Dn} that has a field f, we have\nD \u2208 D and Dik \u0016 D;\n\u22a5, otherwise.\ninh(x\u2192D::f) =df x\u2192D::f.\nand these two mappings also apply to virtual method invocations. For non-virtual\nmethods like x\u2192D::m, we always have inh(x\u2192D::m) =df x\u2192D::m.\nAn informal description of ambiguity is that there are two chains of inheritance\nwith the bottom (subclass of all) C, and f occurs in classes of both chains. For\nother situations different from the one above, that is, f appears and only appears\nin one chain, then the f in the nearest class to C is the reference we need.\nAs is stated, dynamic polymorphism can be realized under this infrastructure.\nTake a class inheritance class C : D and a variable x typed D as example, x can\nalso be initialized as an object of C via x = new C(). In the situation that both C\nand D has the field f , the semantics of expression x\u2192f is a reference to the f of\nx\u2192C::f but not x\u2192D::f , and we must explicitly specify the latter if we want its\nreference. The verification system to be built later is based on such semantics.\nFinally, in the remainder of this paper it is assumed that all the class inheri-\ntances are valid (no illegal circle in the partial order) and all the references are not\nambiguous, since these should be guaranteed at compile-time.\n3 Separation logic for multiple inheritance\n3.1 The storage model\nAs is introduced, separation logic is about the reasoning of aliases and shared muta-\nble objects. Because both such aliases and sharing occur on the heap, it is necessary\nto include the heap in our storage model, which is different from classical Hoare logic\n4\nC. Luo and S. Qin\nwhere variables are accessed based on the stack. Meanwhile stack is still needed in\nour model, since the heap can be modeled as a mapping from an address to a value,\nin which the address should be accessed via the stack. Our storage model, given as\nfollows, is based on the standard model for separation logic.\nStack =df ProgVar \u21c0 Loc\nAux =df AuxVar \u21c0 Loc\nHeap =df Loc \u21c0 (ClassName\u00d7 Field)\nField =df {f | f : ClassName\u00d7 FieldName \u21c0 Loc}\nStack is a mapping from program variables to address locations Loc, which will\nnot be defined further.\nThe auxiliary variables compose a significant part of the program state. Though\nthey are not a real part of the storage, they can be useful as assistance to describe\nprogram states and specifications. Hence they are also involved in the storage\nmodel. These variables do not have fixed types and are supposed to capture any\nappropriate value from both the stack and the heap.\nNote that our model of heap is slightly different from the classical separation\nlogic, where heap is modeled as a mapping from locations (a subset of integers or\nvalues) to values, i.e. Heap =df Loc \u21c0 Value\n+. The reason for us to diverge from\nthis is that, as an object-oriented language, heap locations are not simply typed as\nintegers or floats, but as more complicated objects of user-defined classes in order\nto support inheritance and method overriding. Hence the type information of an\nobject must be recorded.\nMeanwhile, similar as that a heap location can store many values in the classical\nseparation logic, in our model an object can also have many fields with diverse\ntypes. As a result, beneath the heap there is one more set of mappings, Field, to\nrecord the information of an object\u2019s fields. Each element f of Field, denoting one\nobject in the runtime environment, maps a pair of a field\u2019s (type, name) to its stored\naddress, where the name is the name of the field, and the type is the class name\ncontaining the field (but not the type of the field itself). This design is to facilitate\nmultiple inheritance, since a class may inherit many fields with the same name from\nits ancestor classes, which form a lattice in lieu of a chain; hence both the name of\nthe field and the actual class containing it are needed when accessing that field. The\nvalues mapped to by f are undefined for such pairs not contained in this object.\nBesides the heap model itself, a union operation for two disjoint heaps is defined\nhere to support the semantics later:\nh1 \u2217 h2 =df\n{\nh1 \u222a h2, if dom(h1)\u2229dom(h2)=\u2205;\n\u22a5, otherwise.\nThis operation conforms to the separation conjunction which will be brought in by\nthe introduction of separation logic. Separation conjunction explicitly claims that\ntwo pointers point to disjoint part of heap and thus are not alias to each other, which\nreduces the intricacy of traditional types of logic for stating that a heap location is\npointed to by a pointer exclusively.\nBased on the aforesaid models, the definition of program state (also storage)\n5\nC. Luo and S. Qin\nmodel is a cartesian product of them.\n\u03a3 =df Stack\u00d7 Heap\u00d7 Aux\nLater we will employ s, h and \u03c3 to go through instances of stacks, heaps and states.\n3.2 Assertion language\nAs for separation logic, it adds two separation-related logical operators. One is\nseparation conjunction \u2217, and the other is the separation implication \u2212\u2217. In this\npaper only the first is utilized. Its semantics will be introduced later.\nNext is the assertion language for our verification system, in which e and e\u2032\nstand for variables, null and this, and f and f \u2032 denote field names:\nP =df true | false | \u00acP | P\u2227P | P\u2228P | P\u21d2P | P\u2217P |\ne=e\u2032 | e\u2192C::f=e\u2032\u2192C::f \u2032 | e\u2192C::f 7\u2192 e\u2032 | e : C | \u2203X.P | \u2200X.P\nIt is worth noting here that we do not have the assertion emp in standard separation\nlogic to express empty heap. Instead, the assertion x = null is used to express\nthat no part of the heap is allocated for the variable x and thus it points to a\nreserved area null. This assertion not only depicts empty heap but also specifies the\nvariable owning no corresponding allocated heap, which is more accurate without\nthe presence of dangling pointers.\nWith the storage model as a foundation, each assertion is interpreted as a set of\nstates.\n|[true]| =df \u03a3\n|[false]| =df \u2205\n|[\u00acP ]| =df \u03a3 \\ |[P ]|\n|[P\u2227Q]| =df |[P ]| \u2229 |[Q]|\n|[P\u2228Q]| =df |[P ]| \u222a |[Q]|\n|[P\u21d2Q]| =df |[\u00acP \u2228Q]|\n|[P\u2217Q]| =df {(\u03c3.1, \u03c3.2, \u03c3.3) | \u03c3\u2208\u03a3 \u2227 \u2203h1, h2 . (\u03c3.2=h1\u2217h2\n\u2227 (\u03c3.1, h1, \u03c3.3)\u2208|[P ]| \u2227 (\u03c3.1, h2, \u03c3.3)\u2208|[Q]|)}\n|[e=e\u2032]| =df {\u03c3 | \u03c3.1(e) = \u03c3.1(e\n\u2032)}\n|[e\u2192C::f 7\u2192 e\u2032]| =df {\u03c3 | \u03c3.2(\u03c3.1(e)).2(C1 , f) = \u03c3.1(e\n\u2032)}\nwhere C1 is the nearest class\u2019 name to f in inh(e\u2192C::f)\n|[e\u2192C::f=e\u2032\u2192C \u2032::f \u2032]| =df {\u03c3 | \u03c3.2(\u03c3.1(e)).2(C1 , f) = \u03c3.2(\u03c3.1(e\n\u2032)).2(C \u20321, f\n\u2032)}\nwhere C1 and C\n\u2032\n1 are the nearest classes\u2019 names to f and\nf \u2032 in inh(e\u2192C::f) and inh(e\u2032\u2192C \u2032::f \u2032), respectively\n|[e : C]| =df {\u03c3 | \u03c3.2(\u03c3.1(e)).1 = C}\nFor the semantics of these assertions, the ones in ordinary logic are easy to under-\nstand. The separation conjunction \u2217 means that, if both P and Q hold for a state\n\u03c3, and the heap locations referred to by P are different from those by Q, then P\u2217Q\nalso holds for \u03c3, with the additional semantics that their orbits over the heap are\ndisjoint.\nThe 7\u2192 considers the field C::f of e as a pointer pointing to (or mapped to by\nthe heap) the semantics of e\u2032. This assertion allows us to reason about program\n6\nC. Luo and S. Qin\nvariables\u2019 fields, where the fields are interpreted with the predefined function inh for\ninheritance purposes.\nThe e : C is a test of a variable (or rather a location)\u2019s real type in the program\nexecution time. This is dynamic due to polymorphism. The result is possibly the\nvariable\u2019s defined type or any of its subtype.\nAt last, the \u2203X.P and \u2200X.P are interpreted as in normal first-order logic, where\nX is an auxiliary variable. And for \u2203X.P (X) we use P (-) for short.\n3.3 Rules\nIn this section we present the rules exploited in our verification system. These rules\nare in the following triple form:\n\u0393 \u22a2 {P} s {Q}\nwhere \u0393 := \u01eb | {P} C.m(x) {Q},\u0393 is the statical result of verification, consisting of\nverified method specifications. The triples are common Hoare logic triples written\nin the former assertion language and our kernel C++\u2019s syntax.\nOf all the rules in our system, first are the structural ones.\nP \u21d2 P \u2032 \u0393 \u22a2 {P \u2032} s {Q\u2032} Q\u2032 \u21d2 Q\n\u0393 \u22a2 {P} s {Q}\n(conseq)\n\u0393 \u22a2 {P} s {Q}\n\u0393 \u22a2 {\u2203X.P} s {\u2203X.Q}\n(var-elim)\n\u0393 \u22a2 {P} s {Q}\n\u0393 \u22a2 {P \u2217R} s {Q \u2217R}\n(frame)\nwhere no variable in mods(s) appears freely in R.\nThe frame rule is a substitute of the \u201crule of constancy\u201d in classical Hoare logic.\nBy using this rule, the reasoning of local heap can be extended to a global one. For\ninstance, if a recursive method call always uses a separate area of heap at a new\ntime of invocation, then its behavior can be modeled locally to this method body\nfirst, and then extended to the heap containing other instances of invocation of this\nmethod using this rule.\nNext are the canonical rules in ordinary Hoare logic. These rules include skip,\ninstruction sequence, blocks and the if conditions.\n\u0393 \u22a2 {P} ; {P} (skip)\n\u0393 \u22a2 {P} s1 {R} \u0393 \u22a2 {R} s2 {Q}\n\u0393 \u22a2 {P} s1; s2 {Q}\n(seq)\n\u0393 \u22a2 {P} s {Q}\n\u0393 \u22a2 {P} {s} {Q}\n(block)\n\u0393 \u22a2 {P \u2227 (e1=e2 \u2228 e1 7\u2192e2)} s1 {Q} \u0393 \u22a2 {P \u2227 \u00ace1=e2 \u2227 \u00ace1 7\u2192e2} s2 {Q}\n\u0393 \u22a2 {P} if (e1 == e2) s1 else s2 {Q}\n(if)\nFor assignment, there are two cases to be considered in our syntax. One is from\nobject field to another variable, and the other is the opposite direction.\n\u0393 \u22a2 {y\u2192C::f 7\u2192 X} x=y\u2192C::f ; {x = X} (assign-1)\n\u0393 \u22a2 {e = X} x\u2192C::f=e; {x\u2192C::f 7\u2192 X} (assign-2)\n7\nC. Luo and S. Qin\nThe two rules of assignment take use of auxiliary variable X instead of the tradi-\ntional assignment rule using substitution in assertions. The auxiliary variable in-\ntroduced can be eliminated later in a proof. Note that an assignment also changes\nthe heap location that a variable points to.\nNext is a special case of assignment: the downcast.\n\u0393 \u22a2 {(y=X \u2227 y:C) \u2228 y=null)} x=(C \u2217)y; {x = X} (downcast)\nAs downcasting requires that a variable of a base class be casted down to an object\nof its subclass, it is essential to check whether the variable is pointing to an object\nof the subclass; if not, the downcasting cannot be performed.\nThe rules below are for fields manipulation.\n\u0393 \u22a2 {true} C \u2217 x; {x=null} (def)\n\u0393 \u22a2 {x=X} x=new C(); {x=Y \u2227 \u00acX=Y \u2227 x:C} (new)\nwhere Y is a fresh auxiliary variable.\n\u0393 \u22a2 {x 7\u2192-} delete x; {x=null} (delete)\nFor variable definition, it is supposed that the compiler will prevent re-definition\nstatically, and hence the pre-condition is not needed. The operations of new and\ndelete have opposite behaviors on the heap, as is expressed in the rules, one allo-\ncates a fresh location in the heap, while the other disposes some part of the heap.\nAnd the last are the rules for methods definition and invocation.\n\u0393 \u22a2 {P \u2227 this:C} C \u2217 y; y=x; s[y\/x] {Q[x\/ret]} m(C \u2032 \u2217 x\u2032){s return x; }\n\u0393\u2190 {P} C.m(x) {Q},\u0393\n(m-def)\nwhere ret is the return value of the method and\ny does not occur freely in the method body.\nThis rule first ensures that this method is defined in the right class C. After that\nthe method body is checked to agree with the specification {P} s {Q[x\/ret]}. Then\nthe specification is added to the statical environment to support potential method\ninvocation, which is depicted in the following rule.\n\u03931, {P} D.m(x) {Q},\u03932 \u22a2 {\u03b8(P ) \u2227 (\u00acy=null)} x=y\u2192C::m(e); {\u03b8(Q)} (m-call)\nwhere \u03b8 = [e, y, x \/ x, this, ret] and D is the\nlast class name before m in inh(y\u2192C::m).\nThe above rule verifies the call of a overridden method from an object y. It has\nthe inverse behavior of the last rule by substituting the actual parameters with the\nformal ones to fit in the specification recorded in \u0393. When using this rule the static\ntype of y should be judged.\nIn this section we have combined separation logic with a OO language with\nmultiple inheritance. This logic has a semantics based on multiple inheritance and\nheap model of storage, and has a series of formal verification rules upon this model.\n8\nC. Luo and S. Qin\nHowever, when using such rules to derive a program\u2019s proof we still have to consider\nthe polymorphism and the specification compatibility in method overriding, which\nwill be the main topic of next section.\n4 Behavioral subtyping\nAs our verification is performed over an object-oriented language with multiple in-\nheritance, it is necessary to deal with dynamic dispatching during program execution\ntime, for the possible inheritance and the resulted method overriding.\nFor this issue we turn to Liskov\u2019s behavioral subtyping ([4,7]). Since upcasting\ncould occur in any place of a program, it must be ensured that any object of a\nsubclass should behave like an object of its superclass. That is, for any of this\nobject\u2019s method overriding the superclass\u2019 counterpart, its specification should be\nconsistent with the superclass\u2019 method\u2019s. Thus no matter an object belonging to\na class or its subclass appears, it will conform to the expected specification. And\nthis is formalized with behavioral subtypes, say, a type C is a behavioral subtype of\nD, if for each virtual method m of C overriding that of D, with the specifications\n{PC} {QC} and {PD} {QD}, the implications PD \u21d2 PC and QC \u21d2 QD hold.\nIn the view of canonical Hoare logic, this definition of behavioral subtyping\nis another description of the rule of consequence. If all the classes of a program\nconform to such restrictions, then in verification it is safe to ignore the real type\nof an object during execution time, since the behavior of the object\u2019s methods will\nalways comply with the specifications, no matter those for the base class or for its\ninherited classes.\nParkinson and Biermann ([12]) proposed a concept of compatible specifica-\ntions, as a generality of behavioral subtyping: \u2200s, if we have {PD} s {QD} \u21d2\n{PC} s {QC}, namely, a proof of the latter with the only premise of the former,\nthen the latter is defined as compatible with the former. The aim of behavioral\nsubtyping is to ensure that each overriding method C.m(x) has a specification com-\npatible with its counterpart in the superclass, D.m(x).\nTo achieve this goal, a possible way is to make a \u201cconjunction\u201d of the base\nclass\u2019 method\u2019s specification and the subclass\u2019 method\u2019s. Such specification could\ncarry the conditions specified for both classes\u2019 method and be used appropriately\naccording to the real type of objects.\nConsider two specifications for a virtual method m in class C and its base class\nD. m in C overrides m in D, and their specifications are as follows, respectively:\n{PD} {QD} {PC} {QC}\nIf we can make a specification consistent with both two above, then whenever the\nmethod m of an object x, with static type of class D, is invoked, this specification\ncan be used even if x : C. This can be accomplished by the following means:\n{\n(PC \u2227 IC)\u2228\n(PD \u2227 ID)\n} {\n(QC \u2227 IC)\u2228\n(QD \u2227 ID)\n}\nwhere assertions PC , QC , PD and QD are the same as above, while IC and ID are\n9\nC. Luo and S. Qin\ninvariants of type identity. It can be shown that this is compatible with both m\u2019s in\nC andD. To illustrate, for {PD} {QD} as a specification of D.m(x), we can set the\ninvariant as this : D and modify the specification as {PD\u2227this:D} D.m(x) {QD\u2227\nthis:D}, which can be derived just from our specification conjunction. Also an\nauxiliary variable may be set to specify the different cases, which can be eliminated\nwith the auxiliary variable elimination rule later.\nIn our case of multiple inheritance, suppose that there are several chains of class\ninheritance relationship. Then for each of such chain Cn \u227a Cn\u22121 \u227a \u00b7 \u00b7 \u00b7 \u227a C1 and\neach overridden methodm of these classes, a conjunction of different specifications of\ndiverse implementations of m should be made available. Without loss of generality,\nassume m is overridden in each Ci with specification {Pi} Ci.m {Qi}, and then the\ntotal specification to capture all behaviors of different m\u2019s in this inheritance chain\nshould be\n{\nn\u2228\ni=1\n(Pi \u2227 Ii)} m {\nn\u2228\ni=1\n(Qi \u2227 Ii)}\nwhich can be used at any call site of m belonging to an object with static type of\nany Ci.\n5 An example\nThis section depicts an example as an illustration of our former means. It is based\non the task-display example from Stroustrup [16,17] and has some modifications to\ncater for our language.\nConsider a simulation of a network of computers. There are mainly two types\nof beings: tasks and displays. Tasks provide basic facilities for co-routine style\nbehaviors of the network, and displays provide means for the monitoring of object\nstates in the network. For these two concepts, two classes are defined as Task\nand Display. Task\u2019s objects include network nodes called switches, and Display\ncontains elements like communication lines in the network. These two are naturally\nmodeled as Switch and Line, subclasses of the former two base ones.\nIdeally Task and Display are disjoint because they share no similarity. However,\na computer terminal, whose class is denoted Terminal, can act both as a task node\nand a monitor device. Thus the best way is to make Terminal inherit both Task\nand Display. In the following example we omit the definition of Switch, Line\nand other indifferent methods in our view for the space limit. For more detailed\nbackground of these examples, the bibliography is recommended.\nBelow are the codes for our examples. The class Node is added for support.\nclass Node { ... };\nclass Task {\nNode *n;\nvirtual Node *trace\n(Node *an) {\nthis->n = an;\nreturn this->n;\n}\n};\nclass Display {\nNode *n;\nvirtual Node *trace(Node *an) {\nNode *tmp;\nif (an == this->n) tmp = an;\nelse tmp = this->n;\nreturn tmp;\n}\n};\n10\nC. Luo and S. Qin\nclass Terminal : Display, Task {\nNode *trace(Node *an) {\nNode *tmp;\nif (this->Display::n == this->Task::n)\ntmp = this->Display::trace(this->Task::n);\nelse tmp = this->Task::trace(an);\nreturn tmp;\n}\n};\nThe results of the three methods\u2019 verification is depicted as a \u0393 built up by their\nspecifications:\n{(this\u2192n 7\u2192 N1 \u2227 an=N1) \u2228 (this\u2192n 7\u2192 N1 \u2227 an = N2 \u2227 \u00acN1=N2)}\nDisplay.trace(Node \u2217 an)\n{this\u2192n 7\u2192 N1 \u2227N1=an \u2227 an=ret}\n{an = N1} Task.trace(Node \u2217 an) {this\u2192n 7\u2192 N1 \u2227N1=an \u2227 an=ret}\n{\n(this\u2192Display::n 7\u2192 N1 \u2217 this\u2192Task::n 7\u2192 N1) \u2228\n((this\u2192Display::n 7\u2192 N1 \u2217 this\u2192Task::n 7\u2192 N2) \u2227 \u00acN1=N2)\n}\nTerminal.trace(Node \u2217 an)\uf8f1\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4\uf8f3\n((this\u2192Display::n 7\u2192 N1 \u2217 this\u2192Task::n 7\u2192 N1)\u21d2\n((this\u2192Display::n 7\u2192 N1 \u2217 this\u2192Task::n 7\u2192 N1) \u2227 ret=N1))\u2227\n(((this\u2192Display::n 7\u2192 N1 \u2217 this\u2192Task::n 7\u2192 N2) \u2227 \u00acN1=N2)\u21d2\n(this\u2192Display::n 7\u2192 N1 \u2217 this\u2192Task::n 7\u2192 N3 \u2227 an=N3 \u2227 an=ret))\n\uf8fc\uf8f4\uf8f4\uf8fd\n\uf8f4\uf8f4\uf8fe\nTo deal with behavioral subtyping, as is stated in the paper, a \u201cconjunction\u201d\nof the three methods\u2019 specifications can be made with an invariant to distinguish\namong different dynamic situations. However, in our example we only have to\nconjugate the specifications of Display.trace\u2019s and Terminal.trace\u2019s, and also\nTask.trace\u2019s and Terminal.trace\u2019s, separately, since these two are different chains\nof inheritance.\n6 Conclusions\nThis paper brings out an extension of the separation logic for the reasoning of\nobject-oriented programs with multiple inheritance. It has condensed the syntax of\nC++ to a core and set up a storage model for it based on the canonical separation\nlogic. The verification rules are proposed according to this model, and behavioral\nsubtyping is considered for the sake of runtime type decision. Finally an example\nis utilized to illustrate this whole approach.\n6.1 Related work\nSeparation logic [14,3,15] is a significant extension of Hoare logic to boost reasoning\nabout programs with pointers and heap manipulation. It allows reasoning to be\ndone locally for a single part of heap without interfering with others, and also al-\nlows the result of reasoning to be extended again to global environment. Therefore\n11\nC. Luo and S. Qin\nmany works took use of this modularity. O\u2019Hearn et al. [10] used the separation\nconjunction and the hypothetical frame rule to separate one module\u2019s internal re-\nsources from those accessed by its clients which was a first step for separation logic\ntowards modular program verification. O\u2019Hearn [9] also employed the analogous\napproach in concurrent program verification to describe resources in critical region\nof concurrent processes. Due to this modularity, separation logic is highly suitable\nfor the verification of object-oriented programs. Another former attempt to intro-\nduce separation logic into the field of OO verification belongs to Parkinson [11]. In\nthat work he found good means (abstract predicate family) to depict methods spec-\nifications and to rebuild the logic for Java program reasoning. We intend to follow\nhis route to construct another extension of separation logic for a more general case\nof class inheritance. In our case the chains of inheritance might have intersections,\nwhich are different from single inheritance in both syntax and semantics.\nTo support reasoning about the type hierarchy and inheritance of object-oriented\nprogramming languages, and to capture their important properties such as polymor-\nphism and diverse implementations, the concept of behavioral subtyping has been\ndeveloped, as in Liskov [4], Liskov and Wing [7], Meyer [8], Dhara and Leavens [2],\nLeavens and Naumann [5], Parkinson [11], Parkinson and Biermann [13], and Chin\net al. [1]. The first ([4]) was one of the beginners to develop the relationship between\ndata abstraction and type hierarchy. Later Liskov and Wing proposed the behav-\nioral subtyping as a general approach to dealing with inheritance and polymorphism\n([7]). Another method to enforce that the new specification should also inherit the\nold one in class inheritance was introduced by Meyer ([8]) for Eiffel. Those two\ntechniques were combined by Dhara and Leavens ([2]), and were eventually proven\nto be equivalent by Leavens and Naumann ([5]). The rest were practices, using\nbehavioral subtyping or not, to process class hierarchy and inheritance in modeling\nand verification of object-oriented languages. Chin et al. [1] divided the method\nspecification into finer-grained static and dynamic ones to prevent repeated verifi-\ncation and meanwhile to preserve behavioral subtyping. Parkinson and Biermann\n([13]) used their abstract predicate family to cope with the same problem and could\neven handle cases there were beyond the capability of behavioral subtyping. In our\nwork we took the compatible specification to guarantee behavioral subtyping. How-\never, as a matter of fact, the way to treat with type hierarchy and class inheritance\nis orthogonal to our work. Therefore any of the aforesaid approach may be utilized.\n6.2 Future work\nBeyond this work, there are still several possible directions calling for further re-\nsearch. One of them aims at the defect of this work, viz. the re-verification of the\ninherited virtual methods. Since these methods may have different implementations\nfrom their antecedents, it may be necessary to treat them as totally new methods\nfor re-verification, which requires much extra workload. Some feasible solutions for\nthis include the works of Chin et al. ([1]), which separated method specifications to\nstatic and dynamic ones, where only the latter needed re-verification, and Parkin-\nson and Biermann ([13]) who invented abstract predicate families to reduce the\nnecessity of re-verification.\nAnother important future work is to give an implementation of this extension of\n12\nC. Luo and S. Qin\nseparation logic. Before this more features of C++ must be added to the language,\nsuch as stack variables for basic data types, arithmetic operations and access con-\ntrol. Then the model and the rules should be combined to some (semi-) automatic\nreasoners for implementation.\nAcknowledgement\nChenguang Luo is funded by Doctoral Fellowship Scheme of Durham University.\nShengchao Qin is supported in part by the EPSRC project EP\/E021948\/1.\nReferences\n[1] W. Chin, C. David, H. H. Nguyen, and S. Qin. Enhancing modular OO verification with separation\nlogic. San Francisco, USA, January 2008. The 35th ACM SIGPLAN-SIGACT Symposium on Principles\nof Programming Languages (POPL\u201908).\n[2] K. Dhara and G. Leavens. Forcing behavioral subtyping through specification inheritance. Berlin,\nGermany, March 1996. Proceedings of the 18th International Conference on Software Engineering\n(ICSE-18).\n[3] S. Isthiaq and P. O\u2019Hearn. BI as an assertion language for mutable data structures. London, United\nKingdom, January 2001. The 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming\nLanguages (POPL\u201901).\n[4] B. Liskov. Data abstraction and hierarchy. ACM SIGPLAN Notices, 23(5):1734, May 1988.\n[5] G. Leavens and D. Naumann. Behavioral subtyping is equivalent to modular reasoning for object-\noriented programs. Technical Report 06-36, Department of Computer Science, Iowa State University,\n2006.\n[6] J. Loeckx, K. Sieber, and R. Stansifer. The foundations of program verification. John Wiley and Sons,\n1984.\n[7] B. Liskov and J. Wing. A behavioral notion of subtyping. ACM Transactions on Programming\nLanguages and Systems, 16(6):1811-1841. November 1994.\n[8] B. Meyer. Eiffel: the language. Object-Oriented Series. Prentice Hall. New York, 1992.\n[9] P. O\u2019Hearn. Resources, concurrency, and local reasoning. Proceedings of CONCUR\u201904, LNCS 3170,\npp49-67.\n[10] P. O\u2019Hearn, H. Yang, and J. Reynolds. Separation and information hiding. Venice, Italy, January 2004.\nThe 31th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL\u201904).\n[11] M. Parkinson. Local reasoning for Java. PhD thesis, Cambridge University, August 2005.\n[12] M. Parkinson and G. Biermann. Separation logic and abstraction. Long Beach, California,\nUSA, January 2005. The 32th ACM SIGPLAN-SIGACT Symposium on Principles of Programming\nLanguages (POPL\u201905).\n[13] M. Parkinson and G. Biermann. Separation logic, abstraction and inheritance. San Francisco,\nCalifornia, USA, January 2008. The 35th ACM SIGPLAN-SIGACT Symposium on Principles of\nProgramming Languages (POPL\u201908).\n[14] J. Reynolds. Intuitionistic reasoning about shared mutable data structure. Millennial Perspectives in\nComputer Science, Proceedings of the 1999 Oxford\u2013Microsoft Symposium in Honour of Sir Tony Hoare,\n1999.\n[15] J. Reynolds. Separation logic: A logic for shared mutable data structures. In Lecture Notes in Computer\nScience. Springer-Verlag, 2002.\n[16] B. Stroustrup. The C++ programming language. Addison-Wesley, 1991.\n[17] B. Stroustrup. Multiple inheritance for C++. The C\/C++ Users Journal, May 1999.\n[18] Daniel Wasserrab, Tobias Nipkow, Gregor Snelting, and Frank Tip. An operational semantics and type\nsafety proof for multiple inheritance in C++. In OOPSLA\u201906: Object-Oriented Programming, Systems,\nLanguages, and Applications. ACM Press, 2006.\n13\n"}