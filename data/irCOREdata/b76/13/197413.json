{"doi":"10.1109\/SERVICES.2010.27","coreId":"197413","oai":"oai:lra.le.ac.uk:2381\/9660","identifiers":["oai:lra.le.ac.uk:2381\/9660","10.1109\/SERVICES.2010.27"],"title":"Web Services Feature Interaction Detection based on Situation Calculus","authors":["Xu, Jiuyun","Yu, Wengong","Chen, Kun","Reiff-Marganiec, Stephan"],"enrichments":{"references":[{"id":43708351,"title":"Detecting Race Conditions in Web Services,","authors":[],"date":"2006","doi":"10.1109\/aict-iciw.2006.82","raw":"Zhang, J., Su, S., and Yang, F. Detecting Race Conditions in Web Services, In Proceedings of the International Conference on Internet and Web Applications and Services (ICIW'06), 2006.","cites":null},{"id":43708346,"title":"Detecting the Web Services Feature Interactions.","authors":[],"date":"2006","doi":"10.1007\/11912873_19","raw":"Zhang, J., Yang, F., and Su, S. Detecting the Web Services Feature Interactions. In K. Aberer et al. (Eds.): WISE 2006, LNCS 4255, pp. 169-174, 2006.","cites":null},{"id":43708343,"title":"Feature Interaction Outside a Telecom Domain. In:","authors":[],"date":"2001","doi":null,"raw":"Blair, L., Blair, G., Pang, J., and Efstratiou, C. Feature Interaction Outside a Telecom Domain. In: Proceedings of the Workshop on Feature Interactions in Composed Systems (ECOOP'2001) 15-20, 2001.","cites":null},{"id":43708345,"title":"Feature interaction: a critical review and considered forecast.","authors":[],"date":"2003","doi":"10.1016\/s1389-1286(02)00352-3","raw":"Calder, M., Kolberg, M., Magill, E.H. and Reiff-Marganiec, S. Feature interaction: a critical review and considered forecast. International Journal of Computer Networks. 41: pp. 115-141, 2003.","cites":null},{"id":43708347,"title":"Feature Interactions: Old Hat or Deadly New Menace? In:","authors":[],"date":"2004","doi":"10.1002\/0470020504.ch13","raw":"Magill, E.H.. Feature Interactions: Old Hat or Deadly New Menace? In: K. Turner, E. Magill and D. Marples (Eds.), Service Provision: Technologies for Next Generation Communications, Wiley, pp. 235-252, 2004.","cites":null},{"id":43708350,"title":"Formalising Web Services. In:","authors":[],"date":"2005","doi":"10.1007\/11562436_34","raw":"Turner, K.J. Formalising Web Services. In: Proceeding of Formal Techniques for Networked and Distributed Systems (FORTE XVIII), LNCS 3731, 473-488, 2005.","cites":null},{"id":43708344,"title":"Guest Editorial: Directions in Feature Interaction Research. In:","authors":[],"date":"2004","doi":"10.1016\/j.comnet.2004.03.024","raw":"Amyot, D. and Logrippo, L. Guest Editorial: Directions in Feature Interaction Research. In: Computer Networks, Special Issue on Feature Interactions in Emerging Application Domains 45 5, 563-567, 2004.","cites":null},{"id":43708352,"title":"Immune-Inspired Online Method for Service Interactions Detection.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-69507-3_70","raw":"Zhang, J., Yang, F., Shuang, K., and Su, S. Immune-Inspired Online Method for Service Interactions Detection. In Jan van Leeuwen et al. (Eds.): SOFSEM 2007, LNCS 4362, pp. 808-818, 2007.","cites":null},{"id":43708358,"title":"Information and Network Dynamics Lab Semantic Web Agents Project,","authors":[],"date":null,"doi":null,"raw":"MINDSWAP: Maryland Information and Network Dynamics Lab Semantic Web Agents Project, OWL-S API. http:\/\/www.mindswap.org\/2004\/owl-s\/api\/.","cites":null},{"id":43708354,"title":"Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems.","authors":[],"date":"2001","doi":"10.1017\/s0269888906210749","raw":"R. Reiter. Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems. MIT Press, 2001.","cites":null},{"id":43708348,"title":"On Feature Interactions among Web Services. In:","authors":[],"date":"2004","doi":"10.1109\/icws.2004.1314727","raw":"Weiss, M. and Esfandiari, B. On Feature Interactions among Web Services. In: Proceedings of the International Conference on Web Services (ICWS), IEEE, 2004.","cites":null},{"id":43708356,"title":"OWL rules: A proposal and prototype implementation.","authors":[],"date":"2005","doi":"10.1016\/j.websem.2005.05.003","raw":"Horrocks, I., Patel-Schneider, P.F., Bechhofer, S. and Tsarkov, D.: OWL rules: A proposal and prototype implementation. J. of Web Semantics 3 (2005), pp.23-40.","cites":null},{"id":43708357,"title":"OWL-S Atomic Services Composition with SWRL Rules.","authors":[],"date":"2008","doi":"10.1007\/978-3-540-68123-6_66","raw":"Redavid, D., Iannone, L., Payne, T. and Semeraro, G. OWL-S Atomic Services Composition with SWRL Rules. Lecture Notes in Computer Science: Foundations of Intelligent Systems, vol. 4994, pp. 605-611, 2008.","cites":null},{"id":43708355,"title":"OWL-S: Semantic Markup for Web Services,","authors":[],"date":null,"doi":"10.1201\/9781584889342.ch5","raw":"OWL-S: Semantic Markup for Web Services, http:\/\/www.w3.org\/Submission\/OWL-S\/.","cites":null},{"id":43708359,"title":"Policy Support for Call Control.","authors":[],"date":"2006","doi":"10.1016\/j.csi.2005.05.004","raw":"Turner, K.J., Reiff-Marganiec, S., Blair, L., Pang, J., Gray, T., Perry, P. and Ireland, J. Policy Support for Call Control. Computer Standards and Interfaces, vol 28\/6 pp 635-649, 2006.","cites":null},{"id":43708353,"title":"Some Contributions to the Metatheory of the Situation Calculus.","authors":[],"date":"1999","doi":"10.1145\/316542.316545","raw":"Pirri, F. and Reiter, R. Some Contributions to the Metatheory of the Situation Calculus. Journal of the ACM, 46(2):261-325, 1999.","cites":null},{"id":43708349,"title":"Towards a Classification of Web Service Feature Interactions, In:","authors":[],"date":"2005","doi":"10.1007\/11596141_9","raw":"Weiss, M., Esfandiari, B., and Luo, Y. Towards a Classification of Web Service Feature Interactions, In: Proceedings of the Third International Conference on Service Oriented Computing (ICSOC05), Amsterdam, Netherlands , 2005.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2010-07","abstract":"This paper was presented at the 6th World Congress on Services, Miami, Florida, July 05-July 10 2010 and published in the proceedings.Feature interaction has been identified as a problem in the telecommunications domain in the 1980s, but since it has been shown to be a problem of systems that are composed of individually designed components. Clearly Web service composition is a way of building services from independently designed components and hence is subject to the same problem. This paper investigates the detection of feature interactions in Web services at runtime and proposes a novel detection method by taking inspiration from the Situation Calculus. Two case studies show that it is effective for detecting feature interactions in composite Web services.Peer-reviewedPost-prin","downloadUrl":"http:\/\/hdl.handle.net\/2381\/9660","fullTextIdentifier":"https:\/\/lra.le.ac.uk\/bitstream\/2381\/9660\/1\/2010-1.pdf","pdfHashValue":"c9d88cb847ba5df383d248ee9a8d539500240806","publisher":"Institute of Electrical and Electronics Engineers (IEEE)","rawRecordXml":"<record><header><identifier>\n        \n            \n                oai:lra.le.ac.uk:2381\/9660<\/identifier><datestamp>\n                2011-09-07T01:01:49Z<\/datestamp><setSpec>\n                com_2381_316<\/setSpec><setSpec>\n                com_2381_9549<\/setSpec><setSpec>\n                col_2381_4072<\/setSpec>\n            <\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:doc=\"http:\/\/www.lyncode.com\/xoai\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n            \nWeb Services Feature Interaction Detection based on Situation Calculus<\/dc:title><dc:creator>\nXu, Jiuyun<\/dc:creator><dc:creator>\nYu, Wengong<\/dc:creator><dc:creator>\nChen, Kun<\/dc:creator><dc:creator>\nReiff-Marganiec, Stephan<\/dc:creator><dc:subject>\nFeature Interaction<\/dc:subject><dc:subject>\nWeb services<\/dc:subject><dc:subject>\nInteraction Detection<\/dc:subject><dc:subject>\nSituation Calculus<\/dc:subject><dc:subject>\nOWL-S<\/dc:subject><dc:description>\nThis paper was presented at the 6th World Congress on Services, Miami, Florida, July 05-July 10 2010 and published in the proceedings.<\/dc:description><dc:description>\nFeature interaction has been identified as a problem in the telecommunications domain in the 1980s, but since it has been shown to be a problem of systems that are composed of individually designed components. Clearly Web service composition is a way of building services from independently designed components and hence is subject to the same problem. This paper investigates the detection of feature interactions in Web services at runtime and proposes a novel detection method by taking inspiration from the Situation Calculus. Two case studies show that it is effective for detecting feature interactions in composite Web services.<\/dc:description><dc:description>\nPeer-reviewed<\/dc:description><dc:description>\nPost-print<\/dc:description><dc:date>\n2011-09-06T10:48:01Z<\/dc:date><dc:date>\n2011-09-06T10:48:01Z<\/dc:date><dc:date>\n2010-07<\/dc:date><dc:type>\nConference paper<\/dc:type><dc:identifier>\nXu, Jiuyun; Yu, Wengong; Chen, Kun and Reiff-Marganiec, Stephan, 'Web Services Feature Interaction Detection Based on Situation Calculus', Services (SERVICES-1), 2010 6th World Congress on, pp.213-220<\/dc:identifier><dc:identifier>\n978-0-7695-4129-7<\/dc:identifier><dc:identifier>\n978-1-4244-8199-6<\/dc:identifier><dc:identifier>\nhttp:\/\/ieeexplore.ieee.org\/xpls\/abs_all.jsp?arnumber=5575833<\/dc:identifier><dc:identifier>\nhttp:\/\/hdl.handle.net\/2381\/9660<\/dc:identifier><dc:identifier>\n10.1109\/SERVICES.2010.27<\/dc:identifier><dc:language>\nen<\/dc:language><dc:rights>\n\u00a9 2010 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other users, including reprinting\/ republishing this material for advertising or promotional purposes, creating new collective works for resale or redistribution to servers or lists, or reuse of any copyrighted components of this work in other works.<\/dc:rights><dc:publisher>\nInstitute of Electrical and Electronics Engineers (IEEE)<\/dc:publisher>\n<\/oai_dc:dc>\n<\/metadata>\n        <\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2010,"topics":["Feature Interaction","Web services","Interaction Detection","Situation Calculus","OWL-S"],"subject":["Conference paper"],"fullText":"Web Services Feature Interaction Detection based on Situation Calculus \n \nJiuyun Xu\n1,2\n, Wengong Yu\n1\n, Kun Chen\n1\n \n1\nSchool of Computer and Communication Engineering \nChina University of Petroleum \nDongying, China \ne-mail: jyxu@upc.edu.cn; yuwengong@163.com; \nck_star@126.com \n \n2\nState Key Lab of Networking and Switching \nTechnology \nBeijing University of Posts and Telecom \nBeijing, China \n \nStephan Reiff-Marganiec \nDept. of Computer Science \nUniversity of Leicester \nLeicester, UK \ne-mail: srm13@le.ac.uk  \n \n \n \n \n \nAbstract \u2013 Feature interaction has been identified as a problem \nin the telecommunications domain in the 1980s, but since it has \nbeen shown to be a problem of systems that are composed of \nindividually designed components. Clearly Web service \ncomposition is a way of building services from independently \ndesigned components and hence is subject to the same problem. \nThis paper investigates the detection of feature interactions in \nWeb services at runtime and proposes a novel detection method \nby taking inspiration from the Situation Calculus. Two case \nstudies show that it is effective for detecting feature interactions \nin composite Web services. \n \nKeywords: Feature Interaction; Web services; Interaction \nDetection; Situation Calculus; OWL-S; \nI. INTRODUCTION \nFeatures as well as services are units of functionality which \nare correct on theire own, but when used in combination they \nmight influence their behavior in undesired ways. This \nproblem has been known as Feature Interaction, a term \ncoined by Bellcore in the late 1980s. The Feature Interaction \n(FI) problem [1, 2, 3] has become one of the important \nbottlenecks for the deployment of new services. FI is not a \nbug in the implementation of individual services but an \nemergent behavior if features are used in conjunction. \nHowever, the feature interaction problem is not limited to \ntelecommunications, it can occur in any software system that \nis subject to changes and build out of individually designed \ncomponents.  \nService-oriented architecture (SOA) holds the promise for \nbusinesses of allowing for quick adaptation of systems. Web \nservices are a way of encapsulating application functionality \nin a location and implementation transparent manner. \nHowever, if services are composed the potential feature \ninteraction arises. Akin to FI, Web services may interact with \neach other in unexpected and often undesirable ways \nnegatively affecting service quality and user satisfaction. [4] \ndescribes this as Web Services Feature Interaction (WSFI) \nproblem. \nInteraction is fundamental to Web services and service-\noriented architecture, and in general is desirable \u2013 however \nthere are situations that need to be avoided as they are \nundesirable. Feature interaction detection and resolution \nwould be concerned with the latter. While telecoms \nmarkets have traditionally been closed and tightly \ncontrolled, the FI problem was manageable due to in house \ndesign knowledge, small numbers of features and good \navailable of working details [5]. As the telecoms market \nbecame more open, the need for solutions to FI increased \nand new challenges were posed. The Web services market \nhas always been open, with many people providing \nservices that are supposed to work seamlessly together. \nHence lessons learned in telecomms, should be considered \nin the context of the WSFI problem. Predominately, the \ndetection and resolution of WSFI problem will become \nimportant to increase introduction of new services and the \nrobustness of composite services. \nThere has been plenty of work on the prevention, detection \nand resolution of FI in the telecommunication systems [3], \nbut the traditional detection methods are not suitable for \nthe problem in Web services as: (1) web services are not \ncentrally controlled and there is no global understanding of \nside effects and the operation of the services and (2) FI in \nWeb services is based on undesirable side effects such as \nan inconsistent states, or data inaccuracies rather than \ninconsistent events as is often the case in telecoms. \nHence there is a need for methods that operate at runtime \nto detect interactions which are caused by services \nencountering each other in their operation and producing \ndata based side effects that can lead to inconsistencies and \nviolation of assumptions.  \nThe rest of this paper is organized as follows: section 2 \nintroduces some related work, section 3 provides required \nbackground on the Situation Calculus and OWL-S. Section \n4 describes our online detection method in detail, including \nsome case studies. In sections 5 and 6, we discuss our \nmethod and conclude the paper. \nII. RELATED WORK \nIn the telecommunications domain feature interaction has \nlong been established as a problem leading to a slowdown \nin the introduction of new services. As a similar problem \ncan be seen in the area of web services, called Feature \nInteractions in Web Services (WSFI), a similar negative \nimpact on the introduction of new services can be expected. \nTraditional attempts to address the feature interaction \nproblem include offline method and online methods. Offline \nmethods are applied during design time or for web services \ncomposition time of services, online method are applied \nwhile the features or services are being executed. Offline \nmethods typically depend on the internal service logic \n(modeled at some level of abstraction). Online methods \neither use negotiation or feature interaction managers (FIM). \nNegotiation based approaches regard the components of the \nnetworks (user, terminal and value-added service, etc.) as \ndifferent intelligent entities and detect and resolve FI by \nexchanging intentions of those entities. The FIM method \nadds a FIM into the network to detect and resolve FI. A more \ndetailed overview of FI methods can be found in [3].  \nIn the existing work on feature interaction in Web services \nsome investigations have been conducted into offline \nmethods and have yielded some results. Weiss et al. [6] \npresents a goal-oriented approach for detecting feature \ninteractions among Web services. The authors also \ndistinguish explicitly between functional and non-functional \nfeature interactions. In [7] this is extended with emphasis on \nthe classification of feature interactions. Moreover, they \nanalyze the different types of the potential WSFI in a \n\"Virtual Bookstore\" scenario.  \nTurner [8] extends the feature notation CRESS to \ngraphically and formally describe Web services and service \ncomposition. Moreover, he briefly discusses the WSFI \ndetection using CRESS and a scenario notation called \nMUSTARD.  \nZhang et al. [9] propose a Petri net-based method to detect \nrace conditions, which can be seen as one type of functional \nfeature interactions. Moreover, in [4] they propose a multi-\nlayer WSFI detection system.  \nOffline methods require insight into the internal service \nlogic, details of which might not be publically available; \nfurthermore they require a knowledge of all available \nservices and cannot consider interactions that occur because \nof run-time data. Similar issues have driven online FI work \nin telecoms and we show that some types of interaction \ncannot be caught by offline methods. Moreover, in the Web \nservice arena the number of available services is very large, \ngrowing rapidly and services are offered by a large number \nof providers (a very open market), which does not lend itself \nmuch to offline methods.  \nBased on these observations we are proposing an \northogonal method, a runtime method based on Situation \nCalculus to detect FI in the Web services area. Our method \nanalyses the semantics of the interacting messages rather \nthan utilizing the internal information of service logic in \natomic services. The necessary details are obtained from \nOWL-S (Web Ontology Language for Services) service \ndescriptions and observed SOAP messages. \nIII. BACKGROUND \nOur detection method is based on the use of Situation \nCalculus and OWL-S. In this section, we briefly introduce \nthe Situation Calculus concentrating on the basic concepts \nof the language that will be used. For a more detailed \nintroduction we refer to [11, 12]. We also provide a \nconcise introduction to OWL-S, more information can be \nfound in [13].  \nA. Situation Calculus \nThe Situation Calculus is a many-sorted, first-order logical \nlanguage extended with induction. It is intended for \nrepresenting a dynamically changing world. The main idea \nis that any system can be defined by a fixed initial \nsituation. From any situation another situation can be \nreached through an action or an action set. The sorts S, A, \nF and D for situations, actions, fluents, and domain \nobjects, respectively. Situations represent a snapshot of the \nworld plus a history of the evolution. Actions are regarded \nas the only mean by which the world evolves from one \nsituation to another. Fluents are first-order functional terms \nwhich denote properties of the world that are static. For \nexample, the binary fluent  could mean that x is \nplaced on y. Fluent formulas are first-order formulas in \nwhich every atomic sub-formula is a fluent, e.g. the fact \nthat all objects x are on the table can be written as \n. The following are elements of the \nlanguage: \n: a constant denoting the initial situation, that is the \nstate of the world before anything has occurred. \n: for an action  and a situation  \n is the situation resulting from executing action  \nin situation . \n:  is true if and only if fluent or \nfluent formula  holds in a situation . \n:  is true if and only if it is \npossible to execute action  in situation . \n: is a binary predicate which represents a \npartial order between situations.  is true if and only if \nit is possible to reach situation  from  by executing a \npositive number of actions.  \nA particular domain is modeled by the definition of \nseveral axioms (informally we might call these \u201cdomain \nspecific fluents\u201d).  \nWe regard, as some other authors, a composite Web \nservice as a situation and execution of a Web service is \nregarded as an action. Before a service is executed, the \ncomposite service is in the initial state.  \nB. OWL-S \nOWL-S is the major description language for semantic web \nservices. It is based on an ontology of service concepts that \nsupply a Web service designer with a core for describing \nthe properties and capabilities of a Web service in an \nunambiguous computer-interpretable form.  \nOWL-S organizes a service description into four parts: \nthe process model, the profile, the grounding, and the \nservice. The OWL-S process model is most useful for the \nwork presented here, as it provides the required metadata \nabout the Web services. \nEach OWL-S process is based on an IOPR (Input, Output, \nPrecondition, Result) model. Input represent the information \nthat is required for the execution of the process, Output \nrepresents the information that the process returns to the \nrequester. Preconditions need to hold over Input for the \nprocess to be successfully invoked. Result allows to specify \ndetails about the (possible many) results. Each result can be \nassociated with a result condition, called inCondition, which \nspecifies when a particular result can occur. Therefore, an \ninCondition binds inputs to the corresponding outputs. It is \nassumed that such conditions are mutually exclusive, so that \nonly one result can be obtained for each possible situation. \nWhen an inCondition is satisfied, there are properties \nassociated that specify the corresponding output (withOutput \nproperty) and, possibly, the Effects (hasEffect properties) \nproduced by the execution of the process. Effects will \nbecome true when the service completes and will change the \nstate of the world. The OWL-S conditions (Preconditions, \ninConditions and Effects) are represented as logic formulas. \nIn our method, we firstly transform process descriptions \n(mainly Precondition and inCondition) into sets of rules \nexpressed in an ontology-aware rule language, namely \nSemantic Web Rule Language (SWRL) [14]. This is based \non the method presented in [15], which discusses this in \nmore detail. Then we define relevant predicates using the \nrules to express the composite Web services state. \nIV. THE METHOD \nOur method is used to detect Web service feature \ninteractions during the execution of the service \ncomposition. In this section, we present an overview of the \narchitecture and describe the detection process in detail.  \nTwo case studies show examples for the detection of the \ntwo conflict types that exist (the lack of resources to \ncomplete a latter part of a workflow and the attempt to \ninvoke a service whose pre-conditions are not met anymore \nafter an earlier service execution) and are detected.  \nA. The System Architecture  \nThe FI detection system interacts with three possibly \nexternal systems: (1) a standard workflow engine \nexecuting the service composition (the engine needs to \nallow for the interception of SOAP messages as well as \ntemporary blocking of the execution), (2) a feature \ninteraction rules manager and (3) a conflict resolver. The \nrules manager provides descriptions of the domain \nknowledge as to what constitutes an undesirable interaction \nand the conflict resolver provides a solution for recovering \nthe system from conflicts. Clearly the rules are not tied to a \nspecific instance, but are generic and there is a number of \nresolution strategies possible ranging from manual \nresolution via automatically applied priorities to possibly \nmore complex schemes. \n \n \nFig. 1: Overview of the architecture of the detection system \n \nWorkflow Execution Engine\nFeature Interaction Rule Manager\nConflict Resolver\nFI Detection System\nExtracted \nRules\nExpert Rules\nOWL-S Experts \nResolver\nSOAP Interceptor\nSOAP Extractor\nState Builder\nConflict Detector\nOperation and Service\nInformation\nApplicable Rules\nResolution\nConflict Description\nProgress Action\nSOAP Message\n[conflict]\nThe architecture is designed to support service interaction \ndetection during the execution of composite services. It \nallows for the detection of undesired interactions by \ndetecting conflicts between services that could lead to a \nfailure of the plan execution. Figure 1 provides an overview \nof the architecture and we will describe the main components \nnext. \nThe Soap Interceptor is in charge of intercepting the \nSOAP message for the detection system while services \ninteract in the workflow execution. Both SOAP request and \nSOAP response messages are intercepted and sent to the \ndetection system. The workflow systems execution is halted \nfor a brief period of time until a response comes from the \nInteraction detection system. If no conflicts was detected the \noriginal SOAP message will be sent with no changes, if \nconflicts were detected a new or adapted SOAP message \nmight be inserted into the system. Note that this type of \ninterception has proven to be realistic in telecommunications \nsystems, which tend to be extremely time critical [17]. \nThe SOAP Extractor parses the intercepted SOAP \nmessage to extract the input or output data (SOAP request \nand response respectively). The input and output data \ncontains information on the service and operation used as \nwell as the concrete data of the specific interaction. \nInformation regarding the service and operation are sent to \nthe FI rules manager so that applicable rules can be \nretrieved.  \nThe State Builder instantiates the relevant FI rules and \ngenerates relevant predicates to express the Web service \nstate. It uses the run-time data obtained extracted from the \nSOAP message and information about the service (from \nthe OWL-S document) which is provided by the FI rules \nmanager.  \nThe Conflict Detector is the core part of the detection \nsystem and identifies whether there is a conflict in the \ncurrent state. If conflicts are detected, the Conflict \nResolver is queried for a resolution. If no conflict is \ndetected the SOAP interceptor will notify the workflow \nengine to proceed; if a conflict was detected the resolution \nwill be transmitted back to the workflow engine which will \nreact accordingly.  \nThe Conflict Detector consists of three subsystems:  a \nKnowledge Base, an Inference Engine and a Management \nInterface. The Knowledge Base stores axioms of the world \nand reasoning rules, the Inference Engine is used to \ndetermine whether service states are consistent assuming \nthe domain knowledge and reasoning rules. The \nManagement Interface allows for human intervention, \nexperts can utilize the interface to add inference rules into \n \nFig. 2: Outline of the situation calculus based detection process  \nState Si-1\nPreconditions  and SOAPi Input \nP(x1,x2,\u2026)\u00d9Q(x1,x2,\u2026)\n\u2026\nW(z1,z2,\u2026)\nFacts from State Si-2\nP(x1,x2,\u2026)\u00d9Q(x1,x2,\u2026)\n\u2026\nW(z1,z2,\u2026)\nAdd Facts of Addlist Si-1\nDelete Facts same to Deletelist Si-1\nInConditions \nRules:\nH(x1,x2,\u2026)\u2192B(x1,x2,\u2026)\n...\nAddlist Si\nEffects from Si-1\nDeletelist Si\nEffects from Si-1 \nturn to be false\nWSi\nRestruct Facts \naccording to \nInConditions and \nSOAPi Output\nState Si\nFacts from State Si-1\nP(x1,x2,\u2026)\u00d9Q(x1,x2,\u2026)\n\u2026\nW(z1,z2,\u2026)\nAdd Facts of Addlist Si\nDelete Facts same to \nDeletelist Si\nAdd to\nService1 Servicei ServicenS0 Se\u2026\nOWL-Si\nPreconditions\nInConditionds\nEffects\nSOAPi request \nmessage\nInput\nSOAPi response \nmessage\nOutput\n\u2026\nthe Knowledge Base according to the requirement of new \nservices. Moreover, experts can control or adjust the \ndetection process through the interface. While ideally the \nprocess is automatic, in practice it is useful to have the \nmanual mechanisms available to increase detection accuracy \nin the light of unknown feature interactions.  \nIn addition, two more subsystems can be attached to the \nConflict Detector: an Interaction Information Base and an \nEvent Recorder. The Interaction Information Base is a library \nstoring information on all known services interaction \nphenomena [4, 12], which aids in detecting known \ninteractions more quickly and accurately. The contents of \nthis library will be periodically updated to contain new \nknowledge. The Event Recorder records the detection \nactivities and logs the related information to a database. \nExperts can analyze this to improve the detection process. \nB. Service Interaction Detection Process \nThe detection method is based on situation calculus. At the \nbeginning, the composite service is in the initial state. After \neach atomic service within the composite service is executed \n(that is an action is taken), we get a new service state (or \nsituation), and so on. If the former state is inconsistent with \nthe latter one, or some predicate (fluent or fluent formula) \nbecomes false we have identified a feature interaction. Figure \n2 outlines the detection of feature interactions based on \nsituation calculus.  \n  Figure 3 provides an overview of the detection process, \nwhich consists of six steps as follows: \nStep 1. In the first step the SOAP request or SOAP response \nmessage of the current service in the workflow execution \nengine is intercepted, processing is put on hold until a reply \nmessage is injected in the system. \nStep 2. We extract Preconditions, Effects and inConditions \nfrom the OWL-S document using Mindswap OWL-S API \n[16], which can conveniently read or write OWL-S \ndocument. This task is performed by the Feature Interaction \nRules Manager. The required data to invoke the functions is \navailable in the SOAP message as described earlier and is \ntransmitted in this step.  \nStep 3. This is the first key step in the detection process as it \nbuilds the service state information and prepares the \nextracted data and obtained rules for the detection phase. In \nmore detail, we require two state pools, a Former_state_pool \nand a Latter_state_pool. The former denotes the state before \nthe execution of the current service (initially this is the initial \nsituation ). The latter contains information of the state after \nexecuting the service, or in situation calculus terms \n(assuming action  to be the service execution and  to be the \ncurrent state) the state reached after . Before the \nservice is executed, Preconditions and input data from the \nSOAP request message generate facts (predicates whose \nvalues are definitely true); these are put into the \nFormer_state_pool. We also maintain two lists, called \nAddlist and Deletelist for storing the new predicates during \nthe execution process of the service. The new predicates \nwhose values are definitely true are put into Addlist, the \npredicates whose values change from true to false are put \ninto Deletelist. inConditions is used to generate FI rules. \nAfter the service is executed, FI rules affect the service \nstate and the state is changed according to Effects and the \noutput data from the SOAP response message. In \nparticular, we delete each predicate that occurs in both the \nDeletelist and the Former_state_pool from the latter. Then \nall remaining predicates from the Former_state_pool and \nall the predicates from the Addlist are added to the \nLatter_state_pool. The two state pools now represent two \nstates during the execution process of the service \ncomposition which will be evaluated in step 4.   \nStep 4. In this step we determine whether a Web service \nfeature interaction occurs. There are two situations that can \nlead to feature interaction (the two types of interaction \nmentioned earlier). One is that the Former_state_pool \ndoesn\u2019t satisfy the Preconditions of the current service. \nThe other is that Former_state_pool and Latter_state_pool \nare inconsistent. Using the Knowledge Base and the \nInference Engine, we identify whether either of the two \nsituations will occur.  \nStep 5. In this step information on newly detected \n \n \nFig. 3: The detection algorithm \n Former_state_pool is replaced with S0. \n Latter_state_pool is replaced with S1.\nFetch OWL-S document of current atomic service form \nthe composition service flow.\nGet SOAP request message and SOAP response message.\nNo\n Extract Preconditions, InConditions and Effects from \nOWL-S document,  extract Input data from SOAP request \nmessage and Output data from SOAP response message.\nState pool S0 is NULL\nState pool S1 is NULL\n \nInput satisfy \nPrecondition ?\nConflict\nY\ne\ns\nUse Input and Precondition to generate Facts.\nUse InConditionss to generate Rules\nAdd Facts to S0.\nUse Rules and Output to change the state.\n Predicates whose value turn to be false are put into Deletelist, \nnew predicates whose value turn to be true are put into Addlist.\nDelete each predicate from S0 which is the same as the predicate in Deletelist.\nAdd all the predicates in S0 to S1.\nAdd all the predicates in Addlist to S1.\nFetch one predicate from S0, denoted as P(x1,x2,\u2026,xn).\nxj,xk,\u2026,xm P(x1,x2,\u2026,xn) S\nOr xj,xk,\u2026,xm\nP(x1,x2,\u2026,xn) R1(X) R2(X) \u2026 Rn(X) Q(x1,x2,\u2026,xn) \nQ(x1,x2,\u2026,xn) S\nOr xj,xk,\u2026,xm Q(x1,x2,\u2026,xn) S  \nQ(x1,\u2026) Q1(X) \u2026 Qn(X) P(x1,\u2026)\nYes Conflict End\nN\no\nIs there any predicate in S0 \nthat hasn\u2019 t been fetched?\nN\no\nComposition service flow is \nfinished?\nY\ne\ns\nNormal\nNo Clear Addlist and Deletelist.\nEnd\nEnd\nYes\nStart\ninteractions is recorded in the Interaction Information Base, \nand the events are recorded to the log. This data helps with \nfuture detection. \nStep 6. If an interaction is detected the conflict resolver will \nbe queried to provide a solution. This step will lead to \ntransmitting progress information to the workflow execution \nengine and allow for the processing of the workflow to \ncontinue. \nC. Case Study  \nIn this section we present two scenarios to show how to carry \nout the detection process. Each example shows one of the \nkinds of feature interaction introduced earlier. \n \n1) Case study 1: A reservation service \nOne person wishes go to another place in the country to \nattend a conference and uses a reservation service to reserve \nan airline ticket and a hotel. The composed service consists \nof an airline ticket reservation service and a hotel reservation \nservice. Clearly the reservations include some form of \npayment and the respective payment features are here seen as \npart of the reservation service functionality. Here we only \nprovide the OWL-S description of the charge service, the \nother two perform the obvious functionality. Expected \nbehavior of a payment service occurs: the charge goes \nthrough if the card is not overdrawn; if the card is overdrawn, \nthe only output is a failure notification as the card limit \ncannot be exceeded. \n \n<process:AtomicProcess rdf:ID=\"Purchase\"> \n   <process:hasInput> \n      <process:Input rdf:ID=\"ObjectPurchased\"\/>    \n<\/process:hasInput> \n   <process:hasInput> \n      <process:Input rdf:ID=\"PurchaseAmt\"\/> \n   <\/process:hasInput> \n   <process:hasInput> \n      <process:Input rdf:ID=\"CreditCard\"\/> \n   <\/process:hasInput> \n   <process:hasOutput> \n      <process:Output rdf:ID=\"ConfirmationNum\"\/> \n   <\/process:hasOutput> \n   <process:hasResult> \n     <process:Result>         \n<process:hasResultVar>     \n<process:ResultVar rdf:ID=\"CreditLimH\">                    \n<process:parameterType   \nrdf:resource=\"&ecom;#Dollars\"\/> \n<\/process:ResultVar>  \n<\/process:hasResultVar>        \n<process:inCondition>    \n<expr:KIF-Condition>            \n<expr:expressionBody> \n             (and (current-value (credit-limit \n?CreditCard) ?CreditLimH)                   \n(>= ?CreditLimH ?purchaseAmt)) \n<\/expr:expressionBody>          <\/expr:KIF-\nCondition>  \n<\/process:inCondition>        <process:withOutput>  \n<process:OutputBinding>              \n<process:toParam \nrdf:resource=\"#ConfirmationNum\"\/>              \n<process:valueFunction \nrdf:parseType=\"Literal\">                 \n<cc:ConfirmationNum \nxsd:datatype=\"&xsd;#string\"\/> \n<\/process:valueFunction>           \n<\/process:OutputBinding> \n<\/process:withOutput>        <process:hasEffect>  \n<expr:KIF-Condition>            \n<expr:expressionBody> \n              (and (confirmed (purchase ?purchaseAmt) \n?ConfirmationNum)                   (own \n?objectPurchased)                   (decrease \n(credit-limit ?CreditCard) ?purchaseAmt))            \n<\/expr:expressionBody> \n<\/expr:KIF-Condition>  \n<\/process:hasEffect> \n    <\/process:Result> \n<\/process:hasResult> \n<\/process:AtomicProcess> \n \nLet us consider the core aspects of the interaction detection \n\u2013 clearly the whole process would be applied. \n \nThe composite service flow is as follows:  \n \nTi cket\nReser vat i on\nHot el\nReser vat i on\nS0 Se\n \n \nSuppose that the balance of the card can afford for either \nthe airport ticket reservation service or the hotel \nreservation service respectively, but cannot meet both \nsimultaneously. Further assume that both of the two \nreservation services do not exceed the consumption \nlimitation of the card. Four predicates are defined: \npredicate enoughMoney is used to denote that the \nremaining spent on the card is sufficient to afford the \nservice request; predicate noExceed denotes that the cost of \nthe service request will not exceed the consumption limit \nof the card; predicate notOverdrawn denotes that the card \nis not overdrawn and predicate chargeCard denotes the \ndecreases in available spending power. The FI rule is \ndistilled from the reservation service:   \n \nFI rule: \nkb:enoughMoney(?process:Balance,?process:PurchaseAmt) \u2227 \nkb: noExceed(?process:PurchaseAmt? process:CreditLimH) \n\u2192 \nkb:notOverdrawn(?process:CreditCard) \u2227 \nkb:chargeCard(?process:CreditCard,?process:PurchaseAmt)  \n \nThe service states for ticket reservation are shown in Table \n1. \n \nTABLE 1: SERVICE STATES FOR TICKET RESERVATION \nenoughMoney()\nnoExceed()\nenoughMoney()\nnoExceed()\nnotOverdrawn()\nFormer_state_pool Latter_state_pool\n  \n \nAfter the ticket reservation service is executed, we \nconclude that the two service states do not conflict. Then \nthe hotel reservation service is active. The Precondition of \nthe hotel reservation service is that the credit card can \nafford the hotel rent. But the balance of the card is now \ninsufficient due to having executed the ticket reservation \nservice (and of course the card is not allowed to be \noverdrawn). A feature interaction is detected, so the hotel \nreservation service is withdrawn. This case of feature \ninteraction is a type of resource deficit and is always \ndependent on the service data. \n \n2) Case study 2: Credit risk \nA credit bank provides a credit bank service. People can \nrequest the credit service on the condition that they are not in \nthe blacklist of the credit service. There is also a transfer \nservice, which allows to transfer loans to other people. \nSuppose that one person is qualified to request the credit \nservice, which they do before requesting the transfer service, \ntransferring the loan to person B. Now, further assume that \nperson B is in the blacklist of the credit service. Clearly this \nis a case of credit risk for the bank, or in technical terms this \nis a feature interaction. It is desirable to detect this feature \ninteraction and prevent for the credit risk to occur by \nremoving the interaction.  \nThe OWL-S description of identity validation and the  \ncredit service are as follows: \n \n<process:inCondition> \n   <expr:ConditionType> \n     <expr:expressionBody> \n       (identity-validate(?current-card ?Blacklist)) \n     <\/expr:expressionBody> \n   <\/expr:ConditionType> \n<\/process:inCondition> \n<process:withOutput> \n<process:OutputBinding> \n<process:toParam rdf:resource=\"#Qualification\"\/> \n<\/process:OutputBinding> \n<\/process:withOutput> \n<process:hasEffect> \n   <expr:ConditionType> \n     <expr:expressionBody> \n       (grant-qualification(?current-card)) \n     <\/expr:expressionBody> \n<\/expr:ConditionType> \n<\/process:hasEffect> \n \nThe Composite service flow is as follows: \n \nCr edi t  \nSer vi ce\nTr ansf er  \nSer vi ce\nS0 Se\n \nThe predicate notInBlacklist denotes people who request the \ncredit service are not in the blacklist of the service while \ninBlacklist denotes people who are in the blacklist of the \ncredit service. The blacklists are integral to the credit service \nand can only be obtained when the service is executed. The \npredicate isCreditIdentity denotes one person is a qualified \ncustomer of the credit service, while predicate creditTransfer \ndenotes credit identity transfers from one person to the other. \nPredicate creditIdentity denotes that a credit identity is \ngranted to one person. We can distill two rules from the two \nservices: FI rule 1 from credit service and FI rule 2 from \ntransfer service. \n \nFI rule 1: \nkb:notInBlacklist(?process:PersonA) \u2227 \nkb:Qualified(? process: Qualification) \u2192 \nkb:creditIdentity(?process:PersonA)  \n \nFI rule 2: \nkb:isCreditIdentity(?process:PersonA) \u2227 \nkb: Qualified(? process: Qualification) \u2192 \nkb:creditTransfer(?process:PersonA,?process:PersonB) \u2227 \nkb:creditIdentity(? process:PersonB)  \n \nThe service states before and after the credit service are \nshown in Table 2, while Table 3 shows the respective \nstates for the transfer service. \n \nTABLE 2. SERVICE STATES FOR CREDIT SERVICE  \nnotInBlacklist(PersonA)\ninBlacklist(PersonB)\nnotInblacklist(PersonA)\nisCreditIdentity(PersonA)\ninBlacklist(PersonB)\nFormer_state_pool Latter_state_pool\n \n \n \nTABLE 3. SERVICE STATES FOR TRANSFER SERVICE  \nnotInblacklist(PersonA)\nisCreditIdentity(PersonA)\ninBlacklist(PersonB)\nnotInblacklist(PersonA)\nisCreditIdentity(PersonA)\ninBlacklist(PersonB)\nisCreditIdentity(PersonB)\nFormer_state_pool Latter_state_pool\n \nFrom these tables it is obvious that the fact \ninBlacklist(PersonB) in the Former_state_pool conflicts \nwith the fact isCreditIdentity(PersonB) (informally these \ntwo mean that PersonB is not credit worthy while at the \nsame time being credit worthy) in the Latter_state_pool \nand hence a feature interaction is detected. \n  Note that the feature interaction is not a fault in the \nservice composition \u2013 in general the two services would \nhappily work with each other, but a situation that is caused \nby the data of the services which makes the specific flow \nundesirable. \nV. DISCUSSION \nAn effective method for detecting Web service feature \ninteraction is capable of detecting dynamically not only all \nkinds of specific known feature interactions, but also \nunknown feature interactions, in a uniform manner. \nAccording to this criterion, we present a Situation Calculus \nbased detection method. The method overcomes the \ndrawbacks of static detection method mostly employed in \nthe current research and the limitation of classification-\nbased approaches [6] which only allow for detecting \ninteractions that are known a-priori. Our approach has the \nfollowing beneficial properties: \n  1) The method presented is a runtime method for WSFI \ndetection. Being a runtime method has several advantages, \none of which is that it allows to work in an environment \nwhere new services might arrive and where there is no real \npotential for statically checking all possible combinations. \nSo, this method will also work if the executed services in \nthe workflow are dynamically identified and bound to. The \nactual service execution data is being used in the expression \nof service states.  \n  2) The presented method is especially effective for feature \ninteractions based on instance data of the effects, which \ncould include interactions related to security and privacy \nconcerns. Such feature interactions cannot be detected by \nstatic methods as the occurrence of the interaction depends \non instance data. As our method detects the interaction by \nfinding inconsistencies in the service state, data sensitive \ninteractions can easily be detected as long as the service \nprofile specifies the preconditions and effects of an \nindividual service correctly. \n  3) The method avoids full exploration of large state spaces \nas it only considers services that are actually invoked \ntogether rather than all possible combinations of services and \nfurthermore only looks at inconsistency of the service state. \nIn that way, independent of the number of atomic services \ninvolved in the service composition, we only need to \nconsider two states: one state before an atomic service is \nbeing executed and the state after that execution. The \nrespective state pools might contain a large number of terms \nfor each instance, but that data would need to be considered \nanyhow; however the state pools are renewed after each \ndetection step, meaning that the information considered is \nlocal to the services of current interest.  \n     As far as feature interaction is concerned there is a \ngeneral perception that approaches in feature interaction \nattempt to statically determine the absence of a feature \ninteraction. However, as also shown in [3], the field of \nfeature interaction research is quite wide and there exist run-\ntime approaches that attempt to deal with the problem by \ndetecting interactions and resolving them during system \nexecution time. These approaches have inspired this work, as \nthey are particularly adept at dealing with large numbers of \nservices from different providers that might encounter each \nother for the first time when the system is running. \nVI. CONCLUSION AND FUTURE WORK \nWith the rapid development of Web services and growing \nuse of composite services Web services feature interaction \nwill become a growing obstacle. While some researchers \nhave started to address feature interaction in the web services \ndomain, results are still very limited. By using the semantics \nof Web services and inspiration from the situation calculus, \nwe proposed a novel framework and method to detect and \nallow for resolution of feature interactions in web services at \nexecution time.  \nIn future work, we intend to investigate how to \ndecentralize the detection system. We also will test our \nsystem against more complex case studies to better evaluate \nefficiency and accuracy of the method. As this paper focused \nmostly on the feasibility of the approach in terms of detecting \ninteractions, we are planning a more detailed evaluation of \nperformance \u2013 clearly an important consideration for a run-\ntime approach. \nVII. ACKNOWLEDGMENT \nThis work is jointly supported by the National Natural \nScience Foundation of China (No.60672121), National \nKey Basic Research Program of China (973 Program) \n(2009CB320406) and the Foundation for Innovative \nResearch Groups of the National Natural Science \nFoundation of China (Grant No. 60821001). \nVIII. REFERENCES \n[1]  Blair, L., Blair, G., Pang, J., and Efstratiou, C. Feature Interaction \nOutside a Telecom Domain. In: Proceedings of the Workshop on \nFeature Interactions in Composed Systems (ECOOP'2001) 15-20, \n2001. \n[2]  Amyot, D. and Logrippo, L. Guest Editorial: Directions in Feature \nInteraction Research. In: Computer Networks, Special Issue on \nFeature Interactions in Emerging Application Domains 45 5, 563-\n567, 2004. \n[3]  Calder, M., Kolberg, M., Magill, E.H. and Reiff-Marganiec, S. \nFeature interaction: a critical review and considered forecast. \nInternational Journal of Computer Networks. 41: pp. 115-141, 2003. \n[4]  Zhang, J., Yang, F., and Su, S. Detecting the Web Services Feature \nInteractions. In K. Aberer et al. (Eds.): WISE 2006, LNCS 4255, pp. \n169-174, 2006. \n[5]  Magill, E.H.. Feature Interactions: Old Hat or Deadly New Menace? \nIn: K. Turner, E. Magill and D. Marples (Eds.), Service Provision: \nTechnologies for Next Generation Communications, Wiley, pp. 235-\n252, 2004. \n[6]  Weiss, M. and Esfandiari, B. On Feature Interactions among Web \nServices. In: Proceedings of the International Conference on Web \nServices (ICWS), IEEE, 2004. \n[7]  Weiss, M., Esfandiari, B., and Luo, Y. Towards a Classification of \nWeb Service Feature Interactions, In: Proceedings of the Third \nInternational Conference on Service Oriented Computing \n(ICSOC05), Amsterdam, Netherlands , 2005. \n[8]  Turner, K.J. Formalising Web Services. In: Proceeding of Formal \nTechniques for Networked and Distributed Systems (FORTE \nXVIII), LNCS 3731, 473-488, 2005. \n[9]  Zhang, J., Su, S., and Yang, F. Detecting Race Conditions in Web \nServices, In Proceedings of the International Conference on Internet \nand Web Applications and Services (ICIW'06), 2006. \n[10] Zhang, J., Yang, F., Shuang, K., and Su, S. Immune-Inspired Online \nMethod for Service Interactions Detection. In Jan van Leeuwen et \nal. (Eds.): SOFSEM 2007, LNCS 4362, pp. 808-818, 2007. \n[11] Pirri, F. and Reiter, R. Some Contributions to the Metatheory of the \nSituation Calculus. Journal of the ACM, 46(2):261-325, 1999.  \n[12] R. Reiter. Knowledge in Action: Logical Foundations for Describing \nand Implementing Dynamical Systems. MIT Press, 2001. \n[13] OWL-S: Semantic Markup for Web Services, \nhttp:\/\/www.w3.org\/Submission\/OWL-S\/. \n[14] Horrocks, I., Patel-Schneider, P.F., Bechhofer, S. and Tsarkov, D.: \nOWL rules: A proposal and prototype implementation. J. of Web \nSemantics 3 (2005), pp.23-40. \n[15] Redavid, D., Iannone, L., Payne, T. and Semeraro, G. OWL-S \nAtomic Services Composition with SWRL Rules. Lecture Notes in \nComputer Science: Foundations of Intelligent Systems, vol. 4994, \npp. 605-611, 2008.  \n[16] MINDSWAP: Maryland Information and Network Dynamics Lab \nSemantic Web Agents Project, OWL-S API. \nhttp:\/\/www.mindswap.org\/2004\/owl-s\/api\/. \n[17] Turner, K.J., Reiff-Marganiec, S., Blair, L., Pang, J., Gray, T., Perry, \nP. and Ireland, J. Policy Support for Call Control. Computer \nStandards and Interfaces, vol 28\/6 pp 635-649, 2006. \n \n"}