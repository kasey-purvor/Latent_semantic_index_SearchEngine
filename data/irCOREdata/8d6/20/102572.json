{"doi":"10.1109\/INM.2007.374720","coreId":"102572","oai":"oai:epubs.surrey.ac.uk:2057","identifiers":["oai:epubs.surrey.ac.uk:2057","10.1109\/INM.2007.374720"],"title":"An algorithm to detect packet forwarding misbehavior in mobile Ad-Hoc networks","authors":["Gonzalez, OF","Howarth, MP","Pavlou, G"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007","abstract":null,"downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:2057<\/identifier><datestamp>\n      2017-10-31T14:04:06Z<\/datestamp><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:656C656374726F6E6963656E67696E656572696E67:63637372<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/2057\/<\/dc:relation><dc:title>\n        An algorithm to detect packet forwarding misbehavior in mobile Ad-Hoc networks<\/dc:title><dc:creator>\n        Gonzalez, OF<\/dc:creator><dc:creator>\n        Howarth, MP<\/dc:creator><dc:creator>\n        Pavlou, G<\/dc:creator><dc:date>\n        2007<\/dc:date><dc:type>\n        Conference or Workshop Item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/2057\/1\/SRF002159.pdf<\/dc:identifier><dc:identifier>\n          Gonzalez, OF, Howarth, MP and Pavlou, G  (2007) An algorithm to detect packet forwarding misbehavior in mobile Ad-Hoc networks  In: 10th IFIP\/IEEE International Symposium on Integrated Network Management, 2007-05-21 - 2007-05-25, Munich, GERMANY.     <\/dc:identifier><dc:relation>\n        http:\/\/ieeexplore.ieee.org\/xpls\/abs_all.jsp?arnumber=4258611<\/dc:relation><dc:relation>\n        10.1109\/INM.2007.374720<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/2057\/","http:\/\/ieeexplore.ieee.org\/xpls\/abs_all.jsp?arnumber=4258611","10.1109\/INM.2007.374720"],"year":2007,"topics":[],"subject":["Conference or Workshop Item","PeerReviewed"],"fullText":"An Algorithm to Detect Packet Forwarding\nMisbehavior in Mobile Ad-Hoc Networks\nOscar F. Gonzalez, Michael Howarth, George Pavlou\nCenter for Communications Systems Research\nUniversity of Surrey\nGuildford, UK\nAbstract-Devices in a Mobile Ad Hoc network (MANET) may\nmisbehave by dropping packets that are forwarded in the\nnetwork, for example because they are malicious and deliberately\nintend to disrupt the network, or because they are selfish and\nwish to conserve their own limited resources such as power. In\nthis paper, we present a mechanism that enables the detection of\nnodes that exhibit packet forwarding misbehavior. We present\ninitial evaluation results that demonstrate the operation of our\nalgorithm and show that it effectively detects nodes that drop a\nsignificant fraction of packets.\nKeywords-mobile ad hoc network, misbehavior detection,\npacketforwarding.\nI. INTRODUCTION\nThe wireless nature and inherent features of mobile ad hoc\nnetworks make them vulnerable to a wide variety of attacks by\nmisbehaving nodes. Such attacks range from passive\neavesdropping, where a node tries to obtain unauthorized\naccess to data destined for another node, to active interference\nwhere malicious nodes hinder network performance by not\nobeying globally acceptable rules. Misbehavior can be divided\ninto two categories [1]: routing misbehavior (failure to behave\nin accordance with a routing protocol) and packet forwarding\nmisbehavior (failure to correctly forward data packets in\naccordance with a data transfer protocol). In this paper we\nfocus on the latter type of misbehavior. Our approach consists\nof an algorithm that enables packet forwarding misbehavior\ndetection through the principle offlow conservation [3]. Our\nscheme is not tightly coupled to any specific routing protocol\nand, therefore, it can operate regardless of the routing strategy\nadopted. Our criterion for judging a node is the estimated\npercentage of packets dropped, which is compared against a\npre-established misbehavior threshold. Any node dropping\npackets in excess of this threshold is deemed a misbehaving\nnode while those below the threshold are considered to be\ncorrectly behaving.\nIn this paper we first present a framework and an algorithm\nand protocol that deal with this attack. We then demonstrate\nthrough simulations that an appropriate selection of the\nmisbehavior threshold allows for a good discrimination\nbetween misbehaved and well-behaved nodes in a network that\nis affected by black hole attacks, where malicious nodes drop\nall packets they receive, and\/or gray hole attacks, where they\ndrop packets selectively or in a probabilistic manner in an\nattempt to circumvent the security measures in place.\nSection II of this paper describes our algorithm for packet\nforwarding misbehavior detection, and Section III presents an\ninitial performance evaluation. Finally, the paper is\nsummarized in Section IV.\nII. DETECTING PACKET FORWARDING MISBEHAVIOR\nOur work provides a novel approach to securing the data\nforwarding functionality in mobile ad hoc networks. We\npropose an approach that takes advantage of the principle of\nflow conservation in a network. This states that all\nbytes\/packets sent to a node, and not destined for that node, are\nexpected to exit the node. In this Section we first present, from\na theoretical point of view, how this principle works assuming\nit is implemented in an ideal network, and then we demonstrate\nthat by making some reasonable assumptions and adaptations,\nour algorithm can cope with the practical problems that are\nencountered in real M\\ANETs.\nA. The Principle ofFlow Conservation\nWe formally introduce the principle of flow conservation\nover an ideal static network model:\n* Let v; be a node such that vj E V, whereVF= tV1, V2, V3 ...\nVN} is the set of all nodes in the network, N is the total\nnumber ofnodes in the network, andj= 1, 2, 3 ... N.\n* Let Uj be the subset of nodes in the network which are\nneighbors of vj, i.e. Uj is the neighborhood of vj. It follows\nthat v; 0 U) and also U) c V.\n* Let At be the period oftime elapsed between two points in\ntime to and t1 such that At = t1 - to.\n* Let Tij be the number of packets that node vi has\nsuccessfully sent to node vj for vj to forward to a further\nnode; vi E Uj, vj E Ui, i.j and Tij(to) = 0.\n* Let Rij be the number of packets that node vi has\nsuccessfully received from node vj that did not originate at\nv,; vi E U,, v; E Ui, i -,zj and R,,(to) = 0.\nIf all nodes vj E V remain static for a period of time At\nduring which no collisions occur in any of the transmissions\nover an ideal (noiseless) wireless channel, then for a node vj:\n1-4244-0799-0\/07\/$25.00 t2007 IEEE 813\nAuthorized licensed use limited to: University of Surrey. Downloaded on May 12,2010 at 09:18:15 UTC from IEEE Xplore.  Restrictions apply. \n(1)iR,J(tl)= ViT\nVilviE=Uj VilviE=Uj\nThis equation states the fundamental premise of the flow\nconservation principle in an ideal static network, and is applied\nto packets rather than individual bytes. It states that if all\nneighbors of a node v; are queried for i) the amount of packets\nsent to v; to forward and ii) the amount ofpackets forwarded by\nvj to them, the total amount of packets sent to and received\nfrom v; must be equal.\nIn practice M\\ANETs exhibit conditions that are far from\nideal. First of all, the wireless channel is error prone and\npackets get lost while in transit. Secondly, collisions happen\nwhen the network uses protocols where nodes have to compete\nfor the medium, such as when the link layer protocol is based\non the distributed coordination function (contention period) of\nthe IEEE 802.11 a\/b standard. In order to allow equation (1) to\nhold our algorithm requires the use of a reliable M\\AC protocol\nsuch as IEEE 802.11, M\\ACA [4] or M\\ACAW [5], and the rest\nof this paper assumes that such a reliable MIAC protocol is\nused.\nA reliable M\\AC protocol at the link layer acknowledges\neach successfully transmitted packet and thus transmitter and\nreceiver can maintain synchronized values of their metrics Tij\nand Ri1. The use of a reliable MAC protocol in conjunction with\nthe conservation of flow principle means that we are not\nsusceptible to problems that arise when overhearing other\nnodes' transmissions. Thus, problems such as ambiguous\ncollisions, receiver collisions, and the ability of a node to\ncontrol its transmission power, which affect the approaches\nproposed in [1] and [2], do not exist in our approach.\nAmbiguous collisions occur when a node v1 is trying to\ndetermine if another node v2 is properly forwarding a packet. It\nmay happen that node v2 forwards the packet to a further node\nV3, which is out of the transmission range of vl, while a second\ntransmission prevents v1 from overhearing the forwarded\npacket, thus v1 will not know if the packet was forwarded. On\nthe other hand, in the receiver collision problem v2 forwards\nthe packet to V3 at which point a collision occurs. Node v1 is\nunaware of such a collision and assumes that the packet was\nforwarded even if v2 does not attempt a retransmission.\nAnother common problem is caused by nodes capable of\ncontrolling their transmission power. Thus, v2 can transmit with\nenough power for v1to overhear but not enough power for V3 to\nreceive it, leaving v2 unaware of the situation. All these\nweaknesses, which can be used by malicious nodes to disrupt\nthe network, are due to the fact that overhearing is used by\nnodes to check for misbehavior in other nodes. In our\nalgorithm the nodes that maintain statistics that are used to\ndetermine whether the forwarding was properly made are the\nnodes actively involved in the transmission process, i.e. the\ntransmitter and the receiver of each transmission.\nHowever, a node may exhibit malicious behavior even if it\nis not purposefully doing so. For example, an overloaded node\nmay temporarily lack the CPU cycles, buffer space or\nbandwidth to forward packets [2]. In addition, some reactive\nrouting protocols, e.g. AODV, cause buffered packets to be\ndropped if they go through a path that is even temporarily\nunavailable. For these reasons equation (1) cannot be applied in\na rigorous manner and a threshold needs to be established to\naccount for packets dropped by a node through no fault of its\nown. Equation (2) reflects this change:\n(2)(I -ahreshold ) E Ri )< Ei,b\nVilviE=Ui VilviE=Ui\nThe Ct*hreshold factor can take values between 0 and 1 and as\nwe shall see plays an important role in the detection power of\nour proposed algorithm, i.e. the capability of the algorithm to\ndetect misbehaving nodes. The lower athreshold iS the more likely\nit is that our algorithm detects any malicious behavior.\nHowever, it also means that the probability of a false detection\nincreases. A false detection occurs when the result of a single\nevaluation of a node mistakenly determines that the node\nappears to be misbehaving. Therefore, fine tuning is required to\nreach a fair point in this tradeoff.\nB. Algorithm\nIn MANETs the neighborhood U, of a node v; changes\ndynamically over time, making it difficult to determine those\nnodes that have transmitted or received packets to or from a\nnode vj. Our scheme overcomes this problem by means of a\nlimited broadcast that tracks down nodes that have been in\ncontact with node vj. The core parts of our algorithm are\ndetailed in the pseudocode shown in figure 1. A node vi\nmaintains a table with two metrics T,, and R11, which contains\nan entry for each node vj to which vi has respectively\ntransmitted packets to or received packets from. Node vi\nincrements T,, on successful transmission of a packet to v; for v;\nto forward to another node, and increments Rij on successful\nreceipt of a packet forwarded by vj that did not originate at vj.\nAll nodes in the network continuously monitor their\nneighbors and update the list of those they have heard recently\n(Fig. 1 .a). If the ID of an overheard node is not included in the\ntable of overheard nodes a new entry is created. Otherwise, the\nexisting entry is updated with a timestamp corresponding to the\ntime the node was last overheard. Upon the creation of a new\nentry, a node schedules a task\/event to check the behavior of\nthe node whose ID has been saved in the new entry. Nodes\nrandomly select a period of time between T , and Tmax to\nschedule the behavior checking task. This random selection\nseeks to reduce the possibility of two or more nodes starting a\nbehavior check on the same node at the same time, wasting\nnetwork bandwidth, battery energy and other network\nresources.\nWhen a scheduled task is triggered in node Vk to check vy's\nbehavior (Fig. 1.b), node Vk broadcasts a metrics request packet\n(MREQ) with TTL = 1 in the IP header. An MREQ includes\nthe ID of the node emitting the request (SRC ID), the ID of the\nnode whose behavior is to be checked (CHIJK ID), an\nMREQ_ID and a timestamp indicating the time at which the\ntask was triggered. The MREQID is used in the same way as\nin some routing protocols which base their route discovery\nphase on broadcasting. If a node sees an MREQ that has the\nsame MREQ_ID and SRC ID of a packet seen before, the\nMREQ is dropped. This technique prevents flooding packets\nfrom traversing a zone of the network more than once. The\ntimestamp, on the other hand, is used to resolve conflicts when\n814\nAuthorized licensed use limited to: University of Surrey. Downloaded on May 12,2010 at 09:18:15 UTC from IEEE Xplore.  Restrictions apply. \ntwo nodes start a behavior check on the same node at almost\nthe same time. In such cases, nodes can see which of the\npackets corresponds to the earlier triggered task and disregard\nthe other. This does not require accurate synchronization of the\nnodes' clocks; approximate synchronization is all that need be\nassumed.\na. OVERHEARING\nifnode Vk overhears a node vj E Uk\nifnode vj is not in Vk 's table ofoverheard nodes\n. add node vj to Vk 's table ofoverheard nodes\n. schedule an event to check vj's behavior\n. else\n. update last time node vj was heard\n. endif\nendif\nb. INITIATE BEHAVIOR CHECK\nif in node Vk an event to check node vj's behavior is triggered\n* send a metrics requestpacket (MREQ) with node vj 's ID\n* schedule another event to check vj's behavior again at t+Tmax\nendif\nc. REQUEST HANDLING\nifnode Vk receives a metrics requestfor node vj\nifnode Vk has node vj in its table ofoverheard nodes\n. rebroadcast metrics request packet (MREQ)\n. reschedule any event to check vj's behavior\ni.fnode Vk has metricsfor node vj\n. . send a metrics reply (MREP) back to the requesting node\n. . endif\n. else\n. ignore request\n. endif\nendif\nd. REPLY HANDLING\nifa request was sent out\n-while there are more replies to be receivedfor node vj\n. receive reply\n. add received metrics to totals\n. endwhile\nbroadcast of the MREQ is to go, instead of leaving this task to\nthe IP protocol. Thus, every MREQ travels only one hop at a\ntime, and is then analyzed and rebroadcast if the protocol so\ndetermines. By following this algorithm, our protocol is\ncapable of tracking down nodes that have been in contact with\nthe checked node, as illustrated in Figure 2. We assume\ntransmissions can be overheard by vertically, horizontally and\ndiagonally adjacent nodes. In the Figure, node V7 iS first in\nposition a where it can be overheard by nodes v1, V2, V3, V6, V8,\nVI], V12 and v13. Each of these nodes makes an entry in their\ntable of overheard nodes when V7 first transmits and each of\nthem schedules a task to check its behavior. At some point in\ntime, V7 decides to move following the path depicted in Figure\n2 coming in contact with nodes v14, v17, v18, v19, v20, v23, v24 and\nv25. It finally stops in position b. In the Figure the scheduled\nbehavior check initiation task (Fig. l.b) in v8 is the first to be\ntriggered and the limited broadcast commences. All nodes that\nhave overheard node V7 re-broadcast the MIREQ, whereas\nnodes such as v4, vg and v15 also receive the MIREQ but ignore\nit because they have not overheard node V7.\nrq 'I \":4\n0~~~~\"\n115\nI,\nJI7\nI~~~~~~~~~~~~~~~~~(D\nO Nodes hzat have overheaid v7 V Nodes hzat have not overheaid v7\n| Analyzednode v7 - Node's route LizitedMREQ broadcast\nif ZR< aXhhld ZE1\nVivjE=iU ViVEU\nnode vj is misbehaving (detection)\nelse\nnode vj is not misbehaving (non-detection)\nendif\nendif\nFigure 1. Our algorithm pseudocode.\nThe handling of requests (Fig. l.c) is the heart of our\nlimited broadcast algorithm. When a node receives an MREQ it\nfirst checks ifthe CHK ID is in its table of overheard nodes; if\nit is not the node ignores the MREQ and discards the check.\nHowever, if the CHK ID appears in its table then it\nrebroadcasts the MREQ with TTL = 1 in the IP header. Setting\nthe TTL to one allows our algorithm to control how far the\nFigure 2. Example of limited broadcast to track down nodes that have\noverheard node V7.\nOnce a node has decided whether to continue or not\nbroadcasting a MREQ, it reschedules any pending task to\ncheck the behavior of the checked node specified in the\nCHK ID field of the MREQ. The new behavior checking task\nis scheduled in the same way as when a new entry is made in\nthe table of overheard nodes, i.e. a period of time is randomly\nselected between T and Tmax. In this way if the random\nselection is uniformly distributed and the average frequency\nwith which an active node's behavior is checked is:\n2\navg freq (\n- (Tmin + Tnma, ) \/2 (Tnin + Tnmax )\n(3)\nThe last step a node takes when it receives a MREQ is to\ncheck if it has any metrics (Rij or Tij) relating to the node being\n815\nI\nAuthorized licensed use limited to: University of Surrey. Downloaded on May 12,2010 at 09:18:15 UTC from IEEE Xplore.  Restrictions apply. \nchecked. If any of the metrics has a value other than zero the\nnode returns a metrics reply packet (MIREP) (Fig. l.c)\ncontaining the metrics, but if the value of both metrics is zero\nthen the node does not send back any response. In our scheme\nthe task of finding a route back to the node that originated the\nMREQ has been left to the underlying routing protocol.\nReply handling is executed in the node that initiated the\nMREQ. This node, v8 in Fig. 2, waits for a period of time in\norder to give all nodes with metrics about the checked node the\nopportunity of replying. When the time expires, the node\nchecks the behavior of the analyzed node by verifying that\nequation (2) holds (Fig. l.d). If it does not, it flags the checked\nnode as a misbehaving one; this is a detection. Using a single\ndetection to accuse a node is not sufficient since such an\nalgorithm may lead to false accusations against correctly\nbehaving nodes. A scheme in which multiple detections by\ndifferent nodes are necessary to accuse a node is fairer to well-\nbehaved nodes, while keeping a high probability of correctly\naccusing misbehaving nodes. Thus, a system whose goal is to\naccuse misbehaving nodes, perhaps in order to punish them by\nwithdrawing their right to transmit on the network, could use\nan approach similar to the distributed consensus mechanism\nproposed in SCAN [1].\nIII. EVALUATION\nWe perform our simulations using the GloMoSim\nsimulation package. The results presented for each value are\nthe average of 5 simulation runs. Our simulation parameters\ntake the following values: i) The number of nodes in the\nnetwork is 20, ii) Nodes are placed over an area of 200 x 200\nsquared meters, iii) Nodes move according to the random\nwaypoint mobility model with a constant speed of 10ms-', iv)\nThe pause time takes a value that is exponentially distributed\nwith mean 30 seconds, v) the wireless transmission range of\nevery node is 100 meters, vi) the link capacity is 2 Mbps, vii)\nthe MAC layer protocol is the IEEE 802.11 DCF, viii) the\nunderlying routing protocol is AODV, and ix) the total\nsimulation time for each scenario is 300 seconds. The network\nwas set-up with 25% of nodes misbehaving by not forwarding\nall packets. Nodes check the behavior of active nodes within a\nperiod chosen uniformly between 15 and 30 seconds, and keep\nany overheard node in their tables for 60 seconds after the last\ntime they are heard. The principal metric in our tests is the\npercentage of detections, which is assessed in terms of\nmisbehavior threshold.\nWe consider the precision of our misbehavior detection\nalgorithm in terms of the misbehavior threshold, which is the\nparameter \u00b0Chreshold in equation (2), i.e. the maximum percentage\nof packets that a node is allowed to drop without being\ndetected as a misbehaving node. In order to see properly the\neffect of the misbehavior threshold on nodes, simulations were\ncarried out with nodes dropping packets with probabilities of\n0%, 10%, 20%, 50% and 700O while the misbehavior threshold\nwas varied from 00\/ to 100%.\nFigure 3 depicts the percentage of detections as a function\nof the misbehavior threshold for nodes exhibiting different\nprobabilities of misbehavior. It can be inferred from the graph\nthat the criterion to select an adequate misbehavior threshold\ndepends on the level oftrust required in the network. The lower\nthe threshold is the more packets nodes need to forward to be\nconsidered well-behaved. However, since characteristics\ninherent to MANETs such as mobility and the noisy wireless\nmedium can cause some packets to be lost (including packets\nof our own protocol), it also means that an increasing number\nof correctly behaving nodes can be falsely detected as\nmisbehaving ones. Finally, it can also be seen from Fig. 3 that\nselecting a misbehavior threshold equal to a node's\nmisbehaving probability prevents our approach from\nidentifying misbehaving nodes with certainty, i.e. the\nprobability of detection is approximately 50%. These\noccurrences are all contained in the zone between 400\/ and\n60% probability of detection in the figure.\n100\n90\nu)\na\n.r\nco\nIL\n80\n70\n60\n50\n40\n30\n20\n10\n0 10 20 30 40 50 60 70 80 90 100\nIncreasing Misbehavior Threshold, Uth-hold\nFigure 3. Percentage of positive detections as a function of the increasing\nmisbehavior threshold (mean node speed= lOms-1).\nIV. SUMMARY\nIn this paper we have presented an algorithm that is capable\nof detecting packet forwarding misbehavior. The algorithm\ndoes not require high density networks in which many nodes\ncan overhear each others' received and transmitted packets, but\ninstead uses statistics accumulated by each node as it transmits\nto and receives data from its neighbors.\nV. REFERENCES\n[1] H. Yang, J. Shu, X. Meng, and S. Lu, \"SCAN: Self-organized network-\nlayer security in mobile ad hoc networks,\" IEEE Journal on Selected\nAreas in Communications, vol. 24, issue 2, pp. 261-273, February 2006.\n[2] S. Marti, T. J. Giuli, K. Lai, and M. Baker, \"Mitigating Routing\nMisbehavior in Mobile ad hoc networks,\" Proceedings of the 6th ACM\nInternational Conference on Mobile Computing and Networking, pp.\n255-265, August 2000.\n[3] K. A. Bradley, S. Cheung, N. Puketza, B. Mukherjee, and R. A. Olsson,\n\"Detecting disruptive routers: a distributed network monitoring\napproach,\" Proceedings of the 1998 Symposium on Security and\nPrivacy, pp. 115-124, May 1998.\n[4] P. Karn, \"MACA- a new channel access method for packet radio,\"\nARRL\/CRRL Amateur Radio gth Computer Networking Conference, pp\n134-240, September 1990.\n[5] V. Bharghavan, A. Demers, S. Shenker, and L. Zhang, \"MACAW: A\nMedia Access Protocol for Wireless LANs,\" Proceedings of the ACM\nSIGCOMM Conference on Communications Architectures, Protocols\nand Applications, vol. 24, issue 4, pp. 212-225, 1994.\n816\nAuthorized licensed use limited to: University of Surrey. Downloaded on May 12,2010 at 09:18:15 UTC from IEEE Xplore.  Restrictions apply. \n"}