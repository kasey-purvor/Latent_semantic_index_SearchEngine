{"doi":"10.1016\/j.entcs.2005.04.031","coreId":"102418","oai":"oai:epubs.surrey.ac.uk:1877","identifiers":["oai:epubs.surrey.ac.uk:1877","10.1016\/j.entcs.2005.04.031"],"title":"Tank monitoring: a pAMN case study","authors":["Schneider, Steve","Hoang, Thai Son","Robinson, Ken","Treharne, Helen"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2005-07-21","abstract":"<p>The introduction of probabilistic behaviour into the B-Method is a recent development. In addition to allowing probabilistic behaviour to be modelled, the relationship between expected values of the machine state can be expressed and verified. This paper explores the application of probabilistic B to a simple case study: tracking the volume of liquid held in a tank by measuring the flow of liquid into it. The flow can change as time progresses, and sensors are used to measure the flow with some degree of accuracy and reliability, modelled as non-deterministic and probabilistic behaviour respectively. At the specification level, the analysis is concerned with the expectation clause in the probabilistic B machine and its consistency with machine operations. At the refinement level, refinement and equivalence laws on probabilistic GSL are used to establish that a particular design of sensors delivers the required level of reliability.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1877<\/identifier><datestamp>\n      2017-10-31T14:03:30Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1877\/<\/dc:relation><dc:title>\n        Tank monitoring: a pAMN case study<\/dc:title><dc:creator>\n        Schneider, Steve<\/dc:creator><dc:creator>\n        Hoang, Thai Son<\/dc:creator><dc:creator>\n        Robinson, Ken<\/dc:creator><dc:creator>\n        Treharne, Helen<\/dc:creator><dc:description>\n        <p>The introduction of probabilistic behaviour into the B-Method is a recent development. In addition to allowing probabilistic behaviour to be modelled, the relationship between expected values of the machine state can be expressed and verified. This paper explores the application of probabilistic B to a simple case study: tracking the volume of liquid held in a tank by measuring the flow of liquid into it. The flow can change as time progresses, and sensors are used to measure the flow with some degree of accuracy and reliability, modelled as non-deterministic and probabilistic behaviour respectively. At the specification level, the analysis is concerned with the expectation clause in the probabilistic B machine and its consistency with machine operations. At the refinement level, refinement and equivalence laws on probabilistic GSL are used to establish that a particular design of sensors delivers the required level of reliability.<\/p><\/dc:description><dc:date>\n        2005-07-21<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1877\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Schneider, Steve, Hoang, Thai Son, Robinson, Ken and Treharne, Helen  (2005) Tank monitoring: a pAMN case study   Electronic Notes in Theoretical Computer Science, 137 (2).  pp. 183-204.      <\/dc:identifier><dc:relation>\n        10.1016\/j.entcs.2005.04.031<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1877\/","10.1016\/j.entcs.2005.04.031"],"year":2005,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"REFINE 2005 Preliminary Version\nTank monitoring: a pAMN case study\nSteve Schneider 1\nDepartment of Computing, University of Surrey, UK\nThai Son Hoang\nSchool of Computer Science and Engineering\nUniversity of New South Wales, Australia\nKen Robinson\nSchool of Computer Science and Engineering\nUniversity of New South Wales, Australia\nHelen Treharne\nDepartment of Computing, University of Surrey, UK\nAbstract\nThe introduction of probabilistic behaviour into the B-Method is a recent develop-\nment. In addition to allowing probabilistic behaviour to be modelled, the relation-\nship between expected values of the machine state can be expressed and verified.\nThis paper explores the application of probabilistic B to a simple case study: track-\ning the volume of liquid held in a tank by measuring the flow of liquid into it. The\nflow can change as time progresses, and sensors are used to measure the flow with\nsome degree of accuracy and reliability, modelled as non-deterministic and proba-\nbilistic behaviour respectively. At the specification level, the analysis is concerned\nwith the expectation clause in the probabilistic B machine and its consistency with\nmachine operations. At the refinement level, refinement and equivalence laws on\nprobabilistic GSL are used to establish that a particular design of sensors delivers\nthe required level of reliability.\nKey words: Probabilistic B, refinement, formal methods,\nprobabilistic predicate transformers.\n1 Email: S.Schneider@surrey.ac.uk\nThis is a preliminary version. The final version will be published in\nElectronic Notes in Theoretical Computer Science\nURL: www.elsevier.nl\/locate\/entcs\nSchneider, Hoang, Robinson, and Treharne\n1 Introduction\nThe B-Method [Abr96a] provides a framework for the development of provably\ncorrect systems, based on the weakest precondition semantics of the Gener-\nalised Substitution Language (GSL), and structured around the concept of\nAbstract Machines.\nThe introduction of probabilistic behaviour into the B-Method has recently\nbeen proposed [HJR+03], called probabilistic B. This approach builds on pre-\nvious work which introduces probabilistic choice into program statements, and\nextends the notion of weakest precondition semantics to deal with expectations\n[MMS96]. An expectation can be considered as the expected value of a for-\nmula or expression. Thus programs can be viewed as expectation transformers\nrather than predicate transformers, and their semantics gives the expectation\nof an expression after the program has been executed in terms of expectations\nprior to execution.\nIn addition to allowing such probabilistic behaviour into programs, prob-\nabilistic B introduces expectations on aspects of the state, in addition to the\nexisting parts of a B machine. Thus the relationship between the expected val-\nues of several components of the machine state can be expressed and formally\nverified.\nThis paper explores the application of probabilistic B to a simple case\nstudy: tracking the volume of liquid held in a tank by measuring the liquid\nflow into it. The flow can change as time progresses. Sensors with a given\nreliability are used to measure the flow and provide information to the system,\nso there is a small probability that the sensors will fail, giving an incorrect\nreading. The behaviour of the sensors is described using probabilistic B. We\ninclude the tank explicitly in our model so that we can describe the relationship\nbetween the actual volume of liquid it contains and our system\u2019s measurement\nfor it. As well as probabilistic behaviour, our system exhibits nondeterministic\nbehaviour in the reading that a failed sensor will give, and (after the first\nscenario we consider) in the reading that a correctly working sensor will give:\nany value from a particular range. Thus the case study also explores the\ninteraction between probabilistic and nondeterministic behaviour.\nThe case study is concerned with two stages of the development process:\nspecification, and refinement. At the specification level we are concerned with\nobtaining bounds on the accuracy of the system\u2019s value for the volume of\nliquid in the tank, given a particular level of reliability for the combination\nof sensors providing the readings. This analysis will be concerned with the\nexpectation clause in the probabilistic B machine. At the refinement level, we\nare concerned with establishing that a particular combination of sensors does\nindeed deliver the required level of reliability. This analysis will make use of\nrefinement and equivalence laws on probabilistic GSL.\n2\nSchneider, Hoang, Robinson, and Treharne\n2 Introducing Probability\n2.1 Probabilistic GSL\npGSL is an extension of GSL to include a probabilistic choice statement:\nprog1 p\u2295 prog2\nAn execution of this choice will execute prog1 with probability p, and will\nexecute prog2 with probability 1 \u2212 p. See [Mor98,MM04,MMH03] for a full\nintroduction to pGSL.\nTo give a semantics to pGSL programs, we make use of expectations:\nbounded non-negative real-valued functions of the state space. These are\ngenerally expressed as formulas over the state variables. The weakest pre-\nexpectation semantics for a program prog maps an expectation exp to another\nexpectation [prog ]exp, analogous to weakest precondition semantics. It gives\nthe expected value for exp after prog in terms of expectations on the state\nbefore. The language and its semantics from [Mor98] is given in Figure 1.\nIn this paper we will use a derived operator (also given in [Abr96a]) for\nassigning to a variable some element from a set S chosen nondeterministically.\nWe define\nx :\u2208 S =\u0302@y .(y \u2208 S =\u21d2 x := y)\nThus\n[x :\u2208 S ]exp =(min x | x \u2208 S .exp)\nWe will also use a derived operator (also given in [MM04]) for expressing\na minimum probability on a choice. We define\nprog1 >p\u2295 prog2 =\u0302 @q .(p 6 q 6 1) =\u21d2 prog1 q\u2295 prog2\nThis program chooses prog1 with a probability of at least p.\nThe operator is useful for describing systems with a minimum required\nreliability. If a component is required to behave correctly at least 90% of the\ntime, then this may be described as correct >0.9\u2295 incorrect . This would be\nrefined by a component that behaves correctly at least 95% of the time, for\nexample.\n2.2 Some pGSL laws\nThe semantics supports a collection of algebraic laws concerning the various\noperators. An extended collection of laws is given in Appendix A.3 of [MM04].\nThe following laws from that Appendix will be used in this paper:\nLaw 13:\n(prog1 >p\u2295 prog2); prog3 =(prog1; prog3) >p\u2295 (prog2; prog3)\nLaw 24:\n(prog1 >pq\u2295 prog2)= prog1 >p\u2295 (prog1 >q\u2295 prog2)\n3\nSchneider, Hoang, Robinson, and Treharne\nThe probabilistic generalised substitution language pGSL acts over expectations\nrather than predicates. Expectations are bounded non-negative real-valued\nfunctions of the state space, with the exception that when dealing with miracles\nthey can take a formal value \u221e.\n[x := E ]exp exp[E\/x ]\n[x , y := E ,F ]exp exp[E ,F\/x , y ]\n[pre | prog ]exp \u3008pre\u3009 \u00d7 [prog ]exp, where 0\u00d7\u221e =\u0302 0\nprog1[]prog2 [prog1]expmin[prog2]exp\n[pre =\u21d2 prog ]exp 1\/\u3008pre\u3009 \u00d7 [prog ]exp, where \u221e\u00d7 0 =\u0302\u221e\n[skip]exp exp\n[prog1 p\u2295 prog2]exp p \u00d7 [prog1]exp + (1\u2212 p)\u00d7 [prog2]exp\n[@y .pred =\u21d2 prog ]exp (min y | pred .[prog ]exp)\nprog1 \u2291 prog2 [prog1]exp \u21db [prog2]exp for all exp.\n\u2022 exp is an expectation\n\u2022 pre is a predicate (not an expectation)\n\u2022 \u3008pre\u3009 denotes predicate pre converted to an expectation, here restricted to the\nunit interval: \u3008false\u3009 is 0 and \u3008true\u3009 is 1.\n\u2022 \u00d7 is multiplication.\n\u2022 prog , prog1, prog2 are probabilistic generalised substitutions.\n\u2022 p is an expression over the program variables (possibly but not necessarily con-\nstant), taking a value in [0, 1].\n\u2022 x is a variable.\n\u2022 y is a variable or a vector of variables.\n\u2022 E is an expression.\n\u2022 F is an expression, or a vector of expressions.\n\u2022 exp1 \u21db exp2 means that exp1 is everywhere no more than exp2.\nFig. 1. pGSL\u2014the probabilistic Generalised Substitution Language [Mor98]\nWe also make use of the following law, which we will call Law A:\nprog2 \u2291 prog1\u21d2 prog1 >p\u2295 prog2 = prog1 p\u2295 prog2\n4\nSchneider, Hoang, Robinson, and Treharne\nflow\nvolume\nFig. 2. The tank system\n2.3 Probabilistic B\nThere are two aspects to the introduction of probabilistic behaviour into a B\nmachine as proposed in [HJR+03]. The first is to allow operations to be con-\nstructed using probabilistic GSL, so probabilistic choices can be made within\noperations. The second is to introduce an expectation clause into a B machine\nin order to express requirements on various expectations on the state. An ex-\npectation clause will in general contain a collection of expectation expressions.\nThis clause plays a role for expectations analogous to the invariant clause on\npredicates on the state. The associated proof obligations are that every op-\neration, from any legitimate state (i.e. any state that meets the invariant),\nmust not decrease any of the expectations.\nEach expectation is of the form e \u21db V , meaning that the expected value\nof V is always at least the value of e initially. The new proof obligations\nassociated with each such expectation are the following:\nP1 Initialisation must establish the lower bound of the invariant:\ne \u21db [Init ]V\nP2 Each operation must not decrease the expected value of V :\nV \u21db [Op]V\nIn this paper we will use expectations of the form V . This is an abbre-\nviation for 0 \u21db V . Observe that this still gives rise to a non-trivial proof\nobligation P1, that V is non-negative on initialisation.\n3 The Tank\nThe system we aim to model is a tank being filled with a liquid. The liquid\nflows into the tank through a pipe. We wish to track the volume of liquid in\nthe tank. This is illustrated in Figure 2.\nThe tank can be modelled using the machine given in Figure 3 2 . This\ndescribes a model of the real tank, and will therefore be included in the speci-\nfications we will give, so that we can relate the state of the monitoring system\nto the real state of the tank.\n2 An explanation of the ascii form of pGSL used in Figure 3 and elsewhere in this paper is\ngiven in Appendix A\n5\nSchneider, Hoang, Robinson, and Treharne\nMACHINE Tank\nCONSTANTS minflow, maxflow\nPROPERTIES minflow : REAL & maxflow : REAL\n& minflow > 0\n& maxflow >= minflow\nVARIABLES flow, volume\nINVARIANT flow : REAL & volume : REAL\nINITIALISATION volume := 0 || flow :: [minflow,maxflow]\nOPERATIONS\ntock = flow :: [minflow,maxflow] || volume := volume + flow\nEND\nFig. 3. The AMN description of the tank system\nHere we assume that in one time unit (as represented by tock), the volume\nof liquid increases by the value of flow . The value of flow can itself be any\nvalue between minflow and maxflow , and can change on every time step.\nAn interval of real numbers between l and h is denoted [l , h]. The interval\n[x + l , x + h] is abbreviated x + [l , h].\n4 A monitoring system\n4.1 The first simple system\n4.1.1 Specification\nWe wish to produce a software system that tracks the volume of liquid in the\ntank to some level of accuracy. The system we require can be specified using\nthe probabilistic B machine VolumeTracker1 of Figure 4. (The expectation\nmakes use of values of A and B that will be given later.) For this first example,\nwe take a simple approach where a single poll operation updates both the tank\nand the monitoring system state at the same time. Later in the paper we will\nconsider the separation of system updates from tank updates.\nOur first specification, VolumeTracker1, requires that a state update is\nperfectly accurate at least 99% of the time. Otherwise (i.e. up to 1% of\nthe time) it can be completely arbitrary over the range of possible readings\n[minflow ,maxflow ].\nThe system maintains a single state variable rvolume, which contains the\nvalue the system has for the volume of liquid in the tank. Thus our specifica-\ntion will be concerned with the relationship between rvolume and the actual\nvolume volume.\nIt is natural to have two expectations to provide a range on what the ex-\npected value for volume can be, given a particular value for the expected value\nof rvolume. Because rvolume and volume are increased on each step with some\nvalue from a fixed range of possible values, we consider expectations as linear\ncombinations of rvolume and volume. Thus they would be of the form:\n6\nSchneider, Hoang, Robinson, and Treharne\nMACHINE VolumeTracker1\nINCLUDES Tank\nVARIABLES rvolume\nINVARIANT rvolume : REAL\n& rvolume * (minflow\/maxflow) <= volume\n& volume <= rvolume * (maxflow \/ minflow)\nEXPECTATION E1: rvolume - A * volume,\nE2: B * volume - rvolume\nINITIALISATION rvolume := 0\nOPERATIONS\npoll = T: tock\n|| V1a: (rvolume := rvolume+flow\n0.99 (+)\nV1b: rvolume :: rvolume+[minflow,maxflow] )\nEND\nFig. 4. The VolumeTracker1 machine\nE1: rvolume \u2212 A\u00d7 volume\nE2: B \u00d7 volume \u2212 rvolume\nThese must both be non-negative, so we can deduce for the expected values\nthat\nrvolume\/B 6 volume 6 rvolume\/A\nThus given an expected value for rvolume we have a range for the expected\nvalue of volume. The required degree of accuracy as given by A and B will\nnaturally emerge as part of the specification.\nSince both E1 and E2 must be greater than 0, and non-decreasing on every\noccurrence of poll , we obtain some constraints on the possibilities for A and\nB .\nObserve that any absolute restrictions on the relationship between volume\nand rvolume will appear in the invariant. In particular, the lower and upper\nbounds on volume for any given value of rvolume are given by the following\ninequalities:\nrvolume \u00d7 (minflow\/maxflow) 6 volume 6 rvolume \u00d7 (maxflow\/minflow)\nThis will always be true, so it is included in the invariant. However, it does\nnot provide a very tight relationship between volume and rvolume.\n4.1.2 Deriving A and B\nFor VolumeTracker1 to meet its proof obligations, we require that the expec-\ntations will never decrease on any call of the operation poll , from any state.\n7\nSchneider, Hoang, Robinson, and Treharne\nWe can carry out some calculations to derive conditions for A and B to\nachieve this. We require that E1 \u21db [poll ]E1 and E2 \u21db [poll ]E2. Thus we\nrequire that for any flow , volume, and rvolume, we must have that ([poll ]E1)\u2212\nE1 > 0 and ([poll ]E2)\u2212 E2 > 0.\nWe calculate the requirement on A from the requirement on E1:\n([poll ]E1)\u2212 E1= ([T || (V 1a 0.99\u2295 V 1b)]E1)\u2212 E1\n= ([(T || V 1a) 0.99\u2295 (T || V 1b))]E1)\u2212 E1\n= (0.99\u00d7 [T || V 1a]E1 + 0.01\u00d7 [T || V 1b]E1)\u2212 E1\n(\u2217)= (0.99\u00d7 (rvolume + flow \u2212 A(volume + flow))\n+0.01\u00d7 (rvolume +minflow \u2212A(volume + flow)))\n\u2212(rvolume \u2212 A.volume)\n= 0.99\u00d7 (flow \u2212 A\u00d7 flow) + 0.01(minflow \u2212 A\u00d7 flow)\n= (0.99\u2212A)\u00d7 flow + 0.01\u00d7minflow\nSince this must be non-negative everywhere (i.e. for all possible values of\nflow), we obtain that\nA 6 0.99 + 0.01(minflow\/flow)\nfor any value of flow . The bound takes its minimal value when flow ismaxflow ,\nso we obtain that\nA 6 0.99 + 0.01(minflow\/maxflow)\nThus the closer to 1 the ratio between minflow and maxflow , the closer\nA can be to 1 and the more accurate the upper bound on the expected value\nfor volume for any given expectation on rvolume. However, note that A can\nalways be at least 0.99.\nFor B we perform the following calculation:\n([poll ]E2)\u2212 E2= ([T || (V 1a 0.99\u2295 V 1b)]E2)\u2212 E2\n= ([(T || V 1a) 0.99\u2295 (T || V 1b))]E2)\u2212 E2\n= (0.99\u00d7 [T || V 1a]E2 + 0.01\u00d7 [T || V 1b]E2)\u2212 E2\n(\u2217\u2217)= (0.99\u00d7 (B(volume + flow)\u2212 (rvolume + flow))\n+0.01\u00d7 (B(volume + flow)\u2212 (rvolume +maxflow)))\n\u2212(B .volume \u2212 rvolume)\n= 0.99\u00d7 (B .flow \u2212 flow) + 0.01(B .flow \u2212maxflow)\n=B \u00d7 flow \u2212 0.99\u00d7 flow \u2212 0.01\u00d7maxflow\nWe require that this is non-negative for any value of flow . Thus B > 0.99 +\n0.01(maxflow\/flow) for any value of flow . The largest value for the expression\n(i.e. the largest lower bound for B) is given when flow = minflow , and we\nobtain\nB > 0.99 + 0.01(maxflow\/minflow)\n8\nSchneider, Hoang, Robinson, and Treharne\nObserve lines (*) and (**) concerning the evaluation of [T || V 1b] with\nrespect to an expectation. Since V 1b is nondeterministic in the assignment to\nrvolume, the minimum expectation over all possible assignments to rvolume\nmust be taken. In E1, rvolume is positive, so the smallest possible value of\nrvolume is used in the calculation of the pre-expectation of E1. In E2 rvolume\nis negative so the largest possible value of rvolume is used in the calculation\nof the pre-expectation of E2. This means that however the nondeterminism\nis later resolved, the expectation will be at least the value calculated. Expec-\ntations should always be non-decreasing, so demonic nondeterminism always\nconsiders the worst case with respect to increases.\n4.1.3 Example\nAs an illustration, we shall consider some concrete numbers: if minflow = 100\nand maxflow = 400, then we obtain A 6 0.9925 and B > 10.03. Thus we\nknow that\n(100\/103)\u00d7 rvolume 6 volume 6 rvolume \u00d7 (400\/397)\nThis implies for example that\n0.97\u00d7 rvolume 6 volume 6 10.03\u00d7 rvolume\nso if we have a requirement for 97% accuracy, this will be met.\nHowever, if our requirement is for 99% accuracy, this will not be met. The\ndescription cannot ensure that 0.99 \u00d7 rvolume 6 volume. This is because\nan incorrect reading, that could occur with probability 0.01, could be wrong\nby a factor of 4, leading to a large increase of rvolume over the real value of\nvolume. The level of accuracy is concerned not only with the probability of\ncorrect readings, but also with the amount by which a flawed reading could\nbe out.\nTo ensure 99% accuracy we would either have to reduce the ratio between\nminflow and maxflow (so bad readings cannot be so wildly out), or decrease\nthe probability of a bad reading. Observe that these alterations are concerned\nonly with the specification machine. This machine gives the probability of an\naccurate reading that is required for ensuring the expectations.\n4.1.4 Implementation\nOur first implementation of VolumeTracker1 will make use of two sensors,\nwhich provide readings for the flow, and also give diagnostic information stat-\ning whether they are broken or not. We will firstly consider sensors which\ncan fail on any particular reading independently of any other reading. We will\nconsider sensors which have a reliability of at least 90%. We will need to make\nuse of two of these, Sensor1a and Sensor1b to give readings to 99% accuracy.\nSensor1b is given in Figure 5, and Sensora1 is entirely similar.\n9\nSchneider, Hoang, Robinson, and Treharne\nMACHINE Sensor1b\nSEES Tank\nOPERATIONS\nsf, st <-- poll1b =\nS1bl: sf := flow || st := ok\n>=0.9 (+)\nS1br: sf :: [minflow,maxflow] || st := broken\nEND\nFig. 5. A Sensor machine\nIMPLEMENTATION VolumeTracker1I\nREFINES VolumeTracker1\nIMPORTS Tank, Sensor1a, Sensor1b, Context\nVARIABLES rvolume\nINVARIANT rvolume : REAL\nINITIALISATION rvolume := 0\nOPERATIONS\npoll = VAR v1, v2, st1, st2, rflow\nIN\nP1a: v1,st1 <-- poll1a;\nP1b: v2,st2 <-- poll1b;\nF: rflow <-- flow(v1,st1,v2,st2);\nR: rvolume := rvolume + rflow;\nT: tock\nEND\nEND\nFig. 6. The implementation VolumeTracker1I\nWe propose an implementation VolumeTracker1I ofVolumeTracker1 which\nuses two sensors in order to obtain a more reliable reading of the flow. This\nis given in Figure 6, and makes use of the Context machine of Figure 7.\nObserve that the implementation contains its own variable rvolume. To\navoid complicating this example with imported state, we relax the normal\nrestriction that implementation machines cannot have their own state.\nWe need to prove that the poll operation in the implementation is a refine-\nment of the poll operation in the specification. This can be done by manipu-\nlating the probabilistic choices using the laws of [MM04] given in Section 2.2.\nThe poll operation in VolumeTracker1I of Figure 6 is of the particular form\nP1a; P1b; F ; R; T , where the variables v1, v2, st1, st2, rflow are all local.\nWe show that this operation is equivalent to poll given in the specification\nmachine VolumeTracker1, as follows:\nP1a; P1b; F ; R; T\n10\nSchneider, Hoang, Robinson, and Treharne\nMACHINE Context\nOPERATIONS\nff <-- flow(v1,st1,v2,st2) =\nPRE v1 : REAL & v2 : REAL\n& st1 : STATUS & st2 : STATUS\nTHEN\nF: IF st1 = broken & st2 = broken THEN ff :: [minflow,maxflow]\nELSIF st1 = broken & st2 = ok THEN ff := v2\nELSIF st1 = ok & st2 = broken THEN ff := v1\nELSIF st1 = ok & st2 = ok THEN ff := (v1+v2)\/2\nEND\nEND\nFig. 7. The AMN description of flow calculation\n= {expanding P1a and P1b}\n(S1al >0.9\u2295 S1ar);\n(S1bl >0.9\u2295 S1br); F ; R; T\n= {Law 13}\nS1al ; (S1bl >0.9\u2295 S1br); F ; R; T\n>0.9\u2295\nS1ar ; (S1bl >0.9\u2295 S1br); F ; R; T\n= {Law 13}\n(S1al ; S1bl ; F ; R; T >0.9\u2295 S1al ; S1br ; F ; R; T )\n>0.9\u2295\n(S1ar ; S1bl ; F ; R; T >0.9\u2295 S1ar ; S1br ; F ; R; T )\n= {standard program algebra in each branch; removal of local variables}\n(V 1a \u2016 T >0.9\u2295 V 1a \u2016 T ) >0.9\u2295 (V 1a \u2016 T >0.9\u2295 V 1b \u2016 T )\n= {idempotence of >p\u2295 on left-hand argument}\nV 1a \u2016 T >0.9\u2295 (V 1a \u2016 T >0.9\u2295 V 1b \u2016 T )\n= {Law 24}\n(V 1a \u2016 T >0.99\u2295 V 1b \u2016 T )\n= {Law A, since V 1b \u2291 V 1a}\n(V 1a \u2016 T 0.99\u2295 V 1b \u2016 T )\nThus we arrive at the operation poll given in the machine VolumeTracker1.\nThis demonstrates that VolumeTracker1I indeed provides an implementation\nof VolumeTracker1.\n4.1.5 Summary\nThis first example has illustrated several points:\n\u2022 The expected value of the machine expectation expression should be non-\ndecreasing on every occurrence of the operation.\n11\nSchneider, Hoang, Robinson, and Treharne\n\u2022 However, the actual value of the machine expectation expression can de-\ncrease on some operation calls (provided its expected value does not).\n\u2022 Expectations can be used to express a relationship between the expected\nvalues of state variables, in our case providing a range for the expected value\nof volume in terms of the expected value of rvolume. This is checked as part\nof machine consistency, and is independent of any particular implementa-\ntion.\n\u2022 The accuracy of the approximation rvolume to the tank value volume de-\npends not only on the probability of an incorrect reading, but also on the\nratio between minflow andmaxflow , since this affects the maximum possible\nerror in rvolume.\n\u2022 Probabilistic operations can be implemented using combinations of proba-\nbilistic components (sensors) in the way we would expect. Such implemen-\ntations need only be checked for refinement against the machine descriptions\nof the operations. The machine consistency checks ensure that the machine\noperations provide the overall requirements on the expectations.\n4.2 Introducing error margins\n4.2.1 Specification\nIn the previous example, correct readings of flow were exactly accurate. We\nnow allow for a margin of error in readings of flow . Specifically, the error can\nbe any value in the range [lowerror , higherror ]. Typically the possibility of\nno error at all should be within the range, so lowerror will be negative and\nhigherror will be positive. The revised machine is given in Figure 8.\nThe calculation of appropriate A and B follows the same pattern as shown\npreviously in Section 4.1.2. Now two sources of nondeterminism must be\ntaken into account: the reading of the sensors in V 2a (which can be most\npessimistic with regard to E1 when flow is low) and the arbitrary reading\nin V 2b (which can be most pessimistic for E1 when flow is high). This\ncombination of considerations (recall lowerror is negative, so A 6 1) means\nthat A is bounded above by both of the following values:\n1 + (lowerror\/minflow)\nand\n0.99 + (lowerror\/maxflow) + 0.01(minflow\/maxflow)\nFor example, if minflow = 100, maxflow = 400, and lowerror = \u221210, then the\nfirst value is lower, and we obtain A = 0.9. On the other hand, if lowerror =\n\u22120.1, then the second value is lower and we obtain A = 0.9915. In the first\ncase the possible error in any reading of the flow is 10% of minflow , so the\nworst case occurs when the flow is minflow and minflow + lowerror is added\nto rvolume: the resulting rvolume could be 10% out. On the other hand,\n12\nSchneider, Hoang, Robinson, and Treharne\nMACHINE VolumeTracker2\nINCLUDES Tank\nCONSTANTS lowerror, higherror\nPROPERTIES lowerror : REAL & lowerror <= 0\n& higherror : REAL & higherror >= 0\nVARIABLES rvolume\nINVARIANT rvolume : REAL\nEXPECTATION E1: rvolume - A * volume,\nE2: B * volume - rvolume\nINITIALISATION rvolume := 0\nOPERATIONS\npoll =\nT: tock\n|| V2a: rvolume :: rvolume+flow+[lowerror,higherror]\n0.99 (+)\nV2b: rvolume :: rvolume+[minflow+lowerror,maxflow+higherror]\nEND\nFig. 8. The AMN description of the second monitoring system\nin the second case the error in the flow can be at most 0.1%, so the error\nthat can be introduced by V 2b (1% of the time) dominates, and the worst\ncase occurs when the flow is maxflow and rvolume is only incremented by\nlowerror +minflow .\nSimilar considerations for the expectation E2 yield that the value obtained\nfor B is the maximum of the following two values, the first for the case where\nflow = maxflow and the second when flow = minflow .\n1 + (higherror\/maxflow)\nand\n0.99 + (higherror\/minflow) + 0.01(maxflow\/minflow)\nIn this case, the second value will always be higher, and hence will give the ap-\npropriate value for B , since maxflow\/minflow > 1, and higherror\/minflow >\nhigherror\/maxflow . This informs us that the worst case always occurs with\na flow of minflow , and an incorrect reading of maxflow + higherror . This is\nworse than the worst outcome that can be obtained with a flow of maxflow ,\nas far as ensuring that E2 does not decrease is concerned.\n4.2.2 Implementation: sensors\nThe error is likely to have been included in the specification because the\nsensors introduce some error. We can include these errors within the sensor\ndescriptions, resulting in a new version of sensor description. For example, in\nSensor2b we will take the error range to be [le2b, he2b]. The resulting sensor\n13\nSchneider, Hoang, Robinson, and Treharne\nMACHINE Sensor2b\nSEES Tank\nCONSTANTS le2b, he2b\nPROPERTIES le2b : REAL & le2b <= 0\n& he2b : REAL & re2b >= 0\nOPERATIONS\nsf, st <-- poll2b =\nS2bl: sf :: flow+[le2b,he2b] || st := ok\n>=0.9 (+)\nS2br: sf :: [minflow+le2b,maxflow+he2b] || st := broken\nEND\nFig. 9. The machine Sensor2b\nis given in Figure 9.\nThe implementation VolumeTracker2I will be the same asVolumeTracker1I ,\nexcept that it now importing Sensor2a (with error range [le2a, he2a]) and\nSensor2b, instead of the original sensors. It is given for reference in Figure B.1\nof Appendix B.\nObserve that in this scenario two sensors working correctly might not agree\non their readings. In this case the context machine specifies that the average\nof the two readings should be taken.\nThe machine VolumeTracker2I provides an implementation of poll , pro-\nvided that the following hold: that [le2a, he2a] \u2286 [lowerror , higherror ] and\n[le2b, he2b] \u2286 [lowerror , higherror ]. In other words, that the error ranges for\neach sensor are within those given in VolumeTracker2 for the overall combi-\nnation. The proof of this is given in Appendix B.\n4.2.3 Summary\nThis second example illustrates several points:\n\u2022 We can specify error ranges for readings of flow .\n\u2022 Such ranges have an impact on the expectations that will be non-decreasing\non operations: the nondeterminism in the state updates means that the\nrelationship between rvolume and volume will be weaker.\n\u2022 The particular relationships that can be guaranteed between volume and\nrvolume depend on the error ranges of readings and also on the the ratio of\nmaxflow to minflow . Each of these dominates in some cases.\n\u2022 The flow readings can be implemented by sensors whose errors are within\nthe specified range.\n14\nSchneider, Hoang, Robinson, and Treharne\nMACHINE Sensor3c\nSEES Tank\nCONSTANTS le3c, he3c\nPROPERTIES le3c : REAL & le3c <= 0\n& he3c : REAL & re3c >= 0\nOPERATIONS\nsc <-- poll3c =\nsc :: flow+[le3c,he3c]\n>=0.9 (+)\nsc :: [minflow+le3c,maxflow+he3c]\nEND\nFig. 10. A sensor without diagnostics\n4.3 Removing sensor diagnostics\nWe now consider the situation where the sensors do not provide explicit status\ninformation. In this case the only way faulty readings can be identified is by\ncomparison with other readings.\nIn this example we will work from the sensors to the specification: we will\nderive the specification that the combination of sensors delivers.\n4.3.1 Implementation: sensor\nA sensor without diagnostic information about its status is given in Figure 10.\nIt provides only a flow reading, without any information about its state.\nTo be tolerant to one faulty reading, we need three sensors: Sensor3a,\nSensor3b, and Sensor3c. By taking the median value of the three readings\nwe obtain an accurate reading, provided no more than one of them goes wrong.\nThis suggests the implementation given in Figure 11. We still assume a 90%\nreliability on the reading of any individual sensor.\n4.3.2 Specification\nIn fact here VolumeTracker3I is a refinement of VolumeTracker3 given in\nFigure 12, provided all of the sensor errors are within the error given in\nVolumeTracker3, e.g. [le3, he3] \u2286 [lowerror , higherror ].\nFor VolumeTracker3, carrying out the standard calculations on preserva-\ntion of E1, we find that the best (highest) value we can obtain for A, which\nenables the expectation E1 to be preserved, is the minimum of\n1 + (lowerror\/minflow)\nand\n0.972 + 0.028(minflow\/maxflow) + lowerror\/maxflow\n15\nSchneider, Hoang, Robinson, and Treharne\nIMPLEMENTATION VolumeTrackerI3\nREFINES VolumeTracker3\nIMPORTS Tank, Sensora3, Sensor3b, Sensor3c\nVARIABLES rvolume\nINVARIANT rvolume : REAL\nINITIALISATION rvolume := 0\nOPERATIONS\npoll = VAR v1, v2, v3\nIN\nv1 <-- poll3a;\nv2 <-- poll3b;\nv3 <-- poll3c;\nrflow := median(v1,v2,v3);\nrvolume := rvolume + rflow;\ntock\nEND\nEND\nFig. 11. The implementation VolumeTrackerI 3\nMACHINE VolumeTracker3\nINCLUDES Tank\nPROPERTIES lowerror : REAL & lowerror <= 0\n& higherror : REAL & higherror >= 0\nVARIABLES rvolume\nINVARIANT rvolume : REAL\nEXPECTATION E1: rvolume - A * volume,\nE2: B * volume - rvolume\nINITIALISATION rvolume := 0\nOPERATIONS\npoll =\ntock\n|| S3a: rvolume := rvolume+flow+[lowerror,higherror]\n0.972 (+)\nS3b: rvolume :: rvolume+[minflow+lowerror,maxflow+higherror]\nEND\nFig. 12. The third monitoring system specification\nSimilarly, the best (lowest) value we can obtain for B is the maximum of\n1 + (higherror\/maxflow)\nand\n0.972 + 0.028(maxflow\/minflow) + (higherror\/minflow)\n16\nSchneider, Hoang, Robinson, and Treharne\nThe second of these will always be the maximum, since maxflow > minflow .\nThe situation is similar to the previous example considered in Section 4.2.2,\nbut with a probability of an incorrect reading now at 0.028 rather than 0.01.\nThus the expectations on the relationship between rvolume and volume are\ncorrespondingly weaker, since more weighting is given to the ratio between\nmaxflow and minflow .\nFor example, consider the situation where we have the following: maxflow =\n400, minflow = 100, higherror = 1, lowerror = \u22121.\nSince the expectation E1 = rvolume \u2212 A \u00d7 volume must not decrease,\nwhatever the value of flow , we have two extremes to consider:\n\u2022 If flow = minflow , then volume is incremented by minflow , and the least\nthat rvolume can be incremented by is minflow + lowerror . Thus in this\ncase we obtain a possible value of A = 0.99.\n\u2022 If flow = maxflow , then volume is increased by maxflow , and the least that\nrvolume can be incremented by is minflow + lowerror if at least two sensors\ngo wrong (which can happen with probability 0.028), otherwise maxflow +\nlowerror . Thus the most pessimistic expectation gives a possible value of\nA = 0.9765. Here the ratio betweenmaxflow andminflow is more significant\nthan the ratio between minflow and lowerror in contributing to the amount\nby which rvolume can be down, and we obtain a value of 0.9765 for A.\nWe also require that the expectation E2 = volume \u2212 B \u00d7 rvolume must\nnot decrease. Here we are concerned with the proportion by which volume can\nexceed rvolume, and the worst case always occurs when flow = minflow . In\nthis case, the reading might at worst be maxflow+higherror (with probability\n0.028) and minflow+higherror otherwise. This yields a value for B of at least\n10.085 if the expectation of E2 is not to decrease. This is a margin of error\nof 8.5%.\n4.3.3 Summary\nThis version of the tank monitoring system has considered a version of sensor\nwhich does not provide feedback on its status. Thus a sensor\u2019s incorrect read-\ning can only be discovered by comparing it with other sensors. We considered\nan implementation which uses three sensors in such a way that if at most one\nhas failed then an accurate reading is obtained. We found that if each sensor\nhas at least 90% reliability, then the combination has at least 97.2% reliabil-\nity in terms of providing an accurate reading. This allowed us to construct\nthe specification that was guaranteed by the implementation. This in turn\nenables the relationship between the expected values of volume and rvolume\nto be established.\n17\nSchneider, Hoang, Robinson, and Treharne\n5 Discussion\nThe case study in this paper has shown how probabilistic B can be applied\nto specify and refine a system which naturally includes both probabilistic and\nnondeterministic behaviour, and has highlighted a number of issues that can\narise in this process.\nWe considered a progression of scenarios. In the first scenario, we consid-\nered the simple case where sensor readings are either perfectly accurate, or\ncompletely arbitrary, with the sensors indicating whether they are working\ncorrectly or not. This enabled a value for the accuracy of the system\u2019s value\nrvolume to be given, given in terms of the range of possible flows. Essentially\nthe accuracy is calculated by allowing for the worst case of nondeterminism,\nin accordance with the demonic approach to nondeterminism reflected in the\nsemantics of the language. We obtained the expected result that the larger the\nratio between the maximum and minimum flow, the less accurate the value\nwe could expect.\nIn the second scenario, we allowed some error range on the values read even\nwhen the sensors were working correctly. This additional nondeterminism also\nentered into the calculation to determine the level of accuracy of rvolume, and\nagain we saw that the wider the range of possibilities, for flow readings, and\nfor the possible flows, the lower the level of accuracy for the system\u2019s record\nof the volume of liquid.\nIn the third scenario, the sensors no longer provided a direct indication of\nwhether they were giving a correct reading or not, so it was necessary to use\nthree sensors and compare readings to deduce which values are most likely\ncorrect. In this example we worked from the implementation to the specifica-\ntion, firstly obtaining the reliability provided by the combination of sensors,\nand then calculating the level of accuracy that the system could deliver.\nAll three of these scenarios were modelled using a machine which had only\na single operation, which synchronised updates of the real tank and updates\nof the monitoring system.\nAlthough the case study was of a simple system, this paper has only ex-\nplored some of the interesting kinds of behaviour that can arise in such sys-\ntems, and many other scenarios remain ready to be explored. For example,\nwe might wish to model sensors that take some time to be repaired once they\nbreak. Such modelling would most likely require some auxiliary variable to\ntrack the time left until the sensor is working correctly again, and the best\nway of modelling such a system in probabilistic B is far from clear.\n5.1 Acknowledgements\nWe are grateful to Neil Evans, Carroll Morgan, and Annabelle McIver for\ncomments and discussions on this work.\nThis research was initiated during Ken Robinson\u2019s and Thai Son Hoang\u2019s\n18\nSchneider, Hoang, Robinson, and Treharne\nvisit to Royal Holloway, University of London, in July 2003, and thanks are\ndue to EPSRC for providing funds under grant GR96859\/01 to support this\nvisit.\nReferences\n[Abr96a] J-R. Abrial. The B-Book: Assigning Programs to Meanings. Cambridge\nUniversity Press, 1996.\n[Abr96b] J-R. Abrial. Extending B without changing it (for developing distributed\nsystems). In 1st Conference on the B-Method, 1996.\n[DT97] J. Draper and H. Treharne. The refinement of embedded software with\nthe B-Method. In Northern Formal Methods Workshop. Springer, 1997.\n[HJR+03] T.S. Hoang, Z. Jin, K. Robinson, A. McIver, and C. Morgan. Probabilistic\ninvariants for probabilistic machines. In ZB2003: Third International\nConference of B and Z Users, number 2651 in LNCS. Springer, 2003.\n[MM04] A. McIver and C. Morgan. Abstraction, Refinement and Proof for\nProbabilistic Systems. Springer, 2004.\n[MMH03] A. McIver, C. Morgan, and T.S. Hoang. Probabilistic termination in B.\nIn ZB2003: Third International Conference of B and Z Users, number\n2651 in LNCS. Springer, 2003.\n[MMS96] C. Morgan, A. McIver, and K. Seidel. Probabilistic predicate\ntransformers. ACM Transactions on Programming Languages and\nSystems, 18(3):325\u2013353, 1996.\n[Mor98] C. Morgan. The generalised substitution language extended to\nprobabilistic programs. In B\u201998: the 2nd International B Conference,\nnumber 1393 in LNCS. Springer, 1998.\n[Sch01] S. Schneider. The B-Method: an Introduction. Palgrave, 2001.\n[TS00] H. Treharne and S. Schneider. How to drive a B machine. In ZB2000:\nInternational conference of Z and B Users, number 1878 in LNCS.\nSpringer, 2000.\n[TSB03] H. Treharne, S. Schneider, and M. Bramble. Combining specification with\ncomposition. In ZB2003: 3rd International Conference of Z and B users,\nnumber 2651 in LNCS. Springer, 2003.\nA Machine Readable pGSL\nThis table gives the ascii form of statements in pGSL, used in the AMN\ndescriptions presented in this paper. For a fuller account of machine-readable\n19\nSchneider, Hoang, Robinson, and Treharne\nIMPLEMENTATION VolumeTracker2I\nREFINES VolumeTracker2\nIMPORTS Tank, Sensor2a, Sensor2b, Context\nVARIABLES rvolume\nINVARIANT rvolume : REAL\nINITIALISATION rvolume := 0\nOPERATIONS\npoll = VAR v1, v2, st1, st2, rflow\nIN\nP2a: v1,st1 <-- poll2a;\nP2b: v2,st2 <-- poll2b;\nF: rflow <-- flow(v1,st1,v2,st2);\nR: rvolume := rvolume + rflow;\nT: tock\nEND\nEND\nFig. B.1. The implementation VolumeTracker2I\nAMN, see [Abr96a,Sch01].\nx := E x:=E\nx :\u2208 S x :: S\nx , y := E ,F x,y := E,F\npre | prog pre | prog\nprog1[]prog2 prog1 [] prog2\npre =\u21d2 prog pre ==> prog\nskip skip\nprog1 p\u2295 prog2 prog1 p (+) prog2\nprog1 >p\u2295 prog2 prog1 >=p (+) prog2\n@y .pred =\u21d2 prog @ y . pred ==> prog\nB Verifying the implementation of poll in VolumeTracker2I\nThe poll operation in VolumeTracker2I is of the form P2a; P2b; F ; R; T ,\nwhere v1, v2, st1, st2, rflow are all local variables. We show that this operation\nis equivalent to poll given in the specification machine VolumeTracker2, as\nfollows:\nP2a; P2b; F ; R; T\n= {expanding P2a and P2b}\n(S2al >0.9\u2295 S2ar); (S2bl >0.9\u2295 S2br); F ; R; T\n20\nSchneider, Hoang, Robinson, and Treharne\n= {Law 13, twice }\n(S2al ; S2bl ; F ; R; T >0.9\u2295 S2al ; S2br ; F ; R; T )\n>0.9\u2295\n(S2ar ; S2bl ; F ; R; T >0.9\u2295 S2ar ; S2br ; F ; R; T )\n= {standard program algebra in each branch; removal of local variables}\n(rvolume :: rvolume + flow + [(le2a + le2b)\/2, (he2a + he2b)\/2]; T\n>0.9\u2295 rvolume :: rvolume + flow + [le2a, he2a]; T )\n>0.9\u2295\n(rvolume :: rvolume + flow + [le2b, he2b]; T\n>0.9\u2295 rvolume :: rvolume + flow + [minflow ,maxflow ]; T )\n\u21da {expanding the ranges of the nondeterministic choices,\nprovided lowerror 6 le2a, lowerror 6 le2b,\nhe2a 6 higherror , he2b 6 higherror}\n(rvolume :: rvolume + flow + [lowerror , higherror ]; T\n>0.9\u2295 rvolume :: rvolume + flow + [lowerror , higherror ]; T )\n>0.9\u2295\n(rvolume :: rvolume + flow + [lowerror , higherror ]; T\n>0.9\u2295 rvolume :: rvolume + flow\n+[minflow + lowerror ,maxflow + higherror ]; T )\n= {Laws 13 and 24}\nV 2a; T >0.99\u2295 V 2b; T\n= {Laws 13 and A, since V 2b \u2291 V 2a; T independent of V 2a and V 2b }\n(V 2a \u2016 T 0.99\u2295 V 2b \u2016 T )\nThus we arrive at the operation poll given in the machine VolumeTracker2.\nThis demonstrates that VolumeTracker2I indeed provides an implementation\nof VolumeTracker2.\n21\n"}