{"doi":"10.1109\/TASE.2008.41","coreId":"65303","oai":"oai:dro.dur.ac.uk.OAI2:6247","identifiers":["oai:dro.dur.ac.uk.OAI2:6247","10.1109\/TASE.2008.41"],"title":"Verifying BPEL-like programs with Hoare logic.","authors":["Luo, C.","Qin, S.","Qiu, Z."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2008-06-01","abstract":"The WS-BPEL language has recently become a de facto standard for modeling Web-based business processes. One of its essential features is the fully programmable compensation mechanism. To understand it better, many recent works have mainly focused on formal semantic models for WS-BPEL. In this paper, we make one step forward by investigating the verification problem for business processes written in BPEL-like languages. We propose a set of proof rules in Hoare-logic style as an axiomatic verification system for a BPEL-like core language containing key features such as data states, fault and compensation handling. We also propose a big-step operational semantics which incorporates all these key features. Our verification rules are proven sound with respect to this underlying semantics. The application of the verification rules is illustrated via the proof search process for a nontrivial example","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65303.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6247\/1\/6247.pdf","pdfHashValue":"556771d36df24c1aef3ff1fcc4b9f01bd9ca2891","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6247<\/identifier><datestamp>\n      2011-12-02T16:18:19Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Verifying BPEL-like programs with Hoare logic.<\/dc:title><dc:creator>\n        Luo, C.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Qiu, Z.<\/dc:creator><dc:description>\n        The WS-BPEL language has recently become a de facto standard for modeling Web-based business processes. One of its essential features is the fully programmable compensation mechanism. To understand it better, many recent works have mainly focused on formal semantic models for WS-BPEL. In this paper, we make one step forward by investigating the verification problem for business processes written in BPEL-like languages. We propose a set of proof rules in Hoare-logic style as an axiomatic verification system for a BPEL-like core language containing key features such as data states, fault and compensation handling. We also propose a big-step operational semantics which incorporates all these key features. Our verification rules are proven sound with respect to this underlying semantics. The application of the verification rules is illustrated via the proof search process for a nontrivial example.<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        (2008). 2nd IFIP\/IEEE International Symposium on Theoretical Aspects of Software Engineering, TASE 2008, 17-19 June 2008, Nanjing, China; proceedings. Los Alamitos, CA: IEEE, pp. 151-158<\/dc:source><dc:date>\n        2008-06-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6247<\/dc:identifier><dc:identifier>\n        doi:10.1109\/TASE.2008.41<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6247\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/TASE.2008.41 <\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6247\/1\/6247.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2008 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2008,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nLuo, C. and Qin, S. and Qiu, Z. (2008) \u2019Verifying BPEL-like programs with Hoare logic.\u2019, in 2nd IFIP\/IEEE\nInternational Symposium on Theoretical Aspects of Software Engineering, TASE 2008, 17-19 June 2008,\nNanjing, China; proceedings. Los Alamitos, CA: IEEE, pp. 151-158.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/TASE.2008.41\nPublisher\u2019s copyright statement:\n2008 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nVerifying BPEL-like Programs with Hoare Logic \u2217\nChenguang Luo1 Shengchao Qin1 Zongyan Qiu2\n1 Department of Computer Science, Durham University\n2 LMAM and Department of Informatics, School of Math. Sciences, Peking University\n{chenguang.luo, shengchao.qin}@durham.ac.uk zyqiu@pku.edu.cn\nAbstract\nThe WS-BPEL language has recently become a de facto\nstandard for modeling Web-based business processes. One\nof its essential features is the fully programmable compen-\nsation mechanism. To understand it better, many recent\nworks have mainly focused on formal semantic models for\nWS-BPEL. In this paper, we make one step forward by in-\nvestigating the verification problem for business processes\nwritten in BPEL-like languages. We propose a set of proof\nrules in Hoare-logic style as an axiomatic verification sys-\ntem for a BPEL-like core language containing key features\nsuch as data states, fault and compensation handling. We\nalso propose a big-step operational semantics which incor-\nporates all these key features. Our verification rules are\nproven sound with respect to this underlying semantics. The\napplication of the verification rules is illustrated via the\nproof search process for a nontrivial example.\n1. Introduction\nThe Internet is now developing at a high speed supported\nby the web technology. As a result, many web-based appli-\ncations, such as Web services, begin to flourish and play\na more and more significant role in various application ar-\neas. Web services boost a new approach to the construction\nof business processes where many basic functions are en-\ncapsulated and provided as individual services on the web,\nwhich later may be composed to form complex services ac-\ncording to diverse clients\u2019 demands. To cater for the de-\nscription of Web service composition, researchers and in-\ndustrial practitioners have proposed several Web service or-\nchestration languages such as XLANG [17], WSFL [11],\nStAC [4], and WS-BPEL [2, 3].\nAmong these orchestration languages, WS-BPEL has\nnow become a de facto standard. One important feature\nof WS-BPEL, as well as some other similar languages, is\n\u2217This work is supported in part by UK EPSRC project EP\/E021948\/1\nand China NNSF project 60773161.\nits mechanism for supporting long run transactions (LRTs).\nIn any single step of an LRT, a fault may occur and appro-\npriate compensation actions may be required. To address\nsuch demand, WS-BPEL provides a set of scope-based fault\nhandling and compensation mechanisms to deal with faults\nand potential undoing of some already completed business\nactivities. The compensation mechanisms are fully pro-\ngrammable, and thus allow users to define any application-\nspecific compensation rules. Nevertheless, these mecha-\nnisms, despite very flexible and powerful, also bring intri-\ncacies into the WS-BPEL language specification. As a re-\nsult, it becomes a challenging issue to formalize and reason\nabout WS-BPEL processes.\nMany recent works focused mostly on the formal seman-\ntics for WS-BPEL, e.g. [15, 14, 16, 10, 20]. These pioneer-\ning works are very important for reducing possible ambigu-\nity in the language specification and also for better under-\nstanding of the language. In this paper we will target at an\northogonal but equally important problem, the partial cor-\nrectness of WS-BPEL processes. To make the presentation\nsimple, we shall focus on a subset of WS-BPEL. However,\nour core language will take into account most of the impor-\ntant language features of WS-BPEL, including data state,\nfault handling and compensation mechanism. We will de-\nsign a concise yet novel operational semantics for our lan-\nguage, and propose a Hoare logic style verification system\non top of it, which will be proven sound with respect to\nthe underlying semantics. Due to the complexity of web-\nbased business processes, the correctness of such programs\nremains as a challenge. Our verification system for BPEL-\nlike language makes one step forward towards tackling this\nchallenging problem. To the best of our knowledge, this is\nthe first axiomatic verification system for a language with\ndata states, scope-based fault and compensation handling\nmechanisms. The main contributions of this paper can be\nsummarized as follows:\n\u2022 We propose a concise yet novel operational seman-\ntics for a BPEL-like core language. Although there\nare some semantic works with similar topics, our se-\nmantics is interesting in that it integrates features like\n2nd IFIP\/IEEE International Symposium on Theoretical Aspects of Software Engineering\n978-0-7695-3249-3\/08 $25.00 \u00a9 2008 IEEE\nDOI 10.1109\/TASE.2008.41\n151\nscopes, data states, fault handling and compensation in\na very simple way.\n\u2022 We design an assertion language for specifying certain\nsafety properties for BPEL-like processes, and also\npropose a set of axioms and inference rules in Hoare\nlogic style to form an axiomatic verification system for\nthe language. The pre- and postconditions are formu-\nlas expressed in our assertion language.\n\u2022 We state and prove the soundness of our axiomatic ver-\nification system with respect to the semantics. That is,\nprovable specifications are all semantically valid. A\nnontrivial example is presented to illustrate the appli-\ncation of the verification rules.\nThe remainder of this paper is organized as follows. Sec\n2 introduces our language BPEL\u2217 which is a core subset\nof WS-BPEL. A new operational semantics for BPEL\u2217 is\nthen presented in Sec 3. Sec 4 is devoted to the Hoare logic\nstyle verification system for BPEL\u2217. Sec 5 deals with the\nsoundness of our verification system, while Sec 6 gives a\nnontrivial example proof using our verification system. Re-\nlated work and concluding remarks follow afterwards.\n2. The BPEL\u2217 Language\nTo concentrate on the main aim of this study, we take\ninto account a core subset of theWS-BPEL language, called\nBPEL\u2217, which comprises not only the important fault and\ncompensation handling mechanisms but also data states of\nWS-BPEL processes.\nThe abstract syntax of BPEL\u2217 is given in Figure 1. Note\nthat a program written in BPEL\u2217 is called a business process\n(denoted as BP) which may contain an activity A and a fault\nhandler F. We may sometimes use the general term process\nto refer to an activity A, a compensation handler C, or a fault\nhandler F. The set of all processes is denoted as P.\nBP ::= {| A : F |} (business process)\nA ::= skip (do nothing) | x := e (assignment)\n| rec a y (receive) | inv a x y (invoke)\n| rep a x (reply) | throw (throw a fault)\n| A;A (sequence) | A \u2016 A (flow)\n| if b then A else A (conditional)\n| n : {A ? C : F} (scope)\nC,F ::= \u0002n (compensation) | . . . (similar as A)\nFigure 1. The Syntax of BPEL\u2217\nIn Figure 1, x and y stand for variable names, e repre-\nsents arithmetic expressions, b is for boolean expressions,\nand n for scope names. A denotes a general activity, while\nC and F are for compensation and fault handlers, respec-\ntively. It is worth noting that the compensation activity \u0002n\ncan only appear in these two constructs. Note that in a scope\nn : {A ? C : F}, A is the normal activity, C is the compen-\nsation handler, and F is the fault handler.\nIn BPEL\u2217, we assume all names for variables defined\nin a business process are distinct, so are the scope names.\nThis is just for simplicity and does not lose generality as\nwe can easily achieve this by a pre-processing step. Under\nsuch assumptions, we can refer to a variable or a scope sim-\nply by its name, with no need of mentioning its enclosing\ncontext. We also assume that the processes under consid-\neration have been statically checked to meet certain basic\nwell-formedness conditions. For instance, the compensa-\ntion activity \u0002n will only occur in the immediate enclosing\nscope of the scope n.\nTo focus more on the novel aspects of WS-BPEL, in-\ncluding the fault and compensation handling, we restrict the\nparallel composition (flow) construct so that links between\nits components (i.e. additional control-flow restrictions) are\ndisallowed in BPEL\u2217. We can do so because this issue is al-\nmost orthogonal to our focus in this paper and it has already\nbeen well investigated by researchers, eg. [18, 19].\n3. Dynamic Semantics\nIn this section, we propose a big-step operational seman-\ntics for BPEL\u2217. The semantics not only serves as a runtime\nmodel for the language, but also acts as a reference seman-\ntics in the soundness proof for our axiomatic verification\nsystem. In what follows, we will define the runtime states\nused for the semantics and then depict the semantic rules.\n3.1. Runtime States\nThe nontrivial business processes need often to support\nlong-running transactions (LRTs), where the exceptional\nfaults are unavoidable, and as a result the partially com-\npleted tasks may need to be revoked accordingly. This kind\nof processes are hard to describe without language sup-\nport. WS-BPEL deals with this necessity with its scope\nand compensation mechanism, which can be invoked to re-\nverse some partially completed transactions. Since a fault\nmay happen from time to time, the WS-BPEL specification\nadvocates to keep records of state snapshots for the suc-\ncessfully completed scopes, as the associated compensation\nhandlers may refer to such completion states when the com-\npensation is invoked. Our semantics will record those suc-\ncessfully completed scope snapshots in the runtime state,\nsimilar to the way used in Qiu et al. [15] for recording com-\npensation closures. To facilitate the handling of faults, we\nalso instrument the runtime state with a boolean value to in-\ndicate whether the current state is a normal state or a faulty\n152\nstate. The formal notations we use are as follows:\nf \u2208 Status =df {fail, norm}\ns \u2208 Val =df Var \u21c0 Value\n\u03b1, [\u03b4, .., \u03b4] \u2208 CPCtx =df seq CPCl\n\u03b4, \u3008n, s, \u03b1\u3009 \u2208 CPCl =df ScopeN\u00d7 Val\u00d7 CPCtx\n\u03c3, (f, s, \u03b1) \u2208 \u03a3 =df Status\u00d7 Val\u00d7 CPCtx\nIn the semantic model, a runtime state \u03c3 = (f, s, \u03b1) is com-\nposed of three elements, where f indicates whether the cur-\nrent state is normal (f = norm) or of a fault (f = fail), and\nthe s records current snapshot for the values of all variables\nin the process. The third element \u03b1 is the compensation\ncontext used to record the state snapshots and relative com-\npensation information for successfully completed scopes.\nWhen a compensation activity \u0002n runs, the code to be\nexecuted (i.e. the compensation handler defined in scope\nn) is statically determined. However, the behavior of the\ncompensation will depend on not only the scope snapshot\nof n, but also the dynamic execution of the normal activ-\nity in scope n that yields the state snapshot. This is due\nto the fact that (1) the current compensation may invoke\ncompensation handlers from the immediate sub-scopes of\nn, so its behavior will depend on whether or not each of\nthe sub-scopes has completed successfully (thus the asso-\nciative handler has been installed) and (2) such informa-\ntion is determined dynamically during the execution of the\nnormal activity of scope n. To record such information\nalong with the scope snapshot, we define the compensa-\ntion context \u03b1 as a (possibly empty) sequence of compen-\nsation closures [\u03b41, \u03b42, . . . , \u03b4n], whereby compensation clo-\nsure \u03b4i = \u3008n, s, \u03b11\u3009 is a nested structure which records the\nstate snapshot s for scope n (i.e., the data state at the end of\nthe normal execution of scope n). The third element \u03b11 is\nthe compensation context accumulated during the execution\nof the normal activity of scope n. It includes all the compen-\nsation closures for those normally completed immediately-\nenclosed sub-scopes. When the compensation handler of n\nis invoked, both the scope snapshot s and the enclosed con-\ntext \u03b11 are passed on.\nWe do not record the handlers in the context as such in-\nformation can be statically determined for a given business\nprocess. Instead, we assume the availability of a mapping\nto fetch the corresponding handlers:\nC : ScopeN \u2192 P\nwhere ScopeN is the set of scope names. For a valid scope\nname n \u2208 dom(C), C(n) \u2208 P is the compensation handler\ndefined in scope n.\nWe will make use of standard sequence operators given\nbelow (where \u03b11 = [\u03b41, .., \u03b4m] and \u03b12 = [\u03b4\u20321, .., \u03b4\u2032n]):\n\u03b40 \u00b7 \u03b11 = [\u03b40, \u03b41, .., \u03b4m]\nhd(\u03b11) = \u03b41\ntl(\u03b11) = [\u03b42, .., \u03b4m]\n\u03b11\u0003\u03b12 = [\u03b41, .., \u03b4m, \u03b4\u20321, .., \u03b4\u2032n]\nWe define a membership relation as follows:\n\u03b4\u2208\u03b1 =df\n\u23a7\u23a8\n\u23a9\nfalse if \u03b1 = [ ]\ntrue if hd(\u03b1) = \u03b4\n\u03b4\u2208tl(\u03b1) else\n\u03b4 \/\u2208\u03b1 =df \u00ac(\u03b4\u2208\u03b1)\nBased on it we can define the following analogous relation:\nn\u2208\u03b1 =df \u2203s, \u03b11 \u2022 \u3008n, s, \u03b11\u3009 \u2208 \u03b1\nn\/\u2208\u03b1 =df \u00ac(n\u2208\u03b1)\nwhere n is a scope name and \u03b1 is a compensation context.\nInformally, n\u2208\u03b1 indicates that the compensation handler for\nthe scope n has been installed (and hence n\u2019s scope snap-\nshot appears in \u03b1).\n3.2. Operational Semantics\nIn this subsection, we present the semantic rules for the\nprocesses in BPEL\u2217. The big-step operational semantics for\nBPEL\u2217 is defined by a set of rules of the form\n\u3008A, \u03c3\u3009\u0004 \u03c3\u2032\nwhere A is a process, while \u03c3 and \u03c3\u2032 denote the initial and\nfinal states, respectively.\nWhen a fault has occurred, the process to be executed\nwill do nothing but propagate the fault. The rule below de-\nscribes this scenario:\n\u03c3 = (fail, s, \u03b1)\n\u3008A, \u03c3\u3009\u0004 \u03c3\nThe following rules define the behavior of skip, assign-\nment, and throw activities from normal states:\n\u3008skip, (norm, s, \u03b1)\u3009\u0004 (norm, s, \u03b1)\n\u3008x := e, (norm, s, \u03b1)\u3009\u0004 (norm, s\u2295 {x\n\u2192s(e)}, \u03b1)\n\u3008throw, (norm, s, \u03b1)\u3009\u0004 (fail, s, \u03b1)\nwhere s\u2295 s\u2032 is a state formed by s and s\u2032:\n(s\u2295 s\u2032)(x) =df\n{\ns\u2032(x) when x \u2208 dom s\u2032\ns(x) otherwise\nWhen synchronized communication inv a x y succeeds,\nthe received value is assigned to y; while failed communi-\ncation also makes the process fail.\n\u3008inv a x y, (norm, s, \u03b1)\u3009\u0004 (norm, s\u2295 {y \n\u2192\u03bd}, \u03b1)\n\u3008inv a x y, (norm, s, \u03b1)\u3009\u0004 (fail, s, \u03b1)\nwhere \u03bd is the value achieved through the communication.\nThe rules for the one-way communications rec a y and\nrep a x are as follows:\n\u3008rec a y, (norm, s, \u03b1)\u3009\u0004 (norm, s\u2295 {y \n\u2192\u03bd}, \u03b1)\n\u3008rec a y, (norm, s, \u03b1)\u3009\u0004 (fail, s, \u03b1)\n\u3008rep a x, (f, s, \u03b1)\u3009\u0004 (f, s, \u03b1)\n153\nNote that the one-way communications provide an invoca-\ntion mechanism for external Web services. The rec a y is\nused to retrieve parameters from other Web services. Its ef-\nfect is to update variable y using the value received from the\nexternal Web service. On the contrary, the rep a x replies to\nother external Web services with the value of x. Thus its\neffect is just like a skip to the current process.\nRules for sequence and conditional activities are routine:\n\u3008A1, (norm, s, \u03b1)\u3009\u0004 (f1, s1, \u03b11)\n\u3008A2, (f1, s1, \u03b11)\u3009\u0004 (f2, s2, \u03b12)\n\u3008A1;A2, (norm, s, \u03b1)\u3009\u0004 (f2, s2, \u03b12)\ns(b) = true \u3008A1, (norm, s, \u03b1)\u3009\u0004 (f1, s1, \u03b11)\n\u3008if b then A1 else A2, (norm, s, \u03b1)\u3009\u0004 (f1, s1, \u03b11)\ns(b) = false \u3008A2, (norm, s, \u03b1)\u3009\u0004 (f1, s1, \u03b11)\n\u3008if b then A1 else A2, (norm, s, \u03b1)\u3009\u0004 (f1, s1, \u03b11)\nThe rule for the parallel composition is as follows:\n(s1, s2) = split(s,Var(A1),Var(A2))\n\u3008A1, (norm, s1, [ ])\u3009\u0004 (f1, s\u20321, \u03b11)\n\u3008A2, (norm, s2, [ ])\u3009\u0004 (f2, s\u20322, \u03b12)\nf \u2032 = f1\u2227f2 s\u2032 = s\u20321\u222as\u20322 \u03b1\u2032 = interleave(\u03b11, \u03b12)\u0003\u03b1\n\u3008A1 \u2016 A2, (norm, s, \u03b1)\u3009\u0004 (f \u2032, s\u2032, \u03b1\u2032)\nwhere for f1 and f2, f1\u2227f2 is defined as\nf1 \u2227 f2 =df\n{\nnorm, if f1 = norm and f2 = norm;\nfail, otherwise.\nThe initial sub-states s1 and s2 are obtained from the overall\nstate s via a splitting operation whose definition is straight-\nforward given that A1 and A2 do not share variables, i.e.,\nVar(A1) \u2229 Var(A2) = \u2205. The function interleave(\u03b11, \u03b12)\nreturns a merged sequence of \u03b11 and \u03b12 by arbitrarily in-\nterleaving elements of \u03b11 and \u03b12.\nThe execution of a scope n : {A ? C : F} may result in\ntwo different situations: the execution of A may complete\nsuccessfully or raise a fault. For the former, the compen-\nsation handler will be installed by adding the compensation\nclosure into the compensation context. For the latter, the\nfault handler is invoked instead.\n\u3008A, (norm, s, [ ])\u3009\u0004 (norm, s1, \u03b11) s\u2032 = s1\u000fV (n)\n\u3008n : {A ? C : F}, (norm, s, \u03b1)\u3009\u0004 (norm, s1, \u3008n, s\u2032, \u03b11\u3009 \u00b7 \u03b1)\n\u3008A, (norm, s, [ ])\u3009\u0004 (fail, s1, \u03b11)\n\u3008F, (norm, s1, \u03b11)\u3009\u0004 (f2, s2, \u03b12)\n\u3008n : {A ? C : F}, (norm, s, \u03b1)\u3009\u0004 (f2, s2, \u03b12)\nHere V (n) denotes the set of local variables of scope n,\nand s1\u000fV (n) takes the part of state local to n, which is the\nsnapshot of scope n when it completes execution.\nNote that the scope is the only part in the model to deal\nwith faults. Once a fault is propagated from an activity A\nto its enclosing scope, it will be caught by the relevant fault\nhandler F. If the fault handler of the immediately enclosing\nscope of A throws the fault again rather than completes the\nhandling, the fault continues its propagation to the next fault\nhandler, or meets the end of the process. This is elaborated\nin the rules defined above.\nNext comes the definition of compensation. Accord-\ning to the WS-BPEL Specification [2], our compensation\nlooks for the installed compensation closure of correspond-\ning scope, removes it from the compensation context and\nruns its handler. If the closure is not installed, the invo-\ncation behaves like a skip. Since we have actually accu-\nmulated the compensation contexts, it turns out simple to\nexecute the handler as below:\nn \/\u2208 \u03b1\n\u3008\u0002n, (norm, s, \u03b1)\u3009\u0004 (norm, s, \u03b1)\n\u03c3 = (norm, s, \u03b11\u0003[\u3008n, s\u2032, \u03b2\u3009]\u0003\u03b12)\n\u3008C(n), (norm, s\u2295 s\u2032, \u03b2)\u3009\u0004 (f1, s1, \u03b3)\n\u3008\u0002n, \u03c3\u3009\u0004 (f1, s1, \u03b11\u0003\u03b12)\nNote that n \/\u2208 \u03b1, defined in last section, means that the com-\npensation handler for n is not installed (hence the closure\nfor n does not appear in \u03b1).\nThe rules for the whole business process are as follows:\n\u3008A, \u03c3\u3009\u0004 (norm, s1, \u03b11)\n\u3008{| A : F |}, \u03c3\u3009\u0004 (norm, s1, \u03b11)\n\u3008A, \u03c3\u3009\u0004 (fail, s1, \u03b11) \u3008F, (norm, s1, \u03b11)\u3009\u0004 (f2, s2, \u03b12)\n\u3008{| A : F |}, \u03c3\u3009\u0004 (f2, s2, \u03b12)\nThere is no top-level compensation handler in the business\nprocess because no one could invoke it if there were any.\n4. An Axiomatic System for BPEL\u2217\nAs a first step to support mechanized verification for\nBPEL\u2217 processes, we propose in this section a set of in-\nference rules in the style of a Floyd-Hoare logic.\n4.1. Assertion Language\nTo specify properties for BPEL\u2217 processes, apart from\nthe usual logical operations, we shall make use of some\nlogical constructs that are specific for compensation related\nreasoning. The syntax for the assertion language Assn is:\nP \u2208 Assn\nP ::= true | false | normal | x\u0010\u223ce | \u223cP | P\u0002 | P\u000fV |\nP+n | P\u2212n | P\u0002n | P\u2217n | P||P | P\tP | P\u2217P |\n\u00acP | P\u2227P | P\u2228P | P\u21d2P\nNote that x, e and n denote a variable name, an expression\nand a scope name, respectively. The \u0010\u223c denotes a relational\noperator in {=, <,>,\u2264,\u2265}.\n154\nIn the axiomatic system, each assertion is viewed as a\nset of states that satisfy the assertion. The semantics for all\nassertions is given in Figure 2.\n|[true]| = \u03a3 |[false]| = \u2205\n|[x]|\u03c3 = \u03c3.2(x) |[normal]| = {\u03c3 | \u03c3.1 = norm}\n|[e]|\u03c3 = \u03c3.2(e) the evaluation result of e under state \u03c3\n|[x\u0010\u223ce]| = {\u03c3 | |[x]|\u03c3\u0010\u223c|[e]|\u03c3},where \u0010\u223c has the\nsemantics of the relational operator\n|[\u223cP]| = {(\u00ac\u03c3.1, \u03c3.2, \u03c3.3) | \u03c3 \u2208 |[P]|}\n|[P\u0002]| = {(\u03c3.1, \u03c3.2, [ ]) | \u03c3 \u2208 P}\n|[P\u000fV]| = {(\u03c3.1, \u03c3.2\u000fV, \u03c3.3) | \u03c3\u2208|[P]|}\n|[P+n]| = {(\u03c3.1, \u03c3.2, \u3008n, \u03c3.2\u000fV (n), \u03c3.3\u3009) | \u03c3 \u2208 |[P]|}\n|[P\u2212n]| = {(\u03c3.1, \u03c3.2, \u03b1) | \u03c3 \u2208 |[P]| \u2227 \u03b1 =\nbefore(n, \u03c3.3)\u0003after(n, \u03c3.3)}\n|[P\u0002n]| = {\u03c3 | \u03c3\u2208|[P]| \u2227 n\u2208\u03c3.3}\n|[P\u2217n]| = {firstof(n, \u03c3) | \u03c3\u2208|[P]| \u2227 n\u2208\u03c3.3}\n|[P||Q]| = {(\u03c3.1 \u2227 \u03c3\u2032.1, \u03c3.2 \u222a \u03c3\u2032.2, \u03b1) | \u03c3\u2208|[P]|\u2227\n\u03c3\u2032\u2208|[Q]| \u2227 \u03b1=interleave(\u03c3.3, \u03c3\u2032.3)}\n|[P\tQ]| = {(\u03c31.1, \u03c31.2, \u03c31.3\u0003\u03c32.3) | \u03c31\u2208|[P]| \u2227 \u03c32\u2208|[Q]|}\n|[P\u2217Q]| = {(\u03c31.1, \u03c31.2, \u03c32.3) | \u03c31\u2208|[P]| \u2227 \u03c32\u2208|[Q]|}\n|[\u00acP]| = \u03a3 \\ |[P]| |[P \u2227 Q]| = |[P]| \u2229 |[Q]|\n|[P \u2228 Q]| = |[P]| \u222a |[Q]| |[P \u21d2 Q]| = |[\u00acP \u2228 Q]|\nFigure 2. Semantics for Assertions\nTo facilitate the description, we use here (and below) \u03c3.i\nto denote the i-th element of tuple \u03c3. For instance, given\n\u03c3 = (f, s, \u03b1), we will have \u03c3.1 = f, \u03c3.2 = s and \u03c3.3 = \u03b1.\nIn the definition, n\u2208\u03c3.3, defined in last section, denotes\nthat the compensation handler for scope n is installed. We\nalso use three operations to extract information w.r.t. scope\nn from compensation context \u03b1: Operation firstof(n, \u03c3)\nextracts from \u03b1 = \u03c3.3 the first state snapshot for n, and\nmerges it with \u03c3.2:\nfirstof(n, \u03c3) =df (norm, \u03c3.2\u2295 s, \u03b2)\nif \u03c3.3 = \u03b11\u0003[\u3008n, s, \u03b2\u3009]\u0003\u03b12 \u2227 n \/\u2208 \u03b11\nWhen n \/\u2208 \u03c3.3, firstof(n, \u03c3) is undefined. before(n, \u03b1) re-\nturns the largest prefix of \u03b1 which contains no closure for\nscope n, and after(n, \u03b1) returns the sub-sequence of \u03b1 after\nthe first closure for scope n, or the empty sequence when\nno such closure in \u03b1. We omit their formal definitions here.\nAmong the semantics for the assertions, some relating to\nflow, scope, and compensation are worth illustration.\nThe assertions P\u000fV and P||Q are used in verification of\nflow constructs. In the first one, V is a set of variables and\nP\u000fV restricts the domain of variable mapping \u03c3.2 (where\n\u03c3 \u2208 |[P]|) to V. For example, (x>0 \u2227 y\u22640)\u000f{x} = x>0.\nThe second one, P||Q, enumerates all possible interleaving\ncases of compensation contexts of states in |[P]| and |[Q]|, re-\nspectively.\nAssertion P+n extracts each state \u03c3 from set |[P ]|, sets its\ncompensation context to the closure \u3008n, \u03c3.2\u000fV (n), \u03c3.3\u3009, and\nforms a new set with all of these states.\nAs its form suggests, P\u2212n performs an \u201celimination\u201d of\nscope name n \u201cfrom\u201d the elements in |[P]|. It extracts first\nthe compensation context \u03b1 from each state of |[P]|, then\nfinds the first compensation closure with name n, and re-\nmoves it to form a new context \u03b1. If there is no such closure\nfound, then \u03b1 will be the original context. The semantics of\nP\u2212n is the set of states with these newly formed \u03b1.\nWhat P\u0002n does is, informally, to \u201crestrict\u201d |[P]| to the set\nof states in which the compensation context contains a clo-\nsure with name n, P\u2217n \u201clocates\u201d the first occurrence of the\nclosure with name n in each state in |[P]|, and forms a set of\nstates from these closures.\nP\tQ and P\u2217Q are for compensation contexts concatena-\ntion and replacement between assertions, respectively.\nAn assertion is modeled as a set containing all the states\nwhich satisfy it. Thus we define\n\u03c3 |= P =df \u03c3 \u2208 |[P]|.\nA specification in our system takes the ordinary form\n{P} A {Q}, where P,Q \u2208 Assn and A \u2208 P is an activity.\nOne thing notable is that a business process may com-\nmunicate with external processes via activities inv, rec and\nrep. As a result, whether a business process behaves in\na desired way might depend on the external processes be-\ning interacted with. Hence, a business process is more\nlike an open system which makes the verification problem\nrather challenging. Our proposal is to verify each business\nprocess separately according to certain dependency order\nin the first step. We assume that specifications for com-\nmunication activities are available in the verification of one\nbusiness process. When all relevant business processes have\nbeen verified separately, we can then check the consistency\nof all the assumptions made on communication activities.\nIn this paper, we focus only on the verification of individual\nbusiness processes.\nFor a given business process, we assume that a set of\nspecifications {P} c {Q} are known, where each c is of the\nform inv a x y, rec a y, or rep a x, representing a commu-\nnication that might be executed by the process with the en-\nvironment. We will use T to denote a set of such specifica-\ntions and pass T as a context to the verification rules. For\na specification {P} c {Q} \u2208 T , the precondition P acts as\nan assertion imposed on the current process to ensure that\ninformation sent out via c satisfies the requirement of the\nenvironment, while Q acts as an assumption made on the\nenvironment: the result sent back by the environment would\nsatisfy Q.\nThe proof rules in our verification system are of the form\nC,T \u0016 {P} A {Q}, where C, defined earlier, is the mapping\nfrom scope names to associated compensation handlers, and\nT is the set of specifications defined above. We shall now\npresent the syntax-directed proof rules in our logic.\n155\n4.2. Consequence Rule\nThe only structural rule in our axiomatic system is the\nconsequence rule for precondition weakening and postcon-\ndition strengthening:\nP \u21d2 P\u2032 C,T \u0016 {P\u2032} A {Q\u2032} Q\u2032 \u21d2 Q\nC,T \u0016 {P} A {Q} (conseq)\n4.3. BPEL\u2217-specific Rules\nThe rules for skip and assignment are simple:\nC,T \u0016 {P} skip {P} (skip)\nC,T \u0016 {normal \u2227 P[e\/x]} x := e {P} (assign)\nThe rule for throw is clear too:\nC,T \u0016 {P} throw {\u00acnormal \u2227 (P \u2228 \u223cP)} (throw)\nHere we do not need to care whether the pre-condition is\nnormal, because the type of fault is not in the range of our\ncurrent consideration.\nFor the basic communication activities, the rules need to\nuse their assumed specifications in T . For the convenience\nof description, we assume the variable names in the pre-\nand postconditions are correspondent with those used in the\ninvocations. Meanwhile, as is stated in former section, in\nthe verification of the process, a triple {P} A {Q} in T can\nalso be used to verify a triple whose pre- and postcondition\nhave the same denotation of compensation contexts, such\nas {P\tR} A {Q\tR}. And in this situation it must be guaran-\nteed that the denotations of compensation contexts in both\npre- and postcondition are the same.\nIf the environment can be modeled as a subset of normal,\nthen rec sets the variable\u2019s value to what the specification\ndenotes. Or it just propagates the fault.\n{normal} rec a y {Q} \u2208 T \u00acnormal \u21d2 Q\nC,T \u0016 {true} rec a y {Q} (rec)\nBecause of its analogous behavior as skip, rep\u2019s rule is also\nthe same.\nC,T \u0016 {P} rep a x {P}(rep)\nThe semantics of two-way invocation is simple:\n{P} inv a x y {Q} \u2208 T\nC,T \u0016 {P} inv a x y {Q} (inv)\nNote that these rules depend on T \u2013 the set of specifications\nassumed on communication activities.\nThe rules for control structures are as follows.\n\u00acnormal \u2227 P \u21d2 Q\nC,T \u0016 {normal \u2227 P} A {R} C,T \u0016 {R} B {Q}\nC,T \u0016 {P} A; B {Q} (seq)\n\u00acnormal \u2227 P \u21d2 Q C,T \u0016 {normal \u2227 P \u2227 b} A {Q}\nC,T \u0016 {normal \u2227 P \u2227 \u00acb} B {Q}\nC,T \u0016 {P} if b then A else B {Q} (if)\nwhere b is an boolean expression of the form x\u0010\u223ce.\nSince we assume that the different parallel flows share\nno variables, the rule for the parallel structures is given as\n\u00acnormal \u2227 P \u21d2 (Q1||Q2)\tP\nC,T \u0016 {P\u0002\u000fV1} A {Q1} C,T \u0016 {P\u0002\u000fV2} B {Q2}\nC,T \u0016 {P} A||B {(Q1||Q2)\tP}\n(flow)\nwhere V1 and V2 are disjoint variable sets and A and B only\nmodify variables in V1 and V2, respectively.\nNow we present the two most significant rules, which\nreveal the essential features of our language. The rule for\nscopes is as follows:\n\u00acnormal \u2227 P \u21d2 Q\nC,T \u0016 {normal \u2227 P\u0002} A {R}\n(normal \u2227 R)+n\tP \u21d2 Q\nC,T \u0016 {\u223c(\u00acnormal \u2227 R)} F {Q}\nC,T \u0016 {P} n : {A ? C : F} {Q} (scope)\nNote that the rule (scope) captures two cases. One stands\nfor the scenario where a fault occurs in A. In that case the\ncontrol transfers to the fault handler, and the compensation\nhandler for scope n is not installed. The other is for the nor-\nmal completion of A and the concatenation of this scope\u2019s\ncompensation context to the process state.\nThen the most intricate rule in our system, the named\ncompensation, comes as follows:\n\u00acnormal \u2227 P \u21d2 Q \u00acP\u0002n \u2227 P \u21d2 Q\nC,T \u0016 {(P\u0002n)\u2217n} C(n) {R} R\u2217P\u2212n \u21d2 Q\nC,T \u0016 {P} \u0002n {Q} (compensate)\nIn this rule, the behavior of a named compensation is de-\npicted with the relevant compensation handler. If the pre-\ncondition does not entail a scope name n, the post-condition\nmust be automatically satisfied. Otherwise, the snapshots\u2019\nset (as the pre-condition for the compensation handler) is\nextracted and the post-condition is a combination of the\nfault and variable mapping states after the handler\u2019s exe-\ncution, and the compensation context with the elimination\nof the first compensation closure named n.\nAt last is the rule for the whole business process:\nC,T \u0016 {P} A {R} (normal \u2227 R) \u21d2 Q\nC,T \u0016 {\u223c(\u00acnormal \u2227 R)} F {Q}\nC,T \u0016 {P} {| A : F |} {Q} (bp)\n5. Soundness\nThis section confirms the soundness of our verification\nsystem. We will first give two definitions, then formalize\nthe soundness theorem.\n156\nDefinition 1 (Validity). We denote that a specification\n{P} A {Q} is valid under C,T, i.e. C,T |= {P} A {Q}, if\nfor all \u03c3 \u2208 \u03a3, if \u03c3 |= P and \u3008A, \u03c3\u3009\u0004 \u03c3\u2032 for some \u03c3\u2032, then\n\u03c3\u2032 |= Q.\nDefinition 2 (Soundness). Our verification system for\nBPEL\u2217 is sound if all provable specifications are indeed\nvalid, that is, if C,T \u0016 {P} A {Q}, then C,T |= {P} A {Q}.\nThe theorem for soundness can be stated as below:\nTheorem 1. The verification system for BPEL\u2217, given in\nthe last section, is sound.\nAs is indicated by Definition 2 above, we need to\nshow that, for any P,A,Q, if C,T \u0016 {P} A {Q}, then\nC,T |= {P} A {Q}. The proof can be accomplished by\nstructural induction over A. Due to space limitation, we\nomit the proof here. A detailed proof can be found in our\ncompanion technical report [12].\n6. Example\nIn this section a purchase example, which is a modified\nversion of that in the book [6], is exhibited to illustrate the\nverification of a real business process.\nThe general flow of the example is as follows. First\nthe business process receives the price for each single item\n(stored in variable p) and the class of the customer from\nother service with communication (into variable y). Then it\ndecides the discount ratio according to the customer class,\nand receives the number of items to store in t. After hav-\ning all the items purchased, it computes the shipping fare\naccording to the value of t. At last the real average price\n(including shipping cost) for each item is calculated and\nreplied, which may fail and hence call for compensation.\nThis business process, denoted as BP, is written in\nBPEL\u2217 below.\n{| n1 : {rec a p; q := p ? p := \u2212p : skip};\nrec b y;\nif y = 1 then\nn2 : {p := p\u00d7 0.5 ? p := p\u00d7 2 : skip}\nelse\nn3 : {p := p\u00d7 0.8 ? p := p\u00d7 1.25 : skip};\nn4 : {rec c t; p := p\u00d7 t ? p := p\/t : skip};\nif t > 500 then\nn5 : {p := p + 500 ? p := p\u2212 500 : skip}\nelse\nn6 : {p := p + t ? p := p\u2212 t : skip };\nif t > 0 then p := p\/t; rep d p else throw\n: \u0002n6; \u0002n5; \u0002n4; \u0002n3; \u0002n2; \u0002n1 |}\nFor this business process we propose a rather compli-\ncated specification to verify:\n{ normal } BP { p=q\/2+500\/t \u2228 p=0.8q+500\/t \u2228\np=q\/2+1 \u2228 p=0.8q+1 \u2228 p = \u2212q }\nHere we give an outline of the verification for BP with\nthe backwards searching strategy. First, for the whole busi-\nness process, we use the rule of (bp) to get three subgoals\nG1, G2, and G3 for further verification:\nG1 : C,T \u0016 {normal} A {R}\nG2 : (normal \u2227 R) \u21d2 Q\nG3 : C,T \u0016 {\u223c(\u00acnormal \u2227 R)} F {Q}\nwhere A stands for the codes before the last \u2018:\u2019 in the\nprocess, Q is the postcondition we want to verify, F rep-\nresents the six compensations (\u0002n6; \u0002n5; . . . ; \u0002n1), and\nthe generated assertion R should be no stronger than\nthe strongest postcondition for A given the precondition\nnormal, and no weaker than (part of) the weakest precon-\ndition for F given the postcondition Q, and should establish\nQ given normal. Due to space limitation, the concrete rep-\nresentation of R is omitted here.\nTo discharge G1, by the (seq) rule, it is sufficient to dis-\ncharge six smaller subgoals (given in the report), which are\nthen proved by several rules including (scope), (rec), (as-\nsign) and (if ). the implication in G2 is quite straightforward\nto prove by logic, resulting in part of the postcondition (p=\nq\/2+500\/t \u2228 p=0.8q+500\/t \u2228 p=q\/2+1 \u2228 p=0.8q+1).\nThe verification of G3 mainly utilizes the (compensate)\nrule to \u201cconsume\u201d the compensation segments within R to\nachieve the last disjunctive part of postcondition (p = \u2212q).\nA detailed proof for this example can be found in the\ntechnical report [12] in a strict backward manner of verifi-\ncation.\n7. Related Work\nThe concept of compensation dates back to Sagas [8] and\nnested transactions [13]. There are many attempts to for-\nmalize workflow languages [1, 9, 4], and still many of them\nare about compensation.\nOn the semantics of such languages there are many in-\nvestigations. Qiu et al. [15] provided a formal operational\nsemantics to a simplified version of WS-BPEL to specify\nthe execution path of a process with possible compensation\nbehavior. Pu et al. [14] also presented an abridged edition\nof WS-BPEL, discussed its operational semantics, and de-\nfined the equivalence between two processes with its pro-\nposed n-bi-simulation. He et al. [10] also focused on the\nprocess equivalence from the perspective of an observation-\noriented model and its algebraic laws. Zhu et al. [20] made\na link among different semantics (operational, denotational\nand algebraic) of the WS-BPEL language with the approach\nof the unifying theories of programming. These works can\nalso be reference semantics for our verification system.\nApart from the work on semantic models, researchers\nhave also tried to model and verify theWS-BPEL processes.\nDuan et al. [5] introduced a logic model to formally specify\n157\nthe semantics of workflow and its composite tasks described\nas WS-BPEL abstract processes, and made a deduction of\nthe weakest precondition for workflow. Fu et al. [7] showed\nsome techniques to analyze and verify the WS-BPEL spec-\nified interactions among Web services with SPIN. Hamadi\nand Benatallah [9] transformed the formal semantics of the\nWS-BPEL composition operators to an expression of Petri\nnets, and hence allowed the verification of properties and\nthe detection of inconsistencies both within and between\nservices. None of these works have attempted in verify-\ning WS-BPEL-like fault handling and compensation as we\nhave done in this paper.\n8. Conclusion\nIn this paper we proposed an axiomatic system to verify\nthe correctness of BPEL\u2217 processes. We have concentrated\non a core subset of WS-BPEL, namely, BPEL\u2217, presented a\ncomplete state model including the fault state and variables\nfor it, and created its operational semantics with state tran-\nsition rules. Based on this, the assertions and Hoare triples\nand their semantics are set up, and the verification rules for\nBPEL\u2217 are formalized as well. We have also proven the\nsoundness of this system by structural induction, and pro-\nvided an example as an illustration. Possible future works\ninclude (1) extending the logic to cover more language fea-\ntures of WS-BPEL, and (2) mechanizing the verification\nsystem for practical use.\nReferences\n[1] W. Aalst, M. Dumas, A. Hofstede, and P. Wohed. Analysis of\nweb services composition languages: The case of bpel4ws.\nIn LNCS, volume 2813, pages 200\u2013215. 22nd International\nConference on Conceptual Modeling, Springer, 2003.\n[2] A. Alves, A. Arkin, S. Askary, and et al. Web Services\nBusiness Process Execution Language Version 2.0. OASIS\nStandard, http:\/\/docs.oasis-open.org\/wsbpel\/2.0\/OS\/wsbpel-\nv2.0-OS.html, April 2007.\n[3] C. Barreto, V. Bullard, T. Erl, and et al. Web Services Busi-\nness Process Execution Language Version 2.0 Primer. OA-\nSIS, http:\/\/docs.oasis-open.org\/wsbpel\/2.0\/Primer\/wsbpel-\nv2.0-Primer.html, May 2007.\n[4] M. Butler and C. Ferreira. An operational semantics for stac,\na language for modelling long-running business transactions.\nIn LNCS, volume 2949, pages 87\u2013104, Pisa, Italy, February\n2004. Proceedings of Sixth International Conference on Co-\nordination Models and Languages, Springer.\n[5] Z. Duan, A. Bernstein, P. Lewis, and S. Lu. Semantics based\nverification and synthesis of bpel4ws abstract processes.\npages 734\u2013737. Proceedings of IEEE International Confer-\nence on Web Services, 2004, July 2004.\n[6] M. Fowler and K. Scott. UML distilled : a brief guide to the\nstandard object modeling language. Addison-Wesley, 2000.\n[7] X. Fu, T. Bultan, and J. Su. Analysis of interacting bpel\nweb services. pages 621\u2013630. Thirteenth InternationalWorld\nWide Web Conference (WWW 2004), ACM Press, 2004.\n[8] H. Garcia-Molina and K. Salem. Sagas. pages 249\u2013259, San\nFrancisco, USA, May 1987. Proceedings of the Association\nfor Computing Machinery Special Interest Group on Man-\nagement of Data 1987 Annual Conference, ACM Press.\n[9] R. Hamadi and B. Benatallah. A petri net-based model for\nweb service composition. volume 47, pages 191\u2013200, Ade-\nlaide, Australia, 2003. Proceedings of the 14th Australasian\ndatabase conference.\n[10] J. He, H. Zhu, and G. Pu. A model for bpel-like languages.\nFrontiers of Computer Science in China, 1(1):9\u201319, 2007.\n[11] F. Leymann. WSFL: Web Services Flow Language. IBM,\nhttp:\/\/www-4.ibm.com\/software\/solutions\/webservices\/pdf\/\nWSFL.pdf, May 2001.\n[12] C. Luo, S. Qin, and Z. Qiu. Verifying BPEL-like Programs\nwith Hoare Logic. Technical report, Durham University,\nhttp:\/\/www.dur.ac.uk\/shengchao.qin\/papers\/tase08 TR.pdf.\nAvailable also at http:\/\/www.math.pku.edu.cn:8000\/var\/\npreprint\/7200.pdf, March 2008.\n[13] J. Moss. Nested Transactions: An Approach to Reliable Dis-\ntributed Computing. PhD thesis, Massachusetts Institute of\nTechnology, 1981.\n[14] G. Pu, H. Zhu, Z. Qiu, S. Wang, X. Zhao, and J. He. Theoret-\nical foundation of scope-based compensable flow language\nfor web service. In LNCS, volume 4037, pages 251\u2013266.\nInt\u2019l Conf. on Formal Methods for Open Object-Based Dis-\ntributed Systems (FMOODS\u201906), Springer, June 2006.\n[15] Z. Qiu, S. Wang, G. Pu, and X. Zhao. Semantics of bpel4ws-\nlike fault and compensation handling. In LNCS, volume\n3582, pages 350\u2013365. Formal Methods: Int\u2019l Symposium of\nFormal Methods Europe, Springer, July 2005.\n[16] Z. Qiu, X. Zhao, C. Cai, and H. Yang. Towards the theoret-\nical foundation of choreography. pages 973\u2013982. Proceed-\nings of Sixteenth International World Wide Web Conference\n(WWW 2007), ACM Press, May 2007.\n[17] S. Thatte. XLANG: Web Service for Business Process De-\nsign. Microsoft, http:\/\/www.gotdotnet.com\/team\/xml\nwsspecs\/xlang-c\/default.htm, 2001.\n[18] Q. Xu, W. P. de Roever, and J. He. The rely-guarantee\nmethod for verifying shared variable concurrent programs.\nFormal Aspects of Computing, 9(2):149\u2013174, 1997.\n[19] H. Zhu. Linking the Semantics of a Multithreaded Discrete\nEvent Simulation Language. PhD thesis, London South Bank\nUniversity, Feburary 2005.\n[20] H. Zhu, J. He, J. Li, and J. Bowen. Algebraic approach to\nlinking the semantics of web services. pages 315\u2013328. Fifth\nIEEE International Conference on Software Engineering and\nFormal Methods, September 2007.\n158\n"}