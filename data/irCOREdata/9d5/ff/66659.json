{"doi":"10.1109\/TMM.2003.819094","coreId":"66659","oai":"oai:dro.dur.ac.uk.OAI2:608","identifiers":["oai:dro.dur.ac.uk.OAI2:608","10.1109\/TMM.2003.819094"],"title":"CyberWalk : a web-based distributed virtual walkthrough environment.","authors":["Chim, J.","Lau, R. W. H.","Leong,  H. V.","Si, A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2003-12","abstract":"A distributed virtual walkthrough environment allows users connected to the geometry server to walk through a specific place of interest, without having to travel physically. This place of interest may be a virtual museum, virtual library or virtual university. There are two basic approaches to distribute the virtual environment from the geometry server to the clients, complete replication and on-demand transmission. Although the on-demand transmission approach saves waiting time and optimizes network usage, many technical issues need to be addressed in order for the system to be interactive. CyberWalk is a web-based distributed virtual walkthrough system developed based on the on-demand transmission approach. It achieves the necessary performance with a multiresolution caching mechanism. First, it reduces the model transmission and rendering times by employing a progressive multiresolution modeling technique. Second, it reduces the Internet response time by providing a caching and prefetching mechanism. Third, it allows a client to continue to operate, at least partially, when the Internet is disconnected. The caching mechanism of CyberWalk tries to maintain at least a minimum resolution of the object models in order to provide at least a coarse view of the objects to the viewer. All these features allow CyberWalk to provide sufficient interactivity to the user for virtual walkthrough over the Internet environment. In this paper, we demonstrate the design and implementation of CyberWalk. We investigate the effectiveness of the multiresolution caching mechanism of CyberWalk in supporting virtual walkthrough applications in the Internet environment through numerous experiments, both on the simulation system and on the prototype system","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66659.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/608\/1\/608.pdf","pdfHashValue":"2c640a393c14f7c95e0ccdf1814bd5450373c069","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:608<\/identifier><datestamp>\n      2011-06-14T15:43:10Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        CyberWalk : a web-based distributed virtual walkthrough environment.<\/dc:title><dc:creator>\n        Chim, J.<\/dc:creator><dc:creator>\n        Lau, R. W. H.<\/dc:creator><dc:creator>\n        Leong,  H. V.<\/dc:creator><dc:creator>\n        Si, A.<\/dc:creator><dc:description>\n        A distributed virtual walkthrough environment allows users connected to the geometry server to walk through a specific place of interest, without having to travel physically. This place of interest may be a virtual museum, virtual library or virtual university. There are two basic approaches to distribute the virtual environment from the geometry server to the clients, complete replication and on-demand transmission. Although the on-demand transmission approach saves waiting time and optimizes network usage, many technical issues need to be addressed in order for the system to be interactive. CyberWalk is a web-based distributed virtual walkthrough system developed based on the on-demand transmission approach. It achieves the necessary performance with a multiresolution caching mechanism. First, it reduces the model transmission and rendering times by employing a progressive multiresolution modeling technique. Second, it reduces the Internet response time by providing a caching and prefetching mechanism. Third, it allows a client to continue to operate, at least partially, when the Internet is disconnected. The caching mechanism of CyberWalk tries to maintain at least a minimum resolution of the object models in order to provide at least a coarse view of the objects to the viewer. All these features allow CyberWalk to provide sufficient interactivity to the user for virtual walkthrough over the Internet environment. In this paper, we demonstrate the design and implementation of CyberWalk. We investigate the effectiveness of the multiresolution caching mechanism of CyberWalk in supporting virtual walkthrough applications in the Internet environment through numerous experiments, both on the simulation system and on the prototype system. <\/dc:description><dc:subject>\n        Distributed virtual environments<\/dc:subject><dc:subject>\n         Model prefetching<\/dc:subject><dc:subject>\n         Multiresolution caching<\/dc:subject><dc:subject>\n         Multiresolution modeling<\/dc:subject><dc:subject>\n         Virtual walkthrough.<\/dc:subject><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        IEEE transactions on multimedia, 2003, Vol.5(4), pp.503-515 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2003-12<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:608<\/dc:identifier><dc:identifier>\n        issn:1520-9210<\/dc:identifier><dc:identifier>\n        doi:10.1109\/TMM.2003.819094<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/608\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/TMM.2003.819094<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/608\/1\/608.pdf<\/dc:identifier><dc:rights>\n        (c) 2003 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:1520-9210","1520-9210"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2003,"topics":["Distributed virtual environments","Model prefetching","Multiresolution caching","Multiresolution modeling","Virtual walkthrough."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n04 July 2008\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nChim, J. and Lau, R. W. H. and Leong, H. V. and Si, A. (2003) \u2019CyberWalk : a web-based distributed virtual\nwalkthrough environment.\u2019, IEEE transactions on multimedia., 5 (4). pp. 503-515.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/TMM.2003.819094\nPublisher\u2019s copyright statement:\n(c) 2003 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nIEEE TRANSACTIONS ON MULTIMEDIA, VOL. 5, NO. 4, DECEMBER 2003 503\nCyberWalk: A Web-Based Distributed\nVirtual Walkthrough Environment\nJimmy Chim, Rynson W. H. Lau, Member, IEEE, Hong Va Leong, and Antonio Si, Member, IEEE\nAbstract\u2014A distributed virtual walkthrough environment al-\nlows users connected to the geometry server to walk through a\nspecific place of interest, without having to travel physically. This\nplace of interest may be a virtual museum, virtual library or virtual\nuniversity. There are two basic approaches to distribute the vir-\ntual environment from the geometry server to the clients, complete\nreplication and on-demand transmission. Although the on-demand\ntransmission approach saves waiting time and optimizes network\nusage, many technical issues need to be addressed in order for the\nsystem to be interactive.\nCyberWalk is a web-based distributed virtual walkthrough\nsystem developed based on the on-demand transmission approach.\nIt achieves the necessary performance with a multiresolution\ncaching mechanism. First, it reduces the model transmission\nand rendering times by employing a progressive multiresolution\nmodeling technique. Second, it reduces the Internet response time\nby providing a caching and prefetching mechanism. Third, it\nallows a client to continue to operate, at least partially, when the\nInternet is disconnected. The caching mechanism of CyberWalk\ntries to maintain at least a minimum resolution of the object\nmodels in order to provide at least a coarse view of the objects\nto the viewer. All these features allow CyberWalk to provide\nsufficient interactivity to the user for virtual walkthrough over the\nInternet environment.\nIn this paper, we demonstrate the design and implementation\nof CyberWalk. We investigate the effectiveness of the multires-\nolution caching mechanism of CyberWalk in supporting virtual\nwalkthrough applications in the Internet environment through nu-\nmerous experiments, both on the simulation system and on the pro-\ntotype system.\nIndex Terms\u2014Distributed virtual environments, model\nprefetching, multiresolution caching, multiresolution modeling,\nvirtual walkthrough.\nI. INTRODUCTION\nI N A VIRTUAL walkthrough application, a viewer could ex-plore a specific place of interest without having to travel\nphysically. The place of interest is usually modeled as a vir-\ntual environment, containing a vast number of virtual objects.\nManuscript received December 1, 2000; revised March 18, 2002. This work\nwas supported in part by an SRG grant from the City University of Hong Kong\n(Project 7001071), and the Hong Kong Polytechnic University Central Grant\n(Grant G-T040). The associate editor coordinating the review of thi spaper and\napproving it for publication was Dr. Chung-Sheng Li.\nJ. Chim was with the Department of Computing, the Hong Kong Polytechnic\nUniversity, Hong Kong. He is now with the School of Visual Arts, New York,\nNY 10010-3994 USA.\nR. W. H. Lau is with the Departments of Computer Science and Computing\nEngineering and Information Technology, City University of Hong Kong,\nKowloon, Hong Kong (e-mail: rynson@cs.cityu.edu.hk).\nH. V. Leong is with Department of Computing, The Hong Kong Polytechnic\nUniversity, Hong Kong.\nA. Si is with Oracle Corporation, Redwood Shores, CA 94065 USA.\nDigital Object Identifier 10.1109\/TMM.2003.819094\nSample applications of this sort include virtual museum, virtual\nlibrary, and virtual university [18]. is a distributed\nvirtual walkthrough system, employing a standard client\u2013server\narchitecture. Information of virtual objects, including their lo-\ncations and geometric shapes, is maintained in a central data-\nbase server. A viewer using a client machine connected to the\nInternet may access and visit the virtual environment provided\nby the server. When the viewer walks through the environment,\ninformation of virtual objects located within a visible distance\nfrom the viewer will be conveyed to the client machine for ren-\ndering. In general, virtual objects could be dynamic, changing\ntheir locations and orientations within the virtual environment.\nHowever, in this paper, we only focus on virtual environments\nwhere objects are static. The goal of is to provide\ngood performance, both in terms of responsiveness and reso-\nlution, under the existing constraints of relatively low Internet\nbandwidth and the large memory demand of virtual objects.\nWe are addressing several research issues in .\nFirst, virtual objects must be modeled in a compact form so\nas to reduce the storage space needed and the time required\nto transfer the objects from the server to a client. A compact\nmodeling of virtual objects also has the benefit of fast retrieval\nfrom secondary storage, both at the server and at a client. How-\never, over-compact modeling of virtual objects will increase\nthe overheads in compressing and decompressing the objects.\nemploys the progressive multiresolution technique\nfor object modeling [12], [15]. The technique allows progressive\ntransmission of object models with only minimal overheads.\nSecond, with the limited bandwidth of the Internet, we need\nto reduce the amount of data requested over the network for\nfaster response time. addresses this problem by em-\nploying caching and prefetching mechanisms. A caching mech-\nanism allows a client to utilize its memory and local storage to\ncache currently visible objects that are likely to be visible in the\nnear future [10]. A prefetching mechanism allows a client to pre-\ndict objects that are likely to be visible in the future and obtain\nthe objects in advance to improve response time. A good caching\nmechanism should retain objects with high affinity while a good\nprefetching mechanism should predict those objects which will\nmost likely be needed in the future.\nThird, the Internet often suffers from various degrees of dis-\nconnection. The local cache of a client can be used to provide\npartial information to support a certain degree of disconnected\noperation. For example, a viewer may still be able to see a coarse\nresolution of objects in the virtual environment if the minimal\napproximated models of the objects are cached. Even if only the\ncoordinates of the virtual objects are cached, a viewer could still\nbe aware of their existence.\n1520-9210\/03$17.00 \u00a9 2003 IEEE\n504 IEEE TRANSACTIONS ON MULTIMEDIA, VOL. 5, NO. 4, DECEMBER 2003\nThe rest of the paper is organized as follows. Section II\npresents a survey on relevant research. Section III presents the\ndesign of in detail. Section IV discusses the im-\nplementation of our experimental prototype system. Section V\nquantifies the performance of our caching and prefetching\nmechanisms with several experiments on . Finally,\nSection VI concludes our paper with a discussion on possible\nfuture work.\nII. RELATED WORK\nIn this section, we summarize existing work in three different\nareas which are fundamental to our work. First, we briefly look\nat the strengths and limitations of existing distributed virtual\nwalkthrough systems. Next, we summarize related multiresolu-\ntion methods for object modeling. Finally, we point out the ra-\ntionale for employing replacement and prefetching techniques\nin .\nA. Distributed Virtual Walkthrough Systems\nTwo main approaches have been proposed to distribute virtual\nobjects from the server to the clients in distributed virtual reality\napplications [25]. Most systems, such as DIVE [4], SIMNET\n[2], and VLNET [20], employ a complete replication approach\nto distribute all geometry data to the clients before the start of\nthe application. Since the geometry database is usually large in\nsize, this approach assumes the use of a high speed network\nin order to reduce preloading time and may not be suitable for\n. A few systems employ the on-demand transmis-\nsion approach to distribute geometry data to the clients [9], [21],\n[24] at runtime. When the virtual environment is large, a viewer\nwould likely only visit a small section of it. This approach re-\nquires only the visible region of the environment to be trans-\nmitted to the client and can thus reduce startup time and net-\nwork traffic. It, however, introduces a number of problems. In\nparticular, we need to fetch the visible objects from the server\nin advance so that they can be available in the client when they\nare needed, in order for the walkthrough application to be in-\nteractive. In [27], this interactive problem was addressed as a\nscheduling problem, with emphasis on deadline and admission\ncontrol of clients to sustain certain level of quality of service.\nHowever, the research work did not consider the client cache\nand, more importantly, did not make use of the multiple granu-\nlarity of the object models, which constitute two major sources\nof performance improvement in . We address this\ninteractive problem as well as related problems, such as con-\ntinued viewing service in momentary network congestion and\nclient disconnection, with a number of solutions as will be de-\nscribed in Section III.\nIn a conventional client-server database environment, data\nobjects are usually transferred from the database server to a\nclient on a per-page basis [3], [10]. This is primarily because\nthe server\u2019s storage is also page-based. The overheads for trans-\nmitting one item or a page are similar. In a distributed virtual en-\nvironment, virtual objects are represented using object models.\nThese models are usually large in size, occupying possibly mul-\ntiple pages. The cost to transfer them in their entirety via the In-\nternet is very high. Furthermore, we might not always need to\nFig. 1. Structure of a progressive mesh.\nrender an object at its full resolution. Hence, there will be situ-\nations that we need to transfer less than a page of information\nand situations that we need to transfer more than a page of in-\nformation. A more dynamic granularity for caching is therefore\nneeded in a distributed virtual environment. To combat frequent\nnetwork disconnections of the Internet, a storage cache, which\nhas the advantage of persistence, may be established. When dis-\nconnected from the server, a client can still operate on the cached\ndatabase objects in its local storage.\nB. Multiresolution Modeling\nIn a distributed environment, rendering a complex object at a\nclient is computationally expensive. From the perspective of a\nviewer in the environment, distant objects appear smaller than\nnearby objects after perspective projection. Most details of a dis-\ntant object are actually not visible to the viewer. Hence, it is only\nnecessary to represent the object at a resolution high enough\nfor a given viewing distance. This could reduce not only the\nrendering time, but also the transmission delay and the storage\nspace required at the client. employs multiresolu-\ntion modeling techniques for caching and prefetching objects in\na client at various granularities, with nearby objects at higher\nresolution and distant objects at lower one.\nA method referred to as progressive meshes was recently\nproposed to encode object models for progressive transmission\n[12]. The method is based on two operations, edge collapse for\nreducing model resolution, and edge split for increasing model\nresolution. Each object is modeled as an ordered list. The list\nbegins with a minimal resolution model of the object, referred\nto as the base mesh. Each subsequent record in the list, referred\nto as a progressive record, stores information of an edge split.\nThe structure of a progressive mesh is shown in Fig. 1. If\nwe apply each progressive record to the base mesh in order,\nthe object model will gradually increase in resolution until it\nreaches the maximum. Conversely, the method may begin with\nthe highest resolution model. If we apply each of the records in\nreverse order, which is equivalent to an edge collapse operation,\nthe object model will gradually decrease in resolution until\nit reaches the resolution of the base mesh. We have recently\ndeveloped a similar method independently [13], [15].\nC. Replacement and Prefetching Techniques\nIf a client can provide unbounded disk storage and wait for\na possibly very long preloading time, we could transmit all vir-\ntual objects in the environment to the client before starting the\nwalkthrough. This approach is adopted by some existing dis-\ntributed virtual walkthrough systems [2], [4], [20]. However, a\nmore realistic situation is that the available cache storage and\npreloading time are limited. Furthermore, preloading a large\nsection of a database would saturate the network with unnec-\nessary traffic, depriving other clients of their service. To avoid\nCHIM et al.: : WEB-BASED DISTRIBUTED VIRTUAL WALKTHROUGH ENVIRONMENT 505\nthis bandwidth over-utilization, employs cache re-\nplacement policy to retain only frequently accessed objects in\nthe cache and prefetching mechanisms to prefetch only poten-\ntially visible objects in order to reduce access and rendering la-\ntency.\nIn [8], various cache replacement policies have been proposed\nand their suitabilities in a conventional database system have\nbeen examined. Policies such as Least Recently Used (LRU) and\nLeast Reference Density (LRD) are being used widely. These\npolicies are derived from their counterpart in operating systems.\nIn the context of databases, the Most Recently Used (MRU)\npolicy is also occasionally adopted to cater for cyclic data ac-\ncess behavior. These policies are all page-based, due to the log-\nical mapping made by the database or operating system to the\nphysical storage. In general, the performance of individual re-\nplacement policies is sensitive to the characteristics of queries\ninitiated. A general conclusion on the performance of the re-\nplacement policies cannot be made. In practice, replacement\npolicy is often approximated by the LRU policy in conventional\ncaching [3], [10], [23]. In [22], we show that LRU policy is not\nappropriate in a context where objects accessed by a client might\nchange over time. Rather, the semantics of data access is more\nimportant in defining the replacement policy. We therefore need\nto develop a more appropriate replacement policy based on the\nsemantics of accesses in a walkthrough environment. This has\nbeen shown to be effective in our preliminary work [7]. Fur-\nthermore, we have also noticed in [5] that prefetching could be\nvery beneficial in improving the performance of database ap-\nplications if the prefetching is performed intelligently. In [14],\nprefetching has been adopted to reduce the expected access time\nto a sequence of web page accesses. Experimental results have\ndemonstrated the benefits brought about by prefetching.\nIII. DESIGN OF\nIn , each virtual object is stored in the database\nserver at its maximum resolution in the form of a progressive\nmesh. The use of such a multiresolution method allows the data-\nbase server to transmit an object model at a resolution just high\nenough for rendering. This could save scarce Internet bandwidth\nfrom transmitting extra details of distant objects. The resolu-\ntion of an object model at a particular point in time is deter-\nmined by its distance from the viewer and its angular distance\nfrom the viewer\u2019s line of sight. However, it would be expen-\nsive to determine the resolution of every object within the vir-\ntual world whenever the viewer makes a movement. In practice,\nthe number of objects that are visible to a viewer is limited, de-\npending on the depth of sight of the viewer. Hence, we could\nfurther minimize the number of objects needed to be handled\nin each frame by associating the concept of depth of sight with\neach viewer. Objects beyond the depth of sight of a viewer will\nnot need to be transmitted from the server to the client, nor do\nthey need to be rendered. In , the depth of sight of a\nviewer is modeled by the idea of object scope and viewer scope.\nTo further reduce the dependency on the Internet, to lower the\ntransmission delay, and to support disconnected operation, we\nhave incorporated a caching mechanism to retain objects of high\naffinity and a prefetching mechanism to predict those that will\nlikely be accessed in the near future.\npossesses several advantages over previous\napproaches. First, previous approaches use an LoD method\n[21] for model transmission. Redundant information will be\nsent over the network, since multiple models of the same object\nat different resolutions need to be transmitted. Our method\napplies the progressive mesh technique for model transmission.\nNo redundant information needs to be sent across the network.\nSecond, the importance of an object is calculated based not\nonly on the distance of the object from the viewer, but also\non the size of the object concerned, the depth of sight of the\nviewer, and the resolution of the viewing device, allowing\nthe object models to be rendered at the lowest cost. Third,\nour caching mechanism differs from conventional caching\nmechanisms [3], [10], [23] in that objects could be cached\nat multiple granularities. Cache replacement is also based on\nobject access patterns rather than on the conventional LRU\npolicy. Finally, the performance of the walkthrough application\nis further improved by predicting the future movement of the\nviewer and prefetching objects in advance.\nA. Object Scope\nTo minimize the amount of data needed to be handled, most\nexisting methods consider only the area of interest (AOI) of\na viewer [9], [17], [21]. If an object falls inside the AOI of a\nviewer, the object is considered visible to the viewer. Other-\nwise, the object is considered too far to be visible. Although\nthese methods can quickly eliminate invisible objects, they do\nnot consider the object size. Hence, a mountain located just out-\nside the AOI of a viewer may still be visible to the viewer, but\nis considered as invisible, while a tiny object such as an insect\nlocated just inside the AOI of a viewer is unlikely to be visible\nto the viewer, but is considered for visibility. The former situa-\ntion may result in a sudden appearance of large objects, and the\nlatter situation may result in a waste of processing time.\nTo overcome this limitation, we generalize the AOI concept\nto both viewers and objects. We call them viewer scope and\nobject scope. We denote the viewer scope for viewer by\nand the object scope for object by . A viewer scope is\nsimilar to AOI. It indicates the depth of sight of a viewer, i.e.,\nhow far the viewer can see. A viewer with a good eyesight or\nequipped with a special device may be able to see objects that\nare further away, and therefore may be assigned with a larger\nscope. A short-sighted viewer may only be able to see nearby\nobjects, and therefore may be assigned with a smaller scope.\nAn object scope indicates how far an object can be seen. A large\nobject has a larger scope and a small object has a smaller scope.\nIn general, a viewer may also be considered as an object and\nassigned with an object scope in addition to the viewer scope.\nThis object scope of the viewer will define how far the viewer\ncan be seen by another viewer in the virtual environment. This\napproach is somewhat similar to the one proposed by [11]. In\n, we define a scope as a circular region. Therefore,\neach scope (object or viewer) is characterized by a radius.\nAn object may be visible to a particular viewer only when\nits scope overlaps with the viewer scope. When the two scopes\n506 IEEE TRANSACTIONS ON MULTIMEDIA, VOL. 5, NO. 4, DECEMBER 2003\nFig. 2. Interaction between the viewer and the objects in the virtual\nenvironment.\noverlap, the object\u2019s distance from the viewer and the object\u2019s\nangular distance from the viewer\u2019s viewing direction are used to\ndetermine the resolution, called the optimal resolution, at which\nthe object should be rendered. If an object is rendered at a reso-\nlution higher than this optimal resolution, the additional details\nwill not be easily noticeable to the viewer. By contrast, if an\nobject is rendered at a resolution lower than this optimal reso-\nlution, the image quality of the rendered object as perceived by\nthe viewer drops rapidly [6]. Such perceived image quality is\ncalled visual perception. The interaction between a viewer and\nthe virtual environment is illustrated in Fig. 2. In addition to the\nviewer scope, each viewer is also associated with a viewing\ndirection , a location , and a viewing region. The viewing\ndirection defines the viewer\u2019s line of sight. Given the location of\na viewer, all virtual objects whose object scopes intersect with\nthe viewer scope are potentially visible to the viewer. These ob-\njects will be associated with the highest priority for caching in\nthe client\u2019s memory and we refer to them as cachable objects.\nEven though some objects may be located behind the viewer, the\nviewer should be able to see them within a very short moment\nsimply by a brief rotation. The viewing region is a sub-space\nof the viewer scope and is captured by a viewing angle. All\ncachable objects within the viewing region are considered for\nrendering at their optimal resolution, and we refer to them as\nrenderable objects.\nB. The Optimal Resolution\nThe optimal resolution of an object model can be determined\naccording to the visual importance of the object to the viewer.\nIn [16], we have identified several factors that may affect the vi-\nsual importance of an object. Those factors can all be considered\nhere. However, for the sake of clarity, we only consider two of\nthose factors, which are relevant to the context of .\nThe first one is the distance factor. If an object is far away from\nthe viewer, the object may be considered as visually less im-\nportant. The second one is the line of sight factor. Studies have\nshown that when an object is located outside the line of sight, the\nviewer is unable to perceive much detail from the object [19],\n[26]. Degradation of peripheral visual details can improve ren-\ndering performance and reduce perceptual impact. In our im-\nplementation, we assume that the viewer\u2019s line of sight is at the\ncenter of the screen.\nFig. 3 depicts visual importance of object to viewer .\nis the current distance between and , while is\nthe distance between them when their scopes just overlap. Since\na scope is defined as a circular region, is the sum of\nthe radii of the two scopes. The angular distance of from the\nFig. 3. Visual importance of an object to a viewer.\nviewer\u2019s line of sight, , is denoted by , where\n. can be defined as\n(1)\nThe first term models the effect of the distance between and\non . Higher results in a lower . The second term models\nthe effect of the angular distance of from the viewer\u2019s line of\nsight on . Higher results in a lower . Since this relation-\nship is not a linear one, a constant is introduced for adjusting\nthe decrement rate of the model resolution due to the increase\nin .\nThe value of in (1) must be chosen carefully because it\nwill affect the performance of visual importance estimation and\nhence, caching and prefetching performance. We determine here\nthe value of for an optimal visual importance distribution.\nEquation (1) can be rewritten as follows:\n(2)\nLet be the angular cutoff point where the visual importance\nwould be assumed to be effectively reduced to zero, be the\nvolume of within , and be the volume of beyond .\nWe now try to find such that is maximized:\n(3)\n(4)\n(5)\nSubstitute (4) and (5) into (3), and perform a differentiation\nto establish :\nSolving for with , we get\nsuch that the visual importance for objects within the\nstereo vision will be optimal. The perspective view, top view,\nCHIM et al.: : WEB-BASED DISTRIBUTED VIRTUAL WALKTHROUGH ENVIRONMENT 507\nFig. 4. Visual importance distribution.\nfront view and side view of the visual importance distribution\nare illustrated in Fig. 4.\nIn , visual importance of object is used to de-\ntermine the optimal resolution of its model. In effect, indicates\nthe percentage of progressive records of required to be rendered\nin addition to its base mesh. During the walkthrough, we contin-\nuously determine those cachable objects. When an object scope\ntouches theperimeterof theviewer scope, willbeequal to0and\nthe optimal resolution of the object will be equal to its base mesh,\nwhich provides the minimal resolution of the object. As the ob-\nject moves closer to the viewer or to the viewer\u2019s line of sight, its\noptimal resolution increases. Extra progressive records are then\ntransmitted to the client if they are not already available from the\nlocal cache, so that the resolution of the object model can be in-\ncreased to match with its optimal resolution.\nC. The Cache Model\nAt the start of the walkthrough, the locations of all objects\nin the virtual environment and the radii of their object scopes\nare sent to the client machine . Depending on the sizes of the\nvirtual environment and the local cache, we may also preload the\nbase meshes of all or some of the objects in the environment.\nSince the size of a base mesh can be as small as 0.1% of that\nof the full resolution model, preloading the base meshes may\nreduce the system latency at the cost of only slightly increased\npreloading time.\nAt the client, the size of the viewer scope and the cachable ob-\njects are determined. The cachable object models at their optimal\nresolutions are then transmitted to . As the viewer moves within\ntheenvironment, continuouslydetermines thecachableobjects\nat each step. Each cached object is associated with a resolution\nindicating its current highest possible resolution available for\nrendering. will then generate a request list for the cachable ob-\njects not in the local cache. Each entry of the request list con-\ntains (ID of ), , and (expected optimal resolution of\n). The server then transmits the outstanding progressive records\nand\/or base meshes to , with renderable objects transmitted be-\nfore other cachable objects.\n508 IEEE TRANSACTIONS ON MULTIMEDIA, VOL. 5, NO. 4, DECEMBER 2003\nFig. 5. Prediction of moving direction using (a) mean, (b) window, and (c) EWMA.\nModels received by will be cached in the local storage. If\nthe storage is exhausted, will employ a replacement policy\nto identify victim objects to be discarded. An access score is\ndetermined for each object indicating the prediction of its future\naccess affinity. An object will be cached if it has a higher score.\nSome progressive records of the cached object with the lowest\nscore will be reclaimed, i.e., will try to decrease the\nresolution of cached objects with lowest scores. It also attempts\nto further improve the performance by prefetching objects likely\nto be accessed in the future, by predicting the next location and\nviewing direction of the viewer based on his\/her past movement\nprofile.\nD. Multiresolution Replacement Scheme\nemploys the Most Required Movement (MRM)\nreplacement technique. Normally, the farther an object is from\nthe viewer, the longer it will take for the viewer to move to view\nthe object in greater detail. Similarly, the larger the angular dis-\ntance of an object is from the viewer\u2019s line of sight, the longer it\nwill take for the viewer to rotate to view the object directly in the\nfront. Both lead to a lower value in caching the object. Simulated\nexperiments have shown that such a replacement scheme out-\nperforms traditional LRU replacement scheme [7]. In this work,\nwe have incorporated the idea of the object scope and the viewer\nscope for visibility determination.\nAmong all possible formulae for calculating the access score\nof an object, we prefer a simple one to model the line of sight\nand the distance factors. The simplest formula is a weighted av-\nerage of the input factors. To make these factors comparable, we\nnormalize them with their reference values. The distance factor\nis normalized by the sum of the radii of the viewer scope and\nthe object scope . The line of sight factor is normal-\nized by the maximum angular distance from the viewer\u2019s line\nof sight . We have developed a formula for estimating the\naccess score with a single parameter . Using the\nnotations in Fig. 3, the access score of object is defined as\n(6)\nWhen the object with the lowest access score is selected for\nreplacement, we first remove the extra progressive records of the\nobject to reduce its resolution to the optimal resolution. If there\nis still not enough room, the object with the next lowest access\nscore will be taken and this process will be iterated. When there\nis still not enough room even after all cached objects have been\nreduced to their optimal resolutions, all progressive records of\nthe object with the lowest score will be removed, leaving only\nits base mesh. Again, this process will be iterated. Finally, the\nbase mesh of the objects with the lowest scores will be removed.\nThis multiresolution replacement scheme tries its best to keep\nat least the base meshes of the cached objects in the client\u2019s\ncache storage. This provides the viewer with a much better vi-\nsual perception since all or most of the cachable objects could\nbe seen instantaneously, even though they may only be visible\nat a low resolution.\nE. Prefetching Mechanism\nTo enable prefetching, the client maintains a profile of the\nviewer, containing the list of historical movement vectors,\n. Each vector is calculated from the\nviewer\u2019s moving direction and location at a particular time.\nWhen the viewer moves to a new location with a new\norientation, the th movement vector is determined. The\nclient will then attempt to predict the th movement\nvector as and request for the transmission of the objects\nthat would become cachable if the viewer were at ,\nin addition to the cachable objects at . This would save\nfuture requests to the server if the prefetched objects are indeed\nrequired by the client.\nPossible prediction schemes include , and\n, as shown in Fig. 5. In the scheme, the next\nmovement vector is predicted as the average of the\nprevious movement vectors, as depicted in Fig. 5(a) with\nthree movement vectors. In the scheme, each viewer\nis associated with a window of size , holding the previous\nmovement vectors. The next movement vector is predicted\nas the average of the most recent vectors. This is indicated\nin Fig. 5(b), showing a window of size . A problem for\nthe window scheme is that all movement vectors within the\nwindow have equal effect on the prediction.\nTo better approximate the real movement, and to adapt\nquickly to changes in the viewer\u2019s moving patterns,\nemploys the (exponentially weighted moving average)\napproach to predict the next location of the viewer. It assigns\nexponentially decreasing weights to each previous movement\nvector . With parameter , the most recent vector will\nreceive a weight of 1, the previous , the next previous , and\nso on. This idea is depicted in Fig. 5(c), indicating the predicted\nmoving direction. The new th movement vector is\nestimated as .\nhas been shown to be quite effective in predicting\naccess probabilities of data items in database applications by\nadapting rather quickly to changes of access patterns [22]. How-\never, it might not perform as satisfactorily in this new context of\npredicting the next viewer location. This is because the access\nCHIM et al.: : WEB-BASED DISTRIBUTED VIRTUAL WALKTHROUGH ENVIRONMENT 509\nFig. 6. Architecture of CyberWalk.\nprobability of a data item is bounded between 0 and 1.\nis trying to incorporate the effect of the change into the new es-\ntimate and normally, the estimation error would not diverge. In\nthe new context here, we are using to predict a vector,\nwhose direction is an angle with an unbounded range, i.e., the\nangle can increase indefinitely, for example, through continuous\nrotation in a circle. Thus, may not be able to cope\nwith the \u201cnonstationary\u201d changes. We need to explicitly correct\nthe prediction with adjustment from residuals or error predic-\ntions. The residual in predication of is .\nWe consider the angle between and , denoted as\n, where is the argument of vector\nin a complex plane. can be predicted by rotating\nthrough an angle of , i.e., a multiplication by . Since\nwe do not really know when we predict , we must\ntry to predict as well. There can be different ways of pre-\ndicting from the previous values of . Again,\nuses to compute the prediction of in each step\nas we compute . Thus, , and\n. We call this the - (\nwith residual adjustment) scheme, since it involves the adjust-\nment to the direction of each movement.\nIV. IMPLEMENTATION OF\nThe architecture of is composed of two main\nparts, the Client Subsystem and the Server Subsystem, as shown\nin Fig. 6. The Server Subsystem consists of four main compo-\nnents. The Server Manager serves as the coordinator of all other\ncomponents at the Server Subsystem and handles all clients\u2019 re-\nquests. The Database Agent maintains the database of the virtual\nenvironment. It is also responsible for identifying and sending\nthe relevant object models to the client in the form of progres-\nsive meshes, upon receiving requests from it. The Client Han-\ndler receives requests from each client, processes the requests\nand sends the requested data back to the client. It is implemented\nas a separate thread for each connected client to reduce response\ntime. The Network Agent handles all communications between\neach client and the server. It also maintains the connection be-\ntween them once a connection is established. When a client re-\nquests for a connection, the Network Agent creates a separate\nClient Handler thread to serve the client.\nThe Client Subsystem consists of five main components. The\nClient Manager serves as the coordinator of all other compo-\nnents at the Client Subsystem. All viewer inputs, such as trans-\nlation or rotation, are directed to and handled by the Client Man-\nager. The Cache Agent controls local caches, including memory\ncache and disk cache at the client. All geometry data would be\ncached via the Cache Agent. The agent maintains a Score Table,\ncontaining the access score of each object in the local caches.\nThe Prefetching Agent prefetches objects from the server based\non historical movement vectors of the client in the form of a\nviewer profile. The Network Agent supports the communication\nbetween a client and the server, maintaining the connection be-\ntween them once a connection is established. It is implemented\nas a separate thread under the Client Manager to exploit exe-\ncution concurrency. The Display Agent accepts inputs from the\nviewer and generates output images for display.\nExcept for the Display Agent, the prototype is implemented\nusing Java, due to its platform independence nature. The Display\nAgent is implemented using OpenGL, as it would utilize the un-\nderlying rendering capability of the client machine, if available,\nfor better performance.\nA. Client\u2013Server Interactions\nA connection-oriented protocol is used in the prototype. The\nconnection between a client and the server is maintained once\nit has been established. This is easily implemented by Java Re-\nmote Method Invocation. We decide to implement our own pro-\ntocol instead of employing the standard HTTP protocol since\nHTTP requires a new connection to be established between the\nclient and server every time before a data transfer. This would\nincrease the response time of the system.\nWhen a client wants to connect to a server, the client sends\na command, specifying the size of its scope and the\nviewing angle. If the server accepts the connection request,\nthe server replies to the client with a new ClientID and some\nstartup information, such as the radii of object scopes and the\npositions of all objects within the virtual environment. As the\nviewer moves or rotates within the virtual environment, the\n510 IEEE TRANSACTIONS ON MULTIMEDIA, VOL. 5, NO. 4, DECEMBER 2003\nclient sends an command to the server followed by a\nrequest list, requesting for the outstanding progressive records\nand\/or base meshes of the cachable objects. If prefetching is\nused, the IDs of the predicted objects would also be included\nin the list. In return, the server will send an signal to the\nclient followed by the list of requested records and meshes.\nNote that there is a slight variation here from our previous\nwork [6] in the way we distribute the tasks between a client and\nthe server. In our previous work, we did not want to make the\nassumption that the viewer had a fast client machine. Hence,\nthe server was responsible for determining the cachable objects\nand running the prediction algorithm. When a viewer moved,\nthe client first sent its new location to the server. The server\nwould then send a list of IDs of the cachable objects and their op-\ntimal resolutions to the client. Upon receiving the list, the client\nwould determine and send the request list of outstanding pro-\ngressive records\/base meshes of those cachable objects. Based\non this list, the server would forward the outstanding data to the\nclient. Although this approach requires minimal computation at\nthe client machine, it increases the network traffic and causes\ntwo roundtrip delays. The delay becomes serious as the trans-\nmission distance between the client and the server increases. In\nthis implementation, we have decided to offload the tasks to the\nclient machine, which is becoming more and more powerful in\nrecent years. This causes only a single roundtrip delay.\nB. Database Structure and Organization\nIn order to provide fast response to client requests, virtual ob-\njects must be organized and maintained in the server in a way\nthat facilitates efficient retrieval. We store each object in the\nvirtual environment into two database files, the mesh file con-\ntaining the base mesh and the record file containing all the pro-\ngressive records of the object.\nWhen the virtual environment is complex, it will most likely\ncontain a huge number of virtual objects. Identifying the set of\ncachable objects with respect to the current position of a viewer\nwill be expensive since the Client Manager has to examine all\nvirtual objects to determine if their object scopes overlap with\nthe viewer scope. To reduce the cost of scope comparison, we\nhave adopted a simple indexing method. We divide the virtual\nenvironment into two-dimensional (2-D) square cells. Each cell\nis a pointer to a list of object IDs. These IDs indicate objects\nwhose scopes overlap with the cell. To determine the cachable\nobjects, we may simply identify the cells that the viewer scope\noverlaps with the objects and the objects IDs found in these cells\nwill simply indicate the cachable objects.\nC. Progressive Mesh Transmission\nIn , a client machine would continuously request\nthe server for objects that are not available in local cache, as\nthe viewer moves around the virtual environment. These re-\nquested objects from the server can be classified into three dis-\njointed groups, the renderable objects, the nonrenderable ob-\njects and the prefetch objects. The nonrenderable objects are\nobjects which are cachable but not renderable, i.e., cachable ob-\njects which are outside the viewing region. The prefetch objects\nare objects which are expected to become cachable in the near\nFig. 7. Example of an edge split operation.\nFig. 8. Data structure of the progressive mesh for transmission.\nfuture as predicted by the prefetching mechanism. These three\ngroups define a total order of transmission: renderable non-\nrenderable prefetch, where denotes the classic precedes\nrelation [1]. In other words, guarantees that pro-\ngressive meshes of the renderable objects will be transmitted\nbefore those of the nonrenderable objects, which in turn, will be\ntransmitted before those of the prefetch objects.\nTo transmit a progressive mesh to the client, the base mesh\nis transmitted first as a single unit. The client reconstructs the\nminimal resolution model of the object as it receives the base\nmesh. Progressive records are then transmitted in order. Each\nrecord stores information of an edge split, thereby increasing the\nresolution of the object model by a small amount. Fig. 7 shows\nan example of such an operation. After an edge split, one vertex,\ni.e., , one edge, i.e., , and two triangles, i.e.,\nand , are inserted into the model. (Note that at the\nsurface boundary, only one triangle is inserted into the model.)\nWe use Fig. 7 as an example to explain the data struc-\nture of a progressive record shown in Fig. 8. First, we\nneed to store the coordinates of the child vertex\nto be inserted into the model and the ID of the parent\nvertex . will join with to form the\ninserted edge. We also need to include the IDs of two ver-\ntices, and . They help to identify the locations\nat which the two new triangles are to be inserted. The two\ntriangles are defined as and\n. When inserting , some\nneighboring vertices of will move to become the neigh-\nboring vertices of . To be able to divide the neighboring\nvertices during an edge split, we maintain a linked list for each\nvertex of the object model at the client. Each linked list points\nto all immediate neighboring vertices of the parent vertex,\nordered in a clockwise direction. Given the IDs of vertices,\nand , the linked list is automatically divided into two\nsegments. As an example, , , , , and will\nbecome the neighboring vertices of while , ,\n, , , and will become the neighboring vertices\nof after the edge split.\nCHIM et al.: : WEB-BASED DISTRIBUTED VIRTUAL WALKTHROUGH ENVIRONMENT 511\nFig. 9. Sample session with the prototype.\nFig. 9 illustrates a sample session of the prototype. Fig. 9(a)\nshows a scene in the virtual environment. Fig. 9(b) illustrates\nthe corresponding model resolutions, with distant objects rep-\nresented by lower resolution models. Fig. 9(c) and (d) show an\nincrease in the resolution of the cow and the tree objects when\nthe viewer moves forward.\nV. RESULTS AND DISCUSSIONS\nWe have conducted extensive experiments to quantify the per-\nformance of our multiresolution scheme with MRM cache re-\nplacement and the effectiveness of various prefetching schemes\nvia simulation as well as on the prototype. The purpose of sim-\nulation is a proof of concept, allowing us to experiment the be-\nhavior of the mechanisms under diverse situations easily. The\nprototype provides a study under a real situation. Due to page\nlimit, we present only a representative subset of experiments in\nthis section. We first present a simulated experiment to illustrate\nthe general behavior of the caching and prefetching schemes,\nfollowed by a more detail analysis of the performance of the\nmechanisms using our prototype.\nWe characterize the performance of the caching and replace-\nment schemes with two metrics: cache hit ratio and visual per-\nception. Cache hit ratio measures the percentage of bytes of the\nrenderable objects, i.e., those within the viewing region, that\ncould be retrieved from the local storage cache of the client.\nA high hit ratio is important to reduce reliance on network and\nto provide service during disconnection. Visual perception mea-\nsures the relative degree (in percentage) of image quality expe-\nrienced by a viewer just after the move. The visual perception\nof a cached renderable object is modeled as a cubic function:\n, where is the expected size of object\nat its optimal resolution and is the size of the object cur-\nrently cached. This definition of visual perception is based on\n512 IEEE TRANSACTIONS ON MULTIMEDIA, VOL. 5, NO. 4, DECEMBER 2003\nTABLE I\nPARAMETERS LISTING FOR EXPERIMENTS\nFig. 10. Moving patterns: (a) CP, (b) CCP, and (c) RW.\nthe fact that when a viewer makes a move in the virtual envi-\nronment, a high visual perception would be experienced if all\nrenderable objects could be seen instantaneously (from the local\ncache) at a resolution close to the optimal one. The visual per-\nception would still be considered as good or acceptable if at a\nminimum, the base meshes of the models are available locally.\nOn the other hand, if some or all of the renderable objects are\nnot visible until after a long period of waiting time, a low visual\nperception is experienced.\nA. Experimental Environment\nThe set of parameters used in our experiments are listed\nin Table I. We focus on a single server and a single client in\nour study here. The size of the virtual environment is set to\n2000 2000 square units. virtual objects are distributed\nuniformly among the square units, each containing an average\nof objects. The viewer\u2019s viewing angle is set to\n120 . The radius of the viewer scope is set to ten units. The\ncache size is set to of the database size.\nWe experimented with different prefetching schemes, in-\ncluding no prefetching ( ), , , and\n. forms a base case for comparison. In the\nscheme, we experimented with four Window sizes,\n. We denote with window size as\n- . We refer to with residual adjustment enabled\nby - , and with residual adjustment disabled\nby - . We experimented with three moving patterns\nof a viewer, as depicted in Fig. 10. Each pattern contains\na sequence of movement steps. The first pattern models a\nconstant circular translation pattern . The viewer moves\ncircularly starting and ending at the same location. Each move-\nment step includes a translation of 15 units along the viewing\ndirection, and then a rotation of the viewing direction by 12 .\nAt each step, the viewer rotates his\/her head by . This\nmodels a situation where a viewer explores the virtual objects\naround him\/her for every movement. The second pattern, called\nchanging circular pattern ( ), models the same pattern as\nexcept that the moving direction changes with an angle of\n10 , after every four movement steps. Finally, in the random\nmoving pattern (random walk or ), each movement step is\neither a translation of arbitrary length or a rotation of arbitrary\nangle.\nB. Experiments From Simulation\nThe purpose of our simulation is to study the performance of\nthe caching mechanism on various moving patterns, with and\nwithout prefetching. In our simulation model, there are 5000\nvirtual objects. Each object is modeled by a progressive mesh.\nThe number of progressive records associated with each object\nmodel follows a normal distribution with a mean of 25 000 and\na standard deviation of 2,500 records. Each progressive record\nhas a size of 40 bytes while each base mesh has a size of 2 KB.\nThe database is approximately 5 GB and the size of the storage\ncache is fixed at 1% of the database.\nThe measurements of the metrics are depicted in Fig. 11. We\nobserve that even without prefetching, the caching mechanism\nperforms reasonably well, achieving a hit ratio ranging from\n79% to 83%. With prefetching, the hit ratios could be improved\nby up to 6%. We observe that is not very effective in\npredicting future movements, with performance similar to that\nof No Prefetch. Both and perform equally\nwell in improving the hit ratios of the caching mechanism.\nWith respect to , a small window size results in better\nperformance under the and moving patterns. Under\nand , the moving direction is always changing, very\noften with a constant angle. With a large window size, aged\nmoving vectors will contribute to the prediction of the moving\nvector, introducing some noise in the prediction. By contrast,\nunder the moving pattern, each movement step bears a\nhigh degree of randomness. The small window does not capture\nenough information to predict the next movement vector. There-\nfore, the performance with a small window size is not as good\nas that with a large window size under . - ex-\nhibits a similar behavior. - performs better under the\nand moving patterns. This is mainly because the angle\ndeviation under these two moving patterns exhibits a well-de-\nfined pattern and is thus predictable. Under the moving pat-\ntern, the angle deviation does not exhibit a clear pattern and the\nresidual correction does not seem to yield any improvement.\nC. Experiments From Prototype\nIn our prototype experiments, the server runs on a Sun Ultra-\nSparc 2 workstation. The client runs on an SGI work-\nstation with 64MB RAM. We study the behavior of the caching\nand prefetching mechanisms under a real system.\nExperiment 1: Our first set of experiments resembles our\nsimulated experiment presented in Section V-B. However, since\nrunning experiments on a prototype is very time-consuming, we\nreduce the number of objects, , to 500 here. The average size\nof each object is also reduced to 200 KB. All other parameters\nremain unchanged. We hope to be able to compare the general\nbehavior of the mechanism under a real system with simulated\nbehavior with this adjustment.\nCHIM et al.: : WEB-BASED DISTRIBUTED VIRTUAL WALKTHROUGH ENVIRONMENT 513\nFig. 11. Performance from simulation.\nFig. 12. Performance from experiment 1.\nThe measurements of the metrics are depicted in Fig. 12.\nFor the moving pattern, the general behavior of the per-\nformance from the prototype is similar to that from the simu-\nlation. The only difference is a slight increase in hit ratios and\nvisual perception by a few percent in the experiment, across all\nprefetching schemes. For other moving patterns, the improve-\nment in hit ratios from seems to be smaller than that\nbrought about by simulation. This is perhaps due to the object\ndistribution in the experimental environment. We are currently\ninvestigating this issue. We hope to be able to report our find-\nings in the future. The impact on visual perception is similar to\nthat on hit ratios, but at a smaller scale.\nExperiment 2: In our second experiment, we study the effect\nof cache size on the performance of the caching and prefetching\nmechanisms. To obtain a better understanding of the effect of\ncache size, we further measure the average response time and la-\ntency time of the prototype. Response time refers to the amount\nof time spent from the moment a client initiates a query for ren-\nderable objects to the moment when the optimal resolutions of\nall renderable objects are available. Latency time refers to the\namount of time spent between the initiation of a query to the\ntime the base meshes of all renderable objects are available at\nthe client. It measures the observable delay experienced by a\nviewer when the viewer makes a move.\nIn this experiment, is again fixed at 500 objects. The\nmoving pattern is fixed at . The size of the storage cache\nranges from 0% to 2% of the database. Other parameters\nremain the same. Fig. 13 depicts the results, with the second\nrow showing the response and latency times of the experiments.\nWith a cache size of only 0.5% of that of the database, the re-\nsponse and latency times of the application are already reduced\nto a quarter and a half respectively, even without prefetching.\nWe observe an increase in hit ratios and visual perception\nwhen the cache size increases. It is simply because a larger cache\nis able to hold more object models; thus, the chance of hitting an\nobject model in the local cache becomes higher. The improve-\nment in both hit ratio and visual perception from to\nis very significant. However, the improvement seems\nto level off when cache size increases beyond 2%.\nis also performing more satisfactorily, yielding similar perfor-\nmance as in the simulation.\nResponse and latency times are not as stable as hit ratio and\nvisual perception, due to their heavy dependency on the avail-\nable network bandwidth when the prototype is running. How-\never, a general observation can still be drawn about their relative\nperformance. With caching, latency time is around 0.25 s. Com-\npared with other prefetching schemes, the schemes\ngenerally result in a smaller access latency. We also observe\nthat prefetching leads to a small improvement in latency. The re-\nsponse time is about 50% higher than the latency, i.e., between\n0.3 s to 0.4 s with a cache size of 1% for all movement patterns,\nand higher with a smaller cache size, as depicted in Fig. 13(c).\nHowever, when compared with no caching, caching alone could\nimprove the response and latency times of the walkthrough ap-\nplication by quite a few times as shown in Fig. 13(c) and (d).\nPrefetching also leads to improvement in response times. Fi-\nnally, with an increasing cache size, improvement in response\nand latency times is also observed.\n514 IEEE TRANSACTIONS ON MULTIMEDIA, VOL. 5, NO. 4, DECEMBER 2003\nFig. 13. Performance from Experiment 2.\nVI. CONCLUSIONS\nIn this paper, we have described the design and implemen-\ntation of . We have pointed out the technical chal-\nlenges that need to be addressed in order to support on-demand\ntransmission of virtual environments without sacrificing the per-\nformance of distributed virtual walkthrough applications. As an\nalternative to improving the performance, we propose a caching\nmechanism that employs the local storage of a client machine to\nhold remote objects residing at the database server. The caching\nmechanism is further complemented by a prefetching mecha-\nnism to predict objects that may be accessed in the near future.\nThe prediction is based on the semantics of virtual walkthrough\napplication. These caching and prefetching mechanisms attempt\nto make the objects available at the client machines as soon as\nthey become visible to the users. As demonstrated in our ex-\nperiments, these mechanisms significantly reduce both response\ntime and latency time of the system.\nWe are currently extending our studies along several di-\nmensions. We are investigating other means of prefetching\nvirtual objects and comparing their effectiveness with\nscheme. We are studying the effectiveness of prioritizing\nobjects for transmission at record level rather than object level\non visual perception. We are investigating the effect of multiple\nclients on the performance of the caching mechanism. We are\nalso investigating the situation when objects are dynamic, i.e.,\nan object can move within the virtual environment. This further\ncomplicates our caching mechanism as the updated location of\neach dynamic object needs to be reflected in the object model\ncached in each client in a consistent manner.\nACKNOWLEDGMENT\nThe authors would like to thank B. Ng for helping to verify\nsome of the experimental results. We would also like to thank\nthe anonymous reviewers and the associate editor of this paper\nfor their helpful suggestions.\nREFERENCES\n[1] P. Bernstein, V. Hadzilacos, and N. Goodman, Concurrency Control and\nRecovery in Database Systems . Norwell, MA: Addison-Wesley, 1987.\n[2] J. Calvin, A. Dicken, B. Gaines, P. Metzger, D. Miller, and D. Owen,\n\u201cThe SIMNET virtual world architecture,\u201d in Proc. IEEE VRAIS, 1993,\npp. 450\u2013455.\n[3] M. Carey, M. Franklin, M. Livny, and E. Shekita, \u201cData caching trade-\noffs in client-server DBMS architectures,\u201d in Proc. ACM SIGMOD.,\n1991, pp. 357\u2013366.\n[4] C. Carlsson and O. Hagsand, \u201cDIVE\u2014A multi-user virtual reality\nsystem,\u201d in Proc. IEEE VRAIS, 1993, pp. 394\u2013400.\n[5] B. Y. L. Chan, H. V. Leong, A. Si, and K. F. Wong, \u201cMODEC: A multi-\ngranularity mobile object-oriented database caching mechanism, proto-\ntype and performance,\u201d J. Distrib. Parallel Databases, vol. 7, no. 3, pp.\n343\u2013372, July 1999.\n[6] J. Chim, M. Green, R. W. H. Lau, H. V. Leong, and A. Si, \u201cOn caching\nand prefetching of virtual objects in distributed virtual environments,\u201d\nin Proc. ACM Multimedia, Sept. 1998.\n[7] J. Chim, R. W. H. Lau, H. V. Leong, and A. Si, \u201cMulti-resolution cache\nmanagement in digital virtual library,\u201d in Proc. IEEE Advances in Dig-\nital Libraries Conf., Apr. 1998, pp. 66\u201375.\n[8] W. Effelsberg and T. Haerder, \u201cPrinciples of database buffer manage-\nment,\u201d ACM Trans. Database Syst., pp. 560\u2013595, Dec. 1984.\n[9] J. Falby, M. Zyda, D. Pratt, and R. Mackey, \u201cNPSNET: Hierarchical data\nstructures for real-time three-dimensional visual simulation,\u201d Comput.\nGraph., vol. 17, no. 1, pp. 65\u201369, 1993.\n[10] M. Franklin, M. Carey, and M. Livny, \u201cGlobal memory management in\nclient-server DBMS architectures,\u201d in Proc. VLDB, 1992, pp. 596\u2013609.\n[11] C. Greenhalgh and S. Benford, \u201cMASSIVE: A distributed virtual reality\nsystem incorporating spatial trading,\u201d in Proc. Int. Conf. Distributed\nComputing Systems, 1995, pp. 27\u201334.\n[12] H. Hoppe, \u201cProgressive meshes,\u201d in Proc. ACM SIGGRAPH \u201996, Aug.\n1996, pp. 99\u2013108.\n[13] V. Icsler, R. W. H. Lau, and M. Green, \u201cReal-time multi-resolution mod-\neling for complex virtual environments,\u201d in Proc. ACM VRST, July 1996,\npp. 11\u201320.\n[14] A. Kraiss and G. Weikum, \u201cIntegrated document caching and\nprefetching in storage hierarchies based on Markov-chain predictions,\u201d\nJ. Very Large Database Syst., vol. 7, no. 3, pp. 141\u2013162, Aug. 1998.\n[15] R. W. H. Lau, M. Green, D. To, and J. Wong, \u201cReal-time continuous\nmulti-resolution method for models of arbitrary topology,\u201d Presence:\nTeleop. Virtual Environ., pp. 22\u201335, Feb. 1998.\nCHIM et al.: : WEB-BASED DISTRIBUTED VIRTUAL WALKTHROUGH ENVIRONMENT 515\n[16] R. W. H. Lau, D. To, and M. Green, \u201cAn adaptive multi-resolution mod-\neling technique based on viewing and animation parameters,\u201d in Proc.\nIEEE VRAIS, 1997, pp. 20\u201327.\n[17] M. Macedonia, M. Zyda, D. Pratt, P. Brutzman, and P. Barham, \u201cEx-\nploiting reality with multicast groups: A network architecture for large-\nscale virtual environments,\u201d in Proc. IEEE VRAIS, Mar. 1995, pp. 2\u201310.\n[18] B. Mannoni, \u201cA virtual museum,\u201d Commun. ACM, vol. 40, no. 9, pp.\n61\u201362, 1997.\n[19] T. Ohshima, H. Yamamoto, and H. Tamura, \u201cGaze-directed adaptive ren-\ndering for interacting with virtual space,\u201d in Proc. IEEE VRAIS, July\n1996, pp. 103\u2013110.\n[20] I. Pandzic, T. Capin, E. Lee, N. Thalmann, and D. Thalmann, \u201cA flex-\nible architecture for virtual humans in networked collaborative virtual\nenvironments,\u201d in Proc. Eurographics \u201997, 1997, pp. 177\u2013188.\n[21] D. Schmalstieg and M. Gervautz, \u201cDemand-driven geometry transmis-\nsion for distributed virtual environments,\u201d in Proc. Eurographics \u201996,\n1996, pp. 421\u2013432.\n[22] A. Si and H. V. Leong, \u201cAdaptive caching and refreshing in mobile\ndatabases,\u201d Personal Technol., vol. 1, no. 3, pp. 156\u2013170, Sept. 1997.\n[23] A. Silberschatz, H. Korth, and S. Sudarshan, Database System Con-\ncepts. New York: McGraw-Hill, 1996.\n[24] G. Singh, L. Serra, W. Png, and H. Ng, \u201cBricknet: A software toolkit for\nnetwork-based virtual worlds,\u201d Presence: Teleop. Virtual Environ., vol.\n3, no. 1, pp. 19\u201334, 1994.\n[25] S. Singhal and M. Zyda, Networked Virtual Environments: Design and\nImplementation . Norwell, MA: Addison-Wesley, 1999.\n[26] B. Watson, N. Walker, and L. Hodges, \u201cEffectiveness of spatial level of\ndetail degradation in the periphery of head-mounted displays,\u201d in Proc.\nACM CHI\u201996, April 1996, pp. 227\u2013228.\n[27] W. M. R. Wong and R. R. Muntz, \u201cProviding guaranteed quality of ser-\nvice for interactive visualization applications,\u201d in Proc. ACM SIGMET-\nRICS, June 2000.\nJimmy Chim received both the undergraduate and\nM.Phil. degrees from the Hong Kong Polytechnic\nUniversity.\nHe is currently with the School of Visual Arts in\nNew York, pursuing the M.S. degree in visual arts and\ncomputer animation. He has conducted research on\nthe area of multimedia systems, both in performance\nstudy and system implementation, publishing several\npapers in major conferences.\nRynson W. H. Lau (M\u201988) received a (top) first class\nhonors degree in computer systems engineering in\n1988 from the University of Kent, Canterbury, U.K.,\nand the Ph.D. degree in computer graphics in 1992\nfrom the University of Cambridge, U.K.\nHe is currently an Associate Professor at the City\nUniversity of Hong Kong. Prior to joining the uni-\nversity in 1998, he taught at the Hong Kong Poly-\ntechnic University. From 1992 to 1993, he worked at\nthe University of York, U.K., on a defense project on\nimage processing. His research interests are in com-\nputer graphics, virtual reality and multimedia systems.\nDr. Lau is a member of the IEEE Computer Society and the ACM.\nHong Va Leong received the Ph.D. degree from the\nUniversity of California, Santa Barbara.\nHe is currently an Associate Professor at the Hong\nKong Polytechnic University. He has served on the\nprogram committees and organization committees\nfor many international conferences. He is also a\nreviewer for a number of international journals,\nincluding several IEEE Transactions. His research\ninterests are in distributed systems, distributed\ndatabases, mobile computing, internet computing,\nand digital libraries.\nDr. Leong is a member of the ACM and the IEEE Computer Society.\nAntonio Si (M\u201995) received the Ph.D. degree from\nthe University of Southern California, Los Angeles.\nHe is currently with Oracle Corporation, Red-\nwood Shores, CA. Before joining Oracle, he was an\nAssistant Professor at the Hong Kong Polytechnic\nUniversity and a Software Engineer at Sun Mi-\ncrosystems, Inc. in the United States. He has served\non the program committees for several international\nconferences and as external reviewers for a number\nof international conferences and journals. His\nresearch interests are in mobile computing, internet\ncomputing, and digital libraries.\nDr. Si is a member of the ACM and IEEE Computer Society.\n"}