{"doi":"10.1016\/S0164-1212(02)00018-3","coreId":"57199","oai":"oai:eprints.lincoln.ac.uk:42","identifiers":["oai:eprints.lincoln.ac.uk:42","10.1016\/S0164-1212(02)00018-3"],"title":"Diagnosis of the significance of inconsistencies in software designs: a framework and its experimental evaluation","authors":["Spanoudakis, George","Kim, Hyoseob"],"enrichments":{"references":[{"id":18432414,"title":"A Metrics Suite for Object Oriented Design,","authors":[],"date":"1994","doi":"10.1109\/32.295895","raw":"Chidamber,  S.,  Kemerer,  C.,  1994.  A  Metrics  Suite  for  Object  Oriented  Design,  IEEE  Transactions on  Software  Engineering,  20(6),  476-493.","cites":null},{"id":18432433,"title":"A Software Complexity Model of Object-Oriented Systems, Decision Support Systems:","authors":[],"date":"1995","doi":"10.1016\/0167-9236(93)e0045-f","raw":"Tegarden,  P.,  Sheetz,  S.,  Monarchi,  D.,  1995.  A  Software  Complexity  Model  of  Object-Oriented Systems,  Decision  Support  Systems:  The  International  Journal,  13,  241-262.","cites":null},{"id":18432429,"title":"Basic Objects in Natural Categories,","authors":[],"date":"1976","doi":"10.1037\/e666602011-017","raw":"Rosch,  E.  et  al.,  1976.  Basic  Objects  in  Natural  Categories,  Academic  Press.","cites":null},{"id":18432420,"title":"Consistency Checking of SCR-Style Requirements Specifications,","authors":[],"date":"1995","doi":"10.1109\/isre.1995.512546","raw":"Heitmeyer,  C.,  Labaw,  B.,  Kiskis,  D.,  1995.  Consistency  Checking  of  SCR-Style  Requirements Specifications,  Proceedings    of  the  2nd  Int.  Symposium  on  Requirements  Engineering,  IEEE CS  Press,  56-63.","cites":null},{"id":18432419,"title":"Design Patterns: Elements of Reusable Object-Oriented Software,","authors":[],"date":"1995","doi":"10.1145\/226239.226255","raw":"Gamma  E.,  et  al.,  1995.  Design  Patterns:  Elements  of  Reusable  Object-Oriented  Software, Addison  Wesley.","cites":null},{"id":18432416,"title":"Inconsistency Handling In Multi-Perspective Specifications,","authors":[],"date":"1994","doi":"10.1007\/3-540-57209-0_7","raw":"Finkelstein,  A.,  Gabbay,  D.,  Hunter,  A.,  Kramer,  J.,  and  Nuseibeh,  B.,  1994.  Inconsistency Handling  In  Multi-Perspective  Specifications,  IEEE  Transactions  on  Software  Engineering, 20(8),  569-578.","cites":null},{"id":18432426,"title":"Leveraging Inconsistency in Software Development,","authors":[],"date":"2000","doi":"10.1109\/2.839317","raw":"Nuseibeh,  B.,  Easterbrook,  S.,  Russo,  A.,  2000.  Leveraging  Inconsistency  in  Software Development,  IEEE  Computer,  33(4),  24-29.","cites":null},{"id":18432430,"title":"Living with Inconsistency in Large Systems,","authors":[],"date":"1988","doi":"10.1007\/978-3-642-93336-3_9","raw":"Schwanke,  W.,  Kaiser,  E.,  1988.  Living  with  Inconsistency  in  Large  Systems,  Proceedings  of  the Int.  Workshop  on  Software  Version  and  Configuration  Control,  98-118 Shafer,  G.,  1975  A  Mathematical  Theory  of  Evidence,  Princeton  University  Press.","cites":null},{"id":18432425,"title":"Managing Conflicts in Goal-Driven Requirements Engineering,","authors":[],"date":"1998","doi":"10.1109\/32.730542","raw":"Lamsweerde,  A.,  Darimont,  A.,  Letier,  E.,  1998.  Managing  Conflicts  in  Goal-Driven Requirements  Engineering,  IEEE  Transactions  on  Software  Engineering,  Special  Issue  on Inconsistency  Management,  November  1998 Lorenz,  M.,  1993.  Object-Oriented  Software  Development:  A  Practical  Guide,  Prentice  Hall.","cites":null},{"id":18432421,"title":"Managing Inconsistent Specifications: Reasoning, Analysis and Action,","authors":[],"date":"1998","doi":"10.1145\/292182.292187","raw":"Hunter,  A.,  Nuseibeh,  B.,  1998.  Managing  Inconsistent  Specifications:  Reasoning,  Analysis  and Action,  ACM  Transactions  in  Software  Engineering  and  Methodology,  7(4),  pp.  335-367 Jacobson  I.,  et  al.,  1995.  Object-Oriented  Software  Engineering:  A  Use  Case  Driven  Approach, Addison-Wesley.","cites":null},{"id":18432417,"title":"Managing Interference,","authors":[],"date":"1996","doi":"10.1145\/243327.243646","raw":"Finkelstein,  A.,  Spanoudakis,  G..,  Till  D.,  1996.  Managing  Interference,  Joint  Proceedings  of  the Sigsoft  \u201896  Workshops  \u2013  Viewpoints  \u201896,  ACM  Press,  172-174.","cites":null},{"id":18432415,"title":"Managing Standards Compliance.","authors":[],"date":"1999","doi":"10.1109\/32.824413","raw":"Emmerich,  W.,  et  al.,  1999.  Managing  Standards  Compliance.  IEEE  Transactions  on  Software Engineering  25(6),  pp.  836-851.","cites":null},{"id":18432427,"title":"OMG Unified Modelling Language Specification,","authors":[],"date":"1999","doi":"10.3403\/30193744","raw":"OMG,  1999.  OMG  Unified  Modelling  Language  Specification,  V.  1.3a.  Available33 from:ftp:\/\/ftp.omg.org\/pub\/docs\/ad\/99-06-08.pdf.","cites":null},{"id":18432428,"title":"Rational Rose '98: Extensibility Reference Manual. See also: http:\/\/www.rational.com\/products\/rose\/index.jtmpl","authors":[],"date":"1998","doi":null,"raw":"Rational,  1998.  Rational  Rose  '98:  Extensibility  Reference  Manual.  See  also: http:\/\/www.rational.com\/products\/rose\/index.jtmpl Robinson,  W.,  Fickas,  S.,  1994.  Supporting  Multiple  Perspective  Requirements  Engineering, Proceedings  of  the  1st  Int.  Conference  on  Requirements  Engineering,  IEEE  CS  Press,  206-215 Robinson,  W.,  Pawlowski,  S.,  1999.  &quot;Managing  Requirements  Inconsistency  with  Development Goal  Monitors&quot;,  IEEE  Transactions  on  Software  Engineering  25(6).","cites":null},{"id":18432431,"title":"Reconciliation of Object Interaction Models,","authors":[],"date":"2001","doi":"10.1007\/978-1-4471-0719-4_7","raw":"Spanoudakis,  G..,  Kim  H.,  2001.  Reconciliation  of  Object  Interaction  Models,  Proceedings  of  the th  International  Conference  on  Object  Oriented  Information  Systems  (OOIS  '01),  Calgary Canada,  (to  appear).","cites":null},{"id":18432422,"title":"Requirements Engineering with Viewpoints&quot;.","authors":[],"date":"1996","doi":"10.1049\/sej.1996.0002","raw":"Kotonya,  G.,  Sommerville  I.,  1996.  &quot;Requirements  Engineering  with  Viewpoints&quot;.  Software Engineering  Journal,  vol.  11,  n.  1,  January,  5-18.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2002-10","abstract":"This paper presents: (a) a framework for assessing the significance of inconsistencies which arise in object-oriented design models that describe software systems from multiple perspectives, and (b) the findings of a series of experiments conducted to evaluate it. The framework allows the definition of significance criteria and measures the significance of inconsistencies as beliefs for the satisfiability of these criteria. The experiments conducted to evaluate it indicate that criteria definable in the framework have the power to create elaborate rankings of inconsistencies in models","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/57199.pdf","fullTextIdentifier":"http:\/\/eprints.lincoln.ac.uk\/42\/1\/jss02.pdf","pdfHashValue":"342a4edc9c3d4c7ff217c12177f35e4f18efcf1f","publisher":"Elsevier","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lincoln.ac.uk:42<\/identifier><datestamp>\n      2013-03-13T08:21:46Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D6A6163735F47:6A6163735F47363130<\/setSpec><setSpec>\n      7375626A656374733D6A6163735F47:6A6163735F47343030<\/setSpec><setSpec>\n      7375626A656374733D6A6163735F47:6A6163735F47363232<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/eprints.lincoln.ac.uk\/42\/<\/dc:relation><dc:title>\n        Diagnosis of the significance of inconsistencies in software designs: a framework and its experimental evaluation<\/dc:title><dc:creator>\n        Spanoudakis, George<\/dc:creator><dc:creator>\n        Kim, Hyoseob<\/dc:creator><dc:subject>\n        G610 Software Design<\/dc:subject><dc:subject>\n        G400 Computer Science<\/dc:subject><dc:subject>\n        G622 Object Oriented Programming<\/dc:subject><dc:description>\n        This paper presents: (a) a framework for assessing the significance of inconsistencies which arise in object-oriented design models that describe software systems from multiple perspectives, and (b) the findings of a series of experiments conducted to evaluate it. The framework allows the definition of significance criteria and measures the significance of inconsistencies as beliefs for the satisfiability of these criteria. The experiments conducted to evaluate it indicate that criteria definable in the framework have the power to create elaborate rankings of inconsistencies in models.<\/dc:description><dc:publisher>\n        Elsevier<\/dc:publisher><dc:date>\n        2002-10<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/eprints.lincoln.ac.uk\/42\/1\/jss02.pdf<\/dc:identifier><dc:identifier>\n          Spanoudakis, George and Kim, Hyoseob  (2002) Diagnosis of the significance of inconsistencies in software designs: a framework and its experimental evaluation.  Journal of systems and software, 64  (1).   pp. 3-22.  ISSN 0164-1212  <\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1016\/S0164-1212(02)00018-3<\/dc:relation><dc:relation>\n        10.1016\/S0164-1212(02)00018-3<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/eprints.lincoln.ac.uk\/42\/","http:\/\/dx.doi.org\/10.1016\/S0164-1212(02)00018-3","10.1016\/S0164-1212(02)00018-3"],"year":2002,"topics":["G610 Software Design","G400 Computer Science","G622 Object Oriented Programming"],"subject":["Article","PeerReviewed"],"fullText":"1Diagnosis of the Significance of Inconsistencies in\nObject-Oriented Designs: A Framework and Its Experimental\nEvaluation\n(Draft)\nGeorge Spanoudakis, Hyoseob Kim\nDepartment of Computing, City University\nNorthampton Square, London, EC1V 0HB\nE-mail: (gespan|hkim)@soi.city.ac.uk\nABSTRACT:  This paper presents: (a) a framework for assessing the significance of\ninconsistencies which arise in object-oriented design models that describe software systems from\nmultiple perspectives, and (b) the findings of a series of experiments conducted to evaluate it. The\nframework allows the definition of significance criteria and measures the significance of\ninconsistencies as beliefs for the satisfiability of these criteria. The experiments conducted to\nevaluate it indicate that criteria definable in the framework have the power to create elaborate\nrankings of inconsistencies in models.\nKEYWORDS: diagnosis of inconsistencies, UML, OCL, Dempster-Shafer beliefs\n1. Introduction\nThe need to describe complex software systems from different design perspectives, such as\nthose of the static structure and the interactions of the components of a system, may result in the\nconstruction of many partial system design models (or simply \"models\" henceforth). These models\nmay be constructed independently by different designers, may advocate specific modelling angles\nand may reflect disparate perceptions of these designers. As a result, they may be inconsistent with\neach other.\nInconsistencies occur when partial models refer to common aspects of the system under\ndevelopment and make assertions which violate consistency rules applicable to these aspects\n(Hunter and Nuseibeh, 1998; Spanoudakis and Finkelstein, 1996; Spanoudakis and Zisman 2001).\n2As an example consider an object-oriented design model that consists of an object interaction\ndiagram and a class diagram. Assume also a consistency rule requiring that for any message\nreceived by an object in the interaction diagram, an operation with the same signature as the\nmessage must have been defined for one of the classes of the object in the class diagram.  In this\nmodel an inconsistency would arise if there was a message with no counterpart operation, thus\nviolating the above consistency rule.\nInconsistencies are inevitable in software development (Schwanke and Kaiser, 1998). And,\nalthough they will have to be settled eventually, they may need to be tolerated temporarily to give\ndesigners a chance to work independently developing their own parts of a model without the need\nfor continual reconciliation (Hunter and Nuseibeh, 1998; Spanoudakis and Finkelstein, 1996). In\nsettings providing freedom for groupwork, it is important to be able to diagnose  the significance\nof an inconsistency in order to decide when and with what degree of priority it has to be settled. In\none of the experiments reported in Section 5.1, we detected 90 violations of the consistency rule\nmentioned above. In such cases having a mechanism to assess the significance of inconsistencies\nand order them by this significance would be undoubtedly useful.\nIn this paper, we describe a framework that we have developed to support the assessment of\nthe significance of inconsistencies in object-oriented software design model expressed in UML\n(OMG, 1999) and present the main findings of a set of experiments that we conducted to evaluate\nit. A description of the framework at an earlier stage of its development is given in (Spanoudakis\nand Kasis, 2000).\nThe main premise of the framework is that the significance of an inconsistency depends on\nthe significance of the model elements that give rise to it for the model. The framework defines a\nset of characteristics which indicate the significance of the main kinds of elements in UML\nmodels. The assessment of whether or not an element has a particular characteristic in a model is\napproximate; the framework incorporates belief functions measuring the extent to which it may be\nbelieved from its modelling that an element has the characteristic. The need for approximate\nreasoning arises because it cannot be guaranteed that the model provides a consistent, complete\nand accurate description of the system it describes at the different stages of its evolution. In\naddition, it cannot be guaranteed that the element will retain the characteristic in the next version\nof the model.\n3The framework presented in this paper has been developed as part of a semi-automated\nmethod that we have developed to assist software developers in managing inconsistencies in\nobject-oriented software design models, called \"reconciliation\". Reconciliation supports the entire\nrange of the activities of what has been termed in the literature as \"inconsistency management\",\nincluding the detection of overlaps and inconsistencies in software models, the diagnosis of the\nsignificance of inconsistencies, and the handling of detected inconsistencies (Finkelstein et al.,\n1996; Spanoudakis and Zisman, 2001). A full description of this method is however beyond the\nscope of this paper and can be found in (Spanoudakis and Finkelstein, 1997; Spanoudakis and\nKim, 2001).\nThe rest of this paper is structured as follows. In Section 2, we introduce the characteristics\nwhich indicate the significance of model elements and the belief functions associated with them.\nIn Section 3, we establish a scheme for expressing consistency rules and significance criteria\nwhich determine the characteristics that the elements which violate these rules must have for the\nviolations to be significant. In Section 4, we give an example of how to use these criteria to\nevaluate the significance of inconsistencies and rank them. In Section 5, we present the results of\nan experimental evaluation of the framework. In Section 6, we overview related work in Section 7\nwe summarize the framework and present directions for further work on it. The paper has also an\nappendix which overviews the statistics used in the rank correlations discussed in Section 5.2.\n2. Characteristics of significant model elements\nThe UML models assumed by our framework can be composed of any number of class and\nsequence diagrams. Class diagrams specify the static structure of, and the relationships between\nthe classes of a system. Classes can have attributes, operations, and be related by associations and\ngeneralisation (Is-a) relations. Sequence diagrams specify interactions between the instances of\nthese classes (the terms \"sequence diagram\" and \"interaction\" are used synonymously in the rest of\nthe paper). An interaction consists of a set of messages exchanged between objects to deliver part\nof the functionality of a system. A complete description of the semantics of these kinds of UML\nmodel elements is beyond the scope of this paper and may be found in (OMG, 1999).\nIn our framework, the significance of the above kinds of UML model elements is indicated by\nsix characteristics: the genericity  and coordination capacity of classes, the  functional essentiality\n4of attributes and association ends, the charactericity  of operations, and the functional dominance\nand coordinating capacity  of messages. These characteristics are described below.\n2.1 Class genericity\nIn software models, classes with numerous subclasses normally specify interfaces (i.e. sets of\noperation signatures) for groups of services which are provided by their subclasses and the internal\nstate of the instances of these subclasses which is required to realise the services. In effect, such\ngeneric classes provide a basis for specifying clients capable of using the services without\nknowing the exact class which provides them. An inconsistency involving the specification of a\ngeneric class is significant since it may affect both its subclasses and the clients that use its\nservices.\nFigure 1.   UML class diagram for a library system\nThe belief to the genericity of a class in our framework is measured as the likelihood of an\narbitrary class in a model being a subclass of it:\nDefinition 1:  The belief to the genericity of a class c\n\nin a model M (denoted by the predicate gen-\nc(c)) is defined as:\nSearchByAuthor\nexecute()\nSearchByTitle\nexecute(argname) : return\nDeleteItemCommand\nexecute()\nInsertItemCommand\nexecute()\nKeyword\n(from  ApplicationClasses)SearchCommand\nexecute()\n+key\nDatabaseCommand\nexecute()\nStatement\n(from ApplicationClasses)\nDBHandler\n(from ApplicationClasses)+imp\nSearchByKeyword\nexecute()\nSForm\n(from ApplicationClasses)\n+sform\nTextField\n(from ApplicationClasses)\nImplementor\n(from  ApplicationClasses)\nCommand\nexecute()\ngetImp() :  Implementor1..1\n-imp\nSMenu\n(from  ApplicationClasses)\n5m1(gen-c(c)) = |c.Sub*| \/ | AllClasses(M) \u2212  {c}|1\nm1(\u00acgen-c(c)) = 1 \u2212  m1(gen-c(c))\nwhere\n\u2022  AllClasses(M) is the set of all the classes in model M\n\u2022  c.Sub* is transitive closure of the subclasses of c\nFigure 1 shows a generalisation hierarchy of command classes for a library system (see\nSection 2.2 below) which has been modeled following the command pattern in (Gamma et al.,\n1995).  The degrees of belief in the genericity of the command classes Command,\nSearchCommand, and SearchByKeyoword  in this hierarchy generated by m1 (assuming that the\nclasses in Figure 1 are the only classes of the model involved) are: m1(gen-c(Command)) = 0.5,\nm1(gen-c(SearchCommand)) = 0.21, m1(gen-c(SearchByKeyword)) = 0\n2.2 Coordination capacity of classes\nSome classes in the design of a system may have a coordination capacity, that is they may\nexist to coordinate interactions between other classes. Coordinating classes are very important in a\ndesign since they encapsulate protocols of interactions between the classes they coordinate and,\nthus, they appear in numerous design patterns (e.g. mediator, observer, facade  (Gamma et al.,\n1995)). An inconsistency involving a coordinating class is important since it is likely to affect all\nthe classes and the interactions which are coordinated by this class.\nA common characteristic of coordinating classes across all the different coordination patterns\nthat they may realise is that they send messages to or receive messages from all the classes that\nthey coordinate. Drawing upon this observation, we measure the belief to the coordination\ncapacity of a class c  in a set of interactions S  as the likelihood that an arbitrary class in S  will be\ncommunicating with c:\nDefinition 2:  The belief to the coordination capacity of a class c\n\nin a subset S  of the interactions of\na model (denoted by the predicate coord-c(c,S)) is defined as:\nm2(coord-c(c,S)) = |Com(c,S)|\/|Classes(S)\u2212{c}|\nm2(\u00accoord-c(c,S)) =  1 \u2212  m2(coord-c(c, S))\nwhere\n                                                     \n1 The expression |S| denotes the cardinality of the set S.\n6\u2022  Com(c,S) is the set of the classes whose instances send messages to or receive messages from\nthe instances of c\n\nin the interactions of the set S  excluding c\n\u2022  Classes(S) is the set of the classes which appear as receivers or senders of messages in the\ninteractions of S.\nAs an example of using m2 to measure the coordinating capacity of classes consider the\nsequence diagrams of Figures 2 and 3.\nThe sequence diagram of Figure 2 shows an interaction between the classes of the library\nsystem whose static class structure was specified in Figure 1. This interaction takes place to allow\nthe user to select one of the search options available from the system. More specifically, the\nsystem offers the options of searching by keywords in the title, author or the keywords associated\nwith library items. A search menu (SMenu) is used to activate the various search options offered\nby the system. These options are modeled (and operationalised) by the command classes\nSearchByKeyword, SearchByAuthor, and SearchByTitle  (in the sense of command classes in\n(Gamma et al., 1995)).\nFigure 2. I1 - Interaction for selecting a search option\nThe sequence diagram of Figure 3 shows the interaction that takes place when the system is\nused to search for library items by keywords. As shown in the diagram, when the command class\nSearchByKeyword. is activated to execute the operation execute(), it displays a search form (see\nmessage setVisible(True)), set itself as a listener of events related to a text field of this form (see\nmessage addActionListener(sbk)), gets the contents of the text field (see message getText()) when\nit is notified that the user has typed something in it (see message actionPerformed(event)),\n :  User  :  SMenu  :  SearchByKeyword  :  SearchByTitle  :  SearchByAuthor\n2: execute( )\n1: selects_search_option [ search_option = searchByKeyword ]\n3: execute( )\n[ search_option = searchByTitle ]\n4: execute( )\n[ search_option = searchByAuthor ]\n7constructs a string representing an SQL query (see message formQuery()), and invokes an\noperation in the class DBHandler (i.e., a database driver) to execute this query (see message\nexecuteQuery(String,OCol)).\nFigure 3. I2 - Interaction for searching by keywords\nAccording to Definition 2, the beliefs in the coordination capacity of the classes\nSearchByKeyword, DBHandler, SMenu  in the diagram I2 are:\n(i)  m2(coord-c(SearchByKeyword,{I2})) = 0.8\nsince Com(SearchByKeyword,{I2}) = {SMenu, SForm, TextField, DBHandler} and\nClasses({I2}) = {SMenu, SearchByKeyword, SForm, TextField, DBHandler,\nStatement}\n(ii)  m2(coord-c(DBHandler,{I2})) = 0.4\nsince Com(DBHandler,{I2}) = {Statement, SearchByKeyword}) and Classes({I2}) is as in (i)\nabove\n(iii)  m2(coord-c(SMenu,{I2})) = 0.2\nsince Com(SMenu,{I2}) = {SearchByKeyword} and Classes({I2}) is as in (i) above\nThese beliefs reflect the strong coordination capacity of SearchByKeyword  in the entire\ninteraction, the moderate coordination capacity of DBHandler for only a part of the interaction and\nthe almost negligible coordination capacity of SMenu.\n : SMenu  : SForm  : DBHandler  : Statement\n : User  :  TextFieldsbk :  SearchByKeyword\n1: execute( )\n2: setVisible(True)\n6: getKeywords() 7: getText()\n8: formQuery()\n9: executeQuery(String,OCol)\n10: executeQuery()\n11: toObjCol(result)\n3: addActionListener(sbk)\n5: actionPerformed(event)\n4: types_keywords\n8Note however that, the above beliefs change if both diagram I1 and diagram I2 are taken into\naccount. In this case, we have:\n(i)  m2(coord-c(SearchByKeyword, {I1,I2})) = 0.571\nsince Com(SearchByKeyword,{I1,I2}) = {SMenu, SForm, TextField, DBHandler}) and\nClasses({I1,I2}) = {SMenu, SearchByKeyword, SearchByTitle, SearchByAuthor, SForm,\nTextField, DBHandler, Statement}\n(ii)  m2(coord-c(SMenu, {I1,I2})) = 0.428\nsince Com(SMenu,{I1,I2}) = {  SearchByKeyword, SearchByAuthor, SearchByTitle})\nand Classes({I1,I2}) is as in (i) above\n(iii)  m2(coord-c(DBHandler, {I1,I2})) = 0.285\nsince Com(DBHandler, {I1,I2}) = {Statement, SearchByKeyword} and Classes({I1,I2}) is as\nin (i) above\nThe new beliefs are affected by the high coordination capacity of the class SMenu  in I1, the\nlow coordination capacity of the class SearchByKeyword  in I1 and the lack of any coordination\ncapacity of the class DBHandler in I1.\n2.3 Functional essentiality of attributes and association ends\nAttributes and association ends may provide the only channels for sending messages between\nthe instances of the classes connected to them. Consider, for instance, an interaction where an\ninstance of a class ci sends a message to an instance of another class cj. Unless ci has an attribute\nor an association end whose type is the class cj (and therefore its instances have a means of\nholding references to the instance of cj) or the message has an argument of type cj, the instance of\nci will not be able to identify and send the message to the instance of cj.\nNote also that in cases where ci has more than one attributes or navigable association ends of\ntype cj it is impossible to identify from the model which of these attributes or association ends is\nused by the sender of the message2. Nevertheless, it is plausible to assume that the more the\nmessages sent by the instances of ci (or its subclasses) to instances of the type of an attribute or\nassociation end a  and the fewer the other attributes or association ends of ci having the same type\nas a, the higher the chance that at least one of these messages is dispatched through a  and thus the\n9higher the functional essentiality of a  for the class ci.  Drawing upon this observation, we define\nthe belief to the functional essentiality of attributes and association end as follows:\nDefinition 3: The belief to the functional essentiality of an attribute or association end a  for a\nclass c  in a model M (denoted by the predicate fessen-a(a,c)) is defined as:\nm3(fessen-a(a,c)) =\n1 \u2212  (1\u22121\/(|Rel(a,c)| +1))|Mes(a, c, M)|\nm3(\u00acfessen-a(a,c)) =  1  \u2212   m3(fessen-a(a,c))\nwhere\n\u2022  Mes(a,c,M) is the set of those messages sent by the instances of c  (or its subclasses) to instances\nof the type of the attribute or the association end a  which do not have an argument of the same\ntype as a\n\u2022  Rel(a,c) is the set of the attributes and navigable association ends defined in or inherited by the\nclass c  that have the same type as a\nm3 measures the likelihood of the instances of c  sending messages to objects that constitute\nthe value of the attribute or association end a. In Definition 3, the cardinality of Rel(a,c) is\nincreased by one to account for the possibility of sending the message to an instance of c  that is\ncreated within the method that implements the operation invoked by the message. This is\nnecessary since this creation might not be evident from the interaction itself.\nAccording to Definition 3, the beliefs to the functional essentiality of the association end\nsform and the attribute key for the class SearchByKeyword  in Figure 1 \u2212  given the sequence\ndiagram of Figure 2 \u2212  are 0.75 and 0, respectively. These beliefs reflect the fact that sform  is likely\nto be the association end used to identify the receivers of at least one of the messages in the\ndiagram sent to instances of SearchByKeyword. Unlike it, the attribute key does not appear to have\nany functional role for SForm  since no messages are sent to instances of its type (that is the class\nKeyword).\nAn inconsistency involving a functionally essential attribute or association end is significant\nbecause it may affect the ability of the objects to request the execution of operations.\n                                                                                                                                                    \n2\n The graphical syntax of UML for sequence diagrams does not allow the specification of the\nexact attribute or association end whose value is used as the receiver of a message in an\ninteraction.\n10\n2.4 Operation charactericity\nAn operation overridden by most of the classes in its scope, that is the set of the classes which\nintroduce or inherit it in a model, is significant for the design of a system because it constitutes a\nbasic kind of behaviour which must be provided by objects of different types (even if realised in\ndifferent ways by these objects). We refer to this characteristic of operations as \"operation\ncharactericity\" and define the belief to it as follows:\nDefinition 4:  The belief to the charactericity of an operation o  in a model M (denoted by the\npredicate char-o(o)) is defined as\nm4(char-o(o)) =\n\u03a0c \u03b5  Oclasses(o) |Ov(o,c)\u222a{c}| \/ | c.Sub*\u222a{c}|\nm4(\u00acchar-o(o)) = 1 \u2212  m4(char-o(o))\nwhere\n\u2022  Oclasses(o) is the set of the most general superclasses of the class of o which define an\noperation with the same signature as o\n\u2022  Ov(o,c) is the set of the subclasses of c  which override o\nm4 measures the likelihood of an arbitrary class in each of the possible scopes of an operation\noverriding it.\nAccording to Definition 4, the beliefs to the charactericity of the operations execute() and\ngetImp() in the class diagram of Figure 1 are 0.875 and 0.125, respectively. The former belief\nmeasure reflects the fact that execute() is an operation that has to be defined in every command\nclass (since it is used to trigger the execution of these commands (Gamma et al., 1994)) but\nimplemented differently by each of these command classes. Unlike it, the operation getImp(),\nwhich returns the object that implements a command, has a single implementation in the abstract\ncommand class Command. The fact that getImp() is not overridden by any of the different\ncommand classes in the Is-a hierarchy of Figure 1 indicates the relatively insignificant functional\nrole of it for these classes.\n11\n2.5 Coordination capacity of messages\nMessages in interactions are exchanged between objects to invoke operations in these objects.\nThese operations may: (a) provide part of the internal functionality of the object, or (b) coordinate\nthe interaction of a group of other objects by invoking other operations in them, combining the\ndata that the latter operations may generate, and eventually notifying the combined outcome of the\ninteraction to the object that invoked them.\nThe operations of the latter kind (and therefore the messages invoking them) are more critical\nfor the design of the system than those of the former kind. This is because they realise the\nprotocols of the required coordination between objects. Note, however, that in a UML design\nmodel, the only evidence about the operations invoked when a specific operation is executed\ncomes from the messages dispatched by the message that invokes the operation. Also, depending\non the elaboration stage of a model, the messages which appear in sequence diagrams may not\nhave counterpart operations defined for the classes of their receivers (or their superclasses) in the\nclass diagrams. To cope with these phenomena, we have defined the coordination capacity as a\ncharacteristic of messages:\nDefinition 5:  The belief to the coordination capacity of a message m  in a subset S  of the\ninteractions of a model M (denoted by the predicate coord-m(m,S)) is defined as:\nm5(coord-m(m,S)) = |Dsig(m,S)|\/ |Asig(m,S)| if Asig(m,S) \u2260  \u2205\nm5(coord-m(m, S)) = 0 if Asig(m,S) = \u2205\nm5(\u00accoord-m(m,S)) = 1 \u2212  m5(coord-m(m,S))\nwhere\n\u2022  Dsig(m,S) is the set of the signatures of the messages directly dispatched by m  in the\ninteractions of S\n\u2022  Asig(m,S) is the set of the signatures of the messages which are directly or indirectly dispatched\nby m  in the interactions of S\nm5 measures the likelihood of an arbitrary message x in the transitive closure of the messages\ndispatched by a message m  being directly (as opposed to indirectly) dispatched by m.\nAccording to Definition 5, the beliefs to the coordination capacity of the messages execute(),\n12\nactionPerformed(event) and setVisible(True) in the interaction of Figure 3 are:\n\u2212  m5(coord-m(execute(),{I2})) = 1\nsince\nAsig(execute(),{I2}) = {setVisible(True), addActionListener(sbk)} and\nDsig(execute(),{I2}) = {setVisible(True), addActionListener(sbk)}\n\u2212  m5(coord-m(actionPerformed(event),{I2})) = 0.5\nsince\nAsig(actionPerformed(event),{I2}) = {getKeywords(), getText(), formQuery(),\nexecuteQuery(String,OCol), executeQuery(),\ntoObjCol(result)} and\nDsig(actionPerformed(event),{I2}) = {getKeywords(),formQuery(),\nexecuteQuery(String,OCol)}\n\u2212  m5(coord-m(setVisible(True),{I2})) = 0\nsince\nAsig(setVisible(True),{I2}) = {} and\nDsig(setVisible(True), {I2}) = {}\nThese beliefs indicate that execute() has a co-ordination capacity in the start of the interaction\nI2 where  it displays the search form and registers the command class SearchByKeyowrd  as a\nlistener to the text field that the user may use to type in the keywords, actionPerformed(event) has\nsome co-ordination capacity in the part of the interaction that executes the search, and\nsetVisible(True) has no coordination capacity.\n2.6 Functional dominance of messages\nWe consider messages that invoke operations triggering a substantial part of the behaviour of\nobjects in an interaction as being functionally dominant in it. In our framework, the basic belief to\nthe functional dominance of a message m  in an interaction is defined as the likelihood of an\narbitrary message in it being dispatched by m  as shown below:\nDefinition 6:  The belief to the functional dominance of a message m  in a set of interactions S of a\nmodel M (denoted by the predicate fdom-m(m,S)) is defined as:\nm6(fdom-m(m,S)) = (|Asig(m,S)|+1)\/|Sg(m,S)|\n13\nm6(\u00acfdom-m(m,S)) = 1 \u2212  m6(fdom-m(m,S))\nwhere\n\u2212  Sg(m,S) is the set of the signatures of the messages in the interactions of set S which are sent\nand received by the classes (not actors) in the interactions of S excluding the signature of m.\nAccording to Definition 6, the beliefs to the functional dominance of the messages execute(),\nactionPerformed(event), and executeQuery(String,OCol) in the sequence diagram I2 are:\n\u2212  m6(fdom-m(execute(),{I2})) = 0.22\nAsig(execute(),{I2}) = {setVisible(True), addActionListener(sbk)} and\nSg(execute(),{I2}) = {setVisible(True), addActionListener(sbk), actionPerformed(event),\ngetKeywords(), getText(), formQuery(),\nexecuteQuery(String,OCol), executeQuery(), toObjCol(result)}\n\u2212  m6(fdom-m(actionPerformed(event),{I2})) = 0.66\nsince\nAsig(actionPerformed(event),{I2}) = {getKeywords(), getText(), formQuery(),\nexecuteQuery(String,OCol), executeQuery(),\ntoObjCol(result)} and\nSg(actionPerformed(event),{I2}) = {execute(), setVisible(True), addActionListener(sbk),\ngetKeywords(), getText(), formQuery(),\nexecuteQuery(String,OCol), executeQuery(),\ntoObjCol(result)}\n\u2212  m6(fdom-m(executeQuery(String,OCol),{I2})) = 0.22\nsince\nAsig(executeQuery(String,OCol),{I2}) = {executeQuery(), toObjCol(result)} and\nSg(executeQuery(String,OCol),{I2}) = {execute(), setVisible(True),\naddActionListener(sbk), actionPerformed(event),\ngetKeywords(), getText(), formQuery(),\nexecuteQuery(), toObjCol(result)}\nThese belief measures reflect the fact that the message actionPerformed(event) triggers a\nsubstantial part of the entire interaction while the other two messages trigger only small parts of it.\n14\n3. Specification of consistency rules and significance criteria\nAs we discussed in Section 1, we define an inconsistency as a violation of a specific\nconsistency rule. To assess the significance of inconsistencies, our framework introduces a scheme\nfor specifying significance criteria and associating them with consistency rules. These criteria\ndefine the characteristics that the elements involved in the violation of a rule should have for the\nviolation to be significant.\nWe express consistency rules using the Object Constraint Language (OCL) which is defined\nas part of (OMG, 1999) and significance criteria using a subset of OCL and the predicates\nintroduced in Section 2, and wrap them in UML objects related as indicated in the extension of the\nUML meta-model that we have made and is shown in Figure 4.\nFigure 4.  Consistency rules and significance criteria\nAs shown in Figure 4, each consistency rule is associated with a specific UML model\nelement, called the \"context\" of the rule. Consequently, the OCL expression that specifies the rule\ncan make references to all the named structural and behavioural features of its context as well as to\nthe associations and generalisations which may relate it to other model elements. The classes of a\nUML model along with built-in OCL types which represent primitive data types and collections of\nvalues\/objects (for example Set (OMG, 1999)) are the legitimate types for the OCL expressions\nwritten for it.\nAn OCL expression specifies conditions over the values of the features it references using the\nstandard logical operators \"and\", \"or\", \"implies\" and \"not\" and the set operators \"forall\" and\n\"exists\". The semantics of these set operators are the same as the semantics of the universal and\nexistential quantifier of predicate calculus. Thus, an expression of the form set->forall(x | OCL-\n+context\n{ordered}\nModelElement\nname : Name\nSignificanceCriterion\nexpression : S-expression\nConsistencyRule\nexpression : OCL_Expression\n1..1\n0..*\n0..*\n1..1\n+criterion\n+rule\n15\ncondition-over-x) and set->exists(x | OCL-condition-over-x) becomes true if OCL-condition-over-\nx  is true for all or at least one of the elements of set, respectively.\nAs an example of specifying consistency rules using OCL consider a rule requiring that for\nevery message in a sequence diagram there must be either an association or an attribute between\nits sender and its receiver navigable from the former to the latter class. This rule can be defined in\nthe context of the UML meta-class Message  (i.e., the class of all the messages which appear in the\ninteractions of a model, see Figure 5) using OCL as follows3:\nFigure 5.  UML model elements (adopted from (OMG, 1999))\nRule 1\ncontext:  Message\nexpression:\nself.action.oclIsTypeOf(CallAction) implies self.sender.feature\u2212>exists(a\uf8e6\na.oclIsTypeOf(Attribute) and\n(a.type  = self.receiver) or  Association.allInstances\u2212>exists(r \uf8e6 r.connection\u2212>exists(e1, e2 \uf8e6\n(e1<> e2) and (e1.type = self.sender) and (e2.type  = self.receiver) and (e2.isNavigable  = True)))\n                                                     \n3\n In OCL and S-expressions strings in boldface and Italics are reserved OCL keywords and names\nestablished in the UML meta-model, respectively. The keyword self  in these expressions refers to\nan instance of the class that constitutes the context of the consistency rule and consequently the\ncontext of the S-expression that defines a criterion associated with it.\nInteraction\nAction\nMessage\n*\n0..1\n+activator\n**\n+predecessor\n1..*\n1\n+message\n+action\n*\n1\nModelElement\nname : Name\nCallAction\nOperation\n+operation\n1*\nAssociation\nFeature\nClassifierRole\n1\n*\n+sender *\n1 +receiver\nClassifier\n*0..1\n+feature\n{ordered}\n+owner\nMultiplicity\nMultiplicityRange\nlower :  Integer\nupper :  UnlimitedInteger+range\n1..*\n1\nAttribute\n(from  Core)\nAssociationEnd\nisNavigable :  Boolean\nordering :  OrderingKind\naggregation : AggregationKind\ntargetScope :  ScopeKind\nmultiplicity :  Multiplicity\nchangeability  :  ChangeableKind\nvisibility  :  VisibilityKind\n2..*\n1\n+connection\n*\n1\n+type\n16\nA significance criterion in our framework is specified by a significance expression (S-\nexpression) and must be associated with a consistency rule (see Figure 4). The S-expression\nspecifies a logical combination of the characteristics which the model elements giving rise to the\nviolation of the rule (or other model elements connected to them) are required to have for the\ninconsistency to be significant. These characteristics are specified by using the special predicates\ndefined in Section 2. An S-expression has the same context as the consistency rule associated with\nthe criterion it defines and, therefore, it can reference any named feature in the closure of the\nfeatures of the model elements which are reachable from this context.\nAtomic S-expression Belief Type validity\ncondition\ngen-c(elem) Bel(gen-c(elem)) =\nm1(gen-c(elem))\nelem.type  = Class\nfessen-a(elem1,elem 2) Bel(fessen-a(elem1,elem 2)) =\nm3(fessen-a(elem1,elem 2))\nelem1.type  = Attribute\nOR\nelem1.type  =\nAssociationEnd AND\nelem2.type  = Class\nchar-o(elem) Bel(char-o(elem)) =\nm4(char-o(elem))\nelem.type  = Operation\ncoord-c(elem1,elem 2) Bel(coord-c(elem1,elem 2)) =\nm2(coord-c(elem1,elem 2))\nelem1.type  = Class\nAND\nelem2.type  = Set\n(Interaction)\ncoord-m(elem1,elem2) Bel(coord-m(elem1,elem 2)) =\nm5(coord-m(elem1,elem 2))\nelem1.type  = Message\nAND\nelem2.type  = Set\n(Interaction)\nfdom-m(elem1,elem2) Bel(fdom-m(elem1, elem2)) =\nm6(fdom-m(elem1, elem2))\nelem1.type  = Message\nAND\nelem2.type  = Set\n(Interaction)\nTable 1.  Syntactic forms, typing conditions and beliefs for valid atomic\nS-Expressions\nTables 1 and 2 present the syntactic forms of the S-expressions definable in our framework\nand the typing conditions that these expressions have to satisfy in order to be valid. More\nspecifically, Table 1 presents the syntactic forms of, and the type validity conditions for the so-\ncalled \"atomic S-expressions\" (these are expressions consisting of only one of the predicates\nintroduced in Section 2). The type validity condition determines the valid type(s) for the\nelement(s) that the predicate of an expression refers to. Table 2 presents the syntactic forms of, and\nthe validity conditions for \"non atomic S-expressions\" (these are logical combinations of atomic\n17\nS-expressions). Thus, for instance, according to Table 1 the S-expression gen-c(elem) is valid only\nif the type of the model element denoted by elem  is the UML meta-class Class. The complete\ngrammar for S-expressions is given in (Spanoudakis, 1999).\nAs an example of specifying a significance criterion consider the case where the violations of\nRule-1  above should be considered significant only if they are caused by messages which are\nfunctionally dominant and have coordinating capacity in their interactions.  This criterion of\nsignificance can be specified as follows:\nCriterion\nRule: Rule-1\nS-expression:\nfdom-m(self, self.interaction)\nand  coord-m(self, self.interaction)\nIn the S-expression of this criterion, \"self\" refers to the instances of the context of Rule-1, that\nis the UML meta-class Message.  By using the special predicates fdom-m  and coord-m, this S-\nexpression specifies that the message that violates the rule must be functionally dominant and\nhave a coordinating capacity in the interaction (sequence diagram) it belongs to (that is the value\nof the feature: self.interaction).\nNon atomic S-Expression Belief Validity condition\np1 and\u2026and pn Bel(andi=1,\u2026,n pi) =\n\u03a0\n i=1,\u2026,nBel (pi)\npi : valid atomic S-\nexpression\n(forall i=1,\u2026,n)\nNon\nquantified\nexpressions\np1 or  \u2026or  pn Bel(ori=1,\u2026,n pi) =\n\u03a3J\u2286{1,\u2026,n}(-1)|J| +1\nBel(andi\u03b5Jpi)\npi : valid atomic S-\nexpression\n(forall i=1,\u2026,n)\nelem->exists(x |\nOCL-exp-over-\nx\nand se(x))\n\u03a3J\u2286S (-1)|J| + 1Bel( andx\u03b5J\nse(x))\nwhere\nS = {x | (x \u03b5  elem) and\nOCL-exp-over-x =\nTrue}\nelem.type =\nSet(ModelElement)\nAND\nse(x): is a valid non\nquantified\nS-expression over x\nQuantified\nexpressions\nelem->forall(x |\nOCL-exp-over-\nx\nand se(x))\n\u03a0x \u03b5  elemBel(se(x))\n      If elem->forall(x |\n        OCL-exp-over-x)\n         = True)\n0    If elem->forall(x |\n        OCL-exp-over-x)\n         = False)\nelem.type =\nSet(ModelElement)\nAND\nse(x): is a valid non\nquantified\nS-expression over x\n18\nTable 2.  Syntactic forms of and validity conditions for non atomic S-Expression\nTo assess the significance of the violations of a specific consistency rule, we compute degrees\nof belief for the satisfiability of the S-expression of the criterion associated with the rule by the\nelements of the model which this expression refers to. These elements are related to the model\nelements that gave rise to the violation of the rule as specified by the S-expression. Subsequently,\nthe violations of the rule are ranked in descending order of these degrees of belief.\nTables 1 and 2 show the formulas used to compute the degrees of belief for the different forms\nof atomic and non-atomic S-expressions. These formulas are derived using the axioms of the\nDempster-Shafer theory of evidence (Shafer, 1975) as we prove in (Spanoudakis, 1999) Their\nderivation is based on the fact that \u2212  as we have also proven in (Spanoudakis, 1999) \u2212  the belief\nfunctions introduced in Section 2 satisfy the axiomatic foundation of Dempster-Shafer basic\nprobability assignments (Shafer , 1975).\nIn the following section, we give an example of computing degrees of belief for the\nsatisfiability of significance criteria and ranking inconsistencies according to them.\n4. Example\nAs an example of detecting and assessing the significance of inconsistencies in our\nframework, consider the UML model consisting of the class and sequence diagram shown in\nFigures 1 and 3, respectively. These diagrams are inconsistent with respect to Rule-1  in Section 3\nsince there are no attributes and\/or associations between the sender and the receiver of the\nfollowing messages: execute(),  getText(), executeQuery(String,OCol).\nIf the significance of these inconsistencies is assessed  according to Criterion-1  in Section 3,\nthe inconsistencies caused by the messages execute() and executeQuery(String,OCol) become the\nones with the highest significance, followed by the inconsistency caused by the message getText().\nThis is because the degrees of belief about the satisfiability of Criterion-1  by each of these\nmessages are (according to the belief functions of Tables 1 and 2):\n1) Bel(fdom-m(execute(),{I2}) and coord-m(execute(),{I2})) =\nm6(fdom-m(execute(),{I2}) \u00d7  m5(coord-m(execute(),{I2})) = 0.22 \u00d7  1 = 0.22\n19\n2) Bel(fdom-m(executeQuery(String,OCol),{I2}) and\ncoord-m(executeQuery(String,OCol),{I2})) =\nm6(fdom-m(executeQuery(String,OCol), {I2})) \u00d7\nm5(coord-m(executeQuery(String,OCol),{I2})) =  0.22 \u00d7  1 = 0.22\n3) Bel(fdom-m(getText(),{I2}) and coord-m(getText(),{I2})) =\nm6(fdom-m(getText(),{I2})) \u00d7  m5(coord-m(getText(),{I2})) = 0 \u00d7  0 = 0\n5. Experimental evaluation\nTo evaluate our framework, we implemented the belief functions defined in Section 2 using\nthe scripting language of the CASE tool Rational Rose (Rational, 1998) (a tool supports UML)\nand conducted a series of preliminary experiments using this implementation.\nMODEL\nSize 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\nNo.  of Classes 19 26 23 14 25 18 25 40 12 16 74 13 43 39 55\nNo.  of Seq. Diagrams 3 4 4 2 4 3 12 9 8 8 3 3 12 13 6\nNo.  of Messages 68 24 32 43 51 44 155 92 87 115 65 36 133 186 185\nNo.  of Associations 82 91 68 29 31 38 79 60 17 17 187 30 198 97 230\nProducer a a a a a a a a a a a a a b a\nLegend: a MSc student\nb Group of MSc students\nTable 3.  Size of models used in experimental evaluation\nOur experiments were aimed at testing:\na)  whether the satisfiability measures calculated for significance criteria definable in the\nframework are of sufficient diversity for producing elaborate rankings of inconsistencies, and\nb)  whether the rankings  of significance produced by the criteria of our framework are compliant\nwith rankings of significance produced by those who developed the models and\/or other\nexpert developers when the same criteria are taken into account.\nIn these experiments, we used 15 UML models produced by postgraduate students doing an\nMSc course in Object-Oriented Software Systems in the Department of Computing at City\n20\nUniversity.  Measures of the size of each of these models are shown in Table 3. The findings of\nthese experiments are discussed below.\n5.1 First Set of Experiments: Design, Results and Discussion\nThe objective of our first set of experiments was to establish whether the criteria definable in our\nframework can produce elaborate rankings of significance of inconsistencies. To conduct this\nexperiment, we checked each of the different models against three consistency rules:\n(i)  The consistency rule Rule-1 defined in Section 3. Recall that this rule requires that for every\nmessage in an interaction there must be either an association or an attribute between the class\nof its sender and the class of its receiver navigable from the former to the latter class.\n(ii)  A consistency rule requiring that the class of the receiver of a message in an interaction\ndefines or inherits an operation with the same signature as the message. This rule is defined in\nOCL as follows:\nRule-2\ncontext:  Message\nS-expression: self.action.oclIsTypeOf(CallAction) implies\nself.receiver.feature\u2212>exists(o:Operation\n(self.action.operation  = o))\n(iii)  A consistency rule requiring that the lower multiplicity bound of an association end that is\nattached to a class whose instances receive at least one message from instances of the class\nattached to the other end of its association must be greater or equal to 1. This rule is specified\nin OCL as follows:\nRule-3\ncontext: AssociationEnd\nS-expression: self.association\u2212>exists(a:Association| a.connection\u2212>exists(e1, e2 | (e1 =\nself)   and (e1 <> e2) and (e1.type  = c1)  and (c1.oclIsTypeOf(Classifier)) and\n(e2.type  = c2)  and (c2.oclIsTypeOf(Classifier)) and (c2.message\u2212>exists(m:\nMessage | m.receiver = c1 )))) implies (self.mutliplicity.range.lower >= 1)\n21\nCriterion S-Expression Meaning\nCriterion\n1\nfdom-m(self, self.interaction) The message has functional\ndominance in the sequence diagram\nit appears.\nCriterion\n2\ncoord-m(self, self.interaction) The message has a co-ordinating\ncapacity in the sequence diagram it\nappears.\nCriterion\n3\ncoord-c(self.receiver, self.interaction) The receiver class of a message has a\nco-ordinating capacity in the specific\nsequence diagram that includes the\nmessage.\nCriterion\n4\ncoord-c(self.sender, self.interaction) The sender class of a message has a\nco-ordinating capacity in the specific\nsequence diagram that includes the\nmessage.\nCriterion\n5\ncoord-m(self, self.interaction) or\ncoord-c(self.receiver,self.interaction)\nor\ncoord-c(self.sender, self.interaction)\nThe message or its receiver class or\nits sender class has a co-ordinating\ncapacity in the specific sequence\ndiagram.\nCriterion\n6\nfessen-a(self,\nself.association.oppositeend.type)\nThe association end is functionally\nessential for the class attached to the\nother end of its association.\nTable 4. Criteria used to assess the significance of the violations of Rule 1 and 2.\nThe significance of the violations of Rule-1 was assessed using the criteria 1 and 2 in Table 4.\nThe significance of the violations of Rule-2 was assessed using the criteria 2, 3, 4 and 5 in Table 4.\nThe significance of the violations of Rule-3 was assessed using the criterion 6 in Table 4.\nBelief measures for the satisfiability of each of these criteria by the inconsistencies in the\ndifferent models were computed and used to rank these inconsistencies as we did with the\ninconsistencies in the example of Section 4. More specifically, the inconsistencies caused by\nelements believed to satisfy a criterion to the same extent (i.e. giving rise to equal belief measures)\nwere classified in the same category. The different categories of inconsistencies were then ranked\nin descending order of the criterion satisfiability beliefs computed for their elements.\nTables 5, 6 and 7 present statistics of the belief measures computed for the satisfiability of the\ncriteria by the model elements violating the rules. The columns of each of these tables indicate the\ndifferent models used in the experiments. The rows are grouped under the different criteria used to\nassess the significance of the inconsistencies. The tables show the number of the inconsistencies\ndetected with respect to the rule in each model (see row Ninc) and, for each criterion: (1) the\nnumber of the different categories of significance generated by the criterion (see rows Nc), (2) the\n22\ncompleteness ratio of the ranking generated by the criterion RC = Nc\/Ninc (see rows RC), (3) the\nmean value of the beliefs for the satisfiability of the criterion (see rows Mb), (4) the median value\nof the beliefs for the satisfiability of the criterion (see rows Medianb), (5) the standard deviation of\nthe beliefs for the satisfiability of the criterion (see rows sb), (6) the standard deviation of the\nnumber of inconsistencies in each category of the ranking (see rows sic), and (7) the relative\nvariability of the beliefs for the satisfiability of the criterion (see rows sb\/mb).\nMODELRule 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\nNinc 20 2 7 5 34 19 82 39 32 16 18 6 49 111 41\nCriterion 1\nNc 5 2 4 4 9 6 21 11 16 12 7 2 10 30 13\nRC 0.25 1 0.57 0.8 0.26 0.32 0.26 0.28 0.5 0.75 0.39 0.33 0.20 0.27 0.32\nMb 0.06 0.15 0.19 0.1 0.2 0.11 0.08 0.4 0.17 0.28 0.07 0.02 0.05 0.11 0.07\nMedianb 0.04 0.15 0.17 0.05 0.08 0.08 0.04 0.38 0.09 0.18 0.04 0 0 0 0.03\nsb 0.04 0.07 0.1 0.09 0.29 0.13 0.04 0.29 0.14 0.26 0.06 0.04 0.12 0.23 0.1\nsic 3.08 0 0.5 0.5 2.99 2.56 4.32 2.46 1.55 0.49 2.44 2.82 10.27 13.66 2.82\nsb \/ Mb 0.64 0.47 0.54 0.88 1.46 1.14 0.53 0.73 0.81 0.93 0.92 2 2.4 2.09 1.43\nCriterion 2\nNc 2 1 2 3 6 2 6 9 8 5 4 2 6 11 5\nRC 0.1 0.5 0.29 0.6 0.18 0.11 0.07 0.23 0.25 0.31 0.22 0.33 0.12 0.1 0.12\nMb 0.1 0 0.29 0.25 0.2 0.26 0.24 0.49 0.29 0.53 0.19 0.17 0.27 0.27 0.7\nMedianb 0 0 0 0 0 0 0 0.5 0 0.5 0 0 0 0 1\nsb 0.31 0 0.49 0.43 0.37 0.45 0.38 0.39 0.39 0.44 0.34 0.4 0.44 0.43 0.41\nsic 11.3 0 2.12 1.15 9.54 6.36 20.8 4.66 5.81 2.28 5.69 2.82 13.27 22.72 9.31\nsb \/ Mb 3.08 0 1.71 1.73 1.9 1.72 1.59 0.8 1.34 0.82 1.82 2.35 1.63 1.59 0.58\nTable 5. Statistics for the rankings of the violations of Rule-1\nThe main statistic to look at in Tables 5-7 is the ranking completeness ratio (RC). When this\nratio is 1 then the criterion used can fully order the inconsistencies detected. The mean value of\nthe RC-ratios in the experiments that we conducted was MRC= 0.40 or, equivalently, the criteria\nused produced distinct significance categories with 2.5 (= 1\/MRC) inconsistencies in each category\non average. Thus, it may be argued that on average the criteria used in our first set of experiments\nwere capable of producing elaborate rankings of significance.\nIt has also to be appreciated that the above mean value of the RC-ratios resulted from a set of\nexperiments in which 5 out of the 6 significance criteria used were atomic S-expressions (Criteria\n1, 2, 3, 4 and 6) concerned with single characteristics of model elements. Evidently from the\nstatistics for Criterion 5 in Table 6, in the only case where we used a significance criterion\nreferring to a logical combination of characteristics of elements giving rise to inconsistencies, the\n23\nresulted RC-ratios were significantly higher: the mean value of the RC-ratios for Criterion 5 was\n0.54.\nMODELRule 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\nNinc 8 11 1 7 26 35 90 39 7 14 65 0 16 30 131\nCriterion 2\nNc 1 4 1 3 9 4 9 4 7 3 14 0 8 11 13\nRC 0.13 0.36 1 0.43 0.35 0.11 0.1 0.1 1 0.21 0.22 0 0.5 0.37 0.1\nMb 0 0.24 0 0.44 0.17 0.3 0.11 0.02 0.41 0.13 0.33 0 0.57 0.21 0.39\nMedianb 0 0 0 0.09 0 0 0 0 0.38 0 0.11 0 0.75 0.17 0.4\nsb 0 0.37 0 0.52 0.32 0.45 0.26 0.05 0.3 0.33 0.4 0 0.46 0.17 0.41\nsic 0 2.87 0 1.15 4.94 10.4 23 16.8 0 6.35 7.99 0 2.45 2.05 16.9\nsb \/ Mb 0 1.52 0 1.19 1.86 1.49 2.34 3.22 0.73 2.56 1.2 0 0.81 0.81 1.05\nCriterion 3\nNc 3 3 1 3 11 7 15 6 5 5 9 0 6 8 14\nRC 0.38 0.27 1 0.43 0.42 0.2 0.17 0.15 0.71 0.36 0.14 0 0.37 0.27 0.11\nMb 0.17 0.26 0.29 0.21 0.25 0.29 0.21 0.28 0.39 0.27 0.22 0 0.42 0.38 0.28\nMedianb 0.11 0.17 0.29 0.25 0.18 0.29 0.15 0.25 0.42 0.29 0.18 0 0.43 0.37 0.25\nsb 0.13 0.16 0 0.07 0.19 0.16 0.16 0.2 0.08 0.13 0.12 0 0.10 0.1 0.21\nsic 2.08 1.71 0 2.31 1.75 3.11 5.63 5.75 0.55 1.92 5.45 0 3.14 2.53 11.4\nsb \/ Mb 0.72 0.6 0 0.31 0.73 0.54 0.77 0.73 0.22 0.5 0.53 0 0.24 0.26 0.75\nCriterion 4\nNc 3 3 1 3 11 8 17 8 5 7 8 0 6 8 13\nRC 0.38 0.27 1 0.43 0.42 0.23 0.19 0.21 0.71 0.5 0.12 0 0.37 0.27 0.1\nMb 0.33 0.29 0.14 0.27 0.48 0.47 0.42 0.57 0.2 0.6 0.31 0 0.22 0.22 0.46\nMedianb 0.44 0.25 0.14 0.25 0.56 0.57 0.46 0.63 0.08 0.58 0.27 0 0.17 0.14 0.5\nsb 0.16 0.14 0 0.15 0.22 0.18 0.2 0.17 0.26 0.25 0.15 0 0.10 0.2 0.23\nsic 2.08 1.53 0 2.31 1.91 3.93 4.95 6.27 0.55 1.91 4.12 0 2.65 2.76 8.16\nsb \/ Mb 0.47 0.49 0 0.55 0.46 0.39 0.46 0.29 1.29 0.41 0.47 0 0.45 0.91 0.5\nCriterion 5\nNc 4 8 1 4 17 14 36 11 7 8 33 0 9 22 31\nRC 0.5 0.73 1 0.57 0.65 0.4 0.4 0.28 1 0.57 0.51 0 0.56 0.73 0.24\nMb 0.46 0.6 0.39 0.69 0.68 0.72 0.58 0.69 0.75 0.77 0.63 0 0.73 0.5 0.53\nMedianb 0.51 0.63 0.39 0.62 0.72 0.72 0.59 0.72 0.68 0.88 0.59 0 0.9 0.48 0.62\nsb 0.19 0.25 0 0.31 0.2 0.22 0.22 0.15 0.14 0.18 0.25 0 0.3 0.17 0.36\nsic 0.82 0.52 0 0.96 1.07 2.41 2.24 4.2 0 1.04 2.36 0 2.33 0.79 7.2\nsb \/ Mb 0.4 0.42 0 0.45 0.28 0.3 0.37 0.22 0.19 0.24 0.39 0 0.41 0.34 0.68\nTable 6. Statistics for the rankings of the violations of Rule-2\nAn analysis of the RC-ratios shown in Tables 5, 6 and 7 showed that their distribution\nhad a positive skewness (degree of skewness = 0.93, MedianRC  = 0.35 < MRC  ). This\ndistribution is shown in Figure 6. Also the standard deviation of the RC-values was: sRC =\n0.27. These statistics indicate that further experimentation is needed to confirm the argument\n24\nabout the power of the framework to produce elaborate rankings of inconsistencies. This is\nbecause in 50 per cent of the cases the RC-ratio was lower than 0.35 and there was a relative\nhigh deviation of these values from their average.\nMODELRule 3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\nNinc 1 10 5 9 1 2 10 8 12 10 14 7 23 7 19\nCriterion 6\nNc 1 3 5 4 1 2 5 3 6 3 5 4 8 3 8\nRC 1 0.33 0.66 0.44 1 1 0.5 0.37 0.5 0.33 0.36 0.57 0.35 0.42 0.42\nMb 0.99 0.41 0.55 0.63 0.5 0.93 0.55 0.62 0.70 0.65 0.64 0.45 0.70 0.66 0.61\nMedianb 0.99 0.44 0.55 0.5 0.5 0.93 0.58 0.5 0.70 0.75 0.5 0.5 0.75 0.75 0.75\nsb 0 0.11 0.26 0.18 0 0.08 0.18 0.19 0.20 0.24 0.20 0.35 0.23 0.16 0.37\nsic 0 0.58 0.57 1.5 0 0 1 2.08 1.55 4.04 2.38 0.95 2.36 1.15 1.5\nsb \/ Mb 0 0.27 0.47 0.29 0 0.09 0.33 0.31 0.28 0.37 0.31 0.78 0.33 0.24 0.61\nTable 7. Statistics for the rankings of the violations of Rule-3\nFigure 6. Distribution of RC-ratio values.\nTo explore further the differences in the RC-ratio values, we analysed the correlation of these\nvalues with: (a) different measures of the size of the models (in particular, the number of classes\n(NClasses) and messages (NMessages)), (b) the number of the inconsistencies detected in each case\n(Ninc), and (c) the relative variability of the belief measures computed for the satisfiability of the\ncriteria (i.e., Sb\/Mb).\nThe correlation coefficients calculated by this analysis are shown in Table 8. The most\nprominent result of this analysis was that the RC-ratios were found to be negatively correlated\nwith the number of the inconsistencies (Ninc); the correlation coefficient between these measures\nHistogram\n0\n5\n10\n15\n20\n25\n0\n0.\n1\n0.\n2\n0.\n3\n0.\n4\n0.\n5\n0.\n6\n0.\n7\n0.\n8\n0.\n9 1\nRC-ratios\nFr\ne\nqu\ne\nn\nc\ny\nFrequency\n25\nand the RC-ratios was \u22120.46, as shown in Table 8.\nNClasses NMessages Ninc Sb\/Mb RC\nNClasses 1\nNMessages 1\nNinc 0.48 0.62 1\nSb\/Mb 0.05 0.11 1\nRC -0.27 -0.26 -0.46 -0.37 1\nTable 8.  Correlation of RC-ratios with model size, inconsistency and belief variability measures\nOur explanation of this phenomenon is the following. The number of the inconsistencies\n(Ninc) was found to be positively correlated with the model size: its correlation coefficient with the\nnumber of model classes (Nclasses) was 0.48 and its correlation coefficient with the number of\nmodel messages (Nmessages) was 0.62. This was expected as larger models are more likely to breach\nconsistency rules. What we were also expecting in the case of larger models, however, was that the\nvariability of the belief measures computed for the satisfiability of the used significance criteria\n(i.e., the ratios Sb\/Mb) would also be higher. And, higher variability of the belief measures was\nexpected to lead to finer grain distinctions in the significance rankings. This expectation did not\nturn out to be correct. As shown in Table 8, the Sb\/Mb ratio had only a very weak positive\ncorrelation with the size of the model: its correlation coefficient with the number of model classes\n(Nclasses) was 0.05 and its correlation coefficient with the number of model messages (Nmessages) was\n0.11. The weak correlation between Sb\/Mb  and the different measures of the size of the models is\nexplained by the fact that the criteria used in our experiments were concerned with only specific\nparts of a model (e.g. specific interactions) and, therefore, they were not affected by the overall\nsize of the models. Clearly, further experimentation is needed to explore under what circumstances\nhigher RC-ratios can be obtained.\n5.2 Second Set of Experiments: Design, Results and Discussion\nIn the second set of experiments, we tried to establish whether the rankings of inconsistencies\nproduced by the criteria definable in the framework: (a) preserve the order of rankings of\nsignificance produced by humans, and (b) are as elaborate as the latter rankings. To conduct this\nset of experiments, we selected randomly:\n\u2022 4 of the models used in the first set of experiments, and\n\u2022 12 different inconsistencies detected with respect to Rule 1 (see Section 3) in each of these\nmodels\n26\nA ranking of the inconsistencies in each model was produced by the degrees of belief to the\nsatisfiability of the following criterion (framework ranking of significance):\nCriterion-7\nRule: Rule-2\nS-expression: (fdom-m(self, self.interaction) and  coord-m(self, self.interaction)) or\ncoord-c(self, self.receiver)\nCriterion 7 was used to spot as significant inconsistencies caused by messages which had a\nco-ordinating capacity and were functionally dominant in an interaction or which were invoking\noperations in classes with a co-ordinating capacity in it.\nSubsequently, the author of each model was asked to indicate the significance of the same\ninconsistencies in his\/her model on the scale 1-10, with \"1\" denoting that the inconsistency had no\nsignificance at all and \"10\" denoting that the inconsistency was very significant. The authors were\nprompted to use Criterion 7. The significance scores given by the authors were used to rank the\ninconsistencies of each model (author ranking of significance). The same models and\ninconsistencies were also given to an expert who have had a Ph.D. in Computer Science and 8\nyears of experience in object-oriented modelling. The expert was also asked to indicate the\nsignificance of inconsistencies using the same scale and following the instructions given to the\nauthors. The significance scores given by the expert produced a third ranking of significance of\nthe inconsistencies in each model (expert ranking of significance).\nThe author and expert rankings of the inconsistencies in each model were correlated with the\ncorresponding system rankings using the Kendall's tau  (\u03c4) coefficient for rankings with ties (Hays,\n1969). Kendall\u2019s \u03c4 coefficient is defined as the difference between the probability of two rankings\nagreeing about a pair and the probability of two rankings disagreeing about a pair\n\u03c4 = Pr (two rankings agree about a pair) \u2212  Pr (two rankings disagree about a pair)\nTable 9 shows the main statistics computed from the correlation of the rankings. More\nspecifically, it shows:\n\u0001 the \u03c4 coefficients for the correlation of the author ranking with the system ranking (\u03c4a)\n27\nand the correlation of the expert ranking with the system ranking (\u03c4e)\n\u0001 the values of the statistic S (i.e. the number of agreements minus the number of\ndisagreements of two rankings) used in the calculation of \u03c4 for the correlation of the\nauthor ranking with the system ranking (Sa) and the correlation of the expert ranking with\nthe system ranking (Se), and\n\u0001 the values of the ratio z = S\/\u03c3s (\u03c3s is an estimate of the standard deviation of the values of\nthe statistic S calculated as described in the appendix of the paper) for both correlations\nIn Appendix 1, we give the formulas for and an example of calculating these statistics.\nStatistics MODEL\n7 8 9 11\n\u03c4a -0.284 -0.253 0.174 0.53\nSa -10 -14 7 32\nza -1.08 -1.03 0.65 2.10\n\u03c4e 0.112 0.279 0.098 0.51\nSe 6 14 4 25\nze 0.447 1.1 0.371 1.96\nTable 9. Kendall\u2019s Rank Correlations Statistics\nAs shown in Table 9, the rankings produced by the assessments of significance given by the\nauthors had a negative correlation with the rankings produced by the system for two of the models\n(models 7 and 8) and a positive correlation for the other two models (models 9 and 11). The\nrankings produced by the assessments of significance given by the expert had a positive\ncorrelation with the rankings produced by the system for all the four models. Note, however, that\nonly in the case of model 11 the detected positive correlations were found to be statistically\nsignificant (a = 0.05). The test for the statistical significance of the correlations was based on the z\nratio which is known to have a normal distribution4.\nMODEL\n7 8 9 11\nRCf 0.66 0.66 0.75 0.42\nRCa 0.25 0.33 0.25 0.42\nRCe 0.33 0.25 0.27 0.25\nTable 10. RC-ratios of human- and framework-based rankings of significance\n                                                     \n4\n For rankings with ties, the z-ratio has the normal distribution only if the two rankings show the same distribution of ties.\n28\nOur second set of experiments also showed that the rankings of significance produced by the\nhuman subjects were not as elaborate as those produced by the framework. This can be observed\nfrom the completeness (RC) ratios of the different rankings which are shown in Table 10. The\ncompleteness ratios in this table also show that the statistically significant positive correlations\nbetween the framework and the subject rankings emerged only in the case of model 11 where the\ncompleteness ratio of the framework ranking (RCf) was relatively closer to the completeness ratio\nof the rankings produced by the human subjects (RCa  and RCe).\nThe second set of experiments has shown that the framework tends to create more elaborate\nrankings of significance than developers and that the rankings it creates are not always in\nagreement with rankings of significance produced by developers. These results, however, are by\nno means conclusive and need to be confirmed by further experimentation.\n6. Related work\nWork related to the framework discussed in this paper falls into two broad strands of research\nin the field of software engineering. The first of these strands is concerned with the problem of\nmanaging inconsistencies in software models. The second strand includes research work on\nsoftware metrics.\n6.1 Related work on inconsistency management\nA substantial body of research has been concerned with the problem of detecting and\nresolving inconsistencies between software system specifications (Emmerich et al., 1999;\nFinkelstein et al., 1994; Hunter and Nuseibeh 1998; Spanoudakis and Finkelstein 1996; Schwanke\nand Kaiser 1988; Lamsweerde et al., 1998; Heitmeyer et al., 1995; Robinson and Fickas 1994;\nRobinson and Pawlowski 1999). Those interested may find a survey of the field in (Spanoudakis\nand Zisman, 2001). However, only few strands of work in this general area have been concerned\nwith the particular problem of diagnosing the significance of inconsistencies.\nEmmerich et al (1999) have developed a framework for managing the compliance of software\ndocumentation artifacts with consistency rules which realise document representation standards. In\ntheir framework, software designers can write scripts to implement diagnostic checks to assess the\nimportance and the difficulty of making a document compliant with the rule it violates.\n29\nHunter and Nuseibeh (1998) treat diagnosis as the identification of the \"possible sources\" of\nan inconsistency. In their work, this source is defined in terms of a set \u2206  of all the formulas in a\nsoftware model and a subset P of \u2206  which contains the formulas used in the proof of an\ninconsistency (i.e. the derivation of the empty clause (\u22a5) from the formulas in \u2206). More\nspecifically, the possible source of an inconsistency is defined as any subset S of P whose formulas\nbelong to \u2206  and for which the set of formulas P \u2212  S is a set of consistent formulas. Their work\nsupports the identification of the set S.\nRobinson and Pawlowski (1998) suggest the use of two simple measures as estimates of the\nimpact of conflicting requirement statements, namely the requirement \"contention\" and \"average\npotential conflict\". The contention of a requirement statement in their DealScribe system is\ncomputed as the ratio of the number of the very conflicting or conflicting relations over the total\nnumber of relations that this statement has with other requirements statements. The average\npotential conflict of a statement is measured as the average of the subjective probabilities of\nconflict that have been associated with all the conflicting and very conflicting relations that have\nbeen asserted for it. Robinson and Pawlowski (1998) claim that the contention measure has been\nfound to be very effective in ranking conflicting requirements in terms of significance and\nattempting their resolution in the derived order.\nKotonya and Sommerville (1996) in their VORD method also expect the stakeholders to\nprovide weights that indicate the order of importance of their requirements models. These weights\nare subsequently used to establish the importance of conflicts between these requirements.\n6.2 Related work on software metrics\nSoftware metrics similar to some of the metrics defined in our framework have been proposed\nin the literature but have not been used to assess the significance of inconsistencies in software\nmodels.\nMore specifically, the depth of inheritance tree (DIT) (Chidamber and Kemerer, 1994) and the\nclass hierarchy nesting level (Lorenz, 1993) are similar to m1. Note, however, that unlike m1, DIT\ntreats as generic classes which have no subclasses. Such classes are not as important as classes that\nm1 would spot as generic since they have no subclasses that could be affected by inconsistencies\n30\ninvolving them.\nClass coupling (CBO) (Chidamber and Kemerer, 1994) and the number of collaborating\nclasses (NCC) (Jacobson et al., 1995) are similar to m2. The difference between m2 and CBO and\nNCC is that m2 provides a relative measure of inter-class collaboration in a specific set of system\ninteractions.\nAn idea similar to that underpinning the definition of the functional essentiality of attributes\nand association ends (belief function m3)  underpins the construction of the so-called \"method-to-\nvariable connection matrix\" (MVCM) in (Tegarden et al., 1995) which is used to record (and\nsubsequently count) references to object variables by specific methods.  The main difference\nbetween m3 and the MVCM is that m3 is not applicable to attributes with primitive values (as\nopposed to object-values), and that m3 establishes the potential of using an attribute\/association\nend to identify the receiver of a message dispatched in a method as opposed to using its value in\nany possible way in a method.\nFinally, it has to be appreciated that what clearly differentiates the metrics used in our\nframework from the above software metrics is their common underlying axiomatic interpretation\nas D\u2212S beliefs. This, as discussed in (Spanoudakis, 1999), provides a sound basis for deriving the\nbeliefs for the significance criteria presented in Section 3.\n7. Summary and future work\nIn this paper, we presented a framework for assessing the significance of inconsistencies in\ndesign models of software systems expressed in UML. This assessment is based on criteria that\nsoftware designers can specify to establish combinations of characteristics that the model elements\nwhich are involved in an inconsistency should have for the inconsistency to be significant. The\nframework offers a predefined set of such characteristics which are indicative of the impact that an\ninconsistency that involves a particular model element may have for the model as a whole (see for\nexample the characteristics of class genericity and operation charactericity) or selected parts of it\n(see for example the characteristics of class and message coordinating capacity).\nWe have also presented results of a series of experiments conducted to evaluate the\nframework. The main observations from these experiments were that: (a) it is possible to define\n31\ncriteria in the framework that generate elaborate rankings of significance of inconsistencies, (b)\nthe rankings which are generated by the framework based on particular criteria tend to be more\nelaborate than rankings of significance that developers generate when prompted to use the same\ncriteria, and (c) the rankings of significance produced by the framework tend to have a positive\ncorrelation with rankings of significance produced by experienced developers and a negative\ncorrelation with rankings of significance produced by less experienced developers.\nAn important issue which relates to the use of the presented framework is how to use the\nrankings of significance produced by it in making decisions about the handling the\ninconsistencies. This issue is addressed by the Reconciliation method in the context of which the\ndiagnostic framework has been developed. Reconciliation incorporates an explicit model of the\nprocess of managing inconsistencies which defines: (a) the circumstances under which the\nsignificance of inconsistencies which arise as violations of particular consistency rules may be\nassessed, and (b) alternative ways of handling inconsistencies depending on their significance.\nDevelopers can specify this process model in a way that tailors the inconsistency management\nprocess to the needs of specific software development projects. They may, for instance, define this\nprocess model so as to allow inconsistencies whose significance is below a preset value to be\ntemporarily unresolved and to require inconsistencies whose significance exceeds another preset\nvalue to be fully resolved. The process model may also be specified so as to require the handling\nof inconsistencies in decreasing significance order. The ability to specify the process model along\nwith the ability to specify the criteria for the assessment of violations of individual consistency\nrules makes the activities of diagnosing and handling inconsistencies fully tailorable to the needs\nof specific projects when using Reconciliation. More details on the specification and enactment of\nthe process model of the method may be found in (Spanoudakis and Kim, 2001).\nOn going work on the framework presented in this paper focuses on its further experimental\nevaluation. We are also investigating the possibility of expanding it with additional characteristics\nof model elements as well as with characteristics of entire fragments of models (as opposed to\nindividual model elements) which are related to inconsistencies.\nAcknowledgements\nThe authors would like to thank the British Engineering and Physical Sciences Research\nCouncil (EPSRC) for partially funding the work presented in this paper (IMOOSD project,\n32\nEPSRC grant No. GR\/M57422). They also wish to thank Sylvia Mwenya for carrying out some of\nthe experiments whose results have been analysed in this paper, and Dr. Patricio Letelier\n(University of Valencia) for participating in the experiment described in Section 5.2.\nReferences\nChidamber, S., Kemerer, C., 1994. A Metrics Suite for Object Oriented Design, IEEE Transactions\non Software Engineering, 20(6), 476-493.\nEmmerich, W., et al., 1999. Managing Standards Compliance. IEEE Transactions on Software\nEngineering 25(6), pp. 836-851.\nFinkelstein, A., Gabbay, D., Hunter, A., Kramer, J., and Nuseibeh, B., 1994. Inconsistency\nHandling In Multi-Perspective Specifications, IEEE Transactions on Software Engineering,\n20(8), 569-578.\nFinkelstein, A., Spanoudakis, G.., Till D., 1996. Managing Interference, Joint Proceedings of the\nSigsoft \u201896 Workshops \u2013 Viewpoints \u201896, ACM Press, 172-174.\nGamma E., et al., 1995. Design Patterns: Elements of Reusable Object-Oriented Software,\nAddison Wesley.\nHays, W., 1969. Statistics, 3rd Edition, Holt International, SBN 03 910025.\nHeitmeyer, C., Labaw, B., Kiskis, D., 1995. Consistency Checking of SCR-Style Requirements\nSpecifications, Proceedings  of the 2nd Int. Symposium on Requirements Engineering, IEEE\nCS Press, 56-63.\nHunter, A., Nuseibeh, B., 1998. Managing Inconsistent Specifications: Reasoning, Analysis and\nAction, ACM Transactions in Software Engineering and Methodology, 7(4), pp. 335-367\nJacobson I., et al., 1995. Object-Oriented Software Engineering: A Use Case Driven Approach,\nAddison-Wesley.\nKotonya, G., Sommerville I., 1996. \"Requirements Engineering with Viewpoints\". Software\nEngineering Journal, vol. 11, n. 1, January, 5-18.\nLamsweerde, A., Darimont, A., Letier, E., 1998. Managing Conflicts in Goal-Driven\nRequirements Engineering, IEEE Transactions on Software Engineering, Special Issue on\nInconsistency Management, November 1998\nLorenz, M., 1993. Object-Oriented Software Development: A Practical Guide, Prentice Hall.\nNuseibeh, B., Easterbrook, S., Russo, A., 2000. Leveraging Inconsistency in Software\nDevelopment, IEEE Computer, 33(4), 24-29.\nOMG, 1999. OMG Unified Modelling Language Specification, V. 1.3a. Available\n33\nfrom:ftp:\/\/ftp.omg.org\/pub\/docs\/ad\/99-06-08.pdf.\nRational, 1998. Rational Rose '98: Extensibility Reference Manual. See also:\nhttp:\/\/www.rational.com\/products\/rose\/index.jtmpl\nRobinson, W., Fickas, S., 1994. Supporting Multiple Perspective Requirements Engineering,\nProceedings of the 1st Int. Conference on Requirements Engineering, IEEE CS Press, 206-\n215\nRobinson, W., Pawlowski, S., 1999. \"Managing Requirements Inconsistency with Development\nGoal Monitors\", IEEE Transactions on Software Engineering 25(6).\nRosch, E. et al., 1976. Basic Objects in Natural Categories, Academic Press.\nSchwanke, W., Kaiser, E., 1988. Living with Inconsistency in Large Systems, Proceedings of the\nInt. Workshop on Software Version and Configuration Control, 98-118\nShafer, G., 1975 A Mathematical Theory of Evidence, Princeton University Press.\nSpanoudakis, G., Finkelstein, A., 1996. Managing Interference, Proceedings of the SIGSOFT '96\nWorkshops, ACM Publications, 172-174\nSpanoudakis, G., Towards an Evidential Significance Diagnosis Framework for Elements of UML\nSoftware Models, Technical Report, Technical Report Series, City University, Department of\nComputing, 1999\nSpanoudakis, G., Kasis, K. 2000. An Evidential Framework for Diagnosing the Significance of\nInconsistencies in UML Models, Proceedings of the International Conference on Software:\nTheory and Practice, World Computer Congress 2000, Bejing, China, ISBN 7-5053-6110-4,\n152-162\nSpanoudakis, G., Zisman, A. 2001. Management of inconsistencies in software engineering: a\nsurvey of the state of the art. Handbook of Software Engineering and Knowledge\nEngineering, Vol. 1, World Scientific Pub. Co, (to appear).\nSpanoudakis, G.., Kim H., 2001. Reconciliation of Object Interaction Models, Proceedings of the\n7th International Conference on Object Oriented Information Systems (OOIS '01), Calgary\nCanada, (to appear).\nTegarden, P., Sheetz, S., Monarchi, D., 1995. A Software Complexity Model of Object-Oriented\nSystems, Decision Support Systems: The International Journal, 13, 241-262.\nAppendix: Calculation of Kendall\u2019s \u03c4 coefficient (for rankings with ties)\nThe formula used to calculate \u03c4 for two rankings r1 and r2 with n and k distinct and fully ordered\nranking categories that have ties is:\n34\n\u03c4 = (S+   \u2212   S\u2212) \/ ((((N \/ 2) (N \u2212  1))  \u2212  T1) (((N \/ 2) (N \u2212  1))  \u2212  T2)) \u00bd (1)\nwhere\n\u2022 N is the total number of ranked items in each ranking\n\u2022 S+ is the number of agreements in the two rankings computed by the formula:\nS+= \u03a3i=1\u2026n, j=1,\u2026,k cij \u03a3u=i+1\u2026n, w=j+1,\u2026,k cuw\nThe subscripts indicate the order of categories within a ranking (e.g., the category denoted by\nthe subscript 2 is below the category denoted by the subscript 4 in a ranking).\n\u2022 S\n\u2212\n is the number of disagreements in the two rankings computed by the formula:\nS\n\u2212\n= \u03a3i=1\u2026n, j=1,\u2026,k cij \u03a3u=i+1\u2026n, w= 1,\u2026,j\u22121 cuw\n\u2022 cij(cuw) is the number of the items in category i(u) of ranking r1 and category j(w) of ranking r2\n\u2022 T1 = \u03a3i=1\u2026n ci (ci  \u2212  1) \/ 2, ci is the number of the items in category i of ranking r1.\n\u2022 T2 = \u03a3j=1\u2026k cj (cj  \u2212  1) \/ 2, cj is the number of the items in category j of ranking r2.\nThe ratio z is calculated according to the following formulas:\nZ = S\/\u03c3s (2)\nwhere\n\u2022 S = S+ \u2212  S\u2212\n\u2022 \u03c3s is an estimate of the standard deviation of S calculated by the formula:\n\u03c3s= ((N(N\u22121)(2N + 5) \u2212  \u03a3i=1\u2026n ci (ci \u22121)(2ci+5) \u2212  \u03a3j=1\u2026k cj (cj \u22121)(2cj+5))\/18\n+ [ \u03a3i=1\u2026n ci (ci \u22121)(ci \u22122) ] [ \u03a3j=1\u2026k cj (cj \u22121)(cj\u22122) ] \/ (9N(N\u22121)(N\u22122))\n+ [ \u03a3i=1\u2026n ci (ci \u22121) ] [ \u03a3j=1\u2026k cj (cj \u22121) ] \/ (2N(N\u22121)))1\/2\nAs an example of calculating the above statistics consider the rankings produced for the 12\ninconsistencies of model 11, shown in Table A1. Each inconsistency is denoted by the sequence\ndiagram of the model in which the message that gave rise to it appeared (see column Sequence\nDiagram), the name of the receiver class of the message and the signature of the message (see\ncolumn Receiver-class.message-signature), and the name of the class that sent the message (see\ncolumn Sender-Class). The table also shows the significance scores that the author of the model\ngave to each of the inconsistencies (see column Siga), the rank of the significance category of each\ninconsistency according to the author\u2019s significance scores (see column ra), the beliefs to the\n35\nsatisfiability of Criterion 6 (see Section 5.2) by each of the inconsistencies (see column Bel), and\nthe rank of the significance category of each inconsistency according to these belief measures (see\ncolumn rf),\nSequence diagram Receiver-class.message-signature Sender-class Sig\na\nra Bel rf\nAccountTransferSD AccountQueryBuilder.28.createUpdate(sr\ncAccount,destAccount)\n TransactionManager 6 3 .320 6\nAccountTransferSD TransactionQueryBuilder.24.[1st time]\ncreateQuery(lastTranNo)\n NextTranNo 9 5 .320 5\nRequestStatementSD StatementReqForm.9.displayDefaults\n(accNoList,fromDate,toDate)\n StatementManager 6 3 .231 4\nRequestStatementSD StatementReqForm.9.displayDefaults\n(accNoList,fromDate,toDate)\n StatementManager 6 3 .231 4\nRequestStatementSD  AccountManager.6.getAccList (uRefNo)  StatementManager 6 3 .207 3\nAccountTransferSD  DatabaseManager.15.executeQuery( )  AccountQueryBuilder 3 1 .182 2\nAccountTransferSD  DatabaseManager.25.executeQuery( ) TransactionQueryBuild 3 1 .182 2\nAccountTransferSD  DatabaseManager.7.[!exists]create  AccountQueryBuilder 4 2 .182 2\nAccountTransferSD  DatabaseManager.8.executeQuery( )  AccountQueryBuilder 3 1 .182 2\nRequestStatementSD TransactionTextBox.20.create\n(tranText)\n Statement 8 4 .154 1\nRequestStatementSD  DatabaseManager.14.executeQuery( ) TransactionQueryBuild 3 1 .154 1\nRequestStatementSD  DatabaseManager.8.executeQuery( )  AccountQueryBuilder 3 1 .154 1\nTable A1.   Author and framework rankings of sample of inconsistencies in model 11\nBased on rankings ra  and rf, the values of Kendall\u2019s rank correlation statistics are:\nS+ = 36 T1 = 16 S = 28 \u03c3s = 13.3\nS\n\u2212\n= 8 T2 = 11 \u03c4 = 0.53 z = 2.1\n"}