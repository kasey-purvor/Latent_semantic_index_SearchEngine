{"doi":"10.1109\/CSFW.2005.26","coreId":"102429","oai":"oai:epubs.surrey.ac.uk:1888","identifiers":["oai:epubs.surrey.ac.uk:1888","10.1109\/CSFW.2005.26"],"title":"Temporal rank functions for forward secrecy","authors":["Delicata, Rob","Schneider, Steve A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2005-06-20","abstract":"A number of cryptographic protocols have appeared in the literature that claim to provide forward secrecy. The idea of forward secrecy is that if a long-term key is compromised then any session-keys that were previously established using the long-term key should remain secret. Forward secrecy is important in scenarios where session-keys need protection beyond the time-span during which they are used. These situations typically arise when session-keys are used for data encryption, rather than just authentication. There appears to be a disparity between the growing number of protocols that claim forward secrecy, and the work carried out on its formal analysis. In contrast to secrecy and authentication, the formal verification of forward secrecy has, with some exceptions received little attention in the literature. This paper fills the gap for the rank function approach","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1888<\/identifier><datestamp>\n      2017-08-18T11:49:11Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1888\/<\/dc:relation><dc:title>\n        Temporal rank functions for forward secrecy<\/dc:title><dc:creator>\n        Delicata, Rob<\/dc:creator><dc:creator>\n        Schneider, Steve A.<\/dc:creator><dc:description>\n        A number of cryptographic protocols have appeared in the literature that claim to provide forward secrecy. The idea of forward secrecy is that if a long-term key is compromised then any session-keys that were previously established using the long-term key should remain secret. Forward secrecy is important in scenarios where session-keys need protection beyond the time-span during which they are used. These situations typically arise when session-keys are used for data encryption, rather than just authentication. There appears to be a disparity between the growing number of protocols that claim forward secrecy, and the work carried out on its formal analysis. In contrast to secrecy and authentication, the formal verification of forward secrecy has, with some exceptions received little attention in the literature. This paper fills the gap for the rank function approach.<\/dc:description><dc:date>\n        2005-06-20<\/dc:date><dc:type>\n        Conference or Workshop Item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1888\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Delicata, Rob and Schneider, Steve A.  (2005) Temporal rank functions for forward secrecy  In: 18th IEEE Workshop on Computer Security Foundations, 2005, 20-22 Jun 2005, Aix-en-Provence, France.     <\/dc:identifier><dc:relation>\n        10.1109\/CSFW.2005.26<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1888\/","10.1109\/CSFW.2005.26"],"year":2005,"topics":[],"subject":["Conference or Workshop Item","PeerReviewed"],"fullText":"Temporal rank functions for forward secrecy\nRob Delicata and Steve Schneider\nDepartment of Computing, University of Surrey, UK.\n{R.Delicata, S.Schneider}@surrey.ac.uk\nAbstract\nA number of key establishment protocols claim the prop-\nerty of forward secrecy, where the compromise of a long-\nterm key does not result in the compromise of previously\ncomputed session-keys. We describe how such protocols can\nbe modelled using the process algebra CSP and explain\nwhy the well-known rank function approach is incapable\nof proving their correctness. This shortcoming motivates us\nto propose a generalised proof technique based on the novel\nconcept of a temporal rank function.We apply this approach\nto two examples: a protocol due to Boyd and the Cliques (A-\nGDH.2) group key agreement protocol.\n1. Introduction\nA number of cryptographic protocols have appeared in\nthe literature that claim to provide forward secrecy. The\nidea of forward secrecy is that if a long-term key is com-\npromised then any session-keys that were previously es-\ntablished using the long-term key should remain secret.\nForward secrecy is important in scenarios where session-\nkeys need protection beyond the time-span during which\nthey are used. These situations typically arise when session-\nkeys are used for data encryption, rather than just au-\nthentication. There appears to be a disparity between the\ngrowing number of protocols that claim forward secrecy\n[2, 7, 17, 16, 1, 18, 15] and the work carried out on its for-\nmal analysis. In contrast to secrecy and authentication, the\nformal veri\ufb01cation of forward secrecy has, with some ex-\nceptions [20, 4], received little attention in the literature.\nThis paper \ufb01lls the gap for the rank function approach.\nThis paper demonstrates how the notion of a rank func-\ntion can be generalised to permit the veri\ufb01cation of for-\nward secrecy. The rank function approach [23] has pre-\nviously been used to reason about authentication, secrecy\nand non-repudiation in a number of cryptographic proto-\ncols [23, 25, 9, 5]. In the standard approach, a rank func-\ntion is used to partition the message-space of a protocol\nsuch that all messages which should remain secret are as-\nsigned a rank of sec and all messages that might be public\nare assigned a rank of pub. Typically, the protocol is mod-\nelled using the process algebra Communicating Sequential\nProcesses (CSP) [22, 24]. The central rank theorem gives a\nseries of healthiness conditions that the function must sat-\nisfy in order for us to conclude that the protocol does actu-\nally maintain the secrecy of a given set of messages. Stated\nanother way, the rank theorem gives the conditions under\nwhich it is reasonable to conclude that the sets of public\nand secret messages are disjoint.\nIt turns out that this all-or-nothing view of secrecy is un-\nable to capture properties of protocol models which include\ncompromised keys. Since compromised keys become pub-\nlic after some initial period of secrecy they can neither be\nclassi\ufb01ed as entirely secret nor entirely public, and the stan-\ndard approach cannot model values that inhabit this middle-\nground. Since forward secrecy is dependent on the con-\ncept of compromised keys, protocolswhich provide forward\nsecrecy are unveri\ufb01able using the standard approach. Al-\nthough this incompleteness motivates the richer concept of\na temporal rank that we propose here, a discussion of the\nshortcoming is somewhat incidental to the main thrust of\nthe paper. For this reason we delay it until Section 5. Our\ngoal is not to introduce yet-another-veri\ufb01cation-technique\nbut to show how an existing technique can be generalised\nto permit reasoning about a wider class of security proper-\nties.\nIn the next section we describe how compromised keys\ncan be modelled using CSP and show how forward secrecy\ncan be formalised as a trace speci\ufb01cation over such a proto-\ncol model. In Section 3 we introduce the idea of a temporal\nrank function and establish a central theorem that gives con-\nditions under which we can conclude that a protocol guar-\nantees forward secrecy. We demonstrate this approach on\nthe running example of a protocol due to Colin Boyd and\nin Section 4 consider a further example: the Cliques (A-\nGDH.2) group key agreement protocol. As mentioned, Sec-\ntion 5 discusses why the original rank function approach\nfails in the presence of compromised keys, and Section 6\nconcludes. Some knowledge of CSP is assumed but we pro-\nvide a summary of relevant notation in Appendix A.\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \n2. Formalising forward secrecy\nThe concept of forward secrecy was \ufb01rst introduced by\nGu\u00a8nther [10] who used the term perfect forward secrecy.\nWe follow the lead of other authors [14, 3] in dropping the\nword perfect and avoiding confusionwith the unrelated con-\ncept of perfect secrecy.\nForward secrecy is captured by the following de\ufb01nition:\nDe\ufb01nition 1 A key establishment protocol provides for-\nward secrecy if compromise of the long-term keys of a set\nof principals does not compromise the session-keys estab-\nlished in previous protocol runs involving those principals.\nAs a running examplewe use a protocol due to Boyd [3] that\ntakes its cue from an earlier idea by Wiener [26]. The pro-\ntocol allows a session-key k to be established between two\nprincipals, a and b. a generates a fresh asymmetric key-pair\n(pk, sk) and sends the public half to b along with a fresh\nnonce, na, and the signature of pk under a long-term sign-\ning key Sig(a). b uses the public-key to encrypt the session-\nkey k and sends it to a along with a signature containing a\nhash of the session-key:\n1. a \u2192 b : pk \u00b7 na \u00b7 {pk \u00b7 b}Sig(a)\n2. b \u2192 a : {k}pk \u00b7 {h(k) \u00b7 a \u00b7 na}Sig(b)\n(we write m1 \u00b7m2 for the pairing of messages m1 and m2\nand use {m}k to denote the encryption of m under a key k).\nThis protocol aims to meet the forward secrecy property of\nDe\ufb01nition 1 if a and b are honest and the long-term signing\nkeys Sig(a) and Sig(b) are not compromised until after the\nprotocol has ended. This can be argued informally in the fol-\nlowing way. The keys Sig(a) and Sig(b) are used only to au-\nthenticate the session-key, and although their disclosure al-\nlows an attacker to masquerade as a or b in future protocol\nruns, it does not allow him to recover the past session-key.\nThe session-key can only be recovered with the private-key,\nsk, which is freshly generated for each protocol run. Asym-\nmetric key-pairs, such as (pk, sk), which are discarded after\na single protocol run are termed ephemeral keys, and it is\nthe use of ephemeral keys that enables the protocol to pro-\nvide forward secrecy.\nBoyd and Mathuria [3] call the property in De\ufb01nition 1\nfull forward secrecy in distinction to the weaker property of\npartial forward secrecy:\nDe\ufb01nition 2 A protocol provides partial forward secrecy if\ncompromise of the long-term keys of one or more speci\ufb01c\nprincipals does not compromise the session keys established\nin previous protocol runs involving those principals.\nThe difference between full and partial forward secrecy cen-\ntres around the number of long-term keys that are compro-\nmised. For example, a protocol involving two honest par-\nties, A and B, will provide full forward secrecy if a past\nsession-key remains secure when both A\u2019s and B\u2019s long-\nterm keys are compromised. If this property is not met, how-\never, the protocol may still provide partial forward secrecy\nif the compromise of just one long-term key (either A\u2019s or\nB\u2019s, but not both) prevents the intruder from discovering a\npast session-key. Full forward secrecy takes a pessimistic\nview by assuming the disclosure of all long-term keys, and\nfor the purpose of protocol veri\ufb01cation it will often be pru-\ndent to apply this stronger condition. For protocol analy-\nsis1, however, it is often useful to consider partial forward\nsecrecy since, if the protocol does not meet the weaker goal,\nit will certainly not satisfy the stronger condition. For sim-\nplicity, the present work concentrates on the notion of par-\ntial secrecy, although this is by no means a limitation of\nour approach. In particular, we will show that Boyd\u2019s proto-\ncol achieves partial forward secrecy with respect to the key\nSig(A) for some (honest) initiator A.\nPereira makes an interesting distinction between what he\nterms complete forward secrecy and individual forward se-\ncrecy [19]. In complete forward secrecy it is assumed that\nthe past protocol runs were executed without any interfer-\nence by the intruder, who is passive and merely records the\nmessages that pass on the network. In contrast, individual\nforward secrecy assumes an intruder who has potentially\nmanipulated the messages of one or more principals in pre-\nvious runs. The terms \u2018complete\u2019 and \u2018individual\u2019 are ap-\npropriate for Pereira\u2019s focus on principals in group Dif\ufb01e-\nHellman protocols. Here, however, we will refer to them as\npassive and active forward secrecy, respectively, in recog-\nnition of the intruder\u2019s role in past protocol runs. When\nwe talk about forward secrecy in this paper we are refer-\nring speci\ufb01cally to the notion of active forward secrecy.\nClearly, a protocol that provides active forward secrecy also\nachieves the weaker goal of passive forward secrecy.\n2.1. Compromised keys\nWe model protocols in CSP where each principal, and\na special intruder process called ENEMY, are represented\nby processes. A principal A can transmit a message M to B\nby performing the event trans.A.B.M. Conversely, B can re-\nceive this message by performing rec.B.A.M. We assume\na worst-case-scenario where all data communication (any-\nthing passed on the channels trans and rec) passes through\nthe intruder. This arrangement is shown in Figure 2. A side-\neffect of this network composition is that ENEMY, unlike\nthe user processes, \u2018hears\u2019 messages on channel trans and\n\u2018says\u2019 messages on channel rec.\n1 Our distinction between protocol veri\ufb01cation and protocol analysis\nlies in the goal of the endeavour: the \ufb01rst aims to prove correctness\nwhilst the second attempts to discover attacks. In general, failure to\n\ufb01nd an attack does not imply correctness.\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nPAIRING\nS \u0002 m1 S \u0002 m2\nS \u0002 m1 \u00b7m2\nUNPAIRING\nS \u0002 m1 \u00b7 m2\nS \u0002 m1 S \u0002 m2\nMEMBERSHIP\nS \u0002 m (m \u2208 S)\nHASHING\nS \u0002 m\nS \u0002 h(m)\nENCRYPTION\nS \u0002 m S \u0002 k\nS \u0002 {m}k\nDECRYPTION\nS \u0002 {m}k S \u0002 k\nS \u0002 m\nFigure 1. Intruder deductions\nForward secrecy becomes relevant in situations where\nlong-term keys can become compromised. We are not con-\ncerned with how the keys are leaked (as a result of crypt-\nanalysis, for example), but only with the fact that they are.\nWe develop a process ENEMY that represents an active\nDolev-Yao style intruder [8] with the additional ability to\nlearn long-term keys that have been leaked.\n2.1.1. The intruder process The model of ENEMY is\nbuilt around a set S of facts that the intruder knows and a\n\u2018generates\u2019 relation \u0002 that the intruder can use to deduce\nnew facts. We write S \u0002 m if the intruder can generate the\nmessage m by knowing all messages in the set S. The ca-\npabilities captured by \u0002 are given in Figure 1. The process\nENEMY is parameterised by a set IIK \u2014 the Intruder\u2019s Ini-\ntial Knowledge\u2014 that contains the facts available to the in-\ntruder at the start of the protocol. This set will typically in-\nclude the usernames of all principals, any long-term public-\nkeys and other keys that the intruder may reasonably know.\nThe intruder can (i) hear any message on the network\nand add that message to his knowledge set, (ii) send to any\nprincipal any message generable under \u0002, and (iii) compro-\nmise any key in a set TS of temporary secrets and add it to\nhis knowledge set:\nENEMY = Enemy(IIK)\nEnemy(S) =\ntrans?a?b?m \u2192 Enemy(S \u222a {m})\n\u0001 \u0001 a:U,\nb:U,\nm|S\u0001m\nrec.a.b.m \u2192 Enemy(S)\n\u0001 \u0001\nm:TS\nleak.m \u2192 Enemy(S \u222a {m})\n(whereU is the set of identities of all principals). The de\ufb01ni-\ntion of ENEMY is not entirely general since we can adapt it\nto facilitate the compromise of different sets of keys. Doing\nso will be dependent on both the protocol under considera-\ntion and the precise forward secrecy goal that we intend to\nverify. To reason about full forward secrecy in Boyd\u2019s proto-\ncol, for example, we would de\ufb01ne TS = {Sig(a) | a \u2208 U}.\nNote that the intruder can always signal his knowledge of a\nUSERA\nUSERC\nUSERBtrans.A\nrec.A\ntrans.B\nrec.B\nUSERE\nENEMY\nFigure 2. Network arrangement\nmessage M by performing the event trans.E.E.M, where E\nis the intruder\u2019s identity.\n2.1.2. The principals We model each principal that takes\npart in the protocol as a CSP process representing the pro-\ntocol steps performed by that principal. For example, con-\nsiderUserI(a, b, pk, na) from Figure 3. This process models\na principal a running Boyd\u2019s protocol as initiator (denoted\nby the superscripted I) with b, where pk is the ephemeral\npublic-key and na is the nonce used in the run. Similarly,\nUserR(b, a, k) is a principal b running as responder, appar-\nently with a, using the session-key k. On receipt of the \ufb01rst\nprotocol message, b veri\ufb01es the signature to satisfy himself\nthat the message originated from a. The responder asserts\nhis belief that k will be a secret shared only with a by per-\nforming the signal event signal.b.a.k.\nThe network composition is shown in Figure 3. The pro-\ncess USERa represents the entire behaviour of a principal a\nin both initiator and responder roles. In the initiator case a\nsession variable pk is chosen from the set PKab of public-\nkeys that a will use in runs with a particular principal b.\nThe function nonce is an injective mapping from public-\nkeys to nonces such that nonce(pk) is the nonce that a will\nuse in the run involving pk. Similarly, as a responder, the in-\nterleaving is indexed by the session-key k \u2208 Kba. The sets\nPKab and Kab of public- and session-keys are all pairwise\ndisjoint.\nWe incorporate the ENEMY and user processes into a\nstandard CSP protocol model in which an arbitrary num-\nber of principals can engage in arbitrarily many instances of\nthe protocol concurrently. By convention, the process repre-\nsenting the entire network is called NET.\n2.2. Statement of forward secrecy\nA CSP process can be characterised by its traces, where\na trace represents one possible sequence of events that the\nprocess can perform. For a process P, traces(P) is the set\nof all possible traces of P. The set traces(P) is always non-\nempty since every process can perform the empty trace \u3008\u3009\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nUserI(a, b, pk, na) =\ntrans.a.b.(pk \u00b7 na \u00b7 {pk \u00b7 b}Sig(a))\n\u2192 rec.a.b?({k}pk \u00b7 {h(k) \u00b7 a \u00b7 na}Sig(a))\n\u2192 Stop\nUserR(b, a, k) =\nrec.b.a?(pk \u00b7 na.{pk \u00b7 b}Sig(a))\n\u2192 signal.b.a.k\n\u2192 trans.b.a.({k}pk \u00b7 {h(k) \u00b7 a \u00b7 na}Sig(a))\n\u2192 Stop\nUSERa =\n|||b:U\n(|||pk:PKab UserI(a, b, pk, nonce(pk))\n)\n|||(|||k\u2208Kab UserR(a, b, k)\n)\nNET =\n(|||\na:U\nUSERa\n)\n|[ {| trans, rec |} ]|ENEMY\nFigure 3. CSP model of Boyd\u2019s protocol\nand is pre\ufb01x-closed since, if s \u0001 t is a trace of P, then s is\nalso a trace of P.\nA trace speci\ufb01cation is a predicate on traces, and we\nwrite W(tr) if the predicate W holds for a trace tr. A pro-\ncess P satis\ufb01es W (written P sat W) if all its traces satisfy\nW:\nP sat W \u21d4 \u2200 tr \u2208 traces(P).W(tr)\nWe are already in a position to prove that any message\nthat can be sent by ENEMY must be generable from the set\nIIK together with the messages input on channels trans and\nleak.\nTheorem 1\nENEMY sat\n(IIK \u222a (tr \u21d3 {trans, leak})) \u0002 tr \u21d3 rec\nProof (sketch). We prove by a mutual recursion induc-\ntion that Enemy(S) sat (S \u222a (tr \u21d3 {trans, leak})) \u0002 tr \u21d3\nrec and the result follows from the fact that ENEMY =\nEnemy(IIK). \u0002\nWe introduce two important trace speci\ufb01cations. The\n\ufb01rst is the secret predicate which states that no event t \u2208 T\noccurs in the trace tr:\nDe\ufb01nition 3\nsecret T = tr \u0003 T = \u3008\u3009\n(where tr \u0003 T is the trace tr restricted to events in T). Al-\nthough T is a set of events, it will be convenient to think of\nit as a set of messages that we wish to keep secret, and we\nabuse the notation to write (for example) T = {M} where\nwe should more properly have written T = {trans.a.b.M |\na \u2208 U, b \u2208 U}.\nThe second important trace predicate is St precedes\nwhich states that, for disjoint sets R and T, any occurrence\nof an event t \u2208 T in a trace will be strictly preceded by some\noccurrence of an event r \u2208 R:\nDe\ufb01nition 4\nR St precedes T =\ntr \u0003 T \n= \u3008\u3009 \u21d2\n\u2203 tr\u2032 < tr.tr\u2032 \u0003 R \n= \u3008\u3009 \u2227 tr\u2032 \u0003 T = \u3008\u3009\nConsider the process NET from Figure 3. If a trace tr0 \u2208\ntraces(NET) contains the event leak.Sig(A) we know that\nthe intruder has, at that point, learned the signing-key of\nprincipal A. Similarly, if tr0 contains the event signal.B.A.K\nwe can conclude that, at that point, B was willing to estab-\nlish a key K with a principal who B believed to be A. If\nleak.Sig(A) appears in the trace before signal.B.A.K then\nthe ephemeral key used to encrypt K may have come from\nthe intruder, who invents a key-pair (PK, SK) and a nonce\nNA and uses Sig(A) to masquerade as A:\n1. E(A) \u2192 B : {PK,B}Sig(A)\n2. B \u2192 E(A) : {K}PK, {h(K),A,NA}Sig(B)\n(where E(A) denotes the intruder masquerading as A). If, on\nthe other hand, signal.B.A.K occurs before leak.Sig(A) (i.e.,\nif the predicate {signal.B.A.K} St precedes {leak.Sig(A)}\nholds) then the forward secrecy property tells us that the\ncompromise of Sig(A) should not result in the compromise\nof the (previously established) session-keyK. We can there-\nfore state the claim secret{K}: the intruder never learns K.\nThis is the heart of our statement of forward secrecy: that\nall session-keys established between honest principals be-\nfore the compromise of the long-term key should remain\nsecret even after the long-term key has been leaked. If k is\na session-key established between two honest principals a\nand b and lk is a long-term key used to establish k, we de-\n\ufb01ne the trace speci\ufb01cation fs that captures this notion of for-\nward secrecy:\nDe\ufb01nition 5\nfs(k, lk) =\n{signal.b.a.k} St precedes {leak.lk}(tr)\n\u21d2 secret{k}(tr)\nFor our running example, represented by the process NET,\nwe can state the speci\ufb01cation as:\nNET sat fs(K, Sig(A))\nThat is, if B is willing to establish the session-key K \u2208 KBA\nwith A, before the key Sig(A) is compromised, then K re-\nmains a secret known only to A and B. Note that, if B will-\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \ningly engages in a run with a dishonest principal then nei-\nther secrecy nor forward secrecy of the resulting session-\nkey can be expected.\n2.3. Restricting the network\nLet k0 \u2208 Kba be a session-key established using a long-\nterm key lk0 between two honest principals a and b. Our\ngoal is to prove that NET sat fs(k0, lk0) for some protocol\nmodel NET. However, we can ease this task by \ufb01rst apply-\ning some simple CSP manipulation. Expanding the de\ufb01ni-\ntion of fs for NET, we obtain the goal:\nNET sat\n({signal.b.a.k0} St precedes {leak.lk0}\n\u21d2 secret {k0})\nLet TR be the set of traces ofNET that satisfy the antecedent\n{signal.b.a.k0} St precedes {leak.lk0} :\nDe\ufb01nition 6\nTR = {tr \u2208 traces(NET) |\n{signal.b.a.k0} St precedes {leak.lk0}(tr)}\nLemma 1 TR \u2286 traces(NET)\nThis is an immediate consequence of De\ufb01nition 6.\nTR is both non-empty (since the empty trace \u3008\u3009 satis-\n\ufb01es the antecedent) and pre\ufb01x-closed (since, if s \u0001 t sat-\nis\ufb01es the antecedent then so will s). The trace set TR can be\nseen as representing a restriction of the network described\nbyNET. Since a CSP process is de\ufb01ned in terms of its traces\nwe can (at least in this case) de\ufb01ne a new process, NET \u2032,\nwhose traces are precisely those in the set TR. Intuitively,\nNET \u2032 is the process whose traces are those of NET in which\nsignal.b.a.k0 always precedes leak.lk0.\nLet K be the set of session-keys from which k0 is drawn\nand let LK be the set of long-term keys from which lk0 is\ndrawn. RES is a process that blocks the event leak.lk0 until\nsuch time as signal.b.a.k0 has occurred:\nRES = signal?b?a?k \u2192\nif k = k0 then RUNX else RES\n\u0001 leak?k : (LK \\ {lk0}) \u2192 RES\nwhere X = {| signal, leak |}\nRUNX is a special process that is always willing to com-\nmunicate any event in the set X (See Appendix A). Based\non this we can de\ufb01ne NET \u2032 as follows:\nDe\ufb01nition 7 NET \u2032 = NET |[X ]|RES\nNET \u2032 forces the synchronisation of all leak and signal\nevents between NET and RES, and we can demonstrate that\nNET \u2032 has as its traces precisely the set TR:\nTheorem 2 traces(NET \u2032) = TR\nProof. Consider a trace tr \u2208 traces(NET \u2032). By de\ufb01nition\nof NET \u2032, tr \u2208 traces(NET |[ {| signal, leak |} ]|RES). The\nsemantics of CSP interface parallel then tell us that tr \u2208\ntraces(NET) (i) and tr \u0003 {| signal, leak |} \u2208 traces(RES).\nBy de\ufb01nition of RES we have that whenever leak.lk0 ap-\npears in tr it is preceded by an event signal.b.a.k0 for some\na, b, and so {signal.a.b.k0} St precedes {leak.lk0}(tr) (ii).\nFinally fromDe\ufb01nition 6, (i) and (ii) yield that tr \u2208 TR. The\nsame argument works in the opposite direction to show that\ntr \u2208 TR \u21d2 tr \u2208 traces(NET \u2032). \u0002\nThe assumption {signal.b.a.k0} St precedes {leak.lk0}\non NET has been absorbed into NET \u2032 and this enables us to\nrewrite the fs trace speci\ufb01cation to a simpler form:\nNET \u2032 sat secret {k0}\nIn doing so we have reduced a forward secrecy predicate\nover the whole network (NET) to a secrecy predicate over a\nrestricted subset (NET \u2032) of that network. If we can prove\nthat NET \u2032 sat secret {k0} then we will have shown that\nNET sat fs(k0, lk0). Applied to our running example, we\nare left to prove that NET \u2032 sat secret {K} where K \u2208 Kba\nfor some honest principals a and b.\n3. Temporal rank functions\nIn this section we introduce a proof technique suitable\nfor verifying whether the forward secrecy property of the\nprevious section holds for a given protocol. In particular, we\nobtain a specialised theorem that applies to secrecy proper-\nties on the protocol network. This theorem is the core of the\nproof strategy presented in this paper; it provides a suf\ufb01-\ncient list of conditions whose achievement guarantees that\nNET \u2032 sat secret T for a set T.\n3.1. Time tags\nConsider an instance of the Boyd protocol where the\nsession-key K is established between A and B using the\nlong-term key Sig(A) and that Sig(A) is subsequently com-\npromised at some time n. For simplicity we assume that B\u2019s\nsigning key, Sig(B), is not leaked, and so de\ufb01ne the set TS of\ntemporary secrets as TS = {Sig(A)}. The intruder\u2019s capa-\nbilities are increased at time n since from this point he can\nuse Sig(A) to sign anything he knows and can send the re-\nsultant message to any principal willing to accept it, whilst\nmasquerading as A. The messages that the intruder can gen-\nerate can be divided into several categories: (i) those he can\ngenerate before time n, (ii) those he can generate at or af-\nter time n, and (iii) those he can never generate. In fact, we\ncan go further and tag each message m in the space of the\nprotocol with a label t \u2208 N\u221e representing the earliest time\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nat which m can be assumed to be generable by the intruder\nwithout affecting the correctness of the protocol.\nFor example, since usernames are generally included in\nthe intruder\u2019s initial knowledge we would tag A and B with\n0, denoting the fact that the intruder knows them at time 0.\nSimilarly, since A makes the ephemeral public-key pk avail-\nable before Sig(A) is leaked we would tag it with a label\nin the range 0 \u2264 t < n. Furthermore, since Sig(A) be-\ncomes available at time n we would label it as such. Finally,\nmessages (such as the session-key K) which should never\nbe generable by the intruder would be tagged with in\ufb01n-\nity (\u221e). It may be helpful to think of\u221e as denoting that the\nmessage is not generable in \ufb01nite time, although for practi-\ncal purposes it will only mean that it is computationally in-\nfeasible for the intruder to deduce the message.\nOur veri\ufb01cation approach is based on the interpretation\nof a time tag as a rank, and we will say that a message m\nhas a rank t (written \u03c1(m) = t) if it is safe to assume that\nm is generable by the intruder at time t. We will wish to\nprove that, at time t, the intruder is incapable of generat-\ning any message with a rank greater than t. This will en-\nable us to conclude that messages such as K are actually not\ngenerable by the intruder until time \u221e and, therefore, re-\nmain secret. In the remainder of this section we formalise\nthe notion of a temporal rank, introduce our central theo-\nrem, and show how we can use it to prove that Boyd\u2019s pro-\ntocol meets its forward secrecy goal.\n3.2. Temporal ranks\nA rank function is a function from the space of messages\nM to the set of natural numbers with in\ufb01nity: N\u221e.\nDe\ufb01nition 8 Let M be the message-space of a protocol.\nThen de\ufb01ne \u03c1 to be the function \u03c1 : M \u2192 N\u221e\nOur intention is to de\ufb01ne a rank function over the message-\nspace of NET \u2032 such that the rank of a message m, written\n\u03c1(m), respects the time at which m becomes available to the\nintruder. Messages known initially to the intruder (m \u2208 IIK)\nwill have \u03c1(m) = 0. If, on the other hand, m should be un-\navailable to the intruder we will typically assign it a rank\nof \u221e. Messages that become available to the intruder dur-\ning the course of the protocol will be assigned some (pos-\nsibly non-zero) \ufb01nite rank. A rank function effectively par-\ntitions the message-space into the set of messages that the\nintruder can know (those with \ufb01nite ranks) and those that\nshould remain secret (those with a rank of \u221e). Rank func-\ntions operate on messages communicated as events in the\ntraces of a CSP process. We lift ranks to events in the sense\nthat \u03c1(trans.a.b.m) = \u03c1(rec.a.b.m) = \u03c1(leak.m) = \u03c1(m)\nand to sets by de\ufb01ning \u03c1(S) to be the rank of the highest\nranked message in S.\nGenerally speaking, the traces of a CSP process do not\nhave any concept of time. However, we can impose a sense\nof discrete time onto traces by taking the time of an event\nto be its position in a trace. We de\ufb01ne the leak-time of a key\nk in a trace tr (written \u03c4(k, tr)) to be the position in the se-\nquence tr at which leak.k \ufb01rst occurs. If leak.k does not oc-\ncur in tr then \u03c4(k, tr) = \u221e.\nDe\ufb01nition 9 Assuming that k \/\u2208 IIK, if \u00ac(leak.k in tr) then\n\u03c4(k, tr) = \u221e, else let tr = tr\u2032 \u0001 \u3008leak.k\u3009 \u0001 tr\u2032\u2032 such that\n\u00ac(leak.k in tr\u2032), then \u03c4(k, tr) = #tr\u2032 + 1\nThe following examples will help to clarify this:\n1. If tr0 = \u3008leak.k\u3009 then \u03c4(k, tr0) = 1 .\n2. If tr1 = \u3008trans.a.b.m, rec.b.a.m, signal.a.b.k, leak.k\u3009\nthen \u03c4(k, tr1) = 4 .\n3. If tr2 = \u3008trans.a.b.m1, rec.b.a.m1, trans.a.b.m2\u3009 then\n\u03c4(k, tr2) = \u221e .\nNote that, since leak.k is not preceded by the corresponding\nsignal event in tr0, tr0 \/\u2208 traces(NET \u2032).\nAs discussed earlier, the rank of a message may be de-\npendent on the leak-time of some long-term key. Further-\nmore, the leak-time will not generally be \ufb01xed but will oc-\ncur at different times for different traces of NET \u2032. Rather\nthan de\ufb01ne a distinct rank function for each possible sce-\nnario we use the concept of a family of rank functions\n\u03c1, parameterised by n, such that the rank function \u03c1n will\napply precisely when the leak-time of k in a trace tr0 \u2208\ntraces(NET \u2032) is n. When n is understood we may omit the\nsubscript and simply write \u03c1.\nLet T be a set of values that should not appear in any\ntrace of NET \u2032. T will usually contain the session-key k, but\nmay also include long-term secrets that we disallow the in-\ntruder from compromising.We are now in a position to give\na list of conditions that, if satis\ufb01ed, guarantee that no mem-\nber of T can be discovered by the intruder in NET \u2032. Follow-\ning the statement of the central theorem, we discuss each\ncondition in turn.\nTheorem 3 Let T be a set of messages and let IIK be\nthe intruder\u2019s initial knowledge. If there exists a family\nof rank functions, \u03c1, such that each member \u03c1n satis\ufb01es:\nC1 \u03c1n(IIK) = 0\nC2 \u2200 S \u2286 M,m \u2208 M.S \u0002 m \u2227 \u03c1n(S) = t \u21d2 \u03c1n(m) \u2264 t\nC3 \u2200m \u2208 T.\u03c1n(m) = \u221e\nC4 \u2200 u \u2208 U \\ {E}, tr \u2208 traces(NET \u2032).\ntr \u0003 {| trans.u, rec.u, signal.u |} holds \u03c1n\nC5 \u2200m \u2208 TS.\u03c1(leak.m) < \u221e\nthen NET \u2032 sat secret T\nProof. See Appendix B.\nC1 \u2014 Condition C1 essentially amounts to an assump-\ntion on the initial information available to the intruder. The\nrequirement that \u03c1n(IIK) = 0 states that, at the start of the\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nprotocol, the intruder does not know any secret or compro-\nmisable keys.\nC2 \u2014 The second condition:\n\u2200 S \u2286 M,m \u2208 M.S \u0002 m \u2227 \u03c1n(S) = t \u21d2 \u03c1n(m) \u2264 t\nis a requirement on the generates relation, \u0002. It says that\nif the intruder knows a set of messages S with rank t, any\nmessage m generated from S under \u0002 should have a rank no\ngreater than t. Stated another way: at any time, the intruder\ncan only generate messages which are safe for him to know\nat that time. Since, from C1, we have that the intruder be-\ngins by only knowing messages of rank 0, C2 allows us to\nconclude that the intruder cannot send a message of rank\u221e\nunless he has previously received (from some other princi-\npal or via leak) a message with in\ufb01nite rank.\nC3 \u2014 This is a statement about the contents of the set\nT. Since T should contain the messages (or, more correctly,\nthe events) that we wish to keep secret we must ensure that\neach of these messages has a rank of \u221e. C3 allows us to\nconclude that this is indeed the case.\nC5 \u2014 The \ufb01nal condition is a straightforward obligation\non the set of leakable secrets, namely, that they are assigned\na \ufb01nite rank.\nC4 \u2014 This condition is essentially an obligation on the\nusers of the system: that no honest principal can send a mes-\nsage of in\ufb01nite rank unless it has previously received a mes-\nsage of in\ufb01nite rank. The speci\ufb01cation holds \u03c1n is de\ufb01ned\nas follows:\nDe\ufb01nition 10\nholds \u03c1n \u21d4\n\u03c1n(tr \u21d3 rec) \n= \u221e\u21d2 \u03c1n(tr \u21d3 trans) \n= \u221e\nBy showing that C4 holds we rule out the possibility that\nany of the honest principals introduces a message of in\ufb01-\nnite rank, and if the network admits such a message it must\ntherefore have been introduced by the intruder. (Since C1,\nC2 and C5 tell us that the intruder cannot introduce such a\nmessage either, the combination of C1, C2, C4 and C5 tells\nus that no in\ufb01nite rank message can pass through the sys-\ntem. Since all messages in T have rank\u221e (C3) we can con-\nclude that all elements of T remain secret.) Curiously, the\nstronger, and more obvious, de\ufb01nition of \u2018holding the rank\u2019\n\u2014 where the rank of emitted messages is not greater than\nthe rank of received messages \u2014 is unnecessary (see the\nproof of Theorem 3 in Appendix B).\nNote that C4 is a condition upon the traces of events\ncommunicated by each principal and it is worthwhile to\nconsider how the traces of a process USERa in NET are re-\nlated to the traces involving a in NET \u2032. Consider an arbi-\ntrary trace tr0 \u2208 traces(NET \u2032) restricted to the events in\nwhich a principal A takes part:\ntrA = tr0 \u0003 {| trans.A, rec.A, signal.A |}\nNET \u2032, recall, is the parallel composition:\nNET |[ {| signal, leak |} ]|RES\nwhich blocks the performance of the event leak.lk un-\ntil signal.a.b.k has been communicated. leak events orig-\ninate at the ENEMY and not with user processes, so trA \u2208\ntraces(USERA). Put another way, any behaviour possible by\nA in NET \u2032 will be exhibited by USERA in NET. When we\ncome to prove C4 for a given rank function it will be con-\nvenient, and suf\ufb01cient, to do so by inspection of the pro-\ncesses USERa together with the assumption that, whenever\nleak.Sig(A) occurs then signal.a.b.K must have previously\nbeen communicated.\n3.3. Proving Boyd\u2019s protocol correct\nWe now conclude our running example by showing how\nthe above strategy can be used to prove that Boyd\u2019s protocol\nprovides partial forward secrecy on an unbounded network:\n1. a \u2192 b : pk \u00b7 na \u00b7 {pk \u00b7 b}Sig(a)\n2. b \u2192 a : {k}pk \u00b7 {h(k) \u00b7 a \u00b7 na}Sig(b)\nThe forward secrecy goal that we wish to establish cor-\nresponds to the following predicate (for some session-key\nK \u2208 KBA where A and B are honest):\nNET sat fs(K, Sig(A))\nWe consider the CSP model of Figure 3 and look at a partic-\nular, but arbitrarily chosen, run in which A acts as initiator\nand attempts to establish a session-key with B. Similarly,\nB acts as responder and attempts to establish the session-\nkey K with A. We tailor the ENEMY process by setting\nTS = {Sig(A)}. Our goal is to construct a family of rank\nfunctions that satisfy conditions C1\u2013C5 by characterising\nthe times at which messages become known to the intruder.\nWe de\ufb01ne T = {K} to be the set of values that must re-\nmain secret. We assume that Sig(A) becomes available to\nthe intruder via the channel leak:\nAssumption 1 Sig(A) is unknown to the intruder until it\nappears on channel leak.\nSome care is needed in stating this assumption since it pre-\nsumes the intruder cannot manipulate earlier protocol mes-\nsages in a way that will cause Sig(A) to be revealed. In this\ncase the assumption can be justi\ufb01ed by applying Guttman\u2019s\nconcept of immediate safety [11]: Sig(A) is immediately\nsafe since it is not known initially to the intruder and is not\nsent as a component of any message. Under the perfect en-\ncryption assumption, Sig(A) remains secret until it appears\non channel leak.\nA suitable rank function is given below. We omit a for-\nmal proof but instead present a discussion of the rank func-\ntion and an informal argument as to why C1\u2013C5 hold. In\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nparticular, we show how the restriction of NET to NET \u2032 is\nfundamental to the proof strategy.\nWe begin by de\ufb01ning the rank of usernames and nonces,\nwhich in both cases we set to be 0:\nUSERNAMES \u03c1n(u) = 0\nNONCES \u03c1n(na) = 0\nWe assume that the intruder has all usernames in his ini-\ntial knowledge. Since the protocol uses public nonces we\nmust assign them a \ufb01nite rank. However, it turns out that\nthe protocol is still secure if we assume, as we do here, that\nthey are known to the intruder initially (by assigning a rank\nof 0). The idea of assigning a lower rank to a message than\nis strictly necessary is a useful trick that can help to reduce\nthe complexity of a rank function. It is sound since it as-\nsumes the worst-case: if we can prove security in this con-\ntext then the security goal will still hold if we later decide\nto assign the message a higher rank.\nHASHES \u03c1n(h(m)) = \u03c1n(m)\nPAIRS \u03c1n(m1 \u00b7 m2) = max(\u03c1n(m1), \u03c1n(m2))\nWe de\ufb01ne the rank of a hashed message as equal to the\nrank of the unhashed message, since the intruder knows\nthe hash function h and can deduce h(m) as soon as he\nlearns m. The rank of a concatenation m1 \u00b7 m2 is the great-\nest rank of its components.\nEPH-KEYS \u03c1n(pk) = 0\n\u03c1n(pk\u22121) =\n{\n\u221e if pk \u2208 PKAB\n0 otherwise\nSIG-KEYS \u03c1n(Sig(u)) =\n\uf8f1\uf8f4\uf8f2\n\uf8f4\uf8f3\n\u221e if u = B\nn if u = A\n0 otherwise\n\u03c1n(Sig\u22121(u)) = 0\nSESS-KEYS \u03c1n(k) =\n{\n\u221e if k = K\n0 otherwise\nWhen assigning a rank to keys, we give a rank of 0 un-\nless it is absolutely necessary to do otherwise. The inten-\ntion is to state the secrecy of just those values required to\nmeet the security goal. So we assume, for example, that\nall session-keys apart from K are known initially to the in-\ntruder. Note that the rank of signing-keys respects the fact\nthat Sig(B) is never leaked and Sig(A) is leaked at time n.\nWe assume that all other signing-keys are known to the in-\ntruder from the start.\nENCRYPTS \u03c1n({k}pk) =\n\uf8f1\uf8f4\uf8f2\n\uf8f4\uf8f3\n\u221e if pk \/\u2208 PKAB\n\u2227 k = K\n0 otherwise\nThe rank of encryptions follows from our assumption\nabout the secrecy of session-keys. The intruder should never\nlearn K and should never learn an encryption of K with any\nkey other than those used by A to initiate to B.\nThe most subtle aspect of this rank function is its treat-\nment of signatures. Sig(B) is never leaked and, therefore,\nthe only messages signed using Sig(B) will be those match-\ning the pattern of the protocol messages. For each principal\nu these messages are captured by S(u):\nS(u) = {pk \u00b7 v | pk \u2208 PKu, v \u2208 U}\n\u222a {h(k) \u00b7 v \u00b7 na | k \u2208 Ku, v \u2208 U, na \u2208 N}\nwhere PKu =\n\u22c3\nv\u2208U PKuv. We de\ufb01ne the rank of signa-\ntures as follows:\nSIGNATURES \u03c1n({m}Sig(B)) =\n{\n0 if m \u2208 S(B)\n\u221e otherwise\n\u03c1n({m}Sig(A)) =\n\uf8f1\uf8f4\uf8f2\n\uf8f4\uf8f3\n0 if m \u2208 S(A)\nmax(\u03c1n(m), n)\notherwise\n\u03c1n({m}Sig(u)) = \u03c1n(m) (u \/\u2208 {A,B})\nThe interesting case involves the key Sig(A). Before time\nn the only messages signed with Sig(A) are those that the\nprotocol designer intended: the messages in the set S(A).\nWe can safely assume that such messages are available to\nthe intruder initially, and so assign them a rank of 0. After\nn, however, the intruder can sign any message m he knows\nusing Sig(A). In this case, the rank of the resultant message\nis the greater of the two ranks \u03c1n(m) and n.\nSince the intruder cannot engage in events on the signal\nchannel, we can safely de\ufb01ne \u03c1n(signal.a.b.k) = 0.\nInformally, the set IIK can be constructed to conform to\ncondition C1: that all messages in IIK have a rank of 0. C3:\nthat every message in T has a rank of \u221e \u2014 trivially holds\nsince we have de\ufb01ned T to be the singleton set {K} and\n\u03c1n(K) = \u221e.\nC2 may be proven by considering each of the clauses\nde\ufb01ning \u0002 in turn. For example, if we consider the rule\nfor hashing then we need to prove that \u03c1n(m) = t \u21d2\n\u03c1n(h(m)) \u2264 t. From the de\ufb01nition of the rank of hashes\nwe see that \u03c1n(h(m)) = \u03c1n(m) so the implication holds.\nC4 must be proven for all USERa processes. If we pro-\nceed by a case analysis we \ufb01nd we must show that each of\nthe following processes hold the rank:\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \n1. UserI(a, b, pk, na) for a \n= A\n2. UserI(A, b, pk, na) for b \n= B\n3. UserI(A,B, pk, na)\n4. UserR(b, a, k) for b \n= B\n5. UserR(B, a, k) for a \n= A\n6. UserR(B,A, k)\nThe \ufb01rst \ufb01ve cases are straightforward to prove. The \ufb01-\nnal case, UserR(B,A, k), is more interesting:\nUserR(B,A, k) =\nrec.B.A?(pk \u00b7 na \u00b7 {pk \u00b7 B}Sig(A))\n\u2192 signal.B.A.k\n\u2192 trans.B.A.({k}pk \u00b7 {h(k) \u00b7 A \u00b7 na}Sig(A))\n\u2192 Stop\nAccording to the de\ufb01nition of C4 we are required to\nshow that, if \u03c1(pk \u00b7 na \u00b7 {pk \u00b7 b}Sig(A)) \n= \u221e then \u03c1({k}pk \u00b7\n{h(k) \u00b7 A \u00b7 na}Sig(A)) \n= \u221e.\nFrom the rank function we can immediately deduce that\n\u03c1({h(k) \u00b7 A \u00b7 na}Sig(A)) = 0. By the rank of concatena-\ntion it remains to show that \u03c1({k}pk) \n= \u221e. By assump-\ntion \u03c1(pk \u00b7 na \u00b7 {pk \u00b7 B}Sig(A)) \n= \u221e. An examination of the\nrank function shows that there are two cases to consider, ei-\nther (i) \u03c1({pk \u00b7 B}Sig(A)) = 0 or (ii) \u03c1({pk \u00b7 B}Sig(A)) = n.\n(i) If \u03c1({pk \u00b7B}Sig(A)) = 0, then we can deduce that pk \u2208\nPKAB which results in \u03c1({k}pk) = 0.\n(ii) If \u03c1({pk \u00b7 B}Sig(A)) = n the rank function tells us\nthat pk \/\u2208 PKAB and that Sig(A) has been compromised. As-\nsumption 1 then enables us to deduce that leak.Sig(A) has\noccurred. However, since:\nNET \u2032 sat {signal.A.B.K} St precedes {leak.Sig(A)}\nK must already have been established as a session-key and\ntherefore k \n= K in {k}pk. Finally, the rank function tells us\nthat k \n= K \u21d2 \u03c1({k}pk) = 0, and so the condition holds.\nFinally, it is clear that C5 holds, since only messages\nfrom TS can appear on the channel leak, TS = {Sig(A)}\nand \u03c1(Sig(A)) = n.\nSince C1\u2013C5 hold of \u03c1 we can conclude that NET \u2032 guar-\nantees the secrecy of K and, by implication, we can con-\nclude that the forward secrecy goal:\nNET sat fs(K, Sig(A))\nis also met. Establishing this result only allows us to con-\nclude partial forward secrecy with respect to Sig(A). To es-\ntablish full forward secrecy we would also need to consider\nthe compromise of B\u2019s long-term key. By taking the pes-\nsimistic view \u2014 that both keys become available as soon\nas the \ufb01rst is compromised \u2014 such a proof is straightfor-\nward to construct.\n4. A further example: the Cliques protocol\nThe Cliques protocols [1] provide key distribution ser-\nvices for dynamic groups. We consider a particular proto-\ncol from the Cliques suite, A-GDH.2, which is used to es-\ntablish a Dif\ufb01e-Hellman key between a group of principals\nof arbitrary size, such that each principal contributes to the\nkey. The protocol consists of two stages. In the \ufb01rst (up\ufb02ow)\nstage the group is traversed by a message that collects the\ncontributionsmade by each principal. The \ufb01nal groupmem-\nber to receive this message is designated as the controller,\nwho carries out the second stage by broadcasting the col-\nlected keying material to each member of the group.\nFor a group of size s, each principal ui (i \u2208 [1, s])\nchooses an ephemeral Dif\ufb01e-Hellman value xi and main-\ntains a long-term key K\u22121is whose inverse, Kis, is known to\nthe controller us. A suitable prime-order subgroup of Z\u2217p\nand generator g of G have been (publicly) agreed upon:\nUp\ufb02ow: round i | i \u2208 [1, s\u2212 1]\nui \u2212\u2192 ui+1 : {g\nx1...xi\nxk | k \u2208 [1, i], gx1...xi}\nBroadcast: round s\nus \u2212\u2192 ui|i\u2208[1,s\u22121] : g\nx1...xs\nxi\n.Kis\nUpon receipt of the above, each ui computes\ng(\nx1...xs\nxi\n.Kis).K\u22121is .xi = gx1...xs = K\nSince the long-term keys cancel, the commutativity of\nexponentiation means that K is shared between all of the\nprincipals. We can use a temporal rank function to reason\nabout the forward secrecy of this protocol.\nWe take an abstract view of the Dif\ufb01e-Hellman operation\nin which every value is an exponentiation of the generator\ng by some product of random numbers and long-term keys.\nWe write DH(x, y) to represent the exponentiation xy mod p\nand write DH(g, x \u00b7 y) as a shorthand for DH(DH(g, x), y).\nWe make use of an ingredients function \u03b9 that returns the\nmultiset of components that make up a message. For exam-\nple, \u03b9(DH(g, x \u00b7 x \u00b7 z)) = [[x, x, z]]. We also extend the model\nof the intruder to enable him to perform exponentiation and\nto compute the multiplicative inverse of a value:\nDH\nS \u0002 d S \u0002 d0\nS \u0002 DH(d, d0)\nINVERSE\nS \u0002 d\nS \u0002 d\u22121\nSince computation takes place in an abelian group we\nmust also address the algebraic properties of such computa-\ntion. In particular, we need to take into account the commu-\ntativity of exponentiation (since gxy = gyx) and the cancel-\nlation of multiplicative inverses (since gxyx\u22121 = gy). Previ-\nous work has captured the equivalence of such messages us-\ning a term rewriting system [5]. Here it will suf\ufb01ce to intro-\nduce three algebraic equivalences onto the message space:\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nDH(x, y \u00b7 z) = DH(x, z \u00b7 y)\nDH(x, y \u00b7 1) = DH(x, y)\nDH(x,X \u00b7 w \u00b7 Y \u00b7 w\u22121 \u00b7 Z) = DH(x,X \u00b7 Y \u00b7 Z)\n(where any of X, Y and Z may be the identity element 1).\nThese equations result in a further proof obligation on the\nrank function; namely, that whenever two Dif\ufb01e-Hellman\nmessages are equivalent (according to the above equations)\nwe assign them the same rank.\nWe consider (partial) forward secrecy from the point of\nview of a principal u1 = A who contributes x1 = xA to com-\npute the keyK in a run of the protocol in which us = C is the\ngroup controller and K1s = KAC is the long-term key. As be-\nfore, the protocol is modelled by a CSP process NET, and\nthe security condition is:\nNET sat fs(K,KAC)\nwhere the process representing C performs the signal event\nfor A on receipt of the up\ufb02owmessage, and leak.KAC signals\nthat KAC has been compromised. In this instance we adapt\nour intruder process ENEMY so that no key other than KAC\ncan be leaked.\nAs before, we consider the restricted process NET \u2032\nwhich satis\ufb01es the condition that, in any trace of NET \u2032,\nan occurrence of leak.KAC is preceded by signal.A.C.K.\nWe de\ufb01ne n = \u03c4(KAC, tr) as the time at which the key\nKAC is compromised. Our goal is to construct a fam-\nily of rank functions, parameterised by n, that charac-\nterises the messages that can occur before, at, and after\ntime n.\nWe assign a rank of n to the compromised long-term key\nKAC:\n\u03c1n(k) =\n\uf8f1\uf8f4\uf8f2\n\uf8f4\uf8f3\nn if k = KAC\n\u221e if k = KuC \u2227 u \n= E\n0 otherwise\nAssigning a rank to Dif\ufb01e-Hellman values is non-trivial, but\nwe can make use of the fact that the group controller, C,\nonly ever transmits messages to which he has added both a\nlong-term secret and an ephemeral secret. Other principals\nwill only transmit messages to which they have added an\nephemeral secret. Let cs(d) be the number of C\u2019s ephemeral\nsecrets and lt(d) the number of long-term secrets in a Dif\ufb01e-\nHellman value d. Formally, if LK is the set of all long-\nterm secrets shared by honest principals and SC is the set\nof ephemeral secrets known to the controller C, de\ufb01ne:\ncs(d) = #(SC \u0004 \u03b9(d))\nlt(d) = #(LK \u0004 \u03b9(d))\n(where U \u0004 R is the relation R restricted to domain U). Us-\ning this, we de\ufb01ne the rank of a Dif\ufb01e-Hellman value d as:\n\u03c1(d) =\n{\n0 if (cs(d) + lt(d)) mod 2 = 0\n\u221e otherwise\nUnfortunately, we \ufb01nd that this function does not satisfy\ncondition C2 of Theorem 3: the intruder is able to pro-\nduce a message of rank > n from messages with rank\n\u2264 n. Consider the case where the intruder uses the mes-\nsage DH(g, xA) (rank 0) and the key KAC (rank n) to pro-\nduce the message DH(g, xA \u00b7 KAC). Since DH(g, xA \u00b7 KAC)\ncontains one long-term secret and none of the controller\u2019s\nephemeral secrets it receives a rank of\u221e and so C2 fails.\nGenerally speaking, we cannot conclude protocol inse-\ncurity from the failure of a rank function since a different\nrank function may exist which is suf\ufb01cient to prove proto-\ncol correctness. In this case, however, the failure leads us to\ndeduce the following attack (described for a group of size\n3):\n1. A \u2192 B : {g, gxA}\n2. B \u2192 C : {gxA, gxB , gxAxB}\n3a. C \u2192 E(A) : gxBxCKAC\n3a\u2032 E(C) \u2192 A : gxB\n3b. C \u2192 B : gxAxCKBC\nIn the attack, the intruder observes the \ufb01rst two proto-\ncol messages (noting the value gxAxB in message 2), inter-\ncepts A\u2019s component of the broadcast message from C (3a)\nand replaces it with gxB(3a\u2032). On receipt of the broadcast,\nA computes the key gxBK\n\u22121\nAC xA\n. At a later stage KAC becomes\navailable to the intruder who then deduces K\u22121AC and uses\nthe value gxAxB (remembered from earlier) to compute the\nkey gxAxBK\n\u22121\nAC\n. The intruder now shares a key with A, mark-\ning the failure of forward secrecy.\nThis attack is a simpler version of one proposed by\nPereira and Quisquater [20] who demonstrated attacks on\neach of the main security goals of the Cliques protocols.\nThe same authors have more recently shown that any pro-\ntocols built using the rationale of Cliques are irreparably\n\ufb02awed, at least in situations where the group contains four\nor more principals [21].\n5. Discussion\nAs promised, we now discuss why the standard (two-\nvalued) rank function approach is incapable of verifying\nforward secrecy properties.\nIn the original rank function approach [23] positive ranks\nwere used to denote public messages and non-positive ranks\nwere assigned to secret messages. It was soon discovered\n[13] that this is equivalent to using just two ranks, pub for\npublic and sec for secret messages2. This binary view of se-\ncrecy allows us to make all-or-nothing assertions about the\n2 Previous work has tended to use the ranks 0 and 1 to denote secret and\npublic messages. For the temporal ranks described above we use 0 for\na different purpose, namely, to denote messages available to the in-\ntruder at the start of a protocol. We use the emotive ranks pub and\nsec in this discussion to avoid confusion.\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nsecrecy of messages: a message m is either completely se-\ncret (\u03c1(m) = sec) or completely public (\u03c1(m) = pub).\nIn fact, it turns out that setting \u03c1(m) = pub is equivalent\nto saying that it should be safe for the intruder to know m\nat the start of the protocol. This can be stated another way.\nConsider some protocol P, and a (two-valued) rank func-\ntion \u03c1 that is suf\ufb01cient to prove that P meets some secrecy\ngoal with respect to the intruder\u2019s initial knowledge: IIK0.\nIf there exists a message m \/\u2208 IIK0 with \u03c1(m) = pub then \u03c1\nis also suf\ufb01cient to show that P meets the same secrecy goal\nwith respect to the initial knowledge IIK1 = IIK0 \u222a {m}.\nRecall that, for a security goal expressed as a trace speci-\n\ufb01cation, the existence of a rank function allows us to con-\nclude that the protocol meets the security goal.\nTheorem 4 Let \u03c1 be a rank function with respect to the in-\ntruder\u2019s initial knowledge IIK0. If there exists some m \/\u2208\nIIK0 satisfying \u03c1(m) = pub then \u03c1 is a rank function with\nrespect to IIK1 = IIK0 \u222a {m}.\nProof. The two-valued central rank theorem [23] gives four\nhealthiness conditions that a rank function must satisfy. It\nis straightforward to show that, for each of these, if \u03c1 sat-\nis\ufb01es the condition w.r.t IIK0 then \u03c1 must also satisfy the\ncondition w.r.t IIK1. \u0002\nThis goes against intuition. A message m may become\navailable to the intruder at some point in a protocol run,\nbut this does certainly not mean that the message should\nbe known to the intruder initially. In fact, Heather [12] has\ngiven an example of a (contrived) protocol that contains a\ntemporary secret \u2014 a value that must remain secret for a\nprotocol to reach its secrecy goal but may then be safely\nleaked \u2014 and has shown that such protocols, even if cor-\nrect, are unveri\ufb01able using two-valued rank functions. Ar-\nguing pragmatically, this incompleteness is only of theoret-\nical interest unless it can be shown to hamper our ability\nto reason about real (i.e., uncontrived) protocols. However,\nsince compromised keys are temporary secrets, we are faced\nwith the conclusion that forward secrecy properties are un-\nveri\ufb01able using the standard approach.\nWe can illustrate this with an example. Consider an in-\nstance of the Boyd protocol, modi\ufb01ed so that A makes\nSig(A) public after the key exchange has taken place:\n1. A \u2192 B : PK \u00b7 NA \u00b7 {PK \u00b7 B}Sig(A)\n2. B \u2192 A : {K}PK \u00b7 {h(K) \u00b7 A \u00b7 NA}Sig(B)\n3. A \u2192 B : Sig(A)\nThe results of the previous section allow us to conclude\nthat a run of the protocol should provide forward secrecy;\nthat, even after Sig(A) is leaked, the session-key K should\nremain secret. To see why a two-valued rank function can-\nnot be used to prove this property we can attempt to cre-\nate one. We assume that the usernames of principals are\npublic; in particular, \u03c1(A) = pub. Since Sig(A) is sent in\nthe clear we are forced to set \u03c1(Sig(A)) = pub. For any\nephemeral key-pair (PK\u2032, SK\u2032) invented by the intruder we\nhave \u03c1(PK\u2032) = \u03c1(SK\u2032) = pub, and since the intruder can\nuse these facts to construct the message {PK\u2032 \u00b7 B}Sig(A) we\nare compelled to set \u03c1({PK\u2032 \u00b7 B}Sig(A)) = pub. Now, if\nthe intruder, masquerading as A, sends this message to B,\nB will respond with {K}PK\u2032 and the intruder can use SK\u2032\nto deduce the session-key K. We are therefore forced to set\n\u03c1(K) = pub, whereas our hope was for K to remain secret.\nSome thought leads us to conclude that this attack will not\nwork since Sig(A) is not made public until after K has been\naccepted by A. However, Theorem 4 tells us that rank func-\ntions cannot distinguish a message that is made public at the\nend of a protocol from a message that is public at the start\nof the protocol. Therefore, using a two-valued rank func-\ntion means that setting \u03c1(Sig(A)) = pub is the same as say-\ning that Sig(A) \u2208 IIK. If Sig(A) is known to the intruder at\nthe start then the protocol clearly cannot guarantee the se-\ncrecy of K.\nA rank function is an abstraction technique that allows\nus to prove trace speci\ufb01cations of CSP processes without\nrequiring us to consider the traces directly. A trace records\none possible history of a process. In the above example, if\nthe event trans.A.B.Sig(A) appears in a trace, it will always\nbe preceded by the event rec.A.B.{K}PK\u2032 \u00b7 . . . , represent-\ning the fact that A accepts the session-key before Sig(A) is\nleaked. Thus, a trace does not simply convey information\nabout which messages appear, but also when they appear. A\ntwo-valued rank function abstracts away all of the temporal\ninformation present in the trace and just tells us what mes-\nsages can occur. However, for protocols containing tempo-\nrary secrets, this temporal information is vital if we are to\nprove their correctness. In such cases two-valued rank func-\ntions abstract away too much.\nTemporal ranks overcome this problem by lifting state\ninformation from the trace into the rank function. A tempo-\nral rank function for the example above would say that the\npassword is leaked at some time n and set \u03c1(Sig(A)) = n.\nThe ranks of other messages pivot around n in the sense\nthat a message made public before n is assigned some rank\n0 \u2264 r < n and a message available at or after n is assigned a\nrank in the range n \u2264 r \u2264 \u221e. Crucially, the offending mes-\nsage {PK\u2032 \u00b7 B}Sig(A) would be assigned a rank of n and the\nmessage {K}PK would be assigned a rank less than n, rep-\nresenting the fact that A\u2032s reception of the session-key pre-\ncedes the compromise of the password. At time n, A is there-\nfore unwilling to accept the intruder\u2019s faked message and so\nthe forward secrecy property holds.\n6. Conclusion\nIn this paper we have shown how forward secrecy prop-\nerties of crypto-protocols can be expressed and reasoned\nabout using rank functions. We have introduced the concept\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \nof a temporal rank function that not only allows us to rea-\nson about what messages an attacker can deduce, but when\nin the protocol he can deduce them. We have applied the ap-\nproach to two examples, establishing a proof of correctness\nin one case and rediscovering an attack in the other. Both\nof these examples considered a protocol running on an un-\nbounded network that allows principals to engage in arbi-\ntrarily many protocol runs concurrently. We also described\nthe motivation for using temporal ranks by demonstrating\nthat some protocols may be unveri\ufb01able when using tech-\nniques that classify values as simply public or secret.\nThe present work can be seen as contributing to a grow-\ning body of research that aims to move beyond the familiar\nrealms of perfect encryption, authentication, and secrecy, by\nrelaxing the restrictions on the intruder and considering the\nwider class of security properties that become relevant as a\nresult.\nIt is interesting to note that all of the rank functions given\nin this paper are three valued: 0, n and \u221e and, in fact, it\nwould have been suf\ufb01cient to \ufb01x n at some arbitrary \ufb01nite,\nnon-zero, value. In general, a temporal rank function will be\nthree-valued if all compromised values are assumed to be\nleaked at the same time. In the worst case, a temporal rank\nfunction with k separate leak points will have k + 2 distinct\nranks. It is not clear whether, in practice, more than three\nranks will ever be required. If three ranks are indeed suf-\n\ufb01cient, then the theory presented above should almost cer-\ntainly be re\ufb01ned to re\ufb02ect this fact. In seeking to present\na general theory we have had to introduce some concepts\n(such as the idea of a family of functions) which would be\nredundant in a three-rank theory.\nA temporal rank function can be viewed as establish-\ning a hierarchy of secrecy, where a message m1 is less se-\ncret than a message m2 if \u03c1(m1) < \u03c1(m2). One message\nis therefore more secret than another if it must remain se-\ncret for longer. Such a \ufb01ne-grained notion of secrecy has\nproven useful in the present work, and it would be interest-\ning to consider whether temporal ranks can be applied in a\nmore general setting.\nAt a higher level of abstraction, our treatment of forward\nsecrecy allows us to form a rather natural hierarchy of se-\ncrecy speci\ufb01cations, since, in our model, secrecy is implied\nby the presence of partial forward secrecy and, in turn, par-\ntial forward secrecy is implied by the presence of full for-\nward secrecy. This invites us to verify security protocols in a\nsimilarly hierarchical way; either by working upwards from\nsecrecy or downwards from some stronger condition. The\ntop-down approach (starting with, say, full forward secrecy)\nwould tend to involve a more dif\ufb01cult proof but would have\nthe pleasing side-effect of guaranteeing all weaker secrecy\ngoals by implication. Developing useful notions of secrecy\nthat extend this hierarchy, in either direction, seems an in-\nteresting research challenge.\n7. Acknowledgements\nThanks to Colin Boyd for responding to our questions\nand to Gavin Lowe, whose critique of our earlier approach\n[6] prompted the present work. Martin Green, Neil Evans\nand the programme committees of WITS\u201905 and CSFW-18\nmade many valuable comments on various incarnations of\nthis paper.\nReferences\n[1] G. Ateniese, M. Steiner, and G. Tsudik. Authenticated\ngroup key agreement and friends. In Proceedings of the 5th\nACM Conference on Computer and Communication Secu-\nrity. ACM Press, 2000.\n[2] S. M. Bellovin and M. Merritt. Encrypted key exchange:\nPassword-based protocols secure against dictionary attacks.\nIn Proceedings of the IEEE Symposium on Research in Se-\ncurity and Privacy. IEEE Computer Society Press, 1992.\n[3] C. Boyd and A. Mathuria. Protocols for Authentication and\nKey Establishment. Springer-Verlag, 2003.\n[4] E. Bresson, O. Chevassut, and D. Pointcheval. Dynamic\ngroup Dif\ufb01e-Hellman key exchange under standard assump-\ntions (Ext. abstract). In Advances in Cryptology: Proceed-\nings of EUROCRYPT \u201902, volume 2332 of Lecture Notes in\nComputer Science. Springer-Verlag, 2002.\n[5] R. Delicata and S. A. Schneider. A formal model of Dif\ufb01e\u2013\nHellman using CSP and rank functions. Technical Report\nCSD-TR-03-05, Department of Computer Science, Royal\nHolloway, University of London, 2003.\n[6] R. Delicata and S. A. Schneider. Towards the rank function\nveri\ufb01cation of protocols that use temporary secrets. In Pro-\nceedings of the Workshop on Issues in the Theory of Secu-\nrity: WITS \u201904, 2004.\n[7] W. Dif\ufb01e, P. C. van Oorschot, and M. J. Wiener. Authentica-\ntion and authenticated key exchanges. Designs, Codes and\nCryptography, 2(2), 1992.\n[8] D. Dolev and A. C. Yao. On the security of public key pro-\ntocols. IEEE Transactions on Information Theory, IT-29(2),\n1983.\n[9] N. Evans. Investigating security through proof. Ph.D Thesis,\nRoyal Holloway, University of London, 2003.\n[10] C. G. Gu\u00a8nther. An identity-based key-exchange protocol.\nIn Advances in Cryptology: Proceedings of EUROCRYPT\n\u201989, volume 0434 of Lecture Notes in Computer Science.\nSpringer-Verlag, 1989.\n[11] J. D. Guttman. Key compromise, strand spaces, and the au-\nthentication tests. In Proceedings of Mathematical Founda-\ntions of Programming Semantics: MFPS 17, volume 47 of\nElectronic Notes in Theoretical Computer Science. Elsevier,\n2001.\n[12] J. A. Heather. Strand spaces and rank functions: More than\ndistant cousins. In Proceedings of The 15th IEEE Com-\nputer Security Foundations Workshop. IEEE Computer So-\nciety Press, 2002.\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \n[13] J. A. Heather and S. A. Schneider. Towards automatic veri-\n\ufb01cation of security protocols on an unbounded network. In\nProceedings of The 13th IEEE Computer Security Founda-\ntions Workshop. IEEE Computer Society Press, 2000.\n[14] M. Just and S. Vaudenay. Authenticated multi-party key\nagreement. In Advances in Cryptology: Proceedings of ASI-\nACRYPT \u201996, volume 1163 of Lecture Notes in Computer\nScience. Springer-Verlag, 1996.\n[15] H. Krawczyk. SIGMA: The \u2018SIGn and MAc\u2019 approach to\nauthenticated Dif\ufb01e\u2013Hellman and its use in the IKE proto-\ncols. In Advances in Cryptology: Proceedings of CRYPTO\n\u201903, volume 2729 of Lectures Notes in Computer Science.\nSpringer-Verlag, 1996.\n[16] H. Krawczyk. SKEME: A versatile secure key exchange\nmechanism for internet. In Symposium on Network and\nDistributed System Security. IEEE Computer Society Press,\n1996.\n[17] A. J. Menezes, M. Qu, and S. A. Vanstone. Some new key\nagreement protocols providing mutual implicit authentica-\ntion. In Workshop on Selected Areas in Cryptography: SAC\n\u201995, 1995.\n[18] D. Park, C. Boyd, and S.-J. Moon. Forward secrecy and\nits application to future mobile communications security.\nIn Proceedings of Public Key Cryptography: Third Inter-\nnational Workshop on Practice and Theory in Public Key\nCryptosystems: PKC 2000, volume 1751 of Lecture Notes\nin Computer Science. Springer-Verlag, 2000.\n[19] O. Pereira. Modelling and security analysis of authenti-\ncated group key agreement protocols. Ph.D Thesis, Univer-\nsite\u00b4 Catholique de Louvain, 2003.\n[20] O. Pereira and J.-J. Quisquater. Security analysis of the\nCliques protocols suites. In Proceedings of the 14th IEEE\nComputer Security Foundations Workshop. IEEE Computer\nSociety Press, 2001.\n[21] O. Pereira and J.-J. Quisquater. Generic insecurity of\nCliques-type authenticated group key agreement protocols.\nIn Proceedings of the 17th IEEE Computer Security Founda-\ntions Workshop. IEEE Computer Society Press, 2004.\n[22] A. W. Roscoe. The Theory and Practice of Concurrency.\nPrentice Hall, 1997.\n[23] S. A. Schneider. Verifying authentication protocols with\nCSP. In Proceedings of The 10th IEEE Computer Security\nFoundations Workshop. IEEEComputer Society Press, 1997.\n[24] S. A. Schneider. Concurrent and Real-time Systems: The\nCSP Approach. John Wiley and Sons, Ltd, 2000.\n[25] S. A. Schneider. Verifying authentication protocol imple-\nmentations. In Proceedings of the 5th international confer-\nence on Formal Methods for Open Object-Based Distributed\nSystems, 2002.\n[26] M. J. Wiener. Performance comparison of public-key cryp-\ntosystems. Cryptobytes, 4(1), 1998.\nA. CSP\nCSP is a notation for describing concurrent systems in\nterms of processes which perform events. Communication\nis achieved by pre\ufb01xing. The communication a \u2192 P is the\nprocess that performs the event a and then behaves like P.\nEvents may be structured in terms of channels where the\nevent c.v denotes the communication of value v on channel\nc. Compound events can be used to model input and out-\nput where, by convention, input is represented using \u2018?\u2019 and\noutput using \u2018!\u2019: so, for example, c?v : T \u2192 P(v) is the pro-\ncess that inputs on channel c any value v of type T and then\nbehaves as P(v). The concept of choice is modelled with the\n\u0001 operator such that the process P = a \u2192 P \u0001 b \u2192 P is\nprepared to perform either a or b, and the choice is deter-\nmined by the environment. The generalised choice operator\n\u0001i\u2208I Pi allows the environment to choose between a fam-\nily of processes {Pi | i \u2208 I}. Conditional choice can be\nwritten in the form \u2014 if G then P else Q \u2014- where G is a\nboolean guard.\nProcesses may be composed in parallel to perform hand-\nshaking synchronisation. The process P |[X ]|Q forces the\nprocesses P and Q to agree on all events in the set X. When\nan event x \u2208 X is performed by P |[X ]|Q, both processes\nperform the event. Events outside of X may proceed inde-\npendently. The communication set X will often be written\nin the form {| x1, x2 |}; the {| |} syntax denotes the clo-\nsure of events on channels x1 and x2. An interleaving of two\nprocesses P ||| Q allows P and Q to proceed independently\nof one another, without synchronising on any events. If an\nevent is performed that both P and Q are willing to commu-\nnicate, only one process actually performs the event, and\nis chosen non-deterministically. The generalised interleav-\ning operator |||i\u2208I Pi models the interleaving of a family of\nprocesses {Pi | i \u2208 I}. \u03a3 is the set of all events. Two partic-\nularly important processes are Stop and RUNA. Stop is the\nprocess that does nothing at all. RUNA:\nRUNA =?x : A \u2192 RUNA\nis the process which, for a set of events A \u2286 \u03a3, is always\nwilling to communicate any member of A that the environ-\nment desires.\nSeveral semantic models of CSP exist, and in this paper\nwe make use of the simplest: the traces model. The traces\nmodel describes each process P in terms of its observable\nevents, traces(P), the set of all possible sequences of events\nthat P can perform. traces(P) is always non-empty, since\nevery process can perform the empty trace \u3008\u3009, and traces(P)\nis pre\ufb01x closed, meaning that if s \u0001 t is a trace, then so is\ns. For example, traces(a \u2192 b \u2192 Stop) = {\u3008\u3009, \u3008a\u3009, \u3008a, b\u3009}.\nWe write #tr to mean the length of a trace tr. Each CSP\nconstruct has an associated rule for the calculation of traces.\nThe traces of a process de\ufb01ne the possible behaviour of that\nprocess and are suf\ufb01cient for reasoning about safety prop-\nerties of a system.\nIf an event e occurs in a trace tr0 we write e in tr0. Con-\nversely, if e does not occur in tr0 we write \u00ac(e in tr0) .\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \ntr0 \u0003 T is the sequence tr0 restricted to T: the sequence\nwhose members are those of tr0 which are in T. For exam-\nple, if tr0 = \u3008a, b, a, c\u3009 then tr0 \u0003 {a, c} = \u3008a, a, c\u3009. If C\nis a set of channels then tr0 \u21d3 C is the sequence of values\nthat have been communicated along channels in C in tr0.\nIf tr0 = \u3008input.a, output.b, input.c\u3009 then tr0 \u21d3 {output} =\n\u3008b\u3009. When C is understood as the singleton set {c} we may\nomit the braces and write tr0 \u21d3 c in preference to tr0 \u21d3 {c}.\nA modern presentation of the CSP language and its se-\nmantic models can be found in [22, 24].\nB. Proof of Theorem 3\nTo prove that NET \u2032 sat secret T we need to show that:\n\u2200 tr \u2208 traces(NET \u2032).secret T(tr)\nWe prove, for an arbitrary trace tr0, that the existence of a\nrank function \u03c1n is suf\ufb01cient to conclude secret T(tr) when\n\u03c4(k, tr) = n.\nFor a contradiction assume that C1\u2013C5 hold, but also\nthat \u00ac(secret T(tr0)). Then there exists an occurrence in tr0\nof some message t \u2208 T. Since C3 tells us that \u03c1n(t) = \u221e\nfor any t \u2208 T we have that there are some messages with\na rank of \u221e. Let tr1 be the pre\ufb01x of tr0 whose last mes-\nsage is the \ufb01rst message of tr0 with rank\u221e. The sequence\ntr1 is the trace up to the point where the \ufb01rst rank \u221e mes-\nsage occurs.\nThe pre\ufb01x-closure of traces in processes tells us that\ntr1 \u2208 traces(NET \u2032). The last message of tr1 can take one\nof three forms: leak.m, trans.u.v.m, or rec.u.v.m for some\nu, v and m, where \u03c1n(m) = \u221e.\nCase leak.m: from C5 we have that \u03c1n(leak.m) < \u221e,\nforcing a contradiction.\nCase rec.u.v.m: We have that tr1 is a trace of ENEMY\nand, by Theorem 1, that (IIK \u222a (tr \u21d3 {trans, leak})) \u0002 tr \u21d3\nrec and so (IIK\u222a (tr1 \u21d3 {trans, leak})) \u0002 m. But, by de\ufb01ni-\ntion of tr1 we have that \u03c1n(tr1 \u21d3 {trans, leak}) \n= \u221e since\nall messages in tr1 apart from the last have a \ufb01nite rank.\nTherefore C1 and C2 yield that \u03c1n(m) \n= \u221e, forcing a con-\ntradiction.\nCase trans.u.v.m: Let tru = tr1 \u0003 {trans.u, rec.u}. This\nis the portion of tr1 in which USERu participates, so tru \u2208\ntraces(USERu). Hence, by C4 we have that holds \u03c1n(tru).\nExpanding the de\ufb01nition we have that:\n\u03c1n(tru \u21d3 rec) \n= \u221e\u21d2 \u03c1n(tru \u21d3 trans) \n= \u221e\nfrom which it follows that \u03c1n(tru \u21d3 rec) \n= \u221e \u21d2 \u03c1n(m) \n=\n\u221e. However, by de\ufb01nition of tr0 and hence tru we have that\n\u03c1n(m) = \u221e, forcing a contradiction. In either case we \ufb01nd\na contradiction, which establishes the theorem. \u0002\nProceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW\u201905) \n1063-6900\/05 $20.00 \u00a9 2005 IEEE \n"}