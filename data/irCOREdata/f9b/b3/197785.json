{"doi":"10.1007\/s10703-009-0067-z","coreId":"197785","oai":"oai:lra.le.ac.uk:2381\/10057","identifiers":["oai:lra.le.ac.uk:2381\/10057","10.1007\/s10703-009-0067-z"],"title":"From liveness to promptness","authors":["Kupferman, Orna","Piterman, Nir","Vardi, Moshe Y."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2009-01-28","abstract":"Liveness temporal properties state that something \u201cgood\u201d eventually happens, e.g., every request is eventually granted. In Linear Temporal Logic (LTL), there is no a priori bound on the \u201cwait time\u201d for an eventuality to be fulfilled. That is, F \u03b8 asserts that \u03b8 holds eventually, but there is no bound on the time when \u03b8 will hold. This is troubling, as designers tend to interpret an eventuality F \u03b8 as an abstraction of a bounded eventuality F \u2264k \u03b8, for an unknown k, and satisfaction of a liveness property is often not acceptable unless we can bound its wait time. We introduce here PROMPT-LTL, an extension of LTL with the prompt-eventually operator F p . A system S satisfies a PROMPT-LTL formula \u03c6 if there is some bound k on the wait time for all prompt-eventually subformulas of \u03c6 in all computations of S. We study various problems related to PROMPT-LTL, including realizability, model checking, and assume-guarantee model checking, and show that they can be solved by techniques that are quite close to the standard techniques for LTL.Peer-reviewedPost-prin","downloadUrl":"www.springerlink.com.","fullTextIdentifier":"https:\/\/lra.le.ac.uk\/bitstream\/2381\/10057\/2\/full.pdf","pdfHashValue":"75291162ec4d9dcf1745c2e70c49256dd678d4a5","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n        \n            \n                oai:lra.le.ac.uk:2381\/10057<\/identifier><datestamp>\n                2012-01-30T14:11:11Z<\/datestamp><setSpec>\n                com_2381_316<\/setSpec><setSpec>\n                com_2381_9549<\/setSpec><setSpec>\n                col_2381_1116<\/setSpec>\n            <\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:doc=\"http:\/\/www.lyncode.com\/xoai\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n            \nFrom liveness to promptness<\/dc:title><dc:creator>\nKupferman, Orna<\/dc:creator><dc:creator>\nPiterman, Nir<\/dc:creator><dc:creator>\nVardi, Moshe Y.<\/dc:creator><dc:subject>\nTemporal logic<\/dc:subject><dc:subject>\nVerification<\/dc:subject><dc:subject>\nLiveness<\/dc:subject><dc:subject>\nAUTOMATA<\/dc:subject><dc:subject>\nGAMES<\/dc:subject><dc:description>\nLiveness temporal properties state that something \u201cgood\u201d eventually happens, e.g., every request is eventually granted. In Linear Temporal Logic (LTL), there is no a priori bound on the \u201cwait time\u201d for an eventuality to be fulfilled. That is, F \u03b8 asserts that \u03b8 holds eventually, but there is no bound on the time when \u03b8 will hold. This is troubling, as designers tend to interpret an eventuality F \u03b8 as an abstraction of a bounded eventuality F \u2264k \u03b8, for an unknown k, and satisfaction of a liveness property is often not acceptable unless we can bound its wait time. We introduce here PROMPT-LTL, an extension of LTL with the prompt-eventually operator F p . A system S satisfies a PROMPT-LTL formula \u03c6 if there is some bound k on the wait time for all prompt-eventually subformulas of \u03c6 in all computations of S. We study various problems related to PROMPT-LTL, including realizability, model checking, and assume-guarantee model checking, and show that they can be solved by techniques that are quite close to the standard techniques for LTL.<\/dc:description><dc:description>\nPeer-reviewed<\/dc:description><dc:description>\nPost-print<\/dc:description><dc:date>\n2012-01-30T14:09:33Z<\/dc:date><dc:date>\n2012-01-30T14:09:33Z<\/dc:date><dc:date>\n2009-01-28<\/dc:date><dc:type>\nJournal Article<\/dc:type><dc:type>\nArticle<\/dc:type><dc:identifier>\nFormal Methods in System Design, 2009, 34 (2), pp. 83-103.<\/dc:identifier><dc:identifier>\n0925-9856<\/dc:identifier><dc:identifier>\nhttp:\/\/www.springerlink.com\/content\/2112p18440032827\/<\/dc:identifier><dc:identifier>\nhttp:\/\/hdl.handle.net\/2381\/10057<\/dc:identifier><dc:identifier>\n10.1007\/s10703-009-0067-z<\/dc:identifier><dc:identifier>\n1572-8102<\/dc:identifier><dc:language>\nen<\/dc:language><dc:rights>\n\u00a9 Springer Science+Business Media, LLC 2009.  Deposited with reference to the publisher's archiving policy available on the SHERPA\/RoMEO website.  The original publication is available at www.springerlink.com.<\/dc:rights><dc:publisher>\nSpringer<\/dc:publisher>\n<\/oai_dc:dc>\n<\/metadata>\n        <\/record>","journals":[{"title":null,"identifiers":["issn:0925-9856","0925-9856","issn:1572-8102","1572-8102"]}],"language":null,"relations":[],"year":2009,"topics":["Temporal logic","Verification","Liveness","AUTOMATA","GAMES"],"subject":["Journal Article","Article"],"fullText":"From Liveness to Promptness\nOrna Kupferman\nHebrew University\nNir Piterman\nImperial College London\nMoshe Y. Vardi\nRice University\nAbstract\nLiveness temporal properties state that something \u201cgood\u201d eventually happens, e.g.,\nevery request is eventually granted. In Linear Temporal Logic (LTL), there is no a priori\nbound on the \u201cwait time\u201d for an eventuality to be fulfilled. That is, F\u03b8 asserts that \u03b8\nholds eventually, but there is no bound on the time when \u03b8 will hold. This is troubling, as\ndesigners tend to interpret an eventuality F\u03b8 as an abstraction of a bounded eventuality\nF\n\u2264k\u03b8, for an unknown k, and satisfaction of a liveness property is often not acceptable\nunless we can bound its wait time. We introduce here PROMPT-LTL, an extension of LTL\nwith the prompt-eventually operator Fp. A system S satisfies a PROMPT-LTL formula\n\u03d5 if there is some bound k on the wait time for all prompt-eventually subformulas of \u03d5\nin all computations of S. We study various problems related to PROMPT-LTL, including\nrealizability, model checking, and assume-guarantee model checking, and show that they\ncan be solved by techniques that are quite close to the standard techniques for LTL.\n1 Introduction\nSince the introduction of temporal logic into computer science [Pnu77], temporal logic, in\nits many different flavors, has been widely accepted as an appropriate formal framework for\nthe description of on-going behavior of reactive systems [MP92]. Temporal properties are\ntraditionally classified into safety and liveness properties [AS85]. Intuitively, safety proper-\nties assert that nothing bad will ever happen during the execution of the system, and liveness\nproperties assert that something good will happen eventually. Temporal properties are in-\nterpreted with respect to systems that generate infinite computations. In satisfying liveness\nproperties, there is no bound on the \u201cwait time\u201d, namely the time that may elapse until an\neventuality is fulfilled. For example, the LTL formula F\u03b8 is satisfied at time i if \u03b8 holds at\nsome time j \u2265 i, but j \u2212 i is not a priori bounded.\nIn many applications, it is important to bound the wait time. This has given rise to for-\nmalisms in which the eventually operator F is replaced by a bounded-eventually operator\nF\n\u2264k\n. The operator is parameterized by some k \u2265 0, and it bounds the wait time to k\n[BBG+94, EMSS90]. Since we assume that time is discrete, the operator F\u2264k is simply\na syntactic sugar for an expression in which the next operator X is nested. Indeed, F\u2264k\u03b8 is\njust \u03b8 \u2228X(\u03b8 \u2228X(\u03b8\u2228 k\u22124. . . \u2228X\u03b8)).\nA drawback of the above formalism is that the bound k needs to be known in advance,\nwhich is not the case in many applications. For example, it may depend on the system, which\nmay not yet be known, or it may change, if the system changes. In addition, the bound may be\nvery large, causing the state-based description of the specification (e.g., an automaton for it)\nto be very large too. Thus, the common practice is to use liveness properties as an abstraction\nof such safety properties: one writes F\u03b8 instead of F\u2264k\u03b8 for an unknown or a too large k.\n1\nIt is not hard to see that the above abstraction is not sound in the context of infinite-\nstate systems. For example, the infinite-state system that consists of all the computations in\n\u2205\u2217 \u00b7{q}\u00b7\u2205\u03c9 satisfies the LTL property Fq, yet there is no bound k such that the system satisfies\nthe property F\u2264kq. On the other hand, a finite-state system with k states that satisfies Fq also\nsatisfies the specification F\u2264kq. Indeed, a wait time that is greater than the number of states\nindicates that the wait time may also be infinite (by looping in a cycle that ought to be taken\nduring the wait time).\nIs the abstraction always sound in the context of finite-state systems? For some temporal\nlogics, the abstraction is sound, in the sense that if a system S satisfies a liveness property \u03c8,\nthen there is a bound k, which depends on S, such that S also satisfies the formula obtained\nfrom \u03c8 by replacing all occurrences of F in \u03c8 by F\u2264k. For example, it is shown in [EMSS90]\nthat in the case of CTL, taking k to be the number of states in S does it. Thus, if a state s\nsatisfies AF\u03b8, then it also satisfies AF\u2264k\u03b8, for k = |S|, and similarly for EF\u03b8. Intuitively,\nas in the case of the LTL formula Fq discussed above, since \u03b8 is a state formula, a wait\ntime that is greater than k indicates that the wait time may also be infinite, and may also be\nshortened to at most k.\nSo the abstraction of safety properties by liveness properties is sound for CTL in the\ncontext of finite-state systems. Is it sound also for the linear temporal logic LTL? Consider\nthe system S described in Figure 1 below. While S satisfies the LTL formula FGq, there is\nno k \u2265 0 such that S satisfies F\u2264kGq. To see this, note that for each k \u2265 0, the computation\nthat first loops in the first state for k times and only then continues to the second state, satisfies\nthe eventuality Gq with wait time k + 1.\nS :\nq \u00acq q\nFigure 1: S satisfies FGq but does not satisfy F\u2264kGq, for all k \u2265 0.\nIt follows that the abstraction of safety properties by liveness properties is not sound in\nthe linear-time approach (which is more popular with users, cf. [EF06]). This is troubling,\nas designers tend to interpret eventualities as bounded eventualities, and satisfaction of a\nliveness property is often not acceptable unless we can bound its wait time.1\nIn this work we introduce and study an extension of LTL that addresses the above prob-\nlem. In addition to the usual temporal operators of LTL, our logic, PROMPT-LTL, has a new\ntemporal operator that is used for specifying eventualities with a bounded wait time. We term\nthe operator prompt eventually and denote it by Fp. Let us define the semantics of PROMPT-\nLTL formally. For a PROMPT-LTL formula \u03c8 and a bound k \u2265 0, let \u03c8k be the LTL formula\nobtained from \u03c8 by replacing all occurrences of Fp by F\u2264k. Then, a system S satisfies \u03c8 iff\nthere is k \u2265 0 such that S satisfies \u03c8k.\nNote that while the syntax of PROMPT-LTL is very similar to that of LTL, its semantics\nis defined with respect to an entire system, and not with respect to computations. Indeed,\npromptness plays no role in the context of a single computation: if the computation satisfies\nan eventuality, it ought to satisfy it with some bounded wait time, namely the time that has\nelapsed until the eventuality has been satisfied. For example, while each computation pi in\nthe system S from Figure 1 has a bound k\u03c0 \u2265 0 such that Gq is satisfied in pi with wait time\n1Note that the reduction of liveness to safety as described in [BAS02] is performed by squaring the state space\nrather than trying to bound the wait time of eventualities. Thus, it is not related to the discussion in this paper.\n2\nk\u03c0, there is no k \u2265 0 that bounds the wait time of all computations. It follows that, unlike\nlinear temporal logics, we cannot characterize a PROMPT-LTL formula \u03c8 over a set AP of\natomic propositions by a set of computations L\u03c8 \u2286 (2AP )\u03c9 such that a system S satisfies\n\u03c8 iff the language of S is contained in L\u03c8. On the other hand, unlike branching temporal\nlogics, if two systems agree on their languages, then they agree also on the satisfaction of all\nPROMPT-LTL formulas. Thus, PROMPT-LTL intermediates between the linear and branching\napproaches: as in the linear approach, the specification refers to the set of computations of\nthe system rather than its computation tree; as in the branching approach, we cannot consider\nthese computations individually.\nAs further motivation to a prompt eventuality operator, consider the formula G\u00aca \u2228 Fb\n(positive normal form for Fa \u2192 Fb). As demonstrated in Figure 2 below, a system may\nsatisfy G\u00aca \u2228 Fb but have no bound on the wait time to the satisfaction of the eventuality.\nWhen a user checks Ga\u2228Fb, it is quite likely that what he has in mind is G\u00aca\u2228Fpb, but he\nmay not know a bound k such that G\u00aca\u2228X\u2264kb should be checked. In the context of modular\nverification, it is likely that what the user has in mind is \u201dassume Fa; assert Fb\u201d, where both\neventualities should be satisfied promptly. Our semantics distinguishes these three different\nunderstandings of Fa\u2192 Fb.\n{b}S : { }\nFigure 2: S satisfies G\u00aca \u2228Fb but does not satisfy G\u00aca\u2192 Fpb.\nWe study the basic problems of PROMPT-LTL. Consider a PROMPT-LTL formula \u03c8 over\nAP . The setAP may be partitioned to sets I andO of input and output signals. Consider also\na system S. We study the following problems: realizability (is there a strategy f : (2I)\u2217 \u2192\n2O such that all the computations generated by f satisfy \u03c8?), model checking (does S satisfy\n\u03c8?), and assume-guarantee model checking (given an additional PROMPT-LTL formula \u03d5,\nis it the case that for all systems S\u2032, if S\u2016S\u2032 satisfies \u03d5, then S\u2016S\u2032 also satisfies \u03c8?). Since\na system that satisfies a PROMPT-LTL formula may consist of a single regular computation,\nthe satisfiability problem for prompt-LTL can be easily reduced to LTL satisfiability (simply\nreplace all occurrences of Fp by F). For the other problems, similar reductions do not work,\nand we have to develop a new technique in order to solve them. Let us describe our technique\nbriefly.\nConsider a prompt-LTL formula \u03c8 over AP . Let p be an atomic proposition not in AP .\nThink about p as a description of one of two colors, say green (p holds) and red (p does not\nhold). Each computation of the system can be partitioned to blocks such that states of the\nsame block agree on their color. We show that a system S satisfies a PROMPT-LTL formula\n\u03c8 iff there is some bound k \u2265 0 such that we can color each computation pi of S so that the\ninduced blocks are of length k, and whenever a suffix of pi has to satisfy an eventuality, the\neventuality is fulfilled within two blocks. Indeed, the latter condition holds iff all eventualities\nhave wait time at most 2k.\nThe key idea behind our technique is that rather than searching for a bound k for the\nprompt eventualities, which can be quite large, it is enough to make sure that there is a\ncoloring in which all blocks are of a (not necessarily bounded) finite length, and then use\nsome regularity argument in order to conclude that the size of the blocks could actually be\nbounded. Forcing the blocks to be of a finite length can be done by requiring the colors\nto alternate infinitely often. As for regularity, in the case of realizability, regularity follows\n3\nfrom the finite-model property of tree automata. In the case of model checking and assume-\nguarantee model checking, regularity follows from the finiteness of the system.\nThe complexities that follow from our algorithms are encouraging: reasoning about PROMPT-\nLTL is not harder than reasoning about LTL: realizability is 2EXPTIME-complete, and\nmodel checking and assume-guarantee model checking are PSPACE-complete. For LTL,\nmany heuristics have been studied and applied. Some of them are immediately applicable\nfor PROMPT-LTL (c.f., optimal translations of formulas to automata), and some should be\nextended to the prompt setting (e.g., bad-cycle detection algorithms). We also study some\ntheoretical aspects of PROMPT-LTL, such as a bound on the wait time, when exists (may\nbe linear in the system and exponential in the prompt-LTL formula), the ability to translate\nPROMPT-LTL formulas to branching-temporal logics (a translation to the \u00b5-calculus is al-\nways possible, but may involve a significant blow up), and the ability to determine whether a\nPROMPT-LTL formula has an equivalent LTL formula (PSPACE-complete).\nIn [AETP01], Alur et al. study an extension of LTL in which the temporal operators F and\nG may be parameterized by variables that describe lower and upper bound on the wait time\n(or the satisfaction time, for G). Our logic can be viewed as a special case of the logic there,\nin which only eventualities are parameterized, and only with upper bounds. The algorithms\nsuggested by Alur et al. are rather involved. By restricting attention to prompt eventualities\n(the practical interest of the other combinations is less compelling), we get a much simpler\nmodel-checking algorithm, which is also quite similar to the classical LTL model-checking\nalgorithm. We are also able to a solve the realizability and assume-guarantee model checking.\n2 Prompt Linear Temporal Logic\nThe logic PROMPT-LTL extends LTL [Pnu77] by a prompt-eventually operator Fp. The syn-\ntax of PROMPT-LTL formulas (in negation normal form) is given by the grammar below, for a\nset AP of atomic propositions: \u03d5 ::= AP | \u00acAP | \u03d5\u2228\u03d5 | \u03d5\u2227\u03d5 |X\u03d5 | Fp\u03d5 | \u03d5U\u03d5 | \u03d5R\u03d5.\nThe semantics of a PROMPT-LTL formula is defined with respect to an infinite word w =\nw0, w1, . . . over the alphabet 2AP , a position i \u2265 0 in w, and a bound k \u2265 0. We use\n(w, k, i) |= \u03d5 to indicate that \u03d5 holds in location i of w with bound k. The relation |= is\ndefined by induction on the structure of \u03d5 as follows.\n\u2022 For propositions, Boolean connectives, and LTL temporal operators, the definition is\nindependent of k and coincides with the one for LTL.2\n\u2022 (w, i, k) |= Fp\u03d5 iff there exists j such that i \u2264 j \u2264 i+ k and (w, j, k) |= \u03d5.\nWe use F\u03b8 and G\u03b8 to abbreviate trueU\u03b8 and falseR\u03b8, respectively. Note that the negation of\nFp is not expressible in PROMPT-LTL, thus the logic is not closed under negation. Given a\nPROMPT-LTL formula \u03d5, let live(\u03d5) be the LTL formula obtained from \u03d5 by replacing every\nprompt-eventually operator Fp by a standard eventually operator F.\nA (labeled) transition system is S = \u3008AP, S, \u03c1, s0, L\u3009, where AP is a finite set of atomic\npropositions, S is a finite set of states, \u03c1 \u2286 S \u00d7 S is a total transition relation, s0 \u2208 S0 is\nan initial state, and L : S \u2192 2AP maps each state s to the set of propositions that hold in s.\nWhen \u03c1(s, s\u2032), we say that s\u2032 is a successor of s, and s is a predecessor of s\u2032. A computation\nof S is an infinite sequence of states pi = s0, s1, . . . \u2208 S\u03c9 such that for all i \u2265 0, we have\n\u03c1(si, si+1). The computation pi induces the trace L(pi) = L(s0) \u00b7 L(s1) \u00b7 \u00b7 \u00b7.\n2Recall that in LTL we have that pi, i |= \u03b8R\u03c8 iff for all j \u2265 i, if pi, j 6|= \u03c8, then for some k, i \u2264 k < j, we\nhave pi, k |= \u03b8.\n4\nGiven a system S and a PROMPT-LTL formula \u03d5 over AP , we say that S satisfies \u03d5,\ndenotedS |= \u03d5, if there exists some k \u2265 0 such that for all tracesw of S, we have (w, 0, k) |=\n\u03d5. We then say that S satisfies \u03d5 with bound k. Note that when S 6|= \u03d5, then for every k \u2265 0,\nthere exists a trace w such that (w, 0, k) 6|= \u03d5.\nIn [AETP01], Alur et al. study an extension of LTL in which the temporal operators F and\nG are replaced by the operators F\u2264x,F>y,G\u2264x, and G>y , for variables x and y (the same\nvariable may be used in different operators, but, to ensure decidability, the same variable\ncannot participate in both a lower and an upper bound). Given a system S and a formula in\ntheir logic, one can ask whether there is an assignment to the variables for which the system\nsatisfies the formula, with the expected interpretation of the bounded operators.3 Our logic\ncan be viewed as a special case of the logic studied in [AETP01], in which only eventual-\nities are parameterized, and only with upper bounds. The algorithms suggested by Alur et\nal. are rather involved. By giving up the operators F>y,G\u2264x, and G>y , whose usefulness\nis debatable, we get a much simpler model-checking algorithm, which is also similar to the\nclassical LTL model-checking algorithm. We are also able to a solve the realizability and the\nassume-guarantee model checking problems.\nThe Alternating-Color Technique We now describe the key idea of our technique for\nreasoning about PROMPT-LTL formulas. Let p be an atomic proposition not in AP . We\nthink about p as a description of one of two colors, say green (p holds) and red (p does not\nhold). Each computation of the system can be partitioned to blocks such that states of the\nsame block agree on their color. Our technique is based on the idea that bounding the wait\ntime of prompt eventualities can be reduced to forcing all blocks to be of a bounded length,\nand forcing all eventualities to be fulfilled within two blocks, We now make this intuition\nformal.\nConsider a word w = \u03c30, \u03c31, . . . \u2208 (2AP )\u03c9 . Let p be a proposition not in AP . A p-\ncoloring of w is a word w\u2032 = \u03c3\u20320, \u03c3\u20321, . . . \u2208 (2AP\u222a{p})\u03c9 such that w\u2032 agrees with w on the\npropositions in AP ; i.e., for all i \u2265 0, we have \u03c3\u2032i \u2229AP = \u03c3i. We refer to the assignment to\np as the color of location i and say that i is green if p \u2208 \u03c3\u2032i and is red if p 6\u2208 \u03c3\u2032i. We say that\np changes at i if either i = 0 or the colors of i \u2212 1 and i are different (that is, p \u2208 \u03c3\u2032i\u22121 iff\np \/\u2208 \u03c3\u2032i). We then call i a p-change point. A subword \u03c3\u2032i, . . . , \u03c3\u2032i\u2032 is a p-block if all positions in\nthe subword have the same color, and i and i\u2032+1 are p-change points. We then say that i and\ni\u2032 + 1 are adjacent p-change points. For k \u2265 0, we say that w\u2032 is k-spaced, k-bounded, and\nk-tight (with respect to p) if w\u2032 has infinitely many blocks, and all the blocks are of length at\nleast k, at most k, and exactly k, respectively.\nConsider the formula altp = GFp \u2227GF\u00acp. It requires that the proposition p alternates\ninfinitely often. Given a PROMPT-LTL formula \u03d5, let relp(\u03d5) denote the formula obtained\nfrom \u03d5 by (recursively) replacing each subformula of the form Fp\u03c8 by the LTL formula\n(p \u2192 (pU(\u00acpU\u03c8))) \u2227 (\u00acp \u2192 (\u00acpU(pU\u03c8))). Note that the definition is recursive, thus\nrelp(\u03d5) may be exponentially larger than\u03d5. The number of subformulas of relp(\u03d5), however,\nis linear in the number of subformulas of \u03d5, and it is this number that plays a role in the\ncomplexity analysis (equivalently, the size of the DAG-presentation of relp(\u03d5) is linear in\nthe size of the DAG presentation of \u03d5). For a PROMPT-LTL formula \u03d5, we define c(\u03d5) =\naltp \u2227 relp(\u03d5). Thus, c(\u03d5) forces the computation to be partitioned into infinitely many\nblocks, and requires each prompt eventuality to be satisfied in the current or next block or in\nthe position immediately after the next block (within two blocks, for short),\n3The work in [AETP01] studies many more aspects of the logic, like the problem of deciding whether the formula\nis satisfied with all assignments, the problem of finding an optimal assignment, and other decidability issues.\n5\nLemma 2.1 Consider a PROMPT-LTL formula \u03d5, a word w, and a bound k \u2265 0.\n1. If (w, 0, k) |= \u03d5, then for every k-spaced p-coloring w\u2032 of w, we have (w\u2032, 0) |= c(\u03d5).\n2. If w\u2032 is a k-bounded p-coloring of w such that (w\u2032, 0) |= c(\u03d5), then (w, 0, 2k) |= \u03d5.\nProof: Consider the first claim. Since\u03d5 does not use the proposition p, then clearly (w\u2032, 0, k) |=\n\u03d5. Annotate every location in w\u2032 by the subformulas of \u03d5 that hold in this location. Every lo-\ncation annotated by Fp\u03c8 satisfies either pU(\u00acpU\u03c8) or \u00acpU(pU\u03c8). Indeed,w\u2032 is k-spaced,\nand (w, i, k) |= Fp\u03c8 if there exists j \u2264 k such that (w, i+j, k) |= \u03c8. Hence, (w\u2032, 0) |= c(\u03d5).\nConsider the second claim. Let w\u2032 be a k-bounded p-coloring of w such that (w\u2032, 0) |=\nc(\u03d5), Annotate every location in w\u2032 by the subformulas of c(\u03d5) that hold in this location.\nConsider a location i annotated by pU(\u00acpU\u03c8) or \u00acpU(pU\u03c8). Since w\u2032 is k-bounded, it\nfollows that for some j \u2264 i + 2k, the location j is annotated by \u03c8. Therefore, location i\nsatisfies Fp\u03c8. Hence, (w, 0, 2k) |= \u03d5.\nThe alternating-color technique sets the basis to reasoning about a PROMPT-LTL formula\n\u03d5 by reasoning about the LTL formula c(\u03d5). The formula c(\u03d5), however, does not require\nthe blocks in the colored computation to be of a bounded length. Indeed, the conjunct altp\nonly forces the colors to be finite, and it does not prevent, say, a p-coloring in which each\nblock is longer than its predecessor block, and which is not k-bounded, for all k \u2265 0. Thus,\nthe challenge of forcing the p-coloring to be k-bounded for some k remains, and we have to\naddress it in each of the decision procedures described in the following sections.\n3 Realizability\nGiven an LTL formula \u03c8 over the sets I and O of input and output signals, the realizability\nproblem for \u03c8 is to decide whether there is a strategy f : (2I)\u2217 \u2192 2O such that all the\ncomputations generated by f satisfy \u03c8 [PR89]. Formally, a computation w \u2208 (2I\u222aO)\u03c9\nis generated by f if w = (i0 \u222a o0), (i1 \u222a o1), (i2 \u222a o2), . . . and for all j \u2265 0, we have\noj = f(i0 \u00b7 i1 \u00b7 \u00b7 \u00b7 ij). Thus, the interaction is initiated by the environment that generates i0,\nand the first state in the computation is labeled i0 \u222a f(i0). Then, the environment generates\ni1, and the second state in the computation is i1 \u222a f(i0 \u00b7 i1), and so on. It is known that if\nsome strategy that realizes \u03c8 exists, then there also exists a regular strategy (i.e, a strategy\ngenerated by a finite-state transducer) that realizes \u03c8 [BL69]. Formally, a transducer is D =\n\u3008I,O,Q, \u03b7, q0, L\u3009, where I and O are the sets of input and output signals, Q is a finite set of\nstates, \u03b7 : Q \u00d7 2I \u2192 Q is a deterministic transition function, q0 \u2208 Q is an initial state, and\nL : Q \u2192 2O maps each state to a set of output signals. The transducer D generates f in the\nsense that for every \u03c4 \u2208 (2I)\u2217, we have f(\u03c4) = L(\u03b7(\u03c4)), with the usual extension of \u03b7 to\nwords over 2I .\nWe first show that PROMPT-LTL realizability of a formula \u03d5 cannot be simply reduced\nto the realizability of live(\u03d5). Thus, we describe a formula \u03d5 such that live(\u03d5) is realizable,\nbut for every strategy f that realizes \u03d5 and for every candidate bound k \u2265 0, there is a\ncomputationw generated by f such that (w, 0, k) 6|= \u03d5. Let I = {i} andO = {o}. We define\n\u03d5 = o \u2227 (G(i\u2192 o)) \u2227 ((X\u00aco)Ri) \u2227 (FpGo).\nThus, a computation satisfies \u03d5 if o holds in the present and whenever i holds, whenever i\ndoes not hold in some position, then o does not hold in this position or in an earlier one, and\n6\nthe computation prompt-eventually reaches a position from which o holds everywhere. It is\nnot hard to see that live(\u03d5) is realizable. Indeed, the strategy that sets o to true everywhere\nexcept in the first time that i is false realizes live(\u03d5). On the other hand, \u03d5 is not realizable.\nTo see this, note that the position in which the input i is set to false can be delayed arbitrarily\nby the environment, forcing a delay also in the fulfillment of the Go eventuality. Thus, for\nevery candidate bound k \u2265 0, the input sequence in which i is false at the (k+1)-th position\ncannot be extended to a computation that satisfies FpGo with bound k.\nThe good news is that while realizability of \u03d5 cannot be reduced to the realizability of\nlive(\u03d5), it can be reduced to the realizability of c(\u03d5). Intuitively, it follows from the fact that\nin a regular strategy, the fact that all blocks are of a finite length does imply that they are also\nof a bounded length. Formally, we have the following.\nTheorem 3.1 A PROMPT-LTL formula \u03d5 over input signals I and output signals O is real-\nizable iff the LTL formula c(\u03d5) over input signals I and output signals O \u222a {p} is realizable.\nProof: Suppose that \u03d5 is realizable. Then there exists a strategy f : (2I)\u2217 \u2192 2O and a\nbound k \u2265 0 such that all the computations w of f satisfy (w, 0, k) |= \u03d5. We extend f to\na strategy f \u2032 : (2I)\u2217 \u2192 2O\u222a{p} that realizes c(\u03d5). Intuitively, we add to the computations\nof f a p-coloring that is 2k-tight. Formally, for \u03c4 \u2208 (2I)\u2217, we define f \u2032(\u03c4) = f(\u03c4) \u222a {p} if\n|\u03c4 |mod 2k is between 0 and k\u2212 1 and f \u2032(\u03c4) = f(\u03c4) if |\u03c4 | mod 2k is between k and 2k\u2212 1.\nConsider a computation w induced by f \u2032. Note that w is k-tight and it satisfies \u03d5. Therefore,\nby Lemma 2.1, we conclude that w |= c(\u03d5).\nAssume now that c(\u03d5) is realizable. Let f : (2I)\u2217 \u2192 2O\u222a{p} be a regular strategy that\nrealizes it. We show that the strategy f \u2032 : (2I)\u2217 \u2192 2O obtained from f by projecting it on\nO (that is, for all \u03c4 \u2208 (2I)\u2217, we have f \u2032(\u03c4) = f(\u03c4) \u2229 O) realizes \u03d5. Let n be the number\nof states in the transducer that generates f . We show that all the computations generated\nby f \u2032 satisfy \u03d5 with bound 2n + 2. Consider a computation w of f . We claim that w is\n(n+ 1)-bounded. To see this, assume by way of contradiction that w has adjacent p-change\npoints i and j such that j \u2212 i > n + 1. Let D = \u30082I , 2O, Q, \u03b7, q0, L\u3009 be the transducer\nthat generates f , and let q0, q1, q2, . . . be the run of D that corresponds to w. Since D has\nn states, there exists a state q and locations i\u2032 and j\u2032 such that i \u2264 i\u2032 < j\u2032 \u2264 j \u2212 1 and\nqi\u2032 = qj\u2032 . Thus, some state repeats along the p-block that starts at i and ends at j \u2212 1. Then,\nthe run q0, q1, . . . , qi\u2032\u22121, (qi\u2032 , . . . , qj\u2032\u22121)\u03c9 is also a run of D. This run, however, generates a\ncomputation of f that does not satisfy altp, contradicting the fact that f realizes c(\u03d5). So,\nevery computationw of f \u2032 is (n+1)-bounded, and it satisfies c(\u03d5). Therefore, by Lemma 2.1,\nwe conclude that (w, 0, 2n+ 2) |= \u03d5.\nSince LTL realizability is 2EXPTIME-complete and every LTL formula is also a PROMPT-\nLTL formula, we can conclude:\nTheorem 3.2 The problem of prompt realizability is 2EXPTIME-complete in the size of the\nformula.\nAs demonstrated above, the alternating-color technique is very powerful in the case of\nrealizability. Indeed, the challenge of forcing the p-coloring to be k-bounded for some k\nis taken care of by the regularity of the strategy. We now proceed to the model-checking\nproblem, where a reduction to c(\u03d5) is not sufficiently strong.\n7\n4 Model Checking\nIn this section we describe an algorithm for solving the model-checking problem for PROMPT-\nLTL. An alternative algorithm is described for the richer parameterized linear temporal logic\nin [AETP01]. Our algorithm is much simpler, and it deviates from the standard LTL model-\nchecking algorithm only slightly. In addition, as we show in Section 6, the idea behind our\nalgorithm can be applied also in order to solve assume-guarantee model checking, which is\nnot known to be the case with the algorithm in [AETP01]. Our algorithm is based on the\nautomata-theoretic approach to LTL model-checking, and we first need some definitions.\nA nondeterministic Bu\u00a8chi word automaton (NBW for short) is A = \u3008\u03a3, S, \u03b4, s0, \u03b1\u3009,\nwhere \u03a3 is a finite alphabet, S is a finite set of states, \u03b4 : S \u00d7 \u03a3 \u2192 2S is a transition\nfunction, s0 \u2208 S is an initial state, and \u03b1 \u2286 S is a Bu\u00a8chi acceptance condition. A run of\nA on a word w = w0 \u00b7 w1 \u00b7 \u00b7 \u00b7 is an infinite sequence of states s0, s1, . . . such that s0 is the\ninitial state and for all j \u2265 0, we have sj+1 \u2208 \u03b4(sj , wj). For a run r = s0, s1, . . ., let\ninf(r) = {s \u2208 S | s = si for infinitely many i\u2019s} be the set of all states occurring infinitely\noften in the run. A run is accepting if inf(r) \u2229 \u03b1 6= \u2205. That is, the run visits infinitely many\nstates from \u03b1. A word w is accepted by A if there exists some accepting run of A over w.\nThe language of A, is the set of words accepted by A.\nTheorem 4.1 [VW94] For every LTL formula \u03d5 over AP there exists an NBW A\u03d5 over the\nalphabet 2AP such that A\u03d5 accepts exactly all words that satisfy \u03d5. The number of states of\nA\u03d5 is at most exponential in the number of subformulas of \u03d5.\nIn order to check whether a system S satisfies an LTL formula \u03d5, one takes the product\nof S with the NBW A\u00ac\u03d5 and tests the product for non-emptiness [VW86]. Indeed, a path in\nthis product witnesses a computation of S that does not satisfy \u03d5. As discussed in Section 1,\nin the case of PROMPT-LTL we cannot translate formulas to languages. Moreover, we also\ncannot simply apply the alternating-color technique: even if we check the nonemptiness of\nthe product of the system (an augmentation of it in which the proposition p behaves nonde-\nterministically, thus all p-colorings are possible) with the automaton for altp \u2227 \u00acrelp(\u03d5), a\npath in this product only implies that for some bound k \u2265 0, the formula \u03d5 is not satisfied in\nS with bound k. For proving that S does not satisfy \u03d5 we have to prove something stronger,\nnamely, that \u03d5 is not satisfied in S with bound k, for all bounds k \u2265 0. For that, we do\ntake the product of the system with the automaton for altp \u2227 \u00acrelp(\u03d5), but add a twist to the\nnonemptiness check: we search for a path in the product in which each p-block contains at\nleast one state that repeats. Such a state indicates that for all bounds k \u2265 0, the p-block can\nbe pumped to a p-block of length greater than k, implying that \u03d5 cannot be satisfied in S with\nbound k. We now formalize this intuition.\nA colored Bu\u00a8chi graph is a tuple G = \u3008{p}, V, E, v0, L, \u03b1\u3009, where p is a proposition, V\nis a set of vertices, E \u2286 V \u00d7 V is a set of edges, v0 \u2208 V is an initial vertex, L : V \u2192\n2{p} describes the color of each vertex, and \u03b1 \u2286 V is a set of accepting states. A path\npi = v0, v1, v2, . . . of G is pumpable if all its p-blocks have at least one state that repeats.\nFormally, if i and i\u2032 are adjacent p-change points, then there are positions j and j\u2032 such that\ni \u2264 j < j\u2032 < i\u2032 and vj = vj\u2032 . Also, pi is fair if it visits \u03b1 infinitely often. The pumpable\nnonemptiness problem is to decide, given G, whether is has a pumpable fair path.\nLet c(\u03d5) = altp \u2227 \u00acrelp(\u03d5). That is, we relativize the satisfaction of Fp to the new\nproposition p, negate the resulting formula, and require the proposition p to alternate infinitely\noften. Let Ac(\u03d5) = \u30082AP\u222a{p}, Q, \u03b4, q0, \u03b1\u3009 be the NBW for c(\u03d5) per Theorem 4.1. Consider\na system S = \u3008AP, S, \u03c1, s0, L\u3009. We now define the product of S with Ac(\u03d5) by means of\n8\na colored Bu\u00a8chi graph. Note that S does not refer to the proposition p, and we duplicate\nits state space in order to have in the product all possible p-colorings of computations in S.\nThus, the product is P = \u3008{p}, S \u00d7 {{p}, \u2205} \u00d7Q,M, \u3008s0, {p}, q0\u3009, L, S \u00d7 {{p}, \u2205} \u00d7 \u03b1\u3009,\nwhere M(\u3008s, c, q\u3009, \u3008s\u2032, c\u2032, q\u2032\u3009) iff \u03c1(s, s\u2032) and q\u2032 \u2208 \u03b4(q, L(s) \u222a c), and L(\u3008s, c, q\u3009) = c.\nIt is not hard to see that a path pi = \u3008s0, c0, q0\u3009, \u3008s1, c1, q1\u3009, \u3008s2, c2, q2\u3009, . . . in P corre-\nsponds to a computation s0, s1, s2, . . . of S, a p-coloringL(s0)\u222ac0, L(s1)\u222ac1, L(s2)\u222ac2, . . .\nof the trace that the computation induces, and a run q0, q1, q2, . . . of Ac(\u03d5) on this p-coloring.\nTheorem 4.2 The system S does not satisfy \u03d5 iff the product of S and Ac(\u03d5) is pumpable\nnonempty.\nProof: Assume first that S 6|= \u03d5. Then, for every bound k \u2265 0, there exists a computation\npik of S such that (pik, 0, 2k) 6|= \u03d5. Let k be larger than |S| \u00b7 |Q| and let pik be as above.\nSince (pik, 0, 2k) 6|= \u03d5, then, by Lemma 2.1, for all k-bounded p-coloring pi\u2032k of pik, we have\n(pi\u2032k, 0) 6|= c(\u03d5). Consider the k-tight p-coloring pi\u2032k of pik that starts with a green block. By\nthe above, (pi\u2032k, 0) 6|= c(\u03d5). Also, clearly, (pi\u2032k, 0) |= altp. Thus, (pi\u2032k, 0) |= c(\u03d5). In addition,\nsince k > |S| \u00b7 |Q|, every path in the product P that corresponds to a k-tight p-coloring of\npik is pumpable. Hence, the product of pi\u2032k with an accepting run of Ac(\u03d5) is a pumpable fair\npath in P .\nAssume now thatP contains a pumpable fair path pi = \u3008s0, c0, q0\u3009, \u3008s1, c1, q1\u3009, \u3008s2, c2, q2\u3009,\n. . .. We claim that for every k \u2265 0, we can pump the computation s0, s1, s2, . . . of S to a\ncomputation that does not satisfy \u03d5 with bound k. To see this, note that for each k, we can\npump the path pi to a fair path pik such that the p-coloring of the trace that corresponds to pik\nis k-spaced and satisfies \u00acrelp(\u03d5). Hence, by Lemma 2.1, it does not satisfy \u03d5 with bound\nk.\nIn Section 5, we study the problem of deciding whether a colored Bu\u00a8chi graph is pumpable-\nnonempty, and prove that it is in NLOGSPACE and can also be solved in linear time. This,\ntogether with Theorems 4.1 and 4.2, imply the upper bound in the following theorem. The\nlower bound follows from the known lower bound for LTL.\nTheorem 4.3 The model-checking problem for PROMPT-LTL is PSPACE-complete and can\nbe solved in time exponential in the length of the formula and linear in the size of the system.\nNote that while the pumpable nonemptiness problem to which PROMPT-LTL model-\nchecking is reduced is a variant of the nonemptiness problem to which LTL model checking\nis reduced, the construction of the product is almost the same. In particular, the extensive\nwork on optimal compilation of LTL formulas to NBW (see survey in [Var07]), is applicable\nto our solution too.\nRemark 4.4 The model-checking algorithm of the parametric linear temporal logic of [AETP01]\nis based on the observation that if a PROMPT-LTL formula \u03d5 is satisfied in a system S, then\nit is satisfied with bound k, for some k that is exponential in \u03d5 and polynomial in S. One\ncannot hope to improve this bound. Indeed, for every n \u2265 1, we can define a PROMPT-LTL\nformula \u03c8n of size linear in n such that a systems satisfies \u03c8n iff in all its computations, the\natomic proposition q corresponds to an n-bit counter, and the value of the counter promptly\neventually reaches 2n \u2212 1. Clearly, \u03c8n is promptly satisfied, but the minimal bound k with\nwhich \u03c8n is satisfied with bound k (in some system) is exponential in n.\nThe algorithm in [AETP01] can also be used in order to find the minimal bound. It is an\nopen question whether the minimal bound can be found using our simplified algorithm.\n9\n5 Algorithms for Colored Bu\u00a8chi Graphs\nIn Section 4 we reduced model-checking for PROMPT-LTL to the pumpable nonemptiness\nproblem for colored Bu\u00a8chi graphs. In this section we solve this problems, and provide space\nand time bounds.\nTheorem 5.1 The pumpable nonemptiness problem for colored Bu\u00a8chi graphs is NLOGSPACE-\ncomplete and can be solved in linear time.\nProof: Let G = \u3008{p}, V, E, v0, L, \u03b1\u3009. We start with an algorithm in NLOGSPACE. It is\nnot hard to see that it is enough to search for pumpable fair paths of the form uw\u03c9 where\nu,w \u2208 V +. In addition, we can assume that |u| is a p-change point, that is, the color of the\nlast vertex in u is different from the color of the first vertex in w, and in addition that the first\np-block in w visits \u03b1.\nIt is well known that we can check whether a vertex v is reachable from a vertex v\u2032 in\nNLOGSPACE. We guess a successor v\u2032\u2032 of v, if v\u2032\u2032 = v\u2032 the answer is yes, otherwise we\ncheck whether v\u2032 is reachable from v\u2032\u2032. The algorithm requires logarithmic space in order to\nstore the vertices v, v\u2032 and v\u2032\u2032.\nIn order to find a pumpable fair path we have to iterate the search of paths described\nabove4. We say that a vertex v\u2032 is block-reachable from v if there exists a path from v to v\u2032\nsuch that all vertices on the path agree on their color. Block-reachability can be established\nby an algorithm similar to the above where the search is restricted to vertices that agree with\nv and v\u2032 on their color. We say that vertex v\u2032 is pump-block-reachable from v if v\u2032 is block-\nreachable from v and in addition some vertex repeats on the path from v to v\u2032. We can\nestablish that v\u2032 is pump-block-reachable from v by an algorithm similar to the above. We\nguess a vertex v\u2032\u2032 that agrees with v and v\u2032 on their color, ensure that v\u2032\u2032 is block-reachable\nfrom v, that v\u2032\u2032 is block-reachable from itself, and that v\u2032 is block-reachable from v\u2032\u2032. A\nsimple modification of the above can check that v\u2032 is pump-block-reachable from v by a path\nthat visits \u03b1.\nUsing the pump-block-reachable check described above we do the following. We guess a\nvertex v1 that is the first vertex in w. We check that v1 is reachable from v0 with a sequence\nof pump-block-reachable steps. That is, to make one step from node v we guess a node v\u2032\nthat does not agree with v on its color. We guess a predecessor v\u2032\u2032 of v\u2032 that does agree with v\non its color and check that v\u2032\u2032 is pump-block-reachable from v. Then we continue the search\nfrom v\u2032. Once we have established that v1 is reachable from v0, we guess a vertex v2, make\nsure that some predecessor v\u20321 of v2 is pump-block-reachable from v1 with a path that visits\n\u03b1. Finally, we check that v1 is reachable from v2 by a sequence of pump-block-reachable\nsteps (as before).\nSince the reachability problem in directed graphs is in NLOGSPACE, our algorithm can\nbe implemented in NLOGSPACE.\nWe now move to the time complexity. For standard Bu\u00a8chi nonemptiness, one looks for\na reachable nontrivial strongly connected component that intersects \u03b1. In the colored case,\nwe should further check that each p-block in the path can be pumped. We do this by making\nsure that every green p-block contains at least one vertex that belongs to a nontrivial strongly\nconnected component in the graph of the green vertices, and similarly for the red p-blocks.\nConsider the graph Gg = \u3008Vg, Eg\u3009 obtained from G by restricting attention to green\nvertices. Thus, Vg = {v \u2208 V | L(v) = {p}} and Eg = E \u2229 (Vg \u00d7 Vg). The graph\n4This is similar to the proof that emptiness of Bu\u00a8chi graphs is solvable in NLOGSPACE. We guess a vertex\nv \u2208 \u03b1, show that it is reachable from v0 and that it is reachable from itself.\n10\nGr = \u3008Vr , Er\u3009 is defined similarly. We can find the maximal strongly connected components\n(MSCC) of Gg and Gr in linear time [Tar72] (note we are interested also in MSCCs that are\nnot reachable from v0 in Gg and Gr). Let Sg \u2286 Vg and Sr \u2286 Vr denote the union of all\nnon-trivial MSCCs in Gg and Gr, respectively.\nLet backg(Sg) be the vertices that can reach some vertex in Sg, and let e-backg(Sg) be the\nedges between these vertices. We tag the vertices in backg(Sg)\\Sg by the tag B. Formally, we\ndefine backg0(Sg) = Sg , and back\ng\ni+1(Sg) = {v \u2208 Vg | \u2203v\n\u2032 \u2208 backgi (Sg) and (v, v\u2032) \u2208 E},\nfor 1 \u2264 i < n. Then,\nbackg(Sg) = Sg \u222a ((backgn(Sg)) \\ Sg)\u00d7 {B}).\nFor a vertex u \u2208 backg(Sg), let ver(u) be the vertex in V that induces u; that is, the vertex\nobtained from u by ignoring its tag, if exists. Then,\ne-backg(Sg) = { \u3008u, u\u2032\u3009 : E(ver(u), ver (u\u2032)) and u, u\u2032 \u2208 backg(Sg) }.\nWe note that the only cycles in backg(Sg) are in Sg. Indeed, such a cycle is part of an MSCC\nof green vertices and belongs in Sg . In a similar way, we define forwardg(Sg) to be the set\nof vertices that are reachable from some vertex in Sg (with vertices not in Sg tagged with F)\nand define e-forwardg(Sg) to be the edges between these vertices. The sets backr, e-backr,\nforwardr, and e-forwardr are defined similarly. Another type of edges we need are edges\nbetween p-blocks. Let\nEg\u2192r = {\u3008u, u\n\u2032\u3009 : E(ver(u), ver (u\u2032)), u \u2208 forwardg(Sg), and u\u2032 \u2208 backr(Sr)}\nbe the set of edges along which the color changes from green to red, and let\nEr\u2192g = {\u3008u, u\n\u2032\u3009 : E(ver(u), ver (u\u2032)), u \u2208 forwardr(Sr), and u\u2032 \u2208 backg(Sg)}\nbe the set of edges along which the color changes from red to green.\nConsider now the graph G\u2032 = \u3008V \u2032, E\u2032\u3009, where V \u2032 = backg(Sg) \u222a forwardg(Sg) \u222a\nbackr(Sr) \u222a forwardr(Sr), and\nE\u2032 = e-forwardg(Sg) \u222a e-forwardr(Sr) \u222a e-backg(Sg) \u222a e-backr(Sr) \u222a Eg\u2192r \u222a Er\u2192g.\nNote that the vertices in Sg and Sr appear in G\u2032 with no tag. Other vertices (these in Vg\nthat can reach an MSCC in Sg along green vertices and can also be reached from a different\nMSCC in Sg along green vertices, and similarly for Vr) may appear inG\u2032 with both tags, thus\nthe number of vertices in G\u2032 is at most twice the number of vertices in G.\nIntuitively, the graph G\u2032 contains exactly all the pumpable computations of G. Indeed,\nalong each p-block, there must exists a vertex that belongs to an MSCC of the graph of the\ncorresponding color.\nClaim 5.2 The graph G is pumpable nonempty iff G\u2032 has some non-trivial MSCC that is\nreachable from v0 (possibly tagged with B) and contains a vertex from \u03b1.\nProof: Suppose that there is some non-trivial MSCC in G\u2032 with a vertex v from \u03b1. Let\npi = v0, v1, . . . , be a path from v0 that visits v infinitely often. We show that we can find a\npumpable path pi\u2032 from v0 that visits v infinitely often. (Note that V \u2032 \u2286 V \u222a(V \u00d7{B, F}), thus\nwe abuse here notation and move to talk about the projection of pi on V ). Consider the path pi.\nEvery edge in pi is in one of the six sets of edges that compriseE\u2032. Partition pi to the p-blocks\n11\nthat comprise it pi0, pi1, . . ., where pii = vji , vji+1, . . . , vji+1\u22121. We construct by induction a\npath pi\u2032 in which every block is pumpable. Consider the blocks pi0 and pi1. Suppose that pi0\nis green and pi1 is red (the dual case is similar). It follows that (vj1\u22121, vj1) \u2208 Eg\u2192r and that\nvj1\u22121 \u2208 forwardg(Sg). Hence, there has to be a path in Gg between v0 and vj1\u22121 that passes\nthrough some MSCC inGg . Let pi\u20321 be the path that goes from v0 to vj1\u22121 through this MSCC\nand passes at least some vertex in this MSCC twice. Consider the blocks pii\u22121, pii, pii+1.\nAssume that pii\u22121 is green, pii is red, and pii+1 is green. Then (vji\u22121, vji) \u2208 Eg\u2192r and\n(vji+1\u22121, vji+1) \u2208 Er\u2192g. It follows that vji \u2208 backr(Sr) and vji+1\u22121 \u2208 forwardr(Sr).\nThen pii visits some vertex v in Sr, and we set pi\u2032i to be a path between vji and vji+1\u22121 that\nvisits v twice. The case where the path pi has only finitely many p-blocks can be handled\nsimilarly.\nConsider a pumpable fair path pi = v0, v1, . . . in G. We can tag some of the vertex vi by\nB or F according to its location in its block (tag with B vertices not in Sg that appear before\nthe repeating state and tag with F vertices not in Sg that appear after the repeating state). It is\neasy to see that all the edges in the tagged version of pi are present in G\u2032. It follows that in G\u2032\nthere is some reachable MSCC that visits \u03b1.\nWe analyze the time it takes to construct G\u2032 and to check whether it has a non-trivial\nMSCC that intersects \u03b1. Clearly, the MSCC decomposition of Gg and Gr can be done in\nlinear time. The search for backg and forwardg is done by backward and forward propagation\nfrom Sg. During the search, the edges in e-backg and e-forwardg can be marked. The case\nof backr and forwardr is similar. This stage can be completed in linear time as well. Finally,\nthe MSCC decomposition of G\u2032 is completed again in linear time. Since the size of G\u2032 is at\nmost twice the size of G, the overall running time is linear.\nWe note than our algorithm is based on MSCC-decomposition. It is an open question\nwhether a linear-time algorithm based on nested depth-first-search can be found (see discus-\nsion of these types of algorithms in [Var07]).\nIn Section 6 we reduce assume-guarantee model-checking for PROMPT-LTL to a pumpable\nnonemptiness problem for colored Bu\u00a8chi graphs with two sets of colors. We now turn to con-\nsider such graphs.\nA colored Bu\u00a8chi graph of degree two is a tuple G = \u3008{p, q}, V, E, v0, L, \u03b1\u3009. It is similar\nto a colored Bu\u00a8chi graph, only that now there are two sets of colors, described by p and q.\nAccordingly, L : V \u2192 2{p,q}. Also, \u03b1 is a generalized Bu\u00a8chi condition of index 2, thus\n\u03b1 = {\u03b11, \u03b12}. A path pi = v0, v1, v2, . . . of G is pumpable if we can pump all its q-blocks\nwithout pumping its p-blocks. Formally, if i and i\u2032 are adjacent q-change points, then there\nare positions j, j\u2032, and j\u2032\u2032 such that i \u2264 j < j\u2032 < j\u2032\u2032 < i\u2032, vj = vj\u2032\u2032 and p \u2208 L(vj)\niff p \/\u2208 L(vj\u2032). Also, pi is fair if it visits both \u03b11 and \u03b12 infinitely often. The pumpable\nnonemptiness problem is to decide, given G, whether it has a pumpable fair path.\nTheorem 5.3 The pumpable nonemptiness problem for colored Bu\u00a8chi graphs of degree two\nis NLOGSPACE-complete and can be solved in linear time.\nProof: As before, we are searching for a pumpable fair path of the form uw\u03c9 where u,w \u2208\nV + and that |u| is a p-change point.\nThe search for a q-block that connects v to v\u2032 and contains a pumpable section is parti-\ntioned as follows. We guess v\u2032\u2032 that agrees with v on the assignment to q and search for a\npath from v to v\u2032 while maintaining the same q assignment. Then we search for a path from\nv\u2032\u2032 to itself. This path has to maintain the same assignment to q, however, has to change the\n12\nassignment to p at least twice (as the path leads from v\u2032\u2032 to itself the number of changes is\neven). Finally, we search for a path from v\u2032\u2032 to v\u2032 that maintains the same assignment to q.\nUsing this basic reachability algorithm we do the following. We guess a vertex v1 that\nis the first vertex in w. We make sure that v1 is reachable from v0 with a sequence of such\nmoves. We make sure that v1 is reachable from itself with a sequence of such moves that visit\nboth \u03b11 and \u03b12. The entire algorithm can be implemented in NLOGSPACE.\nWe now describe a linear-time algorithm for solving the problem. Assume that v0 has\nno incoming edges. Consider the graph Gq = \u3008Vq, Eq\u3009 where Vq is the subset of vertices\nlabeled by q, i.e. Vq = {v \u2208 V | q \u2208 L(v)} and Eq = E \u2229 (Vq \u00d7 Vq). The graph\nGq = \u3008Vq , Eq\u3009 is defined similarly for vertices not labeled by q. We can analyze the maximal\nstrongly connected components (MSCC) ofGq andGq in linear time [Tar72]. We restrict our\nattention to MSCCs that contain both vertices labeled by p and vertices not labeled by p. Let\nSq \u2286 Vq denote the union of all non-trivial MSCCs M in Gq such that there exist v, v\u2032 \u2208M\nsuch that p \u2208 L(v) and p \/\u2208 L(v\u2032). Define Sq \u2286 Vq similarly.\nFor \u03b2 \u2208 {q, q}, the sets back\u03b2(S\u03b2), e-back\u03b2(S\u03b2), forward\u03b2(S\u03b2), e-forward\u03b2(S\u03b2) are\ndefined as in the proof of Theorem 5.1. As there, the vertices in back\u03b2(S\u03b2) \\ S\u03b2 are tagged\nwith B and the vertices in forward\u03b2(S\u03b2) \\ S\u03b2 are tagged with F.\nConsider now the graph G\u2032 = \u3008{p}, V \u2032, E\u2032, v0, L, \u03b1\u3009 of G where V \u2032 = backq(Sq) \u222a\nforwardq(Sq) \u222a backq(Sq) \u222a forwardq(Sq) and E\u2032 is as follows.\nE\u2032 = Eq\u2192q \u222a Eq\u2192q \u222a e-forwardq(Sq) \u222a e-forwardq(Sq) \u222a e-backq(Sq) \u222a e-backq(Sq),\nwhere Eq\u2192q and Eq\u2192q are defined as follows.\nEq\u2192q = {\u3008u, u\n\u2032\u3009 : E(ver (u), ver(u\u2032)), u \u2208 forwardq(Sq), and u\u2032 \u2208 backq(Sq)},\nEq\u2192q = {\u3008u, u\u2032\u3009 : E(ver (u), ver(u\u2032)), u \u2208 forwardq(Sq), and u\u2032 \u2208 backq(Sq)}.\nClaim 5.4 The graph G is pumpable nonempty iff G\u2032 has some non-trivial MSCC that is\nreachable from v0 (possibly tagged with B) and contains vertices from \u03b11 and from \u03b12.\nProof: Suppose that there is some non-trivial MSCC in G\u2032 with a vertices s1 and s2 from\n\u03b11 and \u03b12, respectively. Let pi = v0, v1, . . . , be a path from v0 that visits s1 and s2 infinitely\noften. We show that we can find a pumpable path pi\u2032 from v0 that visits \u03b11 and \u03b12 infinitely\noften. Consider the path pi. Every edge in pi is in one of the six sets of edges that compriseE\u2032.\nPartition pi to the q-blocks that comprise it pi0, pi1, . . ., where pii = vji , vji+1, . . . , vji+1\u22121.\nWe build by induction a path pi\u2032 in which every block is pumpable. Consider the blocks\npi0 and pi1. Suppose that pi0 is labeled by q and pi1 is not labeled by q. It follows that\n(vj1\u22121, vj1) \u2208 Eq\u2192q and that vj1\u22121 \u2208 forwardq(Sq). Hence, there has to be a path in Gq\nbetween v0 and vj1\u22121 that visits some vertex v in Sq . By definition of Sq, the vertex v\nbelongs to an MSCC M that contains vertices labeled by p and vertices not labeled by p.\nLet pi\u20321 be the path that goes from v0 to vj1\u22121, visits v twice, and between the two visits to v\npasses vertices labeled by p and vertices not labeled by p. Consider the blocks pii\u22121, pii, pii+1.\nAssume that pii\u22121 is labeled by q, pii is not labeled by q, and pii+1 is labeled by q. Then\n(vji\u22121, vji) \u2208 Eq\u2192q and (vji+1\u22121, vji+1) \u2208 Eq\u2192q . It follows that vji \u2208 backq(Sq) and\nvji+1\u22121 \u2208 forwardq(Sq). Then pii visits some vertex v in Sq, and we set pi\u2032i to be a path\nbetween vji and vji+1\u22121 that visits v twice, and in addition between the two visits to v passes\nvertices labeled by p and vertices not labeled by p. We do not remove visits to \u03b11 and \u03b12,\nhence, if pi visits \u03b11 and \u03b12 infinitely often so does pi\u2032. The case where the path pi has only\nfinitely many q-blocks can be handled similarly.\n13\nConsider a pumpable fair path pi inG. It is simple to see that all the edges on pi are present\nalso in G. It follows that in G there is some reachable MSCC that visits both \u03b11 and \u03b12.\nAs before, all parts of the algorithm can be executed in linear time.\nRemark 5.5 The algorithms described above are explicit. A symbolic PROMPT-LTL model\nchecking algorithm follows from the translation of PROMPT-LTL to the \u00b5-calculus described\nlater in Theorem 7.3. The translation, however, involves a significant blow up. A sym-\nbolic algorithm that performs well on the colored Bu\u00a8chi graphs is left open. For standard\nBu\u00a8chi graphs, algorithms can be classified as ones that are based on a nested fixed point that\ncalculates the set of states that can reach \u03b1 infinitely often [EL86], and ones that calculate\nsymbolically the MSCC of the graph [BGS00]. We believe that algorithms of the second type\ncan be extended to colored graphs.\n6 Assume-Guarantee Model Checking\nFor two systems S = \u3008AP, S, \u03c1, s0, L\u3009 and S\u2032 = \u3008AP, S\u2032, \u03c1\u2032, s\u20320, L\u2032\u3009, the parallel composi-\ntion of S with S\u2032, denoted S\u2016S\u2032, is the system that contains all the joint behaviors of S and\nS\u2032. Formally, S\u2016S\u2032 = \u3008AP, S\u2032\u2032, \u03c1\u2032\u2032, s\u2032\u20320 , L\u2032\u2032\u3009, where S\u2032\u2032 \u2286 S \u00d7 S\u2032 contains exactly all pairs\nthat agree on their label, that is \u3008s, s\u2032\u3009 \u2208 S\u2032\u2032 iff L(s) = L\u2032(s\u2032). Then, s\u2032\u20320 = \u3008s0, s\u20320\u3009 and\n\u03c1\u2032\u2032(\u3008s, s\u2032\u3009, \u3008t, t\u2032\u3009) iff \u03c1(s, t) and \u03c1\u2032(s\u2032, t\u2032). Finally, L\u2032\u2032(\u3008s, s\u2032\u3009) = L(s).\nAn assume-guarantee specification for a system S is a pair of two specifications \u03d51 and\n\u03d52. The system S satisfies the specification, denoted \u3008\u03d51\u3009S\u3008\u03d52\u3009, if it is the case that for all\nsystems S\u2032, if S\u2016S\u2032 satisfies \u03d51, then S\u2016S\u2032 also satisfies \u03d52 [Pnu85]. In the context of LTL it\nis not hard to see that \u3008\u03d51\u3009S\u3008\u03d52\u3009 iff S |= \u03d51 \u2192 \u03d52. Intuitively, since the \u2016 operator amounts\nto taking the intersection of the languages of S and S\u2032, it is sound to restrict attention to\nsystems S\u2032 that correspond to single computations of S. In the case of PROMPT-LTL, we can\nalso restrict attention to single computations, but we have to take the bounds into an account.\nFormally, we have the following.\nLemma 6.1 Consider a system S and PROMPT-LTL formulas \u03d51 and \u03d52. The specification\n\u3008\u03d51\u3009S\u3008\u03d52\u3009 does not hold iff there is a bound k1 \u2265 0 such that for every bound k2 \u2265 0, there\nis a trace w of S such that (w, 0, k1) |= \u03d51 but (w, 0, k2) 6|= \u03d52.\nSince refuting assume-guarantee specifications refer to two bounds, we extend the alternating-\ncolor technique to refer to two sets of colors. The atomic proposition p partitions the com-\nputation to blocks that bound k1, and a new atomic proposition q does the same for k2.\nAccording to Lemmas 2.1 and 6.1, refuting \u3008\u03d51\u3009S\u3008\u03d52\u3009 amounts to finding a bound k1 \u2265 0\nsuch that for all bounds k2 \u2265 0, there is a computation w of S such that w has a k1-bounded\np-coloring that satisfies altp \u2227 relp(\u03d51), but w also has a k2-spaced q-coloring that satisfies\naltq\u2227\u00acrelq(\u03d52). Indeed, such a computation satisfies \u03d51 with bound k1, and does not satisfy\n\u03d52 with bound k2.\nThe intuition above led us to the definition of colored Bu\u00a8chi graphs of degree two and the\ncorresponding definition of pumpable nonemptiness. As before, the pumpable nonemptiness\ntechnique can be used for solving the assume-guarantee model-checking problem.\nLet c(\u03d51) = altp\u2227relp(\u03d51) and c(\u03d52) = altq\u2227\u00acrelq(\u03d52), and letAc(\u03d51) = \u30082AP\u222a{p}, Q1, \u03b41, q10 , \u03b11\u3009,\nand Ac(\u03d52) = \u30082AP\u222a{q}, Q2, \u03b42, q20 , \u03b12\u3009 be the corresponding NBWs (per Theorem 4.1).\nWe define the product of S with Ac(\u03d51) and Ac(\u03d52) as the colored Bu\u00a8chi graph of degree\n14\ntwo. P = \u3008{p, q}, S \u00d7 2{p,q} \u00d7Q1 \u00d7Q2,M, \u3008s0, {p, q}, q10, q\n2\n0\u3009, L, {S \u00d7 2\n{p,q} \u00d7 \u03b11 \u00d7Q2,\nS\u00d72{p,q}\u00d7Q1\u00d7\u03b12}\u3009, whereM(\u3008s, c, q1, q2\u3009, \u3008s\u2032, c\u2032, q\u20321, q\u20322\u3009) iff \u03c1(s, s\u2032), q\u20321 \u2208 \u03b41(q1, L(s)\u222a\n(c \u2229 {p})), and q\u20322 \u2208 \u03b42(q2, L(s) \u222a (c \u2229 {q})). Finally, L(\u3008s, c, q1, q2\u3009) = c.\nTheorem 6.2 The specification \u3008\u03d51\u3009S\u3008\u03d52\u3009 does not hold iff the product of S with Ac(\u03d51)\nand Ac(\u03d52) is pumpable nonempty,\nProof: Assume that \u3008\u03d51\u3009S\u3008\u03d52\u3009 does not hold. Then, by Lemma 6.1, there is a bound k1 \u2265 0\nsuch that for every bound k2 \u2265 0, there is a trace wk1,k2 of S such that (wk1,k2 , 0, k1) |= \u03d51\nbut (wk1,k2 , 0, 2k2) 6|= \u03d52. Let k2 be larger than 2 \u00b7 |S| \u00b7 |Q1| \u00b7 |Q2| \u00b7 k1 and let pik1,k2 be as\nabove. Since (pik1,k2 , 0, k1) |= \u03d51, then, by Lemma 2.1, for all k1-spaced p-coloring pi\u2032k1,k2\nof pik1,k2 , we have (pi\u2032k1,k2 , 0) |= c(\u03d51). Since (pik1,k2 , 0, 2k2) 6|= \u03d52, then, by Lemma 2.1,\nfor all k2-bounded q-coloring pi\u2032\u2032k1,k2 of pik1,k2 , we have (pi\n\u2032\u2032\nk1,k2\n, 0) 6|= c(\u03d52). Consider the\nk1-tight p-coloring and k2-tight q-coloring pi\u2032k1,k2 of pik1,k2 that starts with p and q. By the\nabove, (pi\u2032k1,k2 , 0) 6|= c(\u03d52). Also, clearly, (pi\n\u2032\nk1,k2\n, 0) |= altq. Thus, (pi\u2032k1,k2 , 0) |= c(\u03d52). In\naddition, since k2 > 2 \u00b7 |S| \u00b7 |Q1| \u00b7 |Q2| \u00b7 k1, every path in the product P is (p, q)-pumpable.\nHence, the product of pi\u2032k1,k2 with accepting runs ofAc(\u03d51) and ofAc(\u03d52) is a (p, q)-pumpable\nfair path in P .\nAssume now thatP contains a (p, q)-pumpable fair path pi = \u3008s0, c0, q10 , q20\u3009, \u3008s1, c1, q11 , q21\u3009,\n\u3008s2, c2, q12 , q\n2\n2\u3009, . . .. Let k1 denote the size of the maximal p-block in pi (as explained in Sec-\ntion 5, if P is (p, q)-pumpable nonempty, then it has a regular (p, q)-pumpable path, thus the\nmaximum is well defined). We claim that for every k2 \u2265 0, we can pump the computation\ns0, s1, s2, . . . of S to a computation that satisfies \u03d51 with bound 2k1 but does not satisfy \u03d52\nwith bound k2. Note that if we pump pi, we get a path pi\u2032 such that the p-coloring of the trace\nthat corresponds to pi\u2032 is k1-bounded and satisfies c(\u03d51). In addition, for each k2, we can\npump that path pi to a fair path pik2 such that the q-coloring of the trace that corresponds to\npik2 is 2k2-spaced and satisfies \u00acrelq(\u03d52). Hence, by Lemma 2.1, it satisfies \u03d51 with bound\n2k1, and does not satisfy \u03d52 with bound k2.\nTheorems 4.1, 5.3, and 6.2 imply the upper bound in the following theorem. The lower\nbound follows from the known lower bound for LTL.\nTheorem 6.3 The assume-guarantee model-checking problem for PROMPT-LTL is PSPACE-\ncomplete and can be solved in time exponential in the length of the formulas and linear in the\nsize of the system.\nRemark 6.4 For LTL, fairness constraints about the system can be specified in the formula.\nThus, checking that \u03d52 holds in all computations that satisfy the fairness constraint \u03d51 can\nbe reduced to model checking \u03d51 \u2192 \u03d52. A fairness assumption can also be specified in\nPROMPT-LTL. Here, however, one has to allow the fairness assumption and the specifica-\ntion to be satisfied with different bounds. Thus, fairness should be reduced to checking\n\u3008\u03d51\u3009S\u3008\u03d52\u3009.\nFor two formulas\u03d51 and\u03d52, we say that\u03d51 implies\u03d52 iff for every system S, if S satisfies\n\u03d51, then it also satisfies \u03d52. In the case of LTL, \u03d51 implies \u03d52 iff the formula \u03d51 \u2192 \u03d52 is\nvalid. In the case of PROMPT-LTL, \u03d51 implies \u03d52 iff \u3008\u03d51\u3009U\u3008\u03d52\u3009, where U is the universal\nsystem (a clique over 2AP that contains all traces over AP ). Indeed, since for every system\nS we have that S\u2016U = S, then \u3008\u03d51\u3009U\u3008\u03d52\u3009 does not hold iff there is a system S such that\nif S satisfies \u03d51 but S 6|= \u03d52. Since U is exponential in AP , and the PSPACE complexity\nof assume-guarantee model checking originates from an algorithm that is polynomial in the\n15\nformulas and only logarithmic in the system, we have the following (the lower bound follows\nfrom the PSPACE hardness of LTL implication).\nTheorem 6.5 The implication problem for PROMPT-LTL is PSPACE-complete.\n7 Expressiveness\nIn this section we study expressiveness aspects of PROMPT-LTL. We show that a PROMPT-\nLTL formula \u03d5 has an equivalent LTL formula iff \u03d5 and live(\u03d5) are equivalent, thus the\nproblem of deciding whether \u03d5 can be translated to LTL is PSPACE-complete. Since the\nsemantics of PROMPT-LTL is defined with respect to a system, a natural question is whether\nwe can translate PROMPT-LTL formulas to branching temporal logics. We show that indeed,\nall PROMPT-LTL formulas can be translated to the \u00b5-calculus.\nAll our results refer to finite-state systems. Thus, we say that two formulas \u03d5 and \u03d5\u2032 are\nequivalent iff for all finite systems S, we have that S |= \u03d5 iff S |= \u03d5\u2032. In fact, we later\nshow that the finiteness of the systems is crucial, and the results are different for infinite-state\nsystems.\n7.1 From PROMPT-LTL to LTL\nSome PROMPT-LTL formulas\u03d5 are equivalent to the LTL formula live(\u03d5). For example, it is\nnot hard to see that Fpr is equivalent to Fr, for an atomic proposition r. On the other hand,\nas demonstrated in Section 1, the PROMPT-LTL formula FpGr is not equivalent to the LTL\nformula FGr. Is FpGq equivalent to another LTL formula? A negative answer follows from\nLemma 7.1 below.\nLemma 7.1 Consider a PROMPT-LTL formula \u03d5. There is an LTL formula equivalent to \u03d5\niff \u03d5 is equivalent to live(\u03d5).\nProof: Assume that \u03d5 has an equivalent LTL formula. Then, there is an \u03c9-regular language\nL\u03d5 \u2286 (2P )\u03c9 such that a system S satisfies \u03d5 iff all the traces of S are contained in L\u03d5. We\nprove that then, for every system S, we have that S |= live(\u03d5) iff S |= \u03d5. The direction\nfrom right to left holds always. For the other direction, assume by way of contradiction that\nS |= live(\u03d5), but S 6|= \u03d5. Thus, the traces of S are not contained in L\u03d5. Since S is finite\nstate and L\u03d5 is \u03c9-regular, but there is an \u03c9- regular trace w of S that does not belong to L\u03d5.\nLet k be such that w satisfies live(\u03d5) with bound k (since w is a single trace of a finite state\nsystem, such a bound k must exist). Then, w satisfies also \u03d5, and it therefore belongs to L\u03d5.\nTheorem 7.2 Deciding whether a PROMPT-LTL formula has an equivalent LTL formula is\nPSPACE-complete.\nProof: By Lemma 7.1, the problem of deciding whether a PROMPT-LTL formula \u03d5 has an\nequivalent LTL formula can be reduced to checking the equivalence of \u03d5 and live(\u03d5). Since\n\u03d5 \u2192 live(\u03d5) is valid for all \u03d5, one should only check the implication live(\u03d5) \u2192 \u03d5, which,\naccording to Theorem 6.5, can be done in PSPACE.\nWe prove hardness in PSPACE by a reduction from the satisfiability problem of LTL.\nConsider an LTL formula \u03d5, and a proposition r not used in \u03d5. It is not hard to prove that the\nPROMPT-LTL formula \u03d5 \u2227FpGr has an equivalent LTL formula iff \u03d5 is unsatisfiable.\n16\n7.2 From PROMPT-LTL to the \u00b5-calculus\nIt is not hard to prove that the PROMPT-LTL formula FpGq is equivalent to the CTL formula\nAFAGq. Indeed, a system satisfies both formulas iff there is a bound k \u2265 0 such that all\nthe computations may visit a state in which q does not hold only in the first k positions.\nOne may wonder whether this argument can be generalized, leading to a simple translation\nof PROMPT-LTL formulas to CTL \u22c6 formulas: given a PROMPT-LTL formula \u03d5, translate it\nto a CTL\u22c6 formula \u03d5\u2032 by (recursively) replacing all subformulas of the form Fp\u03b8 by FA\u03b8\n(and adding an external A). To see that the reduction does not hold in general, consider the\nPROMPT-LTL formula \u03d5 = Fp(Gq \u2228Xr). While the system S\u2032 obtained from the system\nS in Figure 1 by adding r to the initial state satisfies \u03d5 (with bound 2), the system S\u2032 does\nnot satisfy the CTL\u22c6 formula \u03d5\u2032 = AFA(Gq \u2228 Xr). The question whether PROMPT-LTL\ncan be expressed in CTL\u22c6 is open. On the other hand, the two-color technique can be used\nin order to translate a PROMPT-LTL formula over P to alternating parity tree automaton over\nthe alphabet 2P\u222a{p}, and then to the \u00b5-calculus over P . Formally, we have the following.\nTheorem 7.3 Every PROMPT-LTL formula has an equivalent \u00b5-calculus formula.\nProof: Given a PROMPT-LTL formula \u03d5 over P , let A\u2200c(\u03d5) be an alternating parity tree\nautomaton that accepts exactly all trees all of whose paths satisfy c(\u03d5); in fact, A\u2200c(\u03d5) can\nbe taken to be a universal co-Bu\u00a8chi automaton [KV05]. Note that A\u2200c(\u03d5) is over the alphabet\n2P\u222a{p}, thus it refers also to the atomic proposition p. Let \u03c8 be a \u00b5-calculus formula equiv-\nalent to A\u2200c(\u03d5) [JW95]. We prove that over finite systems, \u03d5 is equivalent to \u2203p.\u03c8. Assume\nfirst that a system S satisfies \u03d5 with bound k. Then, the unwinding of S augmented with a\np-coloring that is 2k-tight satisfies \u03c8, and thus, by Lemma 2.1, S satisfies \u2203p.\u03c8. Assume now\nthat S satisfies \u2203p.\u03c8. Then, by [Rab69], there also exists a regular labeling of the unwinding\nof S by p such that the unwinding of S augmented with this regular labeling satisfies \u03c8. Let\nn be the product of the number of states in S and the transducer that generates the regular\nlabeling by p. Then, the p-labeling of computations in the unwinding of S must be (n+ 1)-\nbounded. Indeed, as detailed in the proof of Theorem 3.1, otherwise we can generate a path\nof S with the p-labeling that does not satisfy altp. Hence, by Lemma 2.1, S satisfies \u03d5 with\nbound 2n+ 2.\nIt is left to prove that \u2203p.\u03c8, and hence also \u03d5, is equivalent to some \u00b5-calculus formula.\nBy [JW96], every monadic second-order logic sentence that is preserved under bisimulation\nis equivalent to a \u00b5-calculus formulas. Thus, is it enough to show that \u2203p.\u03c8 can be expressed\nin monadic second order logic and is preserved under bisimulation. The first claim follows\nfrom the fact that the \u00b5-calculus can be expressed in monadic second order logic. The second\nfollows from the fact that PROMPT-LTL cannot distinguish between systems with the same\nlanguage, thus \u03c6 is preserved under bisimulation.\nThe proof of Theorem 7.3 explains why we conjecture that PROMPT-LTL is more expres-\nsive than CTL\u22c6. By [HT87], CTL\u22c6 formulas can be translated to monadic SnS formulas in\nwhich all set quantifiers are over paths. The expressiveness strength of PROMPT-LTL is its\nability to relate different paths (they all have to satisfy the prompt eventualities in the formula\nwith the same bound). In our proof, the labeling of the quantified proposition p refers to the\nwhole tree and it does not seem replaceable by set quantifiers over paths.\nRecall that our results refer to finite-state systems. We now show that they do not stay\nvalid in the context of infinite-state systems.\n17\nLemma 7.4 In the context of infinite-state systems, no \u00b5-calculus formula is equivalent to\nthe PROMPT-LTL formula GFpq.\nProof: Assume by way of contradiction that there is a \u00b5-calculus formula \u03c8 equivalent to\nGFpq. Then, by [EJ91, MS95], there is a finite-state nondeterministic parity tree automaton\nA\u03c8 that accepts exactly all trees that satisfy GFpq. Let U\u03c8 be the restriction of A\u03c8 to trees\nof branching degree 1. Thus, U\u03c8 is a word automaton accepting all words that satisfy GFpq.\nThe automaton U\u03c8 accepts the infinite family of computations ({p} \u00b7 \u2205k)\u03c9, for all k \u2265 1.\nIndeed, a computation ({p} \u00b7 \u2205k)\u03c9 in the family satisfies GFpq with bound k. We claim that\nthen, U\u03c8 also accepts a computationw = {p} \u00b7 \u2205i1 \u00b7 {p} \u00b7 \u2205i2 \u00b7 {p} \u00b7 \u2205i3 \u00b7 \u00b7 \u00b7 with ij+1 > ij for\nall j \u2265 1. The computation w, however, does not satisfy GFpq, and should not be accepted\nby U\u03c8.\nWe construct the computation pi as follows. Let n be the number of states in U\u03c8. Recall\nthat U\u03c8 accepts the infinite family of computations ({p} \u00b7 \u2205k)\u03c9, for all k \u2265 1. In particular,\nit accepts w\u2032 = ({p} \u00b7 \u2205n+1)\u03c9 . In the accepting run r\u2032 of U\u03c8 on w\u2032, at least one state repeats\nin the run on each sub-computation of the form \u2205n+1. We can pump w\u2032 and r\u2032 and obtain\nthe required computation w along with a run r of U\u03c8 on it. Thus, we obtain w\u2032 by pumping\nthe sub-computation between a repeated state in the (j +1)-th block of \u2205\u2019s sufficiently many\ntimes to get a block that is longer than the j-th block. We then obtain r\u2032 by pumping the\nbehavior of r along the pumped sub-computation. It is easy to see that a state q belongs\nto inf(r) iff there are infinitely many indices j \u2265 1 such that q is visited by r at least once\nbetween reading the j-th and the (j+1)-th {p}, and similarly for r\u2032. Hence, inf(r) = inf(r\u2032).\nSince r\u2032 is accepting, so is r, and thus, U\u03c8 accepts w.\nIt follows from Lemma 7.4 that Theorem 7.3 does not hold in the context of infinite state\nsystems.\nReferences\n[AETP01] R. Alur, K. Etessami, S. La Torre, and D. Peled. Parametric temporal logic for model\nmeasuring. ACM Transactions on Computational Logic, 2(3):388\u2013407, 2001.\n[AS85] B. Alpern and F.B. Schneider. Defining liveness. Information processing letters, 21:181\u2013\n185, 1985.\n[BAS02] A. Biere, C. Artho, and V. Schuppan. Liveness checking as safety checking. In Proc. 7th\nInternational Workshop on Formal Methods for Industrial Critical Systems, volume 66:2\nof Electronic Notes in Theoretical Computuer Science, 2002.\n[BBG+94] I. Beer, S. Ben-David, D. Geist, R. Gewirtzman, and M. Yoeli. Methodology and system for\npractical formal verification of reactive hardware. In Proc. 6th Conference on Computer\nAided Verification, volume 818 of Lecture Notes in Computer Science, pages 182\u2013193,\nStanford, June 1994.\n[BGS00] R. Bloem, H.N. Gabow, and F. Somenzi. An algorithm for strongly connected component\nanalysis in n log n symbolic steps. In Formal Methods in Computer Aided Design, volume\n1954 of Lecture Notes in Computer Science, pages 37\u201354. Springer-Verlag, 2000.\n[BL69] J.R. Bu\u00a8chi and L.HG. Landweber. Solving sequential conditions by finite-state strategies.\nTrans. AMS, 138:295\u2013311, 1969.\n[EF06] C. Eisner and D. Fisman. A Practical Introduction to PSL. Springer, 2006.\n[EJ91] E.A. Emerson and C. Jutla. Tree automata, \u00b5-calculus and determinacy. In Proc. 32nd IEEE\nSymp. on Foundations of Computer Science, pages 368\u2013377, San Juan, October 1991.\n18\n[EL86] E.A. Emerson and C.-L. Lei. Efficient model checking in fragments of the propositional\n\u00b5-calculus. In Proc. 1st Symp. on Logic in Computer Science, pages 267\u2013278, Cambridge,\nJune 1986.\n[EMSS90] E.A. Emerson, A.K. Mok, A.P. Sistla, and J. Srinivasan. Quantitative temporal reasoning.\nIn Proc. 2nd Conference on Computer Aided Verification, volume 531 of Lecture Notes in\nComputer Science, pages 136\u2013145. Springer-Verlag, 1990.\n[HT87] T. Hafer and W. Thomas. Computation tree logic CTL\u22c6 and path quantifiers in the monadic\ntheory of the binary tree. In Proc. 14th International Coll. on Automata, Languages,\nand Programming, volume 267 of Lecture Notes in Computer Science, pages 269\u2013279.\nSpringer-Verlag, 1987.\n[JW95] D. Janin and I. Walukiewicz. Automata for the modal \u00b5-calculus and related results. In\nProc. 20th International Symp. on Mathematical Foundations of Computer Science, Lec-\nture Notes in Computer Science, pages 552\u2013562. Springer-Verlag, 1995.\n[JW96] D. Janin and I. Walukiewicz. On the expressive completeness of the propositional \u00b5-\ncalculus with respect to the monadic second order logic. In Proc. 7th Conference on\nConcurrency Theory, volume 1119 of Lecture Notes in Computer Science, pages 263\u2013277.\nSpringer-Verlag, 1996.\n[KV05] O. Kupferman and M.Y. Vardi. Safraless decision procedures. In Proc. 46th IEEE Symp.\non Foundations of Computer Science, pages 531\u2013540, Pittsburgh, October 2005.\n[MP92] Z. Manna and A. Pnueli. The Temporal Logic of Reactive and Concurrent Systems: Speci-\nfication. Springer-Verlag, Berlin, January 1992.\n[MS95] D.E. Muller and P.E. Schupp. Simulating alternating tree automata by nondeterministic\nautomata: New results and new proofs of theorems of Rabin, McNaughton and Safra.\nTheoretical Computer Science, 141:69\u2013107, 1995.\n[Pnu77] A. Pnueli. The temporal logic of programs. In Proc. 18th IEEE Symp. on Foundation of\nComputer Science, pages 46\u201357, 1977.\n[Pnu85] A. Pnueli. In transition from global to modular temporal reasoning about programs. In\nK. Apt, editor, Logics and Models of Concurrent Systems, volume F-13 of NATO Advanced\nSummer Institutes, pages 123\u2013144. Springer-Verlag, 1985.\n[PR89] A. Pnueli and R. Rosner. On the synthesis of a reactive module. In Proc. 16th ACM Symp.\non Principles of Programming Languages, pages 179\u2013190, Austin, January 1989.\n[Rab69] M.O. Rabin. Decidability of second order theories and automata on infinite trees. Trans-\naction of the AMS, 141:1\u201335, 1969.\n[Tar72] R.E. Tarjan. Depth first search and linear graph algorithms. SIAM Journal of Computing,\n1(2):146\u2013160, 1972.\n[Var07] M.Y. Vardi. Automata-theoretic model checking revisited. In 8th International Confer-\nence on Verification, Model Checking, and Abstract Interpretation, volume 4349 of Lecture\nNotes in Computer Science, pages 137\u2013150. Springer-Verlag, 2007.\n[VW86] M.Y. Vardi and P. Wolper. An automata-theoretic approach to automatic program verifica-\ntion. In Proc. 1st Symp. on Logic in Computer Science, pages 332\u2013344, Cambridge, June\n1986.\n[VW94] M.Y. Vardi and P. Wolper. Reasoning about infinite computations. Information and Com-\nputation, 115(1):1\u201337, November 1994.\n19\n"}