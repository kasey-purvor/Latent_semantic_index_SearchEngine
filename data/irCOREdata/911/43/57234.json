{"doi":"10.1109\/SCAM.201.972682","coreId":"57234","oai":"oai:eprints.lincoln.ac.uk:29","identifiers":["oai:eprints.lincoln.ac.uk:29","10.1109\/SCAM.201.972682"],"title":"Using automated source code analysis for software evolution","authors":["Burd, Liz","Rank, Stephen"],"enrichments":{"references":[{"id":18433377,"title":"An essay on software reuse.","authors":[],"date":"1984","doi":"10.1109\/tse.1984.5010272","raw":"T. A. Standish. An essay on software reuse. IEEE Transactions on Software Engineering, 10(5), 1984.","cites":null},{"id":18433364,"title":"Analysing largecobolprograms: Theextractionofreusablemodules.","authors":[],"date":"1996","doi":"10.1109\/icsm.1996.565011","raw":"E.L. Burd, M. Munro, and C. Wezeman. Analysing largecobolprograms: Theextractionofreusablemodules. In Proceedings of the International Conference on Software Maintenance, November 1996.","cites":null},{"id":18433373,"title":"Black magic recipe for generating dominance trees from COBOL (or any other programming language) source code.","authors":[],"date":"2000","doi":null,"raw":"Sonata Pakstiene, Liz Burd, and Malcolm Munro. Black magic recipe for generating dominance trees from COBOL (or any other programming language) source code. Technical report, Department of Computer Science, University of Durham, 2000.","cites":null},{"id":18433370,"title":"Flow Analysis of Computer Programs.","authors":[],"date":"1977","doi":null,"raw":"Matthew S. Hecht. Flow Analysis of Computer Programs. Elsevier North-Holland, New York, 1977.","cites":null},{"id":18433334,"title":"On understanding law, evolution and conservation in the large program, life cycle.","authors":[],"date":"1979","doi":"10.1016\/0164-1212(79)90022-0","raw":"On understanding law, evolution and conservation in the large program, life cycle. Journal of Systems and Software, 1:213\u2013221, 1979.","cites":null},{"id":18433362,"title":"Program understandingand the concept assignment problem.","authors":[],"date":null,"doi":null,"raw":"T.J. Biggerstaff, B.G. Mitbander,andD. Webster. Program understandingand the concept assignment problem. CommunicationsoftheACM,37(5):72\u201383,1994.","cites":null},{"id":18433375,"title":"Recognising a program\u2019s design: A graph-parsing approach.","authors":[],"date":"1990","doi":"10.1109\/52.43053","raw":"C. Rich and L.M Wills. Recognising a program\u2019s design: A graph-parsing approach. 7(1):82\u201389, 1990.","cites":null},{"id":18433367,"title":"Software salvaging and the call dominance tree.","authors":[],"date":null,"doi":"10.1016\/0164-1212(94)00049-s","raw":"A. Cimitile and G. Visaggio. Software salvaging and the call dominance tree. Journal of Systems Software, 28(2):117\u2013127,1995.","cites":null},{"id":18433360,"title":"SoftwareReusability; concepts and models, volume 1.","authors":[],"date":"1989","doi":null,"raw":"T. J. BiggerstaffandA. J. Perlis. SoftwareReusability; concepts and models, volume 1. ACM Press, 1989.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2001-11","abstract":"Software maintenance is one of the most expensive and time-consuming phases in the software life-cycle. The size and complexity of commercial applications probably present the greatest difficulty that maintainers face when making changes to their applications. As a result of the corresponding loss of understanding, business knowledge encapsulated within the system becomes fragmented, and any changes made as a result of new business initiatives become difficult to implement and hence may mean a loss of business opportunities.\\ud\n \\ud\nThis paper outlines an approach to regaining understanding of software which has been used in the Release project at Durham University. This approach involves determining the calling structure of a program in terms of a call-graph, and from this call-graph extracting a dominance tree. Various problems which have been encountered during the construction of tools to perform this task are described","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/57234.pdf","fullTextIdentifier":"http:\/\/eprints.lincoln.ac.uk\/29\/1\/rank_analysis.pdf","pdfHashValue":"c80776928d73e40c351007cbbb695bfead17fb59","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lincoln.ac.uk:29<\/identifier><datestamp>\n      2013-03-13T08:21:39Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D6A6163735F47:6A6163735F47363130<\/setSpec><setSpec>\n      7375626A656374733D6A6163735F47:6A6163735F47363030<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/eprints.lincoln.ac.uk\/29\/<\/dc:relation><dc:title>\n        Using automated source code analysis for software evolution<\/dc:title><dc:creator>\n        Burd, Liz<\/dc:creator><dc:creator>\n        Rank, Stephen<\/dc:creator><dc:subject>\n        G610 Software Design<\/dc:subject><dc:subject>\n        G600 Software Engineering<\/dc:subject><dc:description>\n        Software maintenance is one of the most expensive and time-consuming phases in the software life-cycle. The size and complexity of commercial applications probably present the greatest difficulty that maintainers face when making changes to their applications. As a result of the corresponding loss of understanding, business knowledge encapsulated within the system becomes fragmented, and any changes made as a result of new business initiatives become difficult to implement and hence may mean a loss of business opportunities.\\ud\n \\ud\nThis paper outlines an approach to regaining understanding of software which has been used in the Release project at Durham University. This approach involves determining the calling structure of a program in terms of a call-graph, and from this call-graph extracting a dominance tree. Various problems which have been encountered during the construction of tools to perform this task are described.<\/dc:description><dc:date>\n        2001-11<\/dc:date><dc:type>\n        Conference or Workshop contribution<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/eprints.lincoln.ac.uk\/29\/1\/rank_analysis.pdf<\/dc:identifier><dc:identifier>\n          Burd, Liz and Rank, Stephen  (2001) Using automated source code analysis for software evolution.  In: First IEEE International Workshop on Source Code Analysis and Manipulation (SCAM 2001), 10 Nov 2001, Florence, Italy.  <\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1109\/SCAM.201.972682<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/eprints.lincoln.ac.uk\/29\/","http:\/\/dx.doi.org\/10.1109\/SCAM.201.972682"],"year":2001,"topics":["G610 Software Design","G600 Software Engineering"],"subject":["Conference or Workshop contribution","PeerReviewed"],"fullText":"Using Automated Source Code Analysis For Software Evolution\nLiz Burd and Stephen Rank,\nDepartment of Computer Science,\nUniversity of Durham\n\u0000\nLiz.Burd,Stephen.Rank \u0001 @durham.ac.uk\nAbstract\nSoftware maintenance is one of the most expensive and\ntime-consuming phases in the software life-cycle. The\nsize and complexity of commercial applications probably\npresent the greatest difficulty that maintainers face when\nmaking changes to their applications. As a result of the\ncorresponding loss of understanding, business knowledge\nencapsulated within the system becomes fragmented, and\nany changes made as a result of new business initiatives be-\ncome difficult to implement and hence may mean a loss of\nbusiness opportunities.\nThis paper outlines an approach to regaining under-\nstanding of software which has been used in the Release\nproject at Durham University. This approach involves de-\ntermining the calling structure of a program in terms of a\ncall-graph, and from this call-graph extracting a dominance\ntree. Various problems which have been encountered during\nthe construction of tools to perform this task are described.\n1. Introduction\nSoftware maintenance is one of the most expensive and\ntime consuming phases in the software life-cycle. However,\ndespite its obvious importance, it is invariably given little\nemphasis by those working on software applications. Soft-\nware is perceived as a flexible medium of which change is\nboth feasible and simple. In reality this could be, but is not\ntrue. The prolonged and expensive maintenance phase is\nrecognised as being detrimental to the overall maintainabil-\nity of applications and so the flexibility and adaptability that\nsoftware may have is soon lost. During this process appli-\ncations are said to be gaining legacy properties. As a conse-\nquence of this rift between the desired and actual properties\nof our software applications, ways are sought of ensuring\nthat the continued change of applications, their evolution,\nprogresses in a manner which ensure their continued flexi-\nbility.\nThe costs of performing maintenance has been estimated\nto be 70 to 90 percent of the total life-cycle cost [10]. Fur-\nthermore, the costs of performing program comprehension\nhave been widely cited as being between 50 and 90 percent\nof the overall cost of performing maintenance [10]. Assum-\ning that these figures are accurate, we can estimate that the\ncosts of performing comprehension for maintenance over\nthe life-time of software could account for approximately\n35 to 80 percent of the software life-cycle costs (i.e., devel-\nopment and maintenance costs). Clearly, this is an impor-\ntant activity so any approach towards assisting the compre-\nhension process can considerably reduce software costs.\nLegacy systems have, embedded within them, a large in-\nvestment made by the systems developers and\/or owners.\nThis investment ranges from low-level code items or ob-\njects through to higher level business objects. However, the\nstructure imposed by designers and developers of software\nsystems are, in general, not suitable for continued change\nand evolution. Part of the reason for this is that during de-\nvelopment it is difficult, or even impossible, to predict how\nthe system is going to evolve. The fact that the software\nmust continually change over time, or become increasingly\nless useful, was emphasised by Lehman [1]. He also pointed\nout that the structure of evolving software will degrade un-\nless remedial action is taken. This has also been confirmed\nand shown visually by Burd and Munro [4]. An important\naspect of this loss of structure is that business knowledge\nencapsulated within the system becomes fragmented, and\nany changes made as a result of new business initiatives be-\ncome difficult to implement and hence may mean a loss of\nbusiness opportunities.\nThe size and complexity of commercial applications\nprobably present the greatest difficulty that maintainers face\nwhen making changes to their applications. To assist the\ncomprehension process, maintainers need timely and se-\nlective information with regard to their programs. Bigger-\nstaff [2, 3] and Rich and Wills [9] carried out research on\ndesign recovery, where the software architecture was repre-\nsented using techniques such as data-flow graphs, control-\nflow graphs, call graphs, structure diagrams and cross ref-\nerence tables. Although these representations are useful\nfor small programs, little attempt has been made towards\nachieving abstraction in order to simplify the representation\nand allow generalisation. A deeper analysis\u2014for example\nusing dominance relations on call graphs [7]\u2014of some of\nthese representations can lead to a greater understanding of\nthe code [5].\nThe study of software evolution has been identified as a\ncritical aspect of ensuring that the maintainability of soft-\nware applications is retained or even enhanced. Not only\ndoes it provide an abstraction of the information required\nfor the comprehension process, but it also shows the evolu-\ntionary path of a software application thus enabling a main-\ntainer to evaluate changes based on more evidence. For in-\nstance, errors identified can be first investigated with regard\nto those areas in the software which have previously been\nshown to be at fault. Furthermore, the studies of evolution\ncan identify specific locations in the software where consid-\nerable maintenance has been performed and therefore can\nbe used in the targeting of preventative maintenance.\nThe Release project has identified that the calling struc-\nture of the code is one of the most frequently used structures\nwithin source code as a mechanism for gaining an under-\nstanding of that code. This research has also highlighted\nthat this calling structure is also the most likely starting\npoint which maintainers will use when initiating the com-\nprehension process of code that is unfamiliar to them. Thus\nas a means of making the comprehension process of evolu-\ntion accessible to maintainers these familiar constructs are\nadopted as a means of visually representing the code.\nThis paper will describe an approach which has been\nused to study commercial applications. The problems (such\nas problems writing tools to process this language) that have\nbeen identified through this study and the preliminary re-\nsults that have been obtained are also described.\nThe language which is being studied is the user language\nfrom a database system known as \u2018Model 204\u2019, first pro-\nduced by the Computer Corporation of America1 in 1965,\nand further developed since then. The user language is used\nto construct database queries and to provide user interac-\ntion. It is more than a query language, as it can be used to\nwrite general-purpose programs.\nSection 2 describes the means by which the calling struc-\nture of a program is extracted from the source. In section 3,\nthe process for determining dominance trees is outlined.\nResults and conclusions are presented in sections 4 and 5\nrespectively.\n2. Call-Graph Extraction\nThe overall approach adopted within Release is through\na stepwise method. The first of these steps involves the gen-\n1http:\/\/www.cca-int.com\/\neration of a call graph. The objective of this step is to iden-\ntify the calling structure of the code on a procedural basis.\nThis step consists of two tasks. These are:\nCheck preconditions for producing a call graph The\ngeneration of a true calling structure of the software\nrelies on each procedural unit being logically distinct\nfrom other procedures. There should be no use of\nconstructs so as GO TOs or \u2018fall through\u2019 to other\nprocedures (as is common in COBOL). If any of\nthese conditions do not hold then the code should be\nrestructured before the call graph is generated.\nGenerate the \u2018Perform\u2019 graph A perform graph is con-\nstructed from the call graph for each procedural unit.\nFor each call in a procedural unit, a link is made be-\ntween the calling and called procedural unit. These\ncaller\/callee relationships are referred to as the call\ngraph pairs. Where more than one call is issued to a\nparticular procedural unit within one procedural unit,\nthen the duplicate call is recorded numerically. A call\ngraph is a call-directed graph (CDG). A call-directed\ngraph of a code module is formally defined as a di-\nrected graph \u0000\u0002\u0001\u0004\u0003\u0006\u0005\u0006\u0007\t\b\u000b\n\r\f\u000f\u000e where \b\u0010\u0005\u0012\u0011\u0014\u0013\u0016\u0015\u0017\u0015 is\nthe union of \u0011 , the set of the entry procedural unit(s),\nand \u0015\u0017\u0015 , the set of all procedural units, and \f is the\ncall relation \u0007\t\u0011\u0016\u0013\u0018\u0015\u0017\u0015\u0019\u000eff\u001a\u0018\u0015\u0017\u0015 .\nCall-graphs are represented in the \u2018CLL\u2019 file\nformat; each line in a CLL file is of the form\n\u201cparent : child\u201d, where parent and child\nare the two nodes connected by a directed edge.\nThe process of call-graph-extraction is done by pars-\ning the source code (using a parser generated by the Bi-\nson parser generator). This section describes the process in\nmore detail.\n2.1. Source Files\nOne of the first problems of analysing software for evo-\nlution is finding a suitable parser. This project involves\nanalysing Model 204, a language for which there are no\nsuitable parsers available (the only previously known tool\nis the interpreter used by the database system itself). There-\nfore it was decided that the most appropriate solution was\nto build a parser to extract the appropriate constructs.\nThe Model 204 source files from each release have been\nconcatenated into a single file, numbered according to re-\nlease sequence number. Source programs have the format\nshown in figure 1.\n2.2. Call-Graph Extraction Methods\nThis section describes the means by which call graphs\nare extracted from source files.\nPreamble Including global variable declarations, file con-\ntrol commands, etc. (optional).\nMain Program of the form:\nBEGIN\nMain program statements\nEND\nProcedure (Subroutine) Definitions (optional); of the\nform\nFOO: SUBROUTINE or\nSUBROUTINE FOO(%BAR IS type,. . .)\n. . .\nEND SUBROUTINE name \u0000\u0002\u0001\u0004\u0003\nFigure 1. Format of Source Files\nInitially, the calling structure of source was determined\nmanually [8]. These pilot studies highlighted the benefits of\nthe analysis process for the study of evolution. A number of\nimportant points have been identified from this study:\n\u0005 The process provided essential information to main-\ntainers that they would not have otherwise been aware\nof. From interviewing maintainers of these commer-\ncial applications, it was clear that in some instances\nthe implementation approach that was adopted by the\nmaintainer would not have been considered if they\nwere able to see the consequence of a specific change.\n\u0005 The manual approach was costly in terms of time and\nprone to errors; for commercial use the approach must\nbe automated to prevent these problems and produce\ntimely information.\n\u0005 Earlier feedback would be more beneficial. The\nmanual approach analysed only completed system\nchanges. To maximise the benefit of the approach what\nis needed is daily feedback on changes. In this way\nmaintenance approaches can be adjusted depending on\nthe resulting evolutionary trend. Thus it is proposed\nto use the automated system to analyse each nightly\nbuild. However, this intensifies the problems experi-\nenced with the manual approach highlighted above.\nIn order to increase the efficiency of this process, an ex-\ntraction tool is in the process of being written. This tool is\nbeing created using the parser-generator Bison, which gen-\nerates an LALR(1) parser from a definition script (using the\nsame input language that YACC accepts). There are sev-\neral issues which have been discovered while writing the\ntool, most of which have been problems with the source\nlanguage and its documentation. Some example problems\nare described in the next section.\n2.2.1 Example Language Problems\nBlock structure According to the language documenta-\ntion2, \u2018IF\u2019 statements have the traditional (nested) syntax,\ngiven here in slightly modified B.N.F. (using C-style com-\nments):\nif statement \u0006 IF condition THEN\nstatements\nelse part opt\nEND IF\nelse part opt \u0006 \/* empty *\/\nelse part opt \u0006 ELSE statements\nelse part opt \u0006 ELSEIF condition THEN\nstatements else part opt\nstatements \u0006 . . . \/* including if statement *\/\ncondition \u0006 . . .\nHowever, figure 2, which contains code taken from re-\nlease 381, line 7839ff, edited for brevity (elisions indicated\nwith \u2018...\u2019), illustrates a nested IF (marked with [*])\nwhich has no corresponding END IF of its own (it is in-\nstead ended with the ELSEIF marked with a \u2018[#]\u2019).\nIF %SALE:TYPE = 1 THEN\n...\nELSEIF %SALE:TYPE = 2 THEN\n...\n[*] IF %DEPT NE %SALE:DEPT THEN\n%ABORT = 24\nCALL ABORT\nELSE\n%QTY = %QTY + %SALE:QTY\n...\n[#] ELSEIF %SALE:TYPE = 9 THEN\n...\nELSE\n...\nEND IF\nFigure 2. A Code Fragment Illustrating a Sin-\ngle \u2018END IF\u2019 Statement Taking The Place of\nMany.\n2.2.2 Comments\nThe language documentation3 indicates that comment lines\ntake the form of an optional label (of the form \u2018FOO:\u2019) fol-\nlowed by an asterisk, and then the text of the comment.\n2\n\u201cYou must end the IF statement with an END IF statement or an END\nBLOCK statement.\u201d [6, page 11-3].\n3[6, page 2-12].\nHowever, in some of the source files, a comment starts af-\nter a statement, in a form not explicitly mentioned in the\ndocumentation. For example:\nEND IF *** end of processing\nThis problem manifested itself when the initial \u2018*\u2019 was\ninterpreted as the multiplication sign, producing a parse er-\nror. In order to get around this problem, multiple asterisks\nare interpreted (in the tokeniser) as beginning comments,\neven if they\u2019re not at the start of a line.\n2.2.3 Example Documentation Problems\nAs documentation is not automatically generated, it is fre-\nquently not kept up-to-date with changes to the code. For\nexample, the CHANGE statement is specified in one part of\nthe documentation as\nCHANGE fieldname\n[= value] TO newvalue\nbut in another as\nCHANGE fieldname [(subscript)]\n= value1 TO value2\nThis conflict was only resolved by referring to examples\nin the source, and turns out to be a mixture of the two:\nCHANGE fieldname [(subscript)]\n[= value] TO newvalue\n3. Dominance Tree Generation\nWhen studying large commercial applications it is nec-\nessary to provide a means of information abstraction, such\nas calling structures, to assist the maintainer in the com-\nprehension process. However, when studying evolution of\nlarge applications this problem becomes even more acute.\nWhen the changes of a considerable number of an appli-\ncation\u2019s versions are being considered then the timely and\naccurate extraction and abstraction of appropriate informa-\ntion becomes essential.\nResearch on the Release project has identified that com-\nmercial applications sometimes have several hundred nodes\nand several thousand arcs. Within Release, studies of up\nto 30 versions of a single software application have been\nconducted. Thus a means of information abstraction is an\nessential aspect of the analysis process if the information\npresented is to be understandable and usable to the main-\ntainer. The dominance tree is used to provide an abstraction\nof the information required to study evolution. The domi-\nnance tree is a way of abstracting the call graph, but in ad-\ndition represents high-level modularisation of the software\napplications through its branches. Each branch of the domi-\nnance tree represents a concept or high level function of the\nsystem.\nThe problem with call graphs for large commercial appli-\ncations is again their size and complexity. Research on the\nRelease project has identified that commercial applications\nsometimes have several hundred nodes and several thousand\narcs. The dominance tree provides an abstraction of this in-\nformation and is thus the second step of the Release method.\nThe objective of this step is to identify the dominance rela-\ntionships between procedural units.\nA dominance tree is created from a call-directed-acyclic-\ngraph (CDAG). Two relationships can be identified between\nthe nodes of the graph. These are strong and direct domi-\nnance [7].\nThis step is composed of three tasks. These are:\nRemove cycles from the call graph Cycles can occur\nwithin the source code between one or more nodes.\nCycles can be removed by collapsing every strongly\nconnected subgraph (those nodes contained within a\ncycle) into one node.\nIdentify entry points Sometimes more than one entry\npoint exists within a single source code module. This\nmeans that a number of sets of dominance tree rela-\ntionships can be identified from a single code module\nfor each of the entry points within the code. Proce-\ndural units within more than a single dominance tree\nshould be marked as special cases for analysis during\nreconstruction.\nGenerate dominance relations The dominance relations\nare obtained in the following way. In a CDAG, a node\n\u0000\u0002\u0001 dominates a node \u0000\u0002\u0003 if, and only if, every path from\nthe initial node \u0004 of the graph to \u0000\u0002\u0003 includes \u0000\u0005\u0001 . In a\nCDAG, a node \u0000\u0005\u0001 directly dominates a node \u0000\u0005\u0003 if, and\nonly if, all the nodes that dominate \u0000\u0005\u0003 dominate \u0000\u0005\u0001 .\nIn a CDAG, there is a relation of strong direct domi-\nnance between the nodes \u0000\u0005\u0001 and \u0000\u0002\u0003 if, and only if, \u0000\u0005\u0001\ndirectly dominates and it is the only node that calls \u0000\u0002\u0003 .\nDominance trees are represented in the CLL for-\nmat, with the extension that lines are of the form\n\u201cparent : child [: {d,s}]\u201d, with d or s repre-\nsenting direct or strong dominance respectively.\nAs with call-graphs, dominance trees were initially ex-\ntracted using manual techniques[8]. Again, manual pro-\ncesses have been automated, leading to an improvement in\nthe time taken to generate dominance trees.\nCall-graphs are converted to dominance trees using a\ntool written in a mixture of Haskell and C4. The tool ac-\ncepts as input a call-graph (in CLL format), and carries out\nthe following steps:\n4A tool, written in C, for converting paths (described later) into domi-\nnance tree was already available.\nCycle Collapsing All nodes involved in a cycle are col-\nlapsed into a single node (optionally containing the\nnames of all the nodes). This is because the follow-\ning steps require acyclic graphs. Cycles are recursively\ncollapsed, until the graph is acyclic. An example is\nshown in figures 3 and 4.\nPath Determination Root nodes in the call graph are iden-\ntified, and then the list of paths from each root node are\ndetermined. This is shown in figure 5.\nDominance Tree Production Path lists are converted to\ndominance trees by considering the possible paths\nfrom a root node to the various other nodes in its tree.\nThe dominance tree for the above-mentioned graphs is\nshown in figure 6.\nD\nB\nFE\nC\nA\nFigure 3. An Example Call-Graph\nD\nB Cycle1[C,E,F]\nA\nFigure 4. A Call-Graph With a Collapsed Cycle\nA A\nB\nD\n[C,E,F]\nCycle1\nD\nFigure 5. Paths in the Call-Graph\nB\ns s\nd\nCycle1\n[C,E,F]\nA\nD\nFigure 6. Dominance Tree\n4. Results\nThe results of the pilot trials and tool development have\nidentified some of the difficulties of supporting the evolu-\ntion process. The development process has highlighted that\nover the lifetime of the software a number of factors are\ncontinually changing. For instance, not only does the soft-\nware under study evolve but the language itself and com-\npany development house styles change. This increases the\ncomplexity of the support tool. However, gains obtained\nfor the availability of such a support tool justify the com-\nmitment for its development.\nIn order to evaluate the suitability of the tool three eval-\nuation criteria are considered. These are speed, accuracy,\nand usability.\nAs the previous system involved at least a partially man-\nual analysis of the software applications, improvements in\nthe operating of the tool based approach are to be expected.\nOn average the speeds of the semi-manual process per ver-\nsion of code was approximately 30 minutes. The operating\nspeed of the tool running on a standard desktop machine for\nthe same software application has now been reduced to less\nthan half a minute. However, the most significant improve-\nment is the accuracy of the information.\nCurrently, the tools are invoked via a Unix-style\ncommand-line interface. Although a more graphical inter-\nface could be developed, the tools operate in a batch style\n(it is not possible, for example, to interact with the parser\nwhile it is processing a program), and could be used as part\nof automatic overnight processing, for which a GUI is not\nsuitable. It would be difficult to justify a claim that, for ex-\nample, a graphical drag-and-drop interface would be more\nproductive or easier to use than the command-line equiva-\nlent. The users at whom the tools is targeted are experts in\nusing the database system for which they develop. This sys-\ntem is primarily accessed through the command line, and so\nthese developers will be familiar with this kind of interface.\nThe output of the tool has so far been a series of static\ndominance trees. The dominance trees are then represented\nusing a graphical representation tool which has been de-\nveloped as part of the Release project. The trees are then\nloaded either individually for detailed analysis or in series to\nallow comparison. To assist the comparison, process nodes\n(representing the procedures) are sorted alphabetically. The\nnodes are then laid out in a tree formation restricting cross-\ning arcs to a minimum.\nParticularly the comparison process has identified a\nnumber of problems. The first and most obvious of these\nproblems is that of space. When a large number of ver-\nsions are represented then it is not possible to represent\nthem with clarity side by side on a screen. The problem\nis currently overcome by printing the results. The second\nand more interesting problem surrounds the change of soft-\nware applications. As indicated above the nodes are laid\nout alphabetically and to reduce crossing arcs. The laying\nout of the nodes in alphabetical order ensures that the trees\nacross versions looked the same. However, when nodes\nare added or deleted through the evolution process then it\nis harder to see the correspondence between the versions.\nFurthermore when additional calls are added between ex-\nisting nodes then it may be necessary to relax the crossing\nlines weighting on the sort algorithm if the ordering of the\nnodes between versions is to be maintained. When signifi-\ncant changes are made throughout the lifetime of a software\napplication then the maintenance of position tends to signif-\nicantly reduce the readability of the resulting visualisations.\nOverall this is a complex problem that requires considerable\nfurther research.\nFinally the results of the analysis of the commercial ap-\nplication seems promising based on the results of the pilot\ntrials, however the results of the commercial use of the tool\nare yet to be completed. In many instances from the trials,\nit has been found that metrics are more suitable to repre-\nsent the overall change process and when specific interest-\ning anomalies are found in the metrics data small sets of the\ndominance trees are then used as a means of further detailed\nanalysis. Thus support for the daily build process can con-\ncentrate on displaying the dominance trees from only the\nprevious couple of days\u2019 builds.\n5. Conclusions\nThe problems associated with software maintenance are\nboth important and difficult to tackle. In particular, in this\npaper, some of the problems of source-code understanding\nhave been outlined, and an approach to their solution has\nbeen described.\nVarious problems associated with building a parser for a\nlittle-known and aged language have been identified. These\ninclude both language and documentation problems. Study-\ning systems which have been changed over many years, as\nis the case with the systems described here, brings further\nproblems, as the programming language has changed, along\nwith the programs. This leads to further complication in the\ngrammars which are required.\nCall graphs (and therefore dominance trees) can be in-\nferred from source code (subject to resolution of the above-\nmentioned problems). This produces an overview of the\nsystem which is useful during program comprehension. It\nis hoped that further work will enable the use of these tools\nduring development work, as a toolkit for developers and\nmaintainers, in order to decrease costs associated with pro-\ngram understanding.\nThe next phase of the project will be to extend the tool\nfor the support for data analysis. This will again need to en-\nsure that appropriate abstraction mechanisms are provided\nto ensure that the maintainers are able to early comprehend\nand identify the important information.\nMore long term research aims concern issues highlighted\nabove such as maintaining placement of nodes. One pro-\nposed solution to this problem revolves around the anima-\ntion of evolution process. Currently the animation of met-\nrics have been attempted and show promising results. How-\never the animation of the dominance trees is a more com-\nplex problem but seems to be worthy of pursuit. Finally it is\nintended to conduct a more detailed analysis of comments,\nfor example to extract meaning from them to support the\nconcept assignment process for branches of the dominance\ntree. This will therefore lead to the first steps of automated\ndocumentation of the evolution process where descriptions\ncan be obtained as to the functional changes of software\nover time.\nReferences\n[1] On understanding law, evolution and conservation in\nthe large program, life cycle. Journal of Systems and\nSoftware, 1:213\u2013221, 1979.\n[2] T. J. Biggerstaff and A. J. Perlis. Software Reusability;\nconcepts and models, volume 1. ACM Press, 1989.\n[3] T.J. Biggerstaff, B.G. Mitbander, and D. Webster. Pro-\ngram understanding and the concept assignment prob-\nlem. Communications of the ACM, 37(5):72\u201383, 1994.\n[4] E.L. Burd, M. Munro, and C. Wezeman. Analysing\nlarge cobol programs: The extraction of reusable mod-\nules. In Proceedings of the International Conference\non Software Maintenance, November 1996.\n[5] A. Cimitile and G. Visaggio. Software salvaging and\nthe call dominance tree. Journal of Systems Software,\n28(2):117\u2013127, 1995.\n[6] Computer Corporation of America, 36-38 Market\nStreet Maidenhead, Berkshire England SL6 8AD.\nModel 204 User Language Manual Parts I and II Ver-\nsion 4 Release 2.0, February 1999.\n[7] Matthew S. Hecht. Flow Analysis of Computer Pro-\ngrams. Elsevier North-Holland, New York, 1977.\n[8] Sonata Pakstiene, Liz Burd, and Malcolm Munro.\nBlack magic recipe for generating dominance trees\nfrom COBOL (or any other programming language)\nsource code. Technical report, Department of Com-\nputer Science, University of Durham, 2000.\n[9] C. Rich and L.M Wills. Recognising a program\u2019s de-\nsign: A graph-parsing approach. 7(1):82\u201389, 1990.\n[10] T. A. Standish. An essay on software reuse. IEEE\nTransactions on Software Engineering, 10(5), 1984.\n"}