{"doi":"10.1109\/TSE.2008.52","coreId":"65302","oai":"oai:dro.dur.ac.uk.OAI2:6248","identifiers":["oai:dro.dur.ac.uk.OAI2:6248","10.1109\/TSE.2008.52"],"title":"Timed automata patterns.","authors":["Dong, J. S.","Hao, P.","Qin, S.","Sun, J.","Wang, Y."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2008-11-01","abstract":"Timed Automata have proven to be useful for specification and verification of real-time systems. System design using Timed Automata relies on explicit manipulation of clock variables. A number of automated analyzers for Timed Automata have been developed. However, Timed Automata lack of composable patterns for high-level system design. Logic-based specification languages like Timed CSP and TCOZ are well suited for presenting compositional models of complex real-time systems. In this work, we define a set of composable Timed Automata patterns based on hierarchical constructs in timed enriched process algebras. The patterns facilitate hierarchical design of complex systems using Timed Automata. They also allow a systematic translation from Timed CSP\/TCOZ models to Timed Automata so that analyzers for Timed Automata can be used to reason about TCOZ models. A prototype has been developed to support system design using Timed Automata patterns or, if given a TCOZ specification, to automate the translation from TCOZ to Timed Automata","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65302.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6248\/1\/6248.pdf","pdfHashValue":"e3e9cd4ba86aea8e97d3a29070e976f88bc71d01","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6248<\/identifier><datestamp>\n      2011-12-02T16:19:55Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Timed automata patterns.<\/dc:title><dc:creator>\n        Dong, J. S.<\/dc:creator><dc:creator>\n        Hao, P.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Sun, J.<\/dc:creator><dc:creator>\n        Wang, Y.<\/dc:creator><dc:description>\n        Timed Automata have proven to be useful for specification and verification of real-time systems. System design using Timed Automata relies on explicit manipulation of clock variables. A number of automated analyzers for Timed Automata have been developed. However, Timed Automata lack of composable patterns for high-level system design. Logic-based specification languages like Timed CSP and TCOZ are well suited for presenting compositional models of complex real-time systems. In this work, we define a set of composable Timed Automata patterns based on hierarchical constructs in timed enriched process algebras. The patterns facilitate hierarchical design of complex systems using Timed Automata. They also allow a systematic translation from Timed CSP\/TCOZ models to Timed Automata so that analyzers for Timed Automata can be used to reason about TCOZ models. A prototype has been developed to support system design using Timed Automata patterns or, if given a TCOZ specification, to automate the translation from TCOZ to Timed Automata.<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        IEEE transactions on software engineering, 2008, Vol.34(6), pp.844-859 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2008-11-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6248<\/dc:identifier><dc:identifier>\n        issn:0098-5589<\/dc:identifier><dc:identifier>\n        doi:10.1109\/TSE.2008.52<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6248\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/TSE.2008.52<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6248\/1\/6248.pdf<\/dc:identifier><dc:rights>\n        \u00a92009 IEEE. This material is presented to ensure timely dissemination of scholarly and technical work. Copyright and all rights therein are retained by authors or by other copyright holders. All persons copying this information are expected to adhere to the terms and constraints invoked by each author's copyright. In most cases, these works may not be reposted without the explicit permission of the copyright holder\\ud\n\\ud\nPersonal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:0098-5589","0098-5589"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2008,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n09 December 2009\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nDong, J. S. and Hao, P. and Qin, S. and Sun, J. and Wang, Y. (2008) \u2019Timed automata patterns.\u2019, IEEE\ntransactions on software engineering., 34 (6). pp. 844-859.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/TSE.2008.52\nPublisher\u2019s copyright statement:\n2009 IEEE. This material is presented to ensure timely dissemination of scholarly and technical work. Copyright and\nall rights therein are retained by authors or by other copyright holders. All persons copying this information are\nexpected to adhere to the terms and constraints invoked by each author\u2019s copyright. In most cases, these works may\nnot be reposted without the explicit permission of the copyright holder Personal use of this material is permitted.\nHowever, permission to reprint\/republish this material for advertising or promotional purposes or for creating new\ncollective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in\nother works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n09 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nPublished version \n \nCitation for published item: \nDong, J. S. and Hao, P. and Qin, S. and Sun, J. and Wang, Y. (2008) 'Timed automata \npatterns.', IEEE transactions on software engineering., 34 (6). pp. 844-859. \n \nFurther information on publisher\u2019s website: \nhttp:\/\/dx.doi.org\/10.1109\/TSE.2008.52 \n \nPublisher\u2019s statement: \n\u00a92009 IEEE. This material is presented to ensure timely dissemination of scholarly and \ntechnical work. Copyright and all rights therein are retained by authors or by other copyright \nholders. All persons copying this information are expected to adhere to the terms and \nconstraints invoked by each author's copyright. In most cases, these works may not be \nreposted without the explicit permission of the copyright holder \n \nPersonal use of this material is permitted. However, permission to reprint\/republish this \nmaterial for advertising or promotional purposes or for creating new collective works for \nresale or redistribution to servers or lists, or to reuse any copyrighted component of this work \nin other works must be obtained from the IEEE. \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nTimed Automata Patterns\nJin Song Dong, Ping Hao, Shengchao Qin, Jun Sun, and Wang Yi\nAbstract\u2014Timed Automata have proven to be useful for specification and verification of real-time systems. System design using\nTimed Automata relies on explicit manipulation of clock variables. A number of automated analyzers for Timed Automata have been\ndeveloped. However, Timed Automata lack composable patterns for high-level system design. Specification languages like Timed\nCommunicating Sequential Process (CSP) and Timed Communicating Object-Z (TCOZ) are well suited for presenting compositional\nmodels of complex real-time systems. In this work, we define a set of composable Timed Automata patterns based on hierarchical\nconstructs in time-enriched process algebras. The patterns facilitate the hierarchical design of complex systems using Timed\nAutomata. They also allow a systematic translation from Timed CSP\/TCOZ models to Timed Automata so that analyzers for Timed\nAutomata can be used to reason about TCOZ models. A prototype has been developed to support system design using Timed\nAutomata patterns or, if given a TCOZ specification, to automate the translation from TCOZ to Timed Automata.\nIndex Terms\u2014Timed Automata, timed patterns, TCOZ, UPPAAL.\n\u00c7\n1 INTRODUCTION\nSPECIFICATION and verification of real-time systems areimportant research topics that have practical implica-\ntions. A popular approach for specifying real-time systems\nrelies on the graphical notation Timed Automata [2], [35].\nTimedAutomata are powerful in designing real-timemodels\nwith explicit clock variables. Real-time constraints are\ncaptured by explicitly setting\/resetting clock variables. A\nnumber of mechanized verification support for Timed\nAutomata have proven to be successful (e.g., UPPAAL,\nKRONOS, TEMPO, RED, and Timed COSPAN). However,\ndesigning and verifying real-time systems is becoming an\nincreasingly difficult task due to thewidespread applications\nand increasing complexity of such systems. High-level\nrequirements for real-time systems are often stated in terms\nlike deadline, time-out, and wait until, partly evidenced by the\ncase studiespresented in [31], [16], [13], [34], [19]. In industrial\ncase studies of real-time system verification, system require-\nments are often structured into phases, which are then\ncomposed sequentially, in parallel, alternatively, etc. [25],\n[32]. Unlike Statechart or process algebras, Timed Automata\nlack high-level composable patterns (besides parallel com-\nposition) forhierarchicaldesign.TimedAutomatausersoften\nneed tomanually cast those terms into a set of clock variables\nwith carefully calculated clock constraints. The process is\ntedious and error prone.\nProcess algebras, on the other hand, are known for their\nbottom-up composibility, which is important to fight against\nthe complexity of the system design. In the literature, a\nnumber of language-based process algebras have proven to\nbe useful for specifying complex hierarchical real-time\nsystems. Timed Communicating Sequential Processes\n(TimedCSPs [40]), which extend the classic CSP [27], support\na rich set of compositional constructs to capture system\nrequirements, e.g., time-out, timed interrupt, timed-event\nprefixing, etc. Together with compositional constructs like\nexternal\/nondeterministic choice, recursion, and interrupt,\nTimed CSP offers a powerful mechanism for designing\ncomplex real-time systems. Timed Communicating Object-Z\n(TCOZ [36]) is an integrated high-level formal specification\nlanguage that builds on the strengths of Timed CSP and\ncombines it with Object-Z (OZ) [17] for modeling data and\nfunctional aspects of complex systems. In addition, new\ncompositional constructs have been introduced, e.g., dead-\nline andwait until. Thedownside of being expressive is that it\nis highly nontrivial to mechanically validate TCOZ models.\nFor safety-critical systems, exposing a possible violation of\nsystem requirements at the specification level is very\nimportant, especially for hard timing constraints. The\nchallenge of verifying time-enriched process algebras has\nlong been recognized. A model checker named FDR [39] has\nbeen developed to verify CSP. However, there is no\nsatisfactory verification support for either Timed CSP or\nTCOZ.\nBased on the time-proven compositional constructs in\nTimed CSP\/TCOZ, we develop a set of composable time\npatterns for Timed Automata which facilitates high-level\nsystem design using Timed Automata. The patterns cover a\nlarge class of common real-time behavior patterns and yet\ncan be composed to form new useful patterns. The patterns\nare formally defined. By following the formal semantics\n(which are originated from their images in time-enriched\nprocess algebras), a high-level design composed of multiple\ntimed patterns can be flattened to ordinary Timed Auto-\nmata automatically. Thus, existing tools like UPPAAL can\nbe used to verify time patterns with little computational\noverhead. On the other hand, the patterns allow a\n844 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\n. J.S. Dong, P. Hao, and J. Sun are with the School of Computing, National\nUniversity of Singapore, 3 Science Drive 2, Singapore 117543, Republic of\nSingapore. E-mail: {dongjs, haoping, sunj}@comp.nus.edu.sg.\n. S. Qin is with the Department of Computer Science, Durham University,\nScience Laboratories, South Road, Durham DH1 3LE, UK.\nE-mail: shengchao.qin@durham.ac.uk.\n. W. Yi is with the School of Scince and Engineering, North Eastern\nUniversity, P.R. China ans the Department of Information Technology,\nUppsala University, Box 337,751 05, Uppsala, Sweden.\nE-mail: yi@it.uu.se.\nManuscript received 10 Aug. 2007; revised 12 May 2008; accepted 19 June\n2008; published online 23 July 2008.\nRecommended for acceptance by R. Cleaveland.\nFor information on obtaining reprints of this article, please send e-mail to:\ntse@computer.org, and reference IEEECS Log Number TSE-2007-08-0239.\nDigital Object Identifier no. 10.1109\/TSE.2008.52.\n0098-5589\/08\/$25.00 \u0002 2008 IEEE Published by the IEEE Computer Society\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nsystematic translation from Timed CSP\/TCOZ models to\nTimed Automata so that the state-of-art verification\nmechanism for Timed Automata can be used to validate\nTimed CSP\/TCOZ models.\nThis work identifies the strengths and weaknesses of\nTimed Automata and timed process algebras and develops\nnew techniques for system modeling, as well as verification.\nInstead of comparing the expressiveness of the two\nnotations (which is of theoretical interest and has been\npartially done in [38]), we focus on developing practical\ntechniques that are beneficial to both TCOZ\/Timed CSP\nand Timed Automata users. A closely related work is the\nhierarchical Timed Automata proposed in [11]. The notion\nof hierarchical Timed Automata in [11] is based the notion\nof Statechart. Two kinds of Timed Automata composition\nhave been discussed, i.e., named and-states and or-states. In\nour work, the common time patterns introduced in Timed\nCSP and beyond have been formally defined, which serve\nas a library of building blocks for complex real-time\nsystems. This work is also related to works on verification\nof time-enriched process algebra. In [15], Dong et al. have\ndeveloped a model checker for Timed CSP based on\nconstraint solving. In Brooke\u2019s PhD dissertation [8], a\npreliminary PVS encoding of Timed CSP was presented\nwhich relies heavily on user interaction. Another closely\nrelated area of research is Hoenicke and Olderog\u2019s work on\nthe integration of CSP, OZ, and Duration Calculus (DC)\n(named CSP-OZ-DC [28]). By transforming the DC part of a\nsystem model into a Timed Automaton, CSP-OZ-DC\nbenefits from Timed Automata\u2019s tool support. For instance,\nUPPAAL has been used to verify CSP-OZ-DC models. In\nour work, UPPAAL is used to verify TCOZ models.\nHowever, our main contribution is the development of the\ngeneric Timed Automata patterns, i.e., we not only borrow\nTimed Automata\u2019s tool support for TCOZ verification but\nalso lend TCOZ\u2019s hierarchical constructs to facilitate\nsystematic Timed Automata designs. Furthermore, the\nwork in [28] mainly focuses on the smooth integration of\nthe underlying semantic models of CSP, OZ, and DC and its\nuse for verifying properties of CSP-OZ-DC specifications.\nAnother related formalism for modeling real-time systems\nis TRIO [20]. This notation uses a notion of interface\ndiagram that is different from the Timed-CSP-featured\nTCOZ notation in modeling dynamic behaviors. TRIO has\nbeen compared to TCOZ [36]. Similar to our work, some\nother real-time formalisms have been translated or pro-\njected to other formalisms for model-checking [29], [23].\nThis work is also related to works on compositional\nmodeling of real-time systems [4], [3], [41], [22] and works\non specification patterns in general [18], [30].\nThis paper is a revised and extended version of our\nconference paper [14], in which the link between Timed\nAutomata and TCOZ has been investigated. A few timed\npatterns have been briefly introduced to show our initial\nideas of reusing Timed Automata\u2019s tool support to verify\nTCOZ models. This paper substantially extends [14] with a\nrange of common timed patterns, as well as a formal\ntransition from TCOZ to Timed Automata and its correct-\nness proof. We further enhance our previous work with\nillustrative examples, as well as a complex case study,\nwhich demonstrate the applicability of our approach. The\nremainder of the paper is organized as follows: Section 2\nbriefly introduces the relevant features of TCOZ and Timed\nAutomata. Section 3 presents our main contribution, i.e., a\nset of composable Timed Automata patterns with formal\nsemantics. We also demonstrate how new patterns can be\ncomposed from the existing ones. Section 4 shows how\nTCOZ or Timed CSP users may benefit from our patterns,\nby defining a formal translation from TCOZ to Timed\nAutomata. A JAVA application for automating the projec-\ntion is briefly discussed. Section 5 shows how Timed\nAutomata users benefit from the patterns. We demonstrate\na hierarchical Timed Automata design using a railcar\nsystem. Section 6 concludes this work. Throughout the\npaper, a process means a TCOZ or Timed CSP process and\nautomata refer to Timed Automata unless otherwise stated.\n2 BACKGROUND\n2.1 Timed Automata\nTimed Automata were proposed in [2] as an extension of\nthe automata-theoretic approach to the modeling of real-\ntime systems. Since then, the theory and verification tool\nsupport of Timed Automata has been an intensive field of\nresearch in computer science. A Timed Automaton is a\nfinite automaton equipped with a finite set of clocks. Clocks\nare continuous real-valued functions of time that precisely\nrecord the time elapsed. All clocks advance at the same\npace. Real-time system behaviors are captured using Timed\nAutomata by explicitly resetting clocks and comparing a\nclock reading with constants.\nDefinition 1 (Timed Automaton). A Timed Automaton A is a\n7-tuple \u00f0S; init; F ;\u0002; C; Inv; T \u00de, where S is a finite set of\nstates, init 2 S is an initial state,1 F \u0002 S is a set of final\nstates, \u0002 is a set of actions\/events, C is a finite set of clocks,\nInv is a proposition assignment function that, for each state,\ngives a proposition true at the state, and T : S \u0003 \u0002\u0003 2C \u0003\n\u0003\u00f0C\u00de \u0003 S is the transition relation. A transition \u00f0s; a; \u0002; \u0003; s0\u00de\nrepresents a transition fromstate s to state s0 on eventa. The set\u0002\ngives the clocks to be reset with this transition and \u0003 is a clock\nconstraint overC that specifieswhen the switch is enabled.\u0003\u00f0C\u00de\nis a set of clock constraints that is defined by the following\ngrammar: \u2019 :\u00bc truejx \u0004 cjc \u0004 xjx < cjc < xj\u20191 ^ \u20192, where\nx is a clock and c is a real number.\nNote that F might be empty if the Timed Automata never\nterminates (i.e., no deadlock state). The semantics of a Timed\nAutomaton is defined as a transition system. A run of the\ntimed automaton starts with the initial state. The control may\nremain at a state s as long as the state Inv\u00f0s\u00de is not violated. A\ntransition \u00f0s; a; \u0002; \u0003; s0\u00de is enabled if and only if the control is at\nstate s, the guard condition \u0003 is satisfied (by the valuation of\nthe clocks), and the event a is enabled. The transition is\nunguarded if \u0003 is true. After taking the transition, the control\nmoves to state s0 and the clocks in \u0002 reset.\nExample. The following shows a sample Timed Automaton\nspecifying a railcar door (the railcar system will be\nspecified in Section 5).\nDONG ET AL.: TIMED AUTOMATA PATTERNS 845\n1. If there were multiple initial states, a unique initial state is created with\ninternal transitions to the ordinary initial states.\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nFor the sake of readability, the states are labeled with\nnames, e.g., Open, Close, and ToOpen. We assume that\nthe door can be closed instantly and, hence, there is no\nstate named ToClose. Initially, the control is at state\nClose, indicated by the double-lined circle. The transition\nis fired once an input is received over channel open (as\nthe transition is unguarded), the control goes to state\nToOpen, and clock x is reset. Within 2 seconds\n(constrained by the state invariant), the control goes to\nstate Open. An output on the channel conf takes place\nalong with the transition. The door remains open for\n10 seconds, i.e., passengers have 10 time units for\nboarding, and, then, the control goes to state Close.\nA Timed Automata specification may consist of a\nnetwork of Timed Automata. A state in the product of\ntwo Timed Automata is a pair of states, each representing\nthe progress one of the Timed Automata has made so far. A\ntransition in the product is either a local transition of either\nautomaton or a synchronization between the two compo-\nnents. The synchronization is locking; for an input and\noutput pair, a component can input\/output if and only if\nthe other component can output\/input. The following\nformally defines the parallel composition. For simplicity,\nwe assume that there are no common clock variables. Note\nthat parallel composition is the only Timed Automata\npattern in the original proposal of Timed Automata [2].\nDefinition 2 (Parallel Composition). Let Ai \u00bc\n\u00f0Si; initi; Fi;\u0002i; Ci; Invi; Ti\u00de where i 2 f1; 2g be two Timed\nAutomata. The parallel composition of A1 and A2 is\npara\u00f0A1; A2\u00de \u00bc \u00f0S1 \u0003 S2; \u00f0init1; init2\u00de; F1 \u0003 F2;\u00021 [ \u00022;\nC1 [ C2; Inv; T \u00de;\nw h e r e 8\u00f0s1; s2\u00de : S1 \u0003 S2 \u0005 Inv\u00f0\u00f0s1; s2\u00de\u00de \u00bc Inv1\u00f0s1\u00de ^\nInv2\u00f0s2\u00de and T is the smallest transition relation satisfying\nthe following conditions:2\n. If \u00f0s; a; \u0002; \u0003; s0\u00de 2 Ti ^ a 62 \u00023\u0006i where i 2 f1; 2g, then\n\u00f0\u00f0s; t\u00de; a; \u0002; \u0003; \u00f0s0; t\u00de\u00de 2 T .\n. If \u00f0s1; a; \u0002; \u0003; s2\u00de 2 Ti and \u00f0s01; a; \u00020; \u00030; s02\u00de 2 T3\u0006i,\nthen \u00f0\u00f0s1; s01\u00de; a; \u0002 [ \u00020; \u0003 ^ \u00030; \u00f0s2; s02\u00de\u00de 2 T .\nThe indexed parallel composition of multiple automata is\nwritten as para\u00f0A1; A2; . . . ; An\u00de, where A1; . . . ; An are timed\nautomata.\nBy definition, parallel composition is communicative and\ndistributive tracewise. A number of Timed Automata\nverifiers based on the model checking technique have been\ndeveloped. In this work, we focus on the popular UPPAAL\n[33]. UPPAAL is a tool for the modeling, simulation, and\nverification of real-time systems. It consists of three main\nparts: a system editor, a simulator, and a model checker.\nThe system editor provides a graphical interface for the tool.\nTypically, a system description consists of a set of instances\nof Timed Automata declared from process templates and of\nsome global data, such as global clocks, variables, and\nsynchronization channels. The simulator is a validation tool\nthat enables the examination of possible dynamic execu-\ntions of a system. The model checker verifies invariants and\nbounded liveness properties by exploring the symbolic state\nspace of a system, i.e., reachability analysis in terms of\nsymbolic states represented by constraints. The model\nchecking engine of UPPAAL is designed to check a\nrestricted subset of Timed CTL [1] formulas for networks\nof Timed Automata. Note that Timed Automata in\nUPPAAL extend the original one [2] with handy constructs\nlike urgent states and committed states. No time elapsing is\nallowed at an urgent state, i.e., an urgent state is labeled\nwith an additional invariant that the control cannot reside at\nthe state. We write \u00f0s; urgent\u00de 2 Inv to mean that state s is\nurgent. In the following, states in the timed patterns may be\nmarked as urgent states so as to make it easier to prove the\nsoundness of the patterns and to simplify the flattened\nTimed Automata (see later examples). An urgent state is\ndrawn as a circle with a \u201cU\u201d inside.\n2.2 Time Communicating Object Z\nA number of time-enriched process algebras have been\nproposed. In this work, we focus on TCOZ [36], which,\ncompared to others, contains a larger set of compositional\nconstructs. TCOZ is designed to present a complete and\ncoherent specification of systems with not only complicated\ncontrol flows but also complex data and functional require-\nments. It is essentially a blending of OZ with Timed CSP, for\nthemost part preserving them as proper sublanguages of the\nblended notation. TCOZ is novel in that it includes timing\nprimitives, properly separates process control and data\/\nalgorithm issues, fully integrates notions of refinement from\nboth languages, supports themodeling of truemultithreaded\nconcurrency, and distinguishes the notion of active and\npassive objects. In the following, we walk through the main\nfeatures of TCOZ using an illustrative example. A detailed\nintroduction to TCOZ and its Timed CSP and OZ features\nmay be found in [36].\nExample. Fig. 1 presents a TCOZ specification of a timed\nmessage queue. It contains a single class named\nTimedQueue. The anonymous schema called state schema\nidentifies the data space of the class. In particular, the\nvariable item is a sequence of messages. MSG is an\nuninterpreted data type. in and out of reserved type\nchan identifies the communication interfaces of this\nclass, i.e., in and out are channels connecting objects of\nthis class to its environment. Channels that share the\nsame base name in different classes are connected\nimplicitly. Tl, Tj, and To are time constants which are\nused to constrain the duration of a data operation. The\nschema named INIT contains the predicate that identifies\nthe initial data state, i.e., items is empty. The two\nschemas Add and Del are operation schemas. They define\nthe data operations that may update the valuation of the\ndata variables. The predicate part of an operation (the part\nunder the horizontal line) specifies an operation using a\npredicate composed of primed and unprimed versions of\nthe data variables, as well as inputs\/outputs. The primed\nvariables denote the valuation of the variable after the\noperation. In particular, the predicate part of operation\n846 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\n2. In UPPAAL, a pair of input and output results in a silent transition.\nSynchronization among multiple parties is mimicked using the notion of\ncommitted states.\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nAdd means that the sequence of messages after the\noperation should be the original sequence of messages\nfollowed with the input. The remaining part is a set of\nprocess definitions which specifies the dynamic behavior\nof objects of this class. A process is defined by an\nequation. The left-hand side is the process name, e.g.,\nJoin, Leave, and Main. Note that b\u00bc means \u201cis defined\nas.\u201d The right-hand side is the process expression that\ndefines the process. For instance, process Join behaves\nas follows: after getting an input i from channel in (the\npart \u00bdi :MSG\u0007 is a guard condition saying that i must be\nof type MSG), the operation Add is performed within\nTj time units (constrained by the DEADLINE expression).\nThe Leave operation specifies that if the sequence items\nis not empty \u00f0items 6\u00bc ;\u00de, the first element in items\n\u00f0head\u00f0items\u00de\u00de shall be sent over channel out and, then,\noperation Del is performed to remove this element from\nitems in Tl time units. The process named MAIN\nidentifies the behavior of instances of the class after\ninitialization. In particular, the Main process is defined\nas a recursion (as a \u0004 function). The process construct tu\nmeans choice and .fTog means time-out. The process\nreads as \u201cthe system may either behave as prescribed by\nJoin or Leave or, if nothing happens in To time units,\nthen the system performs operation Del in Tl time units\nand then repeats from the beginning.\u201d If no input or\noutput is performed in To time units, then the first\nmessage is lost.\nIn this work, we focus on the process aspects of TCOZ,\nwhich borrows and extends the modeling power of Timed\nCSP. Table 1 shows a list of process constructs in TCOZ.\nSTOP denotes a process that deadlocks and does nothing.\nSKIP denotes a process that terminates successfully. Process\nWAIT t delays the system for exactly t time units. Process\ne! P is initially willing to engage in event e and behaves\nas P afterward. A process e@t! P \u00f0t\u00de behaves just like e!\nP except that the engage time of e is recorded in t. The\nevent e can be a channel communication of the form c!a or\nc?a. In order to capture timing requirements naturally,\nTCOZ supports common timing constraints like deadline\nand wait until. Process P \u0005DEADLINE t is constrained to\nterminate within t time units. The WAITUNTIL operator is a\ndual to DEADLINE. Process P \u0005WAITUNTIL t behaves as P\nbut will not terminate before t time units elapse. If P\nterminates early, it idles until t time units elapse. Processes\nmay be compositional. The sequential composition P ;Q\nbehaves as P until it terminates and then behaves as Q. An\nexternal choice is written as P tu Q. Often, external choices\nare guarded by prefixing or conditionals. The internal\nchoice P uQ behaves as either P or Q nondeterministically.\nThe parallel composition of two processes is written as\nP j\u00bdE\u0007jQ, where E is a set of events. Events in E are\nsynchronized by P and Q. If E is the empty set, the two\nprocesses interleave, written as PkjQ. Process P . ftgQ\nbehaves as P if P makes a move before t time units elapse;\notherwise, Q takes control. P 4 e! Q behaves as P until\nevent e is engaged and, then, P is interrupted and Q takes\ncontrol. Process P 4 ftgQ is called timed interrupt. It\nbehaves as P until t time units elapse and then switches\nto Q. Both interruptions are preemptive. Recursion is\ndefined as a \u0004 function. The semantics of recursion is\ndefined as Tarski\u2019s weakest fixed point. It is known that\nunbounded recursion in CSP (and, therefore, Timed CSP\nand TCOZ) may result in irregular languages. Therefore, we\nrestrict ourselves to tail recursion, i.e., a special case of\nrecursion in which only the last operation of a process is a\nrecursive call.\nDONG ET AL.: TIMED AUTOMATA PATTERNS 847\nFig. 1. Timed message queue specification.\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \n3 TIMED AUTOMATA PATTERNS\nHigh-level real-time system requirements are often stated\nusing terms like deadline, time-out, andwait until, which can be\nregarded as common timing constraint patterns. TCOZ,\ndesigned to capture high-level system requirements, has a\nrich set of hierarchical constructs that capture those common\ntiming patterns. In contrast, Timed Automata users often\nneed tomanually cast those timing patterns into a set of clock\nvariables with carefully calculated clock constraints. In this\nsection, a rich set of composable Timed Automata patterns\nis defined formally in order to facilitate high-level system\ndesign using Timed Automata. Established compositional\npatterns introduced in the classic CCS, CSP, Timed CSP,\nand TCOZ are presented. The usefulness of the composi-\ntions is evidenced by early case studies on using those\nformalisms for system specification and analysis [31], [16],\n[13], [34]. Because we aim for efficient verification and\ncompositional modeling, the patterns are designed to be\nsimple, intuitive, and congruent to timed process algebra\noperators.\n3.1 Patterns\nIn the following, the Timed Automata patterns are\nintroduced one by one. First, the formal definition is\npresented, followed by an intuitive graphic presentation.\nGraphically, an automaton is abstracted as a triangle. The\nleft vertex of the triangle or a circle attached to the left\nvertex represents the initial states. The right edge represents\nthe final states. The parallel composition of two automata is\nrepresented as two triangles that are side by side. In the\nfollowing, \u0005 denotes an internal unobservable transition.\nFor simplicity, a function\/relation is interpreted as a set of\ntuples (as in the Z language [43]). We assume that, for any\nautomaton A \u00bc \u00f0S; init; F ;\u0002; C; Inv; T \u00de, the domain of Inv\nand T is always restricted to S. Note that not all of the\npatterns are essential as some of them can be generated by\ncomposing other patterns. We will thus introduce the\nfundamental ones and then a set of derived ones.\nDefinit ion 3 (Event Prefixing) . Let A \u00bc\n\u00f0S; init; F ;\u0002; C; Inv; T \u00de be a Timed Automaton. Let a be an\nevent. The event-prefixing pattern, i.e., the Timed Automaton\nin which e precedes any action of A, written as\neventprefix\u00f0a;A\u00de, is\n\u00f0S [ finit0g; init0; F ;\u0002 [ fag; C; Inv [ f\u00f0init0; true\u00deg;\nT [ f\u00f0init0; a; ;; true; init\u00deg\u00de;\nwhere init0 is a fresh state.\nEvent prefixing is considered one of the most commonly\nused basic patterns, e.g., a task is preceded by some event.\nIn the above pattern, event a (which may be a synchroniza-\ntion barrier or variable assignment) must be engaged before\na certain task (which is modeled as A) must be carried out.\nThe fresh state init0 is connected to the initial state in A by a\ntransition labeled with a.\nDefinition 4 (Internal Choice) . Let Ai \u00bc\n\u00f0Si; initi; Fi;\u0002i; Ci; Invi; Ti\u00de where i 2 f1; 2g be two Timed\nAutomata. The internal choice of A1 and A2, written as\nintchoice\u00f0A1; A2\u00de, is\n\u00f0S1 [ S2 [ finit0g; init0; F1 [ F2;\u00021 [ \u00022; C1 [ C2;\nInv1 [ Inv2 [ f\u00f0init0; urgent\u00deg; T 0\u00de;\nwher e init0 i s a f r e sh s t a t e and T 0 \u00bc T1 [ T2 [\nf\u00f0init0; \u0005; ;; true; init1\u00de; \u00f0init0; \u0005; ;; true; init2\u00deg.\nThe above pattern captures nondeterminism, i.e., the\nsystem described nondeterministically behaves as either\nA1 or A2. Nondeterminism allows us to abstract away\nirrelevant details of the system [27]. By introducing a fresh\nstate init0 and connecting init0 to initial states of both\nautomata by unguarded transitions labeled with \u0005 , the\nchoice is made internally and, thus, nondeterministically.\nBecause internal choice is symmetric and associative, we\nwrite intchoice\u00f0A1; A2; . . . ; An\u00de to denote the nondetermi-\nnistic choice among multiple timed automata. Note that\ninit0 is urgent and, thus, no time elapsing is allowed. The\nrule is that only additional states are marked urgent.\nMarking states urgent allows us to systematically simplify\ncomposed timed patterns (see example in Section 3.2).\nDefinition 5 (Recursion). Let A \u00bc \u00f0S; init; F ;\u0002; C; Inv; T \u00de be\na Timed Automaton. Let S0 be a set of states such that S0 \b S.\n848 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\nTABLE 1\nTime-Enriched Process Constructs\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nThe recursion pattern, i.e., the Timed Automaton containing\nrecursive invocation of A at a state in S0, written as\nrecur\u00f0A;S0\u00de, is \u00f0S n S0; init; F n S0;\u0002; C; Inv; T 0\u00de, where\nT 0 \u00bc T [ f\u00f0s; a; \u0002; \u0003; init\u00dej9s0 : S0 \u0005 \u00f0s; a; \u0002; \u0003; s0\u00de 2 Tg.\nRecursion is used to introduce infinite behaviors, which is\ncommonly used for specifying nonterminating reactive\nsystems. Given a timed automaton A and a set of states\nS0 where there is a recursive call, the pattern is constructed\nby diverting all of the transitions to a state in S0 to the initial\nstate. Note that we request that S0 must be a proper subset\nof S so as to prevent divergence. The dotted arrow\nrepresents a transition that originally leads to a state in\nS0. In the resulting automaton, such transitions are\nredirected to the initial state of A. This construction only\nhandles tail recursion. Note that we write recur\u00f0A\u00de to\ndenote recur\u00f0A;A:F \u00de, i.e., the second argument is defaulted\nto be the final states of A.\nDefinition 6 (Delay). Let t be a positive real number. The Timed\nAutomaton that delays the execution by t time units, written\nas delay\u00f0t\u00de, is \u00f0fs1; s2; s3g; s1; fs3g; ;; fxg; Inv; T \u00de, where\nInv \u00bc f\u00f0s1; urgent\u00de; \u00f0s2; x \u0004 t\u00de; \u00f0s3; urgent\u00deg a n d T \u00bc\nf\u00f0s1; \u0005; fxg; true; s2\u00de; \u00f0s2; \u0005 ; ;; x \u00bc t; s3\u00deg.\nThe above pattern is used to delay the execution (of the\nsystem) by exactly t time units, e.g., one of the common\nrequirements for timed systems. We remark that internal\nchoice u, event prefixing a! P , recursion, and WAIT may\nbe regarded as the fundamental blocking of Timed CSP\nprocesses. This is justified by combining previous results on\nderiving a normal form for CSP\/Timed CSP processes. In\n[9], it is proven that all CSP processes can be transformed\ninto a normal form, which composes only internal choices,\nevent prefixing, and process referencing.3 In [12], it is\nproven that the only fundamental building block of Timed\nCSP processes (besides those of CSP) is WAIT. We may thus\nprove that patterns that correspond to Timed CSP operators\ncan be generated from the fundamental ones (by transform-\ning them into the normal form) by combining the above\nresults and proving a congruence theorem. In addition to\npatterns corresponding to Timed CSP constructs, two\nadditional patterns are introduced, namely, waituntil and\ndeadline. The wait-until pattern can be generated by\ncomposing other patterns (as we shall show later), whereas\nthe deadline pattern cannot. Thus, we regard the following\ndeadline pattern as fundamental too. Nonetheless, we give\nthe definitions of patterns corresponding to all TCOZ\noperators for user convenience as well as efficiency reasons,\ni.e., a commonly used pattern may be manually optimized.\nDefinition 7 (deadline). Let A \u00bc \u00f0S; init; F ;\u0002; C; Inv; T \u00de be a\nTimed Automaton. Let t be a positive real number. The\ndeadline pattern deadline\u00f0A; t\u00de is\n\u00f0S [ finit0g; init0; F ;\u0002; C [ fxg; f\u00f0init0; urgent\u00deg\n[ f\u00f0s; inv\u00dejs 2 S ^ inv \u00bc \u00f0Inv\u00f0s\u00de ^ x \u0004 t\u00deg;\nT [ f\u00f0init0; \u0005 ; fxg; true; init\u00deg\u00de;\nwhere init0 is a fresh state and x is a fresh clock.\nThe above pattern is used to capture the requirement that\nsome task must be finished by a certain time. It is more of a\nrequirement than a design. Given a Timed Automaton A, if\nit is constrained to finish within t time units, all states in A\nare labeled with an invariant x \u0004 t in which x is a fresh\nclock, which is reset when the control enters the automaton.\nThe leftmost state is the fresh state init0. The local invariant\nx \u0004 t covers each state of the timed automaton and, thus, A\nmust terminate no later than t time units. This pattern may\nintroduce timelocks [6]. In particular, there might be\ntime-actionlocks (i.e., situations in which neither time nor\naction transitions can be performed) or zeno-timelocks (i.e.,\nsituations in which time is unable to pass beyond a certain\npoint, but actions continue to be performed). Detecting and\nresolving timelocks is a highly nontrivial task (refer to [6]\nfor sufficient conditions and sufficient and necessary\nconditions for timelock-freeness). Nonetheless, we choose\nto introduce this pattern simply because deadline is a\ncommon real-time requirement. We may verify (e.g., using\nthe tool presented in [7] or UPPAAL) that A terminates\nwithin t time units in all circumstances (so as to prevent\ntimelocks). Alternative ways of capturing deadlines are\npresented in [3], [26].\nDefinition 8 (wait until). Let A \u00bc \u00f0S; init; F ;\u0002; C; Inv; T \u00de be\na Timed Automaton. Let t be a positive real number. The wait-\nuntil pattern, written as waituntil\u00f0A; t\u00de, is\n\u00f0S [ finit0; f 0; f 00g; init0; ff 0g;\u0002; C [ fxg;\nInv [ f\u00f0init0; urgent\u00de; \u00f0f 0; true\u00de; \u00f0f 00; x \u0004 t\u00deg; T 0\u00de;\nwhere init0, f 0, and f 00 are fresh states, x is a fresh clock, and\nT 0 \u00bc T [ f\u00f0init0; \u0005; fxg; true; init\u00deg\n[ f\u00f0f; \u0005; ;; x \t t; f 0\u00dejf 2 Fg [ f\u00f0f; \u0005; ;; x < t; f 00\u00dejf 2 Fg\n[ f\u00f0f 00; \u0005 ; ;; x \u00bc t; f 0\u00deg:\nThe above pattern is used to constrain that a certain task\nmust take certain time units to finish. The automaton is\nconstrained to finish its process no earlier than t time units.\nGiven the automaton A, if the process of A finishes earlier\nthan t time units, then the system idles at a fresh state f 00\nuntil exactly t time units elapses. Else if the process of A\ntakes more than (or exactly) t time units, the system\nproceeds to final state f 0 without further waiting. Note that\nthis pattern can be generated from the delay pattern and the\nparallel composition pattern, i.e., it is straightforward to\nprove that waituntil\u00f0A; t\u00de is equivalent to para\u00f0A; delay\u00f0t\u00de\u00de.\nDONG ET AL.: TIMED AUTOMATA PATTERNS 849\n3. Or a chaotic process ? , which is irrelevant.\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nDefinition 9 (External Choice). Let Ai \u00bc\n\u00f0Si; initi; Fi;\u0002i; Ci; Invi; Ti\u00de where i 2 f1; 2g be two Timed\nAutomata. An external choice of A1 and A2, written as\nextchoice\u00f0A1; A2\u00de, is para\u00f0A01; A02\u00de, where\nA01 \u00bc \u00f0S1; init1; F1;\u00021; C1; Inv1; f\u00f0s; \u0005; \u0002; \u0003 ^ x \u0004 0; s0\u00dej\n\u00f0s; \u0005; \u0002; \u0003; s0\u00de 2 T1g [ f\u00f0s; x :\u00bc \u00061; \u0002; \u0003 ^ x \u0004 0; s0\u00dej\n\u00f0s; a; \u0002; \u0003; s0\u00de 2 T1g\u00de\nand\nA02 \u00bc \u00f0S2; init2; F2;\u00022; C2; Inv2; f\u00f0s; \u0005; \u0002; \u0003 ^ x \t 0; s0\u00dej\n\u00f0s; \u0005; \u0002; \u0003; s0\u00de 2 T2g [ f\u00f0s; x :\u00bc 1; \u0002; \u0003 ^ x \t 0; s0\u00dej\n\u00f0s; a; \u0002; \u0003; s0\u00de 2 T2g\u00de;\nwhere x : f\u00061; 0; 1g is a fresh control variable.\nThe above pattern is useful when the choice is resolved by\nthe first action of either A1 or A2. In the composition, the\nsystem may initially take a transition enabled in either A1 or\nA2. An initial state in the composition is a pair of initial\nstates \u00f0init1; init2\u00de, which is labeled transitions from either\ninit1 or init2. Given automata A1; . . . ; An, the indexed\nexternal choice is written as extchoice\u00f0A1; . . . ; An\u00de as\nextchoice is symmetric and associative. As external choice\nis an operator of CSP, by applying the result in [9], it can be\nresolved to a normal form containing only the fundamental\nbuilding blocks.\nDefinition 10 (Sequential Composition). Let Ai \u00bc\n\u00f0Si; initi; Fi;\u0002i; Ci; Invi; Ti\u00de where i 2 f1; 2g be two Timed\nAutomata. The sequential composition of A1 and A2, written\nas seq\u00f0A1; A2\u00de, is\n\u00f0S1 [ S2; init1; F2;\u00021 [ \u00022; C1 [ C2; Inv1 [ Inv2\n[ f\u00f0s; urgent\u00dejs 2 F1g; T \u00de;\nwhere T \u00bc T1 [ T2 [ f\u00f0f; \u0005; ;; true; init2\u00dejf 2 F1g.\nGiven two Timed Automata A1 and A2, the above shows the\nsequential composition. Sequential composition is com-\nmonly used to accomplish two tasks\/jobs in order. By\nlinking the final states of A1 (i.e., the right edge) with the\ninitial state of A2 (i.e., the left vertex), the resulting\nautomaton passes control from A1 to A2 immediately after\nA1 terminates. The transition from a final state in A1 to an\ninitial state in A2 is unguarded and labeled with \u0005 . If A1 is\nnonterminating, the final states in A2 may not be reachable.\nDef in i t i on 11 (T ime Out ) . Le t Ai \u00bc\n\u00f0Si; initi; Fi;\u0002i; Ci; Invi; Ti\u00de where i 2 f1; 2g be two Timed\nAutomata. Let t be a positive real number. The time-out\npattern, written as timeout\u00f0A1; A2; t\u00de, is\n\u00f0S1 [ S2 [ finit0g; init0; F1 [ F2;\u00021 [ \u00022; C1 [ C2 [ fxg;\nInv0; T 0\u00de;\nwhere init0 is a fresh state, x is a fresh clock,\nInv0 \u00bc f\u00f0init0; urgent\u00deg [ f\u00f0init1; Inv1\u00f0init1\u00de ^ x \u0004 t\u00deg\n[ f\u00f0s; Inv1\u00f0s\u00de\u00dejs 2 S1 n finit1gg [ f\u00f0s; Inv2\u00f0s\u00de\u00dejs 2 S2g\nand\nT 0 \u00bc T1 [ T2 [ f\u00f0init0; \u0005 ; fxg; true; init\u00deg\n[ f\u00f0init1\u0005; ;; x \u00bc t; init2\u00deg:\nTime out is a common behavior pattern in real-time\nsystems, which is partially evidenced by different ways\nproposed to model it [21], [5], [40]. The fresh clock x is reset\nalong the transition from the fresh initial state to an initial in\nA1. Each initial state in A1 is constrained to make a move no\nlater than t time units. If the control moves out the initial\nstate before t time units, the system behaves as prescribed\nby A1. Otherwise, after exactly t time units, A2 takes over\nthe control. If A1 may make a move at exactly time t, the\nsystem nondeterministically takes one of the transitions and\nprevents the other from happening. The timed-out pattern\ncan be generated using the external choice pattern and the\ndelay pattern.\nDefinition 12 (Timed Interrupt). Let Ai \u00bc\n\u00f0Si; initi; Fi;\u0002i; Ci; Invi; Ti\u00de where i 2 f1; 2g be two Timed\nAutomata. Let t be a positive real number. The timed-interrupt\npattern, i.e., the Timed Automaton in which A1 is interrupted\nby A2 after A1 starts execution for t time units, written as\ntimeinter\u00f0A1; A2; t\u00de, i s \u00f0S1 [ S2 [ finit0g; init0; F2;\u00021 [\n\u00022; C1 [ C2 [ fxg; Inv0; T 0\u00de, where init0 is a fresh state, x\nis a fresh clock,\nInv0 \u00bc f\u00f0init0; urgent\u00deg [ f\u00f0s; Inv1\u00f0s\u00de ^ x \u0004 t\u00dejs 2 S1g\n[ Inv2;\nand\nT 0 \u00bc T1 [ T2 [ f\u00f0init0; \u0005; fxg; true; init1\u00deg\n[ f\u00f0s1; \u0005 ; ;; x \u00bc t; init2\u00dejs1 2 S1g:\nThe pattern is composed of two automata, A1 and A2. The\nfresh state init0 and clock x are used similarly as in the\nprevious patterns. Every state in A1 is constrained to make a\nmove before t time units. After t time units elapse, the\ncontrol transfers from one of the state in A1 (not necessarily\na final state) to the initial state in A2. Note that the\ninterruption is preemptive, i.e., transitions in A1 are\nprevented from happening once t time units have elapsed.\n850 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nDefinition 13 (event interrupt). Let Ai \u00bc\n\u00f0Si; initi; Fi;\u0002i; Ci; Invi; Ti\u00de where i 2 f1; 2g be two Timed\nAutomata. Let a be an event. The event-interrupt pattern, i.e.,\nthe Timed Automaton in which A1 is interrupted whenever\nevent a engages and then the control transfers to A2, written\nas evtinter\u00f0A1; A2; a\u00de, is\n\u00f0S1 [ S2; init1; F1 [ F2;\u00021 [ \u00022 [ fag; C1 [ C2;\nInv1 [ Inv2; T 0\u00de;\nwhere T 0 \u00bc T1 [ T2 [ f\u00f0s1; a; fxg; true; init2\u00dejs1 2 S1g.\nEvent interrupt is similar to timed interrupt except that,\nbecause there are no timing constraints involved, no\nadditional state or clock is necessary. Instead, an unguarded\ntransition labeled with a is created from each state in A1 to\nan initial state in A2.\nDefinition 14 (Timed-Event Prefixing). Let A \u00bc\n\u00f0S; init; F ;\u0002; C; Inv; T \u00de be a Timed Automaton. Let a be an\nevent. Let t be a positive real number. The timed-event-\nprefixing pattern, i.e., the Timed Automaton in which a\nengages at time t and precedes any action of A, written as\nteventprefix\u00f0a; t; A\u00de, is\n\u00f0S [ finit0; init00g; init0; F ;\u0002 [ fag; C [ fxg;\nInv [ f\u00f0init0; urgent\u00de; \u00f0init00; true\u00deg; T 0\u00de;\nwhe r e init0; init00 a r e f r e sh s t a t e s and T 0 \u00bc T [\nf\u00f0init0; \u0005 ; fxg; true; init00\u00de; \u00f0init00; a; t :\u00bc x; ;; true; init\u00deg\u00de.\nBecause t is the time taken from the moment this pattern is\nenabled to the time event a is engaged, a fresh clock x is\ninitiated whenever the automaton is enabled. The reading\nof x at the time when a is engaged is recorded in t.\n3.2 Composing Patterns\nOur experience [16], [13], [37] shows that the patterns\npresented above cover most of the common timed patterns.\nNonetheless, the patterns are by no means complete. New\nuseful patterns can be added into our library or composed\nfromtheexistingones. In the following,weshowhowtobuild\nnew patterns by composing multiple existing patterns.\nExample. Assume that the requirement is that \u201ca task must\nbe repeated every t time units (the hidden requirement is\nthat the task must terminate before t time units).\u201d A new\npattern, named periodic-repeat can be generated by\ncomposing the deadline, wait-until, and recursion patterns.\nLet A \u00bc \u00f0S; init; F ;\u0002; C; Inv; T \u00de be the automaton mod-\neling the task. By Definition 7, deadline\u00f0A; t\u00de is\n\u00f0S [ fi1g; i1; F ;\u0002; C [ fxg; f\u00f0i1; urgent\u00deg\n[ f\u00f0s; Inv\u00f0s\u00de ^ x \u0004 t\u00dejs 2 Sg; T [ f\u00f0i1; \u0005 ; fxg; true; init\u00deg\u00de:\nBy Definition 8,\nwaituntil\u00f0deadline\u00f0A; t\u00de\u00de \u00bc \u00f0S1; init1; F1; C1; Inv1; T1\u00de;\nwhere\nS1 \u00bc S [ fi1; i2; f1; f2g; init1 \u00bc i2;F1 \u00bc ff1g;\n\u00021 \u00bc \u0002;C1 \u00bc C [ fx; yg;\nInv1 \u00bc \u00f0s; Inv\u00f0s\u00de ^ x \u0004 t\u00dejs 2 Sf g [ \u00f0i1; urgent\u00de; \u00f0i2; urgent\u00de;f\n\u00f0f1; true\u00de; \u00f0f2; x \u0004 t\u00deg;\nT1 \u00bc T [ \u00f0i1; \u0005 ; fxg; true; init\u00def g [ \u00f0i2; \u0005; fyg; true; i1\u00def g\n[ \u00f0f; \u0005; ;; y \t t; f1\u00dejf 2 Ff g [ \u00f0f; \u0005; ;; y < t; f2\u00dejf 2 Ff g\n[ \u00f0f2; \u0005 ; ;; y \u00bc t; f1\u00def g:\nThe periodic-repeat pattern is\nperiodicrepeat\u00f0A; t\u00de \u00bc recur\u00f0waituntil\u00f0deadline\u00f0A; t\u00de\u00de\u00de;\nwhich is denoted as \u00f0S1; init2; F2;\u00022; C2; Inv2; T2\u00de. By\nDefinition 5, we have\nS2 \u00bc S [ fi1; i2; f2g; init2 \u00bc i2;F2 \u00bc ;; \u00022 \u00bc \u0002;\nC2 \u00bc C [ fx; yg;\nInv2 \u00bc \u00f0s; Inv\u00f0s\u00de ^ x \u0004 t\u00dejs 2 Sf g [ \u00f0i1; urgent\u00de;f\n\u00f0i2; urgent\u00de; \u00f0f2; x \u0004 t\u00deg;\nT2 \u00bc T [ \u00f0i1; \u0005 ; fxg; true; initf g [ \u00f0i2; \u0005 ; fyg; true; i1\u00def g\n[ \u00f0f; \u0005; ;; y \t t; i2\u00dejf 2 Ff g [ \u00f0f; \u0005; ;; y < t; f2\u00dejf 2 Ff g\n[ \u00f0f2; \u0005 ; ;; y \u00bc t; i2\u00def g:\nNote that, because the only final state f1 is replaced by a\nrecursive call at the last step, the automaton is\nnonterminating (as expected) and, hence, has no final\nstates. The transformation is visualized in Fig. 2. The\nresulting automaton is the one on the left. Because\nstate i1 (the second state from left) is urgent, at any\nmoment x \u00bc y, the automaton is simplified to be the right\none (\u0005 transitions have been removed). The two diverted\ntransitions are merged into one because they are only\nenabled when the reading of clock x or y is t.\nDONG ET AL.: TIMED AUTOMATA PATTERNS 851\nFig. 2. Composing timed patterns.\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nIt is important that the Timed Automata patterns\ncombine with the bottom-up composibility (of process\nalgebra style) because complex real-time systems may be\nnaturally modeled as collections of subcomponents at\ndifferent abstraction levels. In the bottom-up design\nprocess, a subcomponent of reasonable complexity (and\nwhich is flattened) may be modeled as a Timed Automaton.\nThe system can then be naturally composed from the\nmodeling of the subcomponents. The Timed Automata\npatterns provide user-friendly templates to build such\nhierarchical modeling. In the top-down design process,\nthe modeling of a complex system can be generated by\nrefining the components, step by step, using appropriate\npatterns until it is simple enough to be modeled as a\nflattened Timed Automaton. As a reasonable price to pay, a\nsystem design based on Timed Automata patterns may\nrequire extra states or clocks, for instance, Definitions 7, 8,\nand 14 introduce new states and clocks. However, our\nexperience shows that the extra states and clocks often can\nbe removed using simple optimization procedures, e.g.,\n\u0005-transition reduction (if the outgoing transitions of a state\nare all \u0005-transitions, remove the state and redirect all\nincoming transitions), urgent states reduction, or reusing\nclocks that are no longer referenced (which is common as\nclocks are local to one Timed Automaton).\n4 TRANSLATING TIMED PROCESS ALGEBRA TO\nTIMED AUTOMATA\nA practical implication of the Timed Automata patterns is\nthat process-algebra-based specification languages like\nTimed CSP or TCOZ can be systematically translated to\nTimed Automata so as to benefit from the verification\nmechanism of Timed Automata. In this section, a transla-\ntion from TCOZ to Timed Automata is defined (which\nimplies a translation from Timed CSP to Timed Automata).\nThe following defines the Timed Automaton interpretation\nof the primitive processes.\nDefinition 15 (primitives). Let Op be a data operation (or an\noperation schema):\nAskip \u00bc fi; fg; i; ffg; f\u0005g; ;; \u00f0i; urgent\u00de; \u00f0f; true\u00def g;\u00f0\n\u00f0i; \u0005; ;; true; f\u00def g\u00de;\nAstop \u00bc fig; i; ;; ;; ;; \u00f0i; true\u00def g; ;\u00f0 \u00de;\nAOp \u00bc fi; fg; i; ffg; feOpg; ;; \u00f0i; true\u00de; \u00f0f; true\u00def g;\n\u0002\n\u00f0i; eOp; ;; pre Op; f\u00de\n\u0003 \u0004\u0005\n;\nwhere eOp is an atomic event representing the data operation\nand pre Op is its precondition [43].\nAskip allows an unguarded transition from its initial state to\nthe final state. Because the initial state is urgent, the\nautomaton terminates immediately. Astop allows no transi-\ntions at all (and so, no final state is reachable). A data\noperation is presented as a Timed Automaton with only one\ntransition. The transition is guarded with the precondition\nof the operation and labeled with an event that represents\nthe atomic data change. The control may reside at the initial\nstate for some time as the data operation may not be\ninstantaneous.\nDefinition 16 (translation). Let P be the set of all TCOZ\nprocesses. Let A be the set of all Timed Automata. A\ntranslation is a function M : P ! A defined as follows:\nM\u00f0SKIP\u00de \u00bc Askip\nM\u00f0STOP\u00de \u00bc Astop;\nM\u00f0Op\u00de \u00bc AOp;\nM\u00f0a! P \u00de \u00bc eventprefix a;M\u00f0P \u00de\u00f0 \u00de;\nM\u00f0a@t! P \u00de \u00bc teventprefix a; t;M\u00f0P \u00de\u00f0 \u00de;\nM\u00f0WAIT t\u00de \u00bc delay\u00f0t\u00de;\nM\u00f0P \u0005WAITUNTIL t\u00de \u00bc waituntil M\u00f0P \u00de; t\u00f0 \u00de;\nM\u00f0P \u0005DEADLINE t\u00de \u00bc deadline M\u00f0P \u00de; t\u00f0 \u00de;\nM P . ftgQ\u00f0 \u00de \u00bc timeout M\u00f0P \u00de;M\u00f0Q\u00de; t\u00f0 \u00de;\nM P 4 ftgQ\u00f0 \u00de \u00bc timeinter M\u00f0P \u00de;M\u00f0Q\u00de; t\u00f0 \u00de;\nM\u00f0P 4 a! Q\u00de \u00bc evtinter M\u00f0P \u00de;M\u00f0Q\u00de; a\u00f0 \u00de;\nM\u00f0P ;Q\u00de \u00bc seq M\u00f0P \u00de;M\u00f0Q\u00de\u00f0 \u00de;\nM\u00f0PtuQ\u00de \u00bc extchoice M\u00f0P \u00de;M\u00f0Q\u00de\u00f0 \u00de;\nM\u00f0P uQ\u00de \u00bc intchoice M\u00f0P \u00de;M\u00f0Q\u00de\u00f0 \u00de;\nM\u00f0PkQ\u00de \u00bc para M\u00f0P \u00de;M\u00f0Q\u00de\u00f0 \u00de;\nM \u0004X \u0005 P \u00f0X\u00de\u00f0 \u00de \u00bc recur M P \u00f0X\u00de\u00f0 \u00de; SX\u00f0 \u00de;\nwhere P and Q are processes, a is an event, t is a positive real\nnumber, and SX is a set of states where X is invoked.\nNote that recursion in the above definition relies on SX. A\nrecursive process is translated like a normal process except\nthat,whenever there is a recursive callX, insteadofunfolding\nX as a Timed Automaton, a state is created and the state is\nadded to SX. The rest of the translation is mostly self-\nexplanatory. For instance, P \u0005DEADLINE t constrains that P\nmust terminate no later than t. This process is translated to\ndeadline\u00f0M\u00f0P \u00de; t\u00de in which M\u00f0P \u00de is the Timed Automaton\ncapturing the behaviors of process P . The resulting auto-\nmaton differs from M\u00f0P \u00de in that it must terminate before\nt time units, which is the semantics of the TCOZ expression\nP \u0005DEADLINE t. Other mapping rules can be explained\nsimilarly. By applying M iteratively, a process is translated\nto a flattened Timed Automaton straightforwardly.\nExample. We use the timed queue example to illustrate the\ntranslation and hint how the timed patterns can be\napplied to facilitate system design using Timed Auto-\nmata. If TCOZ is used to specify the queue in the first\nplace, by applying M to the MAIN process, a Timed\nAutomaton specification of the queue can be generated\nstep by step. Because the generated Timed Automata are\nbehaviorally equivalent to the TCOZ processes (shown\nbelow), the analysis results on the generated Timed\nAutomata apply to the original TCOZ specification:\n852 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nM\u00f0MAIN\u00de\u00bcM \u0004Q \u0005 \u00f0Join tu Leave\u00de . fTog\u00f0\n\u00f0Del \u0005DEADLINE Tl\u00de;Q\u00de\n\u00bc recur M\u00f0Join tu Leave\u00de . fTog\u00f0\n\u00f0Del \u0005DEADLINE Tl\u00de;Q\u00de; SQ\n\u0005\n\u00bc recur seq M\u00f0Join tu Leave\u00de . fTog\u00f0\u00f0\n\u00f0Del \u0005DEADLINE Tl\u00de\u00de;M\u00f0Q\u00de; SQ\n\u0005\n\u00bc recur seq timeout M\u00f0Join tu Leave\u00de;\u00f0\u00f0\u00f0\nM\u00f0Del \u0005DEADLINE Tl\u00de; To\u00de;M\u00f0Q\u00de\u00de; SQ\n\u0005\n\u00bc recur seq timeout extchoice\u00f0M\u00f0Join\u00de;\u00f0\u00f0\u00f0\nM\u00f0Leave\u00de\u00de; deadline\u00f0M\u00f0Del\u00de; Tl\u00de; To\u00de;M\u00f0Q\u00de\u00de; SQ\n\u0005\n\u00bc recur seq timeout extchoice\u00f0AJoin; ALeave\u00de;\u00f0\u00f0\u00f0\ndeadline\u00f0ADel; Tl\u00de; To\u00de;M\u00f0Q\u00de\u00de; SQ\n\u0005\n:\nAs discussed above, a recursive call shall not be\nunfolded. For instance, M\u00f0Q\u00de in the above is viewed a\nTimed Automaton with only one state (which is both the\ninitial and final state), which later will be removed\nbecause of the recursion pattern. By applying the\ndefinitions in Section 3.1 in a bottom-up manner,\nM\u00f0MAIN\u00de is flattened to the one in Fig. 3b. Note that\nstate Q corresponds to the recursive call of process Q.\nThe Timed Automaton can be further reduced to Fig. 3a\nby removing \u0005-transitions (e.g., the transitions from f2,\nf1, and f3 to f6) and the urgent state f5 and reusing\nclocks (e.g., instead of x, reuse y).\nAlternatively, Timed Automata users can do a top-\ndown design using the patterns in the same modular\nway that TCOZ users do hierarchical system design, that\nis, to assume the availability of lower level processes or\nTimed Automata that behave in a certain way, specify\nthe system in terms of the lower level processes or Timed\nAutomata (e.g., at the top level, a designer may\nintuitively decide that the queue must be recursive and\ntherefore apply the recursion pattern), and then itera-\ntively refine each lower level process or Timed Auto-\nmaton until they are simple enough to be modeled as a\nsimple process or a flattened Timed Automaton.\nIn the following, we prove that the translation M is\nsound, i.e., given any process P , the automaton M\u00f0P \u00de is\nbehaviorally equivalent to P . We show that there is a weak\nbisimulation relation (which implies behavioral equiva-\nlence) between the transition system semantics of a process\nand the automaton. This also justifies that the patterns\ncapture intuitive meanings.\nDefinition 17 (TCOZ Semantics). Let P be the set of all TCOZ\nprocesses. Let P be a process. Let T be the time domain.\nTS1P \u00bc \u00f0P \u0003 T ; \u00f0P; t\u00de;\u0002 [ T ;\u0006!1\u00de is a labeled transition\nsystem where P \u0003 T is the state space, \u00f0P; t\u00de : P \u0003 T is an\ninitial state, \u0002 is a set of events, and \u0006!1 is a labeled\ntransition relation that is defined by the rules in Appendix A,\nwhich can be found on the Computer Society Digital Library at\nhttp:\/\/doi.ieeecomputersociety.org\/10.1109\/TSE.2008.52,\nwhere c \u0006!1a c0 \n \u00f0c; a; c0\u00de 2 \u0006!1.\nMost of the rules (i.e., the operational semantics) can be\nreferenced in Schneider\u2019s book [40], except those rules that\nare TCOZ-specific, e.g., DEADLINE and WAITUNTIL. In the\nnext definition, \u0005-transitions in TS1P are abstracted away\nbecause only observable behaviors are concerned.4\nDefinition 18 (Observable TCOZ Semantics). Let P be the\nset of all TCOZ processes. Let P be a process. Let T be the time\ndomain. TS2P \u00bc \u00f0P \u0003 T ; \u00f0P; t\u00de;\u0002 [ T ;\u00bc)1\u00de is a labeled\ntransition system where P \u0003 T is the state space, \u00f0P; t\u00de :\nP \u0003 T is an initial state, \u0002 is the set of possible events\nincluding the internal event \u0005 , and \u00bc)1 is a labeled transition\nrelation such that for any c; c0 : P \u0003 T ,\n. c \u00bc)1\na\nc0 b\u00bc 9c1; c2 \u0005 c \u0006!\u000b1\n\u0005\nc1 \u0006!1a c2 \u0006!\u000b1\n\u0005\nc0, and\n. c \u00bc)1\n\u0003\nc0 b\u00bc 9c1; c2 \u0005 c \u0006!\u000b1\n\u0005\nc1 \u0006!1\u0003 c2 \u0006!\u000b1\n\u0005\nc0,\nwhere the relation \u0006!\u000b1\n\u0005\nis the sequential composition of a\nfinite number of \u0006!1\u0005 .\nTS2P differs from TS\n1\nP in that all \u0005-transitions are hidden.\nNext, we define the semantics of Timed Automata. A\ntransition system semantics of Timed Automata has been\ndefined in [2], [10].\nDefinition 19 (Timed Automata semantics). Let A \u00bc\n\u00f0S; init; F ;\u0002; C; Inv; T \u00de be a Timed Automaton. Let V be\nthe valuations of clocks. TS1A \u00bc \u00f0S \u0003 V ; \u00f0init; v0\u00de;\u0002 [\nT ;\u0006!2\u00de: b\u00bcS \u0003 V is the state space. The initial state s0 \u00bc\n\u00f0init; v0\u00de comprises the initial state init and a zero valuation\nv0. \u0006!2 \u0002 S \u0003 \u00f0\u0002 [ T \u00de \u0003 S is a transition relation compris-\ning either time passing \u00f0s; v\u00de \u0006!2\u0003 \u00f0s; v\u00fe \u0003\u00de or, if the\ntransition \u00f0s; a; \u0002; \u0006; s0\u00de is enabled, an action execution\n\u00f0s; v\u00de \u0006!2\u0003 \u00f0s0; v0\u00de.\nSimilarly, we define the transition system where all\n\u0005-transitions are hidden.\nDefinition 20 (Observable Timed Automata Semantics).\nLet A \u00bc \u00f0S; init; F ;\u0002; C; Inv; T \u00de be a Timed Automaton.\nLet V be the valuation of the clocks. TS2A \u00bc \u00f0S \u0003\nV ; \u00f0init; v0\u00de;\u0002 [ T ;\u00bc)2\u00de: S \u0003 V is the state space. The\ninitial state s0 \u00bc \u00f0init; v0\u00de comprises the initial state init and\nDONG ET AL.: TIMED AUTOMATA PATTERNS 853\n4. We assume that the processes are divergence free, i.e., only finite\nnumbers of consecutive \u0005 transitions are possible.\nFig. 3. Timed Automaton of a timed queue where e1, e2, and e3 are eJoin, eLeave, and eDel, respectively.\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \na zero valuation v0. \u00bc)2 \u0002 S \u0003 \u00f0\u0002 [ T \u00de \u0003 S is a labeled\ntransition relation such that, for all s; s0 : S \u0003 V ,\n. s \u00bc)2\na\ns0 b\u00bc 9s1; s2 \u0005 s \u0006!\u000b2\n\u0005\ns1 \u00bc)2\na\ns2 \u0006!\u000b2\n\u0005\ns0, and\n. s \u00bc)2\n\u0003\ns0 b\u00bc 9s1; s2 \u0005 s \u0006!\u000b2\n\u0005\ns1 \u00bc)2\n\u0003\ns2 \u0006!\u000b2\n\u0005\ns0,\nwhere the transition relation \u0006!\u000b2\n\u0005\nis the sequential composi-\ntion of at most a finite number of \u0006!2\u0005 .\nWith the above preparation, a bisimilar (homomorphic)\nrelation between TS2P and TS\n2\nA is readily defined.\nDefinition 21 (Bisimulation). Let TSi \u00bc \u00f0Si; initi;\u0002i; Ti\u00de\nwhere i 2 f1; 2g be two labeled transition systems. For any\ns1 2 S1 and s2 2 S2, s1 \f s2 if and only if\n. 8\u00f0s1; a; s01\u00de : T1 \u0005 9s02 2 S2 \u0005 \u00f0s2; a; s02\u00de 2 T2 ^ s01 \f s02\nand\n. 8\u00f0s2; a; s02\u00de : T2 \u0005 9s01 : S1 \u0005 \u00f0s1; a; s01\u00de 2 T1 ^ s01 \f s02.\nTS1 and TS2 are bisimilar, written as TS1 \f TS2, if and only\nif init1 \f init2.\nThe following theorem states that the translation in\nDefinition 16 is sound, i.e., the source and target transition\nsystems are bisimilar. The proof is presented in\nAppendix B, which can be found on the Computer Society\nDigital Library at http:\/\/doi.ieeecomputersociety.org\/\n10.1109\/TSE.2008.52.\nTheorem 1 (soundness). Let P be a TCOZ process. Let TS2P \u00bc\n\u00f0P \u0003 T ; \u00f0P; t\u00de;\u0002 [ T ;\u00bc)1\u00de as defined above. Let A \u00bc\nM\u00f0P \u00de \u00bc \u00f0S; init; F ;\u0002; C; Inv; T \u00de: L e t TS2A \u00bc \u00f0S \u0003\nV ; \u00f0init; v0\u00de;\u0002 [ T ;\u00bc)2\u00de as defined above. TS2P \f TS2A.\n4.1 Implementation\nIn order to assist system development using either TCOZ or\nTimed Automata, we have developed a prototype support-\ning functionalities including automated translation from\nTCOZ specification to Timed Automata (for TCOZ users to\nbenefit from the supporting tools of Timed Automata) and\nhigh-level system design using Timed Automata (refer to\nthe next section).\nThe translation from TCOZ to Timed Automata is\nautomated by employing XML and Java technology. In\nour previous work, the syntax of the Z family languages\n(i.e., Z\/OZ\/TCOZ) has been defined using XML schemas,\nwhich is named ZML [42]. A number of tools based on XML\nrepresentation of TCOZ models have been developed.\nUPPAAL also supports an XML representation of Timed\nAutomata. Hence, the translation is reduced to a conversion\nfrom one XML file to another. Our tool reads a TCOZ\nspecification represented in XML and outputs an XML\nrepresentation of a Timed Automaton specification con-\nforming to the DTD syntax defined in UPPAAL. The\ntranslation rules are used as a design document to trans-\nform the process aspects of a TCOZ specification. Worthy of\nmention is that, because TCOZ allows synchronization\namong multiple parties, whereas UPPAAL allows only\npairwise synchronization, committed states are used to\nachieve broadcasting communication in the target UPPAAL\nmodel (detailed information can be found in [33]). In\naddition, the following handles the data aspects. A channel\ncommunication may carry a value in TCOZ, which is not\npossible in UPPAAL. Value passing in UPPAAL is achieved\nby global variable assignments along the Timed Automata\ntransitions. A class in TCOZ is translated to a Timed\nAutomaton template in UPPAAL (by translating the MAIN\nprocess of the class). Instances of the class are translated as\ninstances of the template. The predicate in the INIT schema\nof a TCOZ class is labeled with the initial state of the\nresultant Timed Automaton. UPPAAL supports limited\ndata types, e.g., bounded integers, arrays of bounded\nintegers, record types, scalars, etc. Thus, only those data\ntypes are allowed for the translation at the current stage.\n5 CASE STUDY: RAILCAR SYSTEM\nThe system design based on TCOZ is to identify objects and\ntheir data attributes from the system requirements, en-\ncapsulate relevant data operations, as well as dynamic\nbehavior patterns, in the respective object modeling, and,\nfinally, compose different objects to form the system\nspecification. Because of the bottom-up composibility of\nprocess algebra (which TCOZ is based on), modeling the\ndynamic behaviors in TCOZ is compositional and natural.\nThe system design based on Timed Automata patterns\nenjoys similar composibility, i.e., starting with building\nTimed Automata designs of fractions of the system and\nthen composing the basic Timed Automata using the timed\npatterns. In this section, a Railcar System is used to\ndemonstrate a high-level real-time system design using\nboth Timed Automata patterns and TCOZ. This system was\ninspired by the railcar system presented in [24].\n5.1 High-Level System Design Using Timed\nAutomata\nIn the Railcar System, there are four (possibly more)\nterminals that are located in a cyclic path. Each terminal\ncontains a push button for passengers to place their\nrequests for car service. A railcar travels clockwise on the\ntrack to transport passengers between terminals. The railcar\nis equipped with a destination board to receive internal\nrequests and to indicate each destination terminal. There is\na central control that receives, processes, and sends data to\nthe terminals and the railcar so that external requests from\nany terminal can be fulfilled. Additional timing require-\nments are added into the original model [24] because\nquantitative timing is an important aspect of the system, as\nillustrated in the following scenarios:\n. Before the railcar leaves a terminal, it sends a signal\nto depart to the terminal. The terminal prepares for\nthe railcar to depart and responds to the railcar\nwithin 5 seconds. The railcar then leaves the\nterminal and cruises toward the destination.\n. When the railcar comes to a stop at a terminal, it\nopens its door for exactly 10 seconds. After that, it\ncloses the door and begins to wait for either internal\npassenger requests or an external request dispatched\nfrom the controller. Passengers inside the railcar are\ngiven 5 seconds to make an internal request before\nthe railcar accepts any external requests.\nDesigning the system from scratch using ordinary Timed\nAutomata is nontrivial. The system is composed of multiple\nobjects, each of which are assigned with different behavior\npatterns, e.g., the controller is responsible for handling\n854 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \ndifferent tasks. Nonetheless, the requirements of the system\nare naturally captured in a hierarchical way [24]. Using the\ntimed patterns, we achieve a similar approach to model the\nsystem as in [24]. The Railcar System has three components,\ni.e., a railcar, the terminals, and a central controller. The\nrailcar is composed of three basic components, i.e., a car\ndestination panel, a car door, and a car handler. There is a\nbutton at each terminal so that passengers can request for a\nservice. The central controller maintains a record of all\nexternal requests and dispatches external requests to the\nrailcar if there is any. All system components are connected\nby channels. Fig. 4 shows a hierarchical blueprint of the\nsystem, where a triangle represents a Timed Automaton\nand a double-arrowed dotted line means that there are\ncommunications in between. Each triangle will be detailed\nin the following. For each component, we will first identify\nthe basic behaviors (of manageable complexity) and then\ncompose them to build the system step by step.\nLet terminal\u00f0i\u00de, where i 2 f1; 2; 3; 4g, be the four term-\ninals. Let tb i : IB be a local variable to terminal\u00f0i\u00de\nrepresenting the button at the ith terminal. tb i \u00bc true if\nand only if the button is lit. The four automata in Fig. 5a\nshow the basic behaviors of a terminal. In automaton\nPressButton\u00f0i\u00de, where i 2 f1; 2; 3; 4g, an external request\nenters the external request queue in the central controller\nonly if the button has not been pressed before. Once\npressed, the light is on (i.e., tb i :\u00bc true). In ButtonOff , once\nthe controller informs the terminal that the request has been\nserviced, the light goes off. In TerApproach, event\napproach req signals the approaching of the car, and the\nDONG ET AL.: TIMED AUTOMATA PATTERNS 855\nFig. 4. A structural design.\nFig. 5. Basic behavior patterns.\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nterminal does the necessary preparation (abstracted as a\ndelay in this modeling) and then acknowledges. Last, in\nTerDepart, before the car departs, the terminal is informed\nby depart req and acknowledges by depart ack. The\ncomposed behavior of a terminal is\nterminal\u00f0i\u00de \u00bc recur extchoice\u00f0PressButton; ButtonOff;\u00f0\nTerApproach; TerDepart\u00de\u00de;\nwhere PressButton = extchoice(PressButton(1), PressBut-\nton(2), PressButton(3), PressButton(4)). The terminals are\nspecified as Terminals = para(terminal(1), terminal(2),\nterminal(3), terminal(4)).\nWe model the behaviors of the car similarly. The door\nhas been modeled in Section 2.1. The panel in the car is\ncomposed of four buttons. Let b be an array of Boolean\nvariables. b\u00bdi\u0007 \u00bc true, where i 2 f1; 2; 3; 4g, means the\nith button has been lit already. Let curr and dest be two\nglobal variables that record the station the car is approach-\ning and the destination, respectively. Let tostop : IB be a\nglobal variable that says whether to stop or not at the next\nterminal. The automata in Fig. 5b model the basic behaviors\nof the panel. In automaton IntRequest, a passenger in the\ncar may press a button on the panel (modeled as event\nint request i, where i 2 f1; 2; 3; 4g) and the button is lit\nafterward. Note that the button may be pressed even if it\nhas been pressed already. In IntSchedule, if there is an\ninternal request, the car panel computes the next destina-\ntion once an input is received on channel int sched (from\nthe car handler). The destination is set to be the next\nrequested terminal. In IntCheck (when the car is approach-\ning the next terminal), the car handler orders the panel to\ncheck whether there is an internal request for the next\nterminal and decides whether to stop at the next terminal.\nThe overall behaviors of the panel are specified as Panel \u00bc\nrecur\u00f0extchoice\u00f0IntRequest; IntSchedule; IntCheck\u00de\u00de.\nThe behavior patterns of the central controller are similar\nto those of the panel except that the car panel handles internal\nrequests, whereas the controller handles external requests.\nThe automata in Fig. 5cmodel its basic behaviors. Let eb be an\narray of Boolean variables that represents whether the\nexternal buttons have been pressed and lit. The overall\nbehaviors of the controller are specified as Controller =\nrecur(extchoice(ExtRequest, ExtSchedule, ExtCheck)).\nThe automata in Fig. 5d model the basic computational\nlogic of the car handler. In order to specify its overall\nbehaviors, we make use of the timed patterns. The\ncompositional Timed Automaton namedMoving, presented\nin Fig. 6, specifies the behaviors of the car handler after\ngetting a request (either from internal or external). If the\ndestination is the current terminal, the car door is opened.\nOtherwise, the car leaves the terminal and heads toward the\ndestination. Once approaching the next terminal, the car\nchecks if there is a newly arrived request from external or\ninternal for the approaching terminal. Afterward, the\nautomaton repeats from the beginning. Note that this\nhierarchical automaton has already been partially flattened\nfor simplicity.\nThe overall behavior of the car handler can be composed\nfrom the above basic one. Initially, the car handler is idling\nat some terminal. It waits for an internal request first. If an\ninternal request arrives within 4 seconds, it starts to serve\nthe request. Otherwise, it waits for either an internal or\nexternal request and then starts moving. Once it reaches the\ndestination, it repeats from the beginning. The overall\nbehavior of the car handler is represented as follows:\nCarHandler \u00bc recur seq timeout IntSchedule; extchoice\u00f0\u00f0\u00f0\n\u00f0IntSchedule; ExtSchedule\u00de; 4\u00de;Moving\u00de\u00de:\nGraphically, it is drawn as shown in Fig. 7. Last, the system\nis the parallel composition of the three components, i.e.,\npara(Terminals, Controller, para(Panel,Door,CarHandler)).\n5.2 Analysis of the TCOZ Modeling\nBased on the strength of OZ and Timed CSP, TCOZ\nsupports object-oriented design of data structures, as well\nas compositional design of dynamic behaviors, as demon-\nstrated in [37], [36]. Because modeling using TCOZ (which\nshares the same bottom-up nature as using the Timed\nAutomata patterns) is largely irrelevant to this paper, we\nshow instead how the TCOZ specification is translated to\nTimed Automata systematically using our prototype and\nthen verified using UPPAAL. The relevant part of the TCOZ\nspecification is presented in Appendix C, which can be\nfound on the Computer Society Digital Library at http:\/\/\ndoi.ieeecomputersociety.org\/10.1109\/TSE.2008.52.\n856 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\nFig. 6. Composed behaviors (1).\nFig. 7. Composed behaviors (2).\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nEach active class in the TCOZ model is projected to a\nTimed Automaton template, namely, a terminal template\nfor the class Terminal; a car door, a car destination panel,\nand a car handler template for the class CarDoor, CarPanel,\nand CarHandler, respectively; and a controller template for\nthe class Controller. The terminal template has four\ninstances, which represents the four different terminals\naccording to the TCOZ specifications. The other templates\nhave only one instance. The translation is a straightforward\napplication of Definition 16. We use the Terminal class as\nan example to show the identification of the states,\ntransitions, guards, and synchronization. Its processes\nmainly have an external choice pattern and a recursion\npattern as defined by its MAIN process:\nrecur extchoice M\u00f0PressDown\u00de;M\u00f0DownOff\u00de;\u00f0\u00f0\nM\u00f0CarApproach\u00de;M\u00f0CarDepart\u00de\u00de; SP \u00de:\nBy applying the translation to each of the processes\nPressDown, DownOff , CarApproach, and CarDepart, we\nobtain the Timed Automaton template of the class\nTerminal. The above translation is automated by our\ntranslation tool. Then, by adding the object reference\ninformation manually, such as the identification of each\ndifferent terminal, the whole automaton can be visualized\nin UPPAAL. Similarly, Timed Automata are generated from\nother system components, e.g., the template for class Door\nis shown in Section 2.1. The translation result is stored in an\nXML format, which can be readily imported by UPPAAL.\nNow, we can use the simulator and verifier of UPPAAL to\nsimulate the system, as well as to model check some\ninvariants and real-time properties. The key point of the\nrailway system is to provide efficient services. The follow-\ning are some of the properties that can be formally specified\nand verified using UPPAAL:\n. Prop1.Whenever the car destination board receives a\nrequest to a terminal, say, terminal 1, the railcar will\neventually get to that terminal within 600 seconds. It\ncan be translated into a Timed CTL as a bounded\nliveness property.\n. Prop2. The door must be open for no more than\n10 seconds.\n. Prop3. The system is deadlock free.\n. Prop4. Whenever the railcar is moving, the car door\nis closed.\nUPPAAL verified that these properties hold for this given\nmodel. As for reference, the time consumption for analyz-\ning each of the properties is listed below. The experiment\nresults are obtained on the Windows XP platform with\n2 Gbyte memory and Intel 3.0 GHz CPU.N is the number of\nterminals.\nIn summary, the Timed Automata patterns allow us to\nenjoy a hierarchical system design using Timed Automata,\ni.e., to apply a divide-and-conquer strategy to deal with the\ncomplexity of the system design. A high-level design (as the\none above where highly coupled system behaviors are\nencapsulated in one component) is easier to understand and\nmaintain. A high-level system design can be automatically\nflattened (by applying the definitions plus optimization\ntechniques for reducing the number of states, as well as\nclocks) and then verified using existing tools like UPPAAL.\nCompared to the system design using timed patterns\ndirectly, which solely focuses on dynamic behaviors, the\nTCOZ-based design is heavy in modeling data and\nfunctional aspects of the system. Because the timed patterns\nare closely related to compositional operators in TCOZ, the\nmodeling of dynamic behaviors using timed patterns and\nTCOZ share similar ideas.\n6 CONCLUSION\nFor the last decades, a variety of formal modeling\/\nspecification languages have been proposed for real-time\nsystem design and verification. The various modeling and\nverification techniques all have similarities and differences\nto some degree. It is important for the formal method\ncommunity to understand how various techniques differ\nfrom each another and how they may benefit from each\nother. The techniques under consideration, namely, TCOZ\/\nTimed CSP and Timed Automata, deal with behavioral real-\ntime aspects of systems. Lying at each end of the spectrum\nof formal modeling techniques, TCOZ is designed for the\nstructural specification of high-level complex system\nrequirements, whereas Timed Automata are used to design\ntimed models with simple clock constraints but with highly\nautomated verification support. In this work, we studied\nboth formalisms from a practical point of view, i.e., how can\nthey help each other? We are not arguing which of the two\nis superior. Instead, we enrich TCOZ with verification\nsupport by translating its models to Timed Automata and\nenrich Timed Automata with composable patterns for high-\nlevel system design.\nThe main contribution of the work is the rich set of timed\npatterns, which covers all common hierarchical system\nbehaviors like deadline, timeout, and timedinterrupt. These\npatterns are formallydefined soas to achieve composibility in\nthe graphical representations.Moreover,wehave shown that\nnew timed patterns may be composed naturally using our\ntimed patterns. These patterns not only provide a proficient\ninterchange media for translating time-enriched process\nalgebra specifications into Timed Automata but also provide\na generic reusable framework for developing real-time\nsystems solelyusingTimedAutomata.As shown inSection 5,\nby decomposing a complex system to subcomponents of\nmanageable size and then composing the subcomponents\nusing timed patterns, these patterns offer a systematic way of\nfighting the great complexity in system design.\nOne of the future works is to develop fully automated\noptimization techniques that could maximally reduce the\nnumber of states and clocks while flattening the Timed\nAutomata patterns. This is important because the number\nof clocks (and states) has a significant impact on the\nperformance of tools like UPPAAL. Another future work\nis to integrate our prototype with UPPAAL for user\nDONG ET AL.: TIMED AUTOMATA PATTERNS 857\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nconvenience. A future work of theoretical interest is to\nfully compare the expressiveness of timed process\nalgebras like Timed CSP and Timed Automata so as to\ngain better support for verifying real-time systems.\nACKNOWLEDGMENTS\nThe authors would like to thank Hugh Anderson, Roger\nDuke, Sun Jing, Wang Hai, Lars Grunske, and the\nanonymous referees for their insightful comments on this\nwork. This research is partially supported by the research\ngrant R-252-000-201-112 funded by National University of\nSingapore. Jun Sun is the corresponding author for this\npaper.\nREFERENCES\n[1] R. Alur, C. Couroubetis, and D.L. Dill, \u201cModel-Checking for Real-\nTime Systems,\u201d Proc. Fifth Ann. IEEE Symp. Logic in Computer\nScience, pp. 414-425, 1990.\n[2] R. Alur and D.L. Dill, \u201cA Theory of Timed Automata,\u201d Theoretical\nComputer Science, vol. 126, pp. 183-235, 1994.\n[3] S. Bornot and J. Sifakis, \u201cRelating Time Progress and Deadlines in\nHybrid Systems,\u201d Proc. Int\u2019l Workshop Hybrid and Real-Time\nSystems, pp. 286-300, 1997.\n[4] S. Bornot, J. Sifakis, and S. Tripakis, \u201cModeling Urgency in Timed\nSystems,\u201d Proc. Int\u2019l Symp. Compositionality: The Significant\nDifference, pp. 103-129, 1997.\n[5] H. Bowman, \u201cModelling Timeouts without Timelocks,\u201d Proc. Fifth\nInt\u2019l AMAST Workshop Formal Methods for Real-Time and Probabil-\nistic Systems, pp. 334-353, 1999.\n[6] H. Bowman and R. Go\u00b4mez, \u201cHow to Stop Time Stopping,\u201d Formal\nAspect of Computing, vol. 18, no. 4, pp. 459-493, 2006.\n[7] H. Bowman, R. Go\u00b4mez, and L. Su, \u201cA Tool for the Syntactic\nDetection of Zeno-Timelocks in Timed Automata,\u201d Electronic Notes\nin Theoretical Computer Science, vol. 139, no. 1, pp. 25-47, 2005.\n[8] P. Brooke, \u201cA Timed Semantics for a Hierarchical Design\nNotation,\u201d PhD dissertation, Univ. of York, 1999.\n[9] S.D. Brooke, \u201cA Model for Communicating Sequential Processes,\u201d\nPhD dissertation, Oxford Univ., 1983.\n[10] A.M.K. Cheng, Real-Time Systems: Scheduling, Analysis, and\nVerification. John Wiley & Sons, 2002.\n[11] A. David and M.O. Mo\u00a8ller, \u201cFrom HUPPAAL to UPPAAL: A\nTranslation from Hierarchical Timed Automata to Flat Timed\nAutomata,\u201d Technical Report RS-01-11, BRICS, Mar. 2001.\n[12] J. Davies, Specification and Proof in Real-Time CSP. Cambridge\nUniv. Press, 1993.\n[13] J.S. Dong, N. Fulton, L. Zucconi, and J. Colton, \u201cFormalizing\nProcess Scheduling Requirements for an Aircraft Operational\nFlight Program,\u201d Proc. First IEEE Int\u2019l Conf. Formal Eng. Methods,\npp. 161-169, 1997.\n[14] J.S. Dong, P. Hao, S.C. Qin, J. Sun, and W. Yi, \u201cTimed Patterns:\nTCOZ to Timed Automata,\u201d Proc. Sixth Int\u2019l Conf. Formal Eng.\nMethods, pp. 483-498, 2004.\n[15] J.S. Dong, P. Hao, J. Sun, and X. Zhang, \u201cA Reasoning Method for\nTimed CSP Based on Constraint Solving,\u201d Proc. Eighth Int\u2019l Conf.\nFormal Eng. Methods, pp. 342-359, 2006.\n[16] J.S. Dong, B.P. Mahony, and N. Fulton, \u201cModeling Aircraft\nMission Computer Task Rates,\u201d Proc. World Congress on Formal\nMethods, p. 1855, 1999.\n[17] R. Duke and G. Rose, \u201cFormal Object Oriented Specification Using\nObject-Z,\u201d Cornerstones of Computing, Macmillan, 2000.\n[18] M.B. Dwyer, G.S. Avrunin, and J.C. Corbett, \u201cPatterns in Property\nSpecifications for Finite-State Verification,\u201d Proc. 21st Int\u2019l Conf.\nSoftware Eng., pp. 411-420, 1999.\n[19] H. Fuhrmann, J. Koch, J. Rennhack, and R.v. Hanxleden, \u201cThe\nAerospace Demonstrator of DECOS,\u201d Proc. Eighth Int\u2019l IEEE Conf.\nIntelligent Transportation Systems, pp. 19-24, 2005.\n[20] C. Ghezzi, D. Mandrioli, and A. Morzenti, \u201cTrio: A Logic\nLanguage for Executable Specifications of Real-time System,\u201d\nJ. Systems and Software, vol. 12, no. 2, pp. 107-123, May 1990.\n[21] UML Resource Page, Object Management Group, http:\/\/\nwww.omg.org\/uml\/, 2008.\n[22] V. Gruhn and R. Laue, \u201cPatterns for Timed Property Specifica-\ntions,\u201d Electronic Notes in Theoretical Computer Science, vol. 153,\nno. 2, pp. 117-133, 2006.\n[23] L. Grunske, K. Winter, and R. Colvin, \u201cTimed Behavior Trees and\nTheir Application to Verifying Real-Time Systems,\u201d Proc. 18th\nAustralian Software Eng. Conf., pp. 211-222, 2007.\n[24] D. Harel and E. Grey, \u201cExecutable Object Modeling with\nStatecharts,\u201d Computer, vol. 30, no. 7, pp. 31-42, July 1997.\n[25] K. Havelund, A. Skou, K.G. Larsen, and K. Lund, \u201cFormal\nModeling and Analysis of an Audio\/Video Protocol: An\nIndustrial Case Study Using UPPAAL,\u201d Proc. 18th IEEE Real-Time\nSystems Symp., pp. 2-13, 1997.\n[26] I.J. Hayes and M. Utting, \u201cDeadlines Are Termination,\u201d Proc. IFIP\nWorking Conf. Programming Concepts and Methods, 1998.\n[27] C.A.R. Hoare, Communicating Sequential Processes. Prentice Hall,\n1985.\n[28] J. Hoenicke and E.-R. Olderog, \u201cCombining Specification Techni-\nques for Processes, Data and Time,\u201d Proc. Third Int\u2019l Conf.\nIntegrated Formal Methods, pp. 245-266, 2002.\n[29] F. Jahanian and A.K. Mok, \u201cA Graph-Theoretic Approach for\nTiming Analysis and Its Implementation,\u201d IEEE Trans. Computers,\nvol. 36, no. 8, pp. 961-975, Aug. 1987.\n[30] S. Konrad and B.H.C. Cheng, \u201cReal-Time Specification Patterns,\u201d\nProc. 27th Int\u2019l Conf. Software Eng., pp. 372-381, 2005.\n[31] L.M. Lai and P. Watson, \u201cA Case Study in Timed CSP: The\nRailroad Crossing Problem,\u201d Proc. Int\u2019l Workshop Hybrid and Real-\nTime Systems, pp. 69-74, 1997.\n[32] K.G. Larsen, M. Mikucionis, B. Nielsen, and A. Skou, \u201cTesting\nReal-Time Embedded Software Using UPPAAL-TRON: An\nIndustrial Case Study,\u201d Proc. Fifth ACM Int\u2019l Conf. Embedded\nSoftware, pp. 299-306, 2005.\n[33] K.G. Larsen, P. Pettersson, and Y. Wang, \u201cUppaal in a Nutshell,\u201d\nInt\u2019l J. Software Tools for Technology Transfer, vol. 1, nos. 1-2,\npp. 134-152, 1997.\n[34] M. Lindahl, P. Pettersson, and Y. Wang, \u201cFormal Design and\nAnalysis of a Gearbox Controller,\u201d Springer Int\u2019l J. Software Tools\nfor Technology Transfer, vol. 3, no. 3, pp. 353-368, 2001.\n[35] N.A. Lynch and F.W. Vaandrager, \u201cAction Transducers and\nTimed Automata,\u201d Formal Aspects of Computing, vol. 8, no. 5,\npp. 499-538, 1996.\n[36] B. Mahony and J.S. Dong, \u201cTimed Communicating Object Z,\u201d\nIEEE Trans. Software Eng., vol. 26, no. 2, pp. 150-177, Feb. 2000.\n[37] B.P. Mahony and J.S. Dong, \u201cNetwork Topology and a Case Study\nin TCOZ,\u201d Proc. 11th Int\u2019l Conf. Z Users, pp. 308-327, 1998.\n[38] J. Ouaknine and J. Worrell, \u201cTimed CSP = Closed Timed Epsilon-\nAutomata,\u201d Nordic J. Computing, vol. 10, no. 2, pp. 99-133, 2003.\n[39] A.W. Roscoe, The Theory and Practice of Concurrency. Prentice Hall,\n1997.\n[40] S. Schneider, Concurrent and Real-Time Systems. John Wiley & Sons,\n2000.\n[41] J. Sifakis, \u201cThe Compositional Specification of Timed Systems\u2014A\nTutorial,\u201d Proc. 11th Int\u2019l Conf. Computer Aided Verification, pp. 2-7,\n1999.\n[42] J. Sun, J.S. Dong, J. Liu, and H. Wang, \u201cA Formal Object Approach\nto the Design of ZML,\u201d Annals of Software Eng., vol. 13, pp. 329-\n356, 2002.\n[43] J. Woodcock and J. Davies, Using Z: Specification, Refinement, and\nProof. Prentice Hall, 1996.\nJin Song Dong received the bachelor\u2019s (first-\nclass honors) and PhD degrees in computing\nfrom the University of Queensland in 1992 and\n1996, respectively. From 1995 to 1998, he was a\nresearch scientist at the Commonwealth Scien-\ntific and Industrial Research Organisation, Aus-\ntralia. Since 1998, he has been with the School\nof Computing at the National University of\nSingapore (NUS), where he is currently an\nassociate professor and a member of the PhD\nsupervisors at the NUS Graduate School. He is on the editorial board of\nthe Formal Aspects of Computing Journal and Innovations in Systems\nand Software Engineering, A NASA Journal. His research interests\ninclude formal methods and software engineering. Some of his papers\ncan be found at http:\/\/www.comp.nus.edu.sg\/~dongjs.\n858 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 6, NOVEMBER\/DECEMBER 2008\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \nPing Hao received the bachelor\u2019s degree in\ntelecommunication from the Huazhong Univer-\nsity of Science and Technology, China, in 2000\nand the PhD degree in computer science from\nthe National University of Singapore (NUS) in\n2008. From 2005 to 2006, she was a research\nassistant in the Software Engineering Labora-\ntory, NUS. Her research interests include formal\nspecification languages, verification, and soft-\nware engineering. More details about her re-\nsearch and background can be found at http:\/\/www.comp.nus.edu.sg\/\n~haoping.\nShengchao Qin received the BSc and PhD\ndegrees from the School of Mathematical\nSciences, Peking University, in 1997 and 2002,\nrespectively. He was a research fellow under the\nSingapore-MIT alliance at the National Univer-\nsity of Singapore from July 2002 to December\n2004. Since 2005, he has been a lecturer in the\nDepartment of Computer Science at Durham\nUniversity, United Kingdom. His research inter-\nests include formal methods, programming\nlanguages, and embedded systems. More information about his\nresearch can be found at http:\/\/www.dur.ac.uk\/shengchao.qin.\nJun Sun received the bachelor\u2019s and PhD\ndegrees from the School of Computing, National\nUniversity of Singapore (NUS), in 2002 and\n2006, respectively. From 2005 to 2006, he was a\nresearch fellow in the School of Computing,\nNUS. Since 2006, he has been a Lee Kuan Yew\npostdoctoral fellow in the Department of Com-\nputer Science, NUS. His research interests are\nmainly in formal system specification, verifica-\ntion, and synthesis. In particular, he has been\nworking with a variety of different specification languages and notations\nin order to develop practical tools for elegant system development. More\ndetails about his research and background can be found at http:\/\/\nwww.comp.nus.edu.sg\/~sunj.\nWang Yi received the PhD degree in computer\nscience from the Chalmers University of Tech-\nnology, Sweden, in 1991. He is a professor in\nreal-time systems at Uppsala University, Swe-\nden, and a Changjiang professor at North\nEastern University, China. From 1991 to 1992,\nhe was a postdoctoral fellow at Aalborg Uni-\nversity, Denmark, before he joined the faculty of\nscience and technology at Uppsala University,\nwhere he was a lecturer from 1992 to 1994, an\nassociate professor from 1994 to 2000, and has been a professor since\n2000. His interests are mainly in the modeling and verification of\nconcurrent, distributed, and real-time systems, in particular, techniques\nand tools for model-based design, analysis, and implementation of\nembedded systems and their industrial applications. He is a cofounder\nof three software tools for modeling and verification, including UPPAAL,\na widely used model checker for timed systems. His publications can be\nfound at http:\/\/user.it.uu.se\/~yi\/.\nDONG ET AL.: TIMED AUTOMATA PATTERNS 859\nAuthorized licensed use limited to: University of Durham. Downloaded on December 9, 2009 at 07:05 from IEEE Xplore.  Restrictions apply. \n"}