{"doi":"10.1109\/ISCE.2006.1689513","coreId":"69740","oai":"oai:eprints.lancs.ac.uk:22914","identifiers":["oai:eprints.lancs.ac.uk:22914","10.1109\/ISCE.2006.1689513"],"title":"QOS Aware CORBA Middleware for Bluetooth.","authors":["Mutlu, Ural Mutlu","Edwards, Reuben","Coulton, Paul"],"enrichments":{"references":[{"id":1026082,"title":"A Proposed Flow Specification\u201d, Internet Engineering Task Force,","authors":[],"date":"1992","doi":null,"raw":null,"cites":null},{"id":1025777,"title":"Access and Terminal Mobility in CORBA\u201d, version 1.2,","authors":[],"date":"2005","doi":null,"raw":null,"cites":null},{"id":1026396,"title":"Cambridge Silicon Radio Newsgroups, news server: \u201cnews.csr.com\u201d, groups: \u201ccsr.public.bluecore.bchs\u201d and \u201ccsr.public.bluecore.bluelab\u201d","authors":[],"date":null,"doi":null,"raw":null,"cites":null},{"id":1025209,"title":"Distributed Systems: Principles and Paradigms\u201c, Prentice Hall; 1st edition,","authors":[],"date":"2002","doi":null,"raw":null,"cites":null},{"id":1026587,"title":"http:\/\/www.omg.org\/technology\/documents\/formal\/audio.htm Ural Mutlu is a PhD student at the Department of Communication Systems,","authors":[],"date":"2000","doi":null,"raw":null,"cites":null},{"id":1025499,"title":"Object Request Broker Architecture: Core Specifications\u201d, version 3.0.3,","authors":[],"date":"2004","doi":null,"raw":null,"cites":null},{"id":1025967,"title":"Official Linux Bluetooth protocol stack,","authors":[],"date":null,"doi":null,"raw":null,"cites":null}],"documentType":{"type":null}},"contributors":[],"datePublished":"2006-07","abstract":"The wireless nature and the mobility of Bluetooth enabled devices combined with the heterogeneity of the wide range of hardware and software capabilities present in those devices makes Bluetooth connection and resource management very complicated and error prone. To manage such diversity of software and hardware, middleware technologies masking the underlying platforms have been designed. One such middleware solution for Bluetooth based on common object request broker architecture (CORBA) is introduced and the mapping of GIOP messages to Bluetooth logical link control and adaptation protocol (L2CAP) links is explained in detail. The paper also describes how CORBA policy objects influence object reference creation and service contexts in the request\/reply sequences and how client-server transport level quality of services (QoS) negotiations are achieved through QoS information embedded in object references and service context","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:22914<\/identifier><datestamp>\n      2018-01-24T02:08:36Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413736<\/setSpec><setSpec>\n      74797065733D626F6F6B5F73656374696F6E<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        QOS Aware CORBA Middleware for Bluetooth.<\/dc:title><dc:creator>\n        Mutlu, Ural Mutlu<\/dc:creator><dc:creator>\n        Edwards, Reuben<\/dc:creator><dc:creator>\n        Coulton, Paul<\/dc:creator><dc:subject>\n        QA76 Computer software<\/dc:subject><dc:description>\n        The wireless nature and the mobility of Bluetooth enabled devices combined with the heterogeneity of the wide range of hardware and software capabilities present in those devices makes Bluetooth connection and resource management very complicated and error prone. To manage such diversity of software and hardware, middleware technologies masking the underlying platforms have been designed. One such middleware solution for Bluetooth based on common object request broker architecture (CORBA) is introduced and the mapping of GIOP messages to Bluetooth logical link control and adaptation protocol (L2CAP) links is explained in detail. The paper also describes how CORBA policy objects influence object reference creation and service contexts in the request\/reply sequences and how client-server transport level quality of services (QoS) negotiations are achieved through QoS information embedded in object references and service contexts<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:date>\n        2006-07<\/dc:date><dc:type>\n        Contribution in Book\/Report\/Proceedings<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:relation>\n        http:\/\/dx.doi.org\/10.1109\/ISCE.2006.1689513<\/dc:relation><dc:identifier>\n        Mutlu, Ural Mutlu and Edwards, Reuben and Coulton, Paul (2006) QOS Aware CORBA Middleware for Bluetooth. In: Consumer Electronics, 2006. ISCE '06. 2006 IEEE Tenth International Symposium on. IEEE. ISBN 1-4244-0216-6<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/22914\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1109\/ISCE.2006.1689513","http:\/\/eprints.lancs.ac.uk\/22914\/"],"year":2006,"topics":["QA76 Computer software"],"subject":["Contribution in Book\/Report\/Proceedings","NonPeerReviewed"],"fullText":"1-4244-0216-6\/06\/$20.00 \u00a92006 IEEE \nQoS aware CORBA Middleware for Bluetooth\nUral Mutlu1, Reuben Edwards2, Paul Coulton3\nAbstract \u2014 The wireless nature and the mobility of \nBluetooth enabled devices combined with the heterogeneity \nof the wide range of hardware and software capabilities \npresent in those devices makes Bluetooth connection and \nresource management very complicated and error prone. To \nmanage such diversity of software and hardware, \nmiddleware technologies masking the underlying platforms \nhave been designed. One such middleware solution for \nBluetooth based on Common Object Request Broker \nArchitecture (CORBA) is introduced and the mapping of \nGIOP messages to Bluetooth Logical Link Control and \nAdaptation Protocol (L2CAP) links is explained in detail. \nThe paper also describes how CORBA policy objects \ninfluence object reference creation and service contexts in \nthe request\/reply sequences and how client-server transport \nlevel Quality of Services (QoS) negotiations are achieved \nthrough QoS information embedded in object references \nand service contexts.  \nIndex Terms \u2014 Middleware, Bluetooth, CORBA, QoS \nI. Introduction \n Applications usually have different Quality of Services \n(QoS) requirements. For example, a file transfer application \nneeds to move data reliably and as quickly as possible; it \ndoes not matter if the link is bursty. On the other hand, an \napplication transferring compressed audio and video streams \nmay want a link that is not as bursty, and may be able to \nmiss a packet as long as the delay on the link is not high. \nTherefore, applications should have the means of declaring \ntheir QoS requirements to the underlying platform, which in \nreturn should make an effort to deliver the required services. \nThe Bluetooth specifications provide QoS configuration \nmechanisms to allow the properties of links to be configured \naccording to the requirements of higher layer protocols [1].  \n Programming Bluetooth link properties is platform \ndependent and requires low level programming, resulting in \nincreased application development time. Therefore, \nmiddleware technologies masking the underlying platform \nand managing connections on behalf of the user have been \ndeveloped. Middleware is a layer above the operating \nsystem but below the application program, it provides a \ncommon programming abstraction across a distributed \nsystem, allowing the underlying system to present a \nstandard \"socket\" for the \"plug\" presented by the application \n[2]. One such widely deployed middleware technology is \nCommon Object Request Broker Architecture (CORBA) \n[3]. 123\n1 Ural Mutlu is with the Department of Communication Systems, \nInfoLab21, Lancaster University, Lancaster, LA1 4WA, UK,                    \n(e-mail:u.mutlu@lancaster.ac.uk). \n This paper shows how CORBA, a platform and language \nindependent object oriented middleware, is employed on \nBluetooth enabled devices in order to develop QoS aware \ndistributed applications. Service invocations in CORBA are \nbased on the client-server paradigm; where a server object is \nthe provider of a service and a client is an object requesting \na service. In CORBA, clients and servers are location \ntransparent and communicate through interoperability \nprotocols. The middleware presented in the paper \nimplements an interoperability protocol over Bluetooth \nLogical Link Control and Adaptation Protocol (L2CAP).  \n CORBA server objects export their address and service \ninformation to the clients as Interoperable Object \nReferences (IOR). A Reference consists of an object type \nfield denoting the type of service offered and one or more \nprofile fields, profiles are further divided into address, \nobject key and component fields. References are generated \nby object adaptors, which also control activation and \nimplementation of server objects depending on the policy \nobjects present. If any of the policies or object services \nrequire exposing invocation related information, the \nrelevant information is generated by the object adaptors and \nembedded into the reference profile components field. \nClient side may investigate references for presence of \nservice information and decide on the action to take. In a \nsimilar manner, if a reply\/request sequence requires \ntransmission of any information besides operation \nparameters and object addressing data, a service context is \ngenerated and embedded within the request or reply \nmessages. In QoS terms, profile components and service \ncontexts represent QoS level offered and QoS level required \nrespectively.\n Our middleware implements a policy object to control \nand manage Bluetooth transport level QoS. The policy \nobject affects the behaviour of the middleware\u2019s connection \nmanagement structure. For example, if the required level of \nservice is higher than offered level, a connection to the \nserver is not established.  \n Section II of the paper introduces CORBA \ncommunication model as well as generation of object \nreferences and policy objects. Section III explains how \nCORBA GIOP requests are transmitted over Bluetooth \nL2CAP, section IV gives an outline of Bluetooth QoS \nspecifications, and the last section explains how QoS \nawareness is achieved in our middleware.  \n2 Reuben Edwards is with the Department of Communication Systems, \nInfoLab21, Lancaster University, Lancaster, LA1 4WA, UK,                    \n(e-mail:r.edwards@lancaster.ac.uk). \n3Paul Coulton is with the Department of Communication Systems, \nInfoLab21, Lancaster University, Lancaster, LA1 4WA, UK,                    \n(e-mail:p.coulton@lancaster.ac.uk) \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 04:15 from IEEE Xplore.  Restrictions apply.\nII. CORBA Communication Model \n CORBA is a framework of standards and concepts for \nopen systems defined by the OMG [3]. In this architecture, \nmethods of remote objects can be invoked transparently in a \ndistributed and heterogeneous environment through an ORB \n(Object Request Broker). The ORB is responsible for all of \nthe mechanisms required to find the object implementation \nfor the request, to prepare the object implementation to \nreceive the request, and to communicate the data making up \nthe request. \n Object invocations in CORBA are based on the client-\nserver paradigm, figure 1. The client is the entity that wishes \nto perform an operation on the object and the server is the \ncode and data that actually implements the object. CORBA \nobjects are defined as interfaces in Interface Definition \nLanguage (IDL). This language defines the types of objects \naccording to the operations that may be performed on them \nand the parameters to those operations.  \nFig. 1. CORBA Communication Model  \n A user-written client application can invoke a method of \na CORBA object by issuing a request to the object through \nthe IDL compiler generated client stub, which is the local \nrepresentation of a CORBA server, figure 1. The presence \nof client stubs in the client side process makes the \ninvocations location transparent, as stubs may be \nrepresenting co-located objects or remote objects. To make \nan invocation a client needs to get an object reference to the \nserver, the process of binding the client to a reference \ncreates the stub, which becomes object\u2019s entry point to the \nORB. Client stub is responsible for marshalling requests to \nserver, and demarshalling replies back to the client.  \n Receiving requests and preparing replies in the server \nside is similar to the client side, with the request\/reply \nmarshalling and demarshalling taking place through the IDL \ncompiler generated server skeletons. However, the server \nprocess is responsible for implementing the interface as a \nservant object and activating the servant, if idle, upon \nreceiving requests for the implemented interface. The ORB \noperations and policies needed to control and manage server \nbehaviour are aggregated in a Portable Object Adaptor \n(POA) interface. The simplest implementation of a POA \nexports a public interface of an object implementation as a \nreference, and a private interface as a skeleton, figure 1.  \n A. Object Interoperability  \n The interaction model seen by CORBA client objects and \nserver objects is connectionless; a client simply sends a \nrequest whenever it needs to, and the request causes a \nvirtual function to be called in the server. Neither client nor \nserver application code ever opens or closes a connection. \nHowever, requests are dispatched over a connection-\noriented transport, so the CORBA run-time environment \nmust take care of managing connections on behalf of clients \nand servers [3]. \n The CORBA specifications define the General Inter-\nORB Protocol (GIOP) as its basic interoperability \nframework. GIOP is not a concrete communication protocol \nthat can be used directly to interact ORBs. Instead, it \ndescribes how to build reply and request messages as well \nas other control massages and how to create and fit a \nparticular transport protocol within the GIOP framework. \nGIOP assumes the underlying transport protocol is \nconnection-oriented, full-duplex, symmetric, provides byte-\nstream abstraction, and indicates disorderly loss of \nconnection. The list of assumptions matches the guarantees \nprovided by the TCP\/IP protocol stack [4]. GIOP realization \nover TCP\/IP is Internet-IOP (IIOP) and for an ORB to be \nCORBA compliant, IIOP must be supported, figure 1.  \n B. Interoperable Object References (IOR) \n As previously mentioned object references are the means \nof identifying an object and are created by a server process \nPOA. Object references are opaque to the client-side \napplication code and completely encapsulate everything that \nis necessary to send requests.  \nFig. 2. Interoperable Object Reference with an IIOP profile  \n Object references consist of two fields; repository id and \nprofile, figure 2. Repository id identifies the most derived \nobject type. Profile on the other hand holds all the \naddressing information necessary for a request message to \nbe delivered, such as: transport protocol, host address, port \nnumber, POA id on which the servant resides, and object id \nof servant implementing the object. Object references may \ncontain more than one profile, if object duplication is \nrequired.   \n The optional tagged components in the profiles are \ngenerated by server side ORB and are used to specify \ntransport or service specific information. The tag, which is \nan unsigned long tells the client how to interpret service \ninformation. \n C. CORBA Policy Objects \n CORBA defines seven POA policies which describe how \nPOA should implement and activate servants. However, \nnone of the seven policies is related to transport level QoS. \nPolicy objects define sets of rules that alter the behaviour of \nClient Server\nGIOP\nIIOP\n ORB A \nGIOP\nIIOP\nORB B\nCORBA\ninvocation\nRequst\/Reply\nTCP\/IP\n Host A \nOS A \nNetwork \nHost B\nOS B \nNetwork \nStub Skeleton\nIOR\nRepository \nIdentifier\nIIOP \nVersion\n     IP \nAddres\n Port Object\nKey\nTagged \nComponents\nTAG\nIIOP\nIIOP Profile \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 04:15 from IEEE Xplore.  Restrictions apply.\nthe ORB, policies do not implement the behaviour \nthemselves. To enable introduction of new policies, the \nOMG declares a CORBA::Policy base interface. New \npolicies can be introduced by declaring a policy inheriting \nfrom the base interface and implementing the new \nbehaviour in the ORB. Applications wishing to control any \nbehaviour defined by policies may do so by creating a \npolicy object with the required parameters [3].  \n CORBA policies are locality-constrained; that is, they \napply only to the server process or the client process \ndepending where they are set. Server-side policies apply to \nthe processing of requests on object implementations, \nwhereas, client-side policies apply to invocations that are \nmade from the client process on an object reference.  \n Some policies and services may require exporting service \nspecific information. If this behaviour is implemented, the \nORB will gather local service information, and pass them \nimplicitly with requests and replies as service contexts in \nGIOP reply or request message headers. Service contexts \nare the same or similar in structure to the profile \ncomponents if used to represent the same information. They \nare key-value pairs as well, where the key identifies how \ndata should be interpreted.  \nIII. GIOP over Bluetooth \n A typical networked Bluetooth application follows the \nmodel described in figure 3. Bluetooth protocols are divided \ninto core protocols and extensions. The core protocols are \npresent on all Bluetooth enabled devices and are Bluetooth \nradio, baseband, Link Manager Protocol (LMP), Logical \nLink Control and Adaptation Protocol (L2CAP), and \nService Discovery Protocol (SDP). The networked \napplication in figure 3 is implemented on top of TCP\/IP \nstack present in the Personal Area Network (PAN) profile \nand the Ethernet protocol in the Bluetooth Network \nEncapsulation Protocol (BNEP) [1].  \nFig. 3: Bluetooth protocol suite \n To realise GIOP messaging in Bluetooth enabled devices, \nthe obvious choice of transport protocol to implement GIOP \nover is the TCP\/IP stack in the PAN. However, Wireless \nAccess and Terminal Mobility extensions of CORBA \n(WCORBA) defines a GIOP tunnelling protocol over the \nwireless link based on L2CAP [5].  \n WCORBA specifications are aimed at mobile \ntransparency to non-mobile nodes. It introduces a transport \nlevel tunnelling protocols, which encapsulate and \ndecapsulate GIOP messages over the wireless transport \nprotocols between the Access Bridge and the Terminal \nBridge, described in detail in [5]. The GIOP Tunnelling \nProtocol assumes that the underlying concrete tunnelling \nprotocol provides the same reliability and ordered delivery \nof messages assumed by the GIOP as mentioned in section \nII.  \n CORBA subgroup working on GIOP tunnel over \nBluetooth, concludes that the tunnelling protocol should be \nimplemented on top of a core Bluetooth protocol and \nBluetooth profiles are not usable because they may not be \navailable on all Bluetooth enabled device. The choice of \nprotocol is L2CAP, which is right above the Host Controller \nInterface (HCI), shown in figure 3, having low overhead \nand providing protocol multiplexing and de-multiplexing for \nupper layers. L2CAP provides connection-oriented data \nservices, a reliable channel and orderly delivery of \nmessages. It also provides notification of disorderly \nconnection loss.  \n Our Bluetooth middleware combines the concepts \nspecified in WCORBA and IIOP to introduce a new \ninteroperability protocol based on L2CAP. The new \nprotocol is L2CAP Inter-ORB Protocol (LIOP), not to be \nconfused with Borland\u2019s Local IOP, and it maps GIOP \nmessages to L2CAP connections, figure 4. LIOP takes the \naddressing structure and message fragmentation rules of \nBluetooth tunnelling protocol from WCORBA \nspecifications, and connection management mechanisms \nfrom Internet Inter-ORB Protocol.  \nFig. 4: GIOP over L2CAP \n The middleware is implemented in MICO [6], a CORBA \nimplementation, on Linux OS and it makes use of Bluez \nBluetooth drivers [7]. The two major factors in our decision \nto use MICO were: the fact that it is a well-maintained open \nsource implementation, and it already implements Bluetooth \ntunnelling protocol profile as part of VIVIAN project [8] \nwhich contributed to the WCORBA specifications.  \n L2CAP packet size is limited by the Maximum \nTransmission Unit (MTU), therefore, GIOP message \nsegmentation and reassembly as described in WCORBA is \nimplemented [5]. The structure of LIOP packets is in the \nflags-length-value format. The flag is one byte and it \ndenotes fragmentation, length is two bytes and gives the \npayload length, the final filed, value contains the payload. \nThe payloads are either entire or fragmented GIOP \nmessages. The length of a LIOP packet is equal to the \ncurrent value of L2CAP MTU. The default L2CAP MTU is \n672 bytes, the minimum length is 48 bytes, and the \nmaximum length is 65535 bytes limited by the two byte \nlength field of L2CAP packet as well as the length field in \nHost\nHost Controller \nApplication\nTCP\/IP\nBNEP\nL2CAP \nLink Manager \nBaseband\nRadio\nStandard \nApplications\nCore\nHCI\nClient\nGIOP\nLIOP\nServer\nGIOP\nLIOP\nObject Invocation \nGIOP request\/reply \nLIOP connection \nL2CAP \nHost\nL2CAP \nHost\nL2CAP connection \nRadio Link \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 04:15 from IEEE Xplore.  Restrictions apply.\nL\nin\nk \nIn\nfo\n \nQ\noS\n V\nio\nla\nti\non\n \nLMP QoS Negotiations \nL2CAP QoS Negotiations L2CAP \nBaseband\nQ\noS\n S\net\nup\n \nL\nin\nk \nC\non\ntr\nol\n \nL\nin\nk \nIn\nfo\n \nQ\noS\n V\nio\nla\nti\non\n \nLMP\nL\nin\nk \nC\non\ntr\nol\n  \nL2CAP \nLMP\nBaseband\nQ\noS\n S\net\nup\n \nthe LIOP packet. A low level call controlling the MTU is \nincorporated in the protocol implementation [1,7].  \nFig. 5: LIOP profile in Interoperable Object References \n The IOR profile specified in the Bluetooth tunnelling \nprotocol defines a host:port pair transport end-point as a \nstring in the <BD_ADDR>#<PSM> format, where \n<BD_ADDR> is a unique 48-bit Bluetooth device MAC \naddress and <PSM> is protocol\/service multiplexer value \n[5]. LIOP implements the same profile as in the Bluetooth \ntunnelling protocol, with the addition of a version and \ntagged components fields, figure 5.  \n If used without QoS policies, described in section V, the \nIIOP connection management strategies implemented in \nMICO are adopted to manage LIOP connections. In this \nform of communication, connection management is \nasymmetric with respect to the roles of the parties at the two \nends of a connection. At one end is the client which initiates \nremote invocations, and at the other end is the server which \nreceives remote invocations [3]. GIOP and IIOP versions \n1.2 introduce bidirectional or symmetric connection \nmanagement where servers can initiate remote invocations \nas well, but bidirectional support is not implemented in our \nmiddleware.  \nIV. Blutooth QoS \n In the protocol stack shown in figure 3, it is the Link \nManager (LM) that configures and controls the baseband \nlink parameters [1]. However, all Bluetooth data \napplications directly or indirectly communicate through the \nL2CAP, except audio transmissions, therefore, Bluetooth \nspecifies L2CAP layer QoS frame that can be sent to the \nLM.\n The QoS frame has a handle to the channel on which the \nparameters should be configured followed by the service \ntype required. The service type could be no traffic, best \neffort or guaranteed. In no traffic mode, the uplink or the \ndownlink should not transmit. Bluetooth traffic model is \nbased on the token bucket algorithm [1, 9, 10], which allows \nfor burstiness in the link if the link is unutilised. If the best \neffort is chosen, the device receiving the request has three \noptions: it may choose to ignore the rest of the parameters, it \nmay try to satisfy the request but not respond, or it may \nrespond with the settings it believes it can achieve [9]. The \nguaranteed service type means for the duration of the \nconnection the LM will honour the agreed QoS level.  \nThe frame consists of the following link parameters:  \n\u00b7 Token rate: the continuous data rate required \n\u00b7 Token bucket size: the maximum burst data that can be \nsent\n\u00b7 Peak bandwidth: the maximum data rate equivalent to a \ncontinuous transmission \n\u00b7 Latency: the maximum acceptable delay to air \n\u00b7 Delay variation: the variation in time delay between    \npackets\n An application requiring a specific QoS on the outgoing \nL2CAP connection constructs a QoS frame and starts \nL2CAP level QoS negotiations as shown in figure 6.\nAlthough, Bluetooth QoS negotiations can be classified as \nL2CAP level negotiations and LM level negotiations, at the \nmoment L2CAP negotiations initiated by the user do not \ntake place between L2CAP entities but take place at the \nLMP [9].  \n The QoS frame is inspected by the LM, and the LM \ndecides what channel parameters to set, or reject the QoS \nsetup request. A QoS setup command is followed by either a \nsetup complete or a QoS rejected HCI event in the LM-\nL2CAP direction. A positive QoS setup response contains \nQoS level accepted, whereas a negative response returns \noffered QoS level. A higher layer application can use the \nQoS level offered in the negative response to decide if it \nwants to start QoS renegotiations.  \nFig. 6: Bluetooth QoS negotiations \n If the LM on which outgoing QoS parameters are being \nconfigured is a Bluetooth channel master, it sends its QoS \nparameters to the slave LM, which in return has to set its \nincoming link parameters accordingly and cannot reject the \nparameters. If the QoS setup is initiated by the slave LM, \nthe master LM may accept or reject incoming link \nparameters, either way; the master LM returns accepted or \noffered QoS parameters. Slave LM may choose to start \nrenegotiations, or pass a negative response with the QoS \noffered to the higher layers.  \n The mapping between the L2CAP QoS requirements and \nbaseband link parameters is not specified and is \nmanufacturer specific. It should be noted that at the time of \nwriting not all commercial Bluetooth implementations \nsupport guaranteed QoS service type or they are interpreted \ndifferently [9, 11]. \nV. QoS Awareness \n In the CORBA framework, communication channels are \ncreated by the ORB. Therefore, transport level QoS \nrequirements of an application must be implemented in the \nORB.\n To achieve QoS awareness, connection management \nstrategies of the middleware have been modified according \nto the concepts introduced in section II. The ORB exposes \nLIOP\nVersion \nBD_ADDR PSM Object key Tagged \nComponents \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 04:15 from IEEE Xplore.  Restrictions apply.\nthe control of some of its behaviour through policy objects. \nThe mechanisms that can be programmatically set by \npolicies are object reference generation, and inclusion of \nservice contexts in GIOP messages.  \n A. Mapping Application QoS to LM  \n CORBA provides applications with methods to create \npolicy objects and set policy values. If QoS aware mode of \nthe middleware is desired, create_policy is called with \nBTQoS_POLICY_TYPE and BTQoSFrame as input \nparameters, shown in the code snippet below. Both, client \nand server create the same policy objects but they are \ninterpreted differently. Server created policy denotes QoS \noffered by the server and client created policy is QoS \nrequired by the client. The process of creating policy objects \nmaps application level QoS values to middleware level \nvalues.  \nmodule BTQoS { \n const CORBA::PolicyType BTQoS_POLICY_TYPE=123; \n struct BTQoSFrame { \n unsigned short ServiceType; \/\/0-best effort, 1-guaranteed \n unsigned long TokenRate; \/\/bytes per second  \n unsigned long TokenBucketSize; \/\/bytes per second \n unsigned long Peakbandwidth; \/\/bytes per second \n unsigned long Latency; \/\/milliseconds  \n unsigned long DelayVariation; \/\/milliseconds  \n }; \n local interface BTQoSPolicy:CORBA::Policy { \n  readonly attribute BTQoSFrame bt_qos; \n }; \n};\n Once created, policies should be set to a scope in which \nthey are valid. Although, applications can set the policy \nscope to be ORB, POA, object reference, or current \nexecution thread, QoS behaviour of the ORB has been \nimplemented to be affected by POA and object reference \npolicies. Therefore, the server sets policy overrides at the \nPOA on which it resides, and client sets policy overrides at \nobject reference scope.  \n Most of the applications do not require setting all the \nfields in the QoS frame. For example, audio and video \napplications generally declare frame rate, and a time \ninterval, which translate to token rate and latency or delay \nvariation in the QoS frame. If an application does not need \nto specify any of the parameters, they should be set to 0, \nwhich translates to \u201cdo not care\u201d in the QoS frame.  \nFig. 7: QoS Aware Middleware \n B. IOR Components and Service contexts  \n POA policies concern both the server ORB and the client \nORB. In the server side, POA has a reference template \nwhich gets updated if there are any changes in the \nenvironment; in this case, setting QoS policy overrides at \nthe POA results in BTQoSFrame being added to the \ncomponent field in the template. Any references generated \nby the POA with QoS policy will contain QoS parameters in \nthe component field, figure 7.  \n In the client side, QoS reference component information \nis interpreted by the ORB as QoS offered. CORBA also \nprovides methods to the client to read component fields on \nwhich they are to invoke operations. This enables the client \nto make QoS related decisions without middleware\u2019s \ninvolvement.  \nClient generated object policies are translated into service \ncontexts by the ORB. Any invocations on the given object \nwill trigger the ORB to insert a service context in the GIOP \nrequest message, figure 7. POA also generates service \ncontexts at the server to be included in GIOP reply \nmessages to denote current level of QoS offered by the \nserver. This second QoS frame is essential, because, \nreferences might be representing an object that was created \nsome time ago and conditions might have changed since its \ncreation.\n C. Connection Management  \n In the basic form of connection management, the ORB \ngenerates transport objects for each connection. Transport \nobjects, incorporate all the methods necessary to set up a \nconnection and transfer data. In QoS mode, a connection \nhandle to an active connection is needed, this connection \nhandle is not the same as a socket, but it is an ACL channel \nnumber [1]. Therefore, the transport objects of the ORB \nhave been modified to uses Bluez libraries to enable \ncommunication with the HCI, thus indirectly with the LM. \nHCI is an interface between the Bluetooth module and the \nlocal host, its only functionality is passing messages from \nthe LM to L2CAP and vice versa [1]. Also, a callback \nobject is assigned to poll LM generated events through the \nHCI.  \n When a client makes an invocation on a remote object, \nthe ORB compares the QoS level offered in the profile \ncomponent with the QoS required which is present in the \nobject policies overridden by the client. If the server QoS \nparameters satisfy client\u2019s requirements, client ORB \nconstructs a GIOP request message with BTQoSFrame in \nthe service context field and establishes a remote LIOP \nconnection to the server and sends the GIOP header \nfollowed by the GIOP request header.  \n The server ORB accepts the LIOP connection and \nreceives GIOP header and GIOP request header and extracts \nClient\n                  ORB \nLinux OS Bluez \nL2CAP \nLMP \nBTQoSPolicy \nGIOP \nLIOP \nStub\nServer\n         ORB \n    Linux OS\nBTQoSPolicy \nGIOP \nLIOP \nPOA \nBluez \nL2CAP \nLMP \nSkeleton \nLMP QoS \ncreate\nRequest Reply Path \nQoS Messaging  \nORB QoS \nIOR\nrequest\nreplycreate policy\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 04:15 from IEEE Xplore.  Restrictions apply.\nservice context information. Although, client side ORB \nalready checked the validity of the QoS frame, server ORB \nchecks the frame again in case there have been changes in \nthe conditions since the reference was created. If the ORB \ndecides the QoS values set in the request header can be \nsatisfied, it builds an L2CAP QoS setup frame and sends it \nto the LM. At this point it is assumed that the server side \nBluetooth is a link master, if not, switch mode function is \ncalled to make the server side link master. If the server \ndecides QoS can not be met, an exception message with \nQoS frame as an attribute is raised.  \n Section IV describes that, QoS setup command is \nfollowed by positive or negative responses in both the slave \nand the master. Therefore, the client ORB does not need an \nacknowledgement from the server ORB. If the client LM \npoller callback object signals the ORB with a positive \nresponse, client ORB starts sending GIOP payload and \nserver ORB starts receiving. If a negative response is \nreceived, QoS offered by the LM is polled from the HCI and \nan exception is raised to the client. The attribute of the \nexception message is the offered QoS received from the \nLM. The client may choose to restart the whole process with \nlesser QoS requirements.  \n The server executes and builds a reply message. At this \npoint, if the server object is aware of any changes in the \nconditions, it should set new policy overrides to be \ntransmitted with the GIOP reply message. The ORB \nconstructs the GIOP reply message with a service context \nrepresenting the current QoS offered.  \n D. Comments  \n It is assumed that Bluetooth controller implements link \nlevel QoS control, scheduling, buffering and polling \nalgorithms and makes an effort in adverse traffic conditions \nto satisfy QoS guarantees and generates events if there are \nany unexpected changes. Therefore, the ORB does not have \nto implement any channel parameter calculating algorithms.  \n Currently, QoS requirements are set only in the downlink \nor server-client direction, because the assumption is that \nQoS is required only in one direction. However, if an \napplication requires bidirectional QoS, a policy object with \nQoS parameters for both directions could be created.  \n Since there is not a parameter for link error rate, LMP \nassumes an error free link is required. However, error free \nlink means infinite retransmission time. The LM retransmits \nfor a certain, manufacturer pre-set, time interval during \nwhich the latency value set might be passed. The first time a \npacket is delivered late, the LM does not generate a link \ndisconnection or QoS violation event, instead the LM starts \na counter and keeps the connection alive until the counter \nthreshold is reached [11]. Infinite retransmission time can \nhave a negative effect in some real-time applications that do \nnot need a data packet that has passed its validity time. If \nthe middleware is to be used in such environments, the \npolicy object could be modified to include a Bluetooth flush \ntimeout parameter defining the duration of data validity.  \nVI. Conclusion \n The paper contributes in two aspects, first it \ndemonstrated how Bluetooth could be deployed in \ndistributed system like CORBA without the need for \nTCP\/IP stack. The second contribution is QoS awareness of \nthe middleware. The ideas presented could be used to \ndevelop Bluetooth applications that make full use of the \nmature specifications of CORBA.   \n With the introduction of Bluetooth 2.0 specifications and \nenhanced data rate (EDR) features, Bluetooth could be \nemployed to stream video in the near future. To stream data \nwith strict time constraints it will be important to manage \nQoS parameters of connections. One possible use of the \nmiddleware is in conjunction with the audio\/video \nstreaming service specifications of CORBA [12]. In these \nspecifications, stream sources declare the QoS parameters \nthat should be satisfied by transport protocols. Those values \ncould be mapped to Bluetooth channel parameters to \nsupport QoS in audio\/video streams.  \n It should also be noted that the tag values used in the \nLIOP and QoS tagged component as well as the service id \nvalue in the QoS service context are OMG administered, \nand the numbers implemented in the middleware were \nchosen randomly. Anyone wishing to deploy the protocols \nin large scale should apply for allocation of suitable \nnumbers.  \nREFERENCES\n[1] Bluetooth SIG \u2013 \u201cSpecification of the Bluetooth System\u201d, \nhttp:\/\/www.bluetooth.org\/foundry\/adopters\/document\/Core_v2.0_ED\nR\n[2]  Andrew S. Tanenbaum, Maarten van Steen, \u201cDistributed Systems: \nPrinciples and Paradigms\u201c, Prentice Hall; 1st edition, 2002 \n[3]  OMG, \u201cCommon Object Request Broker Architecture: Core \nSpecifications\u201d, version 3.0.3, March 2004, \nhttp:\/\/www.omg.org\/technology\/documents\/formal\/corba_iiop.htm  \n[4]  Michi Henning, Steve Vinoski, \u201cAdvanced CORBA(R) Programming \nwith C++\u201d, Addison-Wesley Professional, 1st edition, 1999 \n[5]  OMG, \u201cWireless Access and Terminal Mobility in CORBA\u201d, version \n1.2, May 2005, \nhttp:\/\/www.omg.org\/technology\/documents\/formal\/telecom_wireless.\nhtm \n[6]  MICO CORBA, http:\/\/www.mico.org\/ \n[7]  Bluez, Official Linux Bluetooth protocol stack, http:\/\/www.bluez.org \n[8]  VIVIAN, ITEA 99040, http:\/\/www-nrc.nokia.com\/Vivian\/ \n[9]  Jennifer Bray and Charles F Sturman, \u201cBluetooth Connect Without \nCables\u201d, Prentice Hall, 2001 \n[10]  C. Partridge, \u201cA Proposed Flow Specification\u201d, Internet Engineering \nTask Force, Internet Informational RFC 1363, September 1992, \n  http:\/\/www.ietf.org\/rfc\/rfc1363.txt  \n[11] Cambridge Silicon Radio Newsgroups, news server: \u201cnews.csr.com\u201d, \ngroups: \u201ccsr.public.bluecore.bchs\u201d and \u201ccsr.public.bluecore.bluelab\u201d \n[12]  OMG, \u201cAudio\/Video Stream Specification\u201d, Jan 2000, \nhttp:\/\/www.omg.org\/technology\/documents\/formal\/audio.htm \nUral Mutlu is a PhD student at the Department of \nCommunication Systems, Lancaster University, UK. Mr \nMutlu has a BEng in Electrical and Electronic \nEngineering and MSc in DSP Applications in \nCommunication Systems. His research interests are data \nnetworks, middleware technologies and mobile communications with focus \non middleware technologies for mobile and wireless communications.  \nDr R. Edwards is a Lecturer at Lancaster University. \nReuben has extensive research and development \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 04:15 from IEEE Xplore.  Restrictions apply.\nexperience in mobile systems and applications and has published \nextensively. He is also a member of the IEEE.  \nDr Paul Coulton is a Senior Lecturer at Lancaster \nUniversity and a founding member of Forum Nokia \nChampion. Paul has over 10 years' research and \ndevelopment experience in mobile systems and \napplications and has published extensively. The main \nfocus of his current research surrounds innovative m-\ncommerce solutions with a particular emphasis on mobile entertainment. \nHe is also a member of the IEEE, IGDA.\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 04:15 from IEEE Xplore.  Restrictions apply.\n"}