{"doi":"10.1109\/ICTTA.2006.1684935","coreId":"69733","oai":"oai:eprints.lancs.ac.uk:22927","identifiers":["oai:eprints.lancs.ac.uk:22927","10.1109\/ICTTA.2006.1684935"],"title":"QoS Aware Bluetooth Middleware.","authors":["Mutlu, Ural Mutlu","Edwards, Reuben","Coulton, Paul"],"enrichments":{"references":[{"id":1024744,"title":"Bluetooth Connect Without Cables&quot;,","authors":[],"date":"2001","doi":null,"raw":null,"cites":null},{"id":1023972,"title":"Distributed Systems: Principles and Paradigms&quot;, Prentice Hall; 1st edition","authors":[],"date":"2002","doi":null,"raw":null,"cites":null},{"id":1024233,"title":"Management Group, &quot;The Common Object Request Broker Architecture: Architecture and Specifications&quot;, version 3.0.,","authors":[],"date":"2005","doi":null,"raw":null,"cites":null},{"id":1024489,"title":"Object Management Group, &quot;Wireless CORBA Specifications&quot;,","authors":[],"date":"2004","doi":null,"raw":null,"cites":null}],"documentType":{"type":null}},"contributors":[],"datePublished":"2006-04","abstract":"Bluetooth application developers have to address technical challenges imposed by the heterogeneity of the wide range of hardware and software capabilities present in the Bluetooth enabled devices. The wireless nature and the mobility of devices place an added strain on resource management. To manage such diversity of software and hardware, middleware based solution with the emphasis on transport level quality of service (QoS) management is proposed. An implementation of the common object request broker architecture (CORBA) interoperability protocol over Bluetooth logical link control and adaptation protocol (L2CAP) and L2CAP level QoS abstraction as CORBA service context and tagged components is presented. Service context information is added to the request and reply messages through portable interceptors, which in return signals a manager object of QoS level requirement","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:22927<\/identifier><datestamp>\n      2018-01-24T02:08:42Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413736<\/setSpec><setSpec>\n      74797065733D626F6F6B5F73656374696F6E<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        QoS Aware Bluetooth Middleware.<\/dc:title><dc:creator>\n        Mutlu, Ural Mutlu<\/dc:creator><dc:creator>\n        Edwards, Reuben<\/dc:creator><dc:creator>\n        Coulton, Paul<\/dc:creator><dc:subject>\n        QA76 Computer software<\/dc:subject><dc:description>\n        Bluetooth application developers have to address technical challenges imposed by the heterogeneity of the wide range of hardware and software capabilities present in the Bluetooth enabled devices. The wireless nature and the mobility of devices place an added strain on resource management. To manage such diversity of software and hardware, middleware based solution with the emphasis on transport level quality of service (QoS) management is proposed. An implementation of the common object request broker architecture (CORBA) interoperability protocol over Bluetooth logical link control and adaptation protocol (L2CAP) and L2CAP level QoS abstraction as CORBA service context and tagged components is presented. Service context information is added to the request and reply messages through portable interceptors, which in return signals a manager object of QoS level requirements<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:date>\n        2006-04<\/dc:date><dc:type>\n        Contribution in Book\/Report\/Proceedings<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:relation>\n        http:\/\/dx.doi.org\/10.1109\/ICTTA.2006.1684935<\/dc:relation><dc:identifier>\n        Mutlu, Ural Mutlu and Edwards, Reuben and Coulton, Paul (2006) QoS Aware Bluetooth Middleware. In: Information and Communication Technologies, 2006. ICTTA '06. 2nd. IEEE. ISBN 0-7803-9521-2<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/22927\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1109\/ICTTA.2006.1684935","http:\/\/eprints.lancs.ac.uk\/22927\/"],"year":2006,"topics":["QA76 Computer software"],"subject":["Contribution in Book\/Report\/Proceedings","NonPeerReviewed"],"fullText":"QoS Aware Bluetooth Middleware\nUral Mutlu, Reuben Edwards, Paul Coulton\nDepartment ofCommunication Systems, InfoLab, Lancaster University, Lancaster, UK\nu. mutlu@lancaster. ac. uk, r. edwards@lancaster. ac. uk, p. coulton@lancaster. ac. uk\nAbstract\nBluetooth application developers have to address\ntechnical challenges imposed by the heterogeneity of the\nwide range of hardware and software capabilities\npresent in the Bluetooth enabled devices. The wireless\nnature and the mobility ofdevices place an added strain\non resource management. To manage such diversity of\nsoftware and hardware, middleware based solution with\nthe emphasis on transport level Quality ofService (QoS)\nmanagement is proposed. An implementation of the\nCommon Object Request Broker Architecture (CORBA)\nInteroperability Protocol over Bluetooth Logical Link\nControl and Adaptation Protocol (L2CAP) and L2CAP\nlevel QoS abstraction as CORBA service context and\ntagged components is presented Service context\ninformation is added to the request and reply messages\nthrough portable interceptors, which in return signals a\nmanager object ofQoS level requirements.\n1. Introduction\nSince its launch in 1999, Bluetooth has become one of\nthe most popular wireless connectivity solutions for\nsmall devices such as mobile phones, portable\ncomputers, PDAs, Internet Access Points (AP), printers,\netc [1]. The primary goal of Bluetooth specifications was\nto eliminate the wires, which litter the floors of offices\nand homes and at the same time to provide the user with\na Personal Area Network (PAN). Bluetooth enabled\ndevices, not only network a variety of personal and\nwearable devices within the space surrounding a person,\nbut they also provide connection with the Internet.\nApplications using Bluetooth radio may have\ndifferent QoS requirements. For example, a file transfer\napplications needs to move data reliably and as quickly\nas possible; it does not matter if the link is bursty. On the\nother hand, an application transferring compressed audio\nand video streams may want a link that is not as bursty,\nand may be able to miss a packet only as long as the\ndelay on the link is not high. The Bluetooth\nspecifications provide QoS configuration based on the\ntoken bucket algorithm to allow the properties of links to\nbe configured according to the requirements of higher\nlayer protocols [1].\nThis paper proposes the management of Bluetooth\nlinks through middleware technologies that isolate the\nunderlying platforms from the higher-level applications\nthat have been developed. Middleware is a layer above\nthe operating system but below the application program,\nit provides a common programming abstraction across a\ndistributed system, allowing the underlying system to\npresent a standard \"socket\" for the \"plug\" presented by\nthe application [2]. One such widely deployed\nmiddleware technology is Common Object Request\nBroker Architecture (CORBA) [3].\nCORBA, a platform and language independent object\noriented middleware, is employed on Bluetooth enabled\ndevices in order to develop Quality of Services (QoS)\naware distributed applications. The proposed architecture\nmakes use of Inter-ORB Protocols (IOP) to carry\nrequests and replies over Bluetooth L2CAP, tagged\ncomponents embedded in Interoperable Object\nReferences (IOR) to show possible QoS levels offered\nby servers, service contexts information carried in the\nrequest and reply messages to define QoS level required\nby the client and QoS level offered by the server, and\nfinally Portable Interceptor (PI) objects which\ninvestigate the service context and act as QoS manager\nand negotiator.\nSection 2 gives an outline of the CORBA\ntechnologies involved in the communication process and\nQoS management process. Section 3 explains how\nCORBA requests are transmitted over Bluetooth.\nL2CAP QoS negotiations, and their implementation in\nBluetooth are shown in section 4 and 5. The last part of\nthe paper shows our experimental middleware, and\nfinishes with the discussions and future work.\n2. QoS Management in CORBA\nCORBA is a framework of standards and concepts for\nopen systems defined by OMG [3]. In this architecture,\nmethods of remote objects can be invoked transparently\nin a distributed and heterogeneous environment through\nan ORB (Object Request Broker). The ORB is\nresponsible for all of the mechanisms required to find the\nobject implementation for the request, to prepare the\nobject implementation to receive the request, and to\ncommunicate the data making up the request. The\nCORBA specification establishes the role of each ORB\ncomponent in the environment and defines its interfaces.\nCORBA interfaces are specified as a layer, masking\ndifferences between distinct lower-level systems.\nObject invocations in CORBA are based on the client-\nserver paradigm. The client is the entity that wishes to\nperform an operation on the object and the server is the\ncode and data that actually implements the object.\nCORBA objects are defined as interfaces in Interface\nDefinition Language (IDL). This language defines the\ntypes of objects according to the operations that may be\n0-7803-9521-2\/06\/$20.00 \u00a72006 IEEE. 3239\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 05:01 from IEEE Xplore.  Restrictions apply.\nperformed on them and the parameters to those\noperations.\nr-------------- IOR\nCORBA\n'invocation 1SreIClient 4 24Ca Server\nStub Skeleton\nr- -rF----------\nI ~~~~ Requst\/Reply OB\nI GIOPI 4-* 7 GIOP\nIIO a TCPIP IIOPF\nHost A Host B'\nl OSA |lOSB|\nNetwork Newok\nFigure 1. CORBA Communication Model\nA user-written client application can invoke a method\nof a CORBA object by issuing a request to the object\nthrough the IDL compiler generated client stub, which is\nthe local representation of a CORBA object. The\npresence of client stubs in the client side process makes\nthe invocations location transparent, as stubs can be\nrepresenting co-located objects or remote objects. To\nmake an invocation a client needs to get an Interoperable\nObject Reference (IOR) to the server, the process of\nbinding the client to a reference creates the stub, which\nis object's entry point to the ORB. Client stub is\nresponsible for marshalling requests to server, and\ndemarshalling replies back to the client.\nReceiving requests and preparing replies in the server\nside is similar to the client side, with the request\/reply\nmarshalling and demarshalling through the server\nskeleton. However, the server is responsible for\nimplementing the interface as a servant object and\nactivating the servants upon receiving requests for the\nparticular servant. The process of activating servants\ngenerates an IOR, which is propagated to the client. The\nconcept of server is more complicated than client and\ndescribed further in [3].\n2.1. IOR\nAs previously mentioned Interoperable Object\nReferences (IOR), the means of identifying an object, are\ncreated by servers, figure 2. Object references are\nopaque to the client-side application code and\ncompletely encapsulate everything that is necessary to\nsend requests, including the transport to be used. Object\nreferences consist oftwo fields; repository id and profile.\nRepository id identifies the most derived object type.\nProfile on the other hand holds all the addressing\ninformation necessary for a request message to be\ndelivered, such as transport protocol, host address, port\nnumber, server side portable object adapter id, and object\nfor holding service-specific information. IORs are not\nrestricted to one profile. For example, some applications\nmight require object duplication for load balancing and\nfault tolerance and implement multiple servers on\ndifferent locations, which are separate profiles of the\nsame object and are represented as multiple profiles in\nthe IOR, figure 1. The ORB investigates the IOR and\ndynamically chooses the best profile to be used.\nFigure 2. Interoperable Object Reference\nThe optional tagged components in IOR profiles, are\ngenerated by server side ORB and are used to specify\ntransport or service specific information. The tag, which\nis an unsigned long tells the client how to interpret that\nbinary data.\n2.2. Object Interoperability\nThe interaction model seen by CORBA client objects\nand server objects is connectionless; a client simply\nsends a request whenever it needs to, and the request\ncauses a virtual function to be called in the server.\nNeither client nor server application code ever opens or\ncloses a connection. However, requests are dispatched\nover a connection-oriented transport, so the CORBA\nrun-time environment must take care of managing\nconnections on behalf of clients and servers [3].\nThe CORBA specifications define the General Inter-\nORB Protocol (GIOP) as its basic interoperability\nframework. GIOP is not a concrete communication\nprotocol that can be used directly to interact ORBs.\nInstead, it describes how to build reply and request\nmessages as well as other control massages and how to\ncreate and fit a particular transport protocol within the\nGIOP framework. GIOP assumes the underlying\ntransport protocol is connection-oriented, full-duplex,\nsymmetric, provides byte-stream abstraction, and\nindicates disorderly loss of connection. The list of\nassumptions exactly matches the guarantees provided by\nthe TCP\/IP protocol [4]. GIOP realization over TCP\/IP\nis Internet-IOP (IIOP) and for an ORB to be CORBA\ncompliant, IIOP must be supported.\nid of servant implementing the object. Profile has an\noptional field called Tagged Component, which is used\n0-7803-9521-2\/06\/$20.00 \u00a72006 IEEE. 3240\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 05:01 from IEEE Xplore.  Restrictions apply.\n2.3. Service Contexts and Portable Interceptors\nGIOP request and reply message headers contain\nservice contexts, which are key-value pairs to be used by\nspecific services. Service contexts were first used to help\nimplement some of the CORBA Services. However,\ndocumented APIs made it possible for application\ndevelopers to use service contexts as well. An\napplication can use a portable interceptor to add a\nservice context to outgoing messages and can interrogate\nincoming messages to see if they contain a service\ncontext that corresponds to a specified integer identifier.\nIn this way, if an application receives a service context\nthat it is not expecting then the service context is simply\nignored, figure 2.\nto do with the parameters. One way to deal with the\ntransport level issues would be registering an manager\nobject to the interceptors, that deals with the specific\nissues.\n3. Bluetooth as CORBA Transport\nTo realise GIOP over Bluetooth the obvious choice of\ntransport protocol to be implemented is the TCP\/IP stack\nin the Bluetooth Network Encapsulation Protocol\n(BNEP). However, Wireless Access and Terminal\nMobility specification of CORBA (WCORBA) define a\nGIOP tunnelling protocol over the wireless link based on\nLogical Link Control and Adaptation Protocol (L2CAP)\n[5].\n|Server|\nInterce-ptor\nORB\nOS\nNetwork\nFigure 3. Message flow with interceptors\nEarly CORBA products were monolithic, application\nprogrammers had little or no opportunity to extend the\nrange of capabilities that they offered. Now CORBA\nprovides a plug-in architecture that allows people to add\nnew code to a CORBA product, and is predictably called\nportable interceptor. Interceptors can intercept some of\nthe ORB functionality to modify the ORB's behavior.\nThere are two types of portable interceptors: IOR\ninterceptors and request interceptors.\nAn IOR interceptor is called when an IOR is being\ncreated. The IOR interceptor can find out which policies\nwere used in the object's POA and can use this\ninformation to decide if it wants to embed an extra\ntagged component into the IOR.\nThere are two types of request interceptor: one that\ndeals with the client-side mechanics of sending a request\nand receiving a reply, and another that deals with the\nserver-side mechanics of receiving a request and sending\na reply. A request interceptor is called at various points\nalong the transmission of request and reply messages.\nIn CORBA communication channels are created by\nthe ORB, therefore, QoS requirements of an application\nmust be implemented at the ORB. CORBA\nimplementations are very mature and most of the TCP\/IP\nmanagement issues have been resolved. However, a third\nparty middleware developer should not open the closed\nbox an ORB presents to specify connection specific\nparameters. Portable interceptors allow middleware\ndevelopers to add interception points along the message\ntransmission path that can be used to observe and set\nQoS parameters. It is up to the interceptor to decide what\n-]\n~~~Host\nApplication- BNEP\n__.\nL2CAP J- C\nLink Manager\nCore Baseband Host Controller\nRadio J\nFigure 4: Bluetooth protocol suite\nWCORBA specifications are aimed at mobile\ntransparency to non-mobile nodes. Therefore, only the\nmobile node should implement the extensions.\nWCORBA introduces a transport level tunneling\nprotocol, which encapsulate and decapsulates GIOP\nmessages over the wireless transport protocol and should\ncarry GIOP messages from the Access Bridge to the\nMobile Terminal described in detail in [5]. The GIOP\nTunneling Protocol assumes that the underlying concrete\ntunneling protocol provides the same reliability and\nordered delivery of messages assumed by the GIOP as\nmentioned in section 2.\nWCORBA subgroup working on GIOP tunnel over\nBluetooth, concludes that the tunneling protocol should\nbe implemented on top of a core Bluetooth protocol and\nBluetooth profiles are not usable because they are not\npart of the core Bluetooth specifications. The choice of\nprotocol is L2CAP, which is right above the Host\nController Interface (HCI) having low overhead and still\nproviding protocol multiplexing and de-multiplexing for\nupper layers. L2CAP provides connection-oriented data\nservices, a reliable channel and orderly delivery of\nmessages. It also provides notification of disorderly\nconnection loss.\nL2CAP Tunneling Protocol (LTP) defines a host:port\npair transport end-point as a string in the\n<BD_ADDR>#<PSM> format, where <BD ADDR> is\na unique 48-bit Bluetooth device M\\AC address and\n<PSM> is protocol\/service multiplexer value. Apart\nfrom end point information, LTP profile works in the\nsame way as profiles explained earlier, figure 5.\n0-7803-9521-2\/06\/$20.00 )2006 IEEE.\n|Client|\nInterceptor )\nORB\nOS\n324 1\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 05:01 from IEEE Xplore.  Restrictions apply.\nLTP BD ADDR PSM Object key Tagged\nComponents\nFigure 5: LTP profile in IOR\nAlthough the proposed protocol is a tunneling\nprotocol, the protocol requires implementation of IOR\nprofile to specify tunnel end-points. The presence of IOR\nprofile and the implementation of a concrete protocol\nover which to carry GIOP messages means that objects\nresiding on Bluetooth enabled devices are discoverable\nand they operate in the same manner as non-mobile\ndevices. The term tunneling protocols is used to describe\nprotocols that encapsulate messages of other formats, but\nif used as transport protocol to carry local data rather\nthan packets of other formats becomes misleading. For\nthe rest of the paper, the term LTP is used but it should\nnot be taken literally as a tunneling protocol.\n4. Blutooth QoS\nBluetooth offers Asynchronous Connectionless\n(ACL) and Synchronous Connection-oriented channel\ntypes. SCO links are mainly used by Bluetooth audio\nprofile. At lower level SCO packets are transmitted at\nfixed intervals, and offer no retransmission. Bluetooth\n1.2 and 2.0 improve QoS of SCO channels by allowing\nretransmission before the next packet is due. However,\nL2CAP data is transmitted on ACL channels, therefore,\nonly ACL channels are considered [1].\nWithin the protocol stack shown in figure 4, it is the\nLink Manager (LM) that configures and controls the\nbaseband links. Bluetooth offers application\nprogrammers HCI layer calls to set and observe some\nLink Manager Protocol (LMP) parameters such as\npacket type, and flush timeout which affect the\nbandwidth, latency, and error rate of the channels.\nSetting LMP parameters from higher-level protocols\ngives the programmer a high degree of control but it is\ntedious and time consuming to observe all link\nparameters from the higher layers. Therefore, Bluetooth\nspecifies L2CAP layer QoS frame that can be sent to the\nLM. The LM inspects the QoS frame sent by the higher\nlayer and decides what channel parameters to set, or\nrejects the parameters. A QoS setup command is\nfollowed by either a setup complete or a QoS rejected\nHCI event in the reverse direction.\nIf the LM receiving QoS setup command is a master,\nit sends the new QoS parameters to the slave LM, which\nin return has to set its link parameters accordingly. If the\nQoS setup is initiated by the slave LM, the master LM\nmay accept or reject the parameters. The direction of\nsetup initiation is also the direction of data flow, slave\ninitiated channel is the uplink, the reverse is the\ndownlink.\nThe QoS frame has a handle to the channel on which\nthe parameters should be configured followed by the\nservice type required. The service type could be no\ntraffic, best effort or guaranteed. No traffic means, the\nuplink or the downlink should not transmit. If the best\neffort is chosen, the device receiving the request has\nthree options: it may choose to ignore the rest of the\nparameters, it may try to satisfy the request but not\nrespond, or it may respond with the settings it believe it\ncan achieve [6]. The guaranteed service type, based on\nthe token bucket algorithm, allows for burstiness in the\nlink and it requires the following parameters:\nToken rate: the continuous data rate required\nToken bucket size: the maximum burst data that can\nbe sent\nPeak bandwidth: the maximum data rate equivalent to\na continuous transmission\nLatency: the maximum acceptable delay to air\nDelay variation: the variation in time delay between\npackets\nSince there is not a parameter for link error rate, the\nassumption is that an error free link is required.\nHowever, error free link means infinite retransmission\ntime, or retransmission time of a pre-set value. The\nretransmission rate is controlled by the flush timeout\nparameter in the LM, which defines the validity duration\nof data in the buffers and if the timer expires, the buffer\nis flushed and new data is written to the buffer [6].\nThe mapping between the L2CAP QoS requirement\nand baseband link parameters is not specified and is\nmanufacturer specific. It should be noted that at the time\nof writing not all commercial Bluetooth implementations\nsupport QoS parameters or they are interpreted\ndifferently [6].\n5. QoS aware Bluetooth middleware\nAs part of our research we designed an experimental\nBluetooth middleware using MICO as a CORBA\nimplementation [7]. The two major factors in our\ndecision to use MICO were: the fact that it is a well-\nmaintained open source implementation, and it already\nimplements LTP as part of VIVIAN project [8] which\ncontributed to the WCORBA specifications. However, in\nour experience the protocol did not compile out of the\nbox, and minor bug fixes were needed. The modular\ndesign, through well-written base classes, of MICO\nmakes adding new components to it less time-consuming\nas opposed to some other CORBA implementations\nwhich hard-code the functionality into the base classes,\nthus requiring re-engineering of the middleware to add\nnew functionalities.\nMICO LTP has been designed to make use of Bluez\nBluetooth drivers on Linux machines [9]. At low level\nthe LTP calls L2CAP sockets to establish connections,\ntherefore, the protocol can be ported to any platform that\nhas Bluetooth drivers with minor alterations.\nOur QoS aware Bluetooth middleware\nimplementation makes use of the concepts described in\nsection 2. Server generated LTP IOR tagged components\nrepresent QoS offered by the server in the downlink as\nwell as the parameters a client needs in the uplink.\n0-7803-9521-2\/06\/$20.00 \u00a72006 IEEE. 3242\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 05:01 from IEEE Xplore.  Restrictions apply.\nUplink information is necessary, because in Bluetooth\nnodes can connect to 7 devices simultaneously, and each\nof those devices might be connected to other piconets at\nthe same time forming scatternets, and a correspondent\nnode might be utilising its channels heavily. The\ninformation within the service contexts is identical to the\ntagged components, but they are used to carry reply and\nrequest parameters. If any of the parameters, are set to\nzero, they are interpreted as do not care.\nThe new service context is conveniently named\nBTQoSServiceContext and it consists of L2CAP QoS\nframe, flush timeout, and message priority. To make any\nsense of the service context coder and encoder objects\nthat translate service context into Bluetooth HCI\nmessages over Bluez have also been implemented as\nextensions to the MICO.\nIn order to achieve the design goals, the middleware\nneeds to be able to observe and set QoS values seen by\nthe L2CAP. Therefore, a user level interception point\nusing HCI functions to send packets to the LM in host\ncontroller, and read LM events associated with the\nfunction call has been installed, figure 6.\nFigure 6. QoS aware Bluetooth Middleware\nBesides, the new interceptor, our architecture has\nrequest level and IOR level interceptors as depicted in\nfigure 6. The functionality of the three interceptors has\nbeen combined into a client side and server side user\ndefined connection managers. At the client side, a\nClientConnectionManager registers with the client\ninterceptors in order to observe channel parameters and\nnegotiate requirements with the server. On the server\nside, QoSResourceManager implements the same\nfunctionalities as the ClientConnectionManager as well\nas piconet level connection management.\n5.1. QoS Negotiations\nIn order to use QoS\nclient and server\ninitialisation functions\nfeatures of the middleware, both\napplication developers, call\nwhich register the interceptors\nwith the ORB. Also, the CORBA service context both on\nthe server and client side are created, with the downlink\nuplink QoS parameters.\nWhen the server creates a reference, the\nQoSResourceManager attaches a tagged component to\nthe LTP IOR representing the offered services in the\ndownlink and uplink.\nThe first time a client invokes a request on a remote\ndevice the interceptors check the service context of the\ninvocation, and activate the ClientConnectionManager\nwhich is registered with the local ORB. The\nClientConnectionManager checks QoS field of the\nservice context the user has instantiated and compares it\nto the offered services in the downlink and required\nservices in the uplink, which the manger reads from the\nIOR.\nIf the offered services satisfy the requirements, and\nthe local resources are enough to satisfy an uplink the\nClientConnectionManager issues QoS setup command to\nthe HCI to set the uplink. If the server channel\nconditions have not changed since the LTP IOR has been\ngenerated, the server LM accepts the channel parameters\nand sends an event back with the new parameters.\nFinally the request is forwarded to the server.\nWhen the request is delivered to the server side ORB,\nserver interceptors investigate the received service\ncontext id and activate the QoSResourceManager if not\nactivated, which is registered to act on reception of\nBTQoSServiceContext id.\nThe QoSResourceManager decodes the\nBTQoSServiceContext, which now indicates parameters\nof the already established channel. The manager checks\nchannel requirements of the message, in case there has\nbeen a policy change since the IOR was created. If the\nlocal policies verify, then the request is forwarded to the\nserver implementing the object on which a request was\ncalled.\nIf any of the steps fail, exception messages are sent\nback to the previous entity. The exception messages\ncarry currently offered services in case the client wants\nto start re-negotiations with different parameters.\n5.2. QoS Management\nThe QoSResourceManager is a table of connected\ndevices and channel utilisation of the given piconet. The\nQoSResourceManager is responsible for aggregating all\nthe connection information and making decision on\nconnections. The QoSResourceManager collects\nbandwidth information based on the QoS frames\nreceived and sent. Depending on the priority of the\nconnection, accept or reject decision is made.\nIt was described in section 4 that the Bluetooth HCI\nprovides higher layers with QoS setup function, but it\ndoes not provide a function to read the available\nresources. Connection parameter decision in our\nmiddleware are done by the QoSResourceManager,\ntherefore, a degree of channel predictability is required\non the way LM interprets the QoS parameters and maps\nthem to LMP parameters.\n0-7803-9521-2\/06\/$20.00 \u00a72006 IEEE. 3243\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 05:01 from IEEE Xplore.  Restrictions apply.\nFor example, token rate affects the poll interval.\nToken bucket size gives the buffer memory, which is\ntransmitted if the time slots are not utilised by the other\nchannels. Peak bandwidth is used for resource sharing.\nLatency in some Bluetooth modules is actually\nequivalent to the poll interval. Also, in some Bluetooth\nimplementations, guaranteed service type is interpreted\nas a priority connection, which might result in\ndisconnection of existing best-effort ACL links [6].\nIf the client is a part of another piconet at the same\ntime, it must keep infornation related to channel\nutilisation in that particular piconet, so that it can make\ndecisions on the unlink connections.\nDespite the fact that, the QoSResourceManager\ncollects LMP parameters, it does not aim to replicate the\nprotocols of the low levels, but to make higher layer\nconnection decisions. If the mapping of the L2CAP QoS\nrequirements to baseband parameters was predictable\nand the same for every Bluetooth module, the\nmiddleware could make connection level decisions\nwithout difficulty. To make the middleware work\nefficiently, statistical knowledge of the effects of each\nQoS parameter is needed.\n6. Conclusion and future work\nThe main objectives of middleware technologies are\nto minimise application development time and offer\nunified computing environment through which to\nmanage resources. Our experimental middleware, uses\nexisting technologies, and is easy to port on wide range\nof platforns, as long as the underlying Bluetooth drivers\nsupport HCI QoS setup calls. Therefore, the middleware\nis said to offer unified computing environment, and it\nmanages Bluetooth connections and QoS parameters.\nWithout middleware, a programmer would have to\nopen L2CAP socket to the target machine, and at the\nsame time open another socket to HCI in order to make\nLMP calls. The programmer would have to build QoS\nframes and send them through socket operations, and\nlisten for the returned events from the HCI. With the\nmiddleware, all the programmer needs to do is; define\nclient-server interfaces, implement the servant, and\ndeclare QoS requirements as service context.\nThe next step in our research is to simulate the\nmiddleware, with different traffic conditions. The fact\nthat the middleware uses L2CAP rather than BNEP,\nmakes it suitable for ad-hoc and peer-to-peer\nconnections. With the introduction of Bluetooth 2.0\nspecifications and enhanced data rate (EDR) features,\nBluetooth could be used to stream live video in the\nfuture. To stream data with strict time constraints it will\nbe important to manage QoS parameters of connections.\nThe middleware can be used in conjunction with other\nexisting CORBA services to deploy applications to\nBluetooth enabled devices while providing a level of\nQoS at the same time.\nReferences\n[1]. Bluetooth SIG - Bluetooth Core Specifications vl.2,\nhttp:Hwww.bluetooth.org\/foundry\/adopters\/document\/Bluetoot\nh Core Specification vl.2\n[2]. Andrew S. Tanenbaum, Maarten van Steen, \"Distributed\nSystems: Principles and Paradigms\", Prentice Hall; 1st edition\n(January 15, 2002)\n[3]. Object Management Group, \"The Common Object Request\nBroker Architecture: Architecture and Specifications\", version\n3.0., 2005, www.omg.org\n[4]. Michi Henning, Steve Vinoski, Advanced CORBA(R)\nProgramming with C++,Addison-Wesley Professional; 1st\nedition, 1999\n[5]. Object Management Group, \"Wireless CORBA\nSpecifications\", 2004, www.omg.org\n[6]. Jennifer Bray and Charles F Sturman, \"Bluetooth Connect\nWithout Cables\", Prentice Hall, 2001\n[7]. MICO CORBA, http:\/\/www.mico.org\/\n[8]. VIVIAN, ITEA 99040 http:Hwww-nrc.nokia.comNVivian\/\n[9]. Bluez, Official Linux Bluetooth protocol stack,\nhttp:Hwww.bluez.org\n0-7803-9521-2\/06\/$20.00 \u00a72006 IEEE. 3244\nAuthorized licensed use limited to: Lancaster University Library. Downloaded on January 7, 2009 at 05:01 from IEEE Xplore.  Restrictions apply.\n"}