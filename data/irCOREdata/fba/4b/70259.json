{"doi":"10.1007\/s00779-005-0031-x","coreId":"70259","oai":"oai:eprints.lancs.ac.uk:12734","identifiers":["oai:eprints.lancs.ac.uk:12734","10.1007\/s00779-005-0031-x"],"title":"Guidelines and open issues in systems support for ubicomp: reflections on ubisys 2003 and 2004","authors":["Friday, Adrian","Roman, Manuel","Becker, Christian","Al-Muhtadi, Jalal"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2005-10","abstract":null,"downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/70259.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/12734\/1\/guidelines%2Dreflections%2D2003%2D4%2Dpreprint.pdf","pdfHashValue":"039c4bba480fa40ee924b755e969f738f3e308e1","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:12734<\/identifier><datestamp>\n      2018-01-24T00:04:31Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Guidelines and open issues in systems support for ubicomp: reflections on ubisys 2003 and 2004<\/dc:title><dc:creator>\n        Friday, Adrian<\/dc:creator><dc:creator>\n        Roman, Manuel<\/dc:creator><dc:creator>\n        Becker, Christian<\/dc:creator><dc:creator>\n        Al-Muhtadi, Jalal<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:date>\n        2005-10<\/dc:date><dc:type>\n        Journal Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:relation>\n        http:\/\/dx.doi.org\/10.1007\/s00779-005-0031-x<\/dc:relation><dc:identifier>\n        Friday, Adrian and Roman, Manuel and Becker, Christian and Al-Muhtadi, Jalal (2005) Guidelines and open issues in systems support for ubicomp: reflections on ubisys 2003 and 2004. Personal and Ubiquitous Computing, 10 (1). pp. 1-3. ISSN 1617-4909<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/12734\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1007\/s00779-005-0031-x","http:\/\/eprints.lancs.ac.uk\/12734\/"],"year":2005,"topics":["QA75 Electronic computers. Computer science"],"subject":["Journal Article","PeerReviewed"],"fullText":"Guidelines and Open Issues in Systems Support for \nUbicomp \nReflections on UbiSys 2003 and 2004 \nManuel Roman, Adrian Friday, Christian Becker and Jalal Al-Muhtadi \n \nOne of the most enjoyable features of the Systems Support for Ubiquitous Computing \n(UbiSys) workshops in 2003 and 2004 has been the freeform small group and plenary \ndiscussion sessions. Last year, we focused on identifying \u2018hot topics\u2019 from the paper \nsessions to form break out groups for further discussion. This year the discussion session \nwas motivated by a thought provoking talk from Wim Stut from Philips Research, where \nhe highlighted two aspects they had identified during talks with researchers in this \ndomain, that he believed were often overlooked in existing scenarios: \n \n1. Self-configuration \n \n2. Graceful degradation  \n \nHe argued that existing supporting infrastructures often make unreasonable assumptions \nabout the degree to which the location, context and users of devices involved in typical \nUbicomp application scenarios are known by the system. This knowledge is typically \n\u2018just there\u2019, i.e. is established a priori by system developers or \u201cpower\u201d users, or is even \nso implicit to the scenario that the authors do not realize that they are making these \nassumptions in the first place! Such information makes systems too complex to use in \nreal-life scenarios. These systems are complex and dynamic and therefore require \nfunctionality to configure themselves automatically, or through trivial user interaction. \n \nThe second issue is graceful degradation and affects the response of the system to \nchanges and particularly failures in the environment. According to Wim, most existing \nprojects assume the availability of certain resources such as Internet connectivity and \nspecific servers to be present permanently. However, in situations where these resources \nare not available, the entire system stops working. While this might be acceptable in \nexperimental lab environments, real life demands systems that can cope with the lack of \nresources. Or better still, systems should be able to adapt gracefully to these changes, \npreserving as much functionality as possible using the resources that are available. \n \nThis resonated with an issue from last year\u2019s discussion on, as one of our attendees \nDeborah Zukowski so aptly put it, the systems\u2019 need to demonstrate \u2018tolerance for \nignorance\u2019. We often propose data-driven systems where low level sensing leads to \nderived context (e.g. based on sensor fusion, statistical or knowledge based techniques) in \norder to move closer to concepts understandable by the user. In reality, the system won\u2019t \nbe able to perfectly sense the state of the world \u2013 there will inevitably be \u2018gaps\u2019 in this \nknowledge, e.g. things that can\u2019t be sensed or have been erroneously or imprecisely \nrecorded. This may in turn lead to incorrect 2nd order data that is mistakenly inferred or \nderived from it. Our systems will need to gracefully adapt, again preserving functionality, \nand crucially, should involve the user by exposing this ambiguity or explaining the \nmotivation for any actions taken on their behalf. \n \nThese points were also reflected in the more detailed discussion on the following topics: \n \n1. Mapping between physical objects, their digital representation, and their location \n \n2. Distinguishing technical aspects from user intent when reasoning about self-\nconfigurable systems \n \n3. Keeping the users always \u2018in the loop\u2019 \n \n4. Defining assessment criteria to assist in the evaluation of ubiquitous computing \nsystems \n \nThe first topic, mapping between physical and digital objects was triggered during Wim\u2019s \npresentation (and is clearly related to the issue of self-configuration). Many projects \nassume knowledge in the system, such as the physical locations of users and devices. A \nlight bulb may know that it is \u2018in the lounge\u2019, the orientation of the television screen and \nposition in the room are both accurately known, the presence, name, relationships or \nrights of users are represented and understood by the system. How this information came \nto be known, sensed or inferred is typically not explained. In real life scenarios the \nsystem must be configured with this information or must be able to obtain this \ninformation automatically. During the discussion, some participants suggested using \n\u2018physical space servers\u2019 that provide information about the physical layout of the \nenvironment, as well as properties such as location of physical objects. For example, \nwhen looking for a projector for a presentation, the system should provide a list of \nprojectors located in the presentation\u2019s room and should discard projectors available in \nneighbouring rooms. Discovery services should be extended to take into account physical \nconstraints. Keeping this information up to date is clearly a challenge, but it was pointed \nout that connectivity and interaction patterns over time can provide useful hints. \n \nThe second and third topics were the most extensively discussed. These topics arose \nduring the first discussion. If the system requires information such as physical properties \nand relationships of surrounding entities, should the user provide this information? Most \npeople agreed that the system should be able to configure itself. However, the fact that \nthe system can configure itself does not mean that the system can predict what the user \nwants to do. There are a large number of research papers that describe scenarios where \nusers perform different activities and ubiquitous computing systems automatically \nconfigure existing resources or take actions proactively to optimise the environment for \nsuch activities. However, during the discussion it was clear that we did not believe it \npossible to accurately infer user intention and therefore ubiquitous computing systems \nshould focus on the technical (enabling) aspects of Ubiquitous Computing. Research on \nsystems support should thus focus on providing functionality to simplify the management \nof resources (discovery, coordination, aggregation, use etc.) and should let the user \nchoose how to combine and use those resources at any time. This raised the suggestion \nthat we apply two \u2018rules of thumb\u2019: \n \n1. That the user in Ubicomp should be always part of the loop, and \n \n2. To \u2018sanity check\u2019 our systems and scenarios by applying the following test: \u201cIf \nyou had a personal human servant that followed you around, could they correctly \nanticipate what you wanted under the same circumstances?\u201d \n \nDuring the session, we discussed the fact that providing self-configuration support for \nindividual resources is possible, and in fact, most existing software already provides \nmechanisms to react to certain errors or configuration states. The complexity arises when \ncombining heterogeneous resources dynamically and trying to automate self-\nconfiguration and operation of the system as a single entity. This is clearly an important \ntopic for future research. \n \nA significant emergent issue from last year\u2019s workshop, was the apparent need for \nevaluation frameworks for systems support for Ubicomp: i.e. whether it is possible to \ncreate a set of benchmarks or a test suite that allows us to compare and contrast our \napproaches, allowing for systematic evaluation of Ubicomp infrastructures. This \nframework would be analogous to the standard test suites selected to exercise audio or \nvideo compression algorithms, or the well known datasets used for Information \nVisualisation or Natural Language Processing. One insight in this regard was that each \ncommunity picks and accepts its own preferred mechanisms or suites of benchmarks, it is \njust that Ubiquitous Computing seems to be composed of many communities! \n \nThis year we continued this discussion by considering the definition of assessment \ncriteria to assist in the evaluation of Ubicomp systems. Although we could not quickly \nidentify such a set of criteria, the participants proposed the creation of a workshop that \nwould specify a particular Ubicomp scenario, and would request submissions from \nauthors explaining how they would support such scenario using their particular \ntechnology. As part of the workshop guidelines, we would ask authors to explain how \ntheir system deals with self-configuration and graceful degradation problems. The result \nof the workshop would be a collection of solutions describing a common scenario that \nwould allow us to generate a document with criteria to evaluate ubiquitous computing \nsystems. These topics would form the basis of a new set of benchmarks against which \nresearchers could evaluate their contributions. \n \nThe final thread of discussion was that of how we might design systems to support \nUbiquitous Computing environments that scale while retaining the resilience to failures \nwe\u2019ve recognised. Last year this turned to a more fundamental discussion of the \nunderlying composition of architectures for supporting Ubicomp applications. We \nregarded this architecture as a layered model consisting of a pool of sensed, inferred and \napplication data (Ubi-Data), application agents (in the loosest sense) working with and \non behalf of the user and \u2018the switch\u2019 that binds these together. \n \n \n \nWe might draw parallels between \u2018the switch\u2019 and existing Ubicomp middleware \nplatforms. However, while such platforms typically promote the sharing of information \nbetween applications (such as the context described earlier) and the rewiring and flexible \ncomposition of components to create new applications, we noted that we did not yet have \nmechanisms for avoiding \u2018interference\u2019 between these applications \u2013 potentially a major \nlimitation to scale and resilience as these environments increase in complexity. Studying \nthe architecture of \u2018the Ubicomp switch\u2019 seemed to be an important direction for \nunderstanding how to build scalable and robust Ubicomp environments in the future. \n"}