{"doi":"10.1007\/978-3-540-30477-7_28","coreId":"65319","oai":"oai:dro.dur.ac.uk.OAI2:6227","identifiers":["oai:dro.dur.ac.uk.OAI2:6227","10.1007\/978-3-540-30477-7_28"],"title":"A relational model for object-oriented designs.","authors":["He, J.","Liu, Z.","Li, X.","Qin, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Chin, W.-N."],"datePublished":"2004-11-01","abstract":"This paper develops a mathematical characterisation of object-oriented concepts by defining an observation-oriented semantics for an object-oriented language (OOL) with a rich variety of features including subtypes, visibility, inheritance, dynamic binding and polymorphism. The language is expressive enough for the specification of object-oriented designs and programs. We also propose a calculus based on this model to support both structural and behavioural refinement of object-oriented designs. We take the approach of the development of the design calculus based on the standard predicate logic in Hoare and Hes Unifying Theories of Programming (UTP). We also consider object reference in terms of object identity as values and mutually dependent methods","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65319.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6227\/1\/6227.pdf","pdfHashValue":"fd48d267513a9551e84ffee72dbbdb23499a97bc","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6227<\/identifier><datestamp>\n      2015-03-31T11:45:04Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        A relational model for object-oriented designs.<\/dc:title><dc:creator>\n        He, J.<\/dc:creator><dc:creator>\n        Liu, Z.<\/dc:creator><dc:creator>\n        Li, X.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:description>\n        This paper develops a mathematical characterisation of object-oriented concepts by defining an observation-oriented semantics for an object-oriented language (OOL) with a rich variety of features including subtypes, visibility, inheritance, dynamic binding and polymorphism. The language is expressive enough for the specification of object-oriented designs and programs. We also propose a calculus based on this model to support both structural and behavioural refinement of object-oriented designs. We take the approach of the development of the design calculus based on the standard predicate logic in Hoare and Hes Unifying Theories of Programming (UTP). We also consider object reference in terms of object identity as values and mutually dependent methods.<\/dc:description><dc:subject>\n        Object orientation<\/dc:subject><dc:subject>\n         Refinement<\/dc:subject><dc:subject>\n         Semantics<\/dc:subject><dc:subject>\n         UTP.<\/dc:subject><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Chin, W.-N. (Eds.). (2004). Programming languages and systems : Second Asian Symposium, APLAS 2004, 4-6 November 2004, Taipei, Taiwan ; proceedings. Berlin: Springer, pp. 415-436, Lecture notes in computer science(3302)<\/dc:source><dc:contributor>\n        Chin, W.-N.<\/dc:contributor><dc:date>\n        2004-11-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6227<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/978-3-540-30477-7_28<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6227\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/978-3-540-30477-7_28<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6227\/1\/6227.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/978-3-540-30477-7_28<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2004,"topics":["Object orientation","Refinement","Semantics","UTP."],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nHe, J. and Liu, Z. and Li, X. and Qin, S. (2004) \u2019A relational model for object-oriented designs.\u2019, in\nProgramming languages and systems : Second Asian Symposium, APLAS 2004, 4-6 November 2004, Taipei,\nTaiwan ; proceedings. Berlin: Springer, pp. 415-436. Lecture notes in computer science. (3302).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/b102225\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nHe, J. and Liu, Z. and Li, X. and Qin, S. (2004) 'A relational model for object-oriented \ndesigns.', in Programming languages and systems : Second Asian Symposium, APLAS \n2004, 4-6 November 2004, Taipei, Taiwan ; proceedings. Berlin: Springer, pp. 415-436. \nLecture notes in computer science. (3302). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/b102225 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nA Relational Model for Object-Oriented Designs\nHe Jifeng\n\u0000\n, Zhiming Liu\n\u0000\u0002\u0001 \u0003\n, Xiaoshan Li\n\u0004\nand Shengchao Qin \u0005\n\u0006\nInternational Institute for Software Technology, The United Nations University\n\u0007\nhjf,lzm \b @iist.unu.edu\n\t\nDepartment of Mathematics and Computer Science, The University of Leicester\nzl2@mcs.le.ac.uk\n\n\nFaculty of Science and Technology, The University of Macau\nxsl@umac.mo\n\u000b\nSingapore-MIT Alliance & Dept. of Computer Science, National Univ. of Singapore\nqinsc@comp.nus.edu.sg\nAbstract. This paper develops a mathematical characterisation of object-oriented\nconcepts by defining an observation-oriented semantics for an object-oriented\nlanguage (OOL) with a rich variety of features including subtypes, visibility, in-\nheritance, dynamic binding and polymorphism. The language is expressive enough\nfor the specification of object-oriented designs and programs. We also propose a\ncalculus based on this model to support both structural and behavioural refine-\nment of object-oriented designs. We take the approach of the development of the\ndesign calculus based on the standard predicate logic in Hoare and He\u2019s Unifying\nTheories of Programming (UTP). We also consider object reference in terms of\nobject identity as values and mutually dependent methods.\nKeywords: Object Orientation, Refinement, Semantics, UTP\n1 Introduction\nSoftware engineering is mainly concerned with using techniques to systematically de-\nvelop large and complex program suites. However, it is well known that it is hard to ob-\ntain the level of assurance of correctness for safety critical software using old fashioned\nprogramming techniques. In the search for techniques for making software cheaper and\nmore reliable, two important but largely independent approaches have been visibly in-\nfluential in recent years. They are\n\u2013 object-oriented programming, and\n\u2013 formal methods.\nFirst, it becomes evident that objects are and will remain an important concept in soft-\nware development. Experimental languages of the 1970\u2019s introduced various concepts\nof package, cluster, module, etc, giving concrete expression to the importance of mod-\nularity and encapsulation, the construction of software components hiding their state\nrepresentations and algorithmic mechanisms from users, exporting only those features\nwhich are needed in order to use the components. This gives the software components\na level of abstraction, separating the view of what a module does for the system from\nthe details of how it does them. It is also clear that certain features of objects, particu-\nlarly inheritance and the use of object references as part of the data stored by an object,\ncould be used to construct large system incrementally and efficiently, as well as making\nit possible to reuse objects in different contexts.\nAt least for highly critical systems, it seems essential to give software engineering\nthe same basis in mathematics that is the hall mark of other important engineering\ndisciplines. In this there has good progress, resulting in three main paradigms: model-\nbased, algebraic and process calculi. Both practitioners of formal methods and experts\nin object technology have investigated how formal specification can supplement object-\noriented development, e.g. [21], or how it may help to clarify the semantics of object-\noriented notations and concepts, e.g. [1]. Examples of such work include formalisation\nof the OMG\u2019s core object model [19] using Z.\nModel-based formalisms have been used extensively in conjunction with object-\noriented techniques, via languages such as Object-Z [8], VDM++ [12], and methods\nsuch as Syntropy [11] which uses the Z notation and Fusion [10] that is related to\nVDM. Whilst these formalisms are effective at modelling data structures as sets and re-\nlations between sets, they are not ideal for capturing more sophisticated object-oriented\nmechanisms, such as dynamic binding and polymorphism.\nUsing predicate transformer, Cavalcanti and Naumann defined an object-oriented\nprogramming language with subtype and polymorphism [9, 29]. Sekerinski [33, 28] de-\nfined a rich object-oriented language by using a type system with subtyping and pred-\nicate transformers. However, neither reference types nor mutual dependency between\nclasses are tackled in those approaches. America and de Boer have given a logic for\nthe parallel language POOL [5]. It applies to imperative programs with object sharing,\nbut without subtyping and method overriding. Abadi and Leino defined an axiomatic\nsemantics for an imperative, object-oriented language with object sharing [2], but it\ndoes not permit recursive object types. Poetzsch-Heffter and Mu\u00a8ller have defined a\nHoare-style logic for object-oriented programs that relaxes many of the previous re-\nstrictions [31]. However, as pointed by Leino in [23], instead of allowing the designer\nof a method defining its specification and then checking that implementation meet the\nspecification, the specification of a method in the Poetzsch-Heffter and Mu\u00a8ller logic\nis derived from the method\u2019s known implementation. Leino presented a logic in [23]\nwith imperative features, subtyping, and recursive types. It allows the specification of\nmethods of classes, but restricting inheritance and not dealing with visibility.\nIn this paper, we aim to develop a mathematical characterisation of object-oriented\nconcepts, and provide a proper semantic basis essential for ensuring correctness and\nfor the development of tool support for the use of formal techniques. We define an\nobject-oriented language with subtypes, visibility, reference types, inheritance, dynamic\nbinding and polymorphism. The language is sufficiently similar to Java and C++ and\ncan be used in meaningful case studies and to capture some of the central difficulties in\nmodelling object-oriented programs.\nWe build a logic of object-oriented programs as a conservative extension of the\nstandard predicate logic [18]. In our model, both commands and class declarations are\nidentified as predicates whose alphabets include logic variables representing the initial\nand final values of program variables, as well as those variables representing the con-\ntextual information of classes and their links. Our framework allows local variables to\nbe redefined in its scope. Consequently, their states will usually comprise sequences of\nvalues. A variable of a primitive type stores a data of the corresponding type whereas\na variable of an object type holds the identity or reference of an object as its value.\nWe define the traditional programming constructs, such as conditional, sequential com-\nposition, and recursion in the exactly same way as their counterparts in an imperative\nprogramming language without reference types. This makes our approach more ac-\ncessible to users who are already familiar with the existing imperative languages. For\nsimplicity, unlike [30], we consider neither attribute domain redefinition nor attribute\nhiding. This assumption will be incorporated into the well-formedness condition of a\ndeclaration section in Section 3. With this assumption, the set \u0000 \u0001\u0002\u0001 \u0003\u0005\u0004 C \u0006 of attributes\nof C contains all the attributes declared in C and those inherited from its superclasses.\nWe simplify the model this way because our focus is program requirement specifica-\ntion, design and verification, whilst attribute domain redefinition and attribute hiding\nare languages facilities for programming around defects in the requirement specifica-\ntion and design or for the reuse of some classes that were not originally designed for\nprogram being developed.\nAfter this introduction, Section 2 introduces the syntax of the language. The seman-\ntics of the language is given in Section 3, with the discussion about behavioural refine-\nment of OO designs. In Section 4, we present some initial work towards a (structural)\nrefinement calculus for OO design and programming. We will draw some conclusions\nin Section 5.\n2 Syntax\nIn our model, an object system (or program) \u0007 is of the form cdecls \b P, where cdecls\nis a declaration of a finite number of classes, and P is called the main method and is of\nthe form \u0004\n\t \u000b \f \r \u000e \u0006 consisting of a finite set \t \u000b \f of global variables with their types and\na command \u000e . P can be understood as the \u000f\u0002\u0010\u0012\u0011\u0014\u0013 method if \u0007 is taken as a Java program.\n2.1 Class declarations\nA declaration cdecls is of the form: cdecls \u0015\u0017\u0016 cdecl \u0018 cdecls \u0019 cdecl, where cdecl is a\nclass declaration of the following form\n\u001a ff\u0012fi\n\u0011ffifl\u001f\u0010! \u0012\"$#\u0002% & \u0010\u0012'(' N \"$)( \u0012\"!\u0013 * ' M\n\u0007\nff\u0012fi\n\u0011ffifl\u001f\u0010! \u0012\",+.-0\/21\u0002\/43657\/.89\/;:\n\u0006=< < >,?\nff\u0012fi\u001f@\n \u0012\"\u001f%ffi \u0012\" * +BA\u0002\/2C!\/436DE\/.89\/\n:\n\u0006=< < FG?\nff(H I\n& \u0011(%J+BKL\/ M \/436NE\/.8\n\/;:\n\u0006=< < O\n?\n\u000f2\"$ P\n@\n* Q\n\u0006\n+ R\n\u0006 \u0006TS \u0006\u0014U\nR\n\u0006 \tWV\n\u0006\nU\nR\n\u0006 \nYX \u0006\n8\n\u0007\nN\n\u0006\n\b\n?\u0014ZEZEZE?\nQ\\[]+ R\n[\n\u00064S\n[\nU\nR\n[\n\t0V\n[\nU\nR\n[\n\nYX\n[\n8\n\u0007\nN^[ \b \b\nNote that\n\u2013 A class can be declared as ff\u0012fi \u0011ffifl\u001f\u0010! \u0012\" or ff(H I & \u0011(% . By default, it is assumed as ff(H I & \u0011(% .\nWe use a function anno to extract this information from a class declaration such that\nanno + cdecl 8 is true if cdecl declares a private class and false otherwise.\n\u2013 N and M are distinct names of classes, and M is called the direct superclass of N.\n\u2013 Attributes annotated with ff\u0012fi \u0011]fl\u001f\u0010! \u0012\" are private attributes of the class, and simi-\nlarly, the ff\u0012fi\u001f@  \u0012\"\u0012%ffi \u0012\" * and ff(H I & \u0011(% declarations for the protected and public attributes.\nTypes and initial values of attributes are also given in the declaration.\n\u2013 the \u000f2\"$ P @ * declaration declares the methods, their value parameters ( R\n\/\n\u00064S\n\/\n), result\nparameters( R\n\/\n\t V\n\/\n), value-result parameters ( R\n\/\n\nWX\n\/ ) and bodies ( NE\/ ). We sometimes\ndenote a method by QL+ paras 8 \u0007 N \b , where paras is the list of parameters of Q and N is\nthe body command of Q .\n\u2013 The body of a method N\u0014\/ is a command that will be defined later.\nWe will use Java convention to write a class specification, and assume an attribute\nff(fi\u001f@\n \u0012\"\u001f%] \u0012\" * when it is not tagged with ff\u0012fi \u0011ffifl\u001f\u0010! \u0012\" or ff$H I & \u0011(% . We have these different kinds\nof attributes to show how visibility issues can be dealt with. We can have different kind\nof methods too for a class.\n2.2 Commands\nOur language supports typical object-oriented programming constructs, but we also\nallow some commands for the purpose of specification and refinement:\nN\n\u0001\u0002\u0001\n3 skip\n\u0003\nchaos\n\u0003\nvar R x=e\n\u0003\nend S\n\u0003\nN\n?\nN\n\u0003\nN\u0005\u0004 D\u0005\u0006LN\n\u0003\nN \u0007 N\n\u0003\nD\t\bYN\n\u0003\u000b\n\r\f\u000f\u000e\nQ +\n\f\nU\nC\nU\n1 8\n\u0003\u000b\n\r\f\n\u0001\n3\n\f\u0010\u0003\nC.new + S 8\n\u001a \f\n#\nwhere D is a Boolean expression, \u0011 is an expression, and \n\r\f is an expression which may\nappear on the left hand side of an assignment and is of the form \n\r\f \u0001\u0002\u0001 3 S \u0003\u000b\n\r\f\u000f\u000e 5 where S is\na simple variable and 5 an attribute of an object. Unlike [30] that introduces \u201cstatement\nexpressions\u201d, we use \n\r\f\u000f\u000e QL+ \f U C U 1 8 to denote a call of method Q of the object denoted\nby the left-expression \n\u0012\f with actual value parameters \f for input to the method, actual\nresult parameters C for the return values, and value-result parameters 1 that can be\nchanged during the execution of the method call and with their final values as return\nvalues too; and use the command C.new + S 8 \u001a \f # to create a new object of class C with the\ninitial values of its attributes assigned to the values of the expressions in \f and assign it\nto variable S . Thus, C.new + S 8 \u001a \f # uses S with type C to store the newly created object.\n2.3 Expressions\nExpressions, which can appear on the right hand sides of assignments, are constructed\naccording to the rules below.\n\u0011 \u0015 \u0015\u0017\u0016 \u0013 \u0018 null \u0018 self \u0018 \u0011 \u0014 \u0015 \u0018 \u0011 \u0016\u0018\u0017 C \u0018 \u0004 C \u0006 \u0011 \u0018\u001a\u0019 \u0004 \u0011 \u0006\nwhere null represents the special object of the special class NULL that is a subclass of\nall classes and has null as its unique object, self will be used to denote the active object\nin the current scope (some people use \u0001fiff \u0016\u0018\u0017 ), \u0011 \u0014 \u0015 is the \u0015 -attribute of \u0011 , \u0004 C \u0006 \u0011 is the type\ncasting, \u0011 is C is the type test.\n3 Semantics\nWe now show how to use the basic model of the UTP to define the semantics of our\nlanguage. We will adopt the convention that the semantics fl fl ffi \u001f \u001f of an element ffi , such\nas \u0011 \u0000 \u0016 \u0011 \u0003 or \u0013 \u0015 \u0016 \u0011 , of the language is denoted by ffi itself in a semantic defining\nequation. When ffi appears on the left hand side of a defining equation, it means that its\nsemantics is defined as the right hand side of the equation. When ffi appears on the right\nhand side, it denotes its defined semantics of ffi .\n3.1 Programs are designs\nIn [18], Hoare and He proposed a state-based model in which a program or a program\ncommand is identified as a design, represented by a pair +\u0001\u0000 U P 8 , where \u0000 denotes the set\nof variables of the program, and P is a predicate of the form\n\u0002\n+\nS\n8 \u0003 R + S U=S\u0005\u0004 803 df +\u0001\u0006\b\u0007\n\t \u0002 + S 8=8 \u000b +\u0001\u0006\b\u0007 \u0004 \t R + S U S\u0005\u0004 8=8\nNotice that\n\u2013 we call \u0000 the alphabet of the design and P the contract of the design; \u0000 declares the\nvariables (including logical ones) whose values form the state of the program at a\nmoment of time, and the contract specifies the behaviour of the program in terms\nof what change in the state it may make.\n\u2013\nS and S \u0004 stand for the initial and final values of program variables S in \u0000 , respec-\ntively.\n\u2013 predicate \u0002 , called the precondition of the program, characterises the initial states\nin which the activation of the program will lead its execution to termination.\n\u2013 predicate R, called the post-condition of the program, relates the initial states of the\nprogram to its final states, and\n\u2013 we describe the termination behaviour of a program by the Boolean variables \u0006\b\u0007\nand \u0006\b\u0007 \u0004 , where the former is true if the program is properly activated and the later\nbecomes true if the execution of the program terminates successfully.\nIn what follows, we give formal definitions of sequential composition of designs and\ndesign refinement.\nDefinition 1. For a given alphabet \u0000 and two contracts P \u0006 and P \t , the sequential com-\nposition P \u0006 ? P \t is defined as the relation composition\n+ P \u0006 + S U9S\u0005\u0004 8 ? P \t + S U9S\u0005\u0004 8=803 df \f Q Z P \u0006 + S\u0005U Q 8\r\t P \t +;Q U9S\u0005\u0004 8\nWe also define the composite design +\u0001\u0000 U P \u0006 8 ? +\u0001\u0000 U P \t 8 by +\u0001\u0000 U P \u0006 ? P \t 8 .\nWithin this model, the concept of refinement is defined as predicate implication.\nDefinition 2. (Design refinement) Design D \t 3 df +\u0001\u0000 U P \t 8 is a refinement of design\nD \u0006 3 df +\u0001\u0000 U P \u0006 8 , denoted by D \u0006\u000f\u000e D \t , if \u0010 S U S \u0004 \u000e \u000e \u000e U X7U X \u0004 Z + P \t \u000b P \u0006 8 U where S\u0005U \u000e \u000e\u000b\u000e U=X are\nvariables contained in \u0000 . D \u0006\u0012\u0011 D \t if and only if D \u0006\u000f\u000e D \t and D \t\u0013\u000e D \u0006 .\nDefinition 3. (Data refinement) Let \u0014 be a mapping (that can also be specified as a\ndesign) from \u0000 \t to \u0000 \u0006 . Design D \t 3 df +\u0001\u0000 \t U P \t 8 is a refinement of design D \u0006 3 df +\u0001\u0000 \u0006 U P \u0006 8\nunder \u0014 , denoted by D \u0006\u000f\u000e \u0015 D \t , if \u0004\u0017\u0016 \u0019 P \u0000 \u0006 \u0018 \u0004 P \u0003 \u0019 \u0016 \u0006\u000b\u0014\nA program command usually modifies a subset of the program variables in \u0000 . Let V\nbe a subset of \u0000 , the notation V \u0001 + \u0002 \u0003 R 8 denotes the (framed) design \u0002 \u0003 + R \t M \u0004 3 M 8 ,\nwhere M contains all variables in \u0000 but those in V. V is called the frame of the design\n\u0002\n\u0003 R. In examples, we often omit the frames of designs by assuming that a design only\nchanges the value of a variable S if its primed version S \u0004 occurs in the design.\nFor simplicity, the above model in [18] adopts a universal data type and allows\nneither reference types nor nested declaration. This assumption will not be applicable\nto modelling OO designs anymore. However, we can still follow this classical way of\ndefining a state-based model for a programming language and define our OOL in terms\nof values, variables, states, expressions, commands, declarations and programs.\n3.2 Values, Objects, Variables and States\nEach program declares a set %]\u00137\u0010E\u000f2\" of class names, a partial function ' H(ff \" fi % & \u0010\u0012'(' that\nmaps a class name in %]\u00137\u0010E\u000f2\" to its direct superclass, a function \u0010! ( fi that associates\neach class name C \u0000 %]\u00137\u0010E\u000f2\" with the set \u0010! ( fi + C 8 of its attributes, and a function @ffiff that\nassociates each C \u0000 %\u0014\u00137\u0010E\u000f2\" the set @ffiff + C 8 of its methods. We use \u0001 to denote the reflexive\nand transitive closure of ' H(ff \" fi % & \u0010('(' and C \u0006 \u0001 C \t denotes that C \u0006 is a subclass of C \t .\nWe assume a set \u0002 of primitive types and an infinite set REF of object identities (or\nreferences), and null \u0000 REF. A value is either a member of a primitive type in \u0002 or an\nobject identity in REF. Let the set of values be VAL 3 df \u0003 \u0002\u0005\u0004 REF. An object \u0006 is an\nentity defined by the following structure \u0006 \u0001\u0002\u0001 3 null \u0003\u0007\u0006 ref U  \t\b ff \" U\u000b\n\r\f\r\u000e\u000f\f\r\u0010\u0012\u0011 , where ref \u0000 REF,\nand  \t\b ff \" is a class name, and 'ffi \u0012\u0010! \u0012\" is a mapping from \u0010ffi ( fi +; \t\b ff \"\u001f8 to VAL. Given an\nobject \u0006 3 \u0006 ref U C U \u0013 \u0011 , we use identity +\u0001\u0006$8 to denote the identity ref of \u0006 ,  \t\b ff \"\u0002+\u0001\u0006$8 the type\nC of the object \u0006 , and 'ffi \u0012\u0010! \u0012\"\u0002+\u0001\u0006$8 +;528 the value \u0013 +;5 8 of an attribute 5 of class C.\nLet \u0014 be the set of all objects, including null. Notice that infinite recursive and\nlooping constructions are allowed, such as \u0006\u0016\u0015 \/ U C U \u0013 \/ \u0011 such that \u0013 \/=+;52803 \u0015 \/ , where 5 is an\nattribute of C that is type of C too.\nThe following notations will be employed in the semantics definitions.\n\u2013 Given a non-empty sequence \u0017 3 \u0006 \u0017 \u0006 U \u000e\u0002\u000e U \u0017 O \u0011 , we have head +\u0018\u0017 8W3\u0019\u0017 \u0006 , tail +\u0018\u0017 803 \u0006 \u0017 \t U \u000e\u0002\u000e U \u0017 O \u0011 .\nWe use \u0003 \u0017 \u0003 to denote the length of \u0017 , and \u001a \/ +\u0018\u0017 8 the ff\u0016fi fl element \u0017 \/ , for ff \u0001\u0012ffi U \u000e\u0002\u000e U \u0007 .\n\u2013 For two sets \u001f and \u001f \u0006 , \u001f \u0006! \u001f is the set obtained by removing elements in \u001f \u0006 from\n\u001f . Note that  has higher associativity than normal set operators like \u0004 , \" .\n\u2013 For a mapping # \u0001 D $ % E, &'\u0000 D and \u0015 \u0000 E,\n#)(\n\u0007\n&+*%\n\u0015\n\b 3 df # \u0004 where # \u0004 +;DE803 df\n,\n\u0015\nU if D 3\u0005& ?\n# +;D\u00148\nU if D-\u0000\n\u0007\n& \b\n D\n\u000e\n\u2013 For an object \u0006 3 \u0006 ref U C U \u0013 \u0011 , an attribute 5 of C and a value & ,\nref ( \u0007 5'*% & \b 3 df\n\u0006\nref U C U \u0013 ( \u0007 5+*% & \b \u0011\n\u2013 For a set \u001f .\/\u0014 of objects,\n\u001f 0\n\u00071\u0006\nref U C U \u0013 \u0011 \b 3 df\n\u0007\n\u0006\n\u0003\nidentity +\u0001\u0006$803 ref \b  \u001f \u0004 \u00071\u0006 ref U C U \u0013 \u0011 \b\nRef + \u001f 803 df\n\u0007\nref \u0003 ref is the identity of an object in \u001f \b\nOur model describes the behaviour of an OO program as a design containing the\nlogical variables given in Fig 1 as its free variables that form the alphabet of the pro-\ngram.\nThe semantic model will ensure that for any 2 \u0000 and 2 \u0003 in 3 , identity \u0004 2 \u0000 \u0006 \u0016 identity \u0004 2 \u0003 \u0006\nimplies \u0001 4 5 6 \u0004 2 \u0000 \u0006 \u0016 \u0001 4 5 6 \u0004 2 \u0003 \u0006 and \u0017 \u0001 \u0000 \u0001 6 \u0004 2 \u0000 \u0006 \u0016 \u0017 \u0001 \u0000 \u0001 6 \u0004 2 \u0003 \u0006 . We therefore can use\nidentity of an object to refer to an object in 3 . In the rest of the paper, an object\n2 \u001687 ref \r C \r:9!; means one in 3 if there is no confusion, and will use ref \u0014 \u0015 to denote the\nvalue of \u0017 \u0001 \u0000 \u0001 6 \u0004 2 \u0006 \u0004 \u0015 \u0006 , and \u0001 4 5 6 \u0004 ref \u0006 to denote \u0001 4 5 6 \u0004 2 \u0006 (i.e. C).\n3.3 Evaluation of expressions\nThe evaluation of an expression \f determines its type  \t\b ff \"\u0002+ \f 8 and its value that is a\nmember of  \t\b ff \"\u0002+ \f 8 if this type is primitive, and an object of the current type that is\nvariable representation description\ncname the set of classes declared so far\npricname the set of private class names\nattr(C) \u00071\u0006 5 \/ \u0001 R \/ U & \/ \u0011 \b\n>\n\/\u0001\u0000\n\u0006\nR \/ and & \/ are the type and initial value of attribute\n57\/ , and will be referred by * \"\u0012% &  \t\b\nff\n\"\u0002+ C\n\u000e\n5 \/.8 and\n\u0011\u0014\u0013 \u0011ffi 7\u0011$\u0010 & + C\n\u000e\n57\/.8 respectively. We also abuse the nota-\ntion 5\/\u0000 \u0010! ( \nfi\n+ C 8 and use it to denote\n\f\nR\nU\n&\nZ\n+\n\u0006\n5\n\u0001\nR\nU\n&\n\u0011\n\u0000 \u0010! ( \nfi\n+ C 8=8 . Again, we do not allow attribute\nhiding (or redefinition) in a subclass. We also use an\nattribute name to represent its value and a type name\nto denote the set of its legal values.\nop(C)\n\u0002\u0004\u0003\u0006\u0005\u0004\u0007\b\n\t\u0001\n\n\u0005\f\u000b T \u0005\r\u0005\n\u0001\u000f\u000e\n\u0005\n\u000b T \u0005\u0011\u0010\n\u0001\r\u0012\n\u0005\f\u000b T \u0005\u0011\u0013\n\u0001\nD\n\u0005\u0015\u0014\n\u0001\n\u0016\u0017\u0016\u0017\u0016\n\u0001\n\u0003\u0019\u0018\u001a\u0007\b\n\t\u0001\n\n\u0018 \u000b T \u0018 \u0005\n\u0001\u000f\u000e\n\u0018\n\u000b T \u0018 \u0010\n\u0001\r\u0012\n\u0018 \u000b T \u0018 \u0013\n\u0001\nD\n\u0018ff\u0014\u000ffi\neach method Q \/ has S\n\/\n, V\n\/\nand X\n\/\nas its\nvalue, result and value-result parameters respectively,\nthat are denoted by fl\u001f\u0010 & + C\n\u000e\nQ \/.8 ,\nfi\n\"\u001f'7+ C\n\u000e\nQ \/B8 , and\nfl\u0012\u0010 &\nfi\n\"\u001f'2+ C\n\u000e\nQ \/ 8 , and the behaviour of Q \/ is defined\nby the design fl \/ referred by ffi \" \u001f + C\n\u000e\nQ \/ 8 . Sometimes\nwe simply denote each element in\n@ffiff\n+ C 8 as Q \/ *%\n+ paras\n\/\nU\nfl \/B8 . We also sometimes abuse the notation\nQ \u0000\n@ffiff\n+ C 8 and use it to denote\n\f\nparas U fl Z +;Q *%\n+ paras U fl 8 \u0000\n@ffiff\n+ C 8=8\n \n+ C 8 U   3 df\n!\nC \"$#&%\u000f'&(*)\n \n+ C 8\n \n+ C 8 :the set of objects of class C that currently exist\nin the execution of the program.\n \n: system state, also called current configuration [30]\nsuperclass\n\u0007\nN *% M U\n\u000e\u0002\u000e\u0002\u000e\n\b\na partial function mapping a class (N) to its direct su-\nperclass (M).\nglb the set of global variables declared at the beginning ofthe main program\nlocvar\n\u0007\n+\nS\n\u0006\nU\n\u0006\nR\n\u0006 \u0006\nU\n\u000e \u000e\nU\nR\n\u0006B>\n\u0011\n8\nU\n\u000e\u0002\u000e\u0002\u000e\nU\n+\nS\nF\nU\n\u0006\nR\nF \u0006\nU\n\u000e\u0002\u000e\nU\nR\nF(O\n\u0011\n8 \b\nthe set of local variables which are known to the cur-\nrent scope of the program. R \/ \u0006 , for ff 3 ffi U\n\u000e\u0002\u000e\nU\u0015+ is the\nmost recently declared type of S\n\/\nvar fl\u001f\u0010\nfi\n3-, &\nI\n\u0004 &\n@\n%]fl\u001f\u0010\nfi\nvisibleattr\nthe set of attributes which are visible from inside the\ncurrent class, i.e. all its declared attributes plus the\nprotected attributes of its superclasses and all public\nattributes. Every time before a method of an object is\nexecuted, this set is set to the attributes of the class of\nthe object, and it will be reset after the execution of\nthe method.\nS\nthe state of variable S \u0000 fl\u001f\u0010\nfi\n. Since a local vari-\nable can be redeclared, its state usually comprises a\nnonempty finite sequence of values, whose first (head)\nelement represents the current value of the variable.\nS for S \u0000., &\nI\ncontains at most one value and thus\nwe can simply use S to denote it. A primitive variable\ntakes values of primitive type, while an object variable\ncan store an object name or identity as its value.\nFig. 1. The Alphabet: Logical Variables\nattached to \f . The evaluation makes use of the state of  . However, an expression can\nonly be evaluated when it is well-defined. Some well-definedness conditions are static\nthat can be checked at compiling time, but some are dynamic. The evaluation results of\nexpressions are given in Fig. 2.\nExpression Evaluation\nnull \u0000 + null 803 df true U  \t\b\nff\n\"\u0002+ null 803 df NULL U fl\u0012\u0010 &\nH\n\"\u0002+ null 803 df null\nS\n\u0000 +\nS\n8 3 df S \u0000 fl\u001f\u0010\nfi\n\tL+ * \"\u0012% &  \t\b\nff\n\"\u0002+\nS\n8 \u0000 \u0002 \u0001 * \"\u001f% &  \t\b\nff\n\"G+\nS\n8 \u0000 %]\u00137\u0010E\u000f2\"\u001f8 + Static 8\n\t * \"\u001f% &  \t\b\nff\n\"G+\nS\n8 \u0000 \u0002 \u000b head + S 8 \u0000 * \"\u001f% &  \t\b\nff\n\"G+\nS\n8 + Dynamic 8\n\t * \"\u001f% &  \t\b\nff\n\"G+\nS\n8 \u0000 %]\u0013\u001f\u0010E\u000f2\" \u000b\nhead + S 8 \u0000 Ref +  + * \"\u001f% &  \t\b ff \"G+ S 8=8=8 + Dynamic 8\n \b\nff\n\"\u0002+\nS\n8 3 df\n\u0003\n* \"\u001f% &  \b\nff\n\"G+\nS\n8 * \"\u001f% &  \t\b\nff\n\"G+\nS\n8 \u0000 \u0002\n \t\b\nff\n\"\u0002+ head + S 8=8 otherwise\nfl\u0012\u0010 &\nH\n\"\u0002+\nS\n8W3 df head + S 8\nself\n\u0000 + self 8 3 df self \u0000 &\n@\n%ffifl\u0012\u0010\nfi\n\t * \"\u001f% &  \b\nff\n\"G+ self 8 \u0000 %]\u00137\u0010E\u000f2\"\\+ Static 8\n\t head + self 8 \u0000 Ref +  + * \"\u001f% &  \t\b ff \"\u0002+ self 8=8=8 + Dynamic 8\n \b\nff\n\"\u0002+ self 8 3 df  \b\nff\n\"\u0002+ head + self 8=8\nfl\u0012\u0010 &\nH\n\"\u0002+ self 8W3 df head + self 8\nS\n\u000e\n5\n\u0000 +\nS\n\u000e\n5 803 df \u0000 + S 8\n\t * \"\u001f% &  \t\b\nff\n\"G+\nS\n8 \u0000 %]\u0013\u001f\u0010E\u000f2\" \t\\ \t\b\nff\n\"\u0002+\nS\n8\n\u000e\n5 \u0000 fl7\u0011('(\u0011\nI\n& \"\u0012\u0010! $ \nfi\n+ Static 8\n\t head + S 8\u0005\u00043 null\n \b\nff\n\"\u0002+\nS\n\u000e\n5 803 df  \b\nff\n\"\u0002+ head + S 8\n\u000e\n5 8\nfl\u0012\u0010 &\nH\n\"\u0002+\nS\n\u000e\n5 803 df head + S 8\n\u000e\n5\n\n\r\f\u000f\u000e\n5\nffi +\n\n\r\f\u000f\u000e\n5 803 df ffi +\n\n\r\f\n8 \t  \t\b\nff\n\"\u0002+\n\n\r\f\n8\n\u000e\n5 \u0000\u0007\u0006\t\b\n\n\n\b\u000b\n\r\f\n\u0010\u0007\u000e\u0012\f\r\f\u000f\u000e\nfl\u0012\u0010 &\nH\n\"\u0002+\n\n\r\f\u000f\u000e\n5 803 df fl\u0012\u0010 &\nH\n\"\u0002+\n\n\r\f\n8\n\u000e\n5\n \b\nff\n\"\u0002+\n\n\r\f\u000f\u000e\n5 8 3 df  \b\nff\n\"\u0002+;fl\u001f\u0010 &\nH\n\"\u0002+\n\n\r\f\n8\n\u000e\n528\n+\n\f\nis C 8\n\u0000 +\n\f\nis C 8 3 df \u0000 +\n\f\n8\r\tL+; \t\b\nff\n\"2+\n\f\n8 \u0000 %]\u00137\u0010E\u000f \"\u001f8 \t + C \u0000 %]\u00137\u0010E\u000f \"\u001f8\n \b\nff\n\"\u0002+\n\f\nis C 8 3 df Bool\nfl\u0012\u0010 &\nH\n\"\u0002+\n\f\nis C 8Y3 df fl\u001f\u0010 &\nH\n\"G+\n\f\n8\u0010\u00043 null \t\\ \b\nff\n\"\u0002+\n\f\n8 \u0001 C\n+ C 8\n\f\n\u0000 +=+ C 8\n\f\n8 3 df \u0000 +\n\f\nis C 8\r\t\\fl\u001f\u0010 &\nH\n\"\u0002+\n\f\nis C 8\n \b\nff\n\"\u0002+=+ C 8\n\f\n8 3 df  \t\b\nff\n\"\u0002+\n\f\n8\nfl\u0012\u0010 &\nH\n\"\u0002+=+ C 8\n\f\n8Y3 df fl\u001f\u0010 &\nH\n\"\u0002+\n\f\n8\n\f\u0012\u0011\u0014\u0013\n\u0000 +\n\f\u0012\u0011\u0014\u0013\n8 3 df \u0000 +\n\f\n8 \t \u0000 +\n\u0013\n8 \t * \"\u001f% &  \t\b\nff\n\"G+\n\f\n8T3 Real\n\t * \"\u0012% &  \t\b\nff\n\"\u0002+\n\u0013\n8W3 Real \t fl\u001f\u0010 &\nH\n\"\u0002+\n\u0013\n8\u0015\u00043\u0002\u0016\nfl\u0012\u0010 &\nH\n\"\u0002+\n\f\u0012\u0011\u0014\u0013\n8Y3 df fl\u001f\u0010 &\nH\n\"\u0002+\n\f\n8\n\u0011\nfl\u001f\u0010 &\nH\n\"\u0002+\n\u0013\n8\nFig. 2. Evaluation of Expressions\n3.4 Semantics of commands\nA typical aspect of an execution of an OO program is about how objects are to be at-\ntached to program variables (or entities [27]). An attachment is made by an assignment,\nthe object creation or parameter passing in a method invocation. With the approach of\nUTP, these different cases are unified as an assignment of a value to a program vari-\nable. We shall only present the semantic definitions for assignment, object creation and\nmethod calls, due to page limit. All other programming constructs will be defined in\nexactly the same way as their counter-parts in a procedural language, thus are omitted\nhere. We also present some basic refinement laws for commands.\nAssignments: An assignment \n\u0012\f \u0001 3 \f is well-defined if both \n\r\f and \f are well-defined\nand current type of \f matches the declared type of \n\u0012\f\n\u0000 +\n\n\r\f\n\u0001\n3\n\f\n803 df \u0000 +\n\n\r\f\n8 \t \u0000 +\n\f\n8\r\t\\ \t\b\nff\n\"\u0002+\n\f\n8 \u0001 * \"\u001f% &  \t\b\nff\n\"G+\n\n\r\f\n8\nNotice that this requires dynamic type matching. However, it is safe to replace the con-\ndition  \t\b ff \"2+ \f 8 \u0001 * \"\u001f% &  \t\b ff \"G+ \n\r\f 8 with * \"\u0012% &  \t\b ff \" + \f 8 \u0001 * \"\u001f% &  \t\b ff \"G+ \n\r\f 8 , as the semantics will\nensure the later implies the former. With the use of type test e is C and type casting\n+ C 8\n\f\n, changing the dynamic type matching to the static matching will not lose expres-\nsive power either.\nThere are two cases of assignment. The first is to (re-)attach a value to a variable\n(i.e. change the current value of the variable), but this can be done only when the type of\nthe object is consistent with the declared type of the variable. The attachment of values\nto other variables are not changed.\nS\n\u0001\n3\n\f\n3 df\n\u0007\nS\n\b\n\u0001\n\u0000 +\nS\n\u0001\n3\n\f\n8 \u0003 +\nS \u0004\n3\n\u0006\nfl\u001f\u0010 &\nH\n\"\u0002+\n\f\n8\n\u0011\nZ tail + S 8=8\nAs we do not allow attribute hiding\/redefinition in subclasses and semantics of assign-\nment, the assignment to a simple variable has not side-effect, and thus the Hoare triple\n\u0007\n\u0006\n\t\n\u000e\n5 3\u0001\u0000 \b \u0006\n\u0006\n\u0001\n3 \u0006\n\t\n\u0007\n\u0006\n\u0006\n\u000e\n5 3\u0002\u0000 \b is valid in our model for variables \u0006 \u0006 of class C \u0006 and \u0006 \t\nof C \t , where C \t \u0001 C \u0006 and C \u0006 has 5 as protected attribute of integer type. This has made\nthe theory much simpler than the Haore-logic based semantics for OO programming in\n[30].\nThe second case is to modify the value of an attribute of an object attached to an\nexpression. This is done by finding the attached object in the system state  and mod-\nifying its state accordingly. Thus, all variables that point to the identity of this object\nwill be updated.\n\n\r\f\u000f\u000e\n5\n\u0001\n3\n\f\n3 df\n\u0007\n \n+ * \"\u001f% &  \b\nff\n\"G+\n\n\r\f\n8=8 \b\n\u0001\n\u0000 +\n\n\r\f\u000f\u000e\n5\n\u0001\n3\n\f\n8 \u0003\n\u0003\n \n+ * \"\u001f% &  \t\b\nff\n\"\u0002+\n\n\u0012\f\n8=8\n\u0004\n3\n \n+ * \"\u0012% &  \t\b\nff\n\" +\n\n\u0012\f\n8=8\n0 +\n\u0007\nfl\u001f\u0010 &\nH\n\"\u0002+\n\n\r\f\n8 \b (\n\u0007\n5\u0012*% fl\u001f\u0010 &\nH\n\"\u0002+\n\f\n8 \b!8 \u0004\nFor example, let S be a variable of type C such that C has an attribute & of fl and\nfl has an attribute 5 of integer type. S \u000e & \u000e 5 \u0001 3 \u0005 will change state of S 3 \u0006 ffi U C U \u0007 & *% \u0006 \b \u0011 ,\nwhere reference \u0006 is the identity of \u0006 \u0006 U fl U \u0007 5+*% \u0000 \b \u0011 to S 3 \u0006 ffi U C U \u0007 & *% \u0006 \b \u0011 , but the \u0006 is\nnow the identity of the object \u0006 \u0006 U fl U \u0007 5'*% \u0005 \b \u0011 .\nThis semantic definition shows the side-effect of an assignment and does reflect the\nOO feature pointed out by Broy in [7] that an invocation to a method of an object which\ncontains such an assignment or an instance creation defined later on, changes the state\n \nof the system.\nLaw 1 + \n\u0012\f \u0001 3 \f ? \n\r\f \u0001 3 \u0013 + \n\r\f 8=8 \u0011 + \n\r\f \u0001 3 \u0013 + \f 8=8\nLaw 2 + \n\u0012\f \u0006 \u0001 3 \f \u0006 ? \n\r\f \t \u0001 3 \f \t 8 \u0011 + \n\r\f \t \u0001 3 \f \t ? \n\r\f \u0006 \u0001 3 \f \u0006 8 , provided \n\u0012\f \u0006 and \n\r\f \t are distinct\nsimple names which do not occur in \f \u0006 or \f \t .\nNote that the law might not be valid if \n\r\f\n\/\nare composite names. For instance, the fol-\nlowing equation is not valid when S and V have the same value:\nS\n\u000e\n5\n\u0001\n3\nffi\n?\nV\n\u000e\n5\n\u0001\n3\u0001\u0006\n\u0011\nV\n\u000e\n5 3\u0001\u0006\n?\nS\n\u000e\n5 3\nffi\nObject creation The execution of C.new + S 8 \u001a \f # is well-defined if C \u0000 %]\u00137\u0010E\u000f \" , the length\nof the list \f of the expressions is the same as the number of attributes of C and the types\nof the expressions match those of the corresponding attributes of C, i.e.\n\u0000 + C.new + S 8\n\u001a \f\n# 8 3 df C \u00004%]\u0013\u001f\u0010E\u000f2\" \t\n\u0003 \f \u0003\n3 size +B\u0010! ( \nfi\n+ C 8=8 \t \u0010 ff Z  \t\b\nff\n\"\u0002+\n\f\n\/\n8 \u0001 * \"\u001f% &  \t\b\nff\n\"G+ C\n\u000e\n57\/.8\nThe command (re-)declares variable S , creates a new object, attaches the object to S and\nattaches the initial values of the attributes to the attributes of S too.\nC.new + S 8\n\u001a \f\n#G3 df\n\u0007\nfl\u001f\u0010\nfi\nU9S U\n \n+ C 8 \b \u0001\n\u0000 + C.new + S 8\n\u001a \f\n# 8 \u0003\n\f\nref \u0004\u0000 Ref +  8 Z\n\u0000\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0002\n+\n \n+ C 8 \u0004 3  + C 8 \u0004\n\u0007 \u0006\nref U C U \u0007 57\/ * % fl\u0012\u0010 & H \"\u0002+ \f \/B8 \b \u0011 \u0003 57\/ \u0000 \u0010! $ fi + C 8 \b!8 \t\n+=+\nS\n\u0000 , &\nI\n\tL+\nS\n\u0004\n3 ref 8\n\u0001\n+\nS\n\u0000 &\n@\n%ffifl\u001f\u0010\nfi\n\t +\nS\n\u0004\n3\n\u0006\nref \u0011 Z S 8=8\r\t + & @ %]fl\u001f\u0010 fi \u0004 3 \u0007 S \b  & @ %ffifl\u001f\u0010 fi \u0004 \u0007 + S U \u0006 C \u0011 Z & @ %ffifl\u0012\u0010 fi + S 8=8 \b!8\n\u0001\n+\nS\n\u0004\u0000 fl\u001f\u0010\nfi\n\t +\nS\n\u0004\n3\n\u0006\nref \u0011 8\r\t + & @ %ffifl\u001f\u0010 fi \u0004 3 & @ %ffifl\u001f\u0010 fi \u0004 \u0007 + S U \u0006 C \u0011 8 \b!8=8=8\n\u0003\u0005\u0004\n\u0004\n\u0004\n\u0004\n\u0004\n\u0004\n\u0006\nWe will use C.new + S 8 to denote the command C.new + S 8 \u001a \u0007 \u0013 \u0011] 7\u0011$\u0010 & + C \u000e 5 8 # that creates an\ninstance of C with the default initial values of its attributes.\nLaw 3 If S and V are distinct, S does not appear in \u0013 and V does not appear in \f ,\nC \u0006\n\u000e\nnew + S 8\n\u001a \f\n#\n? C \t\n\u000e\nnew + V 8\n\u001a \u0013\n#\n\u0011 C \t\n\u000e\nnew + V 8\n\u001a \u0013\n#\n? C \u0006\n\u000e\nnew + V 8\n\u001a \f\n#\nLaw 4 If S is not free in the Boolean expression D , then\nC.new + S 8\n\u001a \f\n#\n?\n+ \b \u0004LD\u0005\u0006 \t 8\n\u0011\n+ C.new + S 8\n\u001a \f\n#\n?\n\b 8 \u0004LD\u0005\u0006 + C.new + S 8\n\u001a \f\n#\n?\n\t 8\nMethod Call Let C , \u0015 and C \u0015 be lists of expressions. The command \n\r\f\u000f\u000e QL+;C U \u0015 U C \u0015 8 as-\nsigns the values of the actual parameters C and C \u0015 to the formal value and value-result\nparameters of the method Q of the object \u0006 that \n\r\f refers to, and then executes the body\nof Q . After it terminates, the value of the result and value-result parameters of Q are\npassed back to the actual parameters \u0015 and C\u0007\u0017 .\n\n\r\f\u000f\u000e\nQ +;C\nU\n\u0015\nU\nC\n\u0015\n8 3 df + \u0000 +\n\n\r\f\n8\r\t\\ \t\b\nff\n\"\u0002+\n\n\r\f\n8 \u0000 %]\u00137\u0010 \u000f2\"\u0013\t\\Q \u0000\n@]ff\n+; \t\b\nff\n\"2+\n\n\u0012\f\n8=8 \u000b\n\f\nN Z +; \t\b\nff\n\"\u0002+\n\n\r\f\n8T3 N 8 \t\n\u0000\n\u0002\nfl\u001f\u0010\nfi\nN self 3 \n\r\f U R \u0006 S 36C U R \t V 3 \u0015 U R \n X 3 C \u0015 ?\n\n\n+ N\n\u000e\nQ 8\n?\n\u0015\nU\nC\n\u0015\n\u0001\n3\nVGU X\n?\n\"!\u0013 * self U=S U9VGU X\n\u0003\n\u0006\nwhere S U=VGU=X are resp. value, result and value-result parameters of the method Q of class\n \b\nff\n\"\u0002+\n\n\r\f\n8 , and \n + N \u000e Q 8 stands for the design associated with method Q of class N, that\nwill be defined in the semantics of the whole program in Section 3.6.\n3.5 Class declarations\nA class declaration cdecl given in Section 2.1 is well-defined if the following conditions\nhold.\n1. N has not been declared before: N \u0004\u0000 %\u0014\u00137\u0010E\u000f2\" .\n2. N and M are distinct: N \u00043 M.\n3. The attribute names in the class are distinct.\n4. The method names in the class are distinct.\n5. The parameters of every method are distinct.\nLet \u0000 + cdecl 8 denote the conjunction of the above conditions for class declaration\ncdecl. The class declaration cdecl adds the structural information of class N to the state\nof the program, and this role is characterised by the following design.\ncdecl 3 df\n\u0007\n%]\u0013\u001f\u0010E\u000f2\"\nU\nff\u0012fi\n\u0011(%]\u00137\u0010E\u000f \"\nU\n'\nH(ff\n\"\nfi\n% & \u0010\u0012'('\nU\nff\u0012fi\n\u0011$\u0010\nU\nff\u0012fi\u001f@\n \u001f\u0010\nU\nff(H I\n\u0010 \b\n\u0001\n\u0000 + cdecl 8 \u0003\n\u0000\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0002\n%]\u0013\u001f\u0010E\u000f2\"\n\u0004\n3 %]\u00137\u0010 \u000f2\"-\u0004\n\u0007\nN \b\n\t\nff\u0012fi\n\u0011(%]\u00137\u0010E\u000f \"\n\u0004\n3 +\nff(fi\n\u0011(%]\u00137\u0010 \u000f2\"-\u0004\n\u0007\nN \b \u0004 anno + cdecl 8 \u0006\nff\u0012fi\n\u0011(%]\u0013\u001f\u0010E\u000f2\"78\n\t '\nH$ff\n\"\nfi\n% & \u0010\u0012'('\n\u0004\n3 '\nH(ff\n\"\nfi\n% & \u0010\u0012'$' (\n\u0007\nN *% M \b\n\t\nff\u0012fi\n\u0011$\u0010\n\u0004\n3\nff\u0012fi\n\u0011$\u0010 (\n\u0007\nN *%\n\u00071\u0006\n1\n\u0001\n-\nU\n5\n\u0011\n\b \b\n\t\nff\u0012fi\u0012@\n \u001f\u0010\n\u0004\n3\nff\u0012fi\u001f@\n \u001f\u0010 (\n\u0007\nN *%\n\u00071\u0006\nC\n\u0001\nA\nU\nD\n\u0011\n\b \b\n\t\nff(H I\n\u0010\n\u0004\n3\nff(H I\n\u0010 (\n\u0007\nN *%\n\u00071\u0006\nM\n\u0001\nK\nU\nN\n\u0011\n\b \b\n\t\n@ffiff\n\u0004\n3\n@ffiff\n(\n\u0007\nN *%\n\u0007\n+;Q\n\u0006\n*% + paras 8 \u0006 U N \u0006 8=8 U Z\u0014ZEZEZEZ Z U +;Q [ *% + paras\n[\nU\nN [ 8=8 \b \b\n\u0003\u0005\u0004\n\u0004\n\u0004\n\u0004\n\u0004\n\u0004\n\u0004\n\u0004\n\u0006\nwhere the logical variables pria, prota and puba are introduced to record the\ndeclared attributes of N, from which the state attr can later be constructed. Similarly,\nthe dynamic behaviour of the methods cannot be defined before the dependency rela-\ntion among classes is specified. At the moment, the logical variable @ffiff + N 8 binds each\nmethod Q \/ to code N \/ rather than its definition which will be calculated in the end of the\ndeclaration section.\nExample Consider a simple bank system illustrated by the UML class diagram in\nFigure 3. Account is an abstract class1 and has two subclasses of current accounts CA\nand saving accounts SA. The declaration of class Account, denoted by declAccount,\nB\ra\rn\rk\r\nn\ra\rm\re\r\na\rd\rd\rr\re\rs\rs\r\nw\ri\rt\rh\rd\rr\ra\rw\r(\ra\rI\rD\r,\r \ra\rm\ro\ru\rn\rt\r)\r\ng\re\rt\rB\ra\rl\ra\rn\rc\re\r(\ra\rI\rD\r,\r \rr\re\rs\r)\r\no\rp\re\rn\rA\rc\rc\r(\rn\ra\rm\re\r,\r \ra\rm\ro\ru\rn\rt\r)\r\nA\rc\rc\ro\ru\rn\rt\r\na\rN\ro\r \r:\r \rI\rn\rt\r\nb\ra\rl\ra\rn\rc\re\r:\r \rI\rn\rt\r\nw\ri\rt\rh\rd\rr\ra\rw\r(\ra\rm\ro\ru\rn\rt\r)\r\ng\re\rt\rB\ra\rl\ra\rn\rc\re\r(\r)\r\nC\rA\r\nw\ri\rt\rh\rd\rr\ra\rw\r(\ra\rm\ro\ru\rn\rt\r)\r\nS\rA\r\nFig. 3. A bank system\nis written as follows. Note that we allow specification notations (designs) to appear in\nmethods and commands.\n\u0000 \u0001\u0003\u0002\u0005\u0004\u0006\u0004 Account \u0007\n\b\n\t\f\u000b\u000e\r\u0010\u000f \u0000 \r\u0010\u000f\u0012\u0011\u0014\u0013 Int aNo \u0015 Int balance \u0016\n\u0017 \u000f\u0018\r\u0006\u0019\u001a\u000bff\u0011\u0014\u0013 getBal fiffifl\u0012\u0015 Int \u001f \u0015!fl#\"$\u0007\u0006\u001f \u0013 % balance &'\u0016\nwithdraw fi Int (\u001a\u0015)fl\u0018\u0015*fl'\"*\u0007 balance +,( - balance . % balance \/0(1&#&\nThe declaration declCA of CA is given as\n\u0000 \u0001\u0003\u0002\u0005\u0004\u0006\u0004 CA \u000f\u001821\r3\u000f54\u001a\u0011\n\u0004 Account\n\u0017 \u000f\u0018\r\u0006\u0019\u001a\u000bff\u0011\u0014\u0013 withdraw fi Int (\u001a\u0015!fl\u0018\u0015!fl'\"*\u0007 balance \u0013 % balance \/0(1&\n&\n1 See [25] for a formal definition of an abstract class.\nWe can write the declarations of SA (in which method withdraw is just inherited the\nfrom Account) and Bank (which has a set of accounts associated with it) in the same\nway.\nIt is easy to see that both declAccount and declCA are well-formed. The semantics\nof declAccount is defined by the following design.\ndeclAccount 3 true \u0003\n\u0000\n\u0002\n%]\u00137\u0010 \u000f2\"\n\u0004\n3 %]\u00137\u0010E\u000f \"-\u0004\n\u0007\nAccount \b \t\nff(fi\u001f@\n \n\u0004\n3\n\u0007\nAccount *%\n\u0007 \u0006\nInt aNo \u0011 U\n\u0006\n\u0011]\u0013\u0012 balance \u0011 \b \b \t\n@ffiff\n\u0004\n3\n\u0007\nAccount *%\n\u0007\ngetBal *% +\n\u0006\u0001\u0000\nU Int D U\n\u0000\n\u0011 U\nD\n\u0004\n3 balance 8 U\nwithdraw *% +\n\u0006\nInt S U\n\u0000\nU\n\u0000\n\u0011 U balance \u0002 S \u0003 balance \u0004 3 balance $ S 8 \b \b\n\u0003\n\u0006\nThe semantics of declCA is the following.\ndeclCA 3 true \u0003\n\u0000\n\u0001\n\u0001\n\u0002\n%]\u00137\u0010 \u000f2\"\n\u0004\n3 %]\u00137\u0010E\u000f \"-\u0004\n\u0007\nCA \b \t\n'\nH(ff\n\"\nfi\n% & \u0010('('\n\u0004\n3\n\u0007\nCA *% Account \b \t\n@ffiff\n\u0004\n3\n\u0007\nAccount *%\n\u0007\nwithdraw *%\n+\n\u0006\nInt S U\n\u0000\nU\n\u0000\n\u0011 U balance \u0004 3 balance $ S 8 \b \b\n\u0003\n\u0004\n\u0004\n\u0006\nThe semantics of declSA and declBank for classes SA and Bank can be defined in the\nsame way.\nA class declaration section cdecls comprises a sequence of class declarations. Its\nsemantics is defined from the semantics of a single class declaration given above, and\nthe semantics of sequential composition. However, the following well-definedness con-\nditions need to be enforced onto a declaration section:\n1. All class names used must be declared in the declaration section;\n2. Any superclass of a declared class is declared too;\n3. The function superclass does not induce circularity;\n4. No attributes of a class can be redefined in its subclasses;\n5. No method is allowed to redefine its signature in its subclass.\nThe formal definitions for these conditions are omitted here due to page limitation. In\nwhat follows we denote them as \u0000 \u0006 , \u000e \u000e \u000e , \u0000 \u0003 , respectively.\n3.6 The semantics of a program\nLet cdecls be a class declaration section and P main method of the form + , & I U N\u00148 , the\nmeaning of a program + cdecls \u0004 P 8 is defined as the composition of the meaning of class\ndeclarations cdecls (defined in Section 3.5), the design init, and the meaning of command\nP:\ncdecls \u0004 P 3 df cdecls ? init ? %]\u00137\u0010E\u000f2\" \u0004 3\nff\u0012fi\n\u0011(%]\u00137\u0010E\u000f \"\n \n%]\u00137\u0010E\u000f \"\n?\nN\nwhere the design init performs the following tasks\n1. to check the well-definedness of the declaration section,\n2. to decide the values of \u0010! $ fi and fl7\u0011('$\u0011 I & \"\u0012\u0010ffi ( fi from those of ff(fi \u0011$\u0010 , ff\u0012fi\u001f@  \u0012\u0010 and ff(H I \u0010 ,\n3. to define the meaning of every method body N ,\n4. to check the well-definedness of , & I , i.e. its consistency with the class declarations:\n\u0000 + , &\nI\n803 df \u0010T+ S \u0001 R 8 \u0000 , &\nI\nZ\nR \u0000 + \u0002\/\u0004 +\nff\u0012fi\n\u0011(%]\u00137\u0010E\u000f \"\n \n%]\u00137\u0010E\u000f2\"\u001f8=8\nThe design init is formalised as:\ninit 3 df\n\u0007\nfl7\u0011('$\u0011\nI\n& \"\u0012\u0010ffi ( \nfi\nU\n\u0010! ( \nfi\nU\n@ffiff\n\b\n\u0001\n\u0000\n\u0006\n\t \u0000\n\t\n\t \u0000\n\n\n\t \u0000\n\u000b\n\t \u0000 \u0003 \t \u0000 + , &\nI\n8 \u0003\n\u0000\u0001\n\u0001\n\u0002\nfl7\u0011$'(\u0011\nI\n& \"(\u0010! ( \nfi\n\u0004\n3\n!\nN \"$# %\u000f'\u0001(*)\n\u0007\nN\n\u000e\n5\n\u0003\n5 \u0000\nff(H I\n\u00102+ N 8 \b\n\t \u0010 N \u0000 %]\u00137\u0010 \u000f2\" Z \u0010! ( \nfi\n\u0004\n+ N 803\nff(fi\n\u0011$\u00102+ N 8 \u0004\n\u0003\n\u0007Eff\u0012fi\u001f@\n \u001f\u0010\u0002+ M 8 \u0004\nff(H I\n\u00102+ M 8\n\u0003\nN \u0001 M \b\n\t\n@ffiff\n\u0004\n+ N 803\n\u0007\nQ *% + paras U\n\n\n+ N\n\u000e\nQ 8=8\n\u0003\n+;Q *% + paras U N\u00148=8 \u0000\n@ffiff\n+ M 8\r\t N \u0001 M \b\n\u0003\u0005\u0004\n\u0004\n\u0006\nwhere the family of designs \n + N \u000e Q 8 is defined in the rest of this section.\nThe family of designs \n + N \u000e Q 8 captures the dynamic binding and is defined by a set\nof recursive equations, which contains for each class N \u0000 %]\u0013\u001f\u0010E\u000f2\" , each class M such that\nN \u0001 M, and every method Q \u0000 @ffiff + M 8 and equation\n\n\n+ N\n\u000e\nQ 8 3 # N < > +\n\n\n8 where '\nH(ff\n\"\nfi\n%$\u0010 & '$'\u0002+ N 803 M\nwhere # is constructed according to the following rules:\n(1) Q is not defined in N, but in a superclass, i.e. Q \u0004\u0000 @ffiff + N 8\r\t\\Q \u0000 \u0004 \u0007ffi@ffiff + M 8 \u0003 N \u0001 M \b .\nThe defining equation for this case is simply\n# N < > +\n\n\n8 3 df Set + N 8 ? \u0000 N + \n\u0002\u0001\u0004\u0003\u0006\u0005 + M\n\u000e\nQ 8=8\n? Reset\nwhere the design Set + N 8 finds out all attributes visible to class N in order for the\ninvocation of method Q of N to be executed properly, whereas Reset resets the en-\nvironment to be the set of variables that are accessible to the main program only:\nSet + N 803 df\n\u0007\nfl\u001f\u0011('(\u0011\nI\n& \"\u0012\u0010! ( \nfi\n\b\n\u0001 true \u0003\nfl7\u0011('(\u0011\nI\n& \"\u0012\u0010! ( \nfi\n\u0004\n3\n\u0003\n\u0007\nN\n\u000e\n5\n\u0003\n5 \u0000\nff\u0012fi\n\u0011!\u00102+ N 8 \b \u0004\n\u0003 N \u0007 M\n\u0007\nM\n\u000e\n5\n\u0003\n5 \u0000\nff\u0012fi\u0012@\n \u001f\u00102+ M 8 \b \u0004\n\u0003 M \"$#&%\u000f'&(*)\n\u0007\nM\n\u000e\n5\n\u0003\n5 \u0000\nff(H I\n\u00102+ M 8 \b \u0004\nReset 3 df\n\u0007\nfl7\u0011('$\u0011\nI\n& \"\u0012\u0010ffi ( \nfi\n\b\n\u0001 true \u0003 fl7\u0011('$\u0011\nI\n& \"\u0012\u0010ffi ( \nfi\n\u0004\n3\n\u0003 M \" #&%\u000f'\u0001( )\n\u0007\nM\n\u000e\n5\n\u0003\n5 \u0000\nff(H I\n\u00102+ M 8 \b\nThe function \u0000 N renames the attributes and methods of class N in the code \n\b\u0001\u0004\u0003\u0006\u0005 + N\n\u000e\nQ 8\nby adding object reference self that represents the active object that is executing\nits method. The definition of \u0000 N is given in Fig. 4. Note that Set and Reset are\nused to ensure data encapsulation that is controlled by fl7\u0011('(\u0011 I & \"\u0012\u0010! $ fi and the well-\nformedness condition of an expression.\n(2) Q is a method defined in class N. In this case, the behaviour of the method N \u000e Q is\ncaptured by its body \n\u0002\u0001\t\u0003\t\u0005 + N \u000e Q 8 and the environment in which it is executed\n# N < > +\n\n\n8 3 df Set + N 8 ? \u0000 N + \n\u0002\u0001\u0004\u0003\u0006\u0005 + N\n\u000e\nQ 8=8\n? Reset\nP \u0000 N + P 8 P\n\u0000\nN + P 8\nskip skip chaos chaos\nP \u0006 \u0004LD\u0005\u0006 P \t \u0000 N + P \u0006 8\u0001\u0000 \u0000 N +;DE8\u0001\u0002 \u0000 N + P \t 8 P \u0006 ? P \t \u0000 N + P \u0006 8 ? Set + N 8 ? \u0000 + P \t 8\nP \u0006 \u0007 P \t \u0000 N + P \u0006 8 \u0007 \u0000 N + P \t 8 D\t\b P \u0000 N +;D\u00148 \b + \u0000 N + P 8 ? Set + N 8=8\nfl\u001f\u0010\nfi\nS\n\u0001\nR 3\n\f\nfl\u001f\u0010\nfi\nS\n\u0001\nR 3\n\u0000 N +\n\f\n8 \"!\u0013 *\nS\n\"!\u0013 *\nS\nC.new + S 8 C.new + \u0000 N + S 8=8\n\n\r\f\n\u0001\n3\n\f\n\u0000 N +\n\n\u0012\f\n8\n\u0001\n3\n\u0000 N +\n\f\n8\n\n\r\f\u000f\u000e\nQ +;C\nU\n\u0015\nU\nC\n\u0015\n8\n\u0000 N +\n\n\r\f\n8\n\u000e\nQ +\n\u0000 N +;C78 U \u0000 N +\n\u0015\n8\nU\n\u0000 N +;C\n\u0015\n8=8\n\n\r\f\u000f\u000e\n5\n\u0000 N +\n\n\r\f\n8\n\u000e\n5\nQ +;C\nU\n\u0015\nU\nC\n\u0015\n8 self \u000e QL+ \u0000 N +;C78 U \u0000 N +\n\u0015\n8\nU\n\u0000 N +;C\n\u0015\n8=8 null null\nself self \u0013 + \f 8 \u0013 + \u0000 N +\n\f\n8=8\nS\n,\nself \u000e S U S \u0000\n\u0003 N \u0007 M \u0010! ( \nfi\n\u00137\u0010E\u000f2\"G+ M 8\nS U otherwise\nFig. 4. The Definition of \u0000 N\n4 Refinement\nWe would like the refinement calculus to cover not only the early development stages\nof requirements analysis and specification but also the later stages of design and imple-\nmentation. This section presents the initial results of our exploration on three kinds of\nrefinement:\n1. Refinement relation between object systems.\n2. Refinement relation between declaration sections.\n3. Refinement relation between commands.\nFrom now on, we assume the main method of each program does not use direct field\naccess, that is, expressions of the form le.a. This assumption actually does not reduce\nthe expressiveness of the language, as we can always use getField and setField methods to\nreplace direct field access where necessary. In what follows, we give formal definitions\nfor the above-mentioned refinement relations.\nDefinition 4. Let \u001f \u0006 and \u001f \t are object programs which have the same set of global\nvariables , & I , let \u0003 C\u00125 \u0015\u0005\u0004\u0007\u0006 , ffT3 ffi U \u0006 , be the set of all other variables that are free in \b \/ and\n\u0003\nC\u00125\n\u0015\n\u0004\u0004\u0007\u0006 be the set of their primed versions. \u001f \u0006 is a refinement \u001f \t , denoted by \u001f \u0006\t\b\u000b\n \f \n \u001f \t ,\nif its behaviour is more controllable and predictable than that of \u001f \t :\n\u001f\n\u0006\t\b\nsys \u001f \t 3 df \u0010 , &\nI\nU\n, &\nI\n\u0004\nZ\n+\n\f\n\u0003\nC\u00125\n\u0015\u0007\u0004\n\u0005\nU\n\u0003\nC\u00125\n\u0015\n\u0004\n\u0004\n\u0005\nZ\n\u001f\n\u0006\n8 \u000b +\n\f\n\u0003\nC\u00125\n\u0015\u0007\u0004\n\u0010\nU\n\u0003\nC\u00125\n\u0015\n\u0004\n\u0004\n\u0010\nZ\n\u001f\n\t\n8\nThis indicates the external behaviour of \u001f \u0006 , that is, the pairs of pre- and post global\nstates, is a subset of that of \u001f \t .\nDefinition 5. Let cdecls \u0006 and cdecls \t be two declaration sections. We say cdecls \u0006 is a\nrefinement of cdecls \t , denoted by cdecls \u0006\r\b\u000f\u000e\u0011\u0010 \u0012 \n\u0013\n cdecls \t , if the former can replace the\nlater in any object system:\ncdecls \u0006\t\b class cdecls \t 3 df \u0010 P Z + cdecls \u0006 \u0004 P \b sys cdecls \t \u0004 P 8\nwhere P stands for a main method + , & I U NE8 .\nIntuitively, it states that cdecls \u0006 supports at least the same set of services as cdecls \t .\nDefinition 6. Let P \u0006 and P \t be main methods with the same global variables, and N \u0006\nand N \t be commands. We define\nP \u0006\t\b cmd P \t 3 df \u0010 cdecls Z + cdecls \u0004 P \u0006 8 \b sys + cdecls \u0004 P \t 8\nN\n\u0006\t\b\nN\n\t\n3 df \u0010GC U C \u0004 Z +;N \u0006 \u000b N \t 8\nwhere cdecls is a declaration section, and C and C \u0004 are free variables in N \u0006 and N \t .\nIntuitively, it denotes that P \u0006 does better than P \t , i.e. ensures a stronger postcondition\nwith a weaker precondition, under the same environment.\nWe have already given some refinement laws for refining program commands in\nSection 3.4, which are to ensure the correctness of the semantic model. In what follows,\nwe first give a group of refinement laws that in fact formalize principles of refactoring\n[13]. After that, we will present three refinement laws which capture three key principles\nand patterns in object-oriented design, that are well known as the Expert Pattern, High\nCohesion Pattern and Low Coupling Pattern [22, 24].\nWe first introduce some notations. We use N \u001a supc U pri U prot U pub U ops # to denote a well-\nformed class declaration that declares the class N that has supc as its direct superclass;\npri, prot and pub as its sets of private, protected and public attributes; and ops as its set\nof methods. supc is always of either a class name M, when M is the direct superclass of\nN, or\n\u0000\nwhen N has no superclass. We may also only refer to some, or even none of M,\npri, prot, pub, ops when we talk about a class declaration. For example, N denotes a class\ndeclaration for N, and N \u001a pri # a class declaration that declares the class N that has pri as\nits private attributes.\nLaw 5 The order of the class declarations in a declaration section is not essential:\nN \u0006 ?\n\u000e \u000e \u000e\n? N F 3 N \/ \u0005 ?\n\u000e \u000e \u000e\n? N \/\u0001\u0000\nwhere N \/ is a class declaration and ff \u0006 U \u000e \u000e \u000e U ff F is a permutation of \u0007 ffi U \u000e \u000e\u000b\u000e U + \b .\nA law like this may look utterly trivial, but it is not so obvious for a semantic definition\nof a class declaration to guarantee this law. For example, if the the pre-condition of the\nclass declaration requires that the direct superclass has been declared, this law would\nnot hold.\nThe next law says that more services may come from more classes.\nLaw 6 If a class name N is not in cdecls, cdecls \u000e N \u001aM U pri U prot U pub U ops # ? cdecls \u000e\nIntroducing a private attribute has no effect.\nLaw 7 If neither N nor any of its superclasses and subclasses in cdecls has S as an\nattribute N \u001a pri # ? cdecls \u000e N \u001a pri \u0004 \u0007 R S 3\u0005& \b\u0014# ? cdecls.\nChanging a private attribute into a protected one may support more services.\nLaw 8 N \u001a pri \u0004 \u0007 R S 3\u0005& \b U prot # ? cdecls \u000e N \u001a pri U prot \u0004 \u0007 R S 3 & \bE# ? cdecls.\nSimilarly, changing a protected attribute to a public attribute refines the declaration too.\nAdding a new method can refine a declaration.\nLaw 9 If Q is not defined in N, let QL+ paras 8 \u0007 N \b be a method with distinct parameters\nparas and a command N . Then\nN\n\u001a\nops # ? cdecls \u000e N\n\u001a\nops \u0004\n\u0007\nQ + paras 8\n\u0007\nN \b \b\u0014#\n? cdecls\nprovided that there is no superclass of N in cdecls.\nLaw 10 We can refine a method to refine a declaration. If N \u0006 \u000e N \t ,\nN\n\u001a\nops \u0004\n\u0007\nQ + paras 8\n\u0007\nN\n\u0006\n\b \bE#\n? cdecls \u000e N\n\u001a\nops \u0004\n\u0007\nQL+ paras 8\n\u0007\nN\n\t\n\b \b\u0014#\n? cdecls\nInheritance introduces refinement.\nLaw 11 If none of the attributes of N is defined in M or any superclass of M in cdecls,\nN\n\u001a \u0000\nU pri U prot U pub U ops # ? cdecls \u000e N\n\u001a\nM U pri U prot U pub U ops # ? cdecls\nWe can introduce a superclass as given in the following law.\nLaw 12 Let C \u0006 3 N \u001a \u0000 U pri \u0004 \u001f U prot U pub U ops # , C \t 3 N \u001a \u0007 M \b U pri U prot U pub U ops # . Assume M\nis not declared in cdecls,\nC \u0006\u0014? cdecls \u000e C \tffi? M\n\u001a \u0000\nU\n\u0000\nU\n\u001f\nU\n\u0000\nU\n\u0000\n#\n? cdecls\nWe can move some attributes of a class to its superclass.\nLaw 13 If all the subclasses of M but N do not have attributes in \u001f , then\nM\n\u001a\nprot \u0006 # ? N\n\u001a \u0007\nM \b U prot \u0004 \u001f # ? cdecls \u000e M\n\u001a\nprot \u0006 \u0004 \u001f # ? N\n\u001a \u0007\nM \b U prot # ? cdecls\nWe can move the common attributes of the direct subclasses of a class to the class itself.\nLaw 14 If M has N \u0006 U \u000e \u000e\u000b\u000e U N O as its direct subclasses,\nM\n\u001a\nprot # ? N \u0006\n\u001a\nprot\n\/\n\u0004 \u001f #\n?\n\u000e \u000e\u000b\u000e\n? N O\n\u001a\nprot O \u0004 \u001f # ? cdecls\n\u000e M\n\u001a\nprot \u0004 \u001f # ? N \u0006\n\u001a\nprot \u0006 # ?\n\u000e \u000e \u000e\n? N O\n\u001a\nprot O # ? cdecls\nWe can move some methods of a class to its superclass.\nLaw 15 Let Q + paras 8 \u0007 N \b be a methods of N, but not a method of its direct superclass\nM. Assume that N only involves the protected attributes of M, then\nM\n\u001a\nops # ? N\n\u001a \u0007\nM \b U ops \u0006 \u0004\n\u0007\nQ + paras 8\n\u0007\nN \b \b\u0014#\n? cdecls\n\u000e M\n\u001a\nops \u0004\n\u0007\nQ + paras 8\n\u0007\nN \b \bE#\n? N\n\u001a \u0007\nM \b U ops \u0006 # ? cdecls\nWe can remove a redundant method from a subclass.\nLaw 16 Assume that N has M as its direct superclass and QL+ paras 8 \u0007 N \b \u0000 ops \" ops \u0006 ,\nand N only involves the protected attributes of M,\nM\n\u001a\nops # ? N\n\u001a \u0007\nM \b U ops \u0006 # ? cdecls \u000e M\n\u001a\nops # ? N\n\u001a \u0007\nM \b U ops \u0006\n\u0000 \u0007\nQ + paras 8\n\u0007\nN \b \bE#\n? cdecls\nWe can remove any unused private attributes.\nLaw 17 If + R S 8 is a private attribute of N \u001a pri # that is not used in any command of N,\nN\n\u001a\npri # ? cdecls \u000e N\n\u001a\npri\n\u0000 \u0007\nR\nS\n3\u0005& \b\u0014#\n? cdecls\nWe can remove any unused protected attributes.\nLaw 18 If + R S 3 &78 is a protected attribute of N \u001a prot # that is not used in any command\nof N and any subclass of N,\nN\n\u001a\nprot # ? cdecls \u000e N\n\u001a\nprot\n\u0000 \u0007\nR\nS\n3 & \bE#\n? cdecls\nThe expert patterns says that a class is allowed to delegate some tasks to its associated\nclasses that contain the information for the tasks.\nLaw 19 + \u0000 \u0001\u0003\u0002 \u0010 \u000e \f \u0004 \u000e\u000f\f\r\f\r\u0010 \u000e\u0006\u0005\b\u0007 \u0001 \u000e\n\t'\u0010\u0007\n \u0002\b\u0001 \u0005 \n \b\u000b\n\r\b \f\u000b\b \f \u0005\f\u000b \n \n \b \r \u0005 \u000e \u0010\u000f\u0005 \f 8 Suppose M \u001a ops \u0006 # is de-\nfined in cdecls, Q + paras \u0006 8 \u0007 N \u0006 \b \u0000 ops \u0006 , and + M \u0006(8 be an attribute of N, then\nN\n\u001a\nops \u0004\n\u0007\n+\n+ paras 8\n\u0007\nN\n\u001a\u0011\u0010\nN\n\u0006\n# \b \bE#\n? cdecls \u000e N\n\u001a\nops \u0004\n\u0007\n+\n+ paras 8\n\u0007\nN\n\u001a\n\u0006\n\u000e\nQ # \b \b\u0014#\n? cdecls\nHere N \u0006 is obtained from \u0010N \u0006 by replacing \u0006 \u000e S with S , that is, N \u0006 3 \u0010N \u0006 \u001a S \u0011 \u0006 \u000e S # . Notice\nthat \u0010N \u0006 does not refer to any attribute of N. While N \u001a\u0012\u0010N \u0006 # denotes that \u0010N \u0006 occurs as part\nof command N , and N \u001a \u0006 \u000e Q\\# denotes that the command obtained from N \u001a\u0012\u0010N \u0006 # by substituting\n\u0006\n\u000e\nQ for \u0010N \u0006 . Note also that paras \u0006 . paras.\nThis law is illustrated by the UML class diagram in Figure 5. It will become an equation\nif S is a public attribute \u0013 .\nN\r\no\r:\rM\r\nn\r \r{\rc\r[\rc\r1\r(\ro\r.\rx\r}\r]\r}\r\nM\r\nx\r\nm\r \r{\rc\r1\r(\rx\r)\r}\r\nN\r\no\r:\rM\r\nn\r \r{\rc\r[\ro\r.\rm\r ]\r}\r\nM\r\nx\r\nm\r \r{\rc\r1\r(\rx\r)\r}\r\nFig. 5. Object-oriented Functional decomposition\nTo understand the above law, let us consider a simple example from the afore-\nmentioned bank system in Section 3.5.\nConsider method getBalance of class Bank. Initially, we might have the following\ndesign for it:\ngetBalance fi Int aID \u0015 Int res \u0015!fl#\" % df\n\u0014\na \u0015 \u0016 fi Account \"\u0018\u0017 a.aNo % aID -\n\u0014\na \u0015 \u0016 fi Account \"\u0018\u0017 a \u0019 aNo % aID \u001a res\n.\n% a.balance\nNote that it requires the attributes of class Account to be visible (public) to other classes\n(like Bank). Applying Law 19 to it, we can get the following design:\ngetBalance + Int aID U Int res U\n\u0000\n8W3 df\n\f\na \u0000\n \n+ Account 8 Z a.aNo 3 aID \u0003\n\f\na \u0000\n \n+ Account 8 Z a\n\u000e\naNo 3 aID \u000b res \u0004 3 a.getBalance +B8\nThe refinement delegates the task of balance lookup to the Account class.\nIt is important to note that method invocation, or in another term, object interaction\ntakes time. Therefore, this object-oriented refinement (and the one described in Law 21\nlater) usually exchanges efficiency for \u201csimplicity\u201d, ease of reuse and maintainability,\nand data encapsulation.\nAfter functionalities are delegated to associated classes, data encapsulation can be\napplied to increase security and maintainability. The visibility of an attribute can be\nchanged from public to protected, or from protected to private under certain circum-\nstances. This is captured in the following law.\nLaw 20 + \u0000 \u000e\u000f\f\r\u000e \u0000 \u0005 \u0001 \u000e \u0002 \n\u0003\u0002 \f \u000e\u000f\f \b \u0001 \u0005 8 Suppose M \u001a pri U prot U pub # , and + R \u0006 a \u0006 3\u0005& \u0006 8 \u0000 pub,\n+ R\n\t a \t 3\u0005& \t 8 \u0000 prot.\n1. If no operations of other classes have expressions of the form le.a \u0006 , except for those\nof subclasses of M, we have\nM\n\u001a\npri U prot U pub # ? cdecls \u000e M\n\u001a\npri U prot \u0004\n\u0007\nR\n\u0006 a \u0006 3\u0005& \u0006 \b U pub\n\u0000 \u0007\nR\n\u0006 a \u0006 3\u0005& \u0006 \bE# ? cdecls\n2. If no operations of any other classes have expressions of the form le.a \t , we have\nM\n\u001a\npri U prot U pub # ? cdecls \u000e M\n\u001a\npri \u0004\n\u0007\nR\n\t a \t 3\u0005& \t \b U prot\n\u0000 \u0007\nR\n\t a \t 3 & \t \b U pub # ? cdecls\nAfter applying Law 19 exhaustively (i.e. the expert pattern) to the class Bank for method\ngetBalance, we can then apply Law 20 to the class diagram on the right hand side of\nFigure 5 to achieve the encapsulation of the attribute balance of the class Account. The\nattribute aNo can be encapsulated in a similar way.\nAnother principle of object-oriented design is to make classes simple and highly\ncohesive. This means that the responsibilities (or functionalities) of a class, i.e. its meth-\nods, should be strongly related and focused. We therefore often need to decompose a\ncomplex class into a number of associated classes, so that the system will be\n\u2013 easy to comprehend\n\u2013 easy to reuse\n\u2013 easy to maintain\n\u2013 less delicate and less effected by changes\nWe capture the High Cohesion design pattern [22] by the following refinement rule.\nLaw 21 + \u0004 \b \r \u0005\u0007\u0006 \u0001\b\u0005 \u0010\u0007\n \b \u0001 \u0005 \u0004 \u000e\u000f\f\r\f:\u0010 \u000e\u0006\u0005 8 Assume M \u001a \u0002 \u0015 ff U \u0006 \u0002 # is a well-formed class declara-\ntion, \u0002\n\u0015\nff 3\n\u0007\nS U=V\n\b are (or lists of) attributes of M, Q \u0006 \u0007 N \u0006 + S 8 \b \u0000 \u0006 \u0002 only contains attribute\nS , method Q \t \u0007 N \t \u001a Q \u0006 # \b \u0000 \u0006 \u0002 can only change S by calling Q \u0006 (or though it does not have\nto change it at all). Then\n1. M \u000e M \u001a \u0002 \u0015 ff F\n\t\f\u000b U \u0006 \u0002 F\r\t\f\u000b # ? M \u0006 \u001a \u0002 \u0015 ff \u0006 U \u0006 \u0002 \u0006 # ? M \t \u001a \u0002 \u0015 ff \t U \u0006 \u0002 \t # ,\nwhere\nM\r\nx\r\ny\r\nm\r1\r \r{\rc\r1\r(\rx\r)\r}\r\nm\r2\r \r{\rc\r2\r[\rm\r1\r]\r}\r\nM\r\nM\r1\r \ro\r1\r\nM\r2\r \ro\r2\r\nm\r1\r \r{\ro\r1\r.\rm\r1\r}\r\nm\r2\r \r{\ro\r2\r.\rm\r2\r}\r\nM\r1\r\nx\r\nm\r1\r \r{\rc\r1\r(\rx\r)\r}\r\nM\r2\r\ny\r\nM\r1\r \ro\r1\r\nm\r2\r \r{\rc\r2\r[\ro\r1\r.\rm\r1\r]\r}\r\nM\r\nx\r\ny\r\nm\r1\r \r{\rc\r1\r(\rx\r)\r}\r\nm\r2\r \r{\rc\r2\r[\rm\r1\r]\r}\r\nM\r\nM\r2\r \ro\r2\r\nm\r1\r \r{\ro\r1\r.\rm\r1\r}\r\nm\r2\r \r{\ro\r2\r.\rm\r2\r}\r\n(\ra\r )\r\nM\r 2\r\ny\r\nM\r1\r \ro\r1\r\nm\r1\r \r{\ro\r1\r.\rm\r1\r}\r\nm\r2\r \r{\rc\r2\r[\ro\r1\r.\rm\r1\r]\r}\r\nM\r1\r\nx\r\nm\r1\r \r{\rc\r1\r(\rx\r)\r}\r\n(\rb\r)\r\nf\ro\r r\ra\rl\r l\r o\r :\rM\r .\r \r(\ro\r .\ro\r 1\r=\r o\r .\ro\r 2\r.\ro\r 1\r)\r\nFig. 6. Class Decomposition\n\u2013\n\u0002\n\u0015\nff\nF\r\t\f\u000b\n3\n\u0007\nM \u0006\n\u0006\n\u0006\nU M \t\n\u0006\n\t\n\b\n\u2013 \u0006\n\u0002\nF\r\t\f\u000b\n3\n\u0007\nQ\n\u0006\n\u0007\n\u0006\n\u0006\n\u000e\nQ\n\u0006\n\b\nU\nQ\n\t\n\u0007\n\u0006\n\t\n\u000e\nQ\n\t\n\b \b\n\u2013\n\u0002\n\u0015\nff\n\u0006\n3\n\u0007\nS\n\b , \u0006\n\u0002\n\u0006\n3\n\u0007\nQ\n\u0006\n\u0007\nN\n\u0006\n+\nS\n8 \b \b\n\u2013\n\u0002\n\u0015\nff\n\t\n3\n\u0007\nV U M \u0006 \u0006 \u0006 \b , \u0006 \u0002 \t 3\n\u0007\nQ\n\t\n\u0007\nN\n\t\n\u001a\n\u0006\n\u0006\n\u000e\nQ\n\u0006\n# \b \b\nsuch that\n\u0010\u0005\u0006\n\u0001 M Z\n+\u0001\u0006\n\u000e\n\u0006\n\u0006\n3 \u0006\n\u000e\n\u0006\n\t\n\u000e\n\u0006\n\u0006\n8\nis an invariant of M. This invariant has to be\nestablished by the constructors of these three classes.\nThis refinement is illustrated by the diagram in Figure 6(a).\n2. M \u000e M \u001a \u0002 \u0015 ff F\n\t\f\u000b U \u0006 \u0002 F\r\t\f\u000b # ? M \u0006 \u001a \u0002 \u0015 ff \u0006 U \u0006 \u0002 \u0006 # ? M \t \u001a \u0002 \u0015 ff \t U \u0006 \u0002 \t # ,\nwhere\n\u2013\n\u0002\n\u0015\nff\nF\r\t\f\u000b\n3\n\u0007\nM \t\n\u0006\n\t\n\b\n\u2013\n\u0006\n\u0002\nF\r\t\f\u000b\n3\n\u0007\nQ\n\u0006\n\u0007\n\u0006\n\u0006\n\u000e\nQ\n\u0006\n\b\nU\nQ\n\t\n\u0007\n\u0006\n\t\n\u000e\nQ\n\t\n\b \b\n\u2013\n\u0002\n\u0015\nff\n\u0006\n3\n\u0007\nS\n\b\n,\n\u0006\n\u0002\n\u0006\n3\n\u0007\nQ\n\u0006\n\u0007\nN$+\nS\n8 \b \b\n\u2013\n\u0002\n\u0015\nff\n\t\n3\n\u0007\nV U M \u0006\n\u0006\n\u0006\n\b\n,\n\u0006\n\u0002\n\t\n3\n\u0007\nQ\n\u0006\n\u0007\n\u0006\n\u0006\n\u000e\nQ\n\u0006\n\b\nU\nQ\n\t\n\u0007\nN\n\t\n\u001a\n\u0006\n\u0006\n\u000e\nQ\n\u0006\n# \b \b\nsuch that \u0002 +\u0001\u0006 \u0006 \u000e S U=V 8 is an invariant of M \t .\nThis refinement is illustrated by the diagram in Figure 6(b).\nNotice that the first refinement in Law 21 requires that M to be coupled with both M \u0006\nand M \t ; and in the second refinement M is only coupled with M \t , but more interaction\nbetween M \t and M \u0006 are needed than in the first refinement. We believe that the above\nthree laws, together with the other simple laws for incremental programming effectively\nsupport the use-case driven and iterative RUP development process [22]. The use of\nthe patterns for responsibility assignment in object-oriented software development is\nclearly demonstrated in Larman\u2019s book [22] and in the lecture notes of Liu in [24].\nFor each of the laws, except for Law 13 in the Appendix, let LHS and RHS denote\nthe declarations on the left and right hand sides, respectively. For any main program P,\neach refinement law becomes an equational law: LHS\n\u0004\nP \u0011 RHS\n\u0004\nP, provided LHS\n\u0004\nP\nis well-defined.\n5 Conclusion\nWe have shown how Hoare and He\u2019s design calculus [18] is used to define an OO\nlanguage. A program is represented as a predicate called a design, and the refinement\nrelation between programs is defined as implication between predicates.\nIn [7], Broy gave an assessment of object-orientation. Our model reflects most of the\nfeatures, no matter good or bad, of object-oriented designs. For example, the model does\nshow that inheritance with attribute hiding and method overriding makes it difficult to\nanalyse the system behaviour, and method invocation on an object may indeed change\nthe system\u2019s global states.\nNevertheless, formal techniques for object-orientation have achieved significant ad-\nvance in areas of both formal methods and object technology, e.g. [1, 2, 6, 4, 8, 29].\nThere are a number of recent articles on Hoare Logics for object-oriented program-\nming (see, e.g. [30, 35, 20, 31, 23, 9]). The normal form of a program in our paper is\nsimilarly to that of [9, 30]. However, one major difference of our work is that we also\nprovide a formal characterisation and refinement of the contextual\/structural features,\ni.e. the declaration section, of an object program. This is motivated by our work on the\nformalisation and combinations of UML models [25, 26] to deal with consistency prob-\nlems of different UML models. This characterisation has been proven to be very useful\nin defining semantics for integrated specification languages in general. For example,\n[32] uses this characterisation in defining a semantics of TCOZ.\nThe notions of different kinds of refinements in our model are very close to those\nin [9], though the semantics in [9] is defined in terms of the weakest precondition pred-\nicate transformer and does not deal with reference types. We take a weak semantic\napproach meaning that when the pre-condition of a contact is not satisfied in a state,\nthe program will then behave as chaos, and any modification to the program, such as\nadding exceptional handling, will be a refinement to the program. We also describe\nstatic well-formedness conditions in the pre-condition so that any correction of any\nstatic inconsistency in a program, such as static type mismatching, missing variables,\nmissing methods, etc. will be refinement too. This decision is required for structural\nrefinement calculus of OO designs in order to treat refactoring [13] as refinement and\nproperly combine it with functional\/behavioural refinement. This combination is im-\nportant for the application of the model to composing different UML models and to\nreasoning about their consistency [25, 26] and in giving semantics for integrated lan-\nguage [32]. Also our work on formal object-oriented design with UML [25, 26] has\nprovided us with the insight of functional decomposition in the object-oriented setting\nand its relation with data encapsulation. The functional decomposition and data encap-\nsulation are characterised by the refinement laws 19 - 20. They reflect the essential\nprinciple of object-oriented design.\nThe power of UTP[18] for describing different features of computing, such as state-\nbased properties, communication, timing, higher-order computing [18, 36, 34], makes\nour approach ready for an extension to cope with these different aspects of object-\noriented designs. Alternatively, one can also use temporal logic, such as [3], for the\nspecification and verification of multithreading Java-like programs. However, we would\nlike to deal with concurrency at a higher level when we extend this model for component-\nbased software development [17, 16].\nIn [7], Broy also argued that the property of object identities is of too low level\nand implementation oriented. This is true to some extent and the use of references\ndoes cause some side-effects, making the semantics a bit more difficult. A preliminary\nversion of the model without references can be found in [15]. However, that version is\nonly slight simpler than this version. On the other hand, the complexity in fact mainly\naffects reasoning about low level design and implementation. At high level requirement\nanalysis and design, we can simply use the identities as the objects they refer to or just\ntalk about objects in an abstract way. In our approach for analysis of use cases [25],\nwe mainly describe the change of system states in terms of what objects are created or\ndeleted, what modifications are made to an object and what links between objects are\nformed or broken. We think that features like method overriding and attribute hiding\nare only useful to program around the requirement and design defects detected at the\ncoding stage or even after, or when one tries to reuse a class with a similar template in\na program that the class was not originally designed. These features cause problems in\nprogram verification and the smooth application of the notion of program refinements.\nFuture work includes the study of the issue of completeness of the refinement cal-\nculus, applications to more realistic case studies, and formal treatment of patterns [14].\nReferences\n1. M. Abadi and L. Cardeli. A Theory of Objects. Springer-Verlag, 1996.\n2. M. Abadi and R. Leino. A logic of object-oriented programs. In M. Bidoit and M. Dauchet,\neditors, TAPSOFT \u201997: Theory and Practice of Software Development, 7th International\nJoint Conference, pages 682\u2013696. Springer-Verlag, 1997.\n3. E. Abraham-Mumm, F.S. de Boer, W.P. de Roever, and M. Steffen. Verification for Java\u2019s\nreentrant multithreading concept. In Foundations of Software Science and Computation\nStructures, LNCS 2303, pages 5\u201320. Springer, 2002.\n4. P. America. Designing an object-oriented programming language with behavioural subtyp-\ning. In J. W. de Bakker, illem P. de Roever, and G. Rozenberg, editors, REX Workshop,\nvolume 489 of Lecture Notes in Computer Science, pages 60\u201390. Springer, 1991.\n5. P. America and F. de Boer. Reasoning about dynamically evolving process structures. Formal\nAspects of Computing, 6(3):269\u2013316, 1994.\n6. M.M. Bonsangue, J.N. Kok, and K. Sere. An approach to object-orientation in action sys-\ntems. In J. Jeuring, editor, Mathematics of Program Construction, LNCS 1422, pages 68\u201395.\nSpringer, 1998.\n7. M. Broy. Object-oriented programming and software development - a critical assessment. In\nA. McIver and C. Morgan, editors, Programming Methodology. Springer, 2003.\n8. D. Carrington, et al. Object-Z: an Object-Oriented Extension to Z. North-Halland, 1989.\n9. A. Cavalcanti and D. Naumann. A weakest precondition semantics for an object-oriented\nlanguage of refinement. In LNCS 1709, pages 1439\u20131460. Springer, 1999.\n10. D. Coleman, et al. Object-Oriented Development: the FUSION Method. Prentice-Hall, 1994.\n11. S. Cook and J. Daniels. Designing Object Systems: Object-Oriented Modelling with Syn-\ntropy. Prentice-Hall, 1994.\n12. E. Du\u00a8rr and E.M. Dusink. The role of A fl \u0013 \u0000\u0001\u0000 in the development of a real-time tracking\nand tracing system. In J. Woodcock and P. Larsen, editors, Proc. of FME\u201993, LNCS 670.\nSpringer-Verlag, 1993.\n13. M. Fowler, K. Beck, J. Brant, W. Opdyke, and D. Roberts. Refactoring: Improving the\nDesign of Existing Code. Addison-Wesley, 1999.\n14. E. Gamma, et al. Design Patterns. Addison-Wesley, 1995.\n15. J. He, Z. Liu, and X. Li. Towards a refinement calculus for object-oriented systems (invited\ntalk). In Proc. ICCI02, Alberta, Canada. IEEE Computer Society, 2002.\n16. J. He, Z. Liu, and X. Li. A component calculus. In H.D. Van and Z. Liu, editors, Proc. Of\nFME03 Workshop on Formal Aspects of Component Software (FACS03), UNU\/IIST Techni-\ncal Report 284, UNU\/IIST, P.O. Box 3058, Macao, Pisa, Italy, 2003.\n17. J. He, Z Liu, and X. Li. Contract-oriented component software development. Technical\nReport 276, UNU\/IIST, P.O. Box 3058, Macao SAR China, 2003.\n18. C.A.R. Hoare and J. He. Unifying Theories of Programming. Prentice-Hall, 1998.\n19. I. Houston. Formal specification of the OMG core object model. Technical report, IMB, UK,\nHursely Park, 1994.\n20. M. Huisman and B. Jacobs. Java program verification via a Hoare logic with abrupt termi-\nnation. In T. Maibaum, editor, FASE 2000, LNCS 1783, pages 284\u2013303. Springer, 2000.\n21. K. Lano and H. Haughton. Object-oriented specification case studies. Prentice Hall, New\nYork, 1994.\n22. C. Larman. Applying UML and Patterns. Prentice-Hall International, 2001.\n23. K. Rustan M. Leino. Recursive object types in a logic of object-oriented programming. In\nLNCS 1381. Springer, 1998.\n24. Z. Liu. Object-oriented software development in UML. Technical Report UNU\/IIST Report\nNo. 228, UNU\/IIST, P.O. Box 3058, Macau, SAR, P.R. China, March 2001.\n25. Z. Liu, J. He, X. Li, and Y. Chen. A relational model for formal requirements analysis in\nUML. In J.S. Dong and J. Woodcock, editors, Formal Methods and Software Engineering,\nICFEM03, LNCS 2885, pages 641\u2013664. Springer, 2003.\n26. Z. Liu, J. He, X. Li, and J. Liu. Unifying views of UML. Research Report 288, UNU\/IIST,\nP.O. Box 3058, Macao, 2003. Presented at UML03 Workshop on Compostional Verification\nof UML and submitted for the inclusion in the final proceedings.\n27. B. Meyer. From structured programming to object-oriented design: the road to Eiffel. Struc-\ntured Programming, 10(1):19\u201339, 1989.\n28. A. Mikhajlova and E. Sekerinski. Class refinement and interface refinement in object-orient\nprograms. In Proc of FME\u201997, LNCS. Springer, 1997.\n29. D. Naumann. Predicate transformer semantics of an Oberon-like language. In E.-R. Olerog,\neditor, Proc. of PROCOMET\u201994. North-Holland, 1994.\n30. C. Pierik and F.S. de Boer. A syntax-directed hoare logic for object-oriented programming\nconcepts. Technical Report UU-CS-2003-010, Institute of Information and Computing Sci-\nence, Utrecht University, 2003.\n31. A. Poetzsch-Heffter and P. Muller. A programming logic for sequential Java. In S.D. Swier-\nstra, editor, Proc. Programming Languages and Systems (ESOP\u201999), LNCS 1576, pages 162\u2013\n176. Springer, 1999.\n32. S. Qin, J.S. Dong, and W.N. Chin. A semantics foundation for TCOZ in Unifying Theories of\nProgramming. In K. Araki, S. Gnesi, and D. Mandrioli, editors, FME 2003: Formal Methods,\nLNCS 2805, pages 321\u2013340. Springer, 2003.\n33. E. Sekerinski. A type-theoretical basis for an object-oriented refinement calculus. In Proc.\nof Formal Methods and Object Technology. Springer-Verlag, 1996.\n34. A. Sherif and J. He. Towards a time model for Circus. In ICFEM02, LNCS 2495. Springer,\n2002.\n35. D. von Oheimb. Hoare logic for Java in Isabelle\/HOL. Concurrency and Computation:\nPractice and Experience, 13(13):1173\u20131214, 2001.\n36. J.C.P. Woodcock and A.L.C. Cavalcanti. A semantics of Circus. In ZB 2002, LNCS 2272.\nSpringer, 2002.\n"}