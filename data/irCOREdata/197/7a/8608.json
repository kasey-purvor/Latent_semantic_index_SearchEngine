{"doi":"10.1007\/b95854","coreId":"8608","oai":"oai:eprints.brighton.ac.uk:1028","identifiers":["oai:eprints.brighton.ac.uk:1028","10.1007\/b95854"],"title":"Automatic proofs for scalecharts","authors":["Bosworth, R."],"enrichments":{"references":[{"id":42752962,"title":"Clocks and the Ordering of Events in a Distributed System.","authors":[],"date":"1978","doi":"10.1145\/359545.359563","raw":"Lamport, L.: Time, Clocks and the Ordering of Events in a Distributed System. Comm.A.C.M. 21 (1978) 558-565","cites":null},{"id":42752960,"title":"Scalecharts - Self-similar Statecharts in a Dense Time Domain. To be published","authors":[],"date":"2004","doi":null,"raw":"Bosworth, R.: Scalecharts - Self-similar Statecharts in a Dense Time Domain. To be published in Software and Systems Modelling. Springer-Verlag, Berlin Heidelberg New York (2004)","cites":null},{"id":42752963,"title":"Semantics of Parallelism.","authors":[],"date":"1997","doi":"10.1007\/978-1-4471-0933-4","raw":"Shields, M.W.: Semantics of Parallelism. Springer-Verlag, Berlin Heidelberg New York (1997)","cites":null},{"id":42752961,"title":"Statecharts: a Visual Formalism for Complex Systems.","authors":[],"date":"1987","doi":"10.1016\/0167-6423(87)90035-9","raw":"Harel, D.: Statecharts: a Visual Formalism for Complex Systems. Science of Computer Programming 8 (1987) 231-274","cites":null}],"documentType":{"type":1}},"contributors":["Blackwell, Alan","Marriott, Kim","Shimojima, Atsushi"],"datePublished":"2004","abstract":null,"downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":"Springer-Verlag","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.brighton.ac.uk:1028<\/identifier><datestamp>\n      2014-05-21T11:01:05Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D47303030:47313030<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/eprints.brighton.ac.uk\/1028\/<\/dc:relation><dc:title>\n        Automatic proofs for scalecharts<\/dc:title><dc:creator>\n        Bosworth, R.<\/dc:creator><dc:subject>\n        G100 Mathematics<\/dc:subject><dc:publisher>\n        Springer-Verlag<\/dc:publisher><dc:contributor>\n        Blackwell, Alan<\/dc:contributor><dc:contributor>\n        Marriott, Kim<\/dc:contributor><dc:contributor>\n        Shimojima, Atsushi<\/dc:contributor><dc:date>\n        2004<\/dc:date><dc:type>\n        Contribution to conference proceedings in the public domain<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:rights>\n        <\/dc:rights><dc:identifier>\n        http:\/\/eprints.brighton.ac.uk\/1028\/1\/D2k4RB.pdf<\/dc:identifier><dc:identifier>\n          Bosworth, R.  (2004) Automatic proofs for scalecharts  In: Proceedings of the third international conference, diagrams 2004, Cambridge, UK, 22-24 March, 2002.     <\/dc:identifier><dc:relation>\n        http:\/\/link.springer.com\/chapter\/10.1007\/978-3-540-25931-2_21<\/dc:relation><dc:relation>\n        10.1007\/b95854<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/eprints.brighton.ac.uk\/1028\/","http:\/\/link.springer.com\/chapter\/10.1007\/978-3-540-25931-2_21","10.1007\/b95854"],"year":2004,"topics":["G100 Mathematics"],"subject":["Contribution to conference proceedings in the public domain","NonPeerReviewed"],"fullText":"Automatic Proofs for Scalecharts\nRichard Bosworth\nVisual Modelling Group,\nUniversity of Brighton, UK\nrichard.bosworth@bton.ac.uk\nAbstract. A scalechart is a set of statecharts, operating in a dense time\ndomain, whose behavior is self-similar at different scales. The simplicity\nof extracting proofs of behavior from scalecharts is demonstrated, based\non the < and co relationships. An algorithm is presented which automat-\nically extracts < relationships from a simplified version of scalecharts.\n1 Introduction\nA scalechart [1] is a set of Harel-style statecharts [2] that operate in a dense\n(ever-divisible) time domain. Structurally each statechart of the set consists of a\nset of nodes and a set of transitions between those nodes, which form the vertices\nand arcs respectively of a directed graph. Each statechart has a distinguished\nstart node. A node contains one or more orthogonal components or orthocomps,\neach of which may contain a statechart, forming a self-similar structure in space.\nScalecharts are also self-similar in time. There are no generated events as-\nsociated with transitions in scalecharts; rather, generated signals are associated\nwith nodes. Unlike events, signals have an extended duration in time.\nAsignal d, k\n\/a\nr\n?\nD\n\/d\nF\n\/f\n?\nE k\nB r\n?\nG\n\/g\nI\nK\n\/k\nA\nA\nAU\nH d\n\ufb00\nJ\nd\n\u0001\n\u0001\n\u0001\u0015\nL f\nC\nFig. 1. Signalling inside a compound scalechart node\nFor example, in Fig. 1, the state D has a signal d associated with it. d remains\nasserted as long as D is active. D can only become inactive when transition E\nfires. E can only fire when signal k is asserted.\nNow suppose the scalechart of Fig. 1 is instantiated at time t0. Then ac-\ncording to the semantics in [1], we can guarantee that at some time t1 > t0\nthe top-level scalechart will be in state A, orthocomp B will be in state D, and\northocomp C will be in state G. Because G has an enabled out-transition H,\nit is possible for C to transit to state I and similarly to state K, in which k is\nasserted, allowing B to transit to state F , which in turn allows C to transit back\nto state G.\nUsing the < relation to mean \u201chappened before\u201d (as in [3]) and the co relation\nto mean \u201chappens concurrently with\u201d (as in [4]), and using the convention of\nexpressing occurrence o of signal s as so, we can express this situation as\ng1 < k1 < g2 \u2227 d1 < f1\ng1 co d1 \u2227 d1 co k1\nk1 co f1 \u2227 f1 co g2\nNote that some of the inequalities are independent of the signal-occurrences, for\nexample, within the orthocomp B it is clear that d1 < f1, and within orthocomp\nc we can say that g1 < k1 < g2, and in general gi < ki < gi+1 for all i > 0 .\n2 An Extraction Algorithm for Inequalities\nWe assume that all nodes have a signal expression consisting of one signal. We\nalso ignore input signals completely. This means that a transition is enabled\nwhenever its from-state is active.\nThe extraction algorithm works as follows: we first build the underlying di-\nrected graph from the statechart we are analyzing. We then identify the cycles1\nand parallel trails2 of this graph.\nOnce we have discovered the cycles and parallel paths, it is a simple matter\nto mark nodes which are internal to parallel paths, nodes which are members of\na cycle and nodes which are start\/end nodes of a cycle. Once these nodes are\nidentified, it is possible to generate the inequalities.\nWe can discover all the parallel trails and cycles of a rooted directed graph by\ngrowing all the possible trails from the root. We start with the trail consisting of\nthe root vertex only (this is a trivial trail). We then add each outgoing arc from\nthe root and its to-vertex, to form a new trail. We can continue this process with\nthe end-vertex of each new trail, until we cannot find an outgoing arc that we can\nadd, without breaking the rule that a trail does not have duplicate arcs. As the\ndirected graph has a finite number of arcs, this process is bound to terminate.\n1 a cycle is a circuit of the graph which contains no other circuit\n2 a trail is a walk through the graph which contains no repeated arcs, though it may\ncontain repeated nodes\nFinding the cycles We grow all the trails we can, starting from the root. When\na trail grows to a vertex it has seen before, it contains a cycle. We therefore mark\nthis trail as mature, and stop it growing any more. We continue this way until all\nour trails have stopped growing (either because they have matured, or because\nthey have run out of arcs). Then we extract the cycle from each mature trail.\nFinding the parallel trails We define two trails as being parallel if:\n\u2013 they are both non-trivial\n\u2013 they have the same start vertex and the same end vertex\n\u2013 they have no other shared arc or vertex\n\u2013 they do not contain any circuits at their start or end vertices (unless the start\nand end vertices are identical). They may contain circuits at other vertices.\nWe grow all possible trials from the root as before. When we find two distinct\ntrails which share an end vertex, we have two candidate parallel trails. Because\nwe are allowing cycles in trails, we cannot assume that our two candidates are\ngenuinely parallel: both, one or neither of the trails may have a cycle on its end\nvertex. We discard any pair where only one trail has a cycle on its end vertex.\nWe now remove the common initial sub-trail of the two trails (this may\nbe null), giving two non-trivial trails with the same start vertex and the same\nend vertex. Then we reject any pairs which have common internal nodes or\ntransitions. Finally, for trails with distinct start and end vertices, we check that\nthere are no cycles on the start vertex or the end vertex of our pair.\n3 Conclusions\nWe would like to extend the algorithm informally presented here to include\ntransitions with signal labels and guards. Nevertheless the current algorithm\nshows that it is possible to extract proofs semi-automatically from scalecharts.\nIt is my intention to incorporate this work into a scalechart drawing tool, which\nwould check out designs as they are drawn, and correct errors \u201con the fly\u201d.\nAcknowledgements My indebtedness to Harel, Shields and Lamport is clear\nfrom the text. I wish to thank Jean Flower, John Howse and Gem Stapleton for\ncrucial help in rescuing this paper from its initial vague and error-laden state.\nReferences\n1. Bosworth, R.: Scalecharts - Self-similar Statecharts in a Dense Time Domain. To be\npublished in Software and Systems Modelling. Springer-Verlag, Berlin Heidelberg\nNew York (2004)\n2. Harel, D.: Statecharts: a Visual Formalism for Complex Systems. Science of Com-\nputer Programming 8 (1987) 231-274\n3. Lamport, L.: Time, Clocks and the Ordering of Events in a Distributed System.\nComm.A.C.M. 21 (1978) 558-565\n4. Shields, M.W.: Semantics of Parallelism. Springer-Verlag, Berlin Heidelberg New\nYork (1997)\n"}