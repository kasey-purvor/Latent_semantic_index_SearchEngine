{"doi":"10.1109\/TSE.2008.28","coreId":"102516","oai":"oai:epubs.surrey.ac.uk:1978","identifiers":["oai:epubs.surrey.ac.uk:1978","10.1109\/TSE.2008.28"],"title":"Characterizing Communication Channel Deadlocks in Sequence Diagrams","authors":["Mitchell, Bill"],"enrichments":{"references":[],"documentType":{"type":0.7777777778}},"contributors":[],"datePublished":"2008-05-01","abstract":"<p>UML sequence diagrams (SDs) are a mainstay of requirements specifications for communication protocols. Mauw and Reniers' algebraic (MRA) semantics formally specifies a behaviour for these SDs that guarantees deadlock free processes. Practitioners commonly use communication semantics that differ from MRA, which may result in deadlocks. For example FIFO, token ring, etc. We define a process algebra that is an extension of the MRA semantics for regular sequence diagrams. Our algebra can describe several commonly used communication semantics. Regular SDs are constructed from concurrent message flows via iteration, branching, and sequential composition. Their behaviour is defined in terms of a set of partial orders on the events in the SD. Such partial orders are known as causal orders. We define partial order theoretic properties of a causal order that are particular kinds of race condition. We prove any of the common communication semantics we list either guarantees deadlock free SDs or can result in a deadlock if and only if a causal order of an SD contains one of these types of race condition. This describes a complete classification of deadlocks as specific types of race condition.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1978<\/identifier><datestamp>\n      2017-10-31T14:03:53Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1978\/<\/dc:relation><dc:title>\n        Characterizing Communication Channel Deadlocks in Sequence Diagrams<\/dc:title><dc:creator>\n        Mitchell, Bill<\/dc:creator><dc:description>\n        <p>UML sequence diagrams (SDs) are a mainstay of requirements specifications for communication protocols. Mauw and Reniers' algebraic (MRA) semantics formally specifies a behaviour for these SDs that guarantees deadlock free processes. Practitioners commonly use communication semantics that differ from MRA, which may result in deadlocks. For example FIFO, token ring, etc. We define a process algebra that is an extension of the MRA semantics for regular sequence diagrams. Our algebra can describe several commonly used communication semantics. Regular SDs are constructed from concurrent message flows via iteration, branching, and sequential composition. Their behaviour is defined in terms of a set of partial orders on the events in the SD. Such partial orders are known as causal orders. We define partial order theoretic properties of a causal order that are particular kinds of race condition. We prove any of the common communication semantics we list either guarantees deadlock free SDs or can result in a deadlock if and only if a causal order of an SD contains one of these types of race condition. This describes a complete classification of deadlocks as specific types of race condition.<\/p><\/dc:description><dc:date>\n        2008-05-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1978\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Mitchell, Bill  (2008) Characterizing Communication Channel Deadlocks in Sequence Diagrams   IEEE Transactions on Software Engineering, 34 (3).  pp. 305-320.      <\/dc:identifier><dc:relation>\n        10.1109\/TSE.2008.28<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1978\/","10.1109\/TSE.2008.28"],"year":2008,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"Characterizing Communication Channel\nDeadlocks in Sequence Diagrams\nBill Mitchell\nAbstract\u2014UML sequence diagrams (SDs) are a mainstay of requirements specifications for communication protocols. Mauw and\nReniers\u2019 algebraic (MRA) semantics formally specifies a behavior for these SDs that guarantees deadlock-free processes.\nPractitioners commonly use communication semantics that differ from MRA, which may result in deadlocks, for example, FIFO, token\nring, etc. We define a process algebra that is an extension of the MRA semantics for regular SDs. Our algebra can describe several\ncommonly used communication semantics. Regular SDs are constructed from concurrent message flows via iteration, branching, and\nsequential composition. Their behavior is defined in terms of a set of partial orders on the events in the SD. Such partial orders are\nknown as causal orders. We define partial order theoretic properties of a causal order that are particular kinds of race condition. We\nprove that any of the common communication semantics that we list either guarantees deadlock-free SDs or can result in a deadlock if\nand only if a causal order of an SD contains one of these types of race condition. This describes a complete classification of deadlocks\nas specific types of race condition.\nIndex Terms\u2014Requirements analysis, formal methods, distributed programming.\n\u00c7\n1 INTRODUCTION\nSCENARIO-BASED graphical languages such as messagesequence charts (MSCs) [39] and UML sequence\ndiagrams (SDs) [28] are popular for defining requirements\nspecifications. For example, in the automotive industry, the\ndynamic behavior for the new Media Oriented Systems\nTransport (MOST) standard has been defined using MSCs\n[38]. This is a standard agreed upon among 17 automotive\nmanufacturers, including BMW, DaimlerChrysler, and\nJaguar, as well as 60 consumer electronic manufacturers,\nincluding Siemens, Philips, and Pioneer.\nOne reason for the popularity of sequence diagrams is\nthat practitioners find them more intuitive and \u201ceasier\u201d to\nunderstand than state machines [34]. This popularity has\nled to the development of verification and test automation\ntools, such as those in [6], that can work directly with MSCs\nand SDs. Such tools then reinforce the use of scenario-based\nspecifications.\nMSC is the precursor to SD and was first standardized by\nthe International Telecommunications Union (ITU) in 1992.\nMSC-96 was given a formal behavioral algebraic semantics\nby Mauw and Reniers in [23], [24], which we refer to as the\nMauw and Reniers\u2019 algebraic (MRA) semantics. MSC and\nSD are now mandated by the European Telecommunica-\ntions Standards Institute (ETSI) for use in the process of\nmaking protocol standards [12], [13].\nFrom case studies at Motorola and DaimlerChrsyler\n[5], we found that practitioners frequently do not use the\nMRA semantics. Often, they use particular semantics for\ncommunication channels between processes and message\nconsumption for input buffers. We found that there were\na handful of different communication channel semantics\nthat form the majority of these alternative semantics,\nwhich will be the focus of this paper. Roughly, these\nbreak down into the following categories. Message\npassing semantics were almost always one of the follow-\ning: asynchronous, synchronous, FIFO, or token ring. Most\nmessage consumption semantics for input buffers were\none of what we termed \u201ceager\u201d or \u201clazy.\u201d For example,\nthe MOST specification uses token ring semantics with\n\u201ceager\u201d input buffers rather than the MRA semantics.\nThe MRA semantics is constructed so that scenario\nprocesses do not deadlock. Processes are guaranteed to\ncoordinate correctly according to the specification. How-\never, for the everyday types of semantics we consider here\nit can well be the case that deadlocks do occur. The\nfundamental question that we address is: What type of\nbehavior can now occur as a consequence of such\ncommunication channel semantics that leads to a sequence\ndiagram deadlock?\n1.1 Main Results\nWe first define an operational semantic framework for the\nvarious communication semantics that we consider (Sec-\ntion 3), which extends the MRA semantics for partial order\nscenarios. Such scenarios (defined in Section 2) characterize\nbehavioral semantics as a partial order on the events in the\nscenario. This partial order is known as the causal order for\nthe scenario. These scenarios allow concurrent threads of\nactivity via parallel constructs, but do not include iteration\nor branching behavior.\nOnce we establish our results for partial order scenarios,\nwe extend them to regular sequence diagrams in Section 4.\nA regular sequence diagram is constructed from a set of\npartial order scenarios via sequential composition, iteration,\nIEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008 305\n. The author is with the Department of Computing, University of Surrey,\nGuildford, Surrey GU2 7XH, UK. E-mail: w.mitchell@surrey.ac.uk.\nManuscript received 15 Feb. 2007; revised 3 Oct. 2007; accepted 7 Feb. 2008;\npublished online 22 Apr. 2008.\nRecommended for acceptance by S. Uchitel.\nFor information on obtaining reprints of this article, please send e-mail to:\ntse@computer.org, and reference IEEECS Log Number TSE-0046-0207.\nDigital Object Identifier no. 10.1109\/TSE.2008.28.\n0098-5589\/08\/$25.00 \u0002 2008 IEEE Published by the IEEE Computer Society\nand branching. For brevity, we often refer to a partial order\nscenario as simply a scenario when this will not cause\nconfusion.\nIn Section 3, we define a concurrent composition\noperator kU for each of the communication semantics U in\nwhich we are interested. Essentially, this defines an abstract\nrepresentation of the various communication semantics that\nwe found were common in the case studies which were\nmentioned above.\nWe define the purely partial order theoretic properties of\na causal order that we call chase and sprint conditions.\nThese are a refinement of the partial order characterization\nof race condition discussed in [25]. In this paper, we prove a\nseries of Propositions (3.5, 3.6, 3.12, 3.16, and 3.18) that\ncharacterize which deadlocks are permitted by the various\ncommunication channel semantics U . These results prove\nthat a deadlock occurs between partial order scenario\nprocesses if and only if the causal order contains either\nchase or sprint conditions. When this occurs, we say that the\nscenario has a chase or sprint condition.\nIn Definition 4.5, we formally define the notion of a partial\norder scenario being included in a regular sequence diagram.\nIntuitively, this defines when a scenario describes a specific\nset of choices for all of the branch points in a sequence\ndiagram up to some particular point. We say a sequence\ndiagram includes a chase or sprint condition if the diagram\nincludes a scenario that has a chase or sprint condition.\nProposition4.6proves that adeadlockoccurs ina sequence\ndiagram if and only if it includes a partial order scenario that\ndeadlocks. An immediate corollary is that the only cause of a\ndeadlock in a regular sequence diagram is a chase or sprint\ncondition in one of the underpinning causal orders. That is, a\ndeadlock occurs in a regular sequencediagram if andonly if it\nincludes a chase or sprint condition.\nHence, for the common types of communication seman-\ntics that we consider, deadlocks are uniquely determined\nby the partial order theoretic properties of the under-\npinning causal orders. Further, we can say that different\ntypes of race conditions in those causal orders completely\ndetermine which deadlocks result from communication\nchannel behavior.\nThe results reported here grew out of case studies with\nMotorola and DaimlerChrsyler. They led to a prototype SD\nanalysis tool MINT reported in [5], which found errors in\napproximately one out of five sequence diagrams in an\nearly draft version of MOST.\n1.2 Related Work\nReferences [4], [35] contain good surveys of work related to\nscenario-based reasoning. There are many issues relevant to\nthe verification of protocols expressed as UML\/MSC\ndiagrams that have been studied. References [1], [15], [31],\namong others, have considered the verification of logical\nproperties for languages defined by MSCs and MSC-\nGraphs. References [9], [10], [21], [20], [27], [31] consider\nvarious different compositional semantics for MSCs in\norder to construct state machines from MSCs and MSC-\nGraphs. Other work has considered how to interpolate\nmissing requirements from scenario-based specifications\n[2], [3], [7], [22], [35]. This work is useful both in verifying a\nsystem and in synthesizing a more complete specification.\nReference [36] describes a different approach to synthesis\nwhere safety properties are used to determine how\nscenarios are combined into Modal Transition Systems.\nReference [3] is the seminal work that first considered the\nrealizability of collections of MSCs.\nResearch into automatic test generation from partial\norder scenarios is an active research area [6], [8], [11], [29].\nAmong others, Rountev and Connell [30] consider how to\nreverse engineer a set of scenarios from source code that can\nthen be used for test purposes in an automated test\nexecution environment. Ben-Abdhallah and Leue [7] have\nresearched error detection in MSCs that are due to\nconcurrent aspects of the scenarios, which are caused by a\nlack of coordination between processes.\nThe seminal paper to consider race conditions in MSCs\nwas [16]. The authors characterize the idea of a race condition\nas a disparity between the causal order on events and an\nimplementation ordering of events. References [25], [26]\nconsidered issues surrounding ambiguous scenarios. They\nproved that, when resolving race conditions by altering\nmessage flows, there exists a uniqueminimal extension of the\noriginal scenario that removes all race conditions.\nLive sequence charts (LSCs) [17] are a variation on\nmainstream MSC\/UML scenarios. It is possible to synthe-\nsize state machines from LSCs [18], [19], [32], [33], just as\nwith sequence diagrams and MSCs. One of the aims for\nLSCs has been to allow greater expressitivity, for example,\nby permitting exemplary and mandatory behavior to be\nannotated directly within a scenario. At present, LSCs do\nnot have the same following in industry as they have in\nacademia. Also, as mentioned above, MSC\/UML SDs are\nused by a variety of international standards bodies, whereas\nLSCs have not yet gained that level of institutional support.\n1.3 Graphical Notation\nIn this paper, wewill useUML SDs as the graphical language\nfordescribingpartial order scenarios.Wewill assume that the\nreader is broadly familiar with the basic concepts of UML\nSDs. In this section,webrieflydescribe the semantics for those\naspects of SDs that we use in this paper.\nConsider the SD depicted graphically in Fig. 3. Each\nvertical line describes the timeline for a process where time\nincreases down the page. Messages are depicted by arrows.\nEach message m defines a pair of events \u00f0!m; ?m\u00de, where !m\nis the send event for m and ?m is the receive event for m.\nThe distance between two events on a timeline does not\nrepresent any literal measurement of time, only that\nnonzero time has passed. Events on the same timeline are\nordered linearly down the page, except where they occur\nwithin a coregion or distinct threads of a parallel construct.\nWithin a coregion, events are not locally ordered. Each\ncoregion can only occur on a single timeline. It is depicted\nby a short dashed line delineated by short horizontal lines.\nA parallel construct in an SD, denoted by keyword PAR,\ndescribes a set of interleaving threads that occur in the\ndiagram. Horizontal dotted lines delineate the different\nthreads. Hence, events from one thread are not causally\nordered with respect to events from any other thread. Fig. 3\ncontains a parallel construct split into three threads. The\nbounding box of a parallel construct has no effect on the\nordering of events; it solely delineates the scope of the\n306 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\nconcurrent threads. Events within a particular thread are\nordered in the usual way. Branching in a sequence diagram\nis represented by the ALT construct. Fig. 3 contains an ALT\nconstruct with two possible choices within it. There may be\nany number of choices within an ALT and they are mutually\nexclusive. Iteration is given by the loop construct. This has\ninline-sequential compositional semantics. A loop iterates\nany finite number of times before terminating. Often, a\nsystem is described as a set of SDs. We can always regard\nsuch a set as equivalent to a single SD by using the ALT\nconstruct to combine all of the diagrams in the given set.\nThe UML notation also allows a message to be split into\nlost and found events. This allows a message to be sent in\none scenario and to be received in another. The send part of\nthe message is represented by a lost event and the receive\npart by a found event. Fig. 3 contains two lost messages l0\nand l1. The OMG semantics for lost and found messages\ndoes not make any connection between a lost message and\nits corresponding found message. We regard a lost message\nas syntactic sugar for a complete message to a special Null\nprocess and vice versa for found messages. The Null\nprocess has the empty causal ordering. This does not alter\nmessage flows with regard to deadlocks and is therefore a\nharmless convention from our viewpoint.\n2 PARTIAL ORDER SCENARIOS\nIn this section, we define the causal order for a partial order\nscenario and its associated semantics. We use the same\nmessage semantics as the MSC 2000 standard [39]. Hence,\nwithin this section, a partial order scenario defines a set of\nmessage exchanges between processes with asynchronous\ncommunication channels.\nDefinition 2.1.\n. A partial order over a set E is a binary relation < such\nthat\n< is irreflexive, i.e., there is no x 2 E where x < x,\n< is transitive, i.e., if x < y and y < z, then x < z,\nand\n< is asymmetric, i.e., there are no elements x; y 2 E\nsuch that x < y and y < x.\n. A total order over the set E is a partial order on E\nwhere, for any two distinct elements a and b, either\na < b or b < a.\n. For x; y 2 E, when it is not the case that x < y, we\nwrite :\u00f0x < y\u00de.\n. Two elements x and y of E are unordered if :\u00f0x < y\u00de\nand :\u00f0y < x\u00de.\nWe define a set to be unordered if every pair of distinct\nelements from that set are unordered.\nLet P be a set of processes. A message m between\nprocesses is a pair \u00f0!m; ?m\u00dewhere !m is the send event form\nand ?m is the receive event form. Let E be the set of all send\nand receive events between all processes.\nDefinition 2.2. A partial order scenario Sc on processes P is\n. a collection of disjoint sets E\u00f0P \u00de \u0002 E, for each P 2 P,\nand\n. a set of partial orders <P where <P is a partial order\non E\u00f0P \u00de and is referred to as the process order for P\nsubject to the constraint that, for each send event !m in a\nset E\u00f0P \u00de, the corresponding receive event ?m occurs in some\nset E\u00f0Q\u00de. Note that it is possible for P \u00bc Q.\nWe treat a partial order as a binary relation that can be\nrepresented as the set of pairs that are ordered by the\nrelation. Hence, we can take the union of partial orders,\nwhich is just the set theoretic union of the sets of pairs given\nby the relevant order relations. Next, we define the causal\nordering that represents the behavioral semantics for a\npartial order scenario.\nDefinition 2.3. The causal ordering <C on a partial order\nscenario Sc is the transitive closure of the relation given by[\nP2P\u00f0<P \u00de [\nf\u00f0!e; ?e\u00de j !e 2 E\u00f0P \u00de and ?e 2 E\u00f0Q\u00de for some P;Q 2 Pg:\nThe set of pairs \u00f0!e; ?e\u00de is used to assert that orderings\nbetween processes can only be a consequence of message\nexchanges. Hence, the causal ordering combines process\norderings solely through the causality between send and\nreceive event pairs.\nNote that it is possible that there can be two events x and\ny, both in the same process P , where x <C y but :\u00f0x <P y\u00de.\nWithout loss of generality, we will assume that this is not\nthe case from now on. That is, when x; y 2 E\u00f0P \u00de, we assume\nthat x <C y if and only if x <P y. This is acceptable since the\ncausal semantics will only allow events to be ordered as\ndefined by x <C y. We can therefore modify <P to include\nany additional orderings x <C y, where x <C y but\n:\u00f0x <P y\u00de. If we do not adopt this convention, the notation\nbecomes irksome without giving us any additional benefits.\nHence, if we are given a causal ordering, it will be\nstraightforward to extract the process orderings from it.\nThe following definition describes the global system\nbehavior of a partial order scenario that is meant to occur\nwith respect to the causal order. We will refer to this\nbehavior as the causal behavior or causal semantics,\ndepending on the context in which we refer to it.\nDefinition 2.4. For a causal ordering<C , a causal systemtrace is a\ntotal order extension of <C . For a process P 2 P with process\norder <P , a trace of P is a total order extension of <P .\nThus, the causal order defines which events must be\nordered with respect to each other in each system trace\nand which events must be independent of each other over\nthe set of all system traces. The causal order does not take\ninto account whether it is possible for processes to act in\nconcert to ensure that the causal order is preserved during\nexecution. As we shall see, it is quite possible for execution\ntraces to differ from those specified by the causal order.\n2.1 Chase and Sprint Conditions\nIn this section, we define the concept of chase and race\ncondition in a partial order scenario Sc. We also motivate\nthe definition with various examples that illustrate different\nways in which chase and race conditions may cause\ncoordination errors between processes. Chase conditions\nMITCHELL: CHARACTERIZING COMMUNICATION CHANNEL DEADLOCKS IN SEQUENCE DIAGRAMS 307\nare a refinement of race conditions, as discussed in [16] and\n[25] among others.\nDefinition 2.5. Let Sc be a partial order scenario with causal\nordering <C and events x, ?e 2 E. Let !\u00bdx\u0003 \u00bc !h if x is either\n!h or ?h for some h. A chase exists between x and ?e when\n\u00f0x <C ?e\u00de and :\u00f0!\u00bdx\u0003 <C !e\u00de:\nA race exists between x and ?e when\n\u00f0x <C ?e\u00de and :\u00f0x <C !e\u00de:\nScenarioSc is race free if andonly if, for everypair of eventsx,?e,\n\u00f0x <C ?e\u00de ) \u00f0x <C !e\u00de:\nDenote the race property by r\u00f0x; ?e; <C\u00de and the chase\nproperty by \u0002\u00f0x; ?e; <C\u00de. Notice that \u0002\u00f0x; ?e; <C\u00de )\nr\u00f0x; ?e; <C\u00de so that chase is a stronger condition than race.\nWe use the term sprint condition to refer to a pair of events x,\n?e that form a race condition and not a chase condition.\nThis definition has refined the notion of race condition into\nchase and sprint conditions. Below, we will look at some\nexamples of how these occur in case studies.\nIn Fig. 1, there is a chase between !b and ?c. There is also\na sprint between ?a and ?c (which is therefore not a chase).\nThis is an interesting example since ?a and !b are events on\nthe same lifeline, with ?a preceding !b, and yet they cause\ndifferent race conditions.\nFig. 2 shows an example specification taken from a\nMotorola case study of a telecommunications system used\nin North America. This has been anonymized to remove all\npropriety information. Since this scenario specifies system\nbehavior, the causal system tracesdefinedby this scenario are\na subset of the legitimate traces of the system. We will\nsuppose that the processes have reached a particular\nconfiguration at the start of the scenario (which, in the\noriginal scenario, is described with textual comments) and\nthat the scenario describes how the processes then proceed to\nreach thenextdesiredconfiguration at the endof the scenario.\nConsider events ?mi and ?mk, which are specified by this\nexample to arrive at process E in the order ?mi <C ?mk. If\ncommunication channels between C,D, andE are asynchro-\nnous, which is perfectly possible for a telecommunications\nsystem, it is not possible to ensure that ?mi will occur before\n?mk in practice because there is no coordination between C,\nD, and E to force this to happen. Hence, latency may cause\n?mi to be delayed so that it is received after ?mk, even though\n!mi is correctly sent before !mk. However, if there is only a\nsingle FIFO input channel to E, then we can guarantee that\n?mi will occur before ?mk in practice. As a second example,\nconsider !mk and ?mm. This is a worse situation since, no\nmatter what latency assumptions we make, it will always\nbe possible for G to transmit !mm too early so that it arrives\nbefore !mk has occurred. This can occur since there are no\nmessages between D and G which occur after !mk and\nbefore !mm that could force the necessary coordination to\noccur.\nIn Fig. 2, we can see race conditions between the\nfollowing pairs of events:\n. Sprints: \u00f0?mc; ?mi\u00de, \u00f0?mi; ?mk\u00de, \u00f0?mo; ?mq\u00de, and\n\u00f0?mt; ?mv\u00de.\n. Chases : \u00f0!mk; ?mm\u00de, \u00f0!ml; ?mo\u00de, \u00f0!mr; ?ms\u00de, and\n\u00f0!mt; ?mu\u00de.\nThis list is not exhaustive, for example, \u00f0?mq; ?ms\u00de is\nanother chase. However, since ?mq <C !mr and \u00f0!mr; ?ms\u00de\nare already listed, it is not useful to include \u00f0?mq; ?ms\u00de as\nwell. Looking at this list, we can see that the sprint\nconditions can be resolved, for example, by introducing\nFIFO communication semantics between the appropriate\nprocesses, whereas the chase conditions will still be present\neven with, for example, token ring semantics. As we shall\nprove in later sections, sprint conditions exactly character-\nize those race conditions that can be resolved by supposing\nthat communication channels have something like FIFO\nsemantics, whereas chase conditions cannot be resolved in\nthis way. In other words, sprint conditions can be resolved\nby asserting some kind of transmission interdependence\nbetween related send and receive messages, whereas chase\nconditions cannot be resolved in this way.\nOne way to resolve chase conditions is to allow a process\nto use lazy message consumption semantics. By this, we\nmean that a process has random access to its input buffer\nand can delay message consumption from the input buffer\nuntil necessary. The structural semantics for lazy consump-\ntion are formally defined in Section 3. Lazy message\nconsumption generalizes the original scenario in that it\nresults in allowing more system traces than defined by the\ncausal order, whereas resolving sprint conditions can be\nachieved in a way that refines the original system traces.\nFig. 3 is a simplified version of an MSC taken from the\nMOST specification referred to in Section 1. This example\n308 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\nFig. 1. Simple example of chase and race condition.\nFig. 2. Example of multiple chase and race conditions from the Motorola\ncase study.\nhas both branching behavior (shown by the ALT construct,\nwhich is short for alternative) and iterative behavior (shown\nby the loop construct).\nWe can consider finite approximations to this scenario\nthat are obtained by unwinding the loop a small finite\nnumber and by looking at different branches that could be\ntaken at each iteration. In doing so, we are enumerating the\npartial order scenarios that are included in Fig. 3 (see\nDefinition 4.5). Even before considering the iterative\nbehavior, we can see that there is a sprint between ?m3\nand ?m7. This could be resolved, for example, by adding\nFIFO semantics to process NetworkSlave_2.\nBy adding such semantics, we would also resolve the\nsprint between ?m3, ?m7, and ?m9. Depending on which\nalternative is taken with each iteration of the loop, there\nmay also be a sprint between the consecutive iterations of\n?m9. This would occur if, at some iteration, the later branch\nof the alternative was chosen. Again, this would be resolved\nif NetworkSlave_2 had eager FIFO semantics.\n3 GENERAL COMMUNICATION SEMANTICS\nThe causal semantics in Definition 2.4 describes the global\nsystem behavior of a partial order scenario that is meant to\noccur, but does not describe a communication semantics\nbetween processes that enables them to realize this\nbehavior. Gehrke et al. [14] describe such a communication\nsemantics in the form of a process algebra which extends\nthe MRA semantics. Intuitively, we can summarize the\ncommunication semantics in [14] as follows: A process\ncannot send messages directly to another process. Instead, a\nprocess can only transmit messages to a global traffic\nchannel, T . Within the process algebra, T is a special\nprocess that behaves differently from a normal process. T\ncan always receive messages and it stores them in an\nunbounded random access buffer B, which is represented\nin the form of a multiset. At the moment when a process is\nspecified to receive a message, as defined by the causal\nbehavior, T removes the relevant message from its buffer\nand sends it directly to the waiting process. Hence, T acts as\na global coordination mechanism that ensures that the\nmessages always arrive exactly in accordance with the\ncausal ordering. The causal behavior is equivalent to the\nglobally observed behavior given by concurrently compos-\ning a system\u2019s processes and T within the process algebra.\nIn this section, we define structural operational rules that\nallow us to describe various communication semantics for\npartial order scenarios. Each type of communication is a\nmodification of the standard causal semantics in [14]. Thus,\ncommunication will always consist of processes transmit-\nting messages to a transmission channel T . This channel\nwill then deliver the messages according to the particular\nsemantics being considered.\nThe causal semantics assumes the traffic channel can act\nas a global coordination mechanism. The variations defined\nin this section will not have this property. Hence, it will be\npossible for processes to become deadlocked if they are not\nexplicitly forced to act in concert to ensure that messages\narrive in the correct order. The different semantics\nconsidered in this section are asynchronous, synchronous,\nFIFO, and token ring communication. We will also consider\ntwo variations of FIFO and asynchronous semantics, which\nwe call eager and lazy consumption semantics.\nAn essential difference from the causal semantics is that\nprocesses will now have an input buffer to which messages\nare delivered. How a message is consumed from the buffer\nwill depend on the particular communication semantics\nbeing considered. We will treat message consumption as an\ninternal action that cannot be externally observed. We use \u0003\nto denote the silent action which will be generated when a\nprocess silently consumes a message from its input buffer.\nEach operational rule will be controlled by a predicate\ncondition which is defined in terms of the causal order <C .\nThese will determine exactly how communication occurs.\nThey are designed so that those aspects of the communica-\ntion semantics we wish to consider can be expressed as\nproperties of the causal order within a partial order\ntheoretic framework.\nThe structural rules defining the various semantics are\ngiven in Fig. 4. Each of the constraints InBuf, Trns, and Dlv is\na predicate condition. By choosing the appropriate values\nfor these conditions, we can define the particular commu-\nnication semantics mentioned above. These choices are\ngiven in the table in Fig. 5. The reader will note that the\ndefinition of FIFO semantics is a little unusual. We use this\nformat so that we can present all of he communication\nchannel semantics in a consistent and concise style. In\nSection 3.3, we will prove that the FIFO semantics here are\nequivalent to the usual semantics. In the remainder of this\npaper, when convenient, we abbreviate Eager Asynchro-\nnous as EA, Lazy Asynchronous as LA, Eager FIFO as EF,\nLazy FIFO as LF, Synchronous as S, and Token Ring as TR.\nThroughout this section, we will take Sc to be a partial\norder scenario on processes P \u00bc fPij0 \u0004 i \u0004 ng. For each\nprocess P 2 P, we define a primitive process term Pr\u00f0P \u00de\nMITCHELL: CHARACTERIZING COMMUNICATION CHANNEL DEADLOCKS IN SEQUENCE DIAGRAMS 309\nFig. 3. Simplified SD taken from the MOST specification.\nthat describes the behavior of P . Each primitive term Pr\u00f0P \u00de\nwill be of the form Pr\u00f0In; S;<P \u00de, where In is an input\nbuffer, S \u0002 E\u00f0P \u00de is a set of events that are eligible to occur\nnext in a trace, and <P will define which events will be\nconsecutive to those in S. In is a multiset, as is the buffer B\nfor the transmission channel T .\nDefinition 3.1. For a set S \u0002 E and partial order < on E,\ndefine\nn\u00f0S;<\u00de \u00bc fx 2 E j 9y 2 S : y < x;\nand :9z 2 E : y < z < xg;\nm\u00f0S;<\u00de \u00bc fx 2 S j :9y 2 S : y < xg;\ncns\u00f0a; S;<\u00de \u00bcm\u00f0\u00f0S \u0005 fag\u00de [ n\u00f0fag; <\u00de; <\u00de:\nThe set m\u00f0S;<\u00de contains the minimal elements in S with\nrespect to < . The set n\u00f0S;<\u00de is the least upper bound of S\nwith respect to < . Notice that cns\u00f0a; S;<\u00de is an unordered\nset since the minimal elements of a set are themselves\nalways unordered. If S is an unordered set and a 2 S, then\nS \u0005 fag \u0002 cns\u00f0a; S;<\u00de. In this case, cns\u00f0a; S;<\u00de consists of\nS \u0005 fag together with those elements of n\u00f0fag; <\u00de that are\nunordered with respect to S \u0005 fag.\ncns is an abbreviation for consecutive. Suppose that we\nhave a causal system trace t that is a total extension of < .\nLet a be some event in t so that t is of the form t0 \u0006 a \u0006 t1\n(where \u0006 denotes concatenation). Let S be the set of minimal\nevents from the set of all events not in t0 \u0006 a. Then, t1 must\nbe of the form b \u0006 t2, where b 2 cns\u00f0a; S;<\u00de ([25, Lemma 4.2]).\nIf S contains those events that could occur next at a given\npoint in a system execution and a is the event that then does\noccur, the set cns\u00f0a; S;<\u00de defines which events may be\nconsecutive to a in a causal system trace.\nFor the following rules, when x 2 E\u00f0P \u00de, we define\nE\u00f0x\u00de \u00bc E\u00f0P \u00de. We define the concurrent composition op-\nerator k to be commutative and associative. We use End\u00f0P \u00de\nto denote that process P has been successfully terminated.\nNotice that the Receive, Consume, and Send rules do not\ninvolve the transmission channel. They define how a\nprocess ordering controls the internal part of message\ntransmission through the input buffer. These rules control\nthe process behavior by ensuring the set of events that are\neligible to concurrently occur next is determined by the\ncns\u00f0e; S;<P \u00de set. This ensures that, internally, a process\nbehavior is determined by its process orders <P , which is\nconsistent with causal semantics.\nThe Transmit and Deliver rules define how the transmis-\nsion channel then applies a particular communication\nsemantics to messages while in transit. These rules are\nindependent of how the process will internally handle\nsending and receiving messages.\nDefinition 3.2.We say that !e is connected to a set of events X if\n!e 2 X or ?e 2 X. For a set X \u0002 E, l et Sd\u00f0X\u00de \u00bc\nf!ej!e is any send event connected to Xg and let\n#X \u00bc fy 2 E j 9x 2 X : x <C yg:\nHence, # Sd\u00f0X\u00de represents events that are later than any send\nevent connected to X.\nWhen we set condition InBuf to be In \u00bc fg, the semantics\nare defined to be eager. In this case, a process will deadlock\nif a message that arrives cannot be consumed immediately.\nHence, a process must consume messages in an eager\nmanner to avoid a deadlock. Note that the deliver rule only\npermits T to add a message to a process input buffer when\nit is able to receive a message. As we shall prove below,\neager message consumption models the idea that, if a\nmessage arrives out of order, a process will then deadlock.\nDespite the fact that T will only deliver a message when an\ninput buffer is capable of receiving a message, this does not\nimply that T acts as a global coordination mechanism. T\nwill deliver a message arbitrarily once it is able, irrespective\nof whether this is correct with respect to the causal order for\na specification. The fact that there is a global delivery\nsystem T does not imply that it must act as a global\ncoordination system.\nDefinition 3.3.When U is one of LA, EA, LF, EF, S, or TR, then\nwe define kU to be the concurrent composition defined in Fig. 4\nwith the constraints corresponding to U in the table in Fig. 5.\nLet\nPr\u00f0Pi\u00de \u00bc Pr\u00f0f g; m\u00f0E\u00f0Pi\u00de; <Pi\u00de; <Pi\u00de:\nDefine\nPrU\u00f0Sc\u00de \u00bc Pr\u00f0P0\u00de kU \u0006 \u0006 \u0006 kU Pr\u00f0Pn\u00de\nand PU\u00f0Sc\u00de \u00bc T \u00f0;\u00dekU PrU\u00f0Sc\u00de. Define two sequences of\nevents to be trace equivalent if they are equal once all\n\u0003 actions are deleted from them.\n310 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\nFig. 4. General communication semantics for the partial order scenario.\nFig. 5. Table of predicates defining communication semantics.\nDefine a U communication trace of Sc to be any sequence of\nevents \u0004 where there is some \u00040 trace equivalent to \u0004 and\nPU\u00f0Sc\u00de \u0005\u0005\u0005!?\u0004\n0\nT \u00f0f g\u00de kU End0 kU \u0006 \u0006 \u0006 kU Endn:\nFor a communication trace \u0004 and x; y 2 E, we write x <\u0004 y\nwhen \u0004 is of the form \u00040 \u0006 x \u0006 \u00041 \u0006 y \u0006 \u00042.\nExamining the communication structural rules in Fig. 4, we\ncan see that it is no longer the case that messages are\nnecessarily delivered in the order dictated by <C . If\nmessages no longer arrive in the right order, this may\nresult in a deadlock, depending on the particular commu-\nnication semantics being considered. Inspection of the rules\ndoes show that, if x <C !e for any events x and !e, then it still\nis the case that, for any communication trace \u0004, x <\u0004 !e. This\nfollows since a send event can only be transmitted once all\nof the events before it (with respect to <C ) have been\nconsumed. In order to refer to this fact when needed, we\nwill formally state it as a proposition.\nProposition 3.4. For any communication semantics U , if \u0004 is a\ncommunication trace of PU\u00f0Sc\u00de and there are events x and !e,\nwhere x <C !e, then x <\u0004 !e.\nAlthough deadlocks can occur when messages are sent in\nthe wrong order, the lazy semantics has been designed to\nallow a receiving process the ability to delay the consump-\ntion of a message until the appropriate point. Lazy\nsemantics also allows a process to pick any value from its\ninput buffer for consumption. These two facts together\nmean that processes never deadlock with respect to lazy\ncommunication semantics.\nProposition 3.5. When U is any lazy message passing semantics\n(i.e., when InBuf \u00bc true), process PU\u00f0Sc\u00de has no deadlocks.\nProof. Let \u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de,  k \u00bc T \u00f0Bk\u00dekU\u0005k0kU \u0006 \u0006 \u0006 kU\u0005kn,\nand suppose that there is a deadlock trace \u0006 \u00bc b1 \u0006 \u0006 \u0006 bk,\nwhere\nPU\u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  k:\nLet ER be the set of receive events in E.\nNotice that, with any lazy semantics, although T \u00f0Bk\u00de\nmay have to deliver messages in some constrained way,\nit can always deliver some message as long as its buffer\nis not empty. Also, any process \u0005ki can send a message to\nT as long as there is some send event in Ski . Thus, a\ndeadlock can occur if and only if Bk \u00bc ; and\n8 0 \u0004 i \u0004 n: \u00f0Ski \u0002 ER\u00de and \u00f0Ski \\ Inki \u00bc ;\u00de:\nLet\n?e 2 m\n[\n0\u0004i\u0004n\nSki ; <C\n !\nand suppose that ?e 2 Ski for some i and that !e 2 E\u00f0Pj\u00de\nfor some j. If !e has not already occurred in \u0006, this can\nonly be because there is some x 2 Skj where x <Pj !e. This\ncontradicts that ?e is minimal. Hence, !e \u00bc br for some\n1 \u0004 r \u0004 k. Since Bk \u00bc ;, this can only be true if ?e 2 Inki ,\nwhich is a contradiction. This completes the proof. tu\nNote that the above proposition will also be true if, for\nexample, we consider a lazy version of the Token Ring or\nSynchronous semantics. The reason we do not consider\nsuch lazy alternatives is that Synchronous and Token Ring\nare meant to work without the need to delay message\nconsumption.\nProposition 3.6. Let U be any eager message passing semantics\n(i.e., InBuf is the condition In \u00bc fg). If there is a deadlock\ntrace of PU\u00f0Sc\u00de, then there are events ?e, x 2 E such that\n\u00f0x <C ?e\u00de and :\u00f0x <C !e\u00de:\nThat is, a deadlock can only occur when <C contains a race\ncondition.\nProof. Let \u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de,  k \u00bc T \u00f0Bk\u00dekU\u0005k0kU \u0006 \u0006 \u0006 kU\u0005kn,\nand suppose that there is a deadlock trace \u0006 \u00bc b1 \u0006 \u0006 \u0006 bk,\nwhere\nPU\u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  k:\nFirst, we will prove that there must be some ?e 2 E and\nsome i where f?eg \u00bc Inki and that there is some x 2 Ski ,\nwhere x <C ?e.\nAs we saw in the proof of Proposition 3.5,  k will not\ndeadlock if any process is capable of sending a message.\nWith eager semantics, the various \u0005ki can always transmit\nto T as long as their input buffers Inki are empty.\nConsider if a deadlock has been reached because T \u00f0Bk\u00de is\nunable to deliver any of the messages in Bk. From the\nrules in Fig. 4, this can only be true if the various \u0005ki that\nare meant to receive one of these events all have a value\nin their respective input buffers. Thus,  k can only be\ndeadlocked if some \u0005ki has a nonempty input buffer from\nwhich it is unable to consume the contents.\nHence, there is some \u0005ki where ?e 2 Bk, ?e 62 Ski , and\nf?eg \u00bc Inki . From the definition of the structural commu-\nnication rules, since ?e has not yet been consumed, this\nimplies that ?e 2# Ski . Since ?e 62 Ski , this implies that there\nexists some y 2# Ski where y <C ?e: Choose the minimum\nsuch y and take this to be the value for x. Note that, since !e\nhas already occurred and x has not, :\u00f0x <C !e\u00de by\nProposition 3.4, as required to complete the proof. tu\nThis proposition shows that deadlocks can only occur if <C\ndoes not properly coordinate message passing between\nprocesses. Intuitively, it seems quite reasonable that the\ncausal ordering should ensure that when an event is\nordered before some receive event, it also ought to be\nordered before the corresponding send event. Notice that\nthe proof of this proposition shows that the eager message\npassing semantics causes a deadlock if any message is\ndelivered in the wrong order with respect to the causal\nordering <C . Thus, eager and lazy semantics have opposite\npolicies for handling messages that occur out of order with\nrespect to the causal ordering <C .\nNote that, from the proof of Proposition 3.6, we\nimmediately have the following corollary.\nCorollary 3.7. Suppose that PU\u00f0Sc\u00de deadlocks with trace\n\u0006 \u00bc b1 \u0006 \u0006 \u0006 bk. Then, there is\nPU\u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  Uk ;\nMITCHELL: CHARACTERIZING COMMUNICATION CHANNEL DEADLOCKS IN SEQUENCE DIAGRAMS 311\nwhere  Uk \u00bc T \u00f0Bk\u00dekU\u0005k0kU \u0006 \u0006 \u0006 kU\u0005kn and\n\u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de\nand, for some i, there is x 2 Ski , f?eg \u00bc Inki , :\u00f0x <C !e\u00de, and\nx <C ?e.\n3.1 Eager Asynchronous\nWith Eager Asynchronous (EA) communication, T has no\nrestrictions on delivering messages except that the relevant\ninput buffer must be empty. EA semantics restricts the\ninput buffer for a process to be a single place buffer. The\nSend rule for EA will not allow a process to pass a message\nto the transmission channel if there is a message waiting to\nbe consumed. EA semantics assumes that scenario pro-\ncesses will spontaneously act in concert to enforce the\ncausal order. Clearly then, as long as the processes do not\ndeadlock, the EA semantics will act like the causal\nsemantics. The interesting question is when the processes\nwill deadlock.\nProposition 3.8. The communication traces for PEA\u00f0Sc\u00de are the\ncausal system traces for Sc.\nProof. It is clear from the construction of the EA semantics\nthat, when PEA\u00f0Sc\u00de does not deadlock, there is an\nequivalence between transitions of PEA\u00f0Sc\u00de and Pc\u00f0Sc\u00de.\nThis follows since each transition\nT \u00f0B\u00dekc Pr\u00f0S [ f!eg; <P \u00de\n\u0005!!e T \u00f0B [ f?eg\u00dekc Pr\u00f0cns\u00f0!e; S;<P \u00de; <P \u00de\nis equivalent to a transition\nT \u00f0B\u00dekEA Pr\u00f0fg; S [ f!eg; <P \u00de\n\u0005!!e T \u00f0B [ f?eg\u00dekEA Pr\u00f0fg; cns\u00f0!e; S;<P \u00de; <P \u00de:\nAlso, each transition T \u00f0B [ f?eg\u00dekc Pr\u00f0S;<P \u00de \u0005!\n?e\nT \u00f0B\u00dekc Pr\u00f0cns\u00f0?e; S \u0005 f?eg; <P \u00de; <P \u00de is equivalent to the\ncombined transition\nT \u00f0B [ f?eg\u00de kEA Pr\u00f0f g; S;<P \u00de\n\u0005!\u0003 \u0006?e T \u00f0B\u00de kEA Pr\u00f0f g; cns\u00f0?e; S \u0005 f?eg; <P \u00de; <P \u00de:\nHence, the communication traces of PEA\u00f0Sc\u00de are the same\nas Pc\u00f0Sc\u00de. This completes the proof. tu\nProposition 3.9. PEA\u00f0Sc\u00de deadlocks if and only if there are\nevents x and ?e such that\n\u00f0x <C ?e\u00de and :\u00f0x <C !e\u00de:\nProof. Since we already have Proposition 3.6, it only\nremains to prove the converse to the result. Suppose\nthen that there are x and ?e such that \u00f0x <C ?e\u00de and\n:\u00f0x <C !e\u00de. Suppose that x 2 E\u00f0Pi\u00de. If ?e 62 E\u00f0Pi\u00de, then let\nx0 2 E\u00f0Pi\u00de be minimal such that \u00f0x0 <C ?e\u00de and\n:\u00f0x0 <C !e\u00de. Such an x0 must exist from the definition of\n<C . Hence, without loss of generality, we may suppose\nthat ?e 2 E\u00f0Pi\u00de.\nFirst, consider if x is of the form ?g. Consider those\ntraces generated by allowing PSF \u00f0Sc\u00de to execute as\nfollows: We allow processes to execute in a random\nmanner with respect to the EA semantics. However, we\nrestrict T so that if ?g is transmitted to its buffer B, then T\nnever delivers ?g. Effectively, this will block any event y\nwhere x <C y from being delivered.\nUnder these circumstances, either PEA\u00f0Sc\u00de will dead-\nlock or we will reach a point where !e is transmitted to T .\nSuppose that there is a sequence of events \u0006 where\nPEA\u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  EA;\nwith  EA \u00bc T \u00f0B [ f?eg\u00dekEA\u00050kEA \u0006 \u0006 \u0006 kEA\u0005n and \u0005i \u00bc\nPr\u00f0Ini; Si; <Pi\u00de. Either \u0005i is deadlocked or it has an\nempty input buffer or it can silently consume any\nmessage contained in its input buffer. If \u0005i is deadlocked,\nthis completes this part of the proof. Hence, without loss\nof generality, we may suppose that \u0005i \u00bc Pr\u00f0fg; Si; <Pi\u00de\nand that there is some y 2 Si where ?g <c y. Otherwise,\nfrom the EA semantics, ?g would have already occurred,\nwhich cannot happen because of the restrictions we have\nplaced on T . Hence, we have a transition\nT \u00f0B [ f?eg\u00de kEA \u0005i \u0005!\n?e\nT \u00f0B\u00de kEA Pr\u00f0f?eg; Si; <Pi\u00de\nand Pr\u00f0f?eg; Si; <Pi\u00de is deadlocked.\nNext, consider if x is of the form !g. We generate traces\nby allowing PSF \u00f0Sc\u00de to execute as follows: We allow all\nprocesses except Pi to execute at will and we place no\nrestrictions on T . However, we do not allow Pi to\ntransmit !g. Since :\u00f0!g <C !e\u00de, this does not prevent !e\nfrom being transmitted to T at any time. Thus, either\nPEA\u00f0Sc\u00dewill deadlock or we will reach a point where !e is\ntransmitted to T . The argument now proceeds just as for\nthe ?g case. Thus, we have shown that there will be a\ndeadlock of PEA\u00f0Sc\u00de, which completes the proof. tu\nThe Eager Asynchronous semantics illustrates what hap-\npens if we try to implement the causal order with the\nsimplest of buffer semantics. When the transmission\nchannel cannot enforce the causal ordering, then deadlocks\nwill occur exactly when the causal order contains race\nconditions. Hence, for the EA semantics, race conditions\nprecisely capture when the causal order does not ade-\nquately describe coordination between the processes in\norder to avoid a deadlock.\n3.2 Lazy Asynchronous\nWeknow fromProposition 3.5 that there are no deadlocks for\nlazy communication semantics. Lazy communication allows\nmessages to be delivered in any order to a process. The\nprocess has the responsibility of consuming messages in the\ncorrect order with respect to the causal order <C . Since\nconsumption is internal to the process, external observation\ncan only detect which messages are delivered in an arbitrary\norder. In addition, external observation will show that, when\nthe correct triggers for somemessage have arrived (albeit in a\nrandom order), that message will be sent. This turns out to\nprecisely definewhat communication traces are generated by\nthe Lazy Asynchronous (LA) semantics.\n312 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\nProposition 3.10. Let \u0004 \u00bc a0 \u0006 \u0006 \u0006 am, where ai 2 E for\n0 \u0004 i \u0004 m. Then, \u0004 is an LA communication trace if and\nonly if\n. 8 x, !y 2 E, x <\u0004 !y, x <C !y, and\n. 8 !x 2 E, !x <\u0004 ?x.\nProof. It is clear from the definition of LA semantics that\nany LA communication trace must be of the form \u0004 as\ngiven in the hypothesis.\nSuppose then that we have a sequence \u0004 as in the\nhypothesis. Let \u0004k \u00bc a1 \u0006 \u0006 \u0006 ak. We will prove by induction\non k that there are \u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de and  LAk \u00bc\nT \u00f0lstk\u00dekLA\u0005k0kLA \u0006 \u0006 \u0006 kLA\u0005kn such that\nPLA\u00f0Sc\u00de \u0005\u0005\u0005!?\n\u00040\nk\n LAk ;\nfor some \u00040k trace equivalent to \u0004k.\nThe base case is trivial since the first element of \u0004\nmust be a send event that is minimal with respect to <C .\nIt therefore remains to prove that the above holds for\nk\u00fe 1.\nFirst, consider if ak\u00fe1 is a receive event ?e 2 E\u00f0Pi\u00de for\nsome i. By definition, for \u0004, there is some r \u0004 k such that\n!e \u00bc ar. Hence, by induction, ?e 2 Bk. In such a case,\nsince the lazy semantics allows messages to be delivered\nat any time, we have a transition\nT \u00f0Bk\u00dekLA\u0005ki \u0005!\n?e\nT \u00f0Bk \u0005 f?eg\u00dekLA Pr\u00f0Inki [ f?eg; Ski ; <Pi\u00de:\nNext, consider if ak\u00fe1 is a send event !e 2 E\u00f0Pi\u00de for some\ni. By definition of \u0004k, for any event y <C !e, y must have\nalready occurred in \u0004k.\nIf we cannot form a transition\nT \u00f0Bk\u00dekLA\u0005ki\n\u0005!!e T \u00f0Bk [ f?eg\u00dekLA Pr\u00f0Inki ; cns\u00f0!e; Ski ; <Pi\u00de; <Pi\u00de;\nthen there is a value x 2 Ski where x <C !e. Note that,\nfrom our observation about \u0004k, there are no send\nevents !f where x \u0004C !f <C !e. Hence, x is of the\nform ?h and any value y where x <C y <C !e must also\nbe a receive event. We also know that any such y must\nhave already occurred in \u0004k. From the LA semantics\ndefined in Fig. 5, this can only be if every such y is an\nelement of Inki . Hence, every such y can be silently\nconsumed by \u0005ki . We may therefore replace \u0005\nk\ni with some\nterm of the form Pr\u00f0Inki 0; Ski 0; <Pi\u00de, where ?e 2 Ski 0. We\nnow have a transition as required: T \u00f0Bk\u00dekLA\u0005ki 0 \u0005!\n!e\nT \u00f0Bk [ f?eg\u00dekLA Pr\u00f0Inki 0; cns\u00f0!e; Ski 0; <Pi\u00de; <Pi\u00de. This com-\npletes the induction step and, hence, completes the\nproof. tu\n3.3 Eager FIFO\nThe FIFO semantics defined in Fig. 5 at first sight seems to\nhave little in common with a more standard definition of\nFIFO message passing. In this section, we will show that,\nfrom the point of view of deadlock detection, they are, in\nfact, equivalent. For this section, we will abbreviate the\nstandard FIFO semantics to SF semantics. Throughout this\nsection, let lst be a list of events from E. Let e :: lst be the\nconcatenation of e to the front of lst and lst@e be the\nappending of e to the end of the list. With SF semantics, we\nwill use a traffic channel T \u00f0lst\u00dewhere lstwill now apply the\nusual FIFO rules to pass messages.\nThe SF semantics has the Receive, Consume, Send, and\nTerminate rules in Fig. 4, which we give the eager\nsemantics. We replace the Transmit and Deliver rules with\nthe following versions:\nTransmit\n\u0005 \u0005!!e \u00050\nT \u00f0lst\u00de k \u0005 \u0005!!e T \u00f0?e :: lst\u00dek\u00050\n;\nDeliver\n\u0005 \u0005!?e \u00050\nT \u00f0lst@?e\u00de k \u0005 \u0005!?e T \u00f0lst\u00de k \u00050\n:\nProposition 3.11 There is a deadlock trace for PSF \u00f0Sc\u00de if and\nonly if there is a deadlock trace for PEF \u00f0Sc\u00de.\nProof. First, consider the Dlv constraint for the EF semantics.\nUnpicking the definition for Dlv, we can see that !e 2#\nSd\u00f0B \\ E\u00f0?e\u00de\u00de holds if and only if\n8 ?f 2 B \\ E\u00f0?e\u00de::\u00f0!f <c !e\u00de:\nHence, if ?e and ?f belong to the same process and are\nboth present in T \u2019s buffer and !f <c !e, then ?f must be\ndelivered before ?e. From the definition of SF, we can see\nthat if !f <c !e and both ?e and ?f are elements of lst, then\n?f must occur later than ?e. Hence, ?f will be delivered\nbefore ?e. Therefore, the SF semantics preserves the EF\nsemantics for delivery.\nLet \u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de,\n SFk \u00bc T \u00f0lstk\u00dekSF\u0005k0kSF \u0006 \u0006 \u0006 kSF\u0005kn;\nand suppose that there is a deadlock trace \u0006 \u00bc b1 \u0006 \u0006 \u0006 bk\nwhere\nPSF \u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  SFk :\nFrom our earlier remarks, we thus have\nPEF \u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  EFk ;\nwhere  EFk \u00bc T \u00f0Bk\u00dekEF\u0005k0kEF \u0006 \u0006 \u0006 kEF\u0005kn and Bk is the set\nof events in lstk. Hence, by Corollary 3.7, if  \nSF\nk\ndeadlocks, then there is some \u0005ki where In\nk\ni \u00bc f?eg and\n?e 62 Inki . Hence,  EFk must also be deadlocked.\nConsider next if EF deadlocks. So, we have a\ndeadlock trace \u0006 and process terms  EFk and \u0005\nk\ni as above.\nFrom Proposition 3.6, there are events x, ?e where x <C\n?e and :\u00f0x <C !e\u00de. From Corollary 3.7, we can also\nsuppose that, for some i, Inki \u00bc f?eg and x 2 Ski . If x \u00bc ?g\nfor some g, then we also know that :\u00f0!g <C !e\u00de.\n(Otherwise, EF semantics dictates that !g would have to\noccur before !e. In such a case, ?g would have had to be\nconsumed before ?e could be received. Hence, x 62 Ski ,\nwhich is a contradiction.) If x \u00bc !g for some g, then \u0005ki has\nnot yet sent !g. Whichever of these cases holds, let x0 \u00bc !g.\nNext, we allow PSF \u00f0Sc\u00de to execute as follows: Execute\nany element y where y \u0004C !e whenever possible. Never\nallow PSF \u00f0Sc\u00de to execute x0. Otherwise, allow events to\nbe executed at random. Since :\u00f0x0 <C !e\u00de, there will be no\nreason why we are forced with SF semantics to execute x0\nMITCHELL: CHARACTERIZING COMMUNICATION CHANNEL DEADLOCKS IN SEQUENCE DIAGRAMS 313\nin order to ensure some value less than !e can be\nexecuted. Therefore, either PSF \u00f0Sc\u00de will deadlock or it\nmust become equal to some process of the form  SFr ,\nwhere Inri \u00bc f?eg, and there is some y <C x where y 2 Sri .\nIn such a case, PSF \u00f0Sc\u00de is again deadlocked. This\ncompletes the proof. tu\nGiven that EF communication semantics deadlock exactly\nwhen the SF semantics deadlocks, we next need to\ncharacterize exactly when such deadlocks can occur.\nProposition 3.12. PEF \u00f0Sc\u00de will deadlock if and only if there are\nevents x and ?e where\n\u00f0?x <C ?e\u00de and :\u00f0!\u00bdx\u0003 <C !e\u00de:\nProof. Suppose that PEF \u00f0Sc\u00de deadlocks with trace\n\u0006 \u00bc b1 \u0006 \u0006 \u0006 bk. Hence, there is\nPEF \u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  EFk\nwith  EFk \u00bc T \u00f0Bk\u00dekEF\u0005k0kEF \u0006 \u0006 \u0006 kEF\u0005kn and\n\u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de:\nLooking at the proof for Proposition 3.11, we must have\nthat, for some i, there is x 2 Ski , f?eg \u00bc Inki , :\u00f0!\u00bdx\u0003 <C !e\u00de,\nand x <C ?e. This follows since, in the proof of Proposi-\ntion 3.11, a value x0 is constructed, which is exactly the\nvalue that we need for !\u00bdx\u0003. This completes the proof. tu\nNote that the deadlock condition for Proposition 3.12 is a\nstronger condition than that for Proposition 3.6. Thus, we\nhave a complete characterization of how deadlocks occur\nfor EF communication semantics and have proven that our\nrepresentation of FIFO semantics is equivalent, with respect\nto deadlock detection, to a standard representation. In the\nfollowing proposition, we characterize EF communication\ntraces, which are those traces that describe successful\nexecutions of an SD.\nProposition 3.13. A sequence \u0004 \u00bc a0 \u0006 \u0006 \u0006 am is an EF commu-\nnication trace if and only if \u0004 is a causal system trace and, for\nall P 2 P and ?x; ?y 2 E\u00f0P \u00de,\n!x <c !y) ?x <\u0004 ?y:\nProof. First, consider where \u0004 is an EF communication\ntrace. It is clear from the structural semantics in Fig. 4\nthat any EF communication trace must be a causal\nsystem trace. We will prove that !x <C !y) ?x <\u0004 ?y by\ncontradiction.\nFor a contradiction, suppose that there are !x; !y 2 E,\nwhere !x <C !y and :\u00f0?x <\u0004 ?y\u00de. Since \u0004 contains all\nevents in E, this implies that ?y <\u0004 ?x. The semantics in\nFig. 4 dictate that !x <\u0004 !y. Hence, it is only possible for\n?x <\u0004 ?y if, at some point, they are both present in the\ntransmission channel\u2019s delivery buffer and ?y is deliv-\nered before ?x. At the point when ?y is delivered, ?x will\nstill be present in the delivery buffer for T . Let ?x; ?y 2\nE\u00f0Pi\u00de for some i.\nHence, at some point during the execution of \u0004,\nPEF \u00f0Sc\u00de has transformed into a term of the form  EFk \u00bc\nT \u00f0Bk\u00dekEF\u0005k0kEF \u0006 \u0006 \u0006 kEF\u0005kn a n d \u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de,\nwhere ?x; ?y 2 Bk. In order for there to be a transition\nT \u00f0Bk\u00de kEF \u0005ki \u0005!\n?y\nT \u00f0Bk\u00fe1\u00de kEF \u0005k\u00fe1i ;\nit must be that Dlv holds. Hence, unravelling the\ndefinition for Dlv, we must have :\u00f0!x <c !y\u00de. This is a\ncontradiction, as required.\nNext, suppose that \u0004 is a sequence, as in the\nhypothesis of the proposition, and we will assume\nwithout loss of generality that it does not contain any\n\u0003 actions. Let \u0004k \u00bc a0 \u0006 \u0006 \u0006 ak. Then, there is some  \u00f0C\u00dek\nwhere\n \u00f0C\u00dek \u00bc T \u00f0Bk\u00de kc Pr\u00f0Sk0 ; <P0\u00de kc \u0006 \u0006 \u0006 kc Pr\u00f0Skn; <Pn\u00de\nand Pc\u00f0Sc\u00de \u0005!\u0004k\u0007  \u00f0C\u00dek. Note that, in the equation above,\nPr\u00f0S;<\u00de represents the behavior of a process in the\ncausal semantics. At the same time, we use Pr\u00f0In; S;<\u00de\nto denote the behavior of a process for the EF semantics.\nWe can prove by induction on k that, if we define\n k \u00bc T \u00f0Bk\u00dekEF Pr\u00f0fg; Sk0 ; <P0\u00dekEF \u0006 \u0006 \u0006 kEF Pr\u00f0fg; Skn; <Pn\u00de,\nthen there is some \u00040k equivalent to \u0004k where\nPEF \u00f0Sc\u00de \u0005!\n\u00040k\n\u0007  k. The base case is straightforward, so we\nmove on to the induction step. Supposing that the above\nequations hold, we need to show that they also hold for\nk\u00fe 1. Suppose that ak\u00fe1 2 E\u00f0Pi\u00de. Consider first if ak\u00fe1 \u00bc\n!e for some !e. In this case, we can trivially prove that the\nk\u00fe 1 case holds since there is no restriction on EF\ntransmitting messages to T . Without loss of generality,\nwe may then suppose that ak\u00fe1 is of the form ?e. In such\na case, ?e 2 Ski , Sk\u00fe1i \u00bc cns\u00f0?e; Ski \u0005 f?eg; <Pi\u00de, and\nT \u00f0Bk\u00de kc Pr\u00f0Ski ; <Pi\u00de \u0005!\n?e\nT \u00f0Bk \u0005 f?eg\u00de kc \u00f0Sk\u00fe1i ; <Pi\u00de:\nHence, for all ?y 2 Bk, ?e <\u0004 ?y. Therefore, by definition\nof \u0004, for all ?y 2 Bk, :\u00f0!y <C !e\u00de. Hence, from the\ndefinition of EF , we have\nT \u00f0Bk\u00dekEF Pr\u00f0fg; Ski ; <Pi\u00de \u0005!\n?e\nT \u00f0Bk \u0005 f?eg\u00dekEF \u00f0f?eg; Ski ; <Pi\u00de\n!\u0003 T \u00f0Bk \u0005 f?eg\u00dekEF \u00f0fg; Sk\u00fe1i ; <Pi\u00de:\nThis completes the induction step and, hence, completes\nboth the proof by induction and the proof of the\nproposition. tu\nProposition 3.13 proves that the EF semantics acts in the\nusual FIFO manner precisely when the causal order\ndictates that this must be the case. Proposition 3.11\nproves that the EF semantics is equivalent, with respect to\ndeadlock detection, to the usual FIFO semantics. Finally,\nProposition 3.12 gives a purely partial order theoretic\ncharacterization for EF deadlocks.\n3.4 Lazy FIFO\nLazy FIFO (LF) semantics asserts that, when send events are\ncausally ordered, their corresponding receive events will be\ndelivered in the same order. The only difference from\nEF semantics is that input buffers are unbounded and\nmessages can be consumed from them in the order that a\nprocess requires. From Proposition 3.5, we know that\nLF semantics do not deadlock. In the following proposition,\nwe describe the LF communication traces.\n314 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\nProposition 3.14. A sequence of events \u0004 is a communication\ntrace for PLF \u00f0Sc\u00de if and only if it is a communication trace of\nPLA\u00f0Sc\u00de and, for all P 2 P and ?x; ?y 2 E\u00f0P \u00de,\n!x <C !y) ?x <\u0004 ?y:\nProof. Clearly, PLA\u00f0Sc\u00de can perform any transition that\nPLF \u00f0Sc\u00de can. Hence, any LF communication trace must be\nan LA communication trace. Proposition 3.13 proved that\nEF communication traces are exactly the causal system\ntraces that satisfy the partial order constraint of the\nhypothesis above. This was proven by demonstrating that\nPEF \u00f0Sc\u00de can generate any trace that PC\u00f0Sc\u00de can generate if\nand only if the above partial order constraint is satisfied. If\nwe replace PEF \u00f0Sc\u00de with PLF \u00f0Sc\u00de and replace PC\u00f0Sc\u00de by\nPLA\u00f0Sc\u00de, then the proof for Proposition 3.13 will go\nthrough, word for word, which provides a proof for\nProposition 3.14. tu\nThis proves that if we generalize EF semantics to allow\nprocesses to consume messages when they are required to,\nthe result is a FIFO form of LA semantics, as one would\nexpect.\n3.5 Synchronous\nThe intuition for synchronous message passing is that\nprocesses wait for an acknowledgment after sending a\nmessage before continuing to execute. In MSC\/SD, this can\nbe explicitly modeled with a suspend region on a lifeline,\nwhich ends when an acknowledgment is received. Alter-\nnately, in SDs, there is a graphical notation for depicting a\nmessage as synchronous without using a suspend region or\nexplicitly showing an acknowledgment. The intuition here\nis that a process will not perform any act after sending a\nmessage until it is received and that there is some\nobservationally silent acknowledgment mechanism that\nallows the sending process to know when to proceed.\nFrom a trace perspective, we can capture this intuition in\na partial order theoretic manner that characterizes the\nSynchronous (S) semantics. S semantics dictates that, for\nany message m and S communication trace \u0004, if there is\nsome event e where !m <C e, then ?m <\u0004 e. We prove this\nformally in Proposition 3.15.\nProposition 3.15. A sequence of events \u0004 is a communication\ntrace for PS\u00f0Sc\u00de if and only if it is a causal system trace and,\nfor all events x and messages m,\n!m <C x) ?m <\u0004 x:\nProof. PEA\u00f0Sc\u00de can execute any transition that PS\u00f0Sc\u00de can.\nHence, S communication traces must be EA communica-\ntion traces. From Proposition 3.8, it follows that\nS communication traces are therefore causal system traces.\nFor a contradiction, suppose that there are x and m\nwhere !m <C x and x <\u0004 ?m. Let \u0004k \u00bc a0 \u0006 \u0006 \u0006 ak. Then, for\n0 \u0004 k \u0004 n, we can write\nPS\u00f0Sc\u00de \u0005\u0005\u0005!?\u0004k  Sk ;\nwhere \u0004k \u00bc a0 \u0006 \u0006 \u0006 ak,  Sk \u00bc T \u00f0Bk\u00dekS\u0005k0kS \u0006 \u0006 \u0006 kS\u0005kn, and\n\u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de. Suppose that x \u00bc ak for some k.\nSince ?m is not in the sequence \u0004k and since !m is, we\nmust have ?m 2 Bk. Also, if !m \u00bc ai, then ?m 2 Bj for\ni \u0004 j \u0004 k.\nConsider if x is of the form ?g. There must have been\nan earlier transition  Sj\u00051 \u0005!\naj\n Sj where aj \u00bc !g and\ni \u0004 j \u0004 k. This must have been the result of a transition\nT \u00f0Bj\u00051\u00de kS \u0005j\u00051i \u0005!\n!g\nT \u00f0Bj\u00051 [ f?gg\u00de kS \u0005ji :\nFrom the S structural rules, this transition can only occur\nwhen :\u00f0?g 2# Sd\u00f0Bj\u00051\u00de\u00de. If !m <C !g, then, by definition,\n?g 2# Sd\u00f0Bj\u00051\u00de\u00de. Hence, we must have that :\u00f0!m <C !g\u00de.\nThis implies that there is a chase condition between !m\nand ?g as we have !m <C ?g and :\u00f0!m <C !g\u00de. From\nCorollary 3.7, this implies that \u0004 cannot be an\nS communication trace, which is the contradiction that\nwe require.\nNext, suppose that x is of the form !g. Then, the\ntransition  Sk\u00051 \u0005!\nak\n Sk must be due to a transition\nT \u00f0Bk\u00051\u00de kS \u0005k\u00051i \u0005!\nx\nT \u00f0Bk\u00051 [ f?gg\u00de kS:\nAs we saw for the previous case, this can only occur\nwhen Trns holds, which cannot be true since !m <C !g\nimplies that ?g 2# Sd\u00f0Bk\u00051\u00de\u00de. Again, we have a contra-\ndiction. Hence, any S communication trace must satisfy\nthe partial order constraint.\nNext, we turn out attention to the converse. Suppose\nthat \u0004 is a sequence, as in the statement of the\nproposition. Let \u0004k \u00bc a0 \u0006 \u0006 \u0006 ak. We will prove by induc-\ntion on k that there are  Sk \u00bc T \u00f0Bk\u00dekS\u0005k0kS \u0006 \u0006 \u0006 kS\u0005kn and\n\u0005ki \u00bc Pr\u00f0fg; Ski ; <Pi\u00de, where\nPS\u00f0Sc\u00de \u0005\u0005\u0005!?\n\u00040k\n Sk\nfor some \u00040k equivalent to \u0004k. The base case is\nstraightforward, so we move on to the induction step.\nFirst, consider when ak\u00fe1 is of the form !e. For each\n!m <C !e, we trivially have !m <C ?e. Hence, each ?m is an\nelement of \u0004k. Therefore, there is no ?m 2 Bk where\n!m <C !e. Hence, Trns is true and we have a transition\nT \u00f0Bk\u00de kS \u0005ki \u0005!\nak\nT \u00f0Bk\u00fe1\u00de kS \u0005k\u00fe1i :\nNext, consider when ak\u00fe1 is of the form ?e 2 E\u00f0Pi\u00de for\nsome i. For S semantics, there is no restriction on delivery\nexcept that the input buffer should be empty, which is the\ncase by the induction hypothesis. Process \u0005k\u00fe1i is of the\nform\nPr\u00f0f?eg; Ski ; <Pi\u00de:\nWe need to prove that ?e 2 Ski . For a contradiction,\nsuppose that there is some x 2 Ski where x <C ?e.\nConsider first if x is of the form !g. Since !g <C ?e, we\nhave ?g <\u0004 ?e by the induction hypothesis. This implies\nthat xmust be in \u0004k, which contradicts that it is a value in\nSki . Consider next if x is of the form ?g. If :\u00f0!g <C ?e\u00de, then\nwe have a chase condition, which is a contradiction by the\nproof of Proposition 3.6. Hence, we again have !g <C ?e\nand, again, this leads to a contradiction. Therefore, \u0005k\u00fe1i is\nable to silently consume ?e. Thus, we can write\nMITCHELL: CHARACTERIZING COMMUNICATION CHANNEL DEADLOCKS IN SEQUENCE DIAGRAMS 315\n\u0005k\u00fe1i \u0005!\n\u0003\nPr\u00f0f g; cns\u00f0?e; Ski \u0005 f?eg; <Pi\u00de; <Pi\u00de:\nThis completes the proof by induction and, hence,\ncompletes the proof of the proposition. tu\nThis proposition proves that, during any S system execution\nwhich does not deadlock, each process will not perform any\naction once it has sent a message until the message is\nreceived.\nProposition 3.16. PS\u00f0Sc\u00de will deadlock if and only if there are\nevents x and ?e where\n\u00f0x <C ?e\u00de and :\u00f0!\u00bdx\u0003 <C !e\u00de:\nNote that this is exactly the same condition as for\nProposition 3.12.\nProof. Suppose that PS\u00f0Sc\u00de deadlocks with trace\n\u0006 \u00bc b1 \u0006 \u0006 \u0006 bk. Hence, there is\nPS\u00f0Sc\u00de \u0005\u0005\u0005!?\u0006  Sk ;\nwith Sk \u00bc T \u00f0Bk\u00dekS\u0005k0kS \u0006 \u0006 \u0006 kS\u0005kn and \u0005ki \u00bc Pr\u00f0Inki ; Ski ; <Pi\u00de.\nFrom Corollary 3.7, we must have that, for some i, there\nis x 2 Ski , f?eg \u00bc Inki , :\u00f0x <C !e\u00de, and x <C ?e.\nIf x is of the form !g, then we are done. Suppose then\nthat x is of the form ?g. Since f?eg \u00bc Inki , we know that !e\nis in \u0004k. For a contradiction, suppose that !g <C !e. This\nimplies that !g is also an element of \u0004k. Since !g has\noccurred, but ?g has not, ?g 2 Bk. Let ?e \u00bc bj for some j.\nThus, there is a transition T \u00f0Bj\u00051\u00dekS Pr\u00f0fg; Sj\u00051i ; <Pi\u00de \u0005!\n!e\nT \u00f0Bj\u00051 [ f?eg\u00dekS Pr\u00f0fg; Sk\u00051i ; <Pi\u00de. It must also be that\nTrns holds for this transition to occur. That is,\n:\u00f0?e 2# Sd\u00f0Bj\u00051\u00de\u00de. However, ?g 2 Bj\u00051 since !g occurs\nbefore !e and ?g has not occurred. This implies that\n?e 2# Sd\u00f0Bj\u00051\u00de, which is a contradiction, as required.\nFor the converse, suppose that !\u00bdx\u0003 2 E\u00f0Pi\u00de. We allow\nPS\u00f0Sc\u00de to execute randomly, with the exception that Pi\nmust not transmit !\u00bdx\u0003 to T . Either PS\u00f0Sc\u00de will deadlock at\nsome point or, eventually, ?e will be transmitted. At that\npoint, we will reach a deadlock, as described by\nCorollary 3.7. This completes the proof. tu\nWe have proven that the deadlock condition for S semantics\nis exactly the same as that for EF semantics. Note, however,\nthat the traces of these semantics are quite different.\n3.6 Token Ring\nToken Ring (TR) semantics only allows a single message to\nbe in transit at any time. The concept comes from systems\nwhere a virtual token is continually passed around a\nnetwork ring. When a process holds the token, no other\nprocess may send a message. Once a message is sent, the\nprocess holding the token only releases it once the message\nis received. The structural communication rules in Fig. 4 can\nsimulate this with the constraints given in Fig. 5.\nThe constraints force atmost one value to be in the bufferB\nfor the transmission channel T at any time. The Trns\nconstraint ensures that a value can only be transmitted to T\nwhen B is empty. The Dlv constraint for TR ensures that a\nmessage cannot be delivered unless it is the only value in B.\nAlso, the constraints force a process to consume messages in\nan eager fashion.Note that it is possible for a process to send a\nmessage toT ,which is thendelivered to aprocessQ. Itmaybe\nthat Q will deadlock at this point, but other processes can\ncontinue under the TR semantics to send messages. It is also\npossible that Q does not immediately consume the message\nand other processes start to send messages beforeQ does so.\nHowever, consumption is silent andwe can suppose,without\nloss of generality, that it does occur as soon as possible\nwithout affecting the discussion here. Hence, the TR\nsemantics does not completely characterize the intuitive\nconcept of passing a token.However, this only failswhen one\nof the processes deadlocks and, so, for the purposes of this\npaper, it adequately characterizes token ring semantics.\nProposition 3.17. A sequence of events \u0004 \u00bc a0 \u0006 \u0006 \u0006 an is a\ncommunication trace for PTR\u00f0Sc\u00de if and only if it is a causal\nsystem trace and, for all messages m,\n8 0 \u0004 i \u0004 n: \u00f0!m \u00bc ai\u00de ) \u00f0?m \u00bc ai\u00fe1\u00de:\nProof. By inspection of the constraint on the structural rules\nfor TR, we can see that the following holds.\nThere can be a transition T \u00f0B\u00dekTR Pr\u00f0In; S;<P \u00de \u0005!\n!e\nT \u00f0B [ f?eg\u00dekTR Pr\u00f0In; cns\u00f0?e; S \u0005 f?eg; <P \u00de; <P \u00de if and\nonly if B \u00bc ; and In \u00bc ;. There can be a transition\nT \u00f0B [ f?eg\u00dekTR Pr\u00f0In; S;<P \u00de \u0005!\n?e\u0006\u0003\n\u0007\nT \u00f0B\u00dekTR Pr\u00f0In; cns\u00f0?e; S \u0005 f?eg; <P \u00de; <P \u00de\nif and only if B \u00bc ; and In \u00bc ;.\nHence, for any events !a and b, there is a transition\nequivalent to\nT \u00f0B\u00de kTR Pr\u00f0In; S;<P \u00de \u0005\u0005\u0005!?\n!a\u0006b\nT \u00f0B0\u00de kTR Pr\u00f0In0; S0; <P \u00de\nif and only if b \u00bc ?a. This completes the proof. tu\nProposition 3.18. PTR\u00f0Sc\u00de will deadlock if and only if there are\nevents x and ?e where\n\u00f0x <C ?e\u00de and :\u00f0!\u00bdx\u0003 <C !e\u00de:\nNote that this is exactly the same deadlock condition as for EF\nand S semantics.\nProof. It is clear from the structural rules for TR that EF can\nsimulate any transition that TR can. Thus, byCorollary 3.7,\nif TR deadlocks, then so does EF. This proves that if TR\ndoes deadlock, then the condition above holds.\nSuppose then that we are given events x and ?e where\n\u00f0x <C ?e\u00de and :\u00f0!\u00bdx\u0003 <C !e\u00de:\nFirst, consider if x is of the form !g. As we did with the\nother semantics, we can allow PTR\u00f0Sc\u00de to execute\nrandomly, but with the restriction that !g is not allowed\nto be transmitted to T . As with the other semantics, this\nwill cause PTR\u00f0Sc\u00de to deadlock eventually.\nNext, consider the case where x is of the form ?g.\nFrom Proposition 3.17, we know that there can be no\ntrace where !g occurs after !e and before ?e. Thus, in any\ntrace of PTR\u00f0Sc\u00de, if !e <\u0006 !g, then ?e <\u0006 !g or PTR\u00f0Sc\u00de\ndeadlocks before !g can occur. Thus, if we have ?g <C ?e,\nbut :\u00f0!g <C !e\u00de, we can allow PTR\u00f0Sc\u00de to execute\n316 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\nrandomly with the restriction that !g is not allowed to be\ntransmitted to T . In such a case, we must eventually\nreach a deadlock. This completes the proof. tu\n4 REGULAR SEQUENCE DIAGRAMS\nA regular SD is constructed from a set of partial order\nscenarios by combining them with sequential composition,\niteration, and branching operators. This section extends the\nearlier operational semantics for partial order scenarios to\nregular SDs. The semantics that we define are equivalent to\nthose defined in the MRA semantics [23], [24]. We define\nthem in a form that permits us to integrate them with the\nearlier semantics for partial order scenarios with minimal\neffort. This section also proves one of the main results of\nthis paper, namely, Proposition 4.6.\nConvention. Since we will only be concerned with\nregular SDs, we will simply refer to them as SDs from\nnow on.\nDefinition 4.1. We define an SD process term as follows: This is\ndefined with respect to the possible communication semantics U\ngiven in the table in Fig. 5 and using the notation in\nDefinition 3.3.\nWe assume that there is a fixed set of processes P over\nwhich all the SDs will be defined. If Sd1 and Sd1 are SD\nprocess terms, then so are\n. Sd1 \u00fe Sd2 (alternative operator),\n. Sd1 :: Sd2 (concatenation operator), and\n. Sd11 (loop operator).\nFor any partial order scenario Sc with processes P where\nPU\u00f0Sc\u00de \u0005!?\u0004 T \u00f0B\u00dekU Pr0U for some string of events \u0004, Pr0U is\nalso an SD process term. As usual, we define \u00fe to be\nassociative and commutative and :: to be associative.\nWhen \u0004 is the empty string, we say that Pr0U is an initial\nterm. That is, Pr0U is an initial term when no event has yet\noccurred in PU\u00f0Sc\u00de. Recall from Definition 3.3 that the initial\nterm is denoted PrU\u00f0Sc\u00de.\nAn SD is a process term as above but is constructed only\nfrom initial terms and the operators \u00fe, ::, and 1.\nIntuitively, Sd1 \u00fe Sd2 is the mutually exclusive choice\nbetween alternatives. Graphically, thiswould be shown as an\nALT construct. Sd1 :: Sd2 is the inline sequential composition\noperator. We refer to it as the concatenation operator. This\nrepresents the visual idea of concatenating two SDs together\nwhen they contain the same processes. Sd1 :: Sd2 amounts to\nthe sequential composition of the corresponding processes in\nthe two SDs. Note that it is quite possible with concatenation\nfor some eventswithin the second SD to occur before all of the\nevents in the first diagram have finished. Sd11 represents the\narbitrary iteration ofSd1 any finite number of times.Note that\nwe do not need to explicitly define finite iteration since any\nterm formed by finite iteration can be replaced by an\nequivalent termusingsequential compositionandbranching.\nIn order to have compact operational semantics for SDs,\nwe define some notation concerning when some or all of the\nprocesses in a partial order scenario have ended.\nDefinition 4.2. LetSc be a partial order scenariowith processes P\nwhere PU\u00f0Sc\u00de \u0005!?\u0004 T \u00f0B\u00dekU Pr0U for some string of events \u0004.\nWe refer to Pr0U as a scenario process term.\nIf Pr0U is of the form End\u00f0P \u00dekUQ for some Q, then we say\nthat P has ended in Pr0U . We say that P has ended in an SD\nprocess term Sd when it has ended for every Pr0U that occurs\nin Sd, which we denote by End\u00f0P; Sd\u00de. When P has ended in\nSd for every P 2 P, we say that Sd has ended. We use End to\ndenote a process term that has ended.\nWe formally define the operational semantics for the\nalternative, concatenation, and loop operators in Fig. 6.\nEnd Alt is the only nonintuitive rule in Fig. 6. The alternative\nconstruct semantics can have subtle consequences. Con-\nsider Fig. 7, where the first alternative choice contains no\nactions for process A. If this first alternative is chosen, then\n!c will be the initial event for process A. Moreover, this can\nvalidly occur before process C sends event !b.\nDefinition 4.3. For a sequence diagram Sd, string of events \u0004,\nand sequence diagram process term Sd0, we write\nT \u00f0B\u00de kU Sd \u0005\u0005\u0005!?\n\u0004\nT \u00f0B0\u00de kU Sd0\nMITCHELL: CHARACTERIZING COMMUNICATION CHANNEL DEADLOCKS IN SEQUENCE DIAGRAMS 317\nFig. 6. Communication semantics for regular sequence diagrams.\nFig. 7. Empty alternative for process A.\nwhen the operational semantic rules in Figs. 4 and 6 allow us\nto transform T \u00f0B\u00dekUSd into T \u00f0B0\u00dekUSd0 via the events\ndefined in the string \u0004. We define Sd to have a deadlock trace\nwhen there is a sequence of transitions\nT \u00f0f g\u00de kU Sd \u0005\u0005\u0005!?\n\u0004\nT \u00f0B0\u00de kU Sd0\nand there are no \u00f0non-\u0003\u00de transitions possible for Sd0 and not\nall processes have ended in Sd0. When Sd has a deadlock trace,\nwe say that Sd deadlocks.\nBefore we go on to the main result, we first show that if we\nconcatenate two partial order scenarios, then the result is\nbehaviorally equivalent to another partial order scenario.\nThis lemma will be key in proving the main result for this\nsection. It proves that, irrespective of which communication\nsemantics U we apply, the result of concatenating two\npartial order scenarios is always another partial order\nscenario that is independent of U .\nLemma 4.4. Let Sc1 and Sc2 be two partial order scenarios. Then,\nthe sequence diagram given by PrU\u00f0Sc1\u00de :: PrU\u00f0Sc2\u00de is\nbisimulation equivalent to a partial order scenario, which we\ndenote as Sc1 :: Sc2.\nProof. Let Sd denote PrU\u00f0Sc1\u00de :: PrU\u00f0Sc2\u00de. Both Sc1 and\nSc2 are defined over the same set of processes\nP \u00bc fPij1 \u0004 i \u0004 ng. Without loss of generality, we will\nassume that the events for each scenario are distinct (or\nwe can simply annotate them appropriately so we can\ntell which scenario they belong to). We will denote the\nset of events in Sci for process P as Ei\u00f0P \u00de. The partial\norder over Ei\u00f0P \u00de defined by Sci is denoted <iP .\nDefine a new scenario Sc with events E\u00f0P \u00de \u00bc\nE1\u00f0P \u00de [ E2\u00f0P \u00de for each P 2 P. Define partial orders <P\nby the following:\n. For a, b 2 Ei\u00f0P \u00de, a <P b if and only if a <iP b.\n. For a 2 E1\u00f0P \u00de and b 2 E2\u00f0P \u00de, a <P b.\nClearly, we have sequentially composed the process\ncausal orders for each P . This new scenario Sc is the\nscenario Sc1 :: Sc2 referred to in the hypothesis.\nLet \u0005i \u00bc Pr\u00f0Ini; Si; <Pi\u00de,  \u00bc \u00050kU \u0006 \u0006 \u0006 kU\u0005n, and a\nstring of events \u0004 \u00bc a1 \u0006 \u0006 \u0006 ak, and suppose that there is\na trace where\nPU\u00f0Sc\u00de \u0005\u0005\u0005!?\u0004 T\u00f0B0\u00de kU  :\nBy the construction of Sc, we must have that\nSi \u00bc S1i [ S2i , where S1i \u0002 E1\u00f0Pi\u00de and S2i \u0002 E2\u00f0Pi\u00de. Also,\nwe have that Ini \u00bc In1i [ In2i , where In1i \u0002 E1\u00f0Pi\u00de and\nIn2i \u0002 E2\u00f0Pi\u00de. Let \u0005ji \u00bc Pr\u00f0Inji ; Sji ; <jPi\u00de for j 2 f1; 2g. We\nalso define\n j \u00bc \u0005j0 kU \u0006 \u0006 \u0006 kU \u0005jn:\nNote that the only rule that allows events to be sent from\nSc2 before any event from Sc1 is the !Concat rule. Also, if a\nreceive event ?e from Sc2 occurs before some event in Sc1,\nthen !emust also occur before some of the events in Sc1. In\neither case, End\u00f0Pi;  1\u00dewill be true for the relevant Pi.\nFrom the definitions in Fig. 5, if End\u00f0Pi;  1\u00de holds, then\nInBuf will be true at that point for Pi in Sc. This implies\nthat, for all of the various communication semantics U\ngiven in Fig. 5, the corresponding operational rule has a\nvalid trigger. The converse is also true so that if we were\nable to execute an action in E2\u00f0Pi\u00de for process PU\u00f0Sc\u00de for\nany communication semantics U , then End\u00f0Pi;  1\u00de will be\ntrue. Hence, we have that\nT \u00f0f g\u00de kU Sd \u0005\u0005\u0005!?\n\u0004\nT \u00f0B0\u00de kU \u00f0 1 ::  2\u00de:\nThe converse can be shown to hold in an analogous\nmanner. Putting all of this together gives us the\nbisimulation equivalence, as required. tu\nFrom a sequence diagram, we can define a set of partial\norder scenarios generated by taking a specific choice within\neach of the alternatives in the SD. These scenarios define a\npartition of the concurrent threads in the parent sequence\ndiagram.\nDefinition 4.5. For a sequence diagram process term Sd, define\nthe set S c\u00f0Sd\u00de recursively as follows:\n. S c\u00f0Sd\u00de \u00bc fSdg when Sd is itself a partial order\nscenario process term.\n. S c\u00f0Sd1 \u00fe Sd2\u00de \u00bc S c\u00f0Sd1\u00de [ S c\u00f0Sd2\u00de.\n. S c\u00f0Sd1 :: Sd2\u00de \u00bc fSc1 :: Sc2 j Sc1 2\nS c\u00f0Sd1\u00de and Sc2 2 S c\u00f0Sd2\u00deg.\n. S c\u00f0Sd1\u00de \u00bc fSc1 :: \u0006 \u0006 \u0006 :: Scn j n 2 IN;\nSci 2 S c\u00f0Sd\u00de for 1 \u0004 i \u0004 ng.\nWhen Sc 2 S c\u00f0Sd\u00de, we say that Sc is included in Sd. From\nLemma 4.4, it follows that, when Sd is a sequence diagram,\nthen S c\u00f0Sd\u00de is bisimulation equivalent to a set of partial order\nscenarios.\nA deadlock occurs in a sequence diagram if and only if it\nincludes a partial order scenario that deadlocks, which we\nprove in Proposition 4.6. When combined with the results in\nSection 3, Proposition 4.6 proves that a regular sequence\ndiagram will deadlock if and only if it contains a chase or\nsprint condition.\nProposition 4.6. Let X be a sequence diagram process term and\nSd be a sequence diagram. There is a deadlock trace\nT \u00f0f g\u00de kU Sd \u0005\u0005\u0005!?\n\u0004\nT \u00f0B\u00de kU X\nif and only if there exists a partial order scenario Sc 2 S c\u00f0Sd\u00de\nand, for some Y 2 S c\u00f0X\u00de,\nPU\u00f0Sc\u00de \u0005\u0005\u0005!?\u0004 T \u00f0B\u00de kU Y\nis also a deadlock trace.\nProof. It is straightforward to show that if there exists\nSc 2 S c\u00f0Sd\u00de and if there is a deadlock trace\nPU\u00f0Sc\u00de \u0005!?\u0004 T \u00f0B\u00dekUY , then we also have a deadlock\ntrace T \u00f0f g\u00dekUSd \u0005!?\n\u0004\nT \u00f0B\u00dekUX for some suitable X. It\ntherefore only remains to prove the converse.\nSuppose then that we have a deadlock trace\nT \u00f0f g\u00dekUSd \u0005!\n\u0004\n?\nT \u00f0B\u00dekUX, whe r e \u0004 \u00bc a1 \u0006 \u0006 \u0006 an. T o\ncomplete the proof, it is enough to find Y 2 S c\u00f0X\u00de\nand some Sc 2 S c\u00f0Sd\u00de where PU\u00f0Sc\u00de \u0005!\u0004\n?\nT \u00f0B\u00dekUY . With-\nout loss of generality, we assume that we have annotated\n318 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\nevents in Sd so that the events in each particular\nalternative within it can be considered distinct.\nLet E\u00f0Sd\u00de be the set of events in an SD process term.\nLet E\u00f0\u0004\u00de be the events in the string \u0004. For a sequence\ndiagram, process term Sd, define a partial order\nscenarios process term \u00f0Sd\u00de\u0004 recursively as follows:\n. When Sd is a partial order scenario process term,\n\u00f0Sd\u00de\u0004 \u00bc Sd if E\u00f0Sd\u00de \\ E\u00f0\u0004\u00de 6\u00bc f g; otherwise,\n\u00f0Sd\u00de\u0004 \u00bc End.\n. \u00f0Sd1 \u00fe Sd2\u00de\u0004 \u00bc \u00f0Sd1\u00de\u0004 i f E\u00f0Sd1\u00de \\E\u00f0\u0004\u00de 6\u00bc f g,\n\u00f0Sd1 \u00fe Sd2\u00de\u0004 \u00bc \u00f0Sd2\u00de\u0004 i f E\u00f0Sd2\u00de \\E\u00f0\u0004\u00de 6\u00bc f g;\notherwise, \u00f0Sd1 \u00fe Sd2\u00de\u0004 \u00bc End.\n. \u00f0Sd1 :: Sd2\u00de\u0004 \u00bc Sd\u00041 :: Sd\u00042 .\n. \u00f0Sd1\u00de\u0004 \u00bc \u00f0Sd :: \u0006 \u0006 \u0006 :: Sd\u00de\u0004, which consists of\nn copies of Sd concatenated together.\nLet Sdi be process terms so that the deadlock trace\nT \u00f0f g\u00dekUSd \u0005!?\n\u0004\nX expands as\nT \u00f0f g\u00dekUSd \u0005!\na1\nT \u00f0B1\u00dekUSd1 \u0005!\na2 \u0006 \u0006 \u0006\n\u0005!an T \u00f0Bn\u00dekUSdn \u00bc T \u00f0Bn\u00dekUX:\nBy Lemma 4.4, Sd\u0004 is a partial order scenario, and\nhence, Sd\u0004 2 S c\u00f0Sd\u00de. We can now construct a deadlock\ntrace for Sd\u0004,\nPU\u00f0Sd\u0004\u00de \u0005!a1 T \u00f0B1\u00dekUSd\u00041 \u0005!\na2 \u0006 \u0006 \u0006\n\u0005!an T \u00f0Bn\u00dekUSd\u0004n \u00bc T \u00f0Bn\u00dekUY :\nThis completes the proof. tu\n5 CONCLUSION\nWhere sequence diagrams are constrained to follow MRA\nsemantics, deadlocks are not possible since coordination is\nalways guaranteed between processes. In this paper, we\nhave considered various commonly used communication\nsemantics, which were taken from industrial case studies at\nMotorola and DaimlerChrysler, for example, FIFO and\ntoken ring, as well as eager and lazy message consumption.\nWe formalized these communication semantics with a\nprocess algebra that generalizes the MRA semantics for\nregular sequence diagrams.\nWe refined the idea of race condition into chase and\nsprint conditions. For each of the semantics we considered,\nwe characterized deadlocks either in terms of sprint\nconditions or in terms of chase conditions. The chase and\nsprint conditions together exactly determine when a dead-\nlock can occur in a sequence diagram with one of the\ncommunication semantics that we considered.\nREFERENCES\n[1] R. Alur and M. Yannakakis, \u201cModel Checking of Message\nSequence Charts,\u201d Proc. 10th Int\u2019l Conf. Concurrency Theory,\npp. 114-129, 1999.\n[2] R. Alur, K. Etessami, and M. Yannakakis, \u201cInference of Message\nSequence Charts,\u201d Proc. 22nd Int\u2019l Conf. Software Eng., pp. 304-313,\n2000.\n[3] R. Alur, K. Etessami, and M. Yannakakis, \u201cRealizability and\nVerification of MSC Graphs,\u201d Proc. 28th Int\u2019l Colloquium Automata,\nLanguages, and Programming, pp. 797-808, 2001.\n[4] D. Amyot and A. Eberlein, \u201cAn Evaluation of Scenario Notations\nand Construction Approaches for Telecommunication Systems\nDevelopment,\u201d Telecomm. Systems, vol. 24, no. 1, pp. 61-94, 2003.\n[5] P. Baker, P. Bristow, S. Burton, D. King, C. Jervis, B. Mitchell, and\nR. Thomson, \u201cDetecting and Resolving Semantic Pathologies in\nUML Sequence Diagrams,\u201d Proc. Joint 10th European Software Eng.\nConf. and 13th ACM SIGSOFT Symp. Foundations of Software Eng.,\npp. 50-59, 2005.\n[6] P. Baker, P. Bristow, C. Jervis, D. King, and B. Mitchell,\n\u201cAutomatic Generation of Conformance Tests from Message\nSequence Charts,\u201d Proc. Third Sensor Array and Multichannel Signal\nProcessing Workshop, Telecomm. and Beyond: The Broader Applicability\nof MSC and SDL, pp. 170-198, 2004.\n[7] H. Ben-Abdhallah and S. Leue, \u201cSyntactic Detection of Process\nDivergence and Non-Local Choice in Message Sequence Charts,\u201d\nProc. Third Int\u2019l Conf. Tools and Algorithms for the Construction and\nAnalysis of Systems, pp. 259-274, 1997.\n[8] M. Beyer, W. Dulz, and F. Zhen, \u201cAutomated TTCN-3 Test Case\nGeneration by Means of UML Sequence Diagrams and Markov\nChains,\u201d Proc. 12th Asian Test Symp., pp. 102-106, 2003.\n[9] Y. Bontemps and P.-Y. Schobbens, \u201cSynthesis of Open Reactive\nSystems from Scenario-Based Specifications,\u201d Proc. Third Int\u2019l\nConf. Application of Concurrency to System Design, pp. 41-50, 2003.\n[10] Y. Bontemps and P. Heymens, \u201cTurning High-Level Live\nSequence Charts into Automata,\u201d Proc. 24th Int\u2019l Conf. Software\nEng. Scenarios and State Machines: Models Algorithms and Tools\nWorkshop, May 2002.\n[11] S. Chung, H.S. Kim, H.S. Bae, Y.R. Kwon, and B.S. Lee, \u201cTesting of\nConcurrent Programs Based on Message Sequence Charts,\u201d Proc.\nInt\u2019l Symp. Software Eng. for Parallel and Distributed Systems, pp. 72-\n82, 1999.\n[12] \u201cMethodological Approach to the Use of Object-Orientation in the\nStandards Making Process,\u201d ETSI EG 201 872, 2001.\n[13] \u201cGuidelines for the Use of Formal SDL as a Descriptive Tool,\u201d\nETSI EG 202 106, 2003.\n[14] T. Gehrke, M. Hilhn, and H. Wehrkeim, \u201cAn Algebraic Semantics\nfor Message Sequence Chart Documents,\u201d Proc. IFIP TC6 WG6.1\nJoint Int\u2019l Conf. Formal Description Techniques for Distributed Systems\nand Comm. Protocols and Protocol Specification, Testing and Verifica-\ntion, pp. 3-18, 1998.\n[15] E. Gunter, A. Muscholl, and D. Peled, \u201cCompositional Message\nSequence Charts,\u201d Proc. Seventh Int\u2019l Conf. Tools and Algorithms for\nthe Construction and Analysis of Systems, pp. 496-511, 2001.\n[16] G.J. Holzmann, D.A. Peled, and M.H. Redberg, \u201cAn Analyzer for\nMessage Sequence Charts,\u201d Software Concepts and Tools, vol. 17,\nno. 2, pp. 70-77, 1996.\n[17] D. Harel and W. Damm, \u201cLSCs: Breathing Life into Message\nSequence Charts,\u201d Formal Methods in System Design, vol. 19, pp. 45-\n80, 2001.\n[18] D. Harel and H. Kugler, \u201cSynthesizing State-Based Object Systems\nfrom LSC Specifications,\u201d Int\u2019l J. Foundations of Computer Science,\nvol. 13, no. 1, pp. 5-51, 2002.\n[19] D. Harel, H. Kugler, and A. Pnueli, \u201cSynthesis Revisited:\nGenerating Statechart Models from Scenario-Based Require-\nments,\u201d Formal Methods in Software and System Modeling, pp. 309-\n324, Springer, 2005.\n[20] I. Kruger, R. Grosu, P. Scholz, and M. Broy, \u201cFrom MSCs to\nStatecharts,\u201d Proc. IFIP WG10.3\/WG10.5 Int\u2019l Workshop Distributed\nand Parallel Embedded Systems, pp. 61-71, 1998.\n[21] S. Leue, L. Mehrmann, and M. Rezai, \u201cSynthesizing Software\nArchitecture Descriptions from Message Sequence Chart Specifi-\ncations,\u201d Proc. 13th IEEE Int\u2019l Conf. Automated Software Eng.,\npp. 192-195, 1998.\n[22] M. Lohrey, \u201cSafe Realizability of High-Level Message Sequence\nCharts,\u201d Proc. 13th Int\u2019l Conf. Concurrency Theory, pp. 177-192, 2002.\n[23] S. Mauw and M.A. Reniers, \u201cAn Algebraic Semanitcs of Basic\nMessage Sequence Charts,\u201d Computer J., vol. 7, no. 5, pp. 473-509,\n1995.\n[24] S. Mauw and M.A. Reniers, \u201cOperational Semantics for MSC\u201996,\u201d\nComputer Networks, vol. 31, no. 17, pp. 1785-1799, 1999.\n[25] B. Mitchell, \u201cResolving Race Conditions in Asynchronous Partial\nOrder Scenarios,\u201d IEEE Trans. Software Eng., vol. 31, no. 9, pp. 767-\n784, Sept. 2005.\n[26] B. Mitchell, \u201cInherent Causal Orderings of Partial Order Scenar-\nios,\u201d Proc. Int\u2019l Colloquium Theoretical Aspects of Computing, pp. 114-\n129, Sept. 2004.\nMITCHELL: CHARACTERIZING COMMUNICATION CHANNEL DEADLOCKS IN SEQUENCE DIAGRAMS 319\n[27] B. Mitchell, R. Thomson, and C. Jervis, Phase Automaton for\nRequirements Scenarios, Feature Interactions in Telecommunications\nand Software Systems VII, pp. 77-84. IOS Press, 2003.\n[28] Object Management Group, \u201cUnified Modeling Language Speci-\nfication Version 2.0 Specification,\u201d http:\/\/cgi.omg.org\/, 2004.\n[29] E. Rudolph, I. Schieferdecker, and J. Grabowski, Development of a\nMSC\/UML Test Format. 153-164, Formale Beschreibungstechniken fur\nVerteilte Systeme, pp. 153-164. Verlag Shaker, 2000.\n[30] A. Rountev and B. Connell, \u201cObject Naming Analysis for Reverse-\nEngineered Sequence Diagrams,\u201d Proc. 27th Int\u2019l Conf. Software\nEng., pp. 254-263, 2005.\n[31] J. Schumann and J. Whittle, \u201cGenerating Statechart Designs from\nScenarios,\u201d Proc. 22nd Int\u2019l Conf. Software Eng., pp. 314-323, 2000.\n[32] J. Sun and J.S. Dong, \u201cSynthesis of Distributed Processes from\nScenario-Based Specifications,\u201d Proc. Int\u2019l Symp. Formal Methods,\npp. 415-431, 2005.\n[33] H.H. Wang, S. Qin, J. Sun, and J.S. Dong, \u201cRealizing Live\nSequence Charts in SystemVerilog,\u201d Proc. First Joint IEEE\/IFIP\nSymp. Theoretical Aspects of Software Eng., pp. 379-388, 2007.\n[34] J. Whittle, J. Saboo, and R. Kwan, \u201cFrom Scenarios to Code: An Air\nTraffic Control Case Study,\u201d J. Software and Systems Modeling,\nvol. 4, no. 1, pp. 71-93, 2005.\n[35] S. Uchitel, J. Kramer, and J. Magee, \u201cIncremental Elaboration of\nScenario-Based Specifications and Behaviour Models Using\nImplied Scenarios,\u201d ACM Trans. Software Eng. and Methodology,\nvol. 13, no. 1, pp. 37-85, 2004.\n[36] S. Uchitel, G. Brunet, and M. Chechik, \u201cBehaviour Model\nSynthesis from Properties and Scenarios,\u201d Proc. 29th Int\u2019l Conf.\nSoftware Eng., pp. 34-43, 2007.\n[37] Z.100 (11\/99) ITU-T Recommendation\u2014Languages for Telecom-\nmunications Applications\u2014Specification and Description Lan-\nguage, 1999.\n[38] MOST Dynamic Specification, Most Cooperation, http:\/\/\nwww.mostcooperation.com\/downloads\/Specifications\/MOST\nSpecifications\/, 2005.\n[39] Z.120 (11\/99) ITU-T Recommendation\u2014Message Sequence Chart\n(MSC), 1999.\n[40] ITU-T Recommendation Z.120 (04\/1998) Annex B\u2014Formal\nSemantics of Message Sequence Charts, 1998.\nBill Mitchell received the PhD degree in pure\nmathematics from Manchester University, Uni-\nted Kingdom, in 1987, where he was a lecturer in\ncomputer science until 1999. After four years at\nMotorola Research Labs, he is currently a\nlecturer in the Computing Department at the\nUniversity of Surrey, United Kingdom.\n. For more information on this or any other computing topic,\nplease visit our Digital Library at www.computer.org\/publications\/dlib.\n320 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY\/JUNE 2008\n"}