{"doi":"10.1088\/0957-0233","coreId":"139864","oai":"oai:dspace.lib.cranfield.ac.uk:1826\/1416","identifiers":["oai:dspace.lib.cranfield.ac.uk:1826\/1416","10.1088\/0957-0233"],"title":"Finding minimum spanning trees more efficiently for tile-based phase unwrapping.","authors":["Al-Sawaf, Firas","Tatam, Ralph P."],"enrichments":{"references":[{"id":37950011,"title":"It was observe that hard-disk activity become increasingly pronounced during the progress of this particular tile size. Formatted: Normal, Justified Formatted: Font: (Default) Times New Roman, 12 pt Deleted:","authors":[],"date":null,"doi":null,"raw":"It was observe that hard-disk activity become increasingly pronounced during the progress of this particular tile size. Formatted: Normal, Justified Formatted: Font: (Default) Times New Roman, 12 pt Deleted: \u00b6","cites":null},{"id":37950010,"title":"S Fourier-transform method of fringe pa analysis for computer based topography and interferometry,","authors":[],"date":null,"doi":"10.1364\/josa.72.000156","raw":"M Takeda, H Ina and S Khobayashi, S Fourier-transform method of fringe pa analysis for computer based topography and interferometry, J. Opt. Soc. Am.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2006-06-06T00:00:00Z","abstract":"The tile-based phase unwrapping method employs an algorithm for finding the minimum spanning tree (MST) in each tile. We first examine the properties of a tile's representation from a graph theory viewpoint, observing that it is possible to make use of a more efficient class of MST algorithms. We then describe a novel linear time algorithm which reduces the size of the MST problem by half at the least, and solves it completely at best. We also show how this algorithm can be applied to a tile using a sliding window technique. Finally, we show how the reduction algorithm can be combined with any other standard MST algorithm to achieve a more efficient hybrid, using Prim's algorithm for empirical comparison and noting that the reduction algorithm takes only 0.1% of the time taken by the overall hybrid","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/139864.pdf","fullTextIdentifier":"http:\/\/dx.doi.org\/10.1088\/0957-0233\/17\/6\/022","pdfHashValue":"bff21ed1a1c071efbee9b1f3826034bd1d313279","publisher":"Iop Publishing Ltd","rawRecordXml":"<record><header><identifier>\noai:dspace.lib.cranfield.ac.uk:1826\/1416<\/identifier><datestamp>2013-09-18T10:15:46Z<\/datestamp><setSpec>hdl_1826_19<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>Finding minimum spanning trees more efficiently for tile-based phase unwrapping.<\/dc:title><dc:creator>Al-Sawaf, Firas<\/dc:creator><dc:creator>Tatam, Ralph P.<\/dc:creator><dc:subject>phase unwrapping<\/dc:subject><dc:subject>minimum spanning tree<\/dc:subject><dc:subject>graph theory<\/dc:subject><dc:description>The tile-based phase unwrapping method employs an algorithm for finding the minimum spanning tree (MST) in each tile. We first examine the properties of a tile's representation from a graph theory viewpoint, observing that it is possible to make use of a more efficient class of MST algorithms. We then describe a novel linear time algorithm which reduces the size of the MST problem by half at the least, and solves it completely at best. We also show how this algorithm can be applied to a tile using a sliding window technique. Finally, we show how the reduction algorithm can be combined with any other standard MST algorithm to achieve a more efficient hybrid, using Prim's algorithm for empirical comparison and noting that the reduction algorithm takes only 0.1% of the time taken by the overall hybrid.<\/dc:description><dc:publisher>Iop Publishing Ltd<\/dc:publisher><dc:date>2012-12-10T23:01:38Z<\/dc:date><dc:date>2012-12-10T23:01:38Z<\/dc:date><dc:date>2006-06-06T00:00:00Z<\/dc:date><dc:type>Article<\/dc:type><dc:identifier>Firas Al-Sawaf and Ralph P Tatam; Finding minimum spanning trees more efficiently for tile-based phase unwrapping. Measurement Science and Technology, 2006, Volume 17, Issue 6, pp1428-1435<\/dc:identifier><dc:identifier>0957-0233<\/dc:identifier><dc:identifier>http:\/\/dx.doi.org\/10.1088\/0957-0233\/17\/6\/022<\/dc:identifier><dc:identifier>http:\/\/dspace.lib.cranfield.ac.uk\/handle\/1826\/1416<\/dc:identifier><dc:language>en_UK<\/dc:language><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:0957-0233","0957-0233"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2006,"topics":["phase unwrapping","minimum spanning tree","graph theory"],"subject":["Article"],"fullText":"Finding minimum spanning trees more efficiently for tile based phase \nunwrapping \n \nFiras Al-Sawaf and Ralph P. Tatam \n \nOptical Sensors Group \n \nCentre for Photonics and Optical Engineering \n \nSchool of Engineering \n  \nCranfield University \n  \nCranfield,  \n \nBedford MK43 OAL \n \n \n \nTel: 01234 745360 \n \nFax: 01234 752452 \n \nEmail: r.p.tatam@cranfield.ac.uk \n \nShort Title:  Efficient minimum spanning trees for tile based phase unwrapping \n \n \nPACS: 02.10.0x, 42.30.Ms,  \n \nKeywords: Phase unwrapping, minimum spanning tree, graph theory \n \n \n Abstract \nThe tile-based phase unwrapping method employs an algorithm for finding the \nminimum spanning tree (MST) in each tile. We first examine the properties of a tile\u2019s \nrepresentation from a graph theory view point, observing that it is possible to make \nuse of a more efficient class of MST algorithms. We then describe a novel linear time \nalgorithm which reduces the size of the MST problem by half at the least, and solves \nit completely at best. We also show how this algorithm can be applied to a tile using a \nsliding window technique. Finally, we show how the reduction algorithm can be \ncombined with any other standard MST algorithm to achieve a more efficient hybrid, \nusing Prim\u2019s algorithm for empirical comparison and noting that the reduction \nalgorithm takes only 0.1% of the time taken by the overall hybrid. Deleted: only \n 1. Introduction \nAutomatic fringe analysis techniques, such as the Fourier transform [1, 2] and phase \nstepping1 [3- 6], produce phase information which is inherently wrapped onto the \nrange -\u03c0 to \u03c0. The restoration of the unknown multiple of 2\u03c0 is called phase \nunwrapping, and is central to most such algorithms [7]. \nPhase unwrapping techniques utilising the tiling approach and the minimum spanning \ntree (MST) method [9-13] have been shown to have good noise immunity and \nprevention of error propagation. This is mainly due to dividing the wrapped phase \nmap into tile-like regions. Each tile is then unwrapped independently, and the tiles are \nfinally assembled to obtain the unwrapped phase map. The path for unwrapping in \neach tile is selected in a way which minimises the probability of error. This is \nachieved by choosing a path whose total phase difference is minimal. Identifying such \na path is in fact the MST graph theory problem. Prim\u2019s algorithm [14] is a traditional \nway of solving the MST problem, and is employed by tile phase unwrapping [15]. \nFinding a MST for each tile is a computationally demanding, and impacts the \nefficiency of the overall unwrapping algorithm. We first examine how phase \ninformation in a tile is converted into a weighted graph, and how the topology of such \na graph enables the use of a more efficient class of MST algorithms. We then describe \nan algorithm tailored specifically to a tile\u2019s topology. We show that it is linear time \nefficient, O(n), where n is the number of pixels in a tile, and that it can be used to \nreduce the size of the MST problem by half or more. We then show how it can be \napplied to a tile using an image processing sliding window technique. Finally, we \ndiscuss how any chosen MST algorithm could be attached to ours, creating an \nefficient hybrid. We use Prim\u2019s algorithm for empirical comparison. \n2. Tile representation from a graph theory perspective \nWe give here a brief summary of the relevant graph theory principles [16,17,18,19] \nwhich are relied upon in the descriptions given in the subsequent sections. \n2.1 Graphs and trees \nA graph,  \nFigure 1 (a), can be described as G = [n, e], and consists of a vertex set n connected \nby an edge set e. \n \n    \na. graph b. tree c. weighted graph d. MST \n \nFigure 1 Graph, trees and MST \n \nA graph is said to be connected if each of its vertices is connected to another vertex \nby at least one edge. A spanning tree,  \n                                                 \n1 Phase stepping is also known as quasi-heterodyning. \nFormatted: Normal, Left\nFormatted: Normal, Left\nDeleted:  \nDeleted: \u00b6\nFigure 1\nFigure 1 (b), is an acyclic connected graph. This means that each vertex in a tree is \nconnected to any other vertex via one path only. Thus, an n vertex tree contains n -1 \nedges. A weighted graph,  \nFigure 1 (c), is a graph whose edges have a cost associated with each edge. Finding a \nminimum spanning tree (MST) of such a graph is finding a tree whose total edge cost \nis minimal,  \nFigure 1 (d). \n2.2 Tile graph topology \nThe tiling method of phase unwrapping commences by dividing the wrapped phase \nmap image into tiles. The pixels of a tile become the vertices of the graph. These are \nconnected by edges in a grid fashion, as shown in Figure 2. Each edge is then \nassigned a weight equal to the absolute phase difference of the two pixels it connects. \n \n \nFigure 2 A Topology of a tile\u2019s graph \n \nDepending on the application, there are often minimum and maximum tile sizes \nbetween which the tiling method provides the best results. There are various \nconsiderations taken into account when choosing the tiles\u2019 size, such as the expected \nfringe density and the size of fringe breaks. This is mainly to ensure that tiles are not \nso small that they often fall in between broken edges, and not so large so that they \noften contain sections of different fringes [15].  \nWe note that there is another consideration in relation to the maximum tile size from a \ncomputational point of view. Some MST algorithms, such as Prim\u2019s [14], have a non-\nlinear relationship with the number of vertices (pixels) in the graph. Depending on the \nparticular implementation, this could be O(n2) in the worst case, for a tile of n vertices \n(pixels). This could impose a further restriction on computational performance \nsensitive applications, limiting the maximum usable size for a tile. \n3. Finding a minimum spanning tree \nThe time complexity of an MST algorithm is expressed using the number of its edges, \ne, and vertices, n. Prim O( n2) [14], can be implemented more efficiently with \nmodification to achieve O(e log n) [20, 21]. It can be further improved by the use of \npriority queues to O(e + n log n) [22]. \nThe best deterministic algorithms are near linear time [23-27]. Linear time efficiency \nO(e) was achieved by using a randomised method [28], employing an O(e) MST \nverification algorithm [29]. \nHowever, we note that the actual topology of a tile\u2019s graph is planar. A planar graph is \na graph which can be drawn in a single plane, such that none of its edges intersect. \nThis allows for the use of deterministic and linear time MST algorithms [30, 31]. \nOne of the properties of any connected planar graph, G, is that it is possible to \nconstruct another planar graph, G*, so that each face of G corresponds to a vertex in \nG*. Each pair of faces in G having an edge in common, has a corresponding edge in \nG* crossing it. G* is called a dual graph of G,  \nFigure 3.  \n \nFormatted: Normal, Left\nDeleted: \u00b6\nFigure 1\nDeleted: \u00b6\nFigure 1\nDeleted: \u00b6\nFigure 1\nDeleted: ve\nDeleted: \u00b6\nDeleted: Figure 3\n \nFigure 3 A graph G (solid edges and vertices) and it dual G* \n \nDual graphs have interesting properties, stemming from the fact that each cycle-set of \nG\u2019s edges is also a cut-set of G*, and vice versa. Matsui [31] relies on these properties \nto construct a linear time MST algorithm O(e + n), noting that a maximum edge of a \nvertex in G* can be ruled out of G\u2019s minimum spanning tress, and a minimal edge of \na vertex in G can be ruled out of G*\u2019s maximum spanning tree. \n3.1. Reducing the problem\u2019s size \nTheoretically, it is only possible to improve on O(n) efficiency by having prior \nknowledge of the MST itself. This is the case for MST maintenance algorithms which \ncan carry out a single update, such as single weight change, in O( e )  [32], and in \nO(log n) for planar graphs [33, 34]. \nAlthough prior knowledge of the topology of a graph may not improve on O(n), it can \nhelp to improve the overall efficiency of the algorithm in empirical terms. This could \nbe by reducing the total number of times the edges and vertices are handled, or \nminimising the total number of edge weight comparisons necessary. \n \nWe describe a novel linear time O(n) algorithm which takes advantage of the prior \nknowledge of a tile\u2019s graph topology to reduce its size from G(n, e) to somewhere \nbetween zero, at best, and G[n\/2, e\/2] at the very most. \nThis has the effect of reducing the size of the problem needed to be solved by the \nunderlying MST algorithm of choice. \nImage processing algorithms often employ a sliding window technique to apply their \nvarious operations to the image in question. Similarly, we show how our algorithm \ncan be applied to a tile using a sliding window.  \nFor clarity, we start by describing the four steps of the algorithm separately. The \ndiscrete description is used subsequently for time-performance analysis, and for \ndescribing the sliding window operations. \n4. Algorithm fundamentals and performance analysis \n4.1 Initial state \nThe tile, Figure 2, can have any number of rows and columns of vertices. \nEach corner vertex has two edges, the minimum of which can be immediately ruled in \nthe MST (if not, the resultant tree is either disconnected or is not minimum). \nProcessing the four corners in this way can be carried out in constant time O(1), \nregardless of the number of vertices, n. \n \nFigure 4 illustrates the representation of a tile\u2019s graph G, and its dual G*, once the \ncorners have been processed. \n \nFormatted: Normal, Left\nDeleted: \u00b6\nFigure 4\n \nFigure 4 A tile\u2019s graph G (solid edges and vertices) and it dual G*. VO is a G* vertex  \ncorresponding to the outer face of G2. \n \nThe dual graph G* need not be constructed in practice, and is only shown here to help \nclarify the underlying interactions of the various steps of the algorithm. \n \nWe observe that at this initial state, due to prior knowledge of the topology, the graph \nfulfils the following criteria: \n \na Both G[n, e] and G*[n*, e*] are connected and naturally planar \nb G and G* have n vertices each \nc e = e*, n \u2248  n* and the size of e approaches the size of 2n. \nd Neither G or G* have two vertices connected to each other by more than one \nedge (this is secured by pre-processing the corners, which removes such edges \nfrom G*) \ne Each vertex3 in G and G*, has a maximum of 4 edges. \nf Any G vertex can be picked from this initial state of G and processed \nindependently, and its minimum edge can be ruled in the MST. \ng Any G* vertex can be picked from this initial state of G* and processed \nindependently. Its maximum edge can be ruled out of the MST. \nh Any edge of G and G* can be processed in the same independent way as \ndescribed in f or g, unless one or more of its edges has already been ruled in or \nout by processing an adjacent vertex in the same graph. \n4.2 Step 1 \u2013 Process G vertices alternately, ruling in one edge per vertex \nThe alternate fashion in which the G vertices are targeted,  \nFigure 5 (a), ensures that they can be processed independently (criteria f and h). In \neffect, the G vertices which are not being targeted act as an isolating barrier. \n \n                                                 \n2 A graph\u2019s outer face is also known as the unbounded or infinite face. \n3 As G*\u2019s most outer vertex (VO) does not satisfy this criterion, it will not be relied upon for any of the \nsteps of the algorithm. Although the edges of VO will still be processed by the algorithm, this will be \ndone in the context of the other vertices in G* which are connected to VO. Therefore, all references to \nG* vertices from this point on shall implicitly exclude VO. \nFormatted: Normal, Left\nDeleted: \u00b6\nFigure 5\n \na. G vertices targeted by step 1 b. G* vertices targeted by step 2 \n  \n \nc. G vertices targeted by step 3 d. G* vertices targeted by step 4 \n \nFigure 5 Targeted vertices (shaded) \n \nEach vertex has a maximum of four edges, therefore the minimum edge of each of \nthese vertices can be ruled in the MST in O(1). \n4.2 Step 2 \u2013 Process G* vertices alternately, ruling out one edge per vertex \nEach targeted G* vertex,  \nFigure 5 (b), has a maximum of four edges, therefore the maximum edge of each of \nthese vertices can be found in O(1). This maximum edge of G* crosses an edge in G, \nwhich in turn can be ruled out from the MST. \nIn a similar way to step 1, G* vertices which are targeted can be processed \nindependently. \n4.3 Step 3 \u2013 Ensure each remaining G vertex is connected to at least one \nruled-in edge \nEach of the remaining G vertices,  \nFigure 5 (c), is examined in turn. If it is has an edge which has been already ruled in \nthe MST, then no further processing is required. Otherwise, it must still have one or \nmore edges which have not been processed, because step 2 could not possibly have \ndeleted all of its edges. This also means that such a vertex can still be processed \nindependently (criteria f and h), and therefore we can rule in its minimum edge in \nO(1). \n4.4 Step 4 - Ensure each remaining G* vertex is connected to at least one \nruled-out edge \nThe remaining G* vertices,  \nFormatted: Normal, Left\nFormatted: Normal, Left\nFormatted: Normal, Left\nDeleted: \u00b6\nFigure 5\nDeleted: \u00b6\nFigure 5\nFigure 5 (d), are targeted by this step. It can be shown, using argument similar to \nthose of step 3, that each of the targeted vertices in G* either has a ruled out edge (due \nto step 2), or, otherwise, its maximum edge can be found in O(1). This maximum \nedge of G* crosses an edge in G, which in turn can be ruled out from the MST. \nThe algorithm ends when step 4 has completed. At this point, none of the vertices in \neither G or G* can automatically satisfy criteria f, g or h by relaying on a prior \nknowledge of the initial state. \n5. Problem reduction analysis \nThe consequence of steps 1 and 2 is that n\/2 edges are ruled in the MST and n\/2 edges \nare ruled out. \nThis means that the original G[n, e] graph is now reduced to G[n\/2, e\/2]. \nThe ruled out edges can be clearly dismissed from the graph. Each ruled in edge, on \nthe other hand, serves to fuse the two vertices it connects into one vertex. \nThe remaining (i.e. neither ruled in or out) edges of the original two vertices now \nbecome incident on the fused vertex. \n \nA B\nAB\n \nThe dashed edge is contracted. The union of \nedges incident onto A and B becomes incident \non the merged vertex, AB. \n \nFigure 6 Edge contraction \n \nThis process is known as edge contraction,  \nFigure 6, and naturally results in the reduction of the number of the vertices in the \ngraph. \n \nIf the algorithm were only to perform steps 1 and 2, it would still be guaranteed to \nreduce the original problem by half. This gives the algorithm the worst case reduction \nbound. Steps 3 and 4 of the algorithm may improve on the above reduction, but are \nnot guaranteed to do so; it is possible that by some chance every non-targeted vertex \nhas one of its edges contracted or removed by an adjacent targeted vertex. In this case \nsteps 3 and 4 would not perform any further edge contraction or deletion. \nAt the other extreme, steps 3 and 4 could find n\/2 edges to contract, therefore \ncompletely solving the MST problem. This is because an MST has exactly n-1 edges \nto be identified (i.e. ruled in or contracted). \nFormatted: Normal, Justified\nDeleted: \u00b6\nFigure 5\nDeleted: reaming \nDeleted: \u00b6\nDeleted: Figure 6\nDeleted: \u00b6\n5.1 Edge contraction and dual graph construction \nThe edge contraction, described above, serves to illustrate the extent of the problem \nreduction. Explicit edge contraction as such, however, need not be performed by the \nalgorithm for the above stated reduction in problem size to be realised. The same \napplies to the construction of the dual graph G*. \nWhether or not edge contraction or G* construction need to be performed, solely \ndepends on the nature of the algorithm chosen to find the remaining edges of the \nMST. Matsui [31], for example, requires G*, and avoids edge contraction by \nemploying a constant time bucketing strategy to keep track of the vertices which are \nless than four-connected. By contrast, algorithms such as [24, 28] do depend on edge \ncontraction, but do not employ a dual graph as they were not specifically aimed at \nplanar graphs. Such distinction is less obvious in the cases of some algorithms [35, \n36, 23] which although make use of edge contraction, their respective asymptotic \ncomplexity does not rely on such use. \n5.2 Time performance \nSteps 1 and 2 visit n\/2 G vertices, and carry out each operation in O(1) constant time. \nSimilarly, steps 3 and 4 visit n\/2 G vertices, carrying out each operation in O(1). \nTherefore the algorithm performs all of its operations in O(n) linear time. \n6. A windowing approach \nWe show here how the various steps of the algorithm are combined and applied to a \ntile via a sliding window. In addition, we show how the algorithm can be performed \nwithout the construction of a dual graph G*, and how edges to be ruled out can be \ndirectly processed in the context of G. \nThe algorithm is carried out in two phases, processing n\/2 vertices in each phase. \n6.1 Phase 1 \u2013 Combining steps 1 and 2 \nOver all, phase 1 visits n\/2 vertices.  \nFigure 7 shows how each of the vertices and edges targeted by steps 1 and 2 can be \nprocessed using a sliding window. When the window is in position \u201ca\u201d it performs \nstep 1 on vertex a, ruling in the minimum of a1, a2, a3 and a4. It then performs step 2, \nruling out the maximum of a2, a3, a5 and a6. The window is then moved to position \n\u201cb\u201d and the same process is similarly repeated, and so on. \n \n \nFigure 7 The sliding window visiting position \u201ca\u201d then sliding to position \u201cb\u201d. \n \nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Font: (Default)\nTimes New Roman\nFormatted: Normal, Justified\nDeleted: Although t\nDeleted: \u00b6\nFigure 7\nOperations of Steps 1 and 2 can in fact be carried out in either order. Each sliding \nwindow operation will process one vertex and a maximum of 6 edges, and is \nguaranteed to rule in one edge and rule out another. \n6.2 Phase 2 \u2013 Combining steps 3, and 4 \nPhase 2 visits the remaining n\/2 vertices using the same window shape,  \nFigure 7. The operations of steps 3 and 4 can be carried out, in either order, over the \ntargeted six edges. During this phase there are no guarantees as to the additional \nnumber of edges to be ruled in or out, as discussed in a pervious section. \n7. Hybrid algorithms \nWe have shown how our algorithm can be used to reduce the size of the problem to be \nfound by the MST algorithm of choice. We consider here a selection of MST \nalgorithm, with no loss to generality, and how they can be applied to find the \nremainder of the solution. \n7.1 Matsui [31] \nMatsui is perhaps the best choice of algorithm for the problem; it is linear time \nefficient, relatively straightforward to implement, and is specifically targeted at planar \ngraphs. \nIt is theoretically possible to implement Matsui\u2019s algorithm without constructing G*. \nOn the other hand, G* provides for a more straightforward implementation. \nRegardless of whether G* is constructed or not, the reduction algorithm needs to keep \ntrack of the number of edges incident on G and G* vertices, as Matsui relies on this \ninformation to pick the vertex to be processed next. \nThis is an additional O(1) operation and does not impact the linearity of the reduction \nalgorithm. \nBoth the reduction algorithm and Matsui\u2019s are linear time efficient, and the resulting \nhybrid is dominated by Matsui\u2019s O(e + n) efficiency. \n7.2 Kruskal [37] \nKruskal normally performs worse than Prim [14] in O(e log e). This is mainly due to \nits stipulation that all the edges need to be sorted at the start of the algorithm. \nThis means that even the edge which are eventually ruled out are also sorted, which \nresults in efficiency loss. \nThe reduction algorithm decreases the number of edges in the graph from 2n to n or \nless. This means that a Kruskal hybrid can be then applied in O(n log n), which is \ncomparable to using Prim\u2019s algorithm without reduction. \n7.3 Randomised Karger et al [28] \nWhen Karger is applied to the problem remaining after reduction, it randomly selects \nhalf of the remaining n (or less) edges (those neither ruled in or out) to connect the \nMSF\u2019s into a candidate MST. It then uses a linear time O(e) verification algorithm \n[29] to rule some of these selected edges out of the MST. The process is repeated \niteratively until enough edges have been ruled out or a true MST has been identified. \nThe performance of Karger is shown to be exponentially likely O(e), and thus the \nhybrid is equally exponentially likely O(n). \nFormatted: Normal, Justified\nDeleted: \u00b6\nFigure 7\n7.4 Prim [14] hybrid and empirical comparison \nAlthough Prim algorithm is not linear, it is certainly worth consideration as it is one of \nthe simplest to understand and implement of the minimum spanning tree algorithms \nand is commonly available through most graph theory related computer programming \nlibraries. \nSignificantly, Prim\u2019s is also the algorithm chosen for the tile-based method in its \noriginal implementation by Judge [15]. \nTherefore, we give Prim\u2019s algorithm an empirical treatment as well as theoretical. \n8. Theoretical analysis \nThe reduction algorithm need not carry out any additional chores in addition to \nmarking edges when it rules them in or out of the MST. \nThe ruled out edges help make Prim more efficient by reducing the number of edges it \nneeds to search at each iteration to identify the next edge to connect the next vertex to \nthe MST. \nThe edges already ruled in by the reduction algorithm effectively define minimum \nspanning forests (MSF) of vertices. Prim then adds one collection of vertices in a \nMSF in one of its iterations (as opposed to the usual single vertex), which improves \nits overall performance. Prim can thus be used to connect the MSFs identified by the \nreduction algorithm, which amounts to the connected MST. \nPrim\u2019s algorithm is not linear time efficient, therefore its time complexity dominates \nthe overall performance of the hybrid algorithm. \n8.1 Empirical results \nFor the empirical analysis of our reduction algorithm, we chose to use the Boost \nGraph Library (BGL) [38] for the following reasons: \n\u2022 Its credibility. After the Standard Template Library which it extends, the \nBoost Library is perhaps the most respected in the C++ domain. The BGL in \nparticular is very highly acclaimed. \n\u2022 Its generality, wide adoption and applicability. The BGL is rapidly becoming \nthe C++ graph library of choice for industry and academia alike. \n\u2022 It supports an optimised version of Prim\u2019s algorithm with a well documented \nO(e log n) efficiency. \n\u2022 Its data structures and algorithms have been designed, implemented, analysed \nand tested sufficiently rigorously for their respective time efficiency \ncharacteristics to be well understood and fully documented. \nWe implemented our reduction algorithm using the same components which the \nBGL uses for its native Prim\u2019s implementation. \n \nTile edge size Vertex count \nTime \nwithout \nreduction \nTime with \nreduction \nTime for \nreduction \n64 4,096 31 16 0.016 \nDeleted:  \nDeleted: \u00b6\n128 16,384 47 16 0.016 \n256 65,536 156 110 0.094 \n512 262,144 843 453 0.438 \n1,024 1,048,576 3,547 2062 2.031 \n2,048 4,194,304 3,0781 2,0984 20.781 \nAll times shown are in milliseconds. Data obtained using the Boost library \nversion 1.31.0, compiled with Microsoft\u00ae Visual Studio .Net 2003, on a \nMesh\u00ae Computers Plc personal computer: Intel\u00ae Pentium\u00ae 4 CPU 3.0 \nGHz, RAM 1 Gigabyte, Microsoft\u00ae XP Home Edition 2002 \u2013 service pack \n2. \n \nTable 1 Worst-case analysis of the enhanced time performance due to the \nreduction algorithm, in tabular format \n \nGraphs with tile-topology were constructed and assigned random weights using a \npseudo-random number generator. The range of edge weights used was 0 \u2013 255, \ndepicting the intensity range of an 8-bit digital camera.  \nThe analysis results are shown in  \nTable 1 and  \nFigure 8, and are discussed in the following section. \n \nFormatted: Normal, Justified\nDeleted: \u00b6\nDeleted: Table 1\nDeleted: \u00b6\nDeleted: Figure 8\nEm\npi\nric\nal\n a\nna\nly\nsi\ns \nof\n P\nrim\n-R\ned\nuc\ntio\nn \nhy\nbr\nid\n05101520253035\n0\n50\n0\n1,\n00\n0\n1,\n50\n0\n2,\n00\n0\n2,\n50\n0\nN\num\nbe\nr o\nf p\nix\nel\ns \nal\non\ng \non\ne \ned\nge\n o\nf t\nhe\n s\nqu\nar\ne \ntil\ne\nTime (seconds)\nTi\nm\ne \nw\nith\nou\nt r\ned\nuc\ntio\nn\nN\nor\nm\nal\nis\ned\n e\n lo\ng \n(n\n)\nTi\nm\ne \nw\nith\n re\ndu\nct\nio\nn\nTi\nm\ne \nfo\nr r\ned\nuc\ntio\nn\n \n \nFigure 8 Worst-case analysis of the enhanced time performance due to the \nreduction algorithm, in chart format \n \n8.1 Empirical worst-case analysis \nPhase 1 of our reduction algorithm is guaranteed to reduce the problem\u2019s size by one \nhalf. \nFurther reduction by phase 2 is certainly possible, however it is not guaranteed, and \nits extent is likely to depend on the application in question. \nFurthermore, the reduction algorithm is linear by nature. Hence, an estimate of the \ntime performance of phase 2, for a given reduction percentage, can be reliably \nprojected from the analysis results obtained for phase 1. \nTherefore, we confined our empirical analysis to phase 1 of the reduction algorithm, \nand the results of which are shown in the previous section,  \nFigure 8. \nAnalysis of tile edge size of less than 64 did not produce meaningful time \nmeasurement: Most frequently, the time obtained was zero, indicating that the 1 \nmillisecond resolution of the system clock does not provide sufficient resolution for \nsuch measurements. \nAt the other end of the spectrum, a tile edge size of 2048 (or 4,194,304 vertices) \nperformed less well than the general trend would have otherwise suggested. This is \nperhaps due to other factors coming into play, such as hard-disk cashing4. \nIn general, the results obtained empirically confirm the theoretical performance \nanalysis findings. \nIt is also interesting to note that the reduction algorithm generally takes 0.1% of the \ntotal time taken by the overall hybrid, despite the fact that it reduces the problem\u2019s \nsize by 50%. \nAlthough the reduction algorithm halves the problem size, the overall time taken by \nthe hybrid is more than half of that taken by the algorithm without reduction. This is \ndue to the inherent non-linearity of Prim\u2019s algorithm. \n9. Conclusions \nWe have shown how the prior knowledge of a tile\u2019s graph can help reduce the size of \nits MST problem by at least one half in linear time. In the best case the problem is \ncompletely solved. It would be interesting to learn the probability distribution of the \nsize of reduction for a typical tile, and how this knowledge may further enhance the \noverall efficiency of the unwrapping algorithm. \n \nIt would be interesting to find out if further performance gains can be attained by the \nrelaxation of the criterion of the identification of the unwrapping path from an \n\u201cabsolute minimum\u201d to \u201cminimal. If this was the case, it would be then possible to \nmerely connect any disjoints in the path identified by the problem reduction \nalgorithm, without the need to apply an additional minimum spanning tree algorithm. \nOne could then consider the noise immunity vs. the computational cost achieved by \nsuch a partial approach, which ultimately leads to establishing a typical estimate for \nthe computational performance cost vs. the noise immunity gain for a given \napplication. \nReferences \n1 M Takeda, H Ina and S Khobayashi, S Fourier-transform method of fringe pa\nanalysis for computer based topography and interferometry, J. Opt. Soc. Am.\n                                                 \n4 It was observe that hard-disk activity become increasingly pronounced during the progress of this \nparticular tile size. \nFormatted: Normal, Justified\nFormatted: Font: (Default)\nTimes New Roman, 12 pt\nDeleted: \u00b6\nFigure 8\nDeleted: a \nDeleted: p\n(1981), 156-60. \n2 W W Macy Jr., Two-dimensional fringe pattern analysis. Appl. Optics, 22 (23), \n(1983). \n3 B Breuckmann and W Thieme, Computer-aided analysis of holographic \ninterferograms using the phase shift method. Appl. Optics, 24 (14), (1985), \n2145-49. \n4 R Thalman and R Dandliker, High-resolution video processing for holographic \ninterferometry applied to contouring and measuring deformations. SPIE \nECOOSA, Vol. 429, Amsterdam, (1984). \n5 B Breuckmann and W Thieme, Computer-aided analysis of holographic \ninterferograms using the phase shift method. Appl. Optics, 24 (14), (1985), \n2145-49. \n6 R Dandliker and R Thalmann, Heterodyne and quasi-heterodyne holographic \ninterferometry,Optical Engng, 24(5), (1989), 824-31. \n7 J M Huntley and H Saldner, Temporal phase unwrapping algorithm for \nautomated interferogram analysis, Applied Optics, 32(17), (1993), 3047-52 \n8 G T Reid, Automatic fringe analysis - a review, Optics and Lasers in \nEngineering, 7, (1986\/7), 37-68. \n9 A Ettemeyer, U Neupert, H Rottenkolber and C Winter, Schnelle und robuste \nbildanalyse von streifenmustern - ein wichtiger schritt der automation von \nhlografischen profprozessen, Proc. 1st int. Workshop on automatic processing of \nfringe patterns. (1989), 23-31. \n10 D P Tower, T R Judge and P J Bryanston-Cross, A quasi-heterodyne holograph \ntechnique and automatic algorithms for phase unwrapping, SPIE 1163, 1989. \n11 D P Tower, T R Judge and P J Bryanston-Cross, Analysis of holographic fringe \ndata using the dual reference approach. Opt. Engng, 30 (4), (1991), 452-60. \n12 D P Tower, T R Judge and P J Bryanston-Cross, Automatic interferogram \nanalysis techniques applied to quasi-heterodyne holography and ESP. Optics and \nLasers in Engng, 14, (1991), 239-81. \n13 T R Judge, T R Quan and P J Bryanston-Cross, Holographic deformation \nmeasurements by Fourier reansform technique with automatic phase \nunwrapping. Opt Engng, 31 (3), (1992), 533-43. \n14 R C Prim, Shortest connection networks and some generalisations, Bell Systems \nTech. J., 36, (1957), 1389-1401. \n15 T R Judge, Quantitative digital image processing in fringe analysis and particle \nimage velocimetry, PhD thesis, Warwick university (1992) \n16 C Berge, Graphs and Hypergraphs, North-Holland, Amsterdam, 1973. \n17 J A Bondy and U S R Murty, Graph theory with applications, North-Holland, \nNew York, 1976. \n18 R G Busacker and T L Saaty, Finite graphs and networks - an introduction with \napplications, McGraw-Hill, New York, 1965. \n19 F Harry, Graph theory, Addison-Wesley, Reading, MA, 1969. \n20 R E Tarjan, Data structures and network algorithms, Soc Industrial App Math, \nChap 6 (1993), 72-77 \n21 A Kerschenbaum and R Van Slyke, Computing minimum spanning trees \nefficiently, Proc 25th Ann Conf ACM, (1972), 518-527 \n22 B M E Moret and H D Shapiro, An empirical analysis of algorithms for \nconstructing a minimum spanning tress, Lecture notes in computer science 519, \n(1991), 400-411 \n23 M L Fredman and R E Tarjan, Fibonacci heaps and their use in improved \nnetwork optimisation algorithms, J ACM, 34 (3), (1987), 596-615 \n24 H N Gabow, Z Galil, T Spencer and R E Tarjan, Efficient algorithms for finding \nminimum spanning trees in undirected and directed graphs, Combinatorica, 6, \n(1986), 109-122 \n25 A C Yao, An O(|E| log log|V|) algorithm for finding minimum spanning trees, \nInformation Processing Letters, 4 (1), (1975), 21-3. \n26 B Chazelle, A minimum spanning tree algorithm with inverse-Ackermann type \ncomplexity, J ACM, 47, (2000), 1028-1047. \n27 S Pettie, Finding minimum spanning trees in O(m\u03b1(m, n)) time, Tech Rep TR99-\n23, Univ Texas at Austin, 1999. \n28 D R Karger, P N Klein and R E Tarjan, A randomised linear-time algorithm to \nfind minimum spanning trees, J. Assoc. Comput. Machinery, 42 (2), (1995), \n321-28. \n29 V King, A simpler minimum spanning tress verification algorithm, Proc. \nWorkshop on algorithms and data structures, 1995 \n30 D Cheriton and R E Tarjan, Finding minimum spanning trees, SIAM J. Comput., \n5 (4), (1976), 724-42. \n31 T Matsui, The minimum spanning tree problem on a planar graph, Discrete \nApplied Mathematics, 58, (1995), 91-4. \n32 G Frederickson, Data structures for on-line updating of minimum spanning tree, \nwith applications, SIAM J Comp. 14 (4), (1985), 781-798 \n33 D Eppstine, G F Italiano, R Tamassia, R E Tarjan, J Westbrook and M Yung, \nMaintanace of minimum spanning forest in a dynamic planar graph, Proc 1st \nACM\/SIAM Symp. Discrete Algorithms, (1990), 1-11 \n34 H N Gabow and M Stallman, Efficient algorithms for graphic matroid \nintersection and priority, Proc 12th Int. Conf Automata, Languages, and \nProgramming, Springer-Verlag LNCS, 194, (1985), 210-220 \n35 O Boruvka, O jistem problemu minimalnim, Praca Morvavke Prirodovedecke \nSpolecnosi, 3, (1926), 37-58 (Czech with summary in German, translated in \n[36]) \n36 J Nesetril, E Milkova and H Nesetrilova, Otakar Boruvka on minimum spanning \ntree problem, Discrete Mathematics, 233 (1-3), (2001), 3-36 (English translation \nof [35]) \n37 J B Kruskal, On the shortest spanning sub-tree of a graph and the travelling \nsalesman problem, Proc. Amer. Math. Soc., 7, (1956), 48-50. \n38 J G Siek, L Q Lee and A Lumsdaine, The boost graph library, Addison-Wesley, \n2002. \n \n"}