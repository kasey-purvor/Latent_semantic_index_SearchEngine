{"doi":"10.1109\/CCC.2001.933873","coreId":"66624","oai":"oai:dro.dur.ac.uk.OAI2:673","identifiers":["oai:dro.dur.ac.uk.OAI2:673","10.1109\/CCC.2001.933873"],"title":"Tree resolution proofs of the weak pigeon-hole principle.","authors":["Dantchev, S..","Riis, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2001-06","abstract":"We prove that any optimal tree resolution proof of PHPn m is of size 2&thetas;(n log n), independently from m, even if it is infinity. So far, only a 2\u03a9(n) lower bound has been known in the general case. We also show that any, not necessarily optimal, regular tree resolution proof PHPn m is bounded by 2O(n log m). To the best of our knowledge, this is the first time the worst case proof complexity has been considered. Finally, we discuss possible connections of our result to Riis' (1999) complexity gap theorem for tree resolution.\\u","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66624.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/673\/1\/673.pdf","pdfHashValue":"0550fe451d9597f140d40a3eb00ac23b82c87ba4","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:673<\/identifier><datestamp>\n      2010-11-01T15:27:02Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Tree resolution proofs of the weak pigeon-hole principle.<\/dc:title><dc:creator>\n        Dantchev, S..<\/dc:creator><dc:creator>\n        Riis, S.<\/dc:creator><dc:description>\n        We prove that any optimal tree resolution proof of PHPn m is of size 2&thetas;(n log n), independently from m, even if it is infinity. So far, only a 2\u03a9(n) lower bound has been known in the general case. We also show that any, not necessarily optimal, regular tree resolution proof PHPn m is bounded by 2O(n log m). To the best of our knowledge, this is the first time the worst case proof complexity has been considered. Finally, we discuss possible connections of our result to Riis' (1999) complexity gap theorem for tree resolution.\\ud\n<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n         16th Annual IEEE Conference on Computational Complexity, 18-21 June 2001, Chicago, Illinois ; proceedings. . New York: IEEE, pp. 69-77<\/dc:source><dc:date>\n        2001-06<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:673<\/dc:identifier><dc:identifier>\n        doi:10.1109\/CCC.2001.933873<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/673\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/CCC.2001.933873<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/673\/1\/673.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2001 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2001,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n01 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nDantchev, S.. and Riis, S. (2001) \u2019Tree resolution proofs of the weak pigeon-hole principle.\u2019, in 16th Annual\nIEEE Conference on Computational Complexity, 18-21 June 2001, Chicago, Illinois ; proceedings. New York:\nIEEE, pp. 69-77.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/CCC.2001.933873\nPublisher\u2019s copyright statement:\n2001 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nTree Resolution proofs of the Weak Pigeon-Hole Principle \nStefan Dantchev 1)2 Sgren Riis2 \n~BRICS *\nUniversity of Aarhus \n2Dept. of Computer Science \nQueen Mary, University of London \ndantchev @dcs.qmw.ac.uk smriis @ dcs.qmw.ac.uk \nAbstract \nWe prove that any optimal tree resolution proof of \nPHP,\" is of size 2R(n'ogn),  independently from m, even \nif it is in3tzity. So fac only a 2n(n)  lower bound has been \nknown, in the general case. We also show that an): not \nnecessarily optimal, regular tree resolution proof PHP,\" \nis bounded by 2\u00b0(n10g ml .  To best of our knowledge, this is \nfor the first time, the worst case proof complexity is consid- \nered. Finally, we discuss possible connections of our result \nto Riis' complexity gap theorem for  tree resolution. \n1 Introduction \nPigeon-Hole Principle ( P H P )  is probably the simplest \nand at the same time the most widely used combinatorial \nprinciple. In its classical formulations, i t  states that there is \nno injective map from a finite m-element set to a finite n- \nelement set if 711 > n. PHPA\" is very intuitive for the hu- \nman way of thinking, and it  is also easily provable within set \ntheory.'This is however not the case for some propositional \nproofsystems. In his seminal paper [6], Haken showed that \nany resolution proof of PHPc+' is of size 2\"(\"). His proof \nhas been simplified and generalised in [ 161, [4], [ 2 ] ,  [I]. For \nquite a while, the best known result had been a 2R(n2\/m) \nlower bound on any resolution proof of PHP,\", thus hav- \ning left the case m = R (n2\/ log n )  as an important open \nproblem in resolution proof complexity. A partial progress \nhad been made in [4], [9], [13], where lower bounds for \nsome restricted kind of resolution have been proven. Re- \ncently, a 2\"(7L') lower bound on any regular resolution proof \nof PHPF has appeared in [9]. Shortly after that, the prob- \nlem has finally been solved in [ 121 , where the latter result \nhas been extended to general, DAG, resolution. \nIn the paper, we consider tree resolution. Even though \nit  is one of the weakest propositional proof system, studied, \n'Basic Research I n  Computer Science, Centre of the Danish National \nResearch Foundation \nthe exact complexity of tree resolution proofs of PHP,\" \nhas not been known so far. A 2\"(n) lower bound was \nshown in [3], whereas one can construct only a 2\u00b0(\"'09n) \ntree proof by \"unfolding\" the 2O(\") DAG resolution proof \ngiven in the same paper. A 2\u00b0(\"'0gn) lower bound has been \nproved in [7 ] ,  but only for ordinary pigeon-hole principle, \ni.e. PHP;+l. \nThe first contribution (section 3) of our paper is closing \nthe gap. We prove a 2\"(n'ogn) lower bound on any tree \nresolution proof of PHP,\", independently from m, even \nif it is infinity. It is tight up to a constant factor in the ex- \nponent or, in other words, up to a polynomial transforma- \ntion. As a consequence, we get a super-polynomial separa- \ntion between DAG and tree resolution. We should however \nnote that much stronger, almost optimal, such separation is \nknown for another kind of tautologies. \nThe second contribution (section 4) of the paper is con- \nsidering the worst-case tree regular resolution proofs of \nPHP,\"\". To best of our knowledge, this is for the first time, \nthe worst case proof complexity is considered. We prove \nan upper bound of 2\u00b0(\"109m), which is non-trivial, as there \nare mn variables, and one can therefore expect the worst \ncase to be as bad as 2mn (we consider of course only proofs \nwhich do not contain vacuous weakening of axioms). This \nhas the following very interesting consequence. Consider \nP H P Z ,  where m is polynomially bounded by n, and de- \nnote it  by PHPEo'y(n). The optimal and the worst-case tree \nregular resolution proofs of P H P , ~ ' Y ( ~ )  are polynomially \nrelated, and so are any two random tree regular resolution \nproofs. This has an interesting consequence for automated \ntheorem proving, as it shows that there are natural problems \nfor which any DLL-proof search heuristic is as good as any \nother. \nFinally (section 5), we discuss some possible refine- \nments of Riis' complexity gap theorem for tree resolution, \nmotivated by our results. \n1093-0159\/01 $10.00 0 2001 IEEE \n69 \n2 Preliminaries that tree resolution refutations are equivalent to boolean de- \ncision trees. More precisely, given a refutation of the set \nof clauses, it can be viewed as a decision tree, solving the \nsearch problem and vice versa. The same result holds for \nregular resolution refutations and read-once branching pro- \ngrams. In contrast to these, general resolution proofs are \nnot equivalent to branching programs. As a matter of fact, \nthere is a polynomial-size branching program, solving the \nsearch problem corresponding to PHPz+\u2019 while all reso- \nlution refutations are of exponential size. \nEverywhere in the paper, we use the equivalence be- \ntween a tree resolution proof and a boolean decision tree. \nAll the proofs are, in fact, for decision trees, whereas the \nresults are stated in terms of tree resolution proofs. We only \nconsider tree resolution proofs that are regular. This is not a \nrestriction at all as in a decision tree, it does not make sense \nto query any variable more than once. On the other hand, if \nwe do not set this restriction, we would not be able to prove \nany upper bounds, as any given proof can be extended by \n(unbounded) number of \u201cmeaningless\u201d applications of the \nresolution rule. Thus, from now on, every time we say \u201ctree \nresolution\u201d, we really mean \u201ctree regular resolution\u201d. As al- \nready mentioned we do not allow proofs to contain vacuous \nweakening of axioms. In terms of decision trees a branch \nterminates as soon as a contradiction is reached. \nA very important technique, we use to prove lower \nbounds on proofs, is considering a proof as a Prover- \nAdversary game. It is first introduced in [ 1 13 and developed \nfurther in [lo] for general resolution. For tree resolution, \nit can be simplified, as done in [ 5 ] .  Adversary claims that \nthere is a satisfying assignment. Prover\u2019s task is to expose \nhim. In order to do that, Prover asks questions about vari- \nables according to a decision tree, she holds. Clearly, there \nis no way for Adversary to win the game. His task is there- \nfore to enforce a big enough subtree, contained in Prover\u2019s \ndecision tree. If he has a strategy, enforcing that, n o  matter \nwhat strategy Prover uses, we have a lower bound on the \ntree resolution refutations of the given set of clauses. \nWe first give some definitions. A literal is either a propo- \nsitional variable or the negation of a propositional variable. \nA clause is a set of literals. It is satisfied by a truth assign- \nment if at least one of its literals is true under this assign- \nment. A set of clauses is satisjiable if there exists a truth \nassignment satisfying all the clauses. \nAs we have already said, by PHP,\u201d we denote the claim \nthat there is no injective map from a set of size m to a set \nof size n ,  where m > n. We encode its negation as the \nfollowing set of clauses \n1. (pil,piz, . . . p i n )  f o r 1  < i < m  \n2. {pij,pik} for 1 5 i 5 m, 1 5 j < k 5 n \nWe allow m to be infinity. In this case, we have an infinite \nset of clauses, but all the clauses themselves are finite. Al- \nthough we consider the injective PHP, all the results and \nproofs from the paper remain valid for the bijective PHP,  \ntoo. \nResolution is a proof system designed to refute given set \nof clauses i.e. to prove that it is unsatisfiable. This is done \nby means of the resolution rule \nThus, we can derive a new clause from two other clauses \nthat contain a variable and its negation respectively. The \ngoal is to derive the empty clause from the initial ones. Any- \nwhere we say we prove some proposition, we mean that first \nwe take its negation in a clausal form and then resolution is \nused to refute these clauses. \nThere is an obvious way to represent every resolution \nrefutation as a directed acyclic graph whose nodes are la- \nbelled by clauses. The sources, i.e. the vertices with no in- \ncoming edges, are the initial clauses. The only sink, i.e. the \nvertex with no outgoing edges, is the empty clause. Every- \nwhere in the paper, we say \u201cthe size of a proof \u201d, we really \nmean the number of vertices in the corresponding graph. \nWe can now define two important restricted versions of \nresolution. First one is tree resolution when the graph is a \ntree or, in other words, we are not allowed to reuse any pre- \nviously derived clauses. The other one is regular resolution \nwhen every variable is resolved at most once along any path \nfrom a source to the sink. \nFor an unsatisfiable set of clause, we can consider the \nfollowing search problem: given a truth assignment, find a \nclause which is falsified under it. There is a close connec- \ntion between refuting an unsatisfiable set of clauses by some \nproof system and solving the corresponding search prob- \nlem within some model of computation. In [8], it is proven \n3 Optimal proofs \nWe first construct a 2 0 ( n \u2019 o g n )  tree resolution proof (in \nfact, boolean decision tree, as we have already mentioned), \nand we prove the corresponding lower bound. \nHere we fix some notations that we will use in both this \nand the next section. We denote the bigger, m-element set \nby M ,  and the other, n-element set by N .  We consider \nM and N as the two parts of the complete bipartite graph \nK,,,, and then there is 1-1 correspondence between the \nedges of the graph and variables p .  Thus we can speak about \na partial matching in Km,n instead of a partial function form \nM to N .  All the queries\/questions, from the decision tree, \nare about the edges. We can however say that a question is \n70 \nabout a vertex, too if the corresponding edge is incident to \nthat vertex. \nUpper bound \nThe sketch of the construction is as follows. Obviously, \nProver can restrict herself to the first n + 1 elements of M .  \nShe asks consecutively all the questions about the first ele- \nment from M ,  namely p l l ,  p l z ,  . . . p l , .  If all the answers \nare \"no\", a contradiction is found. Otherwise, suppose p l j  \nis the first question with a positive answer. Prover then asks \nall the remaining questions about the j- th element of N, \nnamely p 2 j ,  p3 j ,  . . . p,+l, ,. If at least one answer is \"yes\", \na contradiction is found. If not, we can safely remove the \nfirst element from M and the j- th element from N, and then \nlook for a contradiction on a \nThe boolean decision tree is given on the figure 1 below. \nThe internal nodes are labelled with the queried variables, \ninstance. \nFigure 1. An optimal decision tree for PHP,\" \nand the edges are marked with the corresponding answer. \nEvery external node (leave) is labelled by the found contra- \ndiction, i.e. a clause falsified under the (partial) truth assign- \nment corresponding to the path from the root to this node. \nThe nodes marked by PHPRY1 are, in fact, subtrees. \nWhat remains is to estimate the size. The decision tree \nfor PHP,C\" consists of n copies of the decision tree for \nPHPZY1 plus a quadratic in n overhead. More precisely \nwhere S (n)  is the size of the decision tree for P H P Z .  \nIt is now easy to prove by induction that S ( n )  5 \n6 (n + l)!. Finally, an application of Stirling's approxima- \ntion of the factorial gives the desired upper bound. \nLower Bound \nThe main idea in our proof is to define a function on \nthe nodes of the decision tree. The value of the function at \nany node should be a lower bound of the size of the subtree \nrooted by that node. After having done that, it suffices to \ncompute the function value on the root. The result is a lower \nbound on the size of any decision tree, solving the search \nproblem for PHP,\". \nWe assume, w.l.o.g., that n is even. W.l.0.g. we can also \nassume that Prover's decision tree is read-once, i.e. along \nevery path any question is asked at most once. Now, we can \nexplain Adversary's strategy. \nAn important concept, we introduce here, are counters. \nA counter is attached to every vertex in M which is not \nmatched yet to any vertex in N. In addition, there is one \nspecial counter that will be explained later on. Initially \nall the counters are set to zero. During the game, every \ncounter is an upper bound of the number of vertices in N \nthat are \"forbidden\" for the corresponding vertex in M. \nWhen some counter reaches the value n, Adversary \"gives \nup\", although it might be possible to continue the game a \nfew more rounds. \nWe can now classify all the questions that can appear in \nthe decision tree and show how to maintain the counters. \nLet IC be the size of the partial matching obtained so far, i.e. \nthe number of \"yes\" answers along the path from the root to \nthe current node. There are three kinds of queries: \n1 .  Free-choice. Neither of the two vertices involved is in \nthe current partial matching and the counter of the ver- \ntex from M is less than $ + IC. Adversary chooses ei- \nther \"yes\" or \"no\" answer with some probability. The \nactual probability does not matter, the important point \nis that the free choice forces Prover to branch the deci- \nsion tree at that point. If the answer is \"no\", only the \ncounter of the element form M increases by one. If \nthe answer is \"yes\" this counter is cancelled, i.e. not \nmaintained any more, but the counters of all the other \nelements in M are increased by one. \n2. Critical. Neither of the two vertices involved is in the \ncurrent partial matching but the counter of the vertex \nfrom M is equal to 5 + I C .  Adversary answers \"yes\", \nhe current counter is cancelled, and the counters of all \nthe other elements in M are increased by one. \n3 .  Forced. Some of the vertices involved (or both) is al- \nready in the matching. Adversary answers \"no\" and \ndoes not change any of the counters attached to the el- \nements in M .  He however increases by one the special \ncounter, which counts the forced questions. \nFirst of all, i t  is easy to see that for a given element in M, \nits counter is an upper bound on the number of elements in \nN that cannot be matched to that element. There are also \nsome other simple observations to be made. First one says \nthat Adversary always \"survives\" certain number of rounds. \n71 \nLemma 1 A contradiction can be found only when some \ncounter reaches the value n. In this case, at least 5 \u2018j1es\u201d \nanswers must be present on the path from the root to the \ncurrent node. \nProof A simple induction on k proves the following asser- \ntion: All the counters are bounded from above by f + k \nalong any path from a node, where the partial matching is \nof size k ,  to the node, where that size becomes k + 1. The \nlemma then follows.0 \nThe next lemma shows that there must be a very long \nbranch in any decision tree. Together with the main result, \ni t  implies that every such tree is unbalanced. \nLemma 2 In every decision tree for  PHPZ,  there is a path \nof length 52 (n\u2018). \nProof Consider the path, where Adversary answers \u201cno\u201d to \nevery free-choice question. It is now easy to observe that \nwhen k-th critical questions asked, the corresponding ver- \ntex from M has a counter value equal to : + k - 1. That \ncounter has been increased k - 1 times because of the pre- \nvious k - 1 critical question. The remaining 5 increases \nare result of \u2018ho\u201d answers to free-choice question about the \ncorresponding vertex. Thus, along the particular path, we \nconsider, any \u201cyes\u201d answer is preceded by 5 negative an- \nswers about the same vertex. \nThe lemma 1 claims that every path contains at least 5 \n\u201cyes\u201d answers. Therefore our path contains at least 5 \u201cno\u201d \nanswers.0 \nWe can now prove the main result. \nTheorem 1 Every tree resolution proof of PHP,\u201d is of size \n2Q(n 1% 4. \nProof First we define an appropriate function as it has been \nexplained in the beginning of the section. \nLet us denote by k the size of the partial matching at the \ncurrent node U ,  i.e. the number of \u201cyes\u201d answers along the \npath from the root to U .  Let us also sort the m-k unmatched \nvertices from M in decreasing order of their counters, and \ndenote the values of the counters themselves by p l  2 p2 2 \n. . . 2 pm-k.  The forced question counter is denoted by P O .  \nThe value of the function at the node is then defined by \nE-k \ni=l \n5 + k - i - pi if it is positive \nelsewhere \nwhere qi = \nOn the root, T ,  we have f ( T )  = (F - l)!, SO that f ( r )  = \n2 n ( n 1 0 g n ) .  It only remains to prove that at any node the \nfunction value is a lower bound for the size of the subtree \nrooted by the node. \nThe proof is by induction on the tuples of the form \nWe order them as follows. The shorter a tuple, the smaller \nit is. If two tuples have equal length, the lexicographically \nbigger one is the smaller. Clearly, this ordering makes the \ninduction work from the leaves to the root of the decision \ntree, as the tuple on any node is strictly bigger than the tu- \nples on its successors in the tree. \nThe basis case is then Ic = $, where f ( U )  = 1, as the \nproduct is empty. Obviously, the function value at the node. \nis a lower bound of the corresponding subtree, no matter \nwhat the only element of the tuple is. \nTo prove the induction steep, we need to consider all pos- \nsible kind of questions that can appear at the current node \nU .  \n1. Forced. We consider the \u201cno\u201d branch only. Denoting \nits root (the \u201cno\u201d successor of U )  by U ,  we have f (u)  = \nf (v), as only po increases by one when going from U \nto v and f does not depend from P O .  By the induction \nhypothesis, we are done. \n2. Critical. W.l.0.g. we assume that the question is about \nthe element, having pl as a counter. It is so, because \na critical question always involves the biggest counter \n(Even if there are many counters with the biggest value \n+ I C ,  we can always consider p l ,  as two elements, \nhaving the same counter value are indistinguishable to \nAdversary\u2019s strategy). We consider the \u201cyes\u201d branch \nonly. Denoting the \u201cyes\u201d successor of u by U ,  we have \nagain f(u) = f ( v ) .  That is the case, because all the \ncounters p z , . .  . , p ~ k  increase by one when going \nfrom U to v, but so does k, therefore the contributions \nq 2 , .  . . , q g - k  do not change. q1 vanishes at U ,  but its \nvalue at U is one, as pl = + k .  By the induction \nhypothesis, we are done. \n3. Free-choice. There are three sub-cases: \n(a) The index involved, j ,  is greater than - k .  \nW.l.0.g. we can also assume p 5 - k  > p j  since \nif they were equal Adversary could behave as the \nquestion were about 5 - Ic-th element (again, any \ntwo vertices having the same counter value are \nindistinguishable to Adversary\u2019s strategy). The \n\u201cno\u201d answer then does not change anything ex- \ncept the last element of the tuple, but f does not \ndepend on it . ,  So, f (u)  = f(v), where v is the \nsuccessor of U .  By the induction hypothe- \nsis, we are done. \n(b) The index involved, j ,  is between 1 and 5 - IC ,  \nbut the contribution, q j ,  of that element to the \nfunction f is one. That is similar to the previ- \nous sub-case, as the \u201cno\u201d answer leaves the value \no f f  unchanged when going from from U to to its \n\u201cno\u201d successor U. \n(c) The index j is between 1 and f - IC and the con- \ntribution, q j ,  of that element to the function f \nis greater than one. This is the only non-trivial \ncase, in the sense that we need consider both sub- \ntrees of the current node U .  Note that if there \nare many counters, having the same value equal \nto p j ,  w.1.o.g. we can think that j is the mini- \nmum such index, so that the \u201cno\u201d answer does \nnot change the order of the counters. \nThe \u201cno\u201d subtree gives the tuple \nand the value \ntree resolution proofs. We also show the same upper bound, \ni.e. any such proof cannot be worse than that. It is very \nimportant to now note that \u201cworst case\u201d, in our context, has \na conipletely different meaning than the usual one, used in \nComplexity Theory or Analysis of Algorithms. \nLower bound \nThe sketch of the construction is as follows. Prover ask \nall the questions about the first element from N ,  namely \np l l ,  pal, . . . pml .  If all the answers are \u201cno\u201d, we can remove \nthe first element from N ,  and thus get an PHPF-,\u2019  Instance. \nOtherwise, suppose pi1 is the first question with a positive \nanswer. Prover then asks all the remaining questions about \nthe first element of N ,  namely pi+l1, pi+2 1 ,  . . . pml . If at \nleast one answer is \u201cyes\u201d, a contradiction is found. If not, \nwe can safely remove the first element from N and the i -  \nth element from M ,  and then look for a contradiction on a \nPHPAT;\u2019 instance. \nThe boolean decision tree is given on the figure 2 below. \nThe \u201cyes\u201d subtree gives \n(pl + 1,. . .pj-1 f l ,pj+l + 1 . .  . 3pg-k + 1, \nFigure 2. A worst-case decision tree for \nPHP,\u201d \nm--k n \nWhat remains is to estimate the size. The decision tree \nfor PHP.?\u2018 consists of m copies of the decision tree for \nand the value \nThe induction hypothesis then applies to both \nsubtrees, so the size of the current subtree is at \nleast \n1 + f (U) + f ( U )  = 1 + f ( U )  > f ( U )  \u2018 \nThis completes the proof.0 \n4 Worst case proofs \nPHPP-Y\u2019, one decision tree for PHPC-,  plus a quadratic \nin m overhead. More precisely \nmS (m - 1, n - 1) + if n > 1 { 5 i f n  = 1 S ( m , n ) =  S ( m , n - l ) + m i  > \nwhere S (m, n) denotes the size of the decision tree for \nP H P Z .  \nWe have \nS ( m , n )  > mS (m - 1,n - 1) \n> m. (m - 1) S (m - 2, n - 2) \nTherefore, for every m > n > 2, we get \nWe first construct a 2\u00b0(n log m, boolean decision tree for \nPHP,\u201d which is a lower bound for the worst-case regular \n73 \nUpper bound \nThe main idea is the same as in the proof of the lower \nbound on the optimal refutation. This time however, we \nintroduce the counters to the elements of the set N .  Ev- \nery counter p j  equals to m minus the number of questions \nabout the j- th element of N that have already been asked. \nIn other words, the counter contains exactly the number of \npossible questions about the element to be asked in the fu- \nture. There is also one global counter po that is the sum of \nall the counterspj, 1 5 j 5 n. \nWe can now prove the main result of this section. \nTheorem 2 Every regular tree resolution proof of PHP? \nis of size 2*(\u201d log m).  \nProof Again we define an appropriate function on the nodes \nof the read-once decision tree. At any node the value of the \nfunction will be an upper bound on the size of the subtree \nrooted at that node. \nLet us denote by U the current node, and by P ,  P C N ,  \nthe set of all the vertices from N that are not yet matched to \nany vertex in M .  The function f is the defined as \nf ( U )  = 2 (Po + 1) r-J ( P j  + 1) - 1. \nj \u20ac P  \nOn the root of the tree, T ,  we have f ( T )  = \n2 (mn + 1) (m + l)n - 1, so that f ( T )  = 2\u00b0(R10gn).  It \nonly remains to prove that at any node the function value \nis an upper bound for the size of the subtree rooted by the \nnode. \nThe proof is by induction on the global counter po . \nThe basis case is then po = 0, so that all other p\u2019s are \nzeros and therefore f ( U )  = 1. In this case all variables have \nalready been queried, as there are no possible questions left. \nTherefore a contradiction has already been found and f ( U )  \nis an upper bound. \nTo prove the induction steep, we consider the following \ntwo cases. \n1. The question at the current node, U ,  is about the i-th \nelement from N ,  and i $! P. This means that ele- \nment has already been matched to some element in M ,  \nso that the current question is forced. Therefore, the \n\u201cyes\u201d subtree consists of a single vertex, labelled by \nthe contradiction found. Let us denote by w the \u201cno\u201d \nsuccessor of U .  The induction hypothesis applies at w, \nas po decreases by one there, so the size of any subtree \nrooted at U is at most \n2. \n5 \nThe question at the current node, U ,  is about the i-th \nelement from N ,  and i E P.  The induction hypothesis \nthen applies to both \u2018\u2018yes\u2019\u2019 and \u201cno\u201d successors of U .  \nDenoting them by U and w respectively, we have that \nthe size of any subtree rooted at U is at most \n1 + f (w) + f (w) = 1 + 2po (P,  + 1) - 1 + \nJEP\\{ZI  \n2PoPz n (PJ + 1) - 1 \n= 2Po rI (P, + 1) - 1 \n< 2 (Po + 1) n (PJ + 1) - 1 \nP\\{Z) \n,EP \nJ E P  \n= f ( U )  \u2019 \nThis completes the proof.0 \nLink to Complexity Gap theorem \nIn this section, we discuss possible refinements and ex- \ntensions of Riis\u2019 complexity gap theorem for tree resolution. \nThey are motivated by our results presented in the previous \ntwo sections. \nWe first need to state the complexity gap theorem itself. \nWe give here a slightly different version than the one from \nthe original paper [ 141 \nWe are given a first order sentence $ of predicate \nlogic that fails in all finite models. There is a proce- \ndure which translates the sequence of sentences A,  :=\u201d \n$ has no models of size n\u201d into an unsatisfiable set CQ,, of \nclauses. The sequence C$,\u201d is uniformly generated (in the \nsense of [15])and its size is bound by a polynomial in n. \nThe complexity gap theorem states that either 1 or 2 holds: \n1 .  The sequence C+,n have polynomial size in n tree res- \nolution refutations. \n2. There exists X > 0 such that each tree resolution refu- \ntation of C+,, must contain at least 2\u2019\u201d clauses. \nFurthermore 2 holds if and only if $ has an infinite model. \nSo, the gap is between polynomial and exponential size \nproofs and shows that no super-polynomial (e.g. 2 \u2019 ( l o g p  n, \nfor some p > 1) and sub-exponential (e.g. 2\u2019(\u201d\u201c) for some \n0 < E < 1) optimal proofs can appear. \nWe will concentrate on the sentences falling in the sec- \nond case, i.e. requiring exponential size tree resolution refu- \ntations. Let us denote the class of all such sentences by \nExp. \nLet us first consider the following encoding of PHP,\u201d+l \nas a first order sentence (given also in [14]) \n74 \nThe complexity gap theorem gives only a 2\"(\") lower \nbound, whereas we have shown that its real complexity is \n2'(\"logn). Going further, let us encode P H P , n ,  where \np ,  q E Z+ and p > q,  as a first order sentence \nHere ?i? = ( ~ 1 ~ ~ 2 , .  . . x p )  and $ (3) = \n(fi (2)  fi (2) , . . . f, (3)). Our result shows that \nthe exact complexity is 2\u00b0(nq10gn)  for any arbitrary free \nregular resolution proof. \nOn the other hand, let us consider the minimum element \nprinciple, saying that if R is a total order, it has a minimal \nelement. Its negation can be encoded as \n(V'.., Y (z # Y) -+ ( R  (x, Y) a3 R (Y, x ) ) )  A \n@> Y, z ( R  (5 ,  Y) A R (V> 2 ) )  -+ R (Z> 2 ) )  A \nPX3Y R (Y, x)) . \nHere R (z, 9) stands for z < 9. It can easily be proven \nthat the optimal tree resolution proofs of it  are of size 2'(n) ,  \nwhereas the worst-case proofs are of size 2'(\"'). Clearly, \nif we replace the singletons by p-tuples, the corresponding \noptimal and worst-case proofs are 2'(\"') and 2'(\"'') re- \nspectively. \nLet us now denote by Size  ( t  (n ) )  the class of first order \nsentences of propositional logic that have their optimal tree \nresolution proofs of size t (n) ,  and by Opt - the class for \nwhich any arbitrary tree regular resolution proof is poly- \nnomialy related to the optimal one. \nTo summarise, our two examples show \n1. The classes S i z e  (2'(\"')), p E Z+ and \nSize  ( z ' ( ~ '  logn)), q E Z+ are nonempty. \n2. The classes Opt S i z e  (2e(n' l o g n )  ), q E Z+ and \nS i z e  (2'(\"')) \\ Opt, p E Z+ are nonempty. \nAt the same time, the following three interesting open ques- \ntions arise \n- 1. Is it the case that Exp  \nUp,zt Size  ( 2 ' ( n P ) )  U uQEZ+ S i z e  (2'(\"' l o g n )  ) .  7 \nThat IS to ask whether the exponential side of \nComplexity-Gap Theorem can be further refined, \nso that each complexity subclass inside it  is either \nS i z e  (2'(\"')) or S i z e  ( 2 ' ( n q 1 0 g n ) )  for some positive \ninteger plq. \n2. Is it the case that Opt 5 U,z+ Size  ( 2 e ( n q ' o g n ) ) ?  \nThat is to ask whether all trivially automatisable prob- \nlems belong to this particular family of optimal-proof- \nsize classes. Alternatively (and equivalently, assuming \n3. \na positive answer to the previous question), we can ask \nwhether Opt n S i z e  ( 2 ' ( n p ) )  = 8 for every positive \ninteger p.  \nIs it  the case that if s E S i z e  (2'(\"')) for some \np E Z+, the worst-case complexity of the s is at least \n2 W P )  ? \nReferences \nP. Beame and T. Pitassi. Simplified and improved resolu- \ntion lower bounds. In Proceedings of the 37th annual IEEE \nsymposium on Foundation Of Computer Science, pages 274- \n282, 1996. \nE. Ben-Sasson and A. Wigderson. Short proofs are narrow - \nresolution made simple. Technical Report 22, ECCC, 1999. \nS. Buss and T. Pitassi. Resolution and the weak pigeonhole \nprinciple. In Computer science logic (Aarhus, 1997), pages \n149-156. Springer, 1998. \nS. Buss and G. Turin. Resolution proofs of general- \nized pigeonhole principles. Theoretical Computer Science, \nS. Dantchev and S. Riis. A tough nut for tree resolution. \nTechnical Report 20, BRICS, May 2000. \nA. Haken. The intractability of resolution. Theoretical Com- \nputer Science, 39:297-308, 1985. \nK. Iwama and S. Miyazaki. Tree-like resolution is super- \npolynomially slower than DAG-like resolution for the pi- \ngeonhole principle. In Algorithms ana' computation (Chen- \nnai, 1999), pages 133-142. Springer, Berlin, 1999. \nJ. Krajitek. Bounded Arithmetic, Propositional Logic, and \nComplexity Theop. Cambridge University Press, 1995. \nT. Pitassi and R. Raz. Regular resolution lower bounds for \nthe weak pigeonhole principle. 2000. \nP. Pudlik. Proofs as games. American Mathematical \nMonthly, to appear. \nP. Pudlik and S. Buss. How to lie without being (easily) \nconvicted and the lengths of proofs in propositional calcu- \nlus. In Pacholski and Tiuryn, editors, Computer Science \nLogic'94, volume 993 of LNCS, pages 151-162. Springer- \nVerlag, 1995. \nR. Raz. Resolution lower bounds for the weak pigeonhole \nprinciple. Technical report, ECCC, 2001. \nA. Razborov, A. Wigderson, and A. Yao. Read-once branc- \ning programs, rectangular proofs of the pigeonhole principle \nand transversal calculus. ln Syniposiurn on Theop of Corn- \nputing, pages 739-748, 1997. \nS. Riis. A complexity gap for tree-resolution, Technical \nReport RS-99-29, BRICS, September 1999. \nS. Riis and M. Sitharam. Generating hard tautologies us- \ning predicate logic and the symmetric group. Technical Re- \nport 19, BRICS, 1998. \nA. Urquhart. Resolution proofs of matching principles. \n1998. \n62:311-317, 1988. \n"}