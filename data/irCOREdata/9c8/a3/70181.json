{"doi":"10.1016\/0140-3664(96)01069-9","coreId":"70181","oai":"oai:eprints.lancs.ac.uk:12978","identifiers":["oai:eprints.lancs.ac.uk:12978","10.1016\/0140-3664(96)01069-9"],"title":"Supporting collaborative applications in a heterogeneous mobile environment","authors":["Davies, Nigel","Blair, Gordon S.","Cheverst, Keith","Friday, Adrian",", EPSRC (Funder)"],"enrichments":{"references":[{"id":16311284,"title":"Adaption and Mobility in Wireless Information Systems.&quot;","authors":[],"date":null,"doi":null,"raw":"Katz,  R.H.    &quot;Adaption  and  Mobility  in  Wireless  Information  Systems.&quot;  IEEE  Personal Communications Vol. 1 No. 1. Pages  6-17.","cites":null},{"id":16311324,"title":"Collaboration Awareness in Support of Collaboration Transparency: Requirements for the Next Generation of Shared Window Systems.&quot;","authors":[],"date":"1990","doi":"10.1145\/97243.97301","raw":"Lauwers,  J.C.,  and  K.A.  Lantz.    &quot;Collaboration  Awareness  in  Support  of  Collaboration Transparency: Requirements for the Next Generation of Shared Window Systems.&quot; Proc. CHI 1990, 1990. Pages 303-310.","cites":null},{"id":16311307,"title":"Distributed Computing Environment: An Overview&quot;, Open Software Foundation.","authors":[],"date":"1991","doi":null,"raw":"OSF.  &quot;Distributed  Computing  Environment:  An  Overview&quot;,  Open  Software  Foundation. April 1991.","cites":null},{"id":16311314,"title":"Experiences of Handling Multimedia in Distributed Open Systems.&quot;","authors":[],"date":"1992","doi":null,"raw":"Davies, N., G. Coulson, N. Williams, and G.S. Blair.  &quot;Experiences of Handling Multimedia in Distributed Open Systems.&quot; Proc. 3rd USENIX International Symposium on Experiences with Distributed and Multiprocessor Systems, Newport Beach, CA, U.S.A., March 1992.","cites":null},{"id":16311321,"title":"Experiences with X in a Wireless Environment.&quot;","authors":[],"date":"1993","doi":null,"raw":"Kantarjiev, C.K., A. Demers, R. Frederick, R.T. Krivacic, and M. Weiser.  &quot;Experiences with X in a Wireless Environment.&quot; Proc. USENIX Symposium on Mobile and Location Independent Computing, Cambridge, Massachusetts, U.S.A., August 2-3, 1993. Pages 117-","cites":null},{"id":16311303,"title":"Expert Systems to Support Network Switching.&quot;","authors":[],"date":"1993","doi":null,"raw":"Cross,  A.D.,  J.R.  Brailsford,  and  A.T.  Brint.    &quot;Expert  Systems  to  Support  Network Switching.&quot; Proc. 12th International Conference on Electricity Distribution, CIRED 1993, Birmingham, U.K., 17-21 May, 1993.","cites":null},{"id":16311310,"title":"Extensions to ANSA for Multimedia Computing.&quot;","authors":[],"date":null,"doi":"10.1016\/0169-7552(92)90097-a","raw":"Coulson, G., G.S. Blair, N. Davies, and N. Williams.  &quot;Extensions to ANSA for Multimedia Computing.&quot; Computer Networks and ISDN Systems No. 25. Pages  305-323.","cites":null},{"id":16311316,"title":"GroupSketch: A multi-user sketchpad for geographicallydistributed small groups.&quot;","authors":[],"date":"1991","doi":null,"raw":"Greenberg, S., and R. Bohnet.  &quot;GroupSketch: A multi-user sketchpad for geographicallydistributed small groups.&quot; Proc. Graphics Interface '91, 1991. Pages 207-215.","cites":null},{"id":16311330,"title":"Introduction to GRASS 4&quot;, GRASS Information","authors":[],"date":"1991","doi":null,"raw":"Westervelt, J. &quot;Introduction to GRASS 4&quot;, GRASS Information Center, U.S. Army CERL, Champaign, Illinois, U.S. July 1991.","cites":null},{"id":16311281,"title":"Issues in Wireless Mobile Computing.&quot;","authors":[],"date":"1992","doi":"10.1109\/wwos.1992.275698","raw":"Duchamp,  D.    &quot;Issues  in  Wireless  Mobile  Computing.&quot;  Proc.  Third  Workshop  on Workstation  Operating  Systems,  Key  Biscayne,  Florida,  U.S.A.,  1992.  IEEE  Computer Society Press, Pages 2-10.","cites":null},{"id":16311301,"title":"Mobile Open Systems Technologies For The Utilities Industries.&quot;","authors":[],"date":"1993","doi":"10.1007\/978-1-4471-1496-3_11","raw":"Davies, N., G.S. Blair, A. Friday, A.D. Cross, and P.F. Raven.  &quot;Mobile Open Systems Technologies  For  The  Utilities  Industries.&quot;  Proc.  IEE  Colloquium  on  CSCW  Issues  for Mobile and Remote Workers, London, U.K., March 16, 1993.","cites":null},{"id":16311334,"title":"Overview of the CHORUS Distributed Operating System&quot;,","authors":[],"date":"1990","doi":null,"raw":"Rozier, M., V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. L\u00e9onard, and W. Neuhauser. &quot;Overview of the CHORUS Distributed Operating System&quot;, Technical Report CS\/TR-90-25, Chorus syst\u00e9mes. 1990.","cites":null},{"id":16311297,"title":"Providing ConnectionOriented Network Services to Mobile Hosts.&quot;","authors":[],"date":"1993","doi":"10.1109\/wwos.1993.348173","raw":"Keeton,  K.,  B.A.  Mah,  S.  Seshan,  R.H.  Katz,  and  D.  Ferrari.    &quot;Providing  ConnectionOriented Network Services to Mobile Hosts.&quot; Proc. USENIX Symposium on Mobile and Location  Independent  Computing,  Cambridge,  Massachusetts,  U.S.A.,  August  2-3,  1993. Pages 83-102.","cites":null},{"id":16311299,"title":"Providing Network Video Service to Mobile Clients.&quot;","authors":[],"date":"1993","doi":"10.1109\/wwos.1993.348173","raw":"Mah, B., S. Seshan, K. Keeton, R. Katz, and D. Ferrari.  &quot;Providing Network Video Service to Mobile Clients.&quot; Proc. 4th Workshop on Workstation Operating Systems (WWOS-IV), Napa, U.S., October 14-15, 1993.","cites":null},{"id":16311289,"title":"Recommendation X.901: Basic Reference Model of Open Distributed Processing - Part1: Overview and Guide to Use&quot;,","authors":[],"date":"1992","doi":null,"raw":"ISO.  &quot;Draft  Recommendation  X.901:  Basic  Reference  Model  of  Open  Distributed Processing - Part1: Overview and Guide to Use&quot;, Draft Report 1992.","cites":null},{"id":16311291,"title":"Services to Support Distributed Applications in a Mobile Environment.&quot;","authors":[],"date":"1994","doi":"10.1109\/sdne.1994.337774","raw":"Davies, N., S. Pink, and G.S. Blair.  &quot;Services to Support Distributed Applications in a Mobile  Environment.&quot;  Proc.  1st  International  Workshop  on  Services  in  Distributed  and Networked Environments (To Appear), Prague, Czech Republic, June 1994.","cites":null},{"id":16311326,"title":"Structuring Distributed Algorithms for Mobile Hosts.&quot;","authors":[],"date":"1994","doi":"10.1109\/icdcs.1994.302386","raw":"Badrinath, B.R., A. Acharya, and T. Imielinski.  &quot;Structuring Distributed Algorithms for Mobile Hosts.&quot; Proc. 14th International Conference on Distributed Computer Systems (To Appear), Poznan, Poland, June 21-24, 1994.","cites":null},{"id":16311293,"title":"Support for Continuous Media in the Dash System.&quot;","authors":[],"date":"1990","doi":"10.1109\/icdcs.1990.89284","raw":"Anderson,  D.P.,  S.  Tzou,  R.  Wahbe,  R.  Govindan,  and  M.  Andrews.    &quot;Support  for Continuous Media in the Dash System.&quot; Proc. 10th International Conference on Distributed Computing Systems, Paris, May 1990.","cites":null},{"id":16311312,"title":"Supporting the Real-Time Requirements of Continuous Media in Open Distributed Processing.&quot;","authors":[],"date":null,"doi":"10.1016\/0169-7552(94)00034-q","raw":"Coulson, G., G.S. Blair, F. Horn, L. Hazard, and J.B. Stefani.  &quot;Supporting the Real-Time Requirements of Continuous Media in Open Distributed Processing.&quot; Computer Networks and ISDN Systems (To Appear). 19","cites":null},{"id":16311308,"title":"The ANSA Reference Manual Release 01.00&quot;, APM Cambridge Limited,","authors":[],"date":"1989","doi":null,"raw":"A.P.M. Ltd. &quot;The ANSA Reference Manual Release 01.00&quot;, APM Cambridge Limited, UK. March 1989.","cites":null},{"id":16311305,"title":"The Common Object Request Broker: Architecture and Specification (CORBA)&quot;, Report 91.12.1, The Object Management Group.","authors":[],"date":"1991","doi":"10.3403\/30195787","raw":"OMG. &quot;The Common Object Request Broker: Architecture and Specification (CORBA)&quot;, Report 91.12.1, The Object Management Group. 1991.","cites":null},{"id":16311318,"title":"XTV: A Framework for Sharing X Window Clients in Remote Synchronous Collaboration.&quot;","authors":[],"date":"1991","doi":"10.1109\/tricom.1991.152885","raw":"Abdel-Wahab, H.M., and M.A. Feit.  &quot;XTV: A Framework for Sharing X Window Clients in Remote  Synchronous  Collaboration.&quot;  Proc.  IEEE  Tricomm  '91:  Communications  for Distributed Applications and Systems, 1991. Chapel Hill,","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"1996-04","abstract":"This paper describes the implementation and use of a platform designed to support collaborative multimedia applications in a mobile environment. The platform provides a programming interface compatible with emerging open systems standards and includes services for processing multimedia information. In addition, the platform provides feedback to applications and users on the state of their communications infrastructure - an important requirement in mobile environments. The services provided by the platform have been used to develop a collaborative multimedia application designed to support a specific class of mobile worker, i.e. field engineers. The design decisions taken in our implementation of both platform and application are evaluated, and our experiences are presented","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/70181.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/12978\/1\/davies%2Dcollaboration%2Dccspecial%2D1994.pdf","pdfHashValue":"32d78718ba0921adf95abccead11462dba1fc2f8","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:12978<\/identifier><datestamp>\n      2018-01-24T02:23:38Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413736<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Supporting collaborative applications in a heterogeneous mobile environment<\/dc:title><dc:creator>\n        Davies, Nigel<\/dc:creator><dc:creator>\n        Blair, Gordon S.<\/dc:creator><dc:creator>\n        Cheverst, Keith<\/dc:creator><dc:creator>\n        Friday, Adrian<\/dc:creator><dc:creator>\n        , EPSRC (Funder)<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:subject>\n        QA76 Computer software<\/dc:subject><dc:description>\n        This paper describes the implementation and use of a platform designed to support collaborative multimedia applications in a mobile environment. The platform provides a programming interface compatible with emerging open systems standards and includes services for processing multimedia information. In addition, the platform provides feedback to applications and users on the state of their communications infrastructure - an important requirement in mobile environments. The services provided by the platform have been used to develop a collaborative multimedia application designed to support a specific class of mobile worker, i.e. field engineers. The design decisions taken in our implementation of both platform and application are evaluated, and our experiences are presented.<\/dc:description><dc:date>\n        1996-04<\/dc:date><dc:type>\n        Journal Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:relation>\n        http:\/\/dx.doi.org\/10.1016\/0140-3664(96)01069-9<\/dc:relation><dc:identifier>\n        Davies, Nigel and Blair, Gordon S. and Cheverst, Keith and Friday, Adrian and , EPSRC (Funder) (1996) Supporting collaborative applications in a heterogeneous mobile environment. Computer Communications, 19 (4). pp. 346-358. ISSN 0140-3664<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/12978\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1016\/0140-3664(96)01069-9","http:\/\/eprints.lancs.ac.uk\/12978\/"],"year":1996,"topics":["QA75 Electronic computers. Computer science","QA76 Computer software"],"subject":["Journal Article","PeerReviewed"],"fullText":"Internal Report No: MPG-94-18, Computing Department, Lancaster University, Bailrigg, Lancaster, LA1 4YR. January \n1994 and to appear in a special issue of Computer Communication on Mobile Computing, 1995. \nSUPPORTING COLLABORATIVE APPLICATIONS IN A \nHETEROGENEOUS MOBILE ENVIRONMENT \nNigel Davies, Gordon S. Blair, Keith Cheverst and Adrian Friday \n \nDistributed Multimedia Research Group, \nDepartment of Computing, \nLancaster University, \nBailrigg, \nLancaster, \nLA1 4YR, \nU.K. \n \ntelephone: +44 (0)524 65201 \ne-mail: nigel, gordon, kc, adrian@comp.lancs.ac.uk \n \n \nABSTRACT \n This paper describes the implementation and use of a platform designed to support \ncollaborative multimedia applications in a mobile environment. The platform \nprovides a programming interface compatible with emerging open systems standards \nand includes services for processing multimedia information. In addition, the \nplatform provides feedback to applications and users on the state of their \ncommunications infrastructure - an important requirement in mobile environments. \nThe services provided by the platform have been used to develop a collaborative \nmultimedia application designed to support a specific class of mobile worker, i.e. \nfield engineers. The design decisions taken in our implementation of both platform \nand application are evaluated, and our experiences are presented. \n Keywords: Mobile Computing, Open Distributed Processing, Co-operative Work, \nAdaptive Applications, Quality-of-Service. \n1. Introduction \nThis paper describes the results of on-going research at Lancaster aimed at producing a \nplatform to support distributed multimedia applications in a mobile environment. Such \nenvironments have a number of characteristics1, 2, two of the most fundamental of which are:- \n(i) a heterogeneous processing environment (including relatively low-power mobile \nhosts) and, \n(ii) rapid and massive fluctuations in the quality of service (QoS) provided by the \nunderlying communications infrastructure. \nThe first of these issues, i.e. heterogeneity, we have addressed by basing our platform on the \nemerging International Standards Organisation (ISO) standard for Open Distributed Processing \n(ODP)3. This provides applications with a uniform computational model for accessing services \nand enables our platform to operate over a variety of processor\/operating system configurations. \nThe second of these issues, QoS fluctuations, we have addressed with a number of QoS aware \n2 \nrefinements to the basic Reference Model for ODP (RM-ODP). These refinements allow \napplications to react4 or adapt2 to changes in their communications infrastructure. Our basic \nplatform thus consists of a (partial) implementation of the RM-ODP augmented with services to \nsupport mobile operation and the display and manipulation of multimedia information. \nThe development of the platform described above has been motivated in part by the \nrequirement to provide collaborative applications to support field engineers in the utilities \nindustries. In section 2 we describe a specific application scenario involving field engineers and \nconsider the requirements of a mobile collaborative application based on this scenario. Section 3 \nthen describes our platform with reference to these requirements and section 4 the design and \nimplementation of a pilot application based on our platform. This application includes facilities \nfor multimedia communication and allows field engineers to collaboratively view, edit and \nhighlight geographic information. Attention is also focused on the design of the user interface \nwhich provides users with feedback on the QoS currently being offered by the underlying \ncommunications infrastructure. \nThe platform and application have both been implemented on a desk based network of Sun \nworkstations and PCs using a network emulator to simulate operation over a range of wireless \nnetwork types and to vary the QoS offered by the communications infrastructure. Section 5 \nreports on our experiences with developing and using our platform in this environment. In \nparticular, we focus on our experiences of using an ODP-like computational model in a mobile \nenvironment. Finally, section 6 contains our concluding remarks and references. \n2. Collaborative Mobile Applications To Support Field Engineers \nThere are numerous examples of mobile computing applications which provide users with \nremote access to central facilities (e.g. email, news and financial databases). These applications \ntypically make relatively modest demands on their communications infrastructure and have \nsimple client-server based architectures. In this section we focus on the requirements of an \nexample of a more demanding class of mobile application, i.e. collaborative multimedia \napplications. Such applications involve two or more mobile or fixed users co-operating to achieve \na common goal involving the manipulation of information in a range of media types. In \nparticular, these applications often require that continuous media types (e.g. audio)5 are supported \n(note that providing support for continuous media types in a mobile environment is an area of \nincreasing research activity6,7). \n2.1. Application Scenarios \nAs part of the MOST (Mobile Open Systems Technologies for the utilities industries) \nproject8 we have conducted a detailed study of the requirements of field engineers within the \nU.K. power distribution industry and identified a number of application areas for collaborative \nmobile computing. In general, these applications are based on an examination of current working \npractices. As an example consider the following scenario. \nAll work within a regional electricity company is traditionally co-ordinated by a single \ncontrol centre (see figure 1). The engineer supervising a particular repair job files a schedule with \nthe centre some days in advance. This schedule describes in detail the stages involved in carrying \nout the work and, in particular, the sequence of switching which must be carried out to ensure that \nthe work can be conducted safely (i.e. the section of network being operated on is isolated and \nearthed) and with the minimum of disruption to users. The control centre checks the switching \nschedule against its central diagram of the network state (this may be held on its computer \nsystem) and approves or rejects the schedule accordingly. Expert systems may be used by both \n3 \nthe control centre and the field worker in the development of the switching schedule9 although at \npresent these systems are not integrated with the centre's representation of the global network \nstate. \nSubstation A\nSubstation B\nSubstation C\nControl Centre\nArea of network to be repaired\n \nFigure 1 : Maintenance of a Section of a Power Distribution Network \nOnce the schedule has been approved, the work may be carried out. On the day of the work, \nfield engineers are dispatched to the appropriate switching points (substations A, B and C). The \ncontrol centre then uses a voice-oriented private mobile radio system to instruct the staff as to \nwhich switches to operate. The use of a central co-ordinator helps to ensure the work is carried \nout in the correct order and allows the centre to maintain an up-to-date picture of the network's \nstate. Once the work has been carried out the engineer must wait until returning to the office \nbefore completing the associated paper work. \nThere are clearly a number of disadvantages with this approach, in particular the lack of \navailability of global network state for the engineers in the field and the reduction in efficiency \ncaused by the bottle-neck of a central point of control. The latter of these points becomes \nparticularly important when multiple faults occur which require unscheduled work items to be \ncarried out (e.g. as a result of a storm). \n2.2. Requirements of a Mobile Collaborative Application  \nIn considering the development of a collaborative application to assist field engineers in work \nscenarios such as that described above we have identified the following requirements\u2020:- \n(i) Support for Geographical Information \nField engineers make extensive use of geographic or geographic related information. \nExamples include maps showing the position of underground cables, circuit diagrams and \nreports of faults whose ordering is based on geographic location. An application to \nsupport field engineers must offer support for the display and manipulation of data of this \ntype. Note that this does not equate to a requirement for a fully functioning GIS system; \nmany of the features found in such systems are not required by field engineers. However, \n                                                     \n\u2020  The scenario described in section 2.1 is based on specific working-practices but \nclearly has parallels in other domains. Examples include other utilities (gas, water \netc.), the emergency services and command and control applications. \n4 \nsome GIS functionality is required since the application must be able to interpret and \ncross-reference information based on geographic co-ordinates (e.g. to allow diagrams \nshowing cable layout to be superimposed on a physical map background). \n(ii) Support for Collaboration \nCollaboration is an essential part of a field engineer's work, particularly in situations such \nas fault diagnosis. Moreover, as also highlighted, providing field engineers with increased \ncollaboration support would help minimise the effect of the bottle-neck at the control-\ncentre. Hence, there is a requirement to support groups of engineers collaborating using \ngeographic information (see (i)), e.g. a diagram of the current network state. Note that \nthese groups are typically small with only two or three engineers collaborating at any one \ntime. \n(iii) Support for Audio Communications \nAudio communication is an essential tool for collaboration. In addition, many of the \nsafety procedures used by field engineers rely on voice communications. These \nprocedures could not be replaced by other media types in the foreseeable future and \nhence voice communications must be included in any application to support collaborating \nfield engineers. \n(iv) Operation in a Heterogeneous Processing Environment \nIn common with most large organisations electricity companies have a wide range of \nhardware architecture\/operating system configurations currently operational. Field \nengineers often require access to multiple resources both within the company and \n(increasingly) external to the company and hence must interact with heterogeneous \nservice providers. The issue of heterogeneity is particularly significant in a mobile \nenvironment since mobile computers will clearly be required to interact with a wide \nrange of service providers the selection of which must, in part, be determined by their \nphysical location. Thus, while standardisation on communications systems such as GSM \nis important it is, as has become apparent in static environments, equally important that \nhigher level distributed processing standards are employed to ensure an open system. \n(v) Operation in a Heterogeneous Networking Environment \nField engineers require applications which can operate over a wide-area wireless \nnetwork. In addition however, since a significant percentage of their time may be spent in \nan office or control-room environment, support is also required for applications to \noperate over and exploit the benefits accruing from the use of high-speed fixed networks. \nIn other words, there is a requirement for applications to operate over networks offering a \nwide variety of QoSs. \nThe following sections describe the MOST platform which provides support for writing \napplications with these characteristics and a prototype application based on the scenario identified \nin section 2.1.  \n3. A Mobile Distributed Systems Platform \nThe MOST platform is designed to meet the requirements of applications such as those \ndescribed in section 2 and in particular to employ distributed systems standards to enable \noperation in a heterogeneous environment. This area of standardisation has seen intense activity \nin recent years as witnessed by efforts such as the Object Management Group's Common Object \n5 \nRequest Brooker 10, the Open Software Foundation's Distributed Computing Environment 11 and \nthe ISO's ODP standard. All of these efforts attempt to provide support for distributed processing \nin heterogeneous environments. More specifically, they addresses the problem of standardisation \nwithin and between end systems (c.f. OSI standards which are primarily concerned with \ncommunication between end-systems). \nOur platform is based on the ISO RM-ODP. The scope of this model is wide and takes on \nboard the full range of issues from overall business objectives to detailed implementation choices. \nThe complexity inherent in this broad view is managed by partitioning the architecture into five \nviewpoints: enterprise, information, computational, engineering and technology. The focus of our \nwork at Lancaster is on the computational viewpoint, and this aspect of the RM-ODP is described \nin section 3.1. Following this, sections 3.2 and 3.3 describe aspects of our mobile computing \nplatform which is a partial implementation of the RM-ODP. \n3.1. The ODP Computational Viewpoint \nThe ODP computational viewpoint is based on a location independent object-based model of \ndistributed systems. In this model, interacting entities are treated uniformly as objects, i.e. \nencapsulations of state and behaviour. Objects are accessed through interfaces which can be of \ntwo types: signal interfaces and stream interfaces. Signal interfaces define named signals together \nwith constraints on their occurrence. Stream interfaces define named data flows that constitute \nabstractions of sets of interactions which are not visible from the outside. Communication \nbetween objects using signals or flows is only possible through explicit or implicit bindings \nbetween interfaces. \nOperational interfaces are special cases of signal interfaces. Operational interfaces define \nnamed operations together with constraints on their invocations. Operations can be either an \ninterrogation (a two-way operation, comprising an invocation, later followed by a termination \ncarrying results or exceptions), or an announcement (a one-way operation, comprising an \ninvocation only). Implicit binding is only available for operational interfaces. Activity takes place \nin the model when objects communicate via signals or flows supported by explicit or implicit \nbinding objects.  \nObjects offering services are made available for access by exporting interfaces to a database \nof service interfaces known as a trader. An object wishing to interact with a service interface \nmust import the interface by specifying a set of requirements in terms of a interface type and \nattribute values. This will be matched against the available services and a suitable candidate \nselected. Any number of traders can exist and these may be linked or federated to allow access to \nservices in different administrative domains. \nAlso central to the ODP computational model is the notion of transparency whereby selected \naspects of systems can be made invisible to applications. This is achieved by means of notional \ntransparency functions interposed between the application and the support layers (it should be \nnoted that the application of transparency functions is under user control and hence transparencies \nare selective). An important example of a transparency is group transparency which allows \nmultiple services to be invoked via a single interface. Other transparencies identified in ODP \ninclude location, access, concurrency, replication, migration and failure transparencies. \n3.2. The ANSAware Distributed Systems Platform \nThe implementation of our platform is based on APM Ltd.'s ANSAware software suite12. \nThis software suite is itself based on the ANSA architecture which has had a profound influence \n6 \non the RM-ODP. Thus, the platform realises many of the concepts contained within the RM-ODP \nwhile making a number of simplifying assumptions to allow efficient implementation (e.g. \nANSAware does not enforce the computational model requirement that all operation arguments \nand results are interfaces to other objects: most arguments and results are passed by value). \nTo provide a platform conformant with the computational model, the ANSAware suite \naugments a general purpose programming language (usually C) with two additional languages. \nThe first of these is IDL (Interface Definition Language), which allows interfaces to be precisely \ndefined in terms of operations as required by the computational model. The second language, dpl \n(distributed processing language) is embedded in a host language, such as C, and allows \ninteractions to be specified between programs which implement the behaviour defined by these \ninterfaces. Specifically, dpl statements allow the programmer to import and export interfaces, and \nto invoke operations in those interfaces. A number of system services are supplied which include \na trader service and a factory service for creating new objects. \nIn the engineering infrastructure, the binding necessary for invocations is provided by a \nremote procedure call protocol known as REX (Remote EXecution protocol) or a group execution \nprotocol know as GEX (Group EXecution Protocol). This is layered on top of a generic transport \nlayer interface known as a message passing service (MPS). A number of additional protocols may \nbe included at both the MPS and the execution protocol levels and these may be combined in a \nnumber of different configurations. The infrastructure also supports lightweight threads within \nobjects so that multiple concurrent invocations can be dealt with. \nAll the above engineering functionality is collected into a single library, and an instance of \nthis library is linked with application code to form a capsule. Each capsule may implement one or \nmore computational objects. In the UNIX operating system, a capsule corresponds to a single \nUNIX process. Computational objects always communicate via invocation at the conceptual level \nbut, as may be expected, invocation between objects in the same capsule is actually implemented \nby straightforward procedure calls rather than by execution protocols. ANSAware currently runs \non a variety of operating systems platforms including various flavours of UNIX, VMS and MS-\nDOS\/Windows. \n3.3. Extensions to Support Multimedia and Mobility \nWe have extended the basic ANSAware platform to support the transmission of continuous \nmedia and operation in a mobile environment. In particular, we have significantly extended the \nsupport for bindings in ANSAware. A useful side-effect of this work is that our version of the \nANSA platform us now aligned closer to the current RM-ODP than the standard version; the \ncurrent version of ANSAware (4.1) supports only operational interfaces and implicit bindings, i.e. \na client who obtains a reference to an operational interface may use that reference without an \nexplicit bind statement. The example below (figure 2) shows a client importing a transformer \ncontrol service and subsequently invoking an operation on that service's interface. \n! {transformer_control} <- traderRef$Import (\"Transformer\",               \n      \"context\", \"properties\") \n! {result}<-transformer_control$SetVoltage (voltage)  \nFigure 2 : A Transformer Control Interface \nFailures in the implicit binding carried out by the system are reported at invocation time \n(typically the first invocation). \n7 \nIn order to communicate continuous media information additional support is required: a \ncontinuous media communication cannot be represented as a single invocation because of its \npotentially unbounded nature13. For example, the output from a continuously running \nsurveillance camera cannot be captured as the result of a single invocation. Moreover, continuous \nmedia communication cannot be represented as a sequence of invocations because it is not \npossible to specify synchronisation constraints (e.g. jitter) that apply to a sequence of invocations.  \nTo meet the requirement for an abstraction of real-time data flow over time, we have added \nthe concept of explicit stream bindings (as described in the RM-ODP) to our ANSA based \nplatform. Stream bindings provide an end-to-end abstraction over continuous media \ncommunication and support arbitrary m:n connections, i.e. they allow m sources to be connected \nto n sinks. \nContinuous media sources and sinks are represented as objects with stream interfaces. These \ninterfaces contain a specification of a set of one or more flows, each of which is of a type capable \nof being supported by the underlying infrastructure (e.g. audio), has a direction (in or out) and an \nassociated QoS specification (see figure 3). The QoS specification can be used to state, for \nexample, the required throughput, latency and jitter characteristics of a binding to the interface. A \nstream binding between two stream interfaces may thus comprise of a number of component \nflows with differing QoSs and communicating information in different directions.  \nTelephone: STREAM_INTERFACE = \nBEGIN \n  FLOW_SPEC 1 AUDIO IN  64, 20, 5, 10 \n  FLOW_SPEC 2 AUDIO OUT 64, 20, 5, 10 \nEND. \nFigure 3 : An example stream interface \nWithin our platform stream bindings are established using an explicit bind operation (see \nfigure 4) which takes as parameters the source and sink interfaces to be bound and a further set of \ndesired QoS parameters. As with stream interfaces, these parameters can include a specification \nof the desired throughput, latency and jitter associated with the binding. More details of the \nspecification of QoS parameters for continuous media bindings can be found in14. \n! {src} <- traderRef$Import(\"Telephone\",\"context\",\"properties\") \n! {sink} <- traderRef$Import(\"Telephone\",\"context\",\"properties\") \n! {binding_control_ir} <- binder$Bind (Stream,src,sink,QoS) \nFigure 4 : Creating an explicit stream binding \nClients are returned a binding control interface as a result of an explicit bind operation (see \nfigure 5). To conform to the RM-ODP all explicit binding control interfaces must support at least \nthe operation unbind, but in addition the control interfaces for our stream bindings contain a \nnumber of other operations, e.g. to connect and disconnect sources and sinks. To control the QoS \nof the stream once the binding has been established the control interface includes a pair of \noperations setQoS() and getQoS(). These operations take as arguments a set of QoS parameters \nwhich can then be passed by the stream binding to the underlying transport protocol. A call-back \nmechanism is also provided to inform client objects of QoS degradations reported by the \nunderlying transport service.  \n8 \nBindingControl : INTERFACE = \nBEGIN \n  Callback :  TYPE =  { QoSViolationCallback, \n                          ClientMemberPolicy, \n                          ServerMemberPolicy }; \n  Unbind :   OPERATION   [ ] \n   RETURNS [ ] ; \n  SetQoS :   OPERATION  [ NewQoS : QoS ] \n             RETURNS  [ Status, QoS ]; \n  GetQoS :   OPERATION   [ ] \n   RETURNS  [ QoS ]; \n  Add :   OPERATION  [ Int : Interface ]  \n   RETURNS  [ Status ]; \n  Remove :   OPERATION  [ Int : Interface ] \n             RETURNS  [ Status ]; \n  Register :  OPERATION  [ Callback_Type : Callback; \n                            Callback_Interface : Interface ] \n              RETURNS  [ Status ]; \n  DeRegister :  OPERATION  [ Callback_Type : Callback; \n                              Callback_Interface : Interface ] \n                RETURNS [ Status ]; \nEND. \nFigure 5 : IDL specification of the binding control interface \nMulticast and multidrop bindings can be established by supplying grouped stream interfaces \nas parameters to the bind operation or by connecting additional sources and sinks once the \nbinding has been established using operations on the stream binding control interface. Further \ndetails on both modelling and engineering aspects of stream bindings can be found in 13,14,15. \nIn addition to stream bindings for the transmission of continuous media we have also added a \nnew class of explicit binding for use with operational interfaces. These bindings are established \nusing the binder$Bind operation as above but take as arguments operational interfaces. The \nresulting binder control interface is identical to that used for stream bindings except that clients \nare allowed to specify and monitor a different set of QoS parameters associated with the binding. \nThis enables, for example, a client to ask to be informed when the QoS service supplied by the \nbinding falls below a specified threshold. Of particular relevance to mobile applications is the \nability to monitor the possibility of sending or receiving messages via a specified binding without \nhaving to explicitly send application level test messages, i.e. applications can delegate \nresponsibility for guaranteeing QoS assertions to the system. This is of significance since it \nallows mobile applications to be structured in an event based fashion (c.f. polling). For example, \nthrough the use of our bindings it is possible to assert that the absence of messages on a given \ninterface is a result of their being no traffic intended for the specified interface rather than a result \nof communications failure. In addition, QoS driven bindings allow the system to optimise the use \nof test messages which might otherwise be duplicated if left to individual applications, e.g. if \nmultiple applications wished to test QoS assertions between the same pair of objects. Further \ndetails of the structural changes in applications and system services possible as the result of the \n9 \nintroduction of QoS driven bindings can be found in4). \n4. Implementation of a Collaborative Mobile Application \n4.1. Functionality and User Interface Design \nWe have implemented a mobile collaborative multimedia application which is designed to \nassist field engineers in their day-to-day work (see section 2) and exercise the distributed systems \nplatform described in section 3. More specifically, the application allows engineers to perform the \nfollowing functions: \n(i) View and manipulate maps and circuit diagrams on their mobile computer using a \ncustomised GIS system. \n(ii) Establish conferences of engineers with support for audio communication between \nparticipants. \n(iii) Exploit the functionality of the GIS in a conference setting, i.e. show and \nmanipulate maps and diagrams to all or a subset of the conference participants. \nHighlighting or 'Red-Lining' of the images is also permitted by the GIS. \nThere has, to our knowledge, been no previous work on the design of user interfaces for \ncollaborative applications in a mobile environment (interfaces for collaborative applications \nrunning on fixed networks have of course been an area of intense research within the CSCW \ncommunity for a number of years, e.g.16). In developing a user interface for our application we \nhave attempted to integrate experience from fixed environments with the novel features of mobile \nenvironments. While it is easy to anticipate that characteristics of mobile computers such as \nreduced screen sizes and resolutions impact on user interface design, it is perhaps more surprising \nthat the limitations of the communications infrastructure also have a profound impact on interface \ndesign.  \nSTATUS\nNIGE\nGRASS 4.0\nGRASS 4.0\nGRASS CONTROLLER\nSELECTED COLOUR  :          WHITE\nSELECTED INCOMING MONITOR : X1\nSELECTED WORKING MONITOR : X1\nDISPLAY RASTER DISPLAY VECTOR\nPLACE TEXT\nLOAD HISTORY\nSAVE HISTORY\nSHOW HISTORY\nSELECT COLOURHI LIGHT\nHISTORY  FOR  MONITOR  X0\nCROSSES  :-\nWHITE  CROSS  AT  12124, 12123\nWHITE  CROSS  AT  12134, 12128 \nCOMMS\nKEITH NIGE KEITH\nSTAND ALONE OPERATION\nGROUP OPERATION\nSTART\nCANCEL\nSTOP\nQUIT ADD\nCONNECT\nDISCONNECT\nREMOVE\n \nFigure 6 : The user interface \nA component of our user interface which has been specifically designed to cater for low-\nquality communication infrastructures is the interface to the conference manager or group co-\n10 \nordinator component of the application. This is shown in the top left of figure 6. On the left hand \nside are icons representing the sub-applications or modules which are available to the user (the \ntelephone represents audio communications and the globe GIS services) and on the right hand \nside are icons representing users that can participate in conferences. In the centre is a list of the \ncurrent conference participants. Under each participant's icon is a column of further icons which \nrepresent the modules which that user is currently running in conference mode. By selecting these \nicons in rows the user is able to easily direct messages to a subset of the conference members. For \nexample, in figure 2 the user is involved in audio communications with all the members of the \nconference. Hence, the output from the users microphone is communicated to both participants.  \nIn the group co-ordinator interface we have placed considerable emphasis on reporting to the \nuser the state of the communications links between local modules and remote users' modules. In \nour prototype this is done by colouring the modules under each user in the central portion of the \ndisplay to reflect connectivity. Using this information users are able to determine which modules \nare currently working well and can therefore be used freely and which are having problems with \ntheir communications links and should be avoided. The group co-ordinators display is based on \ninformation passed to it by individual modules which monitor the state of their communications \nlinks. An outstanding issue in this area is how to reflect the actions the system may be taking to \ncompensate for poor communications links. For example, if a user in a conference continually \nbecomes disconnected for short periods of time the applications involved may decide simply to \nbuffer messages for this user and deliver them when the user becomes re-connected. Other \nmembers of the conference need to be aware of this strategy in order that they can compensate for \ndelays in responses from the user in question. \nFigure 6 also shows the user interfaces to the audio conferencing module (bottom left) and \nthe GIS services (bottom middle, bottom right and top right). The interface to the former module \nis extremely simple with only four buttons being supported. These allow users to toggle their \nmicrophones on and off, toggle the audio output between speakers and headphones and adjust the \nvolume of the audio output. The interface to the latter module (the GIS services) is more \ncomplex. The GIS module can support multiple display windows or monitors (two are shown in \nfigure 6) and the user interface allows users to select an appropriate monitor and display and \nmanipulate maps within the relevant window. A history of operations that the user has carried out \nin each monitor is displayed. In addition, the user can nominate one monitor as an incoming \nmonitor. In this case group operations by other conference members are directed to this window. \nTypical group operations include displaying maps and highlighting points of interest using a \nnumber of pre-defined highlighting tools. In addition, the history of commands associated with a \nmonitor can be edited and transmitted to group members as a means of passing state. It should be \nnoted at this point that it is a matter of policy whether or not conference participants' incoming \nmonitors are kept consistent. For example, it is possible to locally display a map at a different \nscale to other conference members. The application ensures that if group members do have shared \nmaps displayed at different scales highlighting points are placed\/scaled accordingly. \nThe design of the GIS interface also reflects the nature of the communications link. In \nparticular, we have avoided providing collaborative tools which behave badly over low \nbandwidth links or high-latency links. Examples of such tools include free-hand highlighting \ntools and 'shared pointers'. Instead we provide support for highlighting using pre-defined shapes \nsuch as circles, rectangles, lines, crosses and polygon lines. These enable us to transmit \nhighlighting information over very low bandwidth links. To overcome latency problems \nhighlighting marks are numbered uniquely within the group and these numbers can be displayed \nalong with the marks. In this way users can refer to highlighting points by their identifier which \nensures that all members of the conference are discussing the same highlighting mark. \n11 \n4.2. Architectural Design Philosophy \nOur key design philosophy is one of extensibility. From the users point of view this manifests \nitself in the 'tool-box' feel to the interface. In particular, the list of modules supported can be \nexpanded at any time and we anticipate field engineers configuring their applications to use sub-\nsets of the available modules. We rely on the host's windowing system to provide features to \nallow users to make best use of their display (e.g. facilities to iconise and re-size windows). \nIn terms of implementation, the application is structured as a number of RM-ODP compatible \nservice providers. Moreover, we enforce the computational model requirement that all \ncommunication is via object invocation. Hence, we prohibit, for example, applications using the \nX protocol or X multiplexors (e.g.17) to implement collaborative interfaces. Enforcing this aspect \nof the computational model has a number of benefits. Firstly, we are able to support operation in \na truly heterogeneous environment: since objects only communicate using invocations new \nimplementations of our application need only support the basic invocation mechanism and the \nprescribed service interfaces in order to inter-work with all existing implementations. In addition, \nsince all communication is explicit we avoid building in dependencies on windowing systems \n(e.g. X or Microsoft Windows) and the risk of incurring hidden overheads which are often \nassociated with windowing system protocols. For example, the difficulties associated with using \nthe X protocol for communication to mobile hosts is reported by Kantarjiev in18. \nThe drawback with our approach is that we require customised applications. However, since \nthere has been little positive experience with using conventional applications in a collaborative \ncontext19, we believe that the benefits of our approach outweigh this drawback, particularly given \nthe specific nature of our application domain. In order to simplify the development of \ncollaborative applications for use in our environment we have implemented support for \nconference management within a single service, the group co-ordinator. This ensures that all \napplications share a common view of the participants in a conference and reduces the complexity \nof the applications. In the following sections we describe the group co-ordinator service and our \ntwo collaborative applications: the audio conferencing module and the GIS module. \n4.3. The Group Co-ordinator \nThe conference manager or group co-ordinator is responsible for establishing and maintaining \ngroups of users and coordinating the activities of the various modules that are operating in \nconference mode. The relationship between the conference manager and the various modules is \nsummarised in figure 7. \nModule\nGroupRegister\nModuleCallBack\nGroupGUI\nModule\nGroup \nCoordinator\n1\nGroup \nCoordinator\n3\n2\nGUI\n5\nModule\nGroupRegister\nModuleCallBack\nGroupGUI\nModule\nGroup \nCoordinator\n1\nGroup \nCoordinator\n3\n2\nGUI\n5\n4\n4\n \n12 \nFigure 7 : Group Co-ordinator Architecture \nModules register their existence with their local GroupCoordinator using the GroupRegister \ninterface (binding 1). The GroupCoordinator is then able to control the module as required using \nthe module's Module interface (binding 2). Typical control operations include starting and \nstopping the module as a result of either local or remote requests. GroupCoordinators can also \nreport events to registered modules (e.g. group membership changes) using a back call interface, \nModuleCallBack (binding 3). It is up to the modules to react to these changes. In addition, users \ncan toggle applications between group and stand-alone mode via the group co-ordinator. This \ninformation is propagated to registered modules. \nGroupCoordinator : INTERFACE = \nBEGIN \nConnectRequest :  OPERATION  [ user:User ]  \n   RETURNS  [ User; GC_Status ]; \nAddUser :   OPERATION  [ user:User ]  \n   RETURNS  [ GC_Status ]; \nRemoveUser :  OPERATION  [ user:User ]  \n   RETURNS  [ GC_Status ]; \nDisconnectRequest:OPERATION  [ user:User ]  \n   RETURNS  [ GC_Status ]; \nStartRequest :  OPERATION  [ userid: INTEGER;  \n       module:Module ] \n    RETURNS  [ Module;  \n       GC_Status ]; \nAddModule :  OPERATION  [ userid:INTEGER;  \n       module:Module ] \n    RETURNS  [ GC_Status ]; \nRemoveModule :  OPERATION  [ userid:INTEGER;  \n       module:Module ] \n    RETURNS  [ GC_Status ]; \nStopRequest :  OPERATION  [ userid:INTEGER;  \n       module:Module ] \n   RETURNS  [ GC_Status ]; \nEND. \nFigure 8 : The Group Co-ordinator Internal Interface \nChanges to the group membership and group related control operations are propagated \nthroughout the group by the GroupCoordinators using their internal GroupCoordinator interfaces \n(binding 4) (see figure 8). Finally, the GroupCoordinator can be controlled by any client \n(typically a user interface) using the GroupGUI interface (binding 5).  \nConducting all conference management functions within the group co-ordinator simplifies the \nimplementation of collaborative applications but means that the performance of the group co-\nordinators is critical. We have chosen to implement these using a fully distributed protocol for \nmaintaining the group state. The advantage of this approach is that it avoids a central point of \nfailure and thus should make the implementation more robust in the face of failure. The \n13 \ndisadvantage is that substantially more network traffic is required to ensure that each member of \nthe group has a consistent view of the group state when compared to implementations with a \ncentral control point. It is possible to argue that in a wireless environment reduction in network \ntraffic is more important than avoiding a single point of failure since this single point can be \nplaced on a static machine attached to the fixed network backbone. This solution exploits the \nrelatively plentiful resources found in static networks to reduce the load on mobile hosts (a \nstrategy which frequently has benefits in a mobile environment20). However, this solution \nassumes a cellular based wireless communications infrastructure in which messages between \nmobile hosts always pass through a base station and thus can be intercepted and processed on the \nstatic network for little or no cost. Within our application domain we wish to be able to support \noperation over non-cellular wireless communications systems for which no backbone exists and \nin this case having a central point of failure would be unacceptable. Hence, as described above, \nwe have implemented our group co-ordinators in a distributed fashion. We return to the issue of \ngroup protocols for mobile hosts in section 5. \n4.4. Audio Conferencing Co-ordinator and Support Services \nThe audio conferencing co-ordinator is responsible for establishing and maintaining audio \ncommunications between conference participants. Each participant must support a pair of device \nobjects with stream interfaces to capture and playback audio. The audio conferencing co-\nordinator then establishes stream bindings between these interfaces and those of other conference \nparticipants. In our current implementation stream bindings can only interconnect stream \ninterfaces with a single flow signature. Thus, two stream interfaces are required: one for audio in \nand one for audio out. In the near future we expect to extend our implementation to support \nmultiple flow signatures within single stream interfaces.  \nMultidrop and multicast stream bindings are supported and are used by the audio \nconferencing co-ordinator to establish conference calls. Information regarding changes to the \nconference membership is propagated to the audio conferencing co-ordinator by the group-co-\nordinator and the stream bindings are modified accordingly. Note that in our Ethernet \nimplementation optimisations are made for the special case of point-to-point communication. \nThis enables us to obtain adequate performance for trial purposes using conventional \nworkstations and networking infrastructure.  \n4.5. GIS Co-ordinator and Support Services \nThe Geographic Information System (GIS) services provide a set of standard services to \ndisplay and manipulate geographical information. Each host supports these services which \noperate on local copies of geographic data. The services are offered via two distinct interfaces \n(figure 9). The first of these interfaces offers display oriented operations. The second interface \nprovides management oriented services (e.g. map set management). It should be noted that all \nGIS service operations expect co-ordinates expressed as 'world co-ordinates' rather than in a \nwindow system specific co-ordinate system. \nDisplayFunction : INTERFACE =  \nBEGIN   \n GetBoxWld:     OPERATION  [ ] \n                    RETURNS    [ NECoords \n        DS_Status ]; \n DrawBoxWld:    OPERATION  [ BoxColour : Colour;  \n         BoxCoords : NECoords ]   \n14 \n                    RETURNS    [ DS_Status ]; \n Erase :     OPERATION  [ BckgColour : Colour ] \n                    RETURNS    [ DS_Status ]; \n Zoom :      OPERATION  [ ] \n                    RETURNS    [ DS_Status ]; \n DisplayRaster :   OPERATION  [ RasterToShow : MapName ] \n                   RETURNS    [ DS_Status ]; \n DisplayVector :   OPERATION  [ VectorToShow : MapName;  \n        LineColour : Colour ] \n                        RETURNS    [ DS_Status ]; \nEND. \n \nMapsetManagement : INTERFACE =    \nBEGIN \n Copy :     OPERATION  [ TypeOfFile : TypeOfFile;  \n        NametoCopy : MapName;  \n             Mapset : MapsetName;   \n         NameOfNewCopy : MapName ] \n                   RETURNS    [ MM_Status ]; \n List :     OPERATION  [ TypeOfFile : TypeOfFile;  \n        Mapset : MapsetName ] \n                   RETURNS    [ ListSize;  \n        MapList;  \n        MM_Status ]; \n SetRegion :  OPERATION  [ Coords : NECoords ] \n                   RETURNS    [ MM_Status ]; \nEND \nFigure 9 : GIS Map Management Interface \nIn our implementation we have provided these services using a trimmed down version of the \ndevelopment libraries of an existing public domain GIS called GRASS (Geographic \nResources Analysis Support System)21. These libraries support the functionality required \nby field engineers (see section 2.2) and have been integrated with those of our extended \nversion of ANSAware to form objects which support the interfaces shown in figure 9. \nUsers interact with the services via a GUI supported by the GIS co-ordinator object. This \nobject passes control messages (e.g. zoom) to the local GIS service providers. In addition, the co-\nordinator object is responsible for propagating GIS related messages to other members of the \nconference when the application is in group mode. This propagation is handled by individual \nmodule co-ordinators such as the GIS co-ordinator rather than by the group co-ordinator service \nsince the nature of the messages which are to be propagated are generally application dependent. \nTo illustrate this consider the scenario in which a user operating in group mode wishes to perform \na zoom operation on their local display server and propagate the command to other group \nmembers. On selecting zoom (the zoom operation is invoked on the local display server) the user \nis presented with a rubber-band box and is prompted to drag out the area onto which to zoom. \nThe rectangular area which is selected then becomes the boundaries of the new current region and \n15 \nthe display is re-drawn. It is inappropriate to invoke the same operation i.e. \u2018zoom\u2019 on the remote \ndisplay servers of the other group members. If this was done then the other members would end \nup being presented with a rubber-band drag box. Instead it is necessary to invoke region-oriented \noperations on the remote management servers of other group members to specify the newly \nselected region.  \nIt must be stressed at this point that only control messages are passed between hosts which \nare collaborating (i.e. we do not transfer maps, nor do we transfer windowing events). The issue \nof ensuring that each host has a local copy of the relevant map can, we believe, be solved using a \nmobile file system and is, in the scenarios which we have encountered a simple task since \nrelatively few maps are actually required by field engineers during the course of their work. \n5. Using RM-ODP and ANSAware in a Mobile Environment \nWe have not discovered any aspect of the current RM-ODP which would prohibit a \ncompliant system operating in a mobile environment. Indeed, there are a number of features of \nthe RM-ODP which make such systems particular suitable for operation in a mobile environment. \nThese include the abstraction and encapsulation arising as a result of the use of public interfaces, \nthe deferment of object placement issues until configuration-time, the notion of explicit bindings \nand the well defined model for partitioning the service name space using federated traders. \nThe use of public interfaces and encapsulation have enabled us to be confident that the \nimplementation of individual components within our application can change even at run-time. \nThis should, for example, enable us to allow field engineers using different GISs (supporting our \nGIS service interfaces) to collaborate. The benefits of location and migration transparency are \nwell documented (e.g.12) and these have allowed us to develop our application such that we can \ndynamically re-configure the mapping of objects to hosts in order to trade-off processing and \ncommunication overheads (e.g. we could chose to place some of the co-ordination services \nremotely if processing cycles were at a premium but communications bandwidth was relatively \nplentiful). \nExplicit bindings in the RM-ODP provide a mechanism for applications to specify a \nrequirement for a continuing level of QoS from the communications infrastructure. We have now \nimplemented a large number of multimedia applications using explicit stream bindings and have \nfound no serious difficulties with their use (some application programmers have noted that a \nconsiderable amount of code is required to set up stream bindings between multiple objects but \nthis can easily be remedied by the provision of simple macros for common stream operations) 15. \nExplicit operational bindings provide programmers with a tool for abstracting over some of the \nproblems associated with mobile communications. In particular, they allow a wide range of \napplication structures to be supported. \nFinally, the proposed trader function within the RM-ODP allows traders to inter work by \nsupporting the concepts of syndicated and federated traders. In addition, it has a rich set of polices \nfor specifying the behaviour of traders, particularly with reference to their interactions with other \ntraders. Hence, it is possible to configure a mobile host with its own local trader which attempts \nto match all service requests from local clients. If a matching service offer can not be located for \na given client request then the decision to consult remote traders for a matching offer can be taken \non the basis of, for example, the cost of obtaining the service remotely or the bandwidth currently \nbeing supplied by the communications infrastructure. \nWhile the RM-ODP offers benefits to developers of mobile applications we have found the \nANSAware platform unsuitable for use in a mobile environment in its current form. This \n16 \nunsuitability is primarily a result of the assumption by the ANSAware developers that the \nplatform would operate over standard fixed networks with Ethernet like characteristics. This \nassumption manifests itself primarily in the implementation of the following components; the \nremote execution protocols REX and GEX, the binding function, and the trader function. \nThe problem with the REX protocol is that it takes no account of the characteristics of the \nunderlying network. More specifically, parameters such as the number of retry attempts and the \ninterval between these attempts are fixed at installation time. Thus, when a system configured to \noperate over an Ethernet is run over a low-speed network the absence of congestion control \nwithin REX means that almost no data is actually communicated between user processes. Instead, \nthe network becomes overloaded with REX control messages. Note that while different transport \nprotocols can be placed underneath REX the execution protocol does not take account of any \nfeedback such protocols might provide regarding (for example) congestion control. \nThe GEX protocol is wholly unsuitable for use over many wireless networks. The protocol \nhas been designed to avoid a central point of failure for group communication. Instead, group \nevents such as membership changes and message arrivals are co-ordinated by all group members \nexchanging state information using an internal token-based protocol. This generates multiple \nredundant messages if hardware broadcast is supported and involves the establishment of multiple \npoint-to-point connections between group members if hardware broadcast is not supported. \nIn ANSAware the binding function does not support explicit bindings. This removes the \npossibility of supporting continuous media and of monitoring the QoS of a communications \nchannel between two processes. The arguments for these facilities have already been presented in \nsection 3.3. The removal of the concept of explicit bindings however has further implications \nsince it forces REX to be implemented as a connectionless protocol. Thus, for each invocation \nREX headers are larger than necessary (an invocation with 1 byte of user data generates a REX \nmessage of 96 bytes). To support explicit bindings in our modified version of ANSAware we are \nin the process of developing a number of new protocols. The first of these has been in operation \nfor some time and supports the transmission of continuous media via stream bindings. The \nprotocol optimises mixing of continuous media by re-locating the mixing process based on the \nbinding configuration. In order to support explicit bindings between operational interfaces we are \ndeveloping a pair of new execution protocols called QEX (Quality-of-service driven remote \nEXecution) and G-QEX (Group-Quality-of-service driven remote EXecution). These protocols \nwill gather information on specified bindings based on (for example) the number of retries and \naverage delay they experience over a given channel and be able to pass this information on to \ninterested clients. This will allow our new protocols to implement congestion control and to \npropagate this information to applications in order that they can 'back-off' to further reduce \nnetwork traffic. In the case of G-QEX we hope to be able to adjust the protocol's approach to \nsupporting groups (i.e. centralised or distributed) based on network and user QoS information. \nWhere necessary QEX and G-QEX will periodically test bindings in order to be able to guarantee \nQoS assertions. \nFinally, the implementation of the trading function in ANSAware assumes a high-speed \ncommunication link between federated traders. In particular, local traders do not cache the results \nof queries to remote traders. Thus each time a service is requested a query must be sent to the \nremote trader and the matching offers returned. This is clearly inefficient since only weak \nconsistency is required between local and remote traders. Hence caches could be maintained with \nminimal overhead. \n17 \n6. Concluding Remarks \nIn this paper we have discussed the issue of support for collaborative multimedia applications \nin a mobile environment. A typical application scenario has been described and the requirements \narising from this scenario highlighted. A design for a platform which addresses these \nrequirements has been presented. The key features of our platform are: \n(i) Compliance with open systems standards allowing operation in a heterogeneous \nenvironment. \n(ii) Stream interfaces to allow the specification of continuous media devices. \n(iii) Explicit bindings between stream interfaces to allow the transmission of \ncontinuous media. \n(iv) Explicit bindings between operational interfaces to allow applications to monitor \ncommunications QoS. \nThe implementation of our platform has been carried out using the ANSAware platform and \nthis has proved to have many positive aspects for use in a mobile environment. However, we have \nidentified a number of weaknesses, most crucially in the remote execution protocols, which must \nbe addressed before ANSAware can operate successfully in a mobile environment. We are \ntherefore currently in the process of modifying ANSAware to remedy these deficiencies. In \nimplementation terms we have completed the implementation of explicit stream bindings and \nstream interfaces and have designed (but not implemented) explicit bindings for operational \ninterfaces and pair of new supporting execution protocols QEX and G-QEX. \nIn order to evaluate our platform we have fully implemented a mobile collaborative \napplication which has been demonstrated operating over a low-speed network emulator. This \napplication has a number of important features:- \n(i) An extensible architecture based on the RM-ODP computational model. \n(ii) A group co-ordinator service which provides a common view of group \nmembership across multiple sub-applications. \n(iii) Propagation of events by applications using object invocation (c.f. application \nindependent propagation or reliance on windowing system protocols). \n(iv) Collaboration aware tools designed specifically for use over low-bandwidth \nnetworks. \nIn addition, the application provides users with feedback on the state of communications \nbetween all conference participants and collaborative tools. This novel feature allows users to \nadjust their style of working to suit the current QoS being provided by the communications \ninfrastructure. \nOur future work consists of developments to both the platform and the application. Following \nthe implementation of QEX and G-QEX our platform will be moved to an environment based on \nthe Chorus operating system 22. This will enable us to add QoS driven communications support at \na low-level, thus obviating the need to duplicate QoS monitoring functionality in bindings \nbetween both stream and operational interfaces. The application is shortly to be used as part of a \nfield trial by a UK regional electricity board in order to gain feedback from real end-users. \n18 \nAcknowledgements \nThe work described in this chapter was carried out under the auspices of the MOST project \n(SERC\/DTI Grant No. GR\/H87704). The authors would like to acknowledge the assistance of the \nU.K. regional electricity companies in determining the requirements of mobile utilities workers \nand their co-workers in EA Technology, Capenhurst and the Distributed Multimedia Research \ngroup at Lancaster University. \nReferences \n1. Duchamp, D.  \"Issues in Wireless Mobile Computing.\" Proc. Third Workshop on \nWorkstation Operating Systems, Key Biscayne, Florida, U.S.A., 1992. IEEE Computer \nSociety Press, Pages 2-10. \n2. Katz, R.H.  \"Adaption and Mobility in Wireless Information Systems.\" IEEE Personal \nCommunications Vol. 1 No. 1. Pages  6-17.  \n3. ISO. \"Draft Recommendation X.901: Basic Reference Model of Open Distributed \nProcessing - Part1: Overview and Guide to Use\", Draft Report 1992. \n4. Davies, N., S. Pink, and G.S. Blair.  \"Services to Support Distributed Applications in a \nMobile Environment.\" Proc. 1st International Workshop on Services in Distributed and \nNetworked Environments (To Appear), Prague, Czech Republic, June 1994.  \n5. Anderson, D.P., S. Tzou, R. Wahbe, R. Govindan, and M. Andrews.  \"Support for \nContinuous Media in the Dash System.\" Proc. 10th International Conference on Distributed \nComputing Systems, Paris, May 1990.  \n6. Keeton, K., B.A. Mah, S. Seshan, R.H. Katz, and D. Ferrari.  \"Providing Connection-\nOriented Network Services to Mobile Hosts.\" Proc. USENIX Symposium on Mobile and \nLocation Independent Computing, Cambridge, Massachusetts, U.S.A., August 2-3, 1993. \nPages 83-102. \n7. Mah, B., S. Seshan, K. Keeton, R. Katz, and D. Ferrari.  \"Providing Network Video Service \nto Mobile Clients.\" Proc. 4th Workshop on Workstation Operating Systems (WWOS-IV), \nNapa, U.S., October 14-15, 1993.  \n8. Davies, N., G.S. Blair, A. Friday, A.D. Cross, and P.F. Raven.  \"Mobile Open Systems \nTechnologies For The Utilities Industries.\" Proc. IEE Colloquium on CSCW Issues for \nMobile and Remote Workers, London, U.K., March 16, 1993. \n9. Cross, A.D., J.R. Brailsford, and A.T. Brint.  \"Expert Systems to Support Network \nSwitching.\" Proc. 12th International Conference on Electricity Distribution, CIRED 1993, \nBirmingham, U.K., 17-21 May, 1993.  \n10. OMG. \"The Common Object Request Broker: Architecture and Specification (CORBA)\", \nReport 91.12.1, The Object Management Group. 1991. \n11. OSF. \"Distributed Computing Environment: An Overview\", Open Software Foundation. \nApril 1991. \n12. A.P.M. Ltd. \"The ANSA Reference Manual Release 01.00\", APM Cambridge Limited, UK. \nMarch 1989. \n13. Coulson, G., G.S. Blair, N. Davies, and N. Williams.  \"Extensions to ANSA for Multimedia \nComputing.\" Computer Networks and ISDN Systems No. 25. Pages  305-323.  \n14. Coulson, G., G.S. Blair, F. Horn, L. Hazard, and J.B. Stefani.  \"Supporting the Real-Time \nRequirements of Continuous Media in Open Distributed Processing.\" Computer Networks \nand ISDN Systems (To Appear). \n19 \n15. Davies, N., G. Coulson, N. Williams, and G.S. Blair.  \"Experiences of Handling Multimedia \nin Distributed Open Systems.\" Proc. 3rd USENIX International Symposium on Experiences \nwith Distributed and Multiprocessor Systems, Newport Beach, CA, U.S.A., March 1992.  \n16. Greenberg, S., and R. Bohnet.  \"GroupSketch: A multi-user sketchpad for geographically-\ndistributed small groups.\" Proc. Graphics Interface '91, 1991. Pages 207-215. \n17. Abdel-Wahab, H.M., and M.A. Feit.  \"XTV: A Framework for Sharing X Window Clients in \nRemote Synchronous Collaboration.\" Proc. IEEE Tricomm '91: Communications for \nDistributed Applications and Systems, 1991. Chapel Hill,  \n18. Kantarjiev, C.K., A. Demers, R. Frederick, R.T. Krivacic, and M. Weiser.  \"Experiences \nwith X in a Wireless Environment.\" Proc. USENIX Symposium on Mobile and Location \nIndependent Computing, Cambridge, Massachusetts, U.S.A., August 2-3, 1993. Pages 117-\n128. \n19. Lauwers, J.C., and K.A. Lantz.  \"Collaboration Awareness in Support of Collaboration \nTransparency: Requirements for the Next Generation of Shared Window Systems.\" Proc. \nCHI 1990, 1990. Pages 303-310. \n20. Badrinath, B.R., A. Acharya, and T. Imielinski.  \"Structuring Distributed Algorithms for \nMobile Hosts.\" Proc. 14th International Conference on Distributed Computer Systems (To \nAppear), Poznan, Poland, June 21-24, 1994.  \n21. Westervelt, J. \"Introduction to GRASS 4\", GRASS Information Center, U.S. Army CERL, \nChampaign, Illinois, U.S. July 1991. \n22. Rozier, M., V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. \nKaiser, S. Langlois, P. L\u00e9onard, and W. Neuhauser. \"Overview of the CHORUS Distributed \nOperating System\", Technical Report CS\/TR-90-25, Chorus syst\u00e9mes. 1990. \n"}