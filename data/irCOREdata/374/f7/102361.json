{"doi":"10.1109\/TIT.2004.826673","coreId":"102361","oai":"oai:epubs.surrey.ac.uk:1820","identifiers":["oai:epubs.surrey.ac.uk:1820","10.1109\/TIT.2004.826673"],"title":"Duality and Support Weight Distributions","authors":["Schaathun, Hans Georg"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2004-01-01","abstract":"<p>We show how to compute the support weight distribution A(i)(r) for r greater than or equal to k - d1\/2 + 3, where d1\/2 is the second minimum support weight of a code, provided the weight enumerator of the dual code is known.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1820<\/identifier><datestamp>\n      2017-10-31T14:03:16Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1820\/<\/dc:relation><dc:title>\n        Duality and Support Weight Distributions<\/dc:title><dc:creator>\n        Schaathun, Hans Georg<\/dc:creator><dc:description>\n        <p>We show how to compute the support weight distribution A(i)(r) for r greater than or equal to k - d1\/2 + 3, where d1\/2 is the second minimum support weight of a code, provided the weight enumerator of the dual code is known.<\/p><\/dc:description><dc:date>\n        2004-01-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1820\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Schaathun, Hans Georg  (2004) Duality and Support Weight Distributions   IEEE Transactions on Information Theory, 50 (5).  pp. 862-867.      <\/dc:identifier><dc:relation>\n        10.1109\/TIT.2004.826673<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1820\/","10.1109\/TIT.2004.826673"],"year":2004,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"862 IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 50, NO. 5, MAY 2004\nProof: We have\nx2C ;y2C\n\u0019(yjx)=\nx2C y2C [C\n\u0019(yjx)\u0000\nx2C y2C\n\u0019(yjx):\n(6)\nAs C1 [ C2 is distance-invariant, (5) implies that\nx2C y2C [C\n\u0019(yjx) = M1[Pue(C1 [ C2; p) + (1\u0000 p)\nn]: (7)\nFurthermore, from (4)\nx2C y2C\n\u0019(yjx) = M1[Pue(C1; p) + (1\u0000 p)\nn]: (8)\nSubstituting (7) and (8) into (6) yields\nx2C ;y2C\n\u0019(yjx) = M1 [Pue(C1 [ C2; p)\u0000 Pue(C1; p)] :\nSimilarly, by interchanging the indexes 1 and 2\nx2C ;y2C\n\u0019(yjx) = M2 [Pue(C1 [ C2; p)\u0000 Pue(C2; p)] :\nSince (3) implies \u0019(yjx) = \u0019(xjy), we have\nx2C ;y2C\n\u0019(yjx) =\nx2C ;y2C\n\u0019(yjx):\nEquations (1) and (2) which are essentially Theorems 1 and 11 in [1]\nreadily follow from Theorem 1 by taking C1 [ C2 to be equal to Vn\nand Vn;w , respectively. Clearly, we have Pue(Vn; p) = 1 \u0000 (1\u0000 p)n\nwhich gives (1). Furthermore, it is easy to check that\nPue(Vn;w; p) =\nw\ni=1\nw\ni\nn\u0000 w\ni\np\n2i(1\u0000 p)n\u00002i:\nThis expression, althoughmore elementary than fn;w(p), can be shown\nto equal the latter to yield (2), see [2].\nThe condition that C1 [C2 being distance-invariant is necessary in\ngeneral for Theorem 1 to hold. Indeed, let C1 and C2 be the (5; 2)2\ncodes given by\nC1 = f00000;00011g and C2 = f00101;11011g:\nIt is straightforward to check that\nPue(C1; p) = p\n2(1\u0000 p)3\nPue(C2; p) = p\n4(1\u0000 p)\nand\nPue(C1 [C2; p) = 2p\n2(1\u0000 p)3 + p4(1\u0000 p):\nTheorem 1 does not hold in this case. Notice that C1 [ C2 is not dis-\ntance-invariant. Although it is very easy to come up with examples to\nshow the nonvalidity of the theorem ifC1[C2 is not distance-invariant,\nthis example is interesting since the distance distribution and the weight\ndistribution of C1 [ C2 coincide [4, p. 158].\nIn fact, if C1 [ C2 is not distance-invariant, then one should not\nexpect any relation between the undetected error probabilities of C1,\nC2, and C1 [ C2, that depend on nothing else besides their sizes and\nlengths, to hold in general. We show this by an example that makes\nuse of the codes C1 and C2 of the previous paragraph. Let C02 be the\n(5; 2)2 code given by\nC\n0\n2 = f01100;01111g:\nThen\nPue(C1; p) = Pue(C\n0\n2; p) = p\n2(1\u0000 p)3\nand\nPue(C1 [C\n0\n2; p) = 2p\n2(1\u0000 p)3 + p4(1\u0000 p):\nNotice that C1 [ C2 and C1 [ C 02 have the same parameters and the\nsame undetected error probabilities, while C2 and C 02 have the same\nparameters but different undetected error probabilities.\nREFERENCES\n[1] F. -W. Fu, T. Kl\u00f8ve, and V. K. -W. Wei, \u201cOn the undetected error\nprobability for binary codes,\u201d IEEE Trans. Inform. Theory, vol. 49, pp.\n382\u2013390, Feb. 2003.\n[2] F. -W. Fu, T. Kl\u00f8ve, and S. -T. Xia, \u201cOn the undetected error proba-\nbility ofm-out-of-n codes on the binary symmetric channel,\u201d in Coding\nTheory, Cryptography, and Related Areas, J. Buchmann, T. H\u00f8holdt, H.\nStichtenoth, and H. Tapia-Recillas, Eds. Berlin, Germany: Springer-\nVerlag, 2000, pp. 102\u2013110.\n[3] T. Kl\u00f8ve and V. I. Korzhik, Error Detecting Codes. Norwell, MA:\nKluwer, 1995.\n[4] F. J. MacWilliams and N. J. A. Sloane, The Theory of Error-Correcting\nCodes. Amsterdam, The Netherlands: North-Holland, 1977.\nDuality and Support Weight Distributions\nHans Georg Schaathun, Member, IEEE\nAbstract\u2014We show how to compute the support weight distribution\nfor + 3, where is the second minimum support weight\nof a code, provided the weight enumerator of the dual code is known.\nIndex Terms\u2014Dual code, support weight distribution.\nI. INTRODUCTION\nWe have observed some recent interest in the support weight distri-\nbutions, particularly those of self-dual codes [2], [7]. Possibly, these\nparameters may lead to nonexistence proofs, finally determining the\nhighest minimum distance of self-dual codes with certain lengths. The\noriginal motivation for introducing the support weight distribution was\nto compute the weight enumerator for certain infinite classes of cyclic\ncodes [3]. The weight enumerator, in turn, is used for the computation\nof error probabilities in error-control systems.\nKl\u00f8vehaspreviously shownhowtocompute thesupportweightdistri-\nbutionAri ,providedthatweknowAri forr0 \u0014 rofthedualcode.Thisre-\nsultappearedfirstin[5]andwasformulatedasageneralizedMacWilliams\nidentity in [6]. A different proof of this result appeared in [9].\nIn[8],weexploredarelationbetweenacodeandtheprojectivemultiset\ncorrespondingtothedualcode.Inthesequel,wewillusethisrelationtode-\nterminesupportweightdistributionsofhighorders.Whereaspreviousre-\nsults relyon solvinga large set of equations, theMacWilliams-type iden-\ntities, we find formulas which are faster to compute.\nWe hope that this will take us one step closer toward the complete\ndetermination of support weight distributions of some self-dual codes,\nfor instance, the [72; 36; 16] Type II code. It is not known whether this\ncode exists or not.\nManuscript received July 13, 2001; revised December 2, 2003. The work was\nsupported in part by the Research Council of Norway.\nThe author is with the Department of Informatics, University of Bergen,\nN-5020 Bergen, Norway (e-mail: georg@ii.uib.no).\nCommunicated by S. Litsyn, Associate Editor for Coding Theory.\nDigital Object Identifier 10.1109\/TIT.2004.826673\n0018-9448\/04$20.00 \u00a9 2004 IEEE\nAuthorized licensed use limited to: University of Surrey. Downloaded on March 02,2010 at 11:28:18 EST from IEEE Xplore.  Restrictions apply. \nIEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 50, NO. 5, MAY 2004 863\nII. PROJECTIVE MULTISETS AND DUALITY\nThere is a well-studied correspondence between projective multisets\nand linear codes. In its easiest description, the projective multiset is\nobtained by taking the columns of some generator matrix of the code,\ncounting multiplicities [4]. We will keep this description in mind, but\nstill develop a more mathematically rigorous description, which will\naid us in the study of duality. This description follows the one presented\nin [8].\nA. Vectors, Codes, and Multisets\nA multiset is a collection of elements which are not necessarily dis-\ntinct. More formally, we define a multiset \r on a set S as a map \r :\nS ! f0; 1; 2; . . .g. The number \r(s) is the number of occurrences of\ns in the collection \r. The map \r is always extended to the power set of\nS\n\r(S0) =\ns2S\n\r(s); 8S0 \u0012 S:\nThe number \r(s) or \r(S0) is called the value of s or S0. The size of \r\nis the value \r(S). We will be concerned with multisets of vectors. We\nwill always keep the informal view of \r as a collection in mind.\nWe consider a fixed finite field q with q elements. A message word\nis a k-tuple over q , while a codeword is ann-tuple over q . Let be a\nvector space of dimension k (the message space), and a vector space\nof dimension n (the ambient space). The generator matrix G gives a\nlinear, injective transformation G : ! , and the code C is simply\nthe image under G.\nThe columns of G form a multiset \rC on . Two codes are said\nto be permutation equivalent if one is obtained from the other by re-\nordering the columns of the generator matrix, and thus \rC defines C\nup to permutation equivalence. Two codes are also equivalent if one can\nbe obtained from the other by replacing acolumn g ofG by\u000bg for some\nnonzero scalar \u000b. Hence, the codeC can alternatively be defined by the\nprojective multiset \r0C obtained by mapping \rC into (k\u00001; q), the\nprojective geometry of dimension k \u0000 1 over q .\nWe say that two multisets \r0 and \r1 on are equivalent if \r1 =\n\r0 \u000e\u001e for some automorphism \u001e on . Such an automorphism is given\nby \u001e : g 7! gA whereA is a square matrix of full rank. Replacing each\ncolumn gi by giA in G is equivalent to replacing the message m by\nAm. In other words, equivalent multisets give different encoding, but\nthey give the same code. This is an important observation, because it\nimplies that the coordinate system on is not essential.\nLet B := fe1; e2; . . . ; eng be the coordinate basis of . The vec-\ntors may be considered as linear forms on . There is a natural en-\ndomorphism \u0016 : ! =C?, where \u0016(v) = v + C?. The ele-\nments of =C? are linear forms onC , and \u0016(ei)(c) = gim whenever\nc =mG. So whenC is identified with , gi will correspond to \u0016(ei),\nestablishing an isomorphism between =C? and and proving the\nfollowing lemma.\nLemma 1: A code C \u0012 is given by the vector multiset \rC :=\n\u0016(B) on =C? \u0018= .\nGiven a collection fs1; s2; . . . ; smg of vectors and\/or subsets of\na vector space , we write hs1; s2; . . . ; smi for its span. In other\nwords, hs1; s2; . . . ; smi is the intersection of all subspaces containing\ns1; s2; . . . ; sm.\nB. Weights\nWe define the support \u001f(c) of c 2 C to be the set of coordinate\npositions not equal to zero, that is,\n\u001f(c) := fi j ci 6= 0g; where c = (c1; c2; . . . ; cn):\nThe support of a subset S \u0012 C is\n\u001f(S) =\nc2S\n\u001f(c):\nThe weight (or support size) w(S) is the cardinality of \u001f(S). The ith\nminimum support weight di(C) is the smallest weight of an i-dimen-\nsional subcode Di \u0012 C . The subcode Di will be called a minimum\ni-subcode. The weight hierarchy of C is (d1(C); d2(C); . . . ; dk(C)).\nThe support weight distribution of C is the set of parameters\nfAri (C) : i = 1; . . . ; n; r = 0; . . . ; kg, where Ari (C) is the number\nof r-dimensional subcodes of weight i.\nThe following lemma was proved in [4], and the remark is a simple\nconsequence of the proof.\nLemma 2: There is a one-to-one correspondence between subcodes\nD \u0012 C of dimension r and subspaces U \u0012 of codimension r, such\nthat \rC(U) = n \u0000 w(D).\nRemark 1: Consider two subcodes D1 and D2, and the corre-\nsponding subspaces U1 and U2. We have that D1 \u001a D2 is equivalent\nto U2 \u001a U1.\nWe define dk\u0000r(\rC) such that n\u0000 dk\u0000r(\rC) is the largest value of\nan r-space Vr \u0012 . From Lemma 2, we get the following corollary.\nCorrollary 1: If C is a linear code and \rC is the corresponding\nmultiset, then di(\rC) = di(C).\nC. Projective Spaces and Multisets\nA submultiset \r0 \u0012 \r is a multiset with the property that \r0(x) \u0014\n\r(x) for all x. If \r is a multiset on some vector space , we define a\ncross section of \r to be the restriction \rjU to some subspace U \u0012 .\nCross sections of projective multisets are defined in the same way.\nIn some cases, it is easier to deal with cross sections and their sizes\nthan with subspaces and their values. In particular, we have that n \u0000\ndk\u0000r(\rC) is the size of the largest r-dimensional cross section of \rC .\nLet\nk\nr\n=\nr\u00001\ni=0\nqk\u0000i \u0000 1\nqr\u0000i \u0000 1\ndenote the number of distinct linear r-spaces containing the origin. The\nnumber of r-spaces containing a givenm-space is given by\nk \u0000m\nr \u0000m\n:\nThe rth generalized Singleton bound states that dr \u0014 dk \u0000 k + r.\nThe code is r-maximum-distance separable (r-MDS) if it meets this\nbound with equality.\nConsider anm-space \u0005m \u0012 (k \u0000 1; q). Let\n\u0019\u0005 : (k \u0000 1; q)n\u0005m ! (k \u0000 2\u0000m; q)\nbe the projection map through \u0005m. Let C 0 be the code corresponding\nto \rC := \rC \u000e \u0019\u00001. Note that C 0 has parameters [n \u0000 \rC(\u0005m); k \u0000\n1 \u0000m]. Every r-space in (k \u0000 2 \u0000m; q) is the image of an (r +\nm+ 1)-space containing \u0005m in (k \u0000 1; q). Hence,\n\u0001r(C\n0) \u0014 \u0001r+m+1(C)\u0000 \rC(\u0005m):\nHence, if \u0005m has maximum value, then C 0 is (k \u0000 1 \u0000 m1 + m \u0000\n2)-MDS. Note that C 0 can be viewed as a subcode of C [1].\nD. Duality\nWrite (d1; . . . ; dk) for the weight hierarchy of C , and\n(d?1 ; . . . ; d\n?\nn\u0000k) for the weight hierarchy of C?. Let B \u0012 B.\nAuthorized licensed use limited to: University of Surrey. Downloaded on March 02,2010 at 11:28:18 EST from IEEE Xplore.  Restrictions apply. \n864 IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 50, NO. 5, MAY 2004\nThen \u0016(B) is a submultiset of \rC . Every submultiset of \rC is\nobtained this way. Obviously, dim hBi = #B. Let D := hBi \\ C?\nbe the largest subcode of C? contained in hBi. Then D is the kernel\nof \u0016jhBi, the restriction of \u0016 to hBi. Hence,\ndim h\u0016(B)i = dim hBi \u0000 dimD: (1)\nClearly, #B \u0015 w(D).\nWe are particularly interested in the case when when \u0016(B) is a cross\nsection of \u0016(B). This is, of course, the case if and only if \u0016(B) equals\nthe cross section \u0016(B)jh\u0016(B)i.\nLet U \u0012 =C? be a subspace. We have \u0016(B)jU = \u0016(B), where\nB = fe 2 B j \u0016(e) 2 Ug. Hence, we have \u0016(B) = \u0016(B)jh\u0016(B)i if\nand only if there exists no point e 2 BnB such that \u0016(e) 2 h\u0016(B)i.\nIt follows from (1) that a large cross section \u0016(B) of a given dimen-\nsion must be such that hBi contains a large subcode of C? of suffi-\nciently small weight.\nDefine for any subcode D \u0012 C?\n\f(D) := fex j x 2 \u001f(D)g \u0012 B:\nObviously, \f(D) is the smallest subset ofB such thatD is contained in\nits span. It follows from the preceding argument that ifD is a minimum\nsubcode and \u0016(\f(D)) is a cross section, then \u0016(\f(D)) is a maximum\ncross section for C . Thus, we are lead to the following two lemmas.\nLemma 3: If n\u0000 dr = d?i ,B \u0012 B, and#B = n\u0000 dr , then \u0016(B)\nis a cross section of maximum size and codimension r if and only if\nB = \f(Di) for some minimum i-subcode Di \u0012 C?.\nLemma 4: Let r be an arbitrary number, 0 < r \u0014 n \u0000 k. Let i be\nsuch that d?i \u0014 n \u0000 dr < d?i+1, and let Di \u0012 C? be a minimum\ni-subcode. Then \u0016(hBi) is a maximum r-subspace for any B \u0012 B\nsuch that Di \u0012 hBi and #B = n \u0000 dr .\nE. Support Weight Distributions\nLet ri (C) be the set of all r-spaces of value i, i.e.,\nr\ni (C) := f\u0005 \u0012 (k \u0000 1; q) j \rC(\u0005) = i; dim\u0005 = rg:\nWe define the value distribution of \rC to be\nV ri (\rC) = V\nr\ni (C) := #\nr\ni (C): (2)\nBy Lemma 2, each element of ri (C) corresponds to a k \u0000 1\u0000 r-di-\nmensional subcode of weight n\u0000 i. Hence, V ri (C) = Ak\u00001\u0000rn\u0000i (C).\nWe will mostly abbreviate and write V ri = V ri (C), Ari = Ari (C),\n~Ari = A\nr\ni (C\n?), and ~V ri = V ri (C?). Define\nmi = mi(C) := di(C\n?)\u0000 i\u0000 1:\nObviously,m0 = \u00001 andmn\u0000k = k \u0000 1. We will determine V ri for\nmj \u0014 r < mj+1 for j = 0 and j = 1. We start with a relatively\nsimple result.\nLemma 5: If mj+1 > mj , then\nV\nm\nm +j+1 =\n~Ajm +j+1\nV\nm\ni =0; i > mj + j + 1:\nProof: Consider anmj -space \u0005 for some j wheremj+1 > mj .\nFrom Lemma 3, we know that \u0005 has value d?j = mj + j + 1 if and\nonly if it contains xi for all i 2 \u001f(D) where D \u0012 C? is a j-dimen-\nsional subcode of weight d?j . This gives the first equation. The second\nequation is obvious.\nThe difference sequence (\u000e0; \u000e1; . . . ; \u000ek\u00001) is defined by\n\u000ei = dk\u0000i \u0000 dk\u00001\u0000i, and is occasionally more convenient than the\nweight hierarchy. The maximum value of an r-dimensional, projective\nsubspace is \u0001r = \u000e0 + \u0001 \u0001 \u0001 + \u000er = n \u0000 dk\u00001\u0000r .\nIII. THE NEW RESULTS\nThe following theorem was proved in [5].\nTheorem 1: For \u00001 \u0014 r < m1, and any code C , we have that\nV rj (C) = V\nr\nj (n; k) where\nVrj (n; k) =\nn\nj\nr\u0000j+1\ni=0\n(\u00001)i\nk \u0000 j \u0000 i\nr \u0000 j + 1\u0000 i\nn\u0000 j\ni\nfor any code C .\nOur result is the determination of V ir (C) whenm1 \u0014 r < m2. We\nknow that V ri = 0 for all i > r + 2.\nConsider an r-space\u0005 of value r+2. The cross section \rC j\u0005 defines\nan [r + 2; r + 1] code C0. Let s := m1(C 0). We say that \u0005 has Type\ns. Clearly, m1 \u0014 s \u0014 r. The set of r-spaces of Type s is denoted by\n(r; s).\nGiven an r-space \u00050 of value i \u0014 r + 1, we say that \u00050 is Type I if\nit contains a (i\u0000 2)-space\u000500 of value i. This (i\u0000 2)-space is unique\nwhen it exists. Clearly,\u000500 has Type s for some s, and then we say that\n\u00050 is Type I(s).\nIf \u00050 is not Type I, we say that it is Type II, and then it contains\na unique (i \u0000 1)-space of value i. Let ri (X) be the set of r-spaces\nof value i and Type X , where X is I, II, or I(s) for some s. Write\nUri (X) := #\nr\ni (X).\nA. Subspaces of Maximum Value\nIf C is an [n; n \u0000 1] code, there is a unique s such that \u000es(C) = 2,\nand \u000ei(C) = 1 for i 6= s. Clearly,m1(C) = s. In this case, we call C\nan [n; n \u0000 1] code of Type s.\nLemma 6: Let \rC be a projective multiset defining an [n; n \u0000 1]\ncode C of Type s. Then there is a unique s-space \u0005s of value s+ 2.\nProof: There exists at least one such s-space since s = m1 =\n\u0001s(C) \u0000 2. Suppose there are two distinct s-spaces \u00021 and \u00022 of\nvalue s+ 2. Let i be the dimension of \u0002 := \u00021 \\\u00022. Clearly, i < s\nand thus \rC(\u0002) \u0014 i + 1. We get\n\r(h\u00021;\u00022i) \u0015 2(s+ 2)\u0000 (i+ 1) = 2s\u0000 i+ 3\nbut\ndim h\u00021;\u00022i = 2s\u0000 i = 2s\u0000 i\nso\n\r(h\u00021;\u00022i) \u0014 \u00012s\u0000i(C) = 2s\u0000 i+ 2:\nThe lemma follows by contradiction.\nThere is only one [n; n \u0000 1] code of Type s up to equivalence. The\ncorresponding projective multiset is obtained by taking a frame for a\nprojective s-space and then adding projectively independent points to\nobtain an (n \u0000 2)-space.\nLemma 7: For any code C , ifm1 \u0014 s \u0014 r < m2, we have\n# (r; s) = ~A1s+2\nn\u0000 s\u0000 2\nr \u0000 s\n:\nProof: The number of maximum r-spaces of Type r = s is\n# (s; s) = ~A1s+2; (3)\nby Lemma 5.\nAuthorized licensed use limited to: University of Surrey. Downloaded on March 02,2010 at 11:28:18 EST from IEEE Xplore.  Restrictions apply. \nIEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 50, NO. 5, MAY 2004 865\nAn r-space\u0005r of Type s contains a unique s-space\u0005s of value s+2\nby Lemma 6. Hence, there is a one-to-one correspondence between\nr-spaces of Type s and pairs (\u0005s; S), where \u0005s 2 (s; s) and S \u001a\n\rCn\u0005s is a set of r \u0000 s points. There are ~A1s+2 ways to choose \u0005s by\n(3) and\nn\u0000 s\u0000 2\nr \u0000 s\nways to choose S. Hence, we get the result.\nLemma 8: If m1 \u0014 r < m2, then\nV\nr\nr+2 =\nr\ns=m\n~A1s+2\nn\u0000 s\u0000 2\nr \u0000 s\nV\nr\ni =0; i > r + 2:\nProof: An r-space of value r + 2 has Type s for some s where\nm1 \u0014 s \u0014 r. Thus, we can take the sum of the equation in Lemma 7.\nHence the result.\nB. When n = k + 1\nIn this subsection, we study an [n; n\u0000 1] code C of Type s. We will\nneed the number F(j; n; s) := Un\u00003j (II) for C in the later sections.\nWe obviously have thatF(j; n; s) = 0 if j \u0015 n\u00001.Whenn = s+2,\nC is MDS, so\nF(j; s+ 2; s) = Vs\u00001j (s+ 2; s+ 1): (4)\nLemma 9: For any [n; n \u0000 1] code of Type s, if j \u0014 n \u0000 2, then\nUn\u00003j (II) is given by\nF(i; n; s) =\ni\nj=0\nVs\u00001j (s+ 2; s+ 1)\nm\ni\u0000 j\n(q \u0000 1)m\u0000i+j\nwhere m = n \u0000 s \u0000 2.\nProof: Note that if n = s+ 2, the lemma reduces to (4).\nWe consider the projective space (n\u0000 2; q). We want to find the\nnumber F(i; n; s) of hyperplanes of value i and Type II. Consider an\narbitrary such hyperplane \u0005. There is a unique s-space \u0002 \u0012 (n\u0000\n2; q) of value s + 2. Every hyperplane must meet \u0002 in a subspace of\ndimension s\u0000 1 or more. Since\u0005 has Type II,\u00020 := \u0002\\\u0005 is exactly\nan (s \u0000 1)-space. Let j = \rC(\u00020).\nGiven j (0 \u0014 j \u0014 s), there are F(j; s + 2; s) ways to choose \u00020.\nLet \u00050 \u0012 \u0005 be the smallest subspace of value i and containing \u00020.\nGiven \u00020, we find \u00050 by choosing i \u0000 j points among the n \u0000 s \u0000 2\npoints of positive value not contained in \u0002. Given j, there are thus\nF(j; s+ 2; s)\nn\u0000 s\u0000 2\ni\u0000 j\n= Vs\u00001j (s+ 2; s+ 1)\nn\u0000 s\u0000 2\ni\u0000 j\nways to choose \u00050.\nConsider now the projection \u0019\u0005 . The multiset \r00 := \rC \u000e \u0019\u00001\u0005\ndefines an [n\u0000 i; n\u0000 1\u0000 s\u0000 i+ j] code. There is but one point x of\nvalue \r00(x) = s+2\u0000 j, namely, x = \u0019\u0005 (\u0002). The remaining points\nhave value 0 or 1. We define a new projective multiset \r0 by \r0(x) = 1\nand \r0(y) = \r00(y) for y 6= x. The corresponding code is a projective\n[n0; n0] code where n0 = n \u0000 i \u0000 s \u0000 1 + j.\nFinding\u0005 \u00050 of value i is the same as finding a hyperplane of zero\nvalue for \r0, which is the same as counting one-dimensional subcodes\nof weight n0 for the [n0; n0] code. This number is (q \u0000 1)n \u00001. The\nlemma follows by summing over all j.\nC. Other Subspaces\nNow we return to the general [n; k] code C , in order to determine\nV rj for j \u0014 r + 1.\nProposition 1: Form1 \u0014 r < m2 and r \u0015 i\u0000 2, we have\nU\nr\ni (I(s)) =V\nr+1\u0000i\n0 (n\u0000 i; k + 1\u0000 i) ~A\n1\ns+2\nn\u0000 s\u0000 2\ni\u0000 s\u0000 2\nU\nr\ni (I) =V\nr+1\u0000i\n0 (n\u0000 i; k + 1\u0000 i)V\ni\u00002\ni :\nFor r < i \u0000 2, we have Uri (I) = Uri (I(s)) = 0.\nProof: We have from Lemma 7, that\nU\ni\u00002\ni (I(s)) = ~A\n1\ns+2\nn\u0000 s\u0000 2\ni\u0000 2\u0000 s\n:\nAn r-space of value i and Type s contains a unique (i \u0000 2)-space \u00050\nof value i and Type s. There are U i\u00002i (I(s)) ways to choose \u00050.\nConsider then the multiset \r0 := \rC \u000e \u0019\u00001\u0005 obtained by projection\nthrough \u00050. We know that \r0 defines an [n \u0000 i; k + 1 \u0000 i] code C 0.\nFinding an r-space \u0005 \u00050 of value i corresponds to finding an (r +\n1\u0000 i)-space of value 0 for \r0. Furthermore, \r0 defines a code with\n\u0001m \u0000i(C\n0) \u0014 \u0001m \u00001(C)\u0000 i = m2 + 1\u0000 i:\nHence, C 0 is (k\u00001\u0000m2+i)-MDS, and since r+1\u0000i\u0014m2\u0000i, there\nare Vr+1\u0000i0 (n\u0000i; k+1\u0000i) ways to choose \u0005 \u00050. This proves the\nfirst equation, and the second one follows by summing over all s.\nProposition 2: Ifm1 < j \u0014 m2, we have\nU\nj\u00001\nj (II) =\nn\nj\n\u0000 U j\u00002j (I)\u0000\nj\u00001\ns=m\n(s+ 2)U j\u00001j+1 (I(s)):\nFor i > j, we have U j\u00001i (II) = 0.\nProof: We consider all the n\nj\npossible ways to chose a set S\nof j points of positive value. To find U j\u00001j (II), we must subtract the\nnumber of cases where these j points generate a subspace of Type I.\nSince j \u0000 1 < m2, we have three cases:\n1) dim hSi = j \u0000 1 and \rC(hSi) = j (Type II);\n2) dim hSi = j \u0000 2 and \rC(hSi) = j (Type I);\n3) dim hSi = j \u0000 1 and \rC(hSi) = j + 1 (Type I).\nThe number of sets S giving the first case is U j\u00001j (II), while for the\nsecond case, it is U j\u00002j (I). The third case is more difficult, because S\ndoes not contain all points of positive value in hSi. Suppose hSi has\nType s. Then hSi can be chosen in U j\u00001j+1 (I(s)) different ways. There\nis one point x 62 S of positive value in hSi, and x must be contained in\nthe unique s-space \u0005s \u0012 hSi of value s+ 2. Moreover, x can be any\npoint of positive value in \u0005s, hence, there are s + 2 different choices\nfor S giving the same hSi of the third case. This gives the lemma.\nLet\n(r1; v1; X1; r2; v2; X2)\n= f(\u00051;\u00052) j \u00051 \u0012 \u00052;\u0005j 2\nr\nv (Xj); j = 1; 2g:\nWe will write vj = \u0003 (resp., Xj = \u0003) when we allow any value of vj\n(resp., Xj ).\nLemma 10: Ifm1 \u0014 r < m2 and 0 \u0014 j \u0014 r, then\nU\nr\nj (II) =\nq \u0000 1\nqr+1\u0000j \u0000 1\nU\nr\u00001\nj (II)\nqk\u0000r \u0000 1\nq \u0000 1\n\u0000\nr+2\nv=j+1\n# (r \u0000 1; j; II; r; v; \u0003) :\nProof: We will count the number of elements of (r \u0000\n1; j; II; r; j; II) in two different ways. Consider a pair\n(\u00050;\u0005) 2 (r \u0000 1; j; II; r; j; II):\nAuthorized licensed use limited to: University of Surrey. Downloaded on March 02,2010 at 11:28:18 EST from IEEE Xplore.  Restrictions apply. \n866 IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 50, NO. 5, MAY 2004\nThere are U rj (II) ways to choose \u0005. For \u00050, we can choose any (r \u0000\n1)-space containing the unique (j \u0000 1)-space of value j in \u0005. Hence,\n# (r \u0000 1; j; II; r; j; II) =Urj (II)\nr + 1\u0000 j\nr \u0000 j\n=Urj (II)\nqr+1\u0000j \u0000 1\nq \u0000 1\n: (5)\nThis gives the first of the two expressions we seek.\nNow we observe that\n# (r \u0000 1; j; II; r; \u0003; \u0003) =\nr+2\nv=j\n# (r \u0000 1; j; II; r; v; \u0003): (6)\nThis number can equivalently be obtained by counting the number of\n(r \u0000 1)-spaces of value j and Type II, and the number of r-spaces\ncontaining each such space. This gives\n# (r \u0000 1; j; II; r; \u0003; \u0003) =Ur\u00001j (II)\nk \u0000 r\n1\n=Ur\u00001j (II)\nqk\u0000r \u0000 1\nq \u0000 1\n: (7)\nClearly, we have that\n# (r \u0000 1; j; II; r; j; I) = 0;\nand if we combine this with with (6) and (7), we get\n# (r \u0000 1; j; II; r; j; II) = Ur\u00001j (II)\nqk\u0000r \u0000 1\nq \u0000 1\n\u0000\nr+2\nv=j+1\n# (r \u0000 1; j; II; r; v; \u0003)\nwhich is our second expression for# (r\u00001; j; II; r; j; II). Combining\nthis with (5), we get the lemma.\nLemma 11: If j < v \u0000 1, then\n# (r \u0000 1; j; II; r; v; I(s)) = Urv (I(s))F(j; v; s)qr+2\u0000v:\nProof: Consider a pair\n(\u00050;\u0005) 2 (r \u0000 1; j; II; r; v; I(s)):\nThere are Urv (I(s))ways to choose\u0005. There is a unique (v\u00002)-space\n\u0002 \u0012 \u0005 of value v and Type s. The intersection \u00020 := \u00050 \\ \u0002 is a\n(v \u0000 3)-space of value j. There are F(j; v; s) ways to choose \u00020.\nConsider the projection \u0019\u0002 . Finding \u00050 is the same as finding a\nhyperplane in \u0019\u0002 not meeting \u0019\u0002 (\u0002), which is a point. There are\n(qr+3\u0000v \u0000 1)=(q \u0000 1) hyperplanes in \u0019\u0002 , of which (qr+2\u0000v \u0000\n1)=(q \u0000 1) meet \u0019\u0002 (\u0002). Hence, there are qr+2\u0000v hyperplanes not\nmeeting \u0019\u0002 (\u0002).\nLemma 12: If j < v, then\n# (r \u0000 1; j; II; r; v; II) = Urv (II)Vv\u00002j (v; v)q\nr+1\u0000v:\nProof: Consider a pair\n(\u00050;\u0005) 2 (r \u0000 1; j; II; r; v; II):\nThere are Urv (II) ways to choose \u0005. There is a unique (v \u0000 1)-space\n\u0002 \u0012 \u0005 of value v, and \rC j\u0002 defines a [v; v] code. The intersection\n\u00020 := \u00050 \\ \u0002 is a (v \u0000 2)-space of value j. There are Vv\u00002j (v; v)\nways to choose \u00020.\nConsider the projection \u0019\u0002 . Finding \u00050 is the same as finding a\nhyperplane in \u0019\u0002 not meeting \u0019\u0002 (\u0002), which is a point. There are\nqr+1\u0000v such hyperplanes.\nWe define for brevity\n(r; j) :=\nr+2\nv=j+1\n# (r \u0000 1; j; II; r; v; \u0003):\nProposition 3: We have\n(r; j) =\nr+2\nv=j+2\nqr+2\u0000v Urv\u00001(II)Vv\u00003j (v \u0000 1; v \u0000 1)\n+\nr\ns=m\nUrv (I(s))F(j; v; s) :\nProof: First note that\n# (r \u0000 1; j; II; r; r + 2; II) = 0;\nbecause Urr+2(II) = 0, and that\n# (r \u0000 1; j; II; r; j + 1; I) = 0\nbecause there is no subspace of value j in a subspace of value j + 1\nand Type I. Now the result follows from Lemmas 11 and 12.\nProposition 4: Ifm1 \u0014 r < m2 and 0 \u0014 j \u0014 r, then\nUrj (II) =\nqk\u0000r \u0000 1\nqr+1\u0000j \u0000 1\nUr\u00001j (II)\u0000\nq \u0000 1\nqr+1\u0000j \u0000 1\n(r; j)\nwhere (r; j) is given by Proposition 3.\nProof: This is simply a rephrase of Lemma 10.\nIf we combine all the results of this correspondence, we get the fol-\nlowing theorem as a conclusion.\nTheorem 2: For k \u0015 r > k+2\u0000d2(C?), it is possible to compute\nAri (C) for all i provided we know the (first) weight enumerator ofC?.\nWe have for k + 1 \u0000 d1(C?) < r \u0014 k, that\nAri (C) =\nn\nn\u0000 i\nk+i\u0000r\u0000n\nj=0\n(\u00001)j\nk \u0000 n+ i\u0000 j\nk \u0000 r \u0000 n+ i\u0000 j\ni\nj\nand for k + 2\u0000 d2(C?) < r \u0014 k + 1\u0000 d1(C?), that\nAri (C) = U\nk\u00001\u0000r\nn\u0000i (II) + U\nk\u00001\u0000r\nn\u0000i (I)\nwhere Uk\u00001\u0000rn\u0000i (II) and U\nk\u00001\u0000r\nn\u0000i (I) are given by Propositions 1, 2,\nand 4.\nIV. DISCUSSION OF FUTURE WORK\nWe have found formulas for computing some high-order support\nweight distributions. The formulas are good for electronic computa-\ntion of the parameters, and, for instance, computing the third through\nthe 24th support weight distribution of the [24; 12] Golay code is a\nmatter of seconds. On the other hand, simplified formulas more com-\nprehensible to human readers would definitely be an improvement.\nIt will not be too difficult to continue and compute Ari (C) for\nk \u0000 d?2 + 2 \u0015 r > k + 3\u0000minfd\n?\n3 ; 2d\n?\n1 g\nprovided the second support weight distribution of C? is known. We\nhave omitted these results, because they would be too tedious, without\nadding significantly to the understanding of the subject.\nTo go below k + 3 \u0000 2d?1 is more difficult, because if i \u0015 2d?1 ,\nwe may have a codeword c 2 C? and a subcode D \u0012 C? of dimen-\nsion more than one, such that \u001f(c) = \u001f(D). This codeword c will be\ncounted in ~A1i , but for computing Arj only D should be counted. It is\na long way to making a general statement for r \u0014 k+ r\u0000 2d?1 , but in\nspecial cases there may be possibilities.\nWe have tried to compute support weight distributions of the tenta-\ntive [72; 36] Type II self-dual code. By combining Theorems 1 and 2\nAuthorized licensed use limited to: University of Surrey. Downloaded on March 02,2010 at 11:28:18 EST from IEEE Xplore.  Restrictions apply. \nIEEE TRANSACTIONS ON INFORMATION THEORY, VOL. 50, NO. 5, MAY 2004 867\nwith the MacWilliams\u2013Kl\u00f8ve identities, we are left with about 100 un-\nknowns. There is a chance that this system may be solved completely\nby extending the techniques presented here, and combining it with all\nthe techniques found in the literature. That will be extensive labour in\nitself, so we leave it to future work.\nACKNOWLEDGMENT\nThis work was inspired by Steven Dougherty\u2019s talk at WCC in Paris,\nFrance, in January 2001. Private correspondence with Aaron Gulliver,\ncoauthor of the mentioned talk, has been very valuable during the re-\nsearch. Finally, I wish to thank Torleiv Kl\u00f8ve for his continuous advice\nas a supervisor, concerning presentation and publication, and also for\nhis help in finding and understanding [5].\nREFERENCES\n[1] S. Dodunekov and J. Simonis, \u201cCodes and projective multisets,\u201d Elec-\ntron. J. Combin., vol. 5, no. 1, 1998.\n[2] S. Dougherty, A. Gulliver, and M. Oura, \u201cHigher weights and graded\nrings for binary self-dual codes,\u201d in Discr. Appl. Math. (Special issue\nfor WCC 2001), vol. 128, 2003, pp. 251\u2013261.\n[3] T. Helleseth, T. Kl\u00f8ve, and J. Mykkeltveit, \u201cThe weight distribution of\nirreducible cyclic codes with block lengths n1((ql \u0000 1)=n),\u201d Discr.\nMath., vol. 18, pp. 179\u2013211, 1977.\n[4] T. Helleseth, T. Kl\u00f8ve, and \u00d8. Ytrehus, \u201cGeneralized Hamming weights\nof linear codes,\u201d IEEE Trans. Inform. Theory, vol. 38, pp. 1133\u20131140,\nMay 1992.\n[5] T. Kl\u00f8ve, \u201cThe weight distribution of linear codes overGF (ql)having\ngenerator matrix over GF (q),\u201d Discr. Math., vol. 23, pp. 159\u2013168,\n1978.\n[6] , \u201cSupport weight distribution of linear codes,\u201d Discr. Math., vol.\n106\/107, pp. 311\u2013316, 1992.\n[7] O. Milenkovic, \u201cOn the generalized Hamming weight enumerators and\ncoset weight distributions of even isodual codes,\u201d in Proc. IEEE Int.\nSymp. Information Theory, Washington, DC, June 2001, p. 62.\n[8] H. G. Schaathun, \u201cDuality and greedy weights for linear codes and pro-\njective multisets,\u201d in Applied Algebra, Algebraic Algorithms and Error-\nCorrecting Codes (Lecture Notes in Computer Science). Berlin, Ger-\nmany: Springer-Verlag, 2001, vol. 2227, pp. 92\u2013101.\n[9] J. Simonis, \u201cThe effective length of subcodes,\u201d Appl. Algebra Eng.\nCommun. Comput., vol. 5, no. 6, pp. 371\u2013377, 1994.\nDesign and Decoding of Optimal High-Rate\nConvolutional Codes\nAlexandre Graell i Amat, Student Member, IEEE,\nGuido Montorsi, Member, IEEE, and Sergio Benedetto, Fellow, IEEE\nAbstract\u2014This correspondence deals with the design and decoding\nof high-rate convolutional codes. After proving that every ( 1)\nconvolutional code can be reduced to a structure that concatenates a block\nencoder associated to the parallel edges with a convolutional encoder\ndefining the trellis section, the results of an exhaustive search for the\noptimal ( 1) convolutional codes is presented through various\ntables of best high-rate codes. The search is also extended to find the \u201cbest\u201d\nrecursive systematic convolutional encoders to be used as component\nencoders of parallel concatenated \u201cturbo\u201d codes. A decoding algorithm\nworking on the dual code is introduced (in both multiplicative and additive\nform), by showing that changing in a proper way the representation of\nthe soft information passed between constituent decoders in the iterative\ndecoding process, the soft-inpu soft-output (SISO) modules of the decoder\nbased on the dual code become equal to those used for the original code.\nA new technique to terminate the code trellis that significantly reduces the\nrate loss induced by the addition of terminating bits is described. Finally,\nan inverse puncturing technique applied to the highest rate \u201cmother\u201d\ncode to yield a sequence of almost optimal codes with decreasing rates is\nproposed. Simulation results applied to the case of parallel concatenated\ncodes show the significant advantages of the newly found codes in terms of\nperformance and decoding complexity.\nIndex Terms\u2014Block codes, convolutional codes, dual codes, high-rate\ncodes, inverse puncturing, iterative decoding, puncturing, trellis termina-\ntion, turbo-like codes.\nI. INTRODUCTION\nAs the need for increasingly high data rate communications intensi-\nfies, the resources, like bandwidth and energy, become scarce and pre-\ncious. For instance, magnetic recording and fiber-optic applications re-\nquire both very high data rates (from one to several tens of gigabits per\nsecond) and very low code redundancies, thus, calling for high coding\ngains and very high code rates simultaneously.\nTraditionally, algebraic block codes have been preferred for very\nhigh coding rates because of the better performance\/complexity com-\nparison with respect to convolutional codes. Indeed, to keep the de-\ncoding complexity reasonably low for high-rate convolutional codes,\none needs to resort to punctured codes [1]\u2013[3], which become rather\nweak in terms of distance spectrum (or just free distance) for the heavy\npuncturing required to get very high rates. On the other hand, punc-\ntured convolutional codes yield the advantage of flexibility, i.e., they\noffer a wide range of code rates without modifying the co-decoding\nalgorithm, which remains essentially the same needed to decode the\nrate-1=2 mother code.\nWith the advent of concatenated codes with interleavers (or\nturbo-like codes), hard-in hard-out (like those used for algebraic\nblock codes) and soft-in hard-out (as the Viterbi algorithm) decoding\nalgorithms must be replaced by soft-input soft-output (SISO in the\nfollowing) symbol decoding algorithms to be embedded into the\nManuscript received December 10, 2002; revised November 20, 2003. This\nwork was supported in part by ST Microelectronics and Qualcomm Inc. The\nmaterial in this correspondence was presented in part at the IEEE Information\nTheory Workshop, Bangalore, India, October 2002, and at the IEEE Global\nCommunications Conference, San Francisco, CA, December 2003.\nThe authors are with the Politecnico di Torino, 10129 Torino, Italy (e-mail:\ngraell@polito.it; montorsi@polito.it; benedetto@polito.it).\nCommunicated by S. Litsyn, Associate Editor for Coding Theory.\nDigital Object Identifier 10.1109\/TIT.2004.826669\n0018-9448\/04$20.00 \u00a9 2004 IEEE\nAuthorized licensed use limited to: University of Surrey. Downloaded on March 02,2010 at 11:28:18 EST from IEEE Xplore.  Restrictions apply. \n"}