{"doi":"10.1109\/TC.2007.1022","coreId":"102368","oai":"oai:epubs.surrey.ac.uk:1827","identifiers":["oai:epubs.surrey.ac.uk:1827","10.1109\/TC.2007.1022"],"title":"Dynamic balanced key tree management for secure multicast communications","authors":["Ng, WHD","Howarth, MP","Sun, Zhili","Cruickshank, Haitham"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007","abstract":null,"downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1827<\/identifier><datestamp>\n      2017-10-31T14:03:17Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:656C656374726F6E6963656E67696E656572696E67:63637372<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1827\/<\/dc:relation><dc:title>\n        Dynamic balanced key tree management for secure multicast communications<\/dc:title><dc:creator>\n        Ng, WHD<\/dc:creator><dc:creator>\n        Howarth, MP<\/dc:creator><dc:creator>\n        Sun, Zhili<\/dc:creator><dc:creator>\n        Cruickshank, Haitham<\/dc:creator><dc:date>\n        2007<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1827\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Ng, WHD, Howarth, MP, Sun, Zhili and Cruickshank, Haitham  (2007) Dynamic balanced key tree management for secure multicast communications   IEEE Transactions on Computers, 56 (5).  pp. 590-605.      <\/dc:identifier><dc:relation>\n        10.1109\/TC.2007.1022<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1827\/","10.1109\/TC.2007.1022"],"year":2007,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"Dynamic Balanced Key Tree Management for\nSecure Multicast Communications\nWee Hock Desmond Ng, Michael Howarth, Zhili Sun, and Haitham Cruickshank\nAbstract\u2014A secure multicast communication is important for applications such as pay-per-view and secure videoconferencing. A key\ntree approach has been proposed by other authors to distribute the multicast group key in such a way that the rekeying cost scales with\nthe logarithm of the group size for a join or depart request. The efficiency of this key tree approach critically depends on whether the\nkey tree remains balanced over time as members join or depart. In this paper, we present two Merging Algorithms suitable for batch\njoin requests. To additionally handle batch depart requests, we extend these two algorithms to a Batch Balanced Algorithm. Simulation\nresults show that our three algorithms not only maintain a balanced key tree, but their rekeying costs are lower compared with those of\nexisting algorithms.\nIndex Terms\u2014Multicast security, group key management, secure group communication.\n\u00c7\n1 INTRODUCTION\nINTERNET Protocol (IP) multicast [1] allows a sender totransmit a single copyof somedata,with network elements\nsuch as routers making copies as necessary for the receivers.\nThis approach reduces sender-processing overhead and\nnetwork bandwidth usage. This technology benefits many\ngroup communication applications [2], [3], [4], [5] such as\npay-per-view, online teaching, and share quotes.\nBefore these group-oriented multicast applications can\nbe successfully deployed, access control mechanisms must\nbe developed such that only authorized members can access\nthe group communication [6], [7], [8], [9], [10], [11], [12],\n[13], [14], [15], [16], [17]. The only way to ensure controlled\naccess to data is to use a shared group key, known only to\nthe authorized members, to encrypt the multicast data. As\ngroup membership might be dynamic, this group key has to\nbe updated and redistributed securely to all authorized\nmembers whenever there is a change in the membership in\norder to provide forward and backward secrecy. Forward\nsecrecy means that a departing member cannot obtain\ninformation about future group communication and back-\nward secrecy means that a joining member cannot obtain\ninformation about past group communication. We assume\nthe existence of a trusted entity, known as the Group\nController (GC), which is responsible for updating the\ngroup key. This allows the group membership to scale to\nlarge groups.\nA number of scalable approaches have been proposed\nand one in particular, the key tree approach [10], [11], [12],\n[13], [14], is analyzed in detail in this paper. In short, the key\ntree approach employs a hierarchy of keys in which each\nmember is assigned a set of keys based on its location in the\nkey tree. The rekeying cost of the key tree approach\nincreases with the logarithm of the group size for a join or\ndepart request. The operation for updating the group key is\nknown as rekeying and the rekeying cost denotes the\nnumber of messages that need to be disseminated to the\nmembers in order for them to obtain the new group key.\nIndividual rekeying, that is, rekeying after each join or\ndepart request, has two drawbacks [18]. First, it is inefficient\nsince each rekey message has to be signed for authentica-\ntion purposes and a high rate of join\/depart requests may\nresult in performance degradation because the signing\noperation is computationally expensive. Second, if the delay\nin a rekey message delivery is high or the rate of join\/\ndepart requests is high, a member may need a large amount\nof memory to temporarily store the rekey and data\nmessages before they are decrypted. Batch rekeying [18],\n[19], [20], [21], [22], [23] has been proposed to alleviate these\nproblems as a trade-off between performance and security.\nIn this scheme, the GC does not perform rekeying\nimmediately; instead, it consolidates the total number of\njoining and departing members during a time period before\nperforming the rekeying. A short rekey interval does not\nprovide much batch rekeying benefit, whereas a long rekey\ninterval causes a delay to joining members and increases\nvulnerability from departing members who can still receive\nthe data. A more detailed analysis of the trade-off among\nuser dynamics, group size, and rekey interval has been\npresented in [19].\nThe efficiency of the key tree approach critically depends\non whether the key tree is balanced [21], [24], [25], [26]. A\nkey tree is considered balanced if the distance from the root\nto any two leaf nodes differs by not more than 1 [26]. For a\nbalanced key tree with N members, the height from the root\nto any leaf node is logk N , where k is the outdegree of the\nkey tree, but, if the key tree becomes unbalanced, then the\ndistance from the root to a leaf node can become as high as\nN . In other words, this means that a member might need to\nperform N \u0002 1 decryptions in order to get the group key.\nFurthermore, in an unbalanced key tree, some members\n590 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\n. W.H.D. Ng is with AT&T Singapore, Block 85 The Cavendish #03-05\/08\nScience Park Drive, Singapore 118261. E-mail: desmondng@gmail.com.\n. M. Howarth, Z. Sun, and H. Cruickshank are with the Centre for\nCommunication Systems Research, University of Surrey, Guildford,\nSurrey GU2 7XH, UK.\nManuscript received 6 Feb. 2005; revised 7 Dec. 2005; accepted 28 Aug. 2006;\npublished online 13 Feb. 2007.\nFor information on obtaining reprints of this article, please send e-mail to:\ntc@computer.org, and reference IEEECS Log Number TC-0061-0205.\nDigital Object Identifier no. 10.1109\/TC.2007.1022.\n0018-9340\/07\/$25.00 \u0002 2007 IEEE Published by the IEEE Computer Society\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nmight need to store N keys, whereas some might only need\nto store two keys.\nIn this paper, we propose two Merging Algorithms\nsuitable for batch join events for combining subtrees\ntogether. These two Merging Algorithms not only balance\nthe key tree, but have lower rekeying costs compared to\nexisting algorithms. In other words, our Merging Algo-\nrithms allow all members in the multicast session to have\nsimilar storage and decryption requirements during each\nrekeying operation. Having a balanced key tree greatly\nbenefits mobile devices since they generally have limited\nstorage and computation power [4]; reducing the number of\ndecryptions needed by the mobile devices can help to\nconserve the battery power. In order to additionally handle\ndeparting members, we extend these two Merging Algo-\nrithms to a Batch Balanced Algorithm where the tree height\nadapts to the change in the group membership. However,\nthis requires a reorganization of the group members in the\nkey tree. Simulation results show that our Batch Balanced\nAlgorithm performs significantly better than existing algo-\nrithms when the number of joining members is greater than\nthe number of departing members or when the number of\ndeparting members is around N=k, with no joining\nmembers. For similar numbers of joining and departing\nmembers, our Batch Balanced Algorithm achieves the same\nperformance as that of existing algorithms. The rest of the\npaper is organized as follows: Section 2 covers the back-\nground and reviews existing work. We describe our\nproposed algorithms in Section 3. Section 4 describes our\nimplementation and presents the simulation results. Sec-\ntion 5 discusses some of the application scenarios where our\nBatch Balanced Algorithm may be used. We present our\nconclusions in Section 6.\n2 BACKGROUND\n2.1 Key Tree Approach\nIn a typical key tree approach [10], [11], [14], as shown in\nFig. 1a, there are three different types of keys: Traffic\nEncryption Key (TEK), Key Encryption Key (KEK), and\nindividual key. TheTEK is alsoknownas thegroupkeyand is\nused to encrypt multicast data. To provide a scalable\nrekeying, the key tree approach makes use of KEKs so that\nthe rekeying cost increases logarithmically with the group\nsize for a join or depart request. An individual key serves the\nsame function as KEK, except that it is shared only by the GC\nand an individualmember. In the example in Fig. 1a, K0 is the\nTEK, K1 to K3 are the KEKs, and K4 to K12 are the individual\nkeys. The keys that a group member needs to store are based\non its location in the key tree; in other words, each member\nneeds to store 1\u00fe logk N keys when the key tree is balanced.\nFor example, inFig. 1a,memberU1knowsK0,K1, andK4and\nmemberU7 knowsK0, K3, andK10. TheGCneeds to store all\nof the keys in the key tree.\nTo uniquely identify each key, the GC assigns an ID to\neach node in the key tree. The assignment of the ID is based\non a top-down and left-right order. The root has the lowest\nID, which is 0. For a node with an ID of m, its parent node\nhas an ID of b\u00f0m\u0002 1\u00de=kc, with its children\u2019s IDs ranging\nfrom km\u00fe 1 to km\u00fe k, as shown in Fig. 1b.\nWhen a member is removed from the group, the GC\nmust change all the keys in the path from this member\u2019s leaf\nnode to the root to achieve forward secrecy. All the\nmembers that remain in the group must update their keys\naccordingly. If the key tree is balanced, the rekeying cost for\na single departing member is k logk\u00f0N\u00de \u0002 1 messages. For\nexample, suppose member U9 is departing in Fig. 1a. Then,\nall the keys that it stores (K0 and K3) must be changed,\nexcept for its individual key. Let fxgy denote key x\nencrypted with key y and x0 denote the new version of\nkey x. Then, the GC needs to multicast the rekey messages\nfK30gK10, fK30gK11, fK00gK1, fK00gK2, and fK00gK30 to\nthe members, giving a total of five encrypted keys.\nIf backward secrecy is required, then a join operation is\nsimilar to a depart operation in that the keys that the joining\nmember receives must be different from the keys previously\nused in the group. The rekeying cost for a single joining\nmember is 2 logk N messages when the key tree is balanced.\nSuppose member U9 is joining the group. Then, the GC\nneeds to multicast the following rekey messages to the\nmembers: fK30gK3, fK30gK12, fK00gK0, and fK00gK30.\nThe efficiency of the key tree approach critically depends\non whether the key tree remains balanced. For a balanced\nkey tree with N leaf nodes, the height from the root to the\nany leaf node is logk N . However, if the key tree becomes\nunbalanced, the distance from the root to a leaf node can\nbecome as high as N . Fig. 2 shows an unbalanced key tree.\nFirst of all, we can see that key storage among the group\nmembers varies from 3 to 6 rather than 4 in a balanced\nbinary key tree of eight members. Second, U1 or U2 needs\nfive decryptions if its sibling departs rather than three\ndecryptions in a balanced key tree. Last, the rekeying cost is\n9 when U1 or U2 departs since K0, K1, K3, K7, and K11\nneed to be changed. For a balanced key tree, the rekeying\ncost for a departing member is only 5. In this example, the\ndifference between a balanced and an unbalanced key tree\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 591\nFig. 1. (a) Logical key tree. (b) Node ID assignment.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nvaries slightly as the group size is small. In a scenario such\nas pay-per-view, where the group membership varies from\nthousands to millions of members, an unbalanced key tree\nmight lead to significant computation efforts for both the\nGC and group members.\n2.2 Batch Rekeying\nBatch rekeying is when join\/depart requests are collected\nduring a time interval called the rekey interval and are\nrekeyed together. This approach is used in [18], [19], [20],\n[21], [22], [23]. This not only alleviates the individual\nrekeying problems described in Section 1 (that is, ineffi-\nciency, rekey message delay, and high join\/depart rates),\nbut also reduces the number of group rekey events.\nFurthermore, the number of rekey messages that need to\nbe multicast to the group can be much smaller than the\nnumber of rekey messages that would be generated if each\nmembership change were processed individually due to the\noverlapping in paths from the leaf nodes to the root.\n2.3 Related Work\nBefore we proceed further, we introduce some notations\nand definitions used in this paper. We use the term ST to\nindicate a subtree. We use \u201cminimum height\u201d to mean the\nminimum number of levels in a tree or subtree from the root\nto any leaf node. Similarly, we use \u201cmaximum height\u201d to\nmean the maximum number of levels in a tree or subtree\nfrom the root to any leaf node. We define the following\nvariables:\nMarking Algorithms have been proposed to update the\nkey tree and generate, at the end of each rekey interval, a\nrekey subtree with a collection of join and depart requests.\nSeveral variations of Marking Algorithms have been\nproposed [18], [20].\nWe refer to the algorithm in [18] as Marking Algorithm 1.\nFor this algorithm, there are four cases to consider. If J \u00bc D,\nthen all departing members are replaced by the joining\nmembers. If J < D, then we pick the J shallowest leaf nodes\nfrom the departing members and replace them with the\njoining members. By the term \u201cshallowest node,\u201d we mean\nthe leaf node of minimum height in our terminology. If\nJ > D and D \u00bc 0, then the shallowest leaf node is selected\nand removed. This leaf node and the joining members form\na new key tree that is then inserted at the old location of the\nshallowest leaf node. Next, if J > D and D > 0, then all\ndeparting members are replaced by the joining members.\nThe shallowest leaf node is selected from these replace-\nments and removed from the key tree. This leaf node and\nthe extra joining members form a new key tree that is then\ninserted at the old location of the removed leaf node. Last,\nthe GC generates the necessary keys and distributes them to\nthe members.\nThe algorithm in [20] is referred to here as Marking\nAlgorithm 2. There are only three cases to consider for this\nMarking Algorithm. Two of them, J \u00bc D and J < D, are\nsimilar to the one mentioned above, except that the nodes of\ndeparting members that are not replaced by the joining\nmembers are marked as null nodes. For J > D, all\ndeparting members are replaced by the joining members.\nIf there are null leaf nodes in the key tree, then they are also\nreplaced by the joining members, starting from the null\nnodes with the smallest node ID. If there are still extra\njoining members, then the member with the smallest node\nID is removed and it is inserted as a child, together with\nk\u0002 1 joining members at its old location. The next smallest\nnode ID member is selected if there are more joining\nmembers. This insertion continues until all of the joining\nmembers have been inserted into the key tree. As before, the\nGC distributes the new key to the members.\nBalanced Batch Logical Key Hierarchy (LKH) [21], [22]\nhas also been proposed to alleviate the inefficiency in\nMarking Algorithm 1 [18], but this algorithm is only\nsuitable for a binary key tree \u00f0k \u00bc 2\u00de and the author does\nnot offer a solution for a key tree with other outdegrees.\n3 BATCH REKEYING ALGORITHM\nWe now propose two Merging Algorithms [27] to combine\nsubtrees together in a way that is suitable for batch join\nevents. To handle all cases such as depart or both join and\ndepart requests, we then extend these two Merging\nAlgorithms into a Batch Balanced Algorithm. The two\nMerging Algorithms are used to combine two subtrees:\nST_A and ST_B. We assume that ST_A has a greater height\nthan ST_B and both subtrees are of the same outdegree k.\n3.1 Merging Algorithm 1\nThis algorithm is only used when the difference in the\nmaximum height between the two subtrees ST_A and ST_B\nis greater than or equal to 1. We will see why it is so in\nSection 4.\nWe now describe Merging Algorithm 1 [27] and illustrate\nit with some examples. The criteria for choosing Merging\nAlgorithm 1 are when the difference between HMAX ST A\nand HMIN ST B is greater than 1 and when the difference\nbetween HMAX ST A and HMAX ST B is greater than or equal\nto 1. If both of these conditions are fulfilled, then the\nalgorithm calculates HINSERT , as illustrated in Fig. 3. The\nfollowing steps are then performed:\nStep 1. For k > 2, the algorithm searches for an empty child\nnode in ST_Aat either levelHINSERT or levelHINSERT \u0002 1.\nIf HINSERT \u00bc 0, then levels 0 and 1 are searched. If such a\n592 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\nFig. 2. An unbalanced key tree.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nnode exists, then the algorithm inserts ST_B as the child\nof that particular key node.\nStep 2. If an empty node is not found in Step 1, mark a\nsuitable key node in ST_A at level HINSERT for insertion\nas follows: If HINSERT \u00bc 0, then a suitable key node at\nlevel 1 is marked. The marked key node is given by the\none with the greatest number of leaf nodes at level\nHMIN ST A. For example, in Fig. 3, there are two key\nnodes at level 1 \u00f0\u00bc HINSERT \u00de. Of these, key node ID 2 is\nmarked for insertion since it has two leaf nodes at level\nHMIN ST A, whereas key node ID 1 has only one.\nStep 3. For k > 2, when an empty node is not found in\nStep 1, the algorithm searches the root of ST_B for an\nempty node. If this exists, then the algorithm inserts the\nmarked key node from Step 2 as the child of ST_B and\ninserts ST_B at the old location of the marked key node.\nStep 4. For k \u00bc 2 or k > 2, if Steps 1 to 3 have not inserted\nST_B into ST_A, then the algorithm creates a new key\nnode at the old location of the marked key node (from\nStep 2) and inserts the marked key node and ST_B as its\nchildren.\nFinally, the GC may need to multicast at most one\nupdate message to inform the affected members. We will\ndiscuss the update message later in this section. After\nupdating the affected nodes, the members can identify the\nset of keys they need in the rekey messages.\nFig. 4 shows how we can combine the two subtrees by\nusing Step 1 in Merging Algorithm 1. Fig. 4a shows only a\npart of ST_A. Suppose there are three joining members and\nno departing members that are formed into a new subtree\nST_B, as shown in Fig. 4b. Since there is an empty node at\nlevel HINSERT \u0002 1 in ST_A (node ID 13), ST_B is inserted at\nthat particular node. The resulting key tree is shown in\nFig. 4c. In this example, no update message is needed.\nFig. 5 shows another example, where k \u00bc 2, and we\ntherefore need to apply only Steps 2 and 4. We have a\nbalanced subtree (ST_A) with eight members. Assume that\ntwo members wish to join the group. These two members\nform a new subtree (ST_B), as shown in Fig. 5b. For these\nsubtrees, HINSERT \u00bc 2. In Step 2, we perform our marking.\nSince all four key nodes at level 2 \u00f0\u00bc HINSERT \u00de have the\nsame number of leaf nodes at level 3 \u00f0\u00bc HMIN ST A\u00de, we\narbitrarily choose key node 3 and mark it as shown in\nFig. 5a. Finally, in Step 4, we create a new key node K18 and\ninsert the marked key node and the new subtree, consisting\nof the new joining members, as its children, as shown in\nFig. 5c. In this case, the GC needs to inform U1 and U2 that\nnode ID 3 has shifted down one level to accommodate one\nnew node. The update message therefore consists of the old\nnode ID, which is 3, and the new node ID, which is 7.\nThe worst rekeying cost is k\u00f0blogk Nc \u0002 dlogk Je \u00fe 1\u00de \u00fe\nkd\u00f0J \u0002 1\u00de=\u00f0k\u0002 1\u00dee (see Appendix A.1).\nFinally, there is an exception in Merging Algo-\nrithm 1. In cases where Step 4 is used to find\nthe insertion point, HMAX ST A \u0002HMIN ST A \u00bc 1 and\nHMAX ST B \u0002HMAX ST B \u00bc 1 and, when there is at least one\nleaf node at level HMAX ST A in the marked key node, a\nslightly unbalanced key tree will exist if ST_A and ST_B are\ncombined using the steps above. One way to alleviate this\nissue is to delete the root in ST_B and split it into at most\nk subtrees. Order these new subtrees in increasing order of\nHMIN . Starting from the subtree with the minimum height,\ninsert it into ST_A by using Merging Algorithm 1 and\nrepeat until all new subtrees have been inserted into ST_A.\nFig. 6 shows an example. In this example, we delete the\nroot in ST_B (K9) and use Step 4 twice to insert the two new\nsubtrees. Member U8 is inserted as the sibling of member\nU3 (seeMARK1) and both members U6 and U7 are inserted\nas the siblings of members U4 and U5 (see MARK2). In this\ncase, the rekeying cost is slightly higher and two update\nmessages are needed.\n3.2 Merging Algorithm 2\nWe now describe our Merging Algorithm 2 [27]. This\nalgorithm is only used for combining subtrees whose height\ndifference is 0 or equal to 1.\nThe criteria for using Merging Algorithm 2 are when the\ndifference between HMAX ST A and both HMIN ST B and\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 593\nFig. 3. ST_A (five members) and ST_B (two members).\nFig. 4. (a) Part of the subtree in ST_A. (b) ST_B subtree (three members). (c) Resulting key tree.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nHMAX ST B is 0 or equal to 1. The algorithm performs the\nfollowing steps:\nStep 1. For k > 2, the algorithm searches the root of ST_A\nfor an empty child key node. If it exists, then the\nalgorithm inserts ST_B at the empty child key node.\nStep 2. For k \u00bc 2 or when Step 1 is not valid for k > 2, the\nalgorithm creates a new key node at the root and inserts\nST_A and ST_B as its children.\nThe GC needs to multicast at most one update message\nto all existing members. After updating the affected node\nIDs, the members can identify the set of keys that they need\nin the rekey messages.\nFig. 7 shows an example of how Merging Algorithm 2 is\nused to combine two subtrees together by using Step 2.\nSince Merging Algorithm 2 creates a new node at the root,\nthe GC needs to inform U1 to U8 that the ID of the old root\nhas changed from 0 to 1 by using the update message.\nAs shown in Appendix A.1, the rekeying cost is k\u00fe\nkd\u00f0J \u0002 1\u00de=\u00f0k\u0002 1\u00dee messages.\n3.3 Batch Balanced Algorithm\nWe now show how our two Merging Algorithms can be\nextended to produce an algorithm that we call Batch\nBalanced Algorithm that encompasses both joining and\ndeparting members.\nThere are six steps in our Batch Balanced Algorithm.\n1. Identify and mark all key nodes that need to be\nupdated. These key nodes are on the ancestor paths\nfrom each departing member to the root.\n594 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\nFig. 6. (a) ST_A subtree (five members). (b) ST_B subtree (three members). (c) Resulting key tree.\nFig. 5. (a) ST_A subtree (eight members). (b) ST_B subtree (two members). (c) Resulting key tree.\nFig. 7. (a) ST_A subtree (eight members). (b) ST_B subtree (four members). (c) Resulting key tree.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \n2. Remove all marked key nodes. After removal, there\nare only two types of element left: the remaining\nsubtrees and the joining members.\n3. Classify all siblings of the departing members as\njoining members since all of the KEKs that they store\ncannot be used.\n4. Group the joining members into one or many\nsubtrees, each with k members. If there are remain-\ning members left, then they are grouped into another\nsubtree of between 2 and k\u0002 1members unless there\nis only one member left. If there is only one member\nleft, then treat it as a single-node subtree.\n5. Starting from the subtree with the minimum height,\ncompare it with another subtree with the next\nminimum height and if the Merging Algorithm 1\ncriteria are met, combine them using Merging\nAlgorithm 1, else combine them using Merging\nAlgorithm 2. Repeat this process until there is only\none key tree.\n6. Construct the update and rekey messages and\nmulticast them to the members.\nFor clarity, we illustrate it with an example. Assume that\nwe have a key tree with 16 members. Suppose members\nU11 and U15 are departing from the group and six new\nmembers, U17 to U22, are joining the group. All of the key\nnodes in the path from the departing members to the root\nare marked and removed (Steps 1 and 2). The siblings of\ndeparting members U12 and U16 form a new subtree, ST7,\nsince the KEKs that they store are unusable (Step 3). The\njoining members form one or more subtrees of k members\n(Step 4). These usable subtrees ST1 to ST7 are identified as\nshown in Fig. 8.\nIn Step 5, we start with the minimum-height subtrees\nand merge them. Thus, ST2 forms a subtree with ST3, ST4\nforms a subtree with ST5, and ST6 forms a subtree with ST7.\nThen, the resulting subtree of ST2 and ST3 is combined with\nthe resulting subtree of ST4 and ST5. This resulting subtree,\nin turn, forms another subtree with the resulting subtree of\nST6 and ST7. Finally, the last two subtrees form a single key\ntree, as shown in Fig. 9. The GC sends out the update\nmessages to inform the members of their new location.\nThose members that need to receive the update messages\nare U12 and the members in ST2 and ST3, which means that\na total of three update messages is needed. In this example,\nwe assume that member U16 and subtree ST1 are left intact\nat their old location. If their locations are changed, then two\nextra update messages are needed. For ST4, ST5, and ST6,\nno update message is needed since the members in the\nsubtrees are newly joining members. At the same time, the\nGC can multicast the rekey messages to the members. The\ntotal rekeying cost is 20 messages.\nIf we use Marking Algorithm 1 [18] or Marking\nAlgorithm 2 [20] in a similar situation, then Marking\nAlgorithm 1 has the same rekeying cost, but it ends up\nwith an unbalanced key tree. Although Marking Algo-\nrithm 2 can maintain a balanced key tree, it needs 28 rekey\nmessages. From this, we can see that reorganizing the group\nmembers leads to saving on rekeying costs.\n3.4 Update Messages\nIn order for the members to identify the keys that they need\nafter the key tree has been reorganized, the GC needs to\ninform the members of their new location. An update\nmessage consists of the smallest node ID of the usable key\ntree m and the new node ID m0. With the new node ID m0,\nthe members can update the remaining keys m0 by using\nthe following function:\nf\u00f0m0\u00de \u00bc kx\u00f0m0 \u0002m\u00de \u00fem0; \u00f01\u00de\nwhere x denotes the level of the usable key tree.\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 595\nFig. 8. Steps 1 to 4 of the Batch Balanced Algorithm.\nFig. 9. Resulting key tree.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nFor example, in Fig. 10, the smallest node ID in the\nusable key tree m is 2 and the smallest new node ID m0 is 8.\nEach member just needs to insert the remaining node ID m0\nthat they store into the function above to obtain the new\nnode ID.\n4 PERFORMANCE EVALUATION\nIn this section, we study the performance of our proposed\nalgorithms and compare them with the Marking Algo-\nrithms described in [18] and [20], which we have already\nlabeled as Marking Algorithm 1 and Marking Algorithm 2,\nrespectively. We consider four performance metrics:\n. rekeying cost,\n. update cost,\n. minimum and maximum height in the key tree, and\n. key storage.\nThe rekeying cost denotes the total number of rekey\nmessages that need to be sent to all authorized group\nmembers in order for them to learn the new group key. A\nhigher rekeying cost means that more bandwidth is needed\nfor the transmission. Although Marking Algorithm 2 adopts\nthe User-Oriented Key Assignment Algorithm (UKA) [20],\nwhere all of the encryptions for a member are assigned in a\nsingle packet, we ignore the UKA when we calculate the\nrekeying costs since it leads to a significant number of\nduplications in rekey messages. Instead, we just calculate\nthe total number of rekey messages that are needed without\nany duplication. The update cost denotes the total number\nof update messages that need to be sent to all affected\nmembers after the key tree has been reorganized in order\nfor them to identify the keys that they need. As for the\nminimum and maximum height, they affect the members\u2019\nkey storage and, thus, the number of decryptions needed by\neach member and may even increase the rekeying costs, too,\nas explained in Section 2. Last, the key storage denotes the\nnumber of keys each member need to store.\nWe ran our algorithms on a Linux terminal with a\n512 Mbyte RAM on a 2 GHz processor. To give an\nindication of runtime, for a tree size of 4,096 members,\nruntimes are typically in the range of 1 to 5 sec and, for a\ntree size of 65,536 members, runtimes are typically in the\nrange of 1 to 40 sec, both results being less than or equal to\napproximately 2,000 departing and joining members.\n4.1 Merging Algorithm Performance Evaluation\nWe have performed some simulations to compare the\nperformance of bothof ourMergingAlgorithmswith existing\nwork for batch join requests. For our simulations, we used a\nbalanced binary key tree of 256 members with a height of 8.\nThe number of joining members varies from 1 to 250.\n4.1.1 Rekeying Cost\nIn Fig. 11, we can see that Marking Algorithm 2 has the\nhighest rekeying cost. This is because the joining members\nare inserted one by one at each leaf node, which affects the\npaths from the affected leaf nodes to the root. As the\nnumber of joining members increases, the number of\naffected nodes increases significantly. On the other hand,\nthe other three algorithms have similar rekeying costs since\nthey try to minimize the number of affected nodes. Marking\nAlgorithm 1 minimizes the rekeying costs by placing the\nnew subtree, which consists of joining members and one\nremoved member on the shallowest height, at the old\nlocation of the removed member. Hence, only the path from\nthat leaf node to the root is affected, regardless of the\nnumber of joining members. In other words, the rekeying\ncost consists of the rekey messages that need to be multicast\nto the joining members and 2 logk N messages to update the\nkeys from that affected leaf node to the root. Merging\nAlgorithm 1 inserts the new subtree consisting of the joining\nmembers into one of the key nodes in the key tree at a\nlocation that depends on the number of the joining\nmembers; thus, as the number of joining members\nincreases, the number of affected nodes is reduced since\nthe key node selected for insertion gets closer to the root.\nFor Merging Algorithm 2, a new root is created with the\nexisting subtree and the new subtree consisting of the\njoining members, which are inserted as its children.\n4.1.2 Update Cost\nOf the four algorithms, only Marking Algorithm 2 does not\nneed to distribute update messages to the members.\nMarking Algorithm 1 needs to send one update message\nto inform the removed leaf node of its new location.\nSimilarly, both Merging Algorithms need to send out one\nupdate message to inform the affected members of the\nnewly created node.\n4.1.3 Minimum and Maximum Height\nFig. 12 shows the maximum height of the key tree after the\njoining members have been inserted into the key tree for all\nalgorithms. Only Marking Algorithm 2 and Merging\nAlgorithm 2 maintain at a fixed height, regardless of the\nnumber of joining members. Marking Algorithm 2 alle-\nviates the inefficiency of Marking Algorithm 1 by inserting\nthe joining members one by one at each leaf node, whereas\n596 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\nFig. 10. (a) Usable and (b) new updated key trees.\nFig. 11. Batch join rekeying costs.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nMerging Algorithm 2 creates a new root and inserts the\nexisting key tree and the joining member key tree as its\nchildren. Merging Algorithm 1 has the same performance as\nMarking Algorithm 2 and Merging Algorithm 2 when the\nnumber of joining members is less than or equal to half the\ngroup size. However, once the number of joining members\nexceeds half the group size, the maximum height increases\nby 1. This is why we set the criteria in Section 3.1, because\nthe selection of the suitable key node is always at the child\nof the root once the joining members are greater than half\nthe group size. In the case of Marking Algorithm 1, the\nmaximum height increases significantly as the number of\njoining members increases because all of the joining\nmembers form a new subtree with one member at the\nminimum height. This new tree is inserted at the old\nlocation of the removed member, causing the maximum\nheight to increase considerably.\nFig. 13 shows the maximum difference in height of the\nkey tree, which indicates whether the key tree is balanced.\nThe maximum difference in height for Marking Algorithm 1\nincreases considerably as the number of joining members\nincreases. Similarly, our Merging Algorithm 2 is not a\nbalanced key tree when the number of joining members is\nless than half the group size and it only maintains a\nbalanced key tree when the number of joining members is\ngreater than or equal to half the group size. This is why we\nset the criteria for Merging Algorithm 2 in Section 3.2. As\nfor our Merging Algorithm 1, it maintains a balanced key\ntree when the number of joining members is less than or\nequal to half the group size. The difference in height in\nMerging Algorithm 1 increases by 1 once the number of\njoining members exceeds half the group size since the child\nof the root is selected for the insertion. Marking Algorithm 2\nis the only algorithm that creates a balanced key tree,\nregardless of the number of joining members. However, this\ncomes with the drawback of the high rekeying costs, as\nshown in Fig. 11. On the other hand, if we can choose\nappropriately between both of our Merging Algorithms\ndepending on the number of joining members, we can\ncreate a balanced key tree without extra costs.\n4.1.4 Key Storage\nTable 1 shows the minimum and maximum number of keys\nthat a member needs to store for the four algorithms for\nbatch join events. We can see that the maximum number of\nkeys that a joining member needs to store in Marking\nAlgorithm 1 is dependent on the number of joining\nmembers at that particular interval. A large number of\njoining members results in a great difference in key storage\namong members. Marking Algorithm 2 does not suffer from\nthe storage inefficiency as in Marking Algorithm 1, but it\ncomes at the expense of the large rekeying costs, as shown\nin Fig. 11. Our Merging Algorithms can achieve the same\nefficiency of Marking Algorithm 2 if the Merging Algorithm\nis chosen appropriately, depending on the number of\njoining members.\n4.2 Batch Balanced Algorithm\n4.2.1 Rekeying Cost\nWe have performed a theoretical analysis for the rekeying\ncost of our Batch Balanced Algorithm, the details of which\nare discussed in Appendix A. To verify our analysis, we\nhave also built a simulator for the algorithm. The simulator\nfirst constructs a balanced key tree with 1,024 members for\nk \u00bc 2. Departing members are either randomly selected or\nselected so as to give either the best or worst rekeying costs.\nJoining members are then inserted into the key tree and the\nrekeying costs are calculated.\nFigs. 14a and 14b show the computed and simulated best\nand worst rekeying costs for a binary key tree. Our analysis\nand simulated results match so well that we could not\ndistinguish between the two. For the best case, the rekeying\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 597\nFig. 12. Maximum height of the key tree. Fig. 13. Maximum difference in height.\nTABLE 1\nMinimum and Maximum Key Storage for Batch Join Events\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \ncosts are not affected by the number of departing members;\nrather, they are based purely on the number of joining\nmembers. This is because the number of affected nodes is\nminimized as the departing members are concentrated on\none area of the key tree. On the other hand, if the departing\nmembers are spread fairly on the key tree, as in the worst\ncase, then it maximizes the number of affected nodes in the\nkey tree. The highest rekeying cost occurs when the number\nof departing members approaches half the group size,\nwhich means that most or all the key nodes in the key tree\ncannot be used.\nIf the departing members are randomly selected, then we\nobtain the mean rekeying costs that lie between the\ntheoretical best and worst cases. Fig. 14c shows the\ncalculated best and worst and also the simulated average\nrekeying cost calculated as an average of 100 simulation\nruns. We can see that the average rekeying cost is closer to\nthe worst rekeying cost than to the best rekeying cost.\nGenerally, we can predict the rekeying costs for a key tree of\nany outdegree k if we are able to group the members\naccording to their departing probability since it is based\npurely on the number of joining members rather than the\nnumber of departing members. However, if the departing\nmembers are spread around as in the worst case, the highest\nrekeying cost happens when the number of departing\nmembers is around N=k since most or all of the KEKs that\nthe members store cannot be used.\nWe also built simulators for the Marking Algorithms\n[18], [20] to compare their performance with that of our\nBatch Balanced Algorithm. All simulators first construct a\nbalanced key tree and then randomly pick departing\nmembers, with all members having an equal probability\nof departing. The joining members are inserted into the key\ntree and, finally, the rekeying costs are calculated. The\nrekeying costs are again based on the average of 100 runs.\nWe use a tree of 1,024 members with a height of 10 for a\nbalanced binary key tree and a tree of 4,096 members with a\nheight of 6 for a balanced key tree of k \u00bc 4.\nFig. 15 shows the rekeying costs for the three algorithms\nfor k \u00bc 2. Marking Algorithm 1 and the Batch Balanced\nAlgorithm have similar rekeying costs. Marking Algorithm 2\nhas twice the rekeying costs compared to both Marking\nAlgorithm 1 and the Batch Balanced Algorithm when the\nnumber of joining members approaches the group size and\nthere are no departing members. Generally, Marking\nAlgorithm 2 has the highest rekeying costs when the\nnumber of joining members is greater than the number of\ndeparting members.\nTo investigate the rekeying costs in detail, we calculate\nthe difference in the rekeying costs for the three algorithms,\nas shown in Fig. 16. For clarity, the y-axis of Fig. 16b is\nreversed. All three algorithms have similar rekeying costs\nwhen the number of joining members and the number of\ndeparting members are comparable. Marking Algorithm 1\nhas the highest rekeying costs compared to the Batch\nBalanced Algorithm when the number of departing\nmembers approaches half the group size, especially when\nthere are no joining members. This is because most of the\nkey nodes in the key tree are affected by the departing\nmembers. By reorganizing the remaining members in the\nkey tree, we can reduce the rekeying costs. Replacing some\nof the departing members with the joining members can\nhelp to diminish this effect for both Marking Algorithm 1\nand Marking Algorithm 2. We can see that Marking\nAlgorithm 2 has the highest rekeying costs compared to\nMarking Algorithm 1 and the Batch Balanced Algorithm\nwhen the number of joining members is greater than the\nnumber of departing members. Another high cost in\n598 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\nFig. 14. (a) Best case. (b) Worst case. (c) Best, average, and worst rekeying costs for k \u00bc 2.\nFig. 15. Rekeying costs for (a) Marking Algorithm 1, (b) Marking Algorithm 2, and (c) Batch Balanced Algorithm.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nMarking Algorithm 2 is when the number of departing\nmembers approaches half the group size. All of these extra\nrekeying costs resulted from the use of the null nodes and\nthe way Marking Algorithm 2 inserts the joining members.\nFig. 17 shows the difference in the rekeying costs for\nk \u00bc 4. As before, the y-axis for the difference in rekeying\nbetween Marking Algorithm 1 and the Batch Balanced\nAlgorithm is reversed for a clearer view. When the number\nof joining members and the number of departing members\nare comparable, all three algorithms have similar rekeying\ncosts. As before, Marking Algorithm 2 has two regions of\nhigh rekeying costs compared to Marking Algorithm 1 and\nthe Batch Balanced Algorithm. The first occurs when the\nnumber of joining members approaches the group size with\nno departing members. The other occurs when the number\nof departing members is around N=k with no joining\nmembers. Marking Algorithm 1 has the highest rekeying\ncosts compared to the Batch Balanced Algorithm when the\nnumber of departing members is in the region of N=k with\nno joining members. Replacing the departing members with\nthe joining members helps to lower the rekeying costs for\nboth Marking Algorithm 1 and Marking Algorithm 2.\n4.2.2 Update Cost\nFor the Batch Balanced Algorithm, there are some over-\nheads incurred since we reorganize the group members in\nthe key tree. This requires the GC to send update messages\nto inform the members of their new location. It is important\nto note that the GC in Marking Algorithm 1 needs to\nmulticast update messages to the members as well.\nFig. 18 shows the total update messages that need to be\nsent to the remaining group members, including the\nsiblings of the departing members, in order for them to\nupdate their new key node IDs. As expected, the update\nmessages are purely dependent on the number of departing\nmembers. The number of update messages increases as the\nnumber of departing members increases to around half the\ngroup size. This is because more key nodes in the key tree\nare affected by the departing members. However, once the\nnumber of departing members exceeds half the group size,\nthe number of update messages decreases since there are\nfewer members left in the group.\nIf we assume that a key is 128 bits long and the node ID\nis 20 bits (that is, up to 220 members), then a rekey message\nis at least 148 bits, excluding other overheads. An update\nmessage consists of the old node ID and the new node ID\nand, ignoring overheads, is therefore 40 bits long. In other\nwords, a rekey message is 3.7 times the length of an update\nmessage; thus, the maximum update cost is equivalent to\n109 rekey messages. In Section 5, we show how we can\nreduce the number of update messages needed by the\ngroup members for some rekey events.\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 599\nFig. 16. Difference in rekeying costs for k \u00bc 2.\nFig. 17. Difference in the rekeying costs for k \u00bc 4.\nFig. 18. Update messages for the Batch Balanced Algorithm \u00f0k \u00bc 2\u00de.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nFig. 19 shows the total number of update messages that\nneed to be multicast to the members for k \u00bc 4. We can see\nthat there is a sharp increase in update messages compared\nwith a binary key tree. This is because, for every departing\nmember, the GC needs to send three update messages to its\nsiblings so that they can update the new location. The\nhighest number of update messages occurs when the\nnumber of departing members is in the region of N=k.\n4.2.3 Minimum and Maximum Height\nFig. 20 shows the minimum and maximum height for\nMarking Algorithm 1, showing that a small percentage of\njoining or departing members can increase the difference in\nheight significantly. In the case where the number of joining\nmembers is greater than the number of departing members,\nonly the maximum height is affected, whereas the mini-\nmum height is left unchanged and vice versa when the\nnumber of departing members is greater than the number of\njoining members. Marking Algorithm 1 can only maintain a\nbalanced key tree when the number of joining members is\nequal to the number of departing members.\nFig. 21 shows the minimum and maximum height for\nMarking Algorithm 2. It can be seen that the rapid increase\nin height as in Marking Algorithm 1 is not visible in this\ncase since the joining members are inserted one by one at\neach leaf node. As for the minimum height, Marking\nAlgorithm 2 alleviates the inefficiency in Marking Algo-\nrithm 1 with the use of the null node. However, one\nproblem with Marking Algorithm 2 is that the key tree has\nnow become a static key tree that can increase its minimum\nheight to accommodate more joining members into the\ngroup but cannot decrease its minimum height with the\ndeparture of the members since nodes that are not occupied\nare marked as null nodes. This causes unnecessary key\nstorage and encryptions or decryptions for both the GC and\ngroup members. There is no way to overcome this issue\nunless the whole key tree is rekeyed, which adds extra\nnetwork costs.\nFig. 22 shows theminimum andmaximum heights for the\nBatch Balanced Algorithm. Regardless of the number of\njoining or departing numbers, bothminimumandmaximum\nheight adapt to the changes in the group membership.\nWe omit the minimum and maximum heights perfor-\nmance for Marking Algorithm 1 and Marking Algorithm 2\nfor k \u00bc 4 since the analysis described above is applicable.\nFig. 23 shows the minimum and maximum heights for\nthe Batch Balanced Algorithm for k \u00bc 4. Both the minimum\nand maximum height have similar output. Since the single\nkey tree is formed using a bottom-up method, some of the\nroot\u2019s child key nodes might be less than k in some case,\nwhich results in one extra level in the minimum and\nmaximum height.\n4.2.4 Key Storage\nTable 2 shows the minimum and maximum key storage for\nthe three algorithms. Since a full calculation for key storage\n600 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\nFig. 19. Update messages for the Batch Balanced Algorithm \u00f0k \u00bc 4\u00de.\nFig. 20. (a) Minimum and (b) maximum height for Marking Algorithm 1.\nFig. 21. (a) Minimum and (b) maximum height for Marking Algorithm 2.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nof Marking Algorithm 1 is complex, we have assumed a\nbalanced key tree when we calculate its maximum and\nminimum storage. The maximum key storage for a joining\nmember in Marking Algorithm 1 then depends on the\nnumber of joining and departing members at that particular\ninterval. For Marking Algorithm 2, the member needs\nadditional key storage since the minimum and maximum\nkey storage values are dependent on the maximum group\nsize ever reached, NMAX, regardless of the current group\nsize. The Batch Balanced Algorithm has a lower maximum\nkey storage than either Marking Algorithm 1 or Marking\nAlgorithm 2.\n5 DISCUSSION\n5.1 Optimization\nFrom the above simulations, we observe that the Batch\nBalanced Algorithm has identical rekeying costs compared\nto existing algorithms when the number of joining members\nand the number of departing members are comparable.\nTherefore, one optimization that we can apply to our Batch\nBalanced Algorithm is not to reorganize the members in the\nkey tree for the following condition:\nD \u0003 J \u0003 \u00f0D\u0002Dmin\u00de \u00fe kDmin; \u00f02\u00de\nwhere Dmin is the number of departing members at the\nminimum height.\nFor the case where J is equal to D, we replace all\nD departs by J joins. If J is greater than D and provided\nthat J is smaller or equal to \u00bd\u00f0D\u0002Dmin\u00de \u00fe kDmin\u0004, then we\nreplace all \u00f0D\u0002Dmin\u00de departs at the maximum height with\n\u00f0D\u0002Dmin\u00de joins. The remaining joining members are split\nacross the Dmin nodes. We illustrate it with an example.\nSuppose, in Fig. 24a, U3, U6, and U7 depart and U8 to U12\njoin. Then, J must lie between 3 and 5 in order to fulfill the\nabove condition. The resultant key tree is shown in Fig. 24b.\nFig. 25 shows the update messages for our optimized\nBatch Balanced Algorithm for k \u00bc 2. We can see that there\nare some cases where no update message is needed since\nthere is no reorganization in the group. The rekeying costs\nstill remain the same as shown in Fig. 15. There is no way to\nmaintain a balanced key tree without reorganizing the key\ntree when the number of departing members is greater than\nthe number of joining members.\n5.2 Application Scenarios\nBased on our simulation results, we now make some\nrecommendations on the various applications where our\nBatch Balanced Algorithm can outperform existing work.\nOur recommendations are based on application requirement,\noperation environments, and expected group membership\nbehavior.\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 601\nFig. 22. (a) Minimum and (b) maximum height for the Batch Balanced Algorithm \u00f0k \u00bc 2\u00de.\nFig. 23. (a) Minimum and (b) maximum height in the Batch Balanced Algorithm \u00f0k \u00bc 4\u00de.\nTABLE 2\nMinimum and Maximum Key Storage for\nBatch Join and\/or Depart Events\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \n. Satellite pay-per-view TV distribution. For this type of\nscenario, generally, the number of joining members\nis greater than the number of departing members at\nthe beginning of the session. During the session, the\nnumber of joining members and departing members\nmight be comparable. Finally, at the end of the\nsession, the number of departing members is greater\nthan the number of joining members. In this case,\nour Batch Balanced Algorithm can overcome the\ninefficiency in Marking Algorithm 1 and Marking\nAlgorithm 2 at the beginning and end of the session.\nIn the middle of the session, the rekeying costs for\nthe three algorithms are expected to be similar.\n. Group-oriented mobile commerce [4], [5]. Generally,\nmobile devices have limited storage and computa-\ntion [4], [27]. In this case, it might be better to\nminimize the number of keys that they need to store\nand the number of decryptions during each batch.\nBy reducing the number of decryptions needed, we\ncan help to conserve the battery power too.\nFurthermore, the energy consumption of decryption\nis 30 percent more than encryption [28]. In this type\nof scenario, the Batch Balanced Algorithm has better\nperformance compared to both Marking Algorithms\nsince its minimum and maximum height adapt to\nthe changes in the group membership. In addition,\nits rekeying cost is lower than or similar to those of\nthe existing algorithms. This is crucial, especially in\nwireless multicast scenario, since the bandwidth is\nlimited and data typically experience a higher\ntransmission error rate than in conventional envir-\nonments [29].\n. Multicast session with long duration. There is usually\nat least one peak period and one nonpeak period for\nthis type of scenario. If Marking Algorithm 2 is used\nfor this type of scenario, then additional rekeying\ncosts are needed during the off-peak period since the\nminimum and maximum height of the key tree stay\nat the same level as in the peak period. Furthermore,\nthere are additional key storage and encryption\/\ndecryption requirements for both the GC and group\nmembers. As for Marking Algorithm 1, the prob-\nability of the key tree becoming unbalanced is very\nhigh [21], which can result in a higher decryption for\nsome of the members.\n6 CONCLUSION\nIn this paper, we have presented two Merging Algorithms\nthat are suitable for batch join events. To additionally\nhandle batch depart requests, we have extended these two\nMerging Algorithms into a Batch Balanced Algorithm. All\nthree algorithms try to minimize the difference in height in\nthe key tree without adding extra network costs. However,\nall of the algorithms require the GC to update the affected\nmembers on their node position by using update messages.\nBy minimizing the differences in height, we minimize the\nnumber of key storage and decryptions needed by each\nmember. This is critical for terminals with limited computa-\ntion and storage. Furthermore, reducing the number of\ndecryptions can help to reduce the energy consumption,\nwhich, in turn, leads to battery saving.\nFor batch join events, the way the joining members are\ninserted has a significant effect on the key tree, especially\nwhen there are a large number of join requests in a batch. The\nkey tree can become unbalanced even if the insertion is at the\nminimum height. Existing algorithms do not simultaneously\nconsiderboth thebalancingofkey tree and rekeying costs and\ntherefore lead to either an unbalanced key tree or high\nrekeying costs. Our proposedMerging Algorithms provide a\ngood compromise compared to existing algorithms, produ-\ncing a balanced key tree with low rekeying costs. Merging\nAlgorithm 1 requires the GC to multicast at most two update\nmessages to inform the affected members, whereas Merging\nAlgorithm 2 needs at most one update message. Compared\nwith that of a rekeymessage, the size of an updatemessage is\nseveral times smaller since it consists of only the old node ID\nand the new node ID.\nAs for other events, our Batch Balanced Algorithm\noutperforms existing algorithms when the number of\njoining members is greater than the number of departing\nmembers and when the number of departing members is\naround N=k with no joining member. However, our\nalgorithm requires the GC to multicast update messages\nto the members. For cases where the number of joining\nmembers and the number of departing members are\ncomparable, our Batch Balanced Algorithm has a similar\nperformance compared to existing work. We further\nobserve that, if we are able to group the members according\n602 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\nFig. 24. (a) Key tree with join and depart requests. (b) Resulting key tree.\nFig. 25. Update message for the optimized Batch Balanced Algorithm\n\u00f0k \u00bc 2\u00de.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \nto their departing probability, then we are able to predict\nthe rekeying costs based on the number of joining members.\nHowever, if the departing members are spread evenly\nacross the key tree, then the highest rekeying cost happens\nat around N=k since most or all of the KEKs that the\nmembers store cannot be used.\nAPPENDIX A\nANALYSIS\nThe performance of the key tree approach depends on\nstorage, computation, and communication overhead. Fol-\nlowing [10], [11], [12], [13], [14], we assume that the key tree\ninvestigated in this work is fully loaded and balanced, with\nheight h. All members have equal probability of departing.\nFor ease of analysis, we assume that all of the subtrees are\ncombined using Merging Algorithm 2 when the number of\ndeparting members is greater than zero.\nIn order for the GC to perform the rekeying, it needs to\nstore all of the keys in the key tree; therefore, its storage is\nd\u00f0kN \u0002 1\u00de=\u00f0k\u0002 1\u00dee keys. The members, on the other hand,\nonly need to store the keys on the ancestral path from their\nlocation in the key tree to the root, which means that each\nmember needs to store logk\u00f0N\u00de \u00fe 1 keys.\nA.1 Merging Algorithm Analysis\nWhen there is no departing member, we can immediately\napply Merging Algorithm 1 or Merging Algorithm 2,\ndepending on the number of joining members. The worst\nrekeying cost for Merging Algorithm 1 occurs when the two\nsubtrees are combined using Step 4 since a new key node is\ncreated for insertion. All of the KEKs from the root to level\nHINSERT are affected by the insertion; in other words, the\nnumber of affected key nodes, including the newly created\nkey node, is blogk Nc \u0002 dlogk Je \u00fe 1. In addition, we include\nthe cost for constructing a subtree for the joining members\nkd\u00f0J \u0002 1\u00de=\u00f0k\u0002 1\u00dee. Similarly, the worst rekeying cost for\nMerging Algorithm 2 occurs when the two subtrees are\ncombined using Step 2 since a new root is created for\ninsertion. The rekeying cost is simply the outdegree k for\ncreating a new root plus the cost for constructing a new key\ntree for the joining member. Thus, the worst rekeying cost\nRC for a batch join event is given by\nWorst RC\u00f0J>0;D\u00bc0\u00de \u00bc\nk\u00f0blogk Nc \u0002 dlogk Je \u00fe 1\u00de\n\u00fek \u00f0J\u00021\u00de\u00f0k\u00021\u00de\nl m Merging Algorithm 1\nk\u00fe k \u00f0J\u00021\u00de\u00f0k\u00021\u00de\nl m\nMerging Algorithm 2:\n8>><\n>>:\n\u00f03\u00de\nIn the best case for the two Merging Algorithms, a new\nnode is not required and, therefore, the best rekeying cost is\ngiven by Best RC \u00bc Worst RC\u0002 k.\nA.2 Batch Balanced Algorithm Worst Case Analysis\nFor simplicity, we first assume that the number of departing\nmembers is some value D \u00bc k0 for some integer l.\nIn the worst case, the departing members are spread\nevenly at the leaf nodes, as shown in Fig. 26a. This means\nthat \u00f0kl\u00fe1 \u0002 1\u00de=\u00f0k\u0002 1\u00de key nodes from level 0 to level l\ncannot be used. From level l\u00fe 1 to h\u0002 2, there are D\u00f0k\u0002 1\u00de\nusable subtrees at each level; in other words, the total\nnumber of usable subtrees is D\u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 l\u00de. At level\nh\u0002 1, there are \u00f0k\u0002 1\u00de siblings for each departing member,\nwhich means a total of D\u00f0k\u0002 1\u00de siblings. The worst update\ncost is D\u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 l\u00de \u00feD\u00f0k\u0002 1\u00de. Using our Batch\nBalanced Algorithm, all J joining members and D\u00f0k\u0002 1\u00de\nsiblings of the departing members form one or more\nsubtrees with k members. Finally, all subtrees form a single\nkey tree. The rekeying cost is therefore given by\nWorst RC\u00f0J\u00050;D 6\u00bc0\u00de\n\u00bc\nk\u00f0D\u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 l\u00de \u00fe D\u00f0k\u00021\u00de\u00feJk\nl m\n\u0002 1\u00de\nk\u0002 1 \u00feD\u00f0k\u0002 1\u00de \u00fe J\n\u00bc kD\u00f0logk\nN\nD\n\u00de \u0002D\u00fe J \u00fe\nk D\u00f0k\u00021\u00de\u00feJk\nl m\n\u0002 k\nk\u0002 1 :\n\u00f04\u00de\nNow, suppose that we have D \u00bc kl \u00fe r, where r\nlies between 0 and \u00f0k\u0002 1\u00dekl. The analysis is split into\ntwo portions. For the kl portion, the previous analysis\nstill applies. As for r, r\u00bd\u00f0h\u0002 3\u0002 1\u00de\u00f0k\u0002 1\u00de \u0002 1\u0004 usable\nsubtrees are produced. The worst update cost is\nkl\u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 l\u00de \u00fe r\u00f0h\u0002 3\u0002 l\u00de\u00f0k\u0002 1\u00de \u00fe \u00f0kl \u00fe r\u00de\u00f0k\u0002 1\u00de. In\naddition, the r\u00f0k\u0002 1\u00de siblings of the r departing members\nform one or more subtrees with the siblings of the\nkl departing members and joining members. The rekeying\ncost therefore becomes\nWorst RC\u00f0J\u00050;D 6\u00bc0\u00de\u00bc\nk\u00bdkl\u00f0k\u00021\u00de\u00f0h\u00022\u0002l\u00de\u00fe \u00f0k\nl\u00fer\u00de\u00f0k\u00021\u00de\u00feJ\nk\n\u0002 \u0003\n\u00021\u00fer\u00f0h\u00023\u0002l\u00de\u00f0k\u00021\u00de\u0002r\u0004\nk\u00021 \u00fe\u00f0kl\u00fer\u00de\u00f0k\u00021\u00de\u00feJ\n\u00bc\u00f0kl\u00fe1\u00ferk\u00de logkNkl\u00fe\nk\n\u00f0kl\u00fer\u00de\u00f0k\u00021\u00de\u00feJ\nk\n\u0002 \u0003\n\u0002k\u0002rk2\nk\u00021 \u0002kl\u0002r\u00feJ:\n\u00f05\u00de\nA.3 Batch Balanced Algorithm Best Case Analysis\nAgain, we first assume that D \u00bc kl for some integer l.\nIn the best case, the number of key nodes affected by the\ndepartingmembers isminimized,whichmeans that all of the\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 603\nFig. 26. (a) Worst and (b) best case rekeying costs.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \ndeparting members will be concentrating on one area of the\nkey tree, as shown in Fig. 26b. In this case, there are \u00f0k\u0002 1\u00de\nusable subtrees in the affected branch from level logk Do to\nh\u0002 2 and the k\u0002 dkD=Ne children of the root are not affected\nby the departing members, where Do lies between 0 and\nN=k \u00f0D \u00bc CN=k\u00feDo\u00de and C is between 0 and k. The best\nupdate cost is \u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 logk D0\u00de \u00fe k\u0002 dkD=Ne. All\njoining members form one or more subtrees with\nk members.\nBest RC\u00f0J\u00050;D6\u00bc0\u00de \u00bc\nk\u00bd\u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 logk Do\u00de \u00fe dJke \u00fe \u00f0k\u0002 dkDN e\u00de \u0002 1\u0004\nk\u0002 1 \u00fe J:\n\u00f06\u00de\nSuppose we have D \u00bc kl \u00fe r, where r lies between 0 and\n\u00f0k\u0002 1\u00dekl.\nThe same analysis still applies, except that r\nproduces another Y subtrees, where Y is the sum\nof the digit of kdlogk Doe \u0002Do when written in radix k.\nIn other words, the total number of usable subtrees is\n\u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 dlogk D0e\u00de \u00fe k\u0002 dkD=Ne \u00fe Y . There are\nDmodk siblings of the departing members. Therefore, the\nbest update cost is\n\u00f0k\u0002 1\u00de\u00f0h\u0002 2\u0002 dlogk D0e\u00de \u00fe k\u0002 dkD=Ne \u00feDmod k:\nThe Dmod k sibling of the departing members and the\njoining members form one or more subtrees with\nk members.\nBest RC\u00f0J\u00050;D6\u00bc0\u00de\u00bc\nk\u00bd\u00f0k\u00021\u00de\u00f0h\u00022\u0002dlogk Doe\u00de\u00fe\nJ\u00feDmodk\u00de\nkd e\u00fe k\u0002 kDNd e\u00f0 \u00de\u00feY\u00021\u0004\nk\u00021 \u00feJ\u00feD mod k: \u00f07\u00de\nAPPENDIX B\nThe operations for both Merging Algorithms and the Batch\nBalanced Algorithm without optimization are shown in\nFigs. 27, 28, and 29, respectively.\nREFERENCES\n[1] S.E. Deering, \u201cHost Extensions for IP Multicasting,\u201d IETF RFC\n1112, Aug. 1989.\n[2] S. Paul, Multicast on the Internet and Its Applications. Kluwer\nAcademic, 1998.\n[3] U. Varshney, \u201cMulticast over Wireless Networks,\u201d Comm. ACM,\nvol. 45, no. 12, pp. 31-37, Dec. 2002.\n[4] U. Varshney, \u201cMulticast Support in Mobile Commerce Applica-\ntion,\u201d Computer, vol. 35, no. 2, pp. 115-117, Feb. 2002.\n[5] N. Shi, Mobile Commerce Applications. Idea Group, 2004.\n[6] R. Canetti, J. Garay, G. Itkis, D. Micciancio, M. Noar, and B.\nPinkas, \u201cMulticast Security: A Taxonomy and Efficient Construc-\ntions,\u201d Proc. IEEE INFOCOM, vol. 2, pp. 708-716, Mar. 1999.\n[7] A. Ballardie, \u201cScalable Multicast Key Distribution,\u201d IETF RFC\n1949, 1996.\n[8] H. Harney and C. Muckerhirn, \u201cGroup Key Management Protocol\n(GKMP) Specification,\u201d IETF RFC 2093, July 1997.\n604 IEEE TRANSACTIONS ON COMPUTERS, VOL. 56, NO. 5, MAY 2007\nFig. 29. Batch Balanced Algorithm without optimization.\nFig. 27. Merging Algorithm 1 and its exception.\nFig. 28. Merging Algorithm 2.\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \n[9] H. Harney and C. Muckenhirn, \u201cGroup Key Management\nProtocol (GKMP) Architecture,\u201d IETF RFC 2094, July 1997.\n[10] D.M. Wallner, E.J. Harder, and R.C. Agee, \u201cKey Management for\nMulticast Issues and Architectures,\u201d IETF RFC 2627, June 1999.\n[11] C. Wong, M. Gouda, and S. Lam, \u201cSecure Group Communication\nUsing Key Graphs,\u201d IEEE\/ACM Trans. Networking, vol. 8, pp. 12-\n23, Feb. 2000.\n[12] D. Balenson, D. McGrew, and A. Sherman, \u201cKey Management for\nLarge Dynamic Groups: One-Way Function Trees and Amortized\nInitialization,\u201d Internet Draft, draft-irtf-smug-groupkeymgmt-oft-\n00.txt, Aug. 2000.\n[13] M. Valdvogel, G. Caronni, D. Sun, N. Weiler, and B. Plattner, \u201cThe\nVersakey Frameworks: Versatile Group Key Management,\u201d IEEE\nJ. Selected Areas in Comm. (JSAC), vol. 17, no. 9, pp. 1614-1631, Sept.\n1999.\n[14] M.P. Howarth, S. Iyengar, Z. Sun, and H. Cruickshank, \u201cDy-\nnamics of Key Management in Secure Satellite Multicast,\u201d IEEE J.\nSelected Areas in Comm. (JSAC), Feb. 2004.\n[15] S. Mittra, \u201cIolus: A Framework for Scalable Secure Multicasting,\u201d\nProc. ACM SIGCOMM, vol. 27, pp. 277-288, Sept. 1997.\n[16] B. DeCleene et al., \u201cSecure Group Communication for Wireless\nNetworks,\u201d Proc. Military Comm. Conf. (MILCOM), Oct. 2001.\n[17] A. Perrig, \u201cEfficient Collaborative Key Management Protocol for\nSecure Autonomous Group Communication,\u201d Proc. Int\u2019l Workshop\nCrypTEC, 1999.\n[18] X.S. Li, Y.R. Yang, M. Gouda, and S. Lam, \u201cBatch Rekeying for\nSecure Group Communications,\u201d Proc. 10th Int\u2019l WWW Conf.,May\n2001.\n[19] S. Setia, S. Koussih, and S. Jajodia, \u201cKronos: A Scalable Group\nRekeying Approach for Secure Multicast,\u201d Proc. IEEE Symp.\nSecurity and Privacy, 2000.\n[20] X.B. Zhang, S. Lam, D.Y. Lee, and Y.R. Yang, \u201cProtocol Design for\nScalable and Reliable Group Rekeying,\u201d IEEE\/ACM Trans.\nNetworking, vol. 11, pp. 908-922, Dec. 2003.\n[21] J. Pegueroles and F. Rico-Novella, \u201cBalanced Batch LKH: New\nProposal, Implementation and Performance Evalution,\u201d Proc.\nIEEE Symp. Computers and Comm. (ISCC), June 2003.\n[22] J. Pegueroles, J. Hernandez-Serrano, F. Rico-Novella, and M.\nSoriano, \u201cAdapting GDOI for Balanced Batch-LKH,\u201d Internet\ndraft, draft-irtf-gsec-gdoi-batch-lkh-00.txt, June 2003.\n[23] P.P.C. Lee, J.C.S. Lui, and D.K.Y. Yau, \u201cDistributed Collaborative\nKey Agreement Protocols for Dynamic Peer Groups,\u201d Proc. IEEE\nInt\u2019l Conf. Network Protocols (ICNP), Nov. 2002.\n[24] A.M. Eskicioglu, \u201cMultimedia Security in Group Communication:\nRecent Progress in Key Management, Authentication and Water-\nmarking,\u201d ACM Multimedia Systems J., special issues on multi-\nmedia security, pp. 239-248, Sept. 2003.\n[25] W. Ng and Z. Sun, \u201cMulti-Layers LKH,\u201d Proc. IEEE Int\u2019l Conf.\nComm. (ICC), May 2005.\n[26] M.J. Moyer, J.R. Rao, and P. Rohatgi, \u201cMaintaining Balanced Key\nTrees for Secure Multicast,\u201d Internet Research Task Force (IRTF),\nInternet draft, draft-irtf-smug-key-tree-balance-00.txt, June 1999.\n[27] W.H.D Ng, H. Cruickshank, and Z. Sun, \u201cScalable Balanced Batch\nRekeying for Secure Group Communication,\u201d Elsevier Computers\nand Security, vol. 25, pp. 265-273, June 2006.\n[28] A. Hodjat and I. Verbauwhede, \u201cThe Energy Cost of Secrets in\nAd Hoc Networks (Short Paper),\u201d Proc. IEEE Circuits and Systems\nWorkshop (CAS), 2002.\n[29] Y. Sun, W. Trappe, and K.J. Ray, \u201cA Scalable Multicast Key\nManagement Scheme for Heterogeneous Wireless Networks,\u201d\nIEEE\/ACM Trans. Networking, vol. 12, Aug. 2004.\nWee Hock Desmond Ng received the BEng\nand PhD degrees in electronics and electrical\nengineering, both from the University of Surrey,\nUnited Kingdom. He is currently working at\nAT&T Singapore. His research interests include\nnetwork security and next-generation network.\nMichael Howarth received the bachelor\u2019s de-\ngree in engineering science and the DPhil\ndegree in electrical engineering, both from\nOxford University and the MSc degree in\ntelecommunications from the University of Sur-\nrey, United Kingdom. Prior to joining the\nUniversity of Surrey, he worked for several\nnetworking and IT consultancies. He is a lecturer\nin networking at the Centre for Communication\nSystems Research (CCSR), University of Sur-\nrey. His research interests include traffic engineering, quality of service,\nsecurity systems, protocol design, and optimization of satellite commu-\nnications. He is a chartered electrical engineer and a member of the\nUnited Kingdom IET.\nZhili Sun received the BSc degree in mathe-\nmatics from Nanjing University, China, and the\nPhD degree in computing science from Lan-\ncaster University, United Kingdom. He is the\nchair of Communication Networking in the\nCentre for Communication Systems Research\n(CCSR), Department of Electronic Engineering,\nSchool of Electronics and Physical Sciences,\nUniversity of Surrey, United Kingdom. He is a\nlecturer in data and Internet networking, as well\nas satellite communication courses, at the University of Surrey. He also\nteaches MSc, undergraduate, and industrial courses on satellite\nnetworking, computer and data networks, and Internet traffic engineering.\nHe was a postdoctoral researcher from 1989 to 1993 in the Telecommu-\nnications Group, Queen Mary and Westfield College, University of\nLondon, before coming to Surrey. He has been a principal investigator\nand technical coordinator for many European projects, including the\nEuropean Strategic Programme for Research and development in\nInformation Technology on Broadband Integrated Satellite Network\nTraffic Evaluation (Esprit BISANTE) project on evaluation of broadband\ntraffic over satellite using simulation approach, Validation of IP Telephony\nover Euroskyway Network (VIP-TEN) project on quality of service (QoS)\nof IP telephony over satellite, EU Fifth and Sixth Framework Programme\nGEOCAST projects on IP multicast over satellites, ICEBERGS project on\nIP-basedMultimedia Conference over Satellite, SatLife project on IP over\ndigital video broadcasting satellite\/radar cross-section (DVB-S\/RCS),\nsatellite-based communications systems within IPv6 networks (SATSIX)\nproject on IPv6 over satellite, and Euro-NGI project on next-generation\nInternet. He has also been a principal investigator for the UK Engineering\nand Physical Sciences Research Council (EPSRC), European Space\nAgency (ESA), and industrial projects on IP multicast security. He has\nsupervised many PhDs and research fellows. He has also been a\nmember of the technical committees for international conferences and of\nreviewers for EU andUK research proposals. He has acted as an external\nexaminer for PhD viva at many universities in the UK, Europe, Singapore,\nand China. Since January 1996, he has been working on several\nEuropean research projects in the Advanced CompuTational Software\n(ACTS), Esprit, Trans-European Telecommunications Network (TEN-\nTELECOM), and Information Society Technologies (IST) programs. His\nmain research interests include network security, satellite network\narchitectures, Voice over IP (VoIP), and IP conferencing over satellites.\nHe has published a book titledSatellite Networking (Wiley) andmore than\n120 papers in international journals and conferences. He is a member of\nthe Satellite and Space Communications Committee of the IEEE\nComputer Society and a chartered engineer and corporate member of\nthe IET in the United Kingdom.\nHaitham Cruickshank is a lecturer in data and\nInternet networking and satellite communication\ncourses at the University of Surrey, United\nKingdom. Since January 1996, he has been\nworking on several European research projects\nin the Advanced CompuTational Software\n(ACTS), Esprit, Trans-European Telecommuni-\ncations Network (TEN-TELECOM), and Informa-\ntion Society Technologies (IST) programs. His\nmain research interests include network secur-\nity, satellite network architectures, Voice over IP (VoIP), and IP\nconferencing over satellites. He is a member of the Satellite and Space\nCommunications Committee of the IEEE Computer Society and a\nchartered engineer and corporate member of the IET in the United\nKingdom.\nNG ET AL.: DYNAMIC BALANCED KEY TREE MANAGEMENT FOR SECURE MULTICAST COMMUNICATIONS 605\nAuthorized licensed use limited to: University of Surrey. Downloaded on February 18,2010 at 09:42:29 EST from IEEE Xplore.  Restrictions apply. \n"}