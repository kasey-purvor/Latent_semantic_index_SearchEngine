{"doi":"10.1007\/s00165-009-0118-7","coreId":"196871","oai":"oai:lra.le.ac.uk:2381\/9076","identifiers":["oai:lra.le.ac.uk:2381\/9076","10.1007\/s00165-009-0118-7"],"title":"From StPowla processes to SRML models","authors":["Bocchi, Laura","Reiff-Marganiec, Stephan","Gorton, Stephen"],"enrichments":{"references":[{"id":43674315,"title":"A calculus for long running transactions.","authors":[],"date":"2003","doi":"10.1007\/978-3-540-39958-2_9","raw":"Laura Bocchi, Cosimo Laneve, and Gianluigi Zavattaro. A calculus for long running transactions. In FMOODS 2003, Lecture Notes in Computer Science. Springer Verlag, 2003.","cites":null},{"id":43674336,"title":"A calculus for orchestration of web services.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-71316-6_4","raw":"Alessandro Lapadula, Rosario Pugliese, and Francesco Tiezzi. A calculus for orchestration of web services. In European Symposium of Programming, volume 4421 of Lecture Notes in Computer Science, pages 33\u201347. Springer, 2007.","cites":null},{"id":43674354,"title":"A compositional framework for access control policies enforcement.","authors":[],"date":"2003","doi":"10.1145\/1035429.1035433","raw":"F. Siewe, A. Cau, and H. Zedan. A compositional framework for access control policies enforcement. In Proceedings of the 2003 ACM workshop on Formal Methods in Security Engineering, pages 32\u201342, NY, NY, USA, 2003. ACM Press.","cites":null},{"id":43674305,"title":"A coordination model for service-oriented interactions. In","authors":[],"date":"2008","doi":"10.1007\/978-3-540-68265-3_1","raw":"Joa\u02dco Abreu and Jose\u00b4 Luiz Fiadeiro. A coordination model for service-oriented interactions. In In Proceedings of Coordination Languages and Models, volume 5052 of Lecture Notes in Computer Science, pages 1\u201316. Springer Verlag, 2008.","cites":null},{"id":43674322,"title":"A Formal Approach to Service Component Architecture. Web Services and Formal Methods,","authors":[],"date":"2006","doi":"10.1007\/11841197_13","raw":"Jose\u00b4 Luiz Fiadeiro, Anto\u00b4nia Lopes, and Laura Bocchi. A Formal Approach to Service Component Architecture. Web Services and Formal Methods, 4184:193\u2013213, 2006.","cites":null},{"id":43674313,"title":"A formal model of services.","authors":[],"date":"2007","doi":"10.1145\/1189748.1189753","raw":"Manfred Broy, Ingolf H. Kru\u00a8ger, and Michael Meisinger. A formal model of services. ACM Trans. Softw. Eng. Methodol., 16(1):5, 2007.","cites":null},{"id":43674360,"title":"A Logic-based Methodology for Busines Process Analysis and Design: Linking Business Policies to Workflow Models.","authors":[],"date":"2006","doi":null,"raw":"Harry Jiannan Wang. A Logic-based Methodology for Busines Process Analysis and Design: Linking Business Policies to Workflow Models. PhD thesis, University of Arizona, 2006.","cites":null},{"id":43674326,"title":"A model checking verification environment for uml statecharts. In AICA,","authors":[],"date":"2005","doi":null,"raw":"Stefania Gnesi and Franco Mazzanti. A model checking verification environment for uml statecharts. In AICA, Udine 2005, 5-7 October 2005.","cites":null},{"id":43674333,"title":"A petri net-based model for web service composition.","authors":[],"date":"2003","doi":null,"raw":"R. Hamadi and B. Benatallah. A petri net-based model for web service composition. In K.-D. Schewe and X. Zhou, editors, ADC, volume 17 of CRPIT, pages 191\u2013200. Australian Computer Society, 2003.","cites":null},{"id":43674314,"title":"A use-case driven approach to formal service-oriented modelling.","authors":[],"date":"2008","doi":"10.1007\/978-3-540-88479-8_12","raw":"Laura Bocchi, Anto\u00b4nia Lopes, and Jose\u00b4 Luiz Fiadeiro. A use-case driven approach to formal service-oriented modelling. In International Symposium on Leveraging Applications of Formal Methods, Verification and Validation, Lecture Notes in Computer Science. Springer Verlag, 2008. to appear.","cites":null},{"id":43674349,"title":"Adeptflex-supporting dynamic changes of workflows without losing control.","authors":[],"date":"1998","doi":null,"raw":"M. Reichert and Peter Dadam. Adeptflex-supporting dynamic changes of workflows without losing control. J. Intell. Inf. Syst., 10(2):93\u2013129, 1998.","cites":null},{"id":43674337,"title":"Agentwork: a workflow system supporting rule-based workflow adaptation.","authors":[],"date":"2004","doi":"10.1016\/j.datak.2004.03.010","raw":"Robert Mu\u00a8ller, Ulrike Greiner, and Erhard Rahm. Agentwork: a workflow system supporting rule-based workflow adaptation. Data Knowl. Eng., 51(2):223\u2013256, 2004.","cites":null},{"id":43674335,"title":"Algebraic Semantics of Service Component Modules.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-71998-4_3","raw":"Anto\u00b4nia Lopes, Jose\u00b4 Luiz Fiadeiro, and Laura Bocchi. Algebraic Semantics of Service Component Modules. In Algebraic Development Techniques, volume 4409 of Lecture Notes in Computer Science, pages 37\u201355. Springer, 2007.","cites":null},{"id":43674307,"title":"Antonio Ravara, Davide Sangiorgi, Vasco Vasconcelos, and Gianluigi Zavattaro. SCC: a service centered calculus.","authors":[],"date":"2006","doi":"10.1007\/11841197_3","raw":"Michele Boreale, Roberto Bruni, Lu\u0131\u00b4s Caires, Rocco De Nicola, Ivan Lanese, Michele Loreti, Francisco Martins, Ugo Montanari, Antonio Ravara, Davide Sangiorgi, Vasco Vasconcelos, and Gianluigi Zavattaro. SCC: a service centered calculus. In Web Services and Formal Methods, volume 4184 of Lecture Notes in Computer Science, pages 38\u201357. Springer, 2006.","cites":null},{"id":43674352,"title":"APPEL: the ACCENT project policy environment\/language.","authors":[],"date":"2005","doi":null,"raw":"Stephan Reiff-Marganiec, Kenneth J. Turner, and Lynne Blair. APPEL: the ACCENT project policy environment\/language. Technical Report TR-161, University of Stirling, 2005.","cites":null},{"id":43674338,"title":"Building Systems using a Service Oriented Architecture. Whitepaper, SCA Consortium,","authors":[],"date":"2005","doi":null,"raw":"M. Beisiegel, H Blohm, D. Booz, J. Dubray, A. Colyer, M. Edwards, D. Ferguson, B. Flood, M. Greenberg, D. Kearns, J. Marino, J. Mischkinsky, M. Nally, G. Pavlik, M. Rowley, K. Tam, and C. Trieloff. Building Systems using a Service Oriented Architecture. Whitepaper, SCA Consortium, 2005. http:\/\/www.oracle.com\/technology\/tech\/webservices\/ standards\/sca\/pdf\/SCA_White_Paper1_09.pdf.","cites":null},{"id":43674362,"title":"Business process modelling notation.","authors":[],"date":"2004","doi":"10.1016\/b978-0-12-799959-3.00021-5","raw":"Stephen A. White. Business process modelling notation. Object Management Group (OMG) and Business Process Management Initiative, 2004. Available from www.bpmn.org.","cites":null},{"id":43674316,"title":"Cc-pi: A constraint-based language for specifying service level agreements.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-71316-6_3","raw":"M.G. Buscemi and U. Montanari. Cc-pi: A constraint-based language for specifying service level agreements. pages 18\u201332, 2007.","cites":null},{"id":43674310,"title":"Constraint-based policy negotiation and enforcement for telco services.","authors":[],"date":"2007","doi":"10.1109\/tase.2007.18","raw":"M.G. Buscemi, L. Ferrari, C. Moiso, and U. Montanari. Constraint-based policy negotiation and enforcement for telco services. 2007.","cites":null},{"id":43674317,"title":"Design rationale for ruleml: A markup language for semantic web rules.","authors":[],"date":"2001","doi":null,"raw":"H. Boley, S. Tabet, and G. Wagner. Design rationale for ruleml: A markup language for semantic web rules. In I.F. Cruz, S. Decker, J. Euzenat, and D.L. McGuinness, editors, SWWS, pages 381\u2013401, 2001.","cites":null},{"id":43674311,"title":"Engineering Service Oriented Applications: From StPowla Processes to SRML Models.","authors":[],"date":"2008","doi":"10.1007\/978-3-540-78743-3_13","raw":"Laura Bocchi, Stephen Gorton, and Stephan Reiff-Marganiec. Engineering Service Oriented Applications: From StPowla Processes to SRML Models. In Jose\u00b4 Luiz Fiadeiro and Paola Inverardi, editors, Fundamental Approaches to Software Engineering, volume 4961 of Lecture Notes in Computer Science, pages 163\u2013178. Springer Verlag, 2008.","cites":null},{"id":43674339,"title":"extensible access control markup language specification. Available from www.oasis-open.org,","authors":[],"date":"2005","doi":null,"raw":"Tim Moses. extensible access control markup language specification. Available from www.oasis-open.org, 2005.","cites":null},{"id":43674364,"title":"Formal model and policy specification of usage control.","authors":[],"date":"2005","doi":"10.1145\/1108906.1108908","raw":"X. Zhang, F. Parisi-Presicce, R. Sandhu, and J. Park. Formal model and policy specification of usage control. ACM Trans. Inf. Syst. Secur., 8(4):351\u2013387, 2005.","cites":null},{"id":43674319,"title":"Formal verification of e-services and workflows.","authors":[],"date":"2002","doi":"10.1007\/3-540-36189-8_15","raw":"X. Fu, T. Bultan, and J. Su. Formal verification of e-services and workflows. In C. Bussler, R. Hull, S. A. McIlraith, M. E. Orlowska, B. Pernici, and J. Yang, editors, WES, volume 2512 of LNCS, pages 188\u2013202, 2002.","cites":null},{"id":43674308,"title":"From Architectural to Behavioural Specification: An encoding of SRML into cows. Technical report, Dipartimento di Sistemi e Informatica, Universit a` di Firenze,","authors":[],"date":"2008","doi":"10.1016\/j.entcs.2009.09.025","raw":"Laura Bocchi, Jose\u00b4 Luiz Fiadeiro, Alessandro Lapadula, Rosario Pugliese, and Francesco Tiezzi. From Architectural to Behavioural Specification: An encoding of SRML into cows. Technical report, Dipartimento di Sistemi e Informatica, Universit a` di Firenze, 2008. Available at http:\/\/rap.dsi.unifi.it\/cows\/ .","cites":null},{"id":43674312,"title":"From BPEL to SRML: A Formal Transformational Approach.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-79230-7_7","raw":"Laura Bocchi, Yi Hong, Anto\u00b4nia Lopes, and Jose\u00b4 Luiz Fiadeiro. From BPEL to SRML: A Formal Transformational Approach. In M. Dumas and R. Heckel, editors, Web Services and Formal Methods, volume 4937 of Lecture Notes in Computer Science, pages 92\u2013107. Springer Verlag, 2007.","cites":null},{"id":43674341,"title":"Logic-based conflict detection for distributed policies. Fundamentae Informatica,","authors":[],"date":"2008","doi":"10.1007\/978-3-540-75698-9_17","raw":"C. Montangero, S. Reiff-Marganiec, and L. Semini. Logic-based conflict detection for distributed policies. Fundamentae Informatica, 2008, accepted for publication.","cites":null},{"id":43674340,"title":"Logic-based detection of conflicts in APPEL policies.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-75698-9_17","raw":"Carlo Montangero, Stephan Reiff-Marganiec, and Laura Semini. Logic-based detection of conflicts in APPEL policies. In F. Arbab and M. Sirjani, editors, FSEN2007, volume 4676 of Lecture Notes in Computer Science. Springer Verlag, 2007.","cites":null},{"id":43674350,"title":"Modeling- and analysis techniques for web services and business processes.","authors":[],"date":"2005","doi":"10.1007\/11494881_16","raw":"Wolfgang Reisig. Modeling- and analysis techniques for web services and business processes. In Martin Steffen and Gianluigi Zavattaro, editors, Formal Methods for Open Object-Based Distributed Systems, volume 3535 of Lecture Notes in Computer Science, pages 243\u2013258. Springer, 2005. 26 L. Bocchi and S. Gorton and S. Reiff-Marganiec","cites":null},{"id":43674363,"title":"On the suitability of bpmn for business process modelling.","authors":[],"date":null,"doi":"10.1007\/11841760_12","raw":"Petia Wohed, Wil M. P. van der Aalst, Marlon Dumas, Arthur H. M. ter Hofstede, and Nick Russell. On the suitability of bpmn for business process modelling. In Dustdar et al. [DFS06], pages 161\u2013176.","cites":null},{"id":43674351,"title":"Policies: Giving users control over calls.","authors":[],"date":"2003","doi":"10.1007\/978-3-540-25930-5_12","raw":"Stephan Reiff-Marganiec. Policies: Giving users control over calls. In Mark Dermot Ryan, John-Jules Ch. Meyer, and Hans-Dieter Ehrich, editors, Objects, Agents, and Features, volume 2975 of Lecture Notes in Computer Science, pages 189\u2013208. Springer Verlag, 2003.","cites":null},{"id":43674330,"title":"Policy support for business-oriented web service management.","authors":[],"date":"2006","doi":"10.1109\/la-web.2006.26","raw":"S. Gorton and S. Reiff-Marganiec. Policy support for business-oriented web service management. In Proceedings of the Fourth Latin American Web Congress (LA-WEB\u201906), pages 199\u2013202, Washington, DC, USA, 2006. IEEE Computer Society.","cites":null},{"id":43674356,"title":"Semiring-based constraint satisfaction and optimization.","authors":[],"date":"1997","doi":"10.1145\/256303.256306","raw":"Stefano Bistarelli, Ugo Montanari, and Francesca Rossi. Semiring-based constraint satisfaction and optimization. J. ACM, 44(2):201\u2013 236, 1997.","cites":null},{"id":43674361,"title":"SENSORIA: Engineering for Service-Oriented Overlay Computers.","authors":[],"date":"2007","doi":null,"raw":"Martin Wirsing, Laura Bocchi, Allan Clark, Jose\u00b4 Luiz Fiadeiro, Stephen Gilmore, Matthias Ho\u00a8lzl, Nora Koch, and Rosario Pugliese. SENSORIA: Engineering for Service-Oriented Overlay Computers. MIT, June 2007. submitted.","cites":null},{"id":43674309,"title":"Service-Oriented Modelling of Automotive Systems.","authors":[],"date":null,"doi":"10.1109\/compsac.2008.228","raw":"Laura Bocchi, Jose\u00b4 Luiz Fiadeiro, and Anto\u00b4nia Lopes. Service-Oriented Modelling of Automotive Systems. 32nd Annual IEEE International Computer Software and Applications Conference (COMPSAC), 0:1059\u20131064, 2008. From StPowla Processes to SRML Models 25","cites":null},{"id":43674324,"title":"SOCK: A calculus for service oriented computing.","authors":[],"date":"2006","doi":"10.1007\/11948148_27","raw":"Claudio Guidi, Roberto Lucchi, Roberto Gorrieri, Nadia Busi, and Gianluigi Zavattaro. SOCK: A calculus for service oriented computing. In Asit Dan and Winfried Lamersdorf, editors, International Confetence on Service Oriented Computing, volume 4294 of Lecture Notes in Computer Science, pages 327\u2013338. Springer, 2006.","cites":null},{"id":43674355,"title":"Software engineering for service-oriented overlay computers (SENSORIA).","authors":[],"date":null,"doi":"10.1007\/978-3-642-20401-2_1","raw":"Software engineering for service-oriented overlay computers (SENSORIA). Web site: http:\/\/sensoria.fast.de\/.","cites":null},{"id":43674304,"title":"Specifying and composing interaction protocols for serviceoriented system modelling.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-73196-2_23","raw":"Joa\u02dco Abreu, Laura Bocchi, Jose\u00b4 Luiz Fiadeiro, and Anto\u00b4nia Lopes. Specifying and composing interaction protocols for serviceoriented system modelling. In Formal Methods for Networked and Distributed Systems, volume 4574 of Lecture Notes in Computer Science, pages 358\u2013373. Springer Verlag, 2007.","cites":null},{"id":43674328,"title":"StPowla: SOA, Policies and Workflows.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-93851-4_35","raw":"Stephen Gorton, Carlo Montangero, Stephan Reiff-Marganiec, and Laura Semini. StPowla: SOA, Policies and Workflows. In Proceedings of 3rd International Workshop on Engineering Service-Oriented Applications: Analysis, Design, and Composition, Vienna, Austria (17th September 2007), 2007.","cites":null},{"id":43674353,"title":"ter Hofstede, and Petia Wohed. On the suitability of uml 2.0 activity diagrams for business process modelling.","authors":[],"date":"2006","doi":"10.1007\/11568322_5","raw":"Nick Russell, Wil M. P. van der Aalst, Arthur H. M. ter Hofstede, and Petia Wohed. On the suitability of uml 2.0 activity diagrams for business process modelling. In Markus Stumptner, Sven Hartmann, and Yasushi Kiyoki, editors, APCCM, volume 53 of CRPIT, pages 95\u2013104. Australian Computer Society, 2006.","cites":null},{"id":43674348,"title":"ter Hofstede. Formal description of non-functional service properties.","authors":[],"date":"2005","doi":null,"raw":"J. O\u2019Sullivan, D. Edmond, and A. H. M. ter Hofstede. Formal description of non-functional service properties. Technical Report FIT-TR-2005-01, Queensland University of Technology, Brisbane, Feb 2005.","cites":null},{"id":43674357,"title":"ter Hofstede. Yawl: yet another workflow language.","authors":[],"date":"2005","doi":"10.1016\/j.is.2004.02.002","raw":"Wil M. P. van der Aalst and Arthur H. M. ter Hofstede. Yawl: yet another workflow language. Inf. Syst., 30(4):245\u2013275, 2005.","cites":null},{"id":43674331,"title":"Towards a task-oriented, policy-driven business requirements specification for web services.","authors":[],"date":null,"doi":"10.1007\/11841760_40","raw":"S. Gorton and S. Reiff-Marganiec. Towards a task-oriented, policy-driven business requirements specification for web services. In Dustdar et al. [DFS06], pages 465\u2013470.","cites":null},{"id":43674334,"title":"Using first-order logic to reason about policies.","authors":[],"date":"2003","doi":"10.1109\/csfw.2003.1212713","raw":"J. Y. Halpern and V. Weissman. Using first-order logic to reason about policies. In 16th IEEE Computer Security Foundations Workshop (CSFW\u201903), page 187, Los Alamitos, CA, USA, 2003. IEEE Computer Society.","cites":null},{"id":43674332,"title":"Web Services Glossary. W3C Working Group Note, World Wide Web Consortium","authors":[],"date":"2004","doi":null,"raw":"Hugo Haas and Allen Brown. Web Services Glossary. W3C Working Group Note, World Wide Web Consortium (W3C), 2004. http:\/\/www.w3.org\/TR\/ws-gloss\/.","cites":null},{"id":43674318,"title":"Web services policy 1.2 \u2013 framework (WS-Policy).","authors":[],"date":"2006","doi":null,"raw":"J. Schlimmer (ed). Web services policy 1.2 \u2013 framework (WS-Policy). W3C, Apr 2006. http:\/\/www.w3.org\/Submission\/WS-Policy\/.","cites":null},{"id":43674359,"title":"Workflow patterns.","authors":[],"date":"2003","doi":"10.1007\/10722620_2","raw":"Wil M. P. van der Aalst, Arthur H. M. ter Hofstede, Bartek Kiepuszewski, and Alistair P. Barros. Workflow patterns. Distributed and Parallel Databases, 14(1):5\u201351, 2003. Information also available from www.workflowpatterns.com.","cites":null},{"id":43674306,"title":"Worklets: A service-oriented implementation of dynamic flexibility in workflows.","authors":[],"date":"2006","doi":"10.1007\/11914853_18","raw":"Michael Adams, Arthur H. M. ter Hofstede, David Edmond, and Wil M. P. van der Aalst. Worklets: A service-oriented implementation of dynamic flexibility in workflows. In Robert Meersman and Zahir Tari, editors, OTM Conferences (1), volume 4275 of Lecture Notes in Computer Science, pages 291\u2013308. Springer, 2006.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2010-05","abstract":"This is the authors' final draft of the paper published as Formal Aspects of Computing, 2010, 22(3-4), pp.243-268. The original publication is available at www.springerlink.com , DOI: 10.1007\/s00165-009-0118-7Service Oriented Computing is a paradigm for developing software systems as the composition of a number of services. Services are loosely coupled entities, that can be dynamically published, discovered and invoked over a network. The engineering of such systems presents novel challenges, mostly due to the dynamicity and distributed nature of service-based applications. In this paper, we focus on the modelling of service orchestrations. We discuss the relationship between two languages developed under the Sensoria project: SRML as a high level modelling language for Service Oriented Architectures, and StPowla as a process-oriented orchestration approach that separates core business processes from system variability at the end-user\u2019s level, where the focus is towards achieving business goals. A fundamental challenge of software engineering is to correctly align business goals with IT strategy, and as such we present an encoding of StPowla to SRML. This provides a formal framework for StPowla and also a separated view of policies representing system variability that is not present in SRML","downloadUrl":"http:\/\/hdl.handle.net\/2381\/9076","fullTextIdentifier":"https:\/\/lra.le.ac.uk\/bitstream\/2381\/9076\/3\/FACS.pdf","pdfHashValue":"581014655308b2bf029b05efa9beb500c01f237b","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n        \n            \n                oai:lra.le.ac.uk:2381\/9076<\/identifier><datestamp>\n                2015-12-07T12:09:21Z<\/datestamp><setSpec>\n                com_2381_316<\/setSpec><setSpec>\n                com_2381_9549<\/setSpec><setSpec>\n                col_2381_1116<\/setSpec>\n            <\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:doc=\"http:\/\/www.lyncode.com\/xoai\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n            \nFrom StPowla processes to SRML models<\/dc:title><dc:creator>\nBocchi, Laura<\/dc:creator><dc:creator>\nReiff-Marganiec, Stephan<\/dc:creator><dc:creator>\nGorton, Stephen<\/dc:creator><dc:subject>\nService modelling<\/dc:subject><dc:subject>\nPolicies<\/dc:subject><dc:subject>\nworkflows<\/dc:subject><dc:subject>\nService oriented architecture<\/dc:subject><dc:description>\nThis is the authors' final draft of the paper published as Formal Aspects of Computing, 2010, 22(3-4), pp.243-268. The original publication is available at www.springerlink.com , DOI: 10.1007\/s00165-009-0118-7<\/dc:description><dc:description>\nService Oriented Computing is a paradigm for developing software systems as the composition of a number of services. Services are loosely coupled entities, that can be dynamically published, discovered and invoked over a network. The engineering of such systems presents novel challenges, mostly due to the dynamicity and distributed nature of service-based applications. In this paper, we focus on the modelling of service orchestrations. We discuss the relationship between two languages developed under the Sensoria project: SRML as a high level modelling language for Service Oriented Architectures, and StPowla as a process-oriented orchestration approach that separates core business processes from system variability at the end-user\u2019s level, where the focus is towards achieving business goals. A fundamental challenge of software engineering is to correctly align business goals with IT strategy, and as such we present an encoding of StPowla to SRML. This provides a formal framework for StPowla and also a separated view of policies representing system variability that is not present in SRML.<\/dc:description><dc:date>\n2011-02-16T10:17:24Z<\/dc:date><dc:date>\n2011-02-16T10:17:24Z<\/dc:date><dc:date>\n2010-05<\/dc:date><dc:type>\nArticle<\/dc:type><dc:identifier>\nFormal Aspects of Computing, 2010, 22(3-4), pp.243-268.<\/dc:identifier><dc:identifier>\n0934-5043 (Print)<\/dc:identifier><dc:identifier>\n1433-299X (Online)<\/dc:identifier><dc:identifier>\nhttp:\/\/link.springer.com\/article\/10.1007%2Fs00165-009-0118-7<\/dc:identifier><dc:identifier>\nhttp:\/\/hdl.handle.net\/2381\/9076<\/dc:identifier><dc:identifier>\n10.1007\/s00165-009-0118-7<\/dc:identifier><dc:language>\nen<\/dc:language><dc:publisher>\nSpringer<\/dc:publisher>\n<\/oai_dc:dc>\n<\/metadata>\n        <\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2010,"topics":["Service modelling","Policies","workflows","Service oriented architecture"],"subject":["Article"],"fullText":"Under consideration for publication in Formal Aspects of Computing\nFrom StPowla Processes to SRML Models\nLaura Bocchi1 and Stephen Gorton2 and Stephan Reiff-Marganiec1\n1Department of Computer Science, University of Leicester, Leicester, UK\n2ATX Technologies Limited, London, UK\nAbstract. Service Oriented Computing is a paradigm for developing software systems as the composition of a number\nof services. Services are loosely coupled entities, that can be dynamically published, discovered and invoked over a\nnetwork. The engineering of such systems presents novel challenges, mostly due to the dynamicity and distributed\nnature of service-based applications. In this paper, we focus on the modelling of service orchestrations. We discuss the\nrelationship between two languages developed under the SENSORIA project: SRML as a high level modelling language\nfor Service Oriented Architectures, and STPOWLA as a process-oriented orchestration approach that separates core\nbusiness processes from system variability at the end-user\u2019s level, where the focus is towards achieving business goals.\nA fundamental challenge of software engineering is to correctly align business goals with IT strategy, and as such we\npresent an encoding of STPOWLA to SRML. This provides a formal framework for STPOWLA and also a separated\nview of policies representing system variability that is not present in SRML.\nKeywords: Service Modelling, Policies, Workflows, Service Oriented Architecture.\n1. Introduction\nService Oriented Computing (SOC) is a paradigm for developing software systems as the composition of a number\nof services. Services are loosely coupled entities that can be dynamically published, discovered and invoked over a\nnetwork. A service is an abstract resource whose invocation triggers a possibly interactive activity (i.e. a session) and\nthat provides some functionality meaningful from the perspective of the business logic [HA04]. A Service Oriented\nArchitecture (SOA) allows services with heterogeneous implementations to interact relying on the same middleware\ninfrastructure. Web Services and the Grid are the most popular implementations of SOA. Exposing software in this\nway means that applications may outsource some functionalities and be dynamically assembled, leading to massively\ndistributed, interoperable and evolvable systems.\nThe engineering of service-oriented systems presents novel challenges, mostly due to this dynamicity [WBC+07].\nIn this paper we focus on the modelling of orchestrations. An orchestration is the description of the executable pattern\nof service invocations\/interactions to follow in order to achieve a business goal.\nConsidering this view, we encounter both: more typical Computer Science issues as well as a business oriented\nperspective \u2013 each with their own challenges \u2013 but also a need to bridge the gap between the two. In the light of this,\nwe discuss the relationship between two modelling languages for service oriented systems developed in the context\nCorrespondence and offprint requests to: Laura Bocchi, Department of Computer Science, University of Leicester, University Road, Leicester LE1\n7RH, UK. e-mail: bocchi@mcs.le.ac.uk\n2 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nof SENSORIA, an IST-FET Integrated Project on Software Engineering for Service-Oriented Overlay Computers: the\nSensoria Reference Modelling Language (SRML) [FLB06, ABFL07] and STPOWLA: the Service-Targeted, Policy-\nOriented WorkfLow Approach [GMRMS07]. The former addresses the Computer Science needs of providing models\nat a high level of abstraction but with the possibility of presenting quite refined descriptions. The latter is oriented\ntowards the business user. Their combined use provides an approach to bridge the gap between Computer Science and\nBusiness needs.\nSRML is a high-level modelling language for SOAs whose goal is \u201cto provide a set of primitives that is expressive\nenough to model applications in the service-oriented paradigm and simple enough to be formalised\u201d [FLB06]. SRML\naims at representing the various foundational aspects of SOC (e.g. service composition, dynamic reconfiguration,\nservice level agreement, etc.) within one integrated formal framework. A declarative semantics has been provided\nin [AF08, LFB07] that maps SRML to mathematical domains that make precise the meaning of the different constructs\nmade available in SRML. In particular, [AF08] provides a formal computational model for SRML which is being\nmapped into a logic adapted from \u00b5UCTL, a formalism being developed within SENSORIA for supporting qualitative\nanalysis [GM05].\nSTPOWLA is an approach to process modelling for service-oriented systems. It has three ingredients: workflows\nto express core processes, services to perform activities and policies to express variability. Workflows are expressed\nusing a graphical notation, such as in [GRM06c] or UML activity diagrams1. Policies can make short-lived changes\nto a workflow instance, i.e. they last for the duration of the workflow instance and usually will be made during the\nexecution of the instance, rather than applied to the overall workflow model. STPOWLA allows for both functional and\nnon-functional changes to a workflow, the former have been introduced in [BGR08]. The non-functional changes are\ncalled refinement and provide a means to select the most appropriate service based on the current environment when\na service is invoked. The functional changes are termed reconfiguration and are short lived structural changes to a\nworkflow instance.\nHaving considered the two languages in more detail, we can now add a few words to expand on the motivatation\nwhy both are needed as a way to address the needs of the two communities mentioned above. One can say that SRMLis\ncomplete in its expressive power with respect to the systems we intend to model. While expressivity is clearly an issue\nto a Computer Scientist, usability is the more important factor for Business Analysts. STPOWLA addresses usability\npartly in making use of graphical notations and more crucially in being modular in that the basic workflow and the\npolicies capturing variability are kept seperate while SRMLis essentially flat in that it merges both into the same\ndescription.\nThe encoding of STPOWLA into SRML, on the one hand provides a formal framework to STPOWLA. Business\nprocesses modelled in STPOWLA can be then represented as SRML models and either being analysed alone or as part\nof more complex modules, where they are composed with other SRML models with heterogeneous implementations\n(e.g. SRML models extracted from existing BPEL processes [BHLF07]).\nA second reason for the encoding is providing a higher layer to the modelling of orchestrations in SRML that\nincludes a process-based approach to the definition of a workflow schedule, a separated view of policies, that had not\nbeen yet considered in SRML, and the inter-relation between workflow and policies.\nThis paper extends on [BGR08] by introducing a mapping for the refinement aspects of STPOWLA and providing\nmore detail on the reconfiguration mapping to enhance clarity. Furthermore we consider an example for the use of\nSRML and STPOWLA in combination based on an industrial case study from the SENSORIA project [sen]. Using the\nexample we present the envisaged methodology of using the two languages.\nIn this paper, we give an overview of the STPOWLA approach, including the extension for workflow reconfigura-\ntions initially proposed in [BGR08] in section 2. We describe the main concepts of SRML, with respect to STPOWLA\nin section 3. We then provide an encoding of basic workflow control flow constructs in section 4, and proceed to\ndescribe the mapping of STPOWLA reconfiguration and refinement policies to SRML in section 5. We present the\nforseen methodology for the combined use of STPOWLA and SRML in 6.1 by presenting a case study. Related work\nand our position relative to these efforts in section 7 and a summary and conclusion in section 8 round the paper off.\n2. Specifying and Reconfiguring StPowla Workflows\nIn this section, we give a brief introduction to the main concepts of STPOWLA, highlighting the motivation and then\nfocusing on workflows, and both refinement and reconfiguration policies.\n1 http:\/\/www.agilemodeling.com\/artifacts\/activityDiagram.htm\nFrom StPowla Processes to SRML Models 3\npolicyName\nappliesTo task_id\nwhen task_entry\ndo req(main, params, [])\nFig. 1. A STPOWLA task\u2019s default policy.\n2.1. Overview\nSTPOWLA has been designed with the business user in mind \u2013 typically businesses follow some business process\nwhich is usually described as a workflow. However, the processes are often subject to temporary changes (for example\ndifferent procedures for holiday cover or large orders) as well as overarching rules applicable to all processes (for\nexample a travel policy requiring employees to travel 2nd class). Of course the tasks in the process need to be executed,\nwhich is often done by automated procedures. With this in mind STPOWLA has three ingredients: workflows, policies\nand SOA. Workflows specify core business processes, in which all task requirements are satisfied by services, that is a\nservice (possibly human) can be invoked to complete the task.\nWe model a workflow using a graphical notation presented in [GRM06c]. However, for the purpose of this paper\nwe also adapt the more concise textual grammar presented in [BGR08] which shows how complex processes can be\ncomposed:\nWF ::= start;P ; end root process\nP ::= T simple task\n| P ;P sequence\n| \u03bb?P : P condition and simple (XOR) join\n| FJ(m, {P,B}, ..., {P,B}) split and complex (AND) join\n| SP (P, ..., P ) strict preference\n| RC(P, ..., P ) random choice\n| Scope(P ) scope\nBriefly, a workflow has a start and end node nesting the process. The simplest process consists of just one task, more\ninteresting processes contain operators that allow sequencing of processes, a conditional branching of the flow with a\nsimple join or a split into parallel processes with a complex merging operation. There are also operators to specify strict\npreferences or random choice. A more formal description of the semantics of each construct is presented together with\nwith a description of the relevant SRML transition in section 4. We have mentioned in an earlier paper [GMRMS07]\nthat the choice of workflow notation in STPOWLA is essentially insignificant.\nPolicies are either Event-Condition-Action (ECA) rules (in which case they require a trigger), or goals (es-\nsentially ECAs without triggers). The purpose of policies is to express system variability. Policies are written in\nAPPEL [RMTB05], a policy description language with formal semantics via a mapping to \u2206DSTL [MRMS07,\nMRMSon]. They are written by the end (business) user and are combined with the workflow at execution time. Poli-\ncies can express refinement and reconfiguration and we will return our attention to each of these types in the next two\nsubsections. Generally policies have the following shape:\npolicyName\nappliesTo task_id\nwhen trigger\nif condition\ndo action\nAdditionally to the user specified policies, each workflow task has a default policy as in Fig. 1. The semantics\nof the req function are essentially to execute the processing of the task, as specified with functional requirements\ndescribed in the main argument, in accordance with invocation parameters in the second argument and keeping to\ndefault SLR (Service Level Request) constraints in the third argument (that is no value is specified in the policy).\nWorkflows are executed by an enhanced workflow engine and at specific trigger points the policy engine is in-\nvoked; the policy engine will check for applicable policies and apply the relevant actions on the workflow. Clearly the\nidentification of a common set of triggers for ECA policies is of interest, as these present the interaction point between\nthe policies and the workflow at runtime. We have identified the following as valid triggers for reconfiguration policies\nas this typeof policy can make changes to the workflow at large:\n4 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nFunction Syntax Informal Description\nreq(action, [args], [SLR]) Request a service to fulfil action that satisfies Service Level Require-\nments SLR.\nTable 1. APPEL policy: refinement action\n\u2022 Workflow entry\/success\/failure\/abort;\n\u2022 Task entry\/success\/failure\/abort;\n\u2022 Service entry\/success\/failure.\nRefinement policies are more local: they only influence the selection of the service for the task to be executed. Hence\nthe only trigger that needs to be considered for refinement policies is \u2018Task entry\u2019.\nNote that in STPOWLA, we view services as a black box, i.e. they are invoked with the required data, but we cannot\nintervene in their processing until they respond (or maybe time out).\n2.2. Refining Tasks with Policies\nRefinement policies in STPOWLA have been the focus of previous work [GMRMS07]. The overall idea is that policies\ncan specify additional criteria on a service. In STPOWLA we refer to such extra requirements as Service Level Requests\n(SLR) \u2013 in many ways they are similar to what one would understand as Service Level Agreements (SLA). The\nsimilarities are focused on what is intended through them and the kind of issues that are expressed in these requests.\nThe overall aim of an SLR is that the chosen service provides the expected criteria; the criteria are often non-functional\nattributes of a service. The main difference to SLAs is that no agreement has been found: there might not be a service\nthat fulfils the requested service levels, in which case negotiation or a suitable other technique needs to be applied to\nresolve the issue.\nAction req is the essential bit of the Appel specialization to deal with selection and invocation of services. It is\ngeneric, i.e. independent of the business domain.\nAction req takes three arguments:\n\u2022 the type of the service, expressing its basic functionality. By default it coincides with the name of the task, and is\ndenoted simply as main. Anyway, the type must be known in the domain description;\n\u2022 the list of service parameters, in terms of the task parameters and attributes;\n\u2022 the specification of the constraints on service selection: they express Service Level Agreements. In the default\npolicy the list of constraints is empty: any service of the required type will do.\nInformally req request to find a service as described by the first and third arguments, bind it, and invoke it with the\nvalues in the second argument. The action succeeds if a service is found, and its invocation is successful. It fails if\neither no service is found or if the bound service fails. The binding acts as a commit: only one service is invoked, and\nif its invocation fails no other found service is invoked.\n2.3. Reconfiguring Workflows with Policies\nA workflow reconfiguration is the structural change of a workflow instance. In STPOWLA, a policy can express a\nreconfiguration rule based on a number of available functions, as described in Table 2. These changes are short-lived,\ni.e. they only affect the workflow instance and not the overall workflow model.\nAs an example, consider a supplier whose business process is to receive an order from a registered customer, and\nthen to process that order (which includes collecting, packing and shipping the items, plus invoicing the client). There\nare no extra constraints on each task, therefore the default task policies are effectively \u201cempty\u201d.\nNow consider that under certain conditions (e.g. financial pressure), a financial guarantee is required from all\ncustomers whose order is above a certain amount. We may have the following policy:\nFrom StPowla Processes to SRML Models 5\nFunction Syntax Informal Description\nfail() Declare the current task to have failed, i.e. discard further task processing\nand generate the task failure event.\nabort() Abort the current task and progress to the next task, generating the\ntask abort event.\nblock(s, p) Wait until predicate p is true before commencing scope s.\ninsert(x, y, z) Insert task or scope y into the current workflow instance after task x if z\nis true, or in parallel with x if z is false.\ndelete(x) Delete scope x from the current workflow instance.\nTable 2. APPEL policy: reconfiguration actions\nreceive \nOrder\nprocess \nOrder\nTransform with \nGetDepositIfLargeOrder policy\nreceive \nOrder\nprocess \nOrder\nget \nDeposit\nFig. 2. A simple reconfiguration example where a core business process is transformed via the insertion of the getDeposit task after the receiveOrder\ntask. The transformation rule comes from a policy.\nGetDepositIfLargeOrder\nappliesTo receiveOrder\nwhen task_completion\nif receiveOrder.orderValue > 250000\ndo insert(requestDeposit, receiveOrder, false)\nIntuitively, this policy (named GetDepositIfLargeOrder) applies to the receiveOrder. It says that when the task\ncompletes successfully and the attribute orderValue (bound to that task) is above \u00a3250000, then there should be an\naction. The action in this case is the insertion of a task requestDeposit into the workflow instance after (not in parallel\nto) the receiveOrder task. The workflow instance thus undergoes the transformation as shown in Fig. 2.\n3. Encoding of StPowla to SRML - Foundational Concepts\nIn SRML composite services are modelled through modules. A module declares one or more components, that are\ntightly bound and defined at design time, a number of requires-interfaces that specify services, that need to be provided\nby external parties, and (at most) one provides-interface that describes the service that is offered by the module. A\nnumber of wires establish interaction protocols among the components and between the components and the external\ninterfaces. Figure 3 shows the SRML module ProcurementService which includes: one provides-interface CR (i.e.,\nthe interface of the service provided to the customer), one requires-interface (i.e., the interface of the service that we\nwill discover at run-time) and two components, BP and PI, that orchestrate the interactions among the parties.\nThe internal nodes of a SRML module can reside at three different layers (top layer, service-oriented layer and\nbottom layer). Layers in SRML are architectural abstractions that reflect different levels of organisation and change.\nEach layer uses the layer underneath. The top layer uses the service-oriented layer to achieve some business goal. For\nexample, an application could be designed for the same organization that intend to use it and not for being published\nas a service. We call this type of applications activity. The creation of the instance of an activity is triggered by a node\nthat belongs to the top layer and not by a provides-interface. The service oriented layer uses the bottom layer which\ntypically includes entities which are persistent as far as the life cycle of the activities is concerned, and can be shared\nby multiple instances of the same activity (e.g., a database shared by all the instances of a service).\nHere we focus on SRML modules where nodes reside only at the service-oriented layer. This simplification is\n6 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nPROCUREMENTSERVICE\nPI:\nPolicyInterface\nBP:\nBusinessProcess\nPB\nBO     CR:     customer\nOP:\norderProcessorCB\nSLA\nFig. 3. The structure of a SRML module for the procurement service example\ndone without loss of generality since it does not have any influence on the encoding. In fact, STPOWLA does not\nmake any distinction about the type of entity that performs a task (e.g., dynamically discovered service vs persistent\nresource). The role of the different layers will become interesting in the discussion on the methodology in Section 6.1.\nThe interested reader can refer to [BFL08b] for more details on the layered structure of SRML modules.\nComponents, external interfaces, wires and interfaces of the different layers are specified in terms of Business\nRoles, Business Protocols, Interaction Protocols, and Layer Protocols respectively. The specifications define the type\nof the nodes. Each specification provides a slightly different style of behavioural description. A business role defines\nan execution pattern involving the interactions that it declares in its signature, what we call an orchestration. Business\nprotocols provide a set of properties that abstracts from details of the executable process implemented by the orchestra-\ntion (e.g., the local state) and describe the behaviour that can be expected of the service (in case of provides-interface)\nor specify the behaviour that is expected (in the case of requires-interface) of the external party. The interaction pro-\ntocols define a collection of properties that establish how the interactions are coordinated, which may include routing\nevents or transforming sent data to the format expected by the receiver. However, each language has been captured in\nthe computational model presented in [AF08], which defines the activity of a configuration of SRML components in\nterms of transition systems where transitions represent the sending, receiving and processing of events by the entities\ninvolved in the business activity. The logic UCTL [GM05] is being used to reason about such transition systems. The\naim is to provide (1) a notion of correctness for service modules (i.e., the properties of a provides-interface are entailed\nby the body of a module, assuming the properties described in the requires\/uses-interfaces), (2) a way of formalising\nthe matching of provides\/requires-interfaces, and (3) a means for validation of activity and service design.\nIn this paper we provide an encoding to derive, from a business process specified in STPOWLA, an SRML compo-\nnent that we call BP, of type BusinessProcess and a second component PI, of type PolicyInterface that is connected\nto BP and represents the interface through which it is possible to trigger policies that modify the control flow. PI sup-\nports the set of interactions used to trigger a workflow modification in the component BP. Figure 3 illustrates the\nstructure of the SRML module representing the workflow and policies in the procurement example described earlier\nin this section.\nComponents are instances of business roles specified in terms of (1) the set of supported interactions, and (2) the\nway in which the interactions are orchestrated. The remainder of this section provides an overview of business roles.\nThe overview will not include the other types of SRML specification as they are not concerned in the encoding.\n3.1. Business Roles: the Interactions\nSRML supports asynchronous two-way conversational interactions: s&r denotes interactions that are initiated by the\nco-party, which expects a reply, r&s denotes interactions that are initiated by the party, which expects a reply from\nits co-party. SRML supports also asynchronous one-way and synchronous interactions that are not discussed here as\nthey are not required for the work presented in this paper.\nThis is followed by the specification of the interactions supported by PolicyInterface, each corresponding to one\nof the STPOWLA functions in Table 2. The business role BusinessProcess supports the complementary interactions\n(i.e. r&s instead of s&r) plus, other interactions that occur with the external parties. Each interaction can have\u05a0 -\nparameters for transmitting data when the interaction is initiated and\u0001 -parameters for carrying a reply (which in this\ncase are not used as the reply event does not carry data). The index i represents a key-parameter that allows us to\nhandle occurrences of multiple interactions of the same type (as in SRML every interaction event must occur at most\nonce). In this case, we allow PI to trigger more instances of policy functions of the same type.\nFrom StPowla Processes to SRML Models 7\nBUSINESS ROLE PolicyInterface is\nINTERACTIONS\ns&r delete[i:natural]\n\u05a0 task:taskId\ns&r insert[i:natural]\n\u05a0 task:taskId\nnewTask:taskId\nc:condition\ns&r block[i:natural]\n\u05a0 task:taskId\nc:condition\ns&r fail[i:natural]\n\u05a0 task:taskId\ns&r abort[i:natural]\n\u05a0 task:taskId\n3.2. Business Roles: the Orchestration\nThe way the declared interactions are orchestrated is specified through a set of variables that provide an abstract view\nof the state of the component, and a set of transitions that model the way the component interacts with its co-parties.\nFor instance, the local state of the orchestrator is defined as follows:\nlocal\nstart[root],start[x],start[ro],...:boolean, ...\nstate[root],state[x],state[ro],...:[toStart,running,exited]\nA module can define an initialisation condition for the each component. For example, the module Procure-\nmentService may define the following initial state for the component OR:\nstart[root]=true\n\u2227 start[x]=start[ro]=...=false\n\u2227 state[root]=state[x]=state[ro]=...=toStart \u2227 ...\nSimilarly, a termination condition may specify the situations in which the component has terminated any activity.\nThe behaviour of components is described by transition rules. Each transition has a name, and a number of other\nfeatures:\ntransition policyHandlerExample\ntriggeredBy samplePolicy\u05a0 [i]\nguardedBy state[samplePolicy\u05a0 [i].task] = toStart\neffects policy[samplePolicy\u05a0 [i].task]\u2019 \u2227 ......\nsends samplePolicy\u0001 [i]\ntriggeredBy is a condition, typically the occurrence of a receive-event or a state condition, which triggers the exe-\ncution of the transition. In the example we engage in the policyHandlerExample transition when we receive the\ninitiation of the interaction samplePolicy (i.e., samplePolicy\u05a0 [i]).\nguardedBy is a condition that identifies the states in which the transition can take place. For instance, the policyHan-\ndlerExample transitions should only be taken when the involved task is in state toStart (i.e. is not in execution and\nit has not been executed yet). The involved task is identified by the parameter task of the interaction samplePolicy\n(i.e., samplePolicy\u05a0 [i].task).\neffects concern changes to the local state. We use var \u2032 to denote the value the state variable var has after the transition.\nsends is a sentence that describes the events that are sent and the values taken by their parameters. In the example we\ninvoke the samplePolicy reply event (i.e., samplePolicy\u0001 [i]) to notify of the correct management of the policy.\n8 L. Bocchi and S. Gorton and S. Reiff-Marganiec\n3.3. Constraints for Service Level Agreement in a SRML Module\nSRML offers primitives for modelling the dynamic aspects concerned with session management and service level\nagreement, which together we call configuration policies. The external configuration policy concerns the constraints\nthat the process of discovery, negotiation and binding must satisfy to establish service level agreements (SLA) with\nservice providers. The external configuration policy models an orthogonal aspect with respect to the orchestration.\nSpecifically, it defines a set of non-functional properties to be considered when, in a specific point of the orchestration\nprocess, the run-time discovery of an external service for outsourcing the execution of a specific task is required.\nIn SRML, we use the algebraic approach developed in [SUF97] for constraint satisfaction and optimization. In the\nfollowing example we use a constraint system where the degree of satisfaction has fuzzy values, i.e. it takes value in\nthe interval [0, 1].\nEXTERNAL POLICY\nSLA VARIABLES\nOP.LOCATION, CR.LOCATION\nCONSTRAINTS\nCloseness is <{OP.LOCATION, CR.LOCATION},def2> s.t.\nif distance(OP.LOCATION, CR.LOCATION)<50 then def2(n,m)=1,\notherwise def2(n,m)=500\/n\nIn order to define the constraints that we wish to apply to the module ProcurementService, we use the SLA variables\nOP.LOCATION and CR.LOCATION which are the locations of the order processor and customer, respectively. We\ndefine only one constraint Closeness, which minimises the distance between the customer CR and the order pro-\ncessor OP. The best degrees of satisfaction are when the distance is less than 50 miles. Otherwise they are inversely\nproportional to the distance. The function distance returns the distance between two locations.\nFor each potential order processor (i.e., the service, among the published ones, whose provides-interface matches\nwithOP, of typeOrderProcessor), the set of constraints has to be solved. The solution assigns a degree of satisfaction\nto each possible tuple of values for the SLA variables. Negotiation in our framework consists in finding an assignment\nthat maximizes the degree of satisfaction. Hence, the outcome of the negotiation between ProcurementService and\nthe potential partner is any tuple that maximizes the degree of satisfaction. Selection then picks a partner with a service\nlevel agreement that offers the best degree of satisfaction.\n4. Encoding StPowla Workflows in SRML\nIn this section we present an encoding from the control constructs of STPOWLA to SRML orchestrations. Our focus\nis on the control constructs and we abstract from the interactions of the service and from the semantics of the simple\nactivities of the workflow tasks.\nSTPOWLA represents a business process as the composition of a number of tasks, either simple (e.g. interactions\nwith services) or complex (e.g. coordinating other tasks by executing them in sequence, parallel, etc.). In SRML we\nassociate an identifier, of type taskId, to any task. We denote with T the set of all the task indexes in the workflow\nschedule.\nFor each task identifier x we define the following local variables, used to handle the control flow and coordinate\nthe execution of the tasks:\n\u2022 start[x] is a boolean variable that, when true, triggers the execution of x,\n\u2022 done[x] is a boolean variable that signals the successful termination of x and triggers the continuation of the\nworkflow schedule,\n\u2022 fail[x] is a boolean variable that signals the termination with failure of x and triggers the failure handler.\nIn general, the next activity in the control flow is executed when the previous one terminates successfully. In case\nof task failure the flow blocks (i.e. the next task is waiting for a signal of successful termination from the previous\ntask) and the failure signal is collected by a failure handler that possibly involves a number of policies. According to\nthe failure handler, the execution of the process can be terminated, resumed, altered, etc. We leave the specification\nof the failure handling mechanisms as a future work. Anyway, the construct of strict preference and random choice,\nthat try a number of alternative tasks until one terminates with success, handle the failure signal directly, within the\nworkflow. The scope construct can be extended in the future to support failure handling, as discussed in Section 4.6.\nFrom StPowla Processes to SRML Models 9\nFig. 4. The sequence control construct in STPOWLA\nWe will introduce in section 5 a set of transitions, as a part of the orchestration of BP that model the policy handler.\nThe policy handler has the responsibility to enact the modifications of the control flow induced by the policies triggered\nby PI. The policy handler blocks the normal flow by setting the variable policy[x] = true, where x is the identifier of\nthe first task involved in the modification. The variable policy[x] is a guard to the execution of x. We will describe the\npolicy handler more later in this paper, by now it is important to know that when a policy function has to be executed\non a task, the task has to be blocked. It is responsibility of the policy handler to reset the flow of execution.\nSome policies can be applied only on running processes (e.g. abort) and some others only on tasks that have\nnot started yet (e.g., the deletion). We define a local variable state[x] for every task identifier x which identifies\nthe state of the execution of the transition associated to x by taking one of the following values: toStart (i.e., the\nexecution of the task has not started yet), running (i.e. the task is in execution) and exited (i.e. x has terminated).\nThe initialization conditions for the module set, for each task identifier x, state[x] = toStart, see for example the\ninitialization condition for ProcurementService presented in Section 3.1. The state variable state[x] isl be used to\nensure that policies act on a task in the correct state of execution (i.e., the deletion of task x can be performed only if\nstate[x] = toStart).\nWe consider the simple tasks as black boxes: we are not interested in the type of activity that they perform but\nonly on the fact that a task, for example task x, is activated by start[x], signals its termination along either done[x] or\nfailed[x] and notifies its state along state[x].\nThe execution of the workflow is started by a special transition root that sets start[x] = true where x is the\nfirst task in the workflow schedule. The local variables are initialized as follows: \u2200i \u2208 T \\ root, start[i] = false \u2227\nstart[root] = true, \u2200i \u2208 T, done[i] = failed[i] = policy[i] = false and \u2200i \u2208 T, state[i] = toStart.\nIt follows the encoding of the workflow template start;P ; end where P is associated to the task identifier x:\ntransition root\ntriggeredBy start[root] \u2228 done[x]\nguardedBy \u00ac policy[root]\neffects\nstart[root]\u2283 \u00ac start[root]\u2019 \u2227 state[root]\u2019=running \u2227 start[x]\u2019\n\u2227 done[x] \u2283 \u00ac done[x]\u2019 \u2227 done[root]\u2019 \u2227 state[root]\u2019=exited\nThe guard of transition x ensures the execution of the transition only if no policy has been triggered on task root\n(i.e., policy[root] is false). According to the trigger, root is executed twice:\n1. at the beginning of the workflow (recall from Section 3.1 that the initialization condition of ProcurementService\nincludes the assignment start[root] = true). The transition in this case has the following effects: (1) disabling\nthe the triggering condition of root (i.e., start[root] is set to false, (2) setting the state of task root to running\nand (3) triggering the transition for task x by setting start[x] to true.\n2. when task x terminates (i.e., done[x] = true). The transition in this case has the following effects: (1) disabling\nthe termination signal for x is disabled (i.e., done[x] is set to false), (2) enabling the termination signal for root\niand (3) setting the state variable for root to exited.\n4.1. Sequence\nThe sequence operator P1;P2, illustrated in Figure 4, first executes P1 and, after the successful termination of P1,\nexecutes P2. We remark that failures are not handled in this document and will be addressed in the future. The\nencoding of the sequence construct in SRML is as follows. The sequence is encoded in the following SRML transition,\nwith task identifier x, which triggers the execution of the first task, with task identifier p1, then collects the termination\nsignal from p1 and triggers the execution of the second subprocess, with task identifier p2:\ntransition X\ntriggeredBy start[x] \u2228 done[p1] \u2228 done[p2]\nguardedBy \u00ac policy[x]\n10 L. Bocchi and S. Gorton and S. Reiff-Marganiec\n(a) Condition\/simple join (b) Split\/complex join\nFig. 5. Multiple branches constructs in STPOWLA\neffects\nstart[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]\u2019=running \u2227 start[p1]\u2019\n\u2227 done[p1] \u2283 \u00ac done[p1]\u2019 \u2227 start[p2]\u2019\n\u2227 done[p2] \u2283 \u00ac done[p2]\u2019 \u2227 done[x]\u2019 \u2227 state[x]\u2019=exited\nTransition X is executed three times:\n1. when start[x] is true. The transition in this case has the following effects: (1) disabling the triggering condition\nstart[x], (2) changing the state of task x to running and (3) enabling the triggering condition start[p1].\n2. when done[p1] is true (i.e., after p1 has been executed). The transition in this case has the following effects: (1)\ndisabling the termination signal p1 and (2) enabling the triggering condition start[p2].\n3. when done[p2] is true. The transition in this case has the following effects: (1) disabling the termination signal for\np2 , (2) enabling the termination signal for x and (3) setting the state of task x to exited.\n4.2. Condition and Simple Join (XOR)\nThe condition and simple join construct \u03bb?P1 : P2, illustrated in Figure 5(a), consists of the combination of the flow\njunction, that diverts the control flow down one of two branches P1 and P2, represented by the task identifiers p1 and\np2, respectively, according to a condition \u03bb, and the flow merge of a number of flows where synchronization is not an\nissue. The condition and simple join are encoded into the following SRML transition:\ntransition X\ntriggeredBy start[x] \u2228 done[p1] \u2228 done[p2]\nguardedBy \u00ac policy[x]\neffects\nstart[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]\u2019=running\n\u2227 (\u03bb \u2283 start[p1]\u2019) \u2227 (\u00ac \u03bb \u2283 start[p2]\u2019)\n\u2227 done[p1] \u2283 \u00ac done[p1]\u2019 \u2227 done[x]\u2019 \u2227 state[x]\u2019=exited\n\u2227 done[p2] \u2283 \u00ac done[p2]\u2019 \u2227 done[x]\u2019 \u2227 state[x]\u2019=exited\nTransition X is executed twice:\n1. when start[x] is true. The transition in this case has the following effects: (1) disabling triggering condition\nstart[x], (2) setting the state of x to running and (3) triggering either p1 or p2 depending on the condition \u03bb.\n2. when either done[p1] or done[p1] is true (either p1 or p2 was executed)). The transition in this case has the\nfollowing effects: (1) disabling the termination signal for p1 or p2, (2) enabling the termination signal of x and (3)\nsetting the state variable of x to exited.\nFrom StPowla Processes to SRML Models 11\n(a) Strict preference (b) Random choice\nFig. 6. Strict preference and random choice in STPOWLA\n4.3. Split and Complex Join (AND)\nThe split and complex join construct FJ(m, {P1,B1}, . . . , {Pn,Bn}) consists of the combination of the flow split,\nthat splits the control flow over many branches, and the conditional merge, that synchronizes two or more flows\ninto one. The value of m, that is statically determined, represents the minimum number of branches that have to be\nsynchronized. Furthermore, any branch is associated to a boolean Bi that determines whether the i \u2212 th branch is\nmandatory in the synchronization. The graphical notation of the construct is illustrated in Fig. 5(b).\nThe encoding is as follows. Let S be the set, with cardinality n, of the task indexes associated to the branches of the\nsplit\/join. Let the identifiers for the subtasks of x to range over p1, . . . , pn. LetN be the set of indexes of the necessary\ntasks and m \u2208 N be the minimum number of branches that have to be synchronized. We assume that m \u2264 |N |. The\ncomplex join is encoded in the following SRML transition, where Kcomb is the set of (m\u2212|N |)\u2212subsets of S \\N .\ntransition X\ntriggeredBy start[x] \u2228 (\u2227i\u2208Ndone[pi]\u2227(\u2228K\u2208Kcomb(\u2227k\u2208Kdone[pj])))\nguardedBy \u00ac policy[x]\neffects\nstart[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]\u2019=running \u2227i\u2208[1,...,n] start[pi]\u2019\n\u2227 \u00ac start[x] \u2283 done[x]\u2019 \u2227 state[x]\u2019=exited \u2227i:[1..n](\u00ac done[pi]\u2019)\nThe transition above is parametric with respect to N and Kcomb in order to model the general case. In a real\nworkflow schedule the general construct would be instantiated (at design-time) and the parameters in the conjuc-\ntion\/disjunctions would disappear (e.g., if N = {1, 2} the term \u2227i\u2208Ndone[pi] becomes done[p1] \u2227 done[p2]. Transi-\ntion X is executed twice:\n1. when start[x] is true. The transition in this case has the following effects: (1) disabling the triggering condition\nstart[x], (2) setting the state of task x to running and (3) enabling the triggering condition for each sub-task i by\nsetting start[i] to true.\n2. in case of successful termination of all the necessary subtasks (i.e., \u2227i\u2208Ndone[pi]) and of a number of tasks greater\nor equal to m (i.e., \u2228K\u2208Kcomb(\u2227k\u2208Kdone[pj])). The transition in this case has the following effects: (1) enabling\nthe termination signal for x, (2) setting the state of x to exited and (3) disabling the successful termination of all\nthe subtasks.\n4.4. Strict Preference\nThe strict preference SP (P1, . . . , Pn), illustrated in Figure 6(a), attempts the tasks P1, . . . , Pn one by one, in a specific\norder, until one completes successfully. In this case, with no loss of generality we consider the tasks ordered by\nincreasing index numbers.\nThe strict preference is encoded in the following SRML transition:\ntransition X\ntriggeredBy start[x] \u2228i:[1..n](done[pi] \u2228 failed[pi])\nguardedBy \u00ac policy[x]\neffects\nstart[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]\u2019=running \u2227 start[p1]\u2019\n\u2227i:[1..n\u22121]failed[pi] \u2283 \u00ac failed[pi]\u2019 \u2227 start[p(i+1)]\u2019\n\u2227 failed[pn] \u2283 \u00ac failed[pn]\u2019 \u2227 failed[x]\u2019 \u2227 state[x]\u2019=exited\n\u2227 \u2228i:[1..n]done[pi] \u2283 done[x]\u2019 \u2227 state[x]\u2019=exited \u2227i:[1..n]\u00ac done[pi]\u2019\n12 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nTransition X is executed a number of times in the following cases:\n1. when the task x is triggered. The transition in this case has the following effects: (1) disabling the triggering\ncondition start[x], (2) setting the state of x to running and (3) triggering the first sub-task p1 of x.\n2. when either any of the tasks pi terminates with failure (failed[pi] = true) or success (done[pi] = true).\n\u2022 If the task failed (i.e., failed[pi] = true) and it was not the last task pn, then the transition has the following\neffects: (1) disabling the termination variable of pi and (2) enabling the next task by setting start[p(i+ 1)] to\ntrue.\n\u2022 If the last task failed (failed[pn] = true) then the transition has the following effects: (1) disabling the signal\nof failed termination of pn, (2) enabling the signal failed[x] of failed termination for x and (3) setting the state\nof x to exited.\n\u2022 If any of the sub-tasks terminated successfully (done[pi] = true) then the transition has the following effects:\n(1) enabling the signal of successful termination for x, (2) setting the state of x to exited and (3) disabling the\nsuccessful terminations of all the sub-tasks.\n4.5. Random Choice\nThe random choice RC(P1, . . . , Pn), illustrated in Figure 6(b), attempts the tasks P1, . . . , Pn simultaneously and\ncompletes when one completes successfully. The random choice is encoded in the following SRML transition:\ntransition X\ntriggeredBy start[x] \u2228i:[1..n](done[pi])\u2228 (\u2227i:[1..n](failed[pi]))\nguardedBy \u00ac policy[x]\neffects\nstart[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]=running \u2227i:[1..n]start[pi]\u2019\n\u2227 (\u2227i:[1..n]failed[pi])\u2283 failed[x]\u2019\u2227 state[x]\u2019=exited \u2227i:[1..n]\u00ac failed[pi]\u2019\n\u2227 (\u2228i:[1..n]done[pi]) \u2283 done[x]\u2019 \u2227 state[x]\u2019=exited\n\u2227i:[1..n](\u00ac done[pi]\u2019 \u2227 \u00ac failed[pi]\u2019)\nTransition X is executed a number of times, in the following cases:\n1. when the task x is triggered. The transition in this case has the following effects: (1) disabling the triggering\ncondition start[x], (2) setting the state variable of x to running and (3) enabling the triggering condition of all\nthe sub-tasks.\n2. when any of the tasks pi terminates with success (i.e., done[pi] = true). The transition in this case has the\nfollowing effects: (1) enabling the successful termination of x, (2) setting the state of x to exited and (3) disabling\nthe successful and faulty terminations for all the sub-processes.\n3. when all the sub-tasks pi terminates with failure (i.e., failed[pi] = true). The transition in this case has the\nfollowing effects: (1) enabling the faulty termination of x, (2) setting the state of x to exited and (3) disabling the\nfaulty terminations for all the sub-processes.\n4.6. Scope\nThe scope construct Scope(P ), where P is associated to the task identifier y behaves similarly to the root process. It is\nillustrated in Figure 7. Within larger business processes it often makes sense to group parts of the process together as\nthese are controlled by one division in the company or the tasks are more intrinsically linked together. We represented\nscopes separately, even though at the moment little is done with them. The scope construct will in the future be\nextended to include notions of compensation and fault handling (that is they will form a way to express long running\ntransactions), however this aspect is beyond the scope of this paper. An idea is to support the mechanism of fault\nhandling by taking into account the semantics given in [BLZ03] through an extension of the asynchronous pi\u2212 calculus.\nThe intuition is to associated at design time a scope with two process: a compensation process and a fault handler.\nThe compensation process can be triggered only after the successful completion of the activity of the scope, in order\nto compensate the effects of the scope. The failure handler is triggered in case of failure during the execution of the\nscope and include (among other activities that depend on the specific process that is being modelled) the triggering of\nthe compensations of all the scopes, enclosed in the failing scope, that have already terminated successfully.\nFrom StPowla Processes to SRML Models 13\nFig. 7. The scope control construct in STPOWLA\nThe Scope choice is encoded in the following SRML transition:\ntransition X\ntriggeredBy start[x] \u2228 done[y]\nguardedBy \u00ac policy[x]\neffects\nstart[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]\u2019=running \u2227 start[y]\u2019\n\u2227 done[y] \u2283 \u00ac done[y]\u2019 \u2227 done[x]\u2019 \u2227 state[x]\u2019=exited\nTransition X is executed twice:\n1. when the triggering condition start[x] is enabled. The transition in this case has the following effects: (1) disabling\nthe triggering condition start[x], (2) setting the state of task x to running and (3) enabling the triggering condition\nfor the sub-task y.\n2. when y terminates with success (i.e., done[y] = true). The transition in this case has the following effects: (1)\ndisabling the successful termination of y, (2) enabling the signal of successful termination for x and (3) setting the\nstate of x to exited.\n5. Encoding StPowla Policies in SRML\n5.1. Refinement Policies\nRecall that in STPOWLA refinement policies are those requesting the req(action, [args], [SLR]) as action.\nThe element that requires encoding in SRML is the Service Level Requirements list. This list contains expressions\nthat specify acceptable values for a domain specific attribute: e.g. [cup temperature = warm] which specifies\nthat the chosen service (here a beverage service) should offer warm cups.\nIn SRML we have seen that the EXTERNAL POLICY element allows to express such issues. The expression\nlanguage in SRML is much more powerful than what STPOWLA offers currently: in SRML complex behaviour such\nas that seen in the example in Section 3.3 can be expressed. The example did show a case where complete satisfaction\nwas achieved by a delivery distance of less than 50 miles, and otherwise satisfaction did decrease in line with distance.\nIn STPOWLA currently only simpler relations such as less, equal or more can be expressed but there will be ongoing\nwork in enhancing the mechanisms in STPOWLA.\nIn general the mapping from STPOWLA to SRML involves creating an external policy for SLRs where for\neach STPOWLA attribute an SLAVARIABLE is created in SRML. The relation and values are then captured as a\nCONSTRAINT in the SRML policy rule.\nLet us consider, for example, the following STPOWLA policy for the procurement service (see workflow in Fig-\nure 2):\nCheapService\nappliesTo processOrder\nwhen on_task_entry\nreq(mail,[],[ServiceCost<10])\nThe policy CheapService ensures that the cost of the transaction with the service for processing the order is\nless then 10\u00a3. In SRML, we can express CheapService as a constraint that applies to the requires-interface OP of\n14 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nthe module ProcurementService (see Figure 3). Since STPOWLA, at the moment, only allows to express sharp\nrequirements, we use a constraint system where the degree of satisfaction has boolean values (i.e. {0, 1}).\nEXTERNAL POLICY\nSLA VARIABLES\nOP.SERVICECOST\nCONSTRAINTS\nCheapService is <{OP.SERVICECOST},def1> s.t.\nif n<10 then def1(n)=1,\notherwise def1(n)=0\nThe constraint uses the SLA variable OP.SERVICECOST (i.e., the price for enacting a transaction with the order\nprocessor), which assign degree of satisfaction of 1 if the service costs less then 10\u00a3 and degree of satisfaction of\n0 otherwise. The constraint ensures that any service which does not ensure a degree of satisfaction of 1 will not be\nselected.\n5.2. Reconfiguration Policies\nOne of the aims of this paper is to illustrate how policies can influence the control flow and how this can be modelled\nin SRML. In this section we discuss the encoding of policies, as described in STPOWLA, into SRML orchestrations.\nEach interaction is handled, in the orchestration of BP, by one or more transitions that model the policy handler. We\nwill see in detail such transitions when discussing the single interactions, in the rest of this section.\nA policy related to a task can have an effect (1) on the state prior to the task execution (i.e. delete, block and\ninsert) or (2) during the execution of a task (i.e. fail and abort). The state of a task is notified through the variable\nstate[y]. The policy handler must check that the task is in the correct state according to the specific policy that has\nto be enacted. The policy handler prevents the execution of either (1) the task or (2) the rest of the task by using the\nvariable policy[x]: the condition \u00acpolicy[x] guards the transition(s) corresponding to the execution of task. Notice\nthat for most of the control constructs it is not possible to trigger policies of this second type on atomic tasks whose\nstate changed directly from toStart to done.\n5.2.1. Delete Task\nThe deletion of task (i.e. delete(x) in STPOWLA) skips the execution of x. The policy manager prevents the execution\nof x by signaling a policy exception (i.e. policy[x] = true).\ntransition policyHandler_delete_1\ntriggeredBy delete[i]\u05a0 \nguardedBy state[delete[i]\u05a0 .task] = toStart\neffects policy[delete[i]\u05a0 .task]\u2019\nTransition policyHandler delete 1 is triggered by the event delete[i]\u05a0  , sent by PI. The guard ensures that a task\ncan be deleted only if its execution has not started yet (i.e., its state has value toStart). The transition has the effect\nof setting the value of the variable policy to true. This will prevent the regular execution of the deleted task (recall\nthat the execution of each task x is guarded by the condition \u00acpolicy[x]). When the triggering condition for task x\nbecomes true, the transition policyHandler delete 2 is executed instead of the transition of the deleted task.\ntransition policyHandler_delete_2\ntriggeredBy start[x]\nguardedBy P_delete[i]\u05a0 ? \u2227 delete[i]\u05a0 .task=x\neffects \u00ac start[x]\u2019 \u2227 done[x]\u2019 \u2227 state[x]\u2019 = done\nsends delete[i]\u0001 \nThe guard of policyHandler delete 2 ensures its execution only if a deletion policy has been triggered for x.\nThe effects of the transition are: (1) to disable the triggering condition of x, (2) to notify the correct termination of x\n(which in fact has not been executed) and (3) to set the state of x to done. The transition also sends the reply event to\nthe interaction delete to notify PI of the completed enactment of the reconfiguration policy.\nFrom StPowla Processes to SRML Models 15\n5.2.2. Block Task\nThe function block(x, p) in STPOWLA blocks a task until p is true. In SRML the policy handler prevents x from\nexecuting (i.e. policy[x] becomes true) temporary until p is true. The policy handler notifies the enactment of the\npolicy to the environment after that the task has been unblocked.\ntransition policyHandler_block_1\ntriggeredBy block[i]\u05a0 \nguardedBy state[block[i]\u05a0 .task] = toStart\neffects policy[block[i]\u05a0 .task]\u2019\nTransition policyHandler block 1 is triggered by the event block[i]\u05a0  , sent by PI. The guard ensures that a task\ncan be deleted only if its execution has not started yet (i.e., its state has value toStart). The transition has the effect\nof setting the value of the variable policy to true. This will prevent the regular execution of the blocked task. When\nthe condition specified through condition p, which has been communicated by PI, becomes true then the transition\npolicyHandler block 2 unblocks the task.\ntransition policyHandler_block_2\ntriggeredBy block[i]\u05a0 .condition\nguardedBy P_block[i]\u05a0 \neffects \u00ac policy[block[i]\u05a0 .task]\u2019\nsends block[i]\u0001 \nTransition policyHandler block 2 is triggered by the condition block[i]\u05a0  .condition and the guard ensures its\nexecution only the task has previously been blocked. The transition has the effect of setting the variable policy for the\ntask to which the policy applied to false so that the task can be executed as soon as its triggering condition becomes\ntrue. The transition also sends the reply event to the interaction block to notify PI of the completed enactment of the\nreconfiguration policy.\n5.2.3. Insert\nThe insertion of a task, represented by the function insert(x, y, z) in STPOWLA, inserts the task y in sequence or\nin parallel with respect to x depending by the value of the boolean variable z. In SRML the insertion is triggered\nby the interaction insert[i]\u0001 with parameter insert[i]\u0001 .task representing the task x, insert[i]\u0001 .insertedTask\nrepresenting the task y and insert[i]\u0001 .condition representing the condition z. We assume that the set of tasks that it\nis possible to insert is determined a priori, in this way we assume that the SRML encoding has a set of transitions for\neach possible task, including the task to possibly insert, that is executed by setting start[y] to true. We introduce in\nthis way a limitation on the number of task types that we can insert and on the fact that a task can be inserted only once\n(we will manage multiple insertions in the future, when we will encode looping constructs) but we do not provide any\nlimitation on the position of the insertion.\nWe rely on a function next : taskId\u2192 taskId that returns, given a task, the next task to execute in the workflow.\nSuch function can be defined by induction on the syntax of STPOWLA defined in Section 2.1.\ntransition policyHandler_insert_1\ntriggeredBy insert[i]\u05a0 \nguardedBy state[insert[i]\u05a0 .task]=toStart\neffects policy[insert[i]\u05a0 .task]\u2019\nThe transition policyHandler insert 1 prevents the execution of the task on which the policy applies (i.e.,\ninsert[i]\u0001 .task) by setting the its policy variable to true. When the task on which the policy applies is triggered,\npolicyHandler insert 2 is executed instead of the regular transition for the task.\ntransition policyHandler_insert_2\ntriggeredBy start[x]\nguardedBy P_insert[i]\u05a0 \u2227 insert[i]\u05a0 .task=x\neffects\ninsert[i]\u05a0 .condition \u2283 \u00ac policy[insert[i]\u05a0 .task]\u2019\n\u2227 \u00ac insert[i]\u05a0 .condition \u2283 policy[insert[i]\u05a0 .task]\u2019\n\u2227 start[insert[i]\u05a0 .insertedTask]\u2019\n16 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nThe transition policyHandler insert 2 starts the execution of the task on which the policy applies (in paral-\nlel with the inserted task if insert[i]\u0001 .condition = true). The transitions policyHandler insert sequence and\npolicyHandler insert parallel coordinate the execution of the tasks (the one on which the policy applies and the\ninserted one) in sequence or in parallel, according to the condition.\ntransition policyHandler_insert_sequence\ntriggeredBy done[x] \u2228 done[y]\nguardedBy P_insert[i]\u05a0 \u2227 insert[i]\u05a0 .condition\n\u2227 (insert[i]\u05a0 .task=x \u2228 insert[i]\u05a0 .insertedTask=y)\neffects\ndone[x] \u2283 \u00ac done[x]\u2019 \u2227 start[y]\u2019\n\u2227 done[y] \u2283 \u00ac done[y]\u2019 \u2227 start[next(x)]\u2019\nsends\ndone[y] \u2283 insert[i]\u0001 \ntransition policyHandler_insert_parallel\ntriggeredBy done[x] \u2227 done[y]\nguardedBy P_insert[i]\u05a0 ? \u2227 \u00ac insert[i]\u05a0 .condition\n\u2227 insert[i]\u05a0 .task=x \u2227 insert[i]\u05a0 .insertedTask=y\neffects \u00ac done[x]\u2019 \u2227 \u00ac done[y]\u2019 \u2227 start[next(block[i]\u05a0 .task)]\u2019\nsends insert[i]\u0001 \nTransitions policyHandler insert sequence and policyHandler insert parallel are similar to regular sequence\nand paralel transitions (see Section 4.6), but they are guarded by the fact that an insertion policy with positive\/negative\ncondition has been triggered in the past. The effects are similar to those of a regular sequence\/parallel transitions. A\nreply event for the interaction insert is sent to notify PI of the completed enactment of the reconfiguration policy\nwhen, in the case of policyHandler insert sequence transition the inserted task terminates (i.e., done[y] \u2283= true)\nand in the case of policyHandler insert parallel both of the parallel tasks terminate.\n5.2.4. Fail Task\nThe failure of a task must occur during the execution of the task (it has no effects otherwise). The failure can be\ntriggered autonomously, within the task or induced externally by the execution of the policy fail. We consider here\nthe second case.\ntransition policyHandler_fail\ntriggeredBy fail[i]\u05a0 \nguardedBy state[fail[i]\u05a0 .task]=running\neffects policy[i][fail[i]\u05a0 .task]\u2019 \u2227 state[fail[i]\u05a0 .task]\u2019=failed\nsends fail[i]\u0001 \nTransitions policyHandler fail is triggered by the event fail[i]\u05a0  , sent by PI. The guard ensures that a task can\nfail only if it is currently in execution (i.e., its state has value running). The transition has the effect of setting the\nvalue of the variable policy to true and the state of the task to failed (so that the normal flow of execution blocks). A\nreply event for the interaction fail is sent to notify PI of the completed enactment of the reconfiguration policy.\n5.2.5. Abort Task\nThe abortion of a task is similar to a deletion, but it involves a running task. An abort of a task occurring not during its\nexecution has no effects.\ntransition policyHandler_abort\ntriggeredBy abort[i]\u05a0 \nguardedBy state[abort[i]\u05a0 .task]=running\neffects policy[abort\u05a0 .task]\u2019 \u2227 state[abort[i]\u05a0 .task]\u2019=done\nsends abort[i]\u0001 \nTransitions policyHandler abort is triggered by the event abort[i]\u05a0  , sent by PI. The guard ensures that a task\ncan fail only if it is currently in execution (i.e., its state has value running). The transition has the effect of setting\nFrom StPowla Processes to SRML Models 17\nthe value of the variable policy to true and the state of the task to done (so that the flow of execution can continue\nnormally). A reply event for the interaction fail is sent to notify PI of the completed enactment of the reconfiguration\npolicy.\n5.3. An Example: the Reconfiguration of the Procurement Scenario\nThe orchestration of the business role BusinessProtocol would consist of the sequence of the tasks request order (i.e.\ntask ro) and process order (i.e. task po).\ntransition X\ntriggeredBy start[x] \u2228 done[ro] \u2228 done[po]\nguardedBy policy[x]\neffects\nstart[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]\u2019=running \u2227 start[ro]\u2019\n\u2227 done[ro] \u2283 \u00ac done[ro]\u2019 \u2227 start[po]\u2019\n\u2227 done[po] \u2283 \u00ac done[po]\u2019 \u2227 done[x]\u2019 \u2227 state[x]\u2019=exited\nIn case of a receive event of type insert[i]\u0001 , triggered by the component PI , with parameter task equal to po, pa-\nrameter insertedTask equal to gbd (i.e. get deposit), and the parameter condition equal to true. The policy handler\nwould: (1) block the execution of ro (preventing in this way ro to trigger its continuation po = next(ro)) by setting\npolicy[ro] = policy[po] = true, (2) wait for the condition start[ro] = true that is triggered by transitionX , (3) since\nthe parameter condition is true, the policy handler would unblock ro, (4) the transition policyHandler insert sequence\nwould handle the execution of gd after ro and, finally, trigger po by setting start[po] = true.\n6. Methodology by Example \u2013 a case study of using StPowla and SRML\nIn this section we present a methodology for developing services, which involves STPOWLA and SRML. The discus-\nsion on the methodology illustrates the rationale of the work presented in this paper by discussing the benefits of a\njoint usage of SRML, STPOWLA and the encoding.\nSome of the methodological aspects concerning SRML have been discussed in previous work [BLF08], which\nproposes a process to arrive at (formal) service models in SRML starting from informal (or semi-formal) specifications\nin notations that are typically described in UML. In Section 6.1 we use the extension of UML use-case diagrams\npresented in [BLF08] to capture requirements in a service-oriented scenario and derive the structure of SRML models.\nFrom the use-case diagram we can determine the services and resources our application relies on. The definition of\nthe internal structure of the SRML module (i.e. the components and wires that define the internal workflow) depends\nin general on the portfolio of components already available for reuse within the business organisation. The definition\nof a complex internal structure from scratch, deriving from the decomposition of the orchestration in a number of\ncoordinated units, can be done, in general, using traditional techniques for Component Based Development.\nSRML offers primitives based on events that allow to suitably model those scenarios where process-based mod-\nelling could result in over-specification. However, the primitives of SRML are general enough to support process based\nmodelling. For example, [BHLF07] presents an encoding from the process-base style of modelling of WS-BPEL to\nSRML. Another example is the encoding presented in this paper where STPOWLA provides SRML with a means\nto define, at a higher level of abstraction, a process-based behaviour (i.e. workflow schedule) which is dynamically\nreconfigured by policies.\nIn Section 6.1 we use STPOWLA to model the internal behaviour of the SRML module. The workflows shown\nin this section use the same workflow notation that we have used earlier and are complete in that notation. To ease\nreadability we have added \u201cswimlanes\u201d to highlight the stake holders as often seen in UML Activity diagrams, but\nnote that these are not used in the translation. By using the encoding we derive the internal structure of the SRML\nmodule and the SRML specifications for each component to model the business process. As described in Section 3,\nthe resulting internal structure of the SRML module consists of one main component BP that models the behaviour of\nthe workflow, and the policy handler PI which handles the reconfiguration policies.\nThe methodology presented through the example involves three different languages that suit the needs of different\nstages of the modelling process:\nRequirements UML Use Case diagrams are used to capture the requirements of the service-oriented application that\n18 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nVoIP Procurement\nCustomer\nOrderManagement\nTest\nLegal\nFig. 8. VoIP Case Study use-case diagram\nhas to be developed. The application may involve a number of related services (i.e., they may share resources and\nare modelled as a single business unit). The usage of UML Use Case diagrams provides a human friendly notation\nsuitable in this phase which involves the intervention of non experts in the engineering process (e.g., members\nof the business company commissioning the development of the application). The outcome of this phase is a Use\nCase diagram. By using the mapping defined in [BLF08] it is possible to derive, from the diagram, the structure for\na number of SRML modules where the orchestration and the behavoural specification of the external interfaces is\nleft unspecified. An Eclipse plugin is currently under development to automate this transformation.\nBusiness Modelling StPowla is used to perform the modelling, at the business level, of the orchestration in terms of\nworkflow schedule and reconfiguration policies. This phase can be performed by experts in business modelling\nwho can benefit by the level of abstraction provided by StPowla (i.e., modular definition of control-based process\nand business policies). The outcome of this phase is a StPowla model of the business process that, by using the\nencoding to SRML, can provide each of the SRML module structures resulting from the previous phase with an\nthe internal orchestration.\nService-Oriented Modelling The SRML modules obtained in the previous phase can be extended to include the\nbehavioural specifications for the external interfaces, modified to include other components in the internal structure\n(for example component extracted from implementations in BPEL [BHLF07] or any other language for which an\nencoding into SRML has been provided), and analyzed with the formal framework provided by SRML.\n6.1. Use Case Driven Example\nIn this section, we present a case study supplied by an industrial partner of the SENSORIA project. The case study is\nbased on a Voice over IP (VoIP) procurement example between a customer and a reseller. If viewed at a higher level,\nit can represent most, if not all, procurement examples.\nThe requirements are expressed in Figure 8. Figure 8 uses the notation for use-case diagrams proposed in [BLF08].\nThe customized icons represent different types of roles that an actor can have in a service-oriented context (e.g.,\ndynamically discovered services, statically bound persistent resources, service requester, etc.).\nThe diagram models a service, provided to a service requester represented by the actor Customer, which manages\nthe order for a VoIP connection. The service relies on the persistent resource Legal, which is shared among the different\ninstances of the service, and the external service Test which is dynamically discovered and selected according to the\ncustomer\u2019s location.\nAs mentioned in Section 3, SRML distinguish among the different types of actors by representing nodes at dif-\nferent layers. The SRML module derived by the diagram in Figure 8 is illustrated in Figure 9. The module has one\nprovides-interface CU of type Customer, one bottom-layer interface LE of type Legal and one requires-interface TE\nof type Test. The internal structure of the module is defined according to Section 3: the component BP of type Busi-\nnessProcess defines the base workflows for orchestrating the service, the component PI of type PolicyInterface\nhandles the reconfiguration requests.\nFrom StPowla Processes to SRML Models 19\nORDERMANAGEMENT\nBP:\nBusinessProcess\nintBP\nSLA\nTE:\nTest\nintTE\nBT     CR:    Customer\nLE:\nLegal\nCB\nBL\nPI:\nPolicyInterface\nPB\nintPI\nFig. 9. VoIP Case Study SRML module.\nThe workflow implemented by BP is modelled with STPOWLA as follows. The STPOWLA base workflow is shown\nin Figure 10. In addition to the workflow specification, we attach a workflow ontology as follows:\nSTPOWLAWorkflow is\nInvariants:\nLowBusinessValueThreshold: int\nLowOrderValueThreshold: int\nActors:\nLegal: Actor\nTest: Actor\nOrderManagement: Actor\nCustomer: Actor\nScopes:\ns1: [PerformServiceTest, ..., ResultsAcceptance]\ns2: [RequestLegalAssistance, ..., SendSLA]\nVariables:\nCustomer.orderValue: int\nCustomer.businessValue :int\nWhat is important to note is that there are two workflow invariants LowBusinessValueThreshold and\nLowOrderValueThreshold, which refer to the level of spend from a customer for which to be regarded as a\nsmall customer and the upper value of an order which would be considered as small, respectively. Furthermore, on\ninvocation of the workflow, two variables attached to the Customer actor specifying the customer\u2019s spend in the last\nyear and the value of the current order.\nThe following policies should be activated on the workflow:\nTelcoPolicy1\nwhen workflow.started\nif customer.businessValue < LowBusinessValueThreshold\nand\ncustomer.orderValue < LowOrderValueThreshold\ndo delete(s1)\nTelcoPolicy2\nwhen workflow.started\nif Customer.orderValue < LowOrderValueThreshold\ndo delete(s3)\nandthen\ninsert(PrepareFinalSLA,...,...)\nandthen\ninsert(CreateAContract, ..., ...)\nThe first policy TelcoPolicy1 states that on commencing the workflow, if the customer could be considered small\n20 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nVoIP Activation \u2013 3: Pre-Delivery (Base Workflow)\nPerform \nService Test\nSend Test \nResult\nReceive Test \nResult\nResults \nAcceptance\nService \nTesting\nReject Test \nResults\nAccept Test \nResults\ns1\nCustomer Test LegalOrder Management\nIdentify Offer \nProposal\nRequest Legal \nAssistance\nPrepare \nFinal SLA\nCreate a \nContract\nReceive \nRequest\nPrepare \nFinal SLA\nSend SLA\ns2\ns3\nFig. 10. VoIP Case Study base workflow.\nVoIP Activation \u2013 3: Pre-Delivery (Base Workflow)\nIdentify Offer \nProposal\nRequest Legal \nAssistance\nPrepare \nFinal SLA\nReceive \nRequest\ns2\ns3\nCustomer Test LegalOrder Management\nCreate a \nContract\nPrepare \nFinal SLA\nSend SLA\nPolicy: No test for small customers and orders of small entity\nFig. 11. VoIP Case Study base workflow.\nand the order value was also small, the order management system should forgo the testing process. If this were applied,\nthe reconfigured workflow instance would be as in Figure 11.\nThe second policy TelcoPolicy2 states that on commencing the workflow, if the order value could be considered\nsmall, then the order management system should not invoke legal assistance. Noting the trigger position of the policy\nand the initial area of effect, the trigger could also have been IdentifyOfferProposal.task started or\nIdentifyOfferProposal.task completed. The choice of which trigger to use is down to the author and this\nFrom StPowla Processes to SRML Models 21\nVoIP Activation \u2013 3: Pre-Delivery (Base Workflow)\nPerform \nService Test\nSend Test \nResult\nReceive Test \nResult\nResults \nAcceptance\nService \nTesting\nReject Test \nResults\nAccept Test \nResults\ns1\nCustomer Test LegalOrder Management\nIdentify Offer \nProposal\nPrepare \nFinal SLA\nCreate a \nContract\ns2\nPolicy: Avoid legal assistance for small orders\nFig. 12. VoIP Case Study base workflow.\ncan have a significant effect depending on the existence of other policies. The policy TelcoPolicy2, which eliminates\nthe branch at the bottom of the split\/join, is implemented by deleting the whole scope s3 and reinserting the upper\nbranch (this is required as just deleting the tasks along the lower branch will leave the operatoes in place and would\nprovide a direct path bypassing the task that we do want to enforce).\nFor example, if the trigger of the second policy were bound to an event from a task in scope s1, it is possible that\nthe scope would be deleted and the policy never initiated. Whereas instead the required functionality was to initiate\nthe policy regardless.\nIf the customer could firstly be identified as a small customer and also the order value is below the low order\nthreshold, it is clear that both policies would be applied. The resulting workflow is shown in Figure 13.\nAccording to the encoding, the process triggered by the root transition (see Section 4) is represented in SRML by\nthe transition x which executes in sequence the scope s1 and then the scope s2 .\ntransition X\ntriggeredBy start[x] \u2228 done[s1] \u2228 done[s2]\nguardedBy \u00ac policy[x]\neffects start[x] \u2283 \u00ac start[x]\u2019 \u2227 state[x]\u2019=running \u2227 start[s1]\u2019\n\u2227 done[s1] \u2283 \u00ac done[s1]\u2019 \u2227 start[s2]\u2019\n\u2227 done[s2] \u2283 \u00ac done[s2]\u2019 \u2227 done[x]\u2019 \u2227 state[x]\u2019=exited\nTransition X is executed when the sequence task is triggered and when any of the two sub-tasks of the sequence\nterminate. The guard ensures that no policies have been triggered for x. In the first execution, the state of x is set\nto running and the first task s1 in the sequence is triggered. In the second execution of the transition s1 completed\nsuccessfully and the second task s2 in the sequence is triggered. In the third execution of the transition s2 completed\nsuccessfully and the sequence task x terminates successfully.\nFragments of the transitions s1 and s2, which illustrate triggers and guards, are reported below. The variables y\nand z represent the root process started within each scope.\ntransition scope1\ntriggeredBy start[s1] \u2228 done[y]\nguardedBy \u00ac policy[s1]\n...\ntransition scope2\n22 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nVoIP Activation \u2013 3: Pre-Delivery (Base Workflow)\nIdentify Offer \nProposal\nPrepare \nFinal SLA\nCreate a \nContract\ns2\nCustomer Test LegalOrder Management\nFig. 13. VoIP Case Study base workflow.\ntriggeredBy start[s2] \u2228 done[z]\nguardedBy \u00ac policy[s2]\n...\nThe business roleBusinessProcess provides transitions to handle the reconfiguration for each sub-process. When\nthe customer creates a new instance of the serviceOrderManagment, the SLA variables concerning the business value\nof the customer and the order value are set. Depending on those values, PI will either request to apply TelcoPolicy1\nand TelcoPolicy2, or not. In order to apply TelcoPolicy1, for instance, PI sends an event delete[s1]\u05a0  ! to BP.\nThe transitions deleteScope1 1 and deleteScope1 2, defined as described in Section 5, handle the request of the\ncomponent PI to delete the scope s1 (i.e., TelcoPolicy1).\ntransition deleteScope1_1\ntriggeredBy delete[s1]\u05a0 \nguardedBy state[delete[s1]\u05a0 .task] = toStart\neffects policy[delete[s1]\u05a0 .task]\u2019\ntransition deleteScope1_2\ntriggeredBy start[s1]\nguardedBy P_delete[s1]\u05a0 \u2227 delete[s1]\u05a0 .task=s1\neffects \u00ac start[s1]\u2019 \u2227 done[s1]\u2019 \u2227 state[s1]\u2019 = done\nsends delete[s1]\u0001 \nThe transition deleteScope1 1 is triggered by the deletion request, only if scope s1 has not started its execution\nyet, and sets the variable policy[delete[s1]\u05a0  .task to true. When the transition x sets start[s1] = true, the trantision\ns1 can not be triggered because of the false guard. The transition deleteScope1 2 is triggered instead. The effects of\ndeleteScope1 2 are to set the variables for s1 as if the scope had been successfully executed (but in fact it has not\nbeen executed at all), and to notify PI of the deletion through the interaction delete[s1]\u0001 !. The following transition\nto be executed is, again, x which triggers the next process in the sequence (i.e., s2).\nFrom StPowla Processes to SRML Models 23\n7. Related Work\nSRML is inspired by the Service Component Architecture (SCA) [MHD+05]. SCA is a set of specifications, proposed\nby an industrial consortium, that describe a middleware-independent model for building over SOAs. Similarly to\nSCA, SRML provides primitives for modelling, in a technology agnostic way, business processes as assemblies of\n(1) tightly coupled components that may be implemented using different technologies (including wrapped-up legacy\nsystems, BPEL, Java, etc.) and (2) loosely coupled, dynamically discovered services. Differently from SRML, SCA\nis not a modelling language but a framework for modelling the structure of a service-oriented software artifact and\nfor its deployment. SCA abstracts from the business logic provided by components in the sense that it does not\nprovide a means to model the behavioural aspects of services. SRML is, instead, a modelling language that relies on a\nmathematical framework and that provides the primitives to specify such behavioural aspects.\nA (formal) model of services based on Component Based Development (CBD) can be found in [BKM07]. There,\nservices are seen as \u201ccrosscutting elements of the system under consideration\u201d, describing \u201cpartial views on the set of\ncomponents in the system under consideration\u201d [BKM07]. SRML captures a different notion of SOC in that there is\nno \u201csystem under consideration\u201d, conceived a priori, that services crosscut. The configuration, consisting of a set of\ncomponents and connectors which together provide a certain functionality, can dynamically change to include other\ncomponents, procured according to given (functional) types and service level constraints from a universe that is not\nfixed a priori. The underlying middleware (SOA) supports the discovery and selection from a set of services that\nis itself dynamically changing as, for example, new services are published. SRML supports, in an integrated way,\nboth CBD and SOC-based service provision in terms of its layered architecture that separates the service-oriented\n(horizontal) layer from the component-based (vertical) one. In this way, SRML captures the positive aspects of SOC\n(i.e., the service-oriented layer provides extensibility and adaptability to change) without unnecessary overhead when\ndiscovery is not needed (i.e., for resources and components).\nThe declarative primitives of SRML capture a comprehensive view of the foundational aspects of services at a\nhigh level of abstraction. SRML provides a more domain-level support for service-oriented modelling with respect to\nformalisms based on Petri-Nets (e.g., [Rei05]) or process calculi(e.g., [LPT07, GLG+06, BBC+06]). For example,\nSRML abstracts on the actual process of discovery, selection, binding, reconfiguration and session management,\nwhereas COWS (Calculus for Orchestrating Web Services) [LPT07] addresses a lower level of abstraction in which\nthe dynamic aspects need to be explicitly modelled. SRML has been related to cows in [BFL+08a] to provide an\noperational semantics of SRMLto make explicit in COWS some of the run-time aspects that the denotational semantics\nfor SRML provided in [AF08, LFB07] abstracts from.\nProcess modelling at a business level is generally achieved using natural English or, more interestingly, structured\nlanguages such as the Business Process Modelling Notation (BPMN) [Whi04] or UML Activity Diagrams. BPMN\ndescribes process flows, with additional structure provided through the use of swimlanes. One particular advantage of\nBPMN is that it can be used to model a BPEL process, although it is still limited by its inability to express service\nselection criteria including non-functional service properties [OEtH05]. However, these notations do not cater for all\nworkflow patterns [vdAtHKB03], as described in [WvdAD+06] and [RvdAtHW06], respectively.\nYAWL [vdAtH05] caters for all workflow patterns and has a graphical syntax with formal semantics, based on Petri\nNets. At a lower business level, languages such as BPEL or WS-CDL are capable of expressing business processes,\nbut with a code-based approach that is not high level enough for the end user.\nProcess calculi and Petri nets offer a formal method in which to express workflows as processes. The formalisms\nprovide operational semantics allowing for reasoning about the process, e.g. [HB03] and [FBS02].\nAs we have previously mentioned, the syntax of the workflow language is not significant, but rather the places\nwhere a policy can interact. We have used the language of [GRM06c] for its simplicity, expressive power and our\nfamiliarity with it\nPolicies have generally been used as an administration technique in system management (e.g. access control [Mos05]\nor Internet Telephony [RM03]). Policies are descriptive and essentially provide information that is used to adapt\nthe behaviour of a system. Most work deals with declarative policies. Examples are the formalisms to define access\ncontrol policies, and to detect conflicts [SCZ03, HW03]; formalisms for modelling the more general notion for usage\ncontrol [ZPPSP05]; formalisms for SLA, i.e. to specify client requirements and service guarantees, and to sign a\ncontract with an agreement between them [BM07, BFMM07].\nRuleML is a language for rule-based and knowledge-based systems, and allows Web-based rule storage, retrieval\nand interchange [BTW01]. Like APPEL, it is XML-based and allows for the definition of ECA rules (note that for\nreadability we have not used APPEL\u2019s XML syntax in this paper).\n24 L. Bocchi and S. Gorton and S. Reiff-Marganiec\nWS-Policy [(ed06] seems the obvious candidate when considering policies in the context of Web Services; however\nWS-Policy addresses mostly aspects related to access control and encryption which are at a much more technical\nlevel then the business concepts that we consider in policies. It might be possible to extend WS-Policy with suitable\nconstructs and then compile the policies into this framework, which is an avenue worthwhile of future investigation.\nIn addition, a methodology has been proposed to extract workflows from business policies [Wan06]. However, we\nare not aware of policies being used as a variability factor in service-targeted processes.\nDynamic processes that are based on the end-user\u2019s needs are more difficult to find. Reichert and Dadam [RD98] and\nAdams et al [AtHEvdA06] introduce ideas for flexibility in workflows. The former discuss a framework for dynamic\nprocess change, but their approach does not include a flexible external system (like our policies) that can affect the\nworkflow in progress. The latter, presents Worklets, a system based on an extensible repertoire of sub processes aligned\nto each task, one of which is chosen at runtime.\nPossibly AgentWork [MGR04], where ECA rules can be used to drop or add individual tasks to workflows, is\nclosest to our initial discussions on linking policies with workflows [GRM06b, GRM06a]. However, there is no notion\nof tasks being linked to services in this work, and the policies are concerned with task replacement rather than task\nimplementation, service selection or the more significant workflow restructuring discussed here.\n8. Summary and Conclusion\nThe engineering of Service Oriented applications, as opposed to more traditional application development, is faced\nwith novel challenges arising from the dynamicity of component selection and assembly, leading to massively dis-\ntributed, interoperable and evolvable systems. Furthermore, a continuing challenge is to correctly align business goals\nwith IT strategy. As such, the development approach must change to accommodate these factors.\nIn this paper, we have presented SRML - a high level modelling language for service-based applications. SRML is\nbased on a formal framework and can model service compositions and configurations. The orchestration of the services\nis modelled by a central agent in each SRML module. However, the business process is less clear. The orchestration\naccording to the business process is defined by STPOWLA, an approach that combines workflows, policies and SOA.\nThe main contributions of this paper are 1) an encoding of basic STPOWLA workflow constructs in SRML, 2)\nan encoding of STPOWLA reconfiguration and refinement policies in SRML and (3) a methodology by example on a\nrealistic case study showing how the combination of STPOWLA and SRML can be used.\nThe benefits of this work are twofold. The mapping between SRML and STPOWLA creates a formal framework\nfor the latter (where it only previously had formal semantics for the APPEL policy language). Since applications are\noften designed based on the business process, STPOWLA can create process models easily, then transformed to SRML\nmodules such that they can be analysed alone or as part of more complex modules. Even further, BPEL processes can\nbe mapped to SRML modules for a clearer path between the defining the process and using the service. Looking at the\nencoding bottom-up, STPOWLA adds a higher level of modelling to SRML modules in the form of a process-oriented\nworkflow schedule, with system variability separated from the core business concerns, which is considered for the first\ntime here.\nReferences\n[ABFL07] Joa\u02dco Abreu, Laura Bocchi, Jose\u00b4 Luiz Fiadeiro, and Anto\u00b4nia Lopes. Specifying and composing interaction protocols for service-\noriented system modelling. In Formal Methods for Networked and Distributed Systems, volume 4574 of Lecture Notes in Computer\nScience, pages 358\u2013373. Springer Verlag, 2007.\n[AF08] Joa\u02dco Abreu and Jose\u00b4 Luiz Fiadeiro. A coordination model for service-oriented interactions. In In Proceedings of Coordination\nLanguages and Models, volume 5052 of Lecture Notes in Computer Science, pages 1\u201316. Springer Verlag, 2008.\n[AtHEvdA06] Michael Adams, Arthur H. M. ter Hofstede, David Edmond, and Wil M. P. van der Aalst. Worklets: A service-oriented implementa-\ntion of dynamic flexibility in workflows. In Robert Meersman and Zahir Tari, editors, OTM Conferences (1), volume 4275 of Lecture\nNotes in Computer Science, pages 291\u2013308. Springer, 2006.\n[BBC+06] Michele Boreale, Roberto Bruni, Lu\u0131\u00b4s Caires, Rocco De Nicola, Ivan Lanese, Michele Loreti, Francisco Martins, Ugo Montanari,\nAntonio Ravara, Davide Sangiorgi, Vasco Vasconcelos, and Gianluigi Zavattaro. SCC: a service centered calculus. In Web Services\nand Formal Methods, volume 4184 of Lecture Notes in Computer Science, pages 38\u201357. Springer, 2006.\n[BFL+08a] Laura Bocchi, Jose\u00b4 Luiz Fiadeiro, Alessandro Lapadula, Rosario Pugliese, and Francesco Tiezzi. From Architectural to Behavioural\nSpecification: An encoding of SRML into cows. Technical report, Dipartimento di Sistemi e Informatica, Universit a` di Firenze,\n2008. Available at http:\/\/rap.dsi.unifi.it\/cows\/ .\n[BFL08b] Laura Bocchi, Jose\u00b4 Luiz Fiadeiro, and Anto\u00b4nia Lopes. Service-Oriented Modelling of Automotive Systems. 32nd Annual IEEE\nInternational Computer Software and Applications Conference (COMPSAC), 0:1059\u20131064, 2008.\nFrom StPowla Processes to SRML Models 25\n[BFMM07] M.G. Buscemi, L. Ferrari, C. Moiso, and U. Montanari. Constraint-based policy negotiation and enforcement for telco services.\n2007.\n[BGR08] Laura Bocchi, Stephen Gorton, and Stephan Reiff-Marganiec. Engineering Service Oriented Applications: From StPowla Processes\nto SRML Models. In Jose\u00b4 Luiz Fiadeiro and Paola Inverardi, editors, Fundamental Approaches to Software Engineering, volume\n4961 of Lecture Notes in Computer Science, pages 163\u2013178. Springer Verlag, 2008.\n[BHLF07] Laura Bocchi, Yi Hong, Anto\u00b4nia Lopes, and Jose\u00b4 Luiz Fiadeiro. From BPEL to SRML: A Formal Transformational Approach. In\nM. Dumas and R. Heckel, editors, Web Services and Formal Methods, volume 4937 of Lecture Notes in Computer Science, pages\n92\u2013107. Springer Verlag, 2007.\n[BKM07] Manfred Broy, Ingolf H. Kru\u00a8ger, and Michael Meisinger. A formal model of services. ACM Trans. Softw. Eng. Methodol., 16(1):5,\n2007.\n[BLF08] Laura Bocchi, Anto\u00b4nia Lopes, and Jose\u00b4 Luiz Fiadeiro. A use-case driven approach to formal service-oriented modelling. In Interna-\ntional Symposium on Leveraging Applications of Formal Methods, Verification and Validation, Lecture Notes in Computer Science.\nSpringer Verlag, 2008. to appear.\n[BLZ03] Laura Bocchi, Cosimo Laneve, and Gianluigi Zavattaro. A calculus for long running transactions. In FMOODS 2003, Lecture Notes\nin Computer Science. Springer Verlag, 2003.\n[BM07] M.G. Buscemi and U. Montanari. Cc-pi: A constraint-based language for specifying service level agreements. pages 18\u201332, 2007.\n[BTW01] H. Boley, S. Tabet, and G. Wagner. Design rationale for ruleml: A markup language for semantic web rules. In I.F. Cruz, S. Decker,\nJ. Euzenat, and D.L. McGuinness, editors, SWWS, pages 381\u2013401, 2001.\n[DFS06] Schahram Dustdar, Jose\u00b4 Luiz Fiadeiro, and Amit P. Sheth, editors. Business Process Management, volume 4102 of Lecture Notes in\nComputer Science. Springer Verlag, 2006.\n[(ed06] J. Schlimmer (ed). Web services policy 1.2 \u2013 framework (WS-Policy). W3C, Apr 2006. http:\/\/www.w3.org\/Submission\/WS-Policy\/.\n[FBS02] X. Fu, T. Bultan, and J. Su. Formal verification of e-services and workflows. In C. Bussler, R. Hull, S. A. McIlraith, M. E. Orlowska,\nB. Pernici, and J. Yang, editors, WES, volume 2512 of LNCS, pages 188\u2013202, 2002.\n[FLB06] Jose\u00b4 Luiz Fiadeiro, Anto\u00b4nia Lopes, and Laura Bocchi. A Formal Approach to Service Component Architecture. Web Services and\nFormal Methods, 4184:193\u2013213, 2006.\n[GLG+06] Claudio Guidi, Roberto Lucchi, Roberto Gorrieri, Nadia Busi, and Gianluigi Zavattaro. SOCK: A calculus for service oriented\ncomputing. In Asit Dan and Winfried Lamersdorf, editors, International Confetence on Service Oriented Computing, volume 4294\nof Lecture Notes in Computer Science, pages 327\u2013338. Springer, 2006.\n[GM05] Stefania Gnesi and Franco Mazzanti. A model checking verification environment for uml statecharts. In AICA, Udine 2005, 5-7\nOctober 2005.\n[GMRMS07] Stephen Gorton, Carlo Montangero, Stephan Reiff-Marganiec, and Laura Semini. StPowla: SOA, Policies and Workflows. In\nProceedings of 3rd International Workshop on Engineering Service-Oriented Applications: Analysis, Design, and Composition,\nVienna, Austria (17th September 2007), 2007.\n[GRM06a] S. Gorton and S. Reiff-Marganiec. Policy support for business-oriented web service management. In Proceedings of the Fourth Latin\nAmerican Web Congress (LA-WEB\u201906), pages 199\u2013202, Washington, DC, USA, 2006. IEEE Computer Society.\n[GRM06b] S. Gorton and S. Reiff-Marganiec. Towards a task-oriented, policy-driven business requirements specification for web services. In\nDustdar et al. [DFS06], pages 465\u2013470.\n[GRM06c] Stephen Gorton and Stephan Reiff-Marganiec. Towards a task-oriented, policy-driven business requirements specification for web\nservices. In Dustdar et al. [DFS06], pages 465\u2013470.\n[HA04] Hugo Haas and Allen Brown. Web Services Glossary. W3C Working Group Note, World Wide Web Consortium (W3C), 2004.\nhttp:\/\/www.w3.org\/TR\/ws-gloss\/.\n[HB03] R. Hamadi and B. Benatallah. A petri net-based model for web service composition. In K.-D. Schewe and X. Zhou, editors, ADC,\nvolume 17 of CRPIT, pages 191\u2013200. Australian Computer Society, 2003.\n[HW03] J. Y. Halpern and V. Weissman. Using first-order logic to reason about policies. In 16th IEEE Computer Security Foundations\nWorkshop (CSFW\u201903), page 187, Los Alamitos, CA, USA, 2003. IEEE Computer Society.\n[LFB07] Anto\u00b4nia Lopes, Jose\u00b4 Luiz Fiadeiro, and Laura Bocchi. Algebraic Semantics of Service Component Modules. In Algebraic Develop-\nment Techniques, volume 4409 of Lecture Notes in Computer Science, pages 37\u201355. Springer, 2007.\n[LPT07] Alessandro Lapadula, Rosario Pugliese, and Francesco Tiezzi. A calculus for orchestration of web services. In European Symposium\nof Programming, volume 4421 of Lecture Notes in Computer Science, pages 33\u201347. Springer, 2007.\n[MGR04] Robert Mu\u00a8ller, Ulrike Greiner, and Erhard Rahm. Agentwork: a workflow system supporting rule-based workflow adaptation. Data\nKnowl. Eng., 51(2):223\u2013256, 2004.\n[MHD+05] M. Beisiegel, H Blohm, D. Booz, J. Dubray, A. Colyer, M. Edwards, D. Ferguson, B. Flood, M. Greenberg, D. Kearns, J.\nMarino, J. Mischkinsky, M. Nally, G. Pavlik, M. Rowley, K. Tam, and C. Trieloff. Building Systems using a Service Ori-\nented Architecture. Whitepaper, SCA Consortium, 2005. http:\/\/www.oracle.com\/technology\/tech\/webservices\/\nstandards\/sca\/pdf\/SCA_White_Paper1_09.pdf.\n[Mos05] Tim Moses. extensible access control markup language specification. Available from www.oasis-open.org, 2005.\n[MRMS07] Carlo Montangero, Stephan Reiff-Marganiec, and Laura Semini. Logic-based detection of conflicts in APPEL policies. In F. Arbab\nand M. Sirjani, editors, FSEN2007, volume 4676 of Lecture Notes in Computer Science. Springer Verlag, 2007.\n[MRMSon] C. Montangero, S. Reiff-Marganiec, and L. Semini. Logic-based conflict detection for distributed policies. Fundamentae Informatica,\n2008, accepted for publication.\n[OEtH05] J. O\u2019Sullivan, D. Edmond, and A. H. M. ter Hofstede. Formal description of non-functional service properties. Technical Report\nFIT-TR-2005-01, Queensland University of Technology, Brisbane, Feb 2005.\n[RD98] M. Reichert and Peter Dadam. Adeptflex-supporting dynamic changes of workflows without losing control. J. Intell. Inf. Syst.,\n10(2):93\u2013129, 1998.\n[Rei05] Wolfgang Reisig. Modeling- and analysis techniques for web services and business processes. In Martin Steffen and Gianluigi\nZavattaro, editors, Formal Methods for Open Object-Based Distributed Systems, volume 3535 of Lecture Notes in Computer Science,\npages 243\u2013258. Springer, 2005.\n26 L. Bocchi and S. Gorton and S. Reiff-Marganiec\n[RM03] Stephan Reiff-Marganiec. Policies: Giving users control over calls. In Mark Dermot Ryan, John-Jules Ch. Meyer, and Hans-Dieter\nEhrich, editors, Objects, Agents, and Features, volume 2975 of Lecture Notes in Computer Science, pages 189\u2013208. Springer Verlag,\n2003.\n[RMTB05] Stephan Reiff-Marganiec, Kenneth J. Turner, and Lynne Blair. APPEL: the ACCENT project policy environment\/language. Technical\nReport TR-161, University of Stirling, 2005.\n[RvdAtHW06]Nick Russell, Wil M. P. van der Aalst, Arthur H. M. ter Hofstede, and Petia Wohed. On the suitability of uml 2.0 activity diagrams\nfor business process modelling. In Markus Stumptner, Sven Hartmann, and Yasushi Kiyoki, editors, APCCM, volume 53 of CRPIT,\npages 95\u2013104. Australian Computer Society, 2006.\n[SCZ03] F. Siewe, A. Cau, and H. Zedan. A compositional framework for access control policies enforcement. In Proceedings of the 2003\nACM workshop on Formal Methods in Security Engineering, pages 32\u201342, NY, NY, USA, 2003. ACM Press.\n[sen] Software engineering for service-oriented overlay computers (SENSORIA).\nWeb site: http:\/\/sensoria.fast.de\/.\n[SUF97] Stefano Bistarelli, Ugo Montanari, and Francesca Rossi. Semiring-based constraint satisfaction and optimization. J. ACM, 44(2):201\u2013\n236, 1997.\n[vdAtH05] Wil M. P. van der Aalst and Arthur H. M. ter Hofstede. Yawl: yet another workflow language. Inf. Syst., 30(4):245\u2013275, 2005.\n[vdAtHKB03]Wil M. P. van der Aalst, Arthur H. M. ter Hofstede, Bartek Kiepuszewski, and Alistair P. Barros. Workflow patterns. Distributed and\nParallel Databases, 14(1):5\u201351, 2003. Information also available from www.workflowpatterns.com.\n[Wan06] Harry Jiannan Wang. A Logic-based Methodology for Busines Process Analysis and Design: Linking Business Policies to Workflow\nModels. PhD thesis, University of Arizona, 2006.\n[WBC+07] Martin Wirsing, Laura Bocchi, Allan Clark, Jose\u00b4 Luiz Fiadeiro, Stephen Gilmore, Matthias Ho\u00a8lzl, Nora Koch, and Rosario Pugliese.\nSENSORIA: Engineering for Service-Oriented Overlay Computers. MIT, June 2007. submitted.\n[Whi04] Stephen A. White. Business process modelling notation. Object Management Group (OMG) and Business Process Management\nInitiative, 2004. Available from www.bpmn.org.\n[WvdAD+06]Petia Wohed, Wil M. P. van der Aalst, Marlon Dumas, Arthur H. M. ter Hofstede, and Nick Russell. On the suitability of bpmn for\nbusiness process modelling. In Dustdar et al. [DFS06], pages 161\u2013176.\n[ZPPSP05] X. Zhang, F. Parisi-Presicce, R. Sandhu, and J. Park. Formal model and policy specification of usage control. ACM Trans. Inf. Syst.\nSecur., 8(4):351\u2013387, 2005.\n"}