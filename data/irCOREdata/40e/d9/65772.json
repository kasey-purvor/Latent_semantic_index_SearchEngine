{"doi":"10.1109\/TSE.2007.70757","coreId":"65772","oai":"oai:dro.dur.ac.uk.OAI2:4832","identifiers":["oai:dro.dur.ac.uk.OAI2:4832","10.1109\/TSE.2007.70757"],"title":"Software architecture visualization : an evaluation framework and its application.","authors":["Gallagher, K.","Hatch, A.","Munro, M."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2008-03-01","abstract":"In order to characterize and improve software architecture visualization practice, the paper derives and constructs a qualitative framework, with 7 key areas and 31 features, for the assessment of software architecture visualization tools. The framework is derived by the application of the Goal Question Metric paradigm to information obtained from a literature survey and addresses a number of stakeholder issues. The evaluation is performed from multiple stakeholder perspectives and in various architectural contexts. Stakeholders can apply the framework to determine if a particular software architecture visualization tool is appropriate to a given task. The framework is applied in the evaluation of a collection of six software architecture visualization tools. The framework may also be used as a design template for a comprehensive software architecture visualization tool","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65772.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/4832\/1\/4832.pdf","pdfHashValue":"2cb71f139de5b3eb25c60a7fc6a0b7afe538c366","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:4832<\/identifier><datestamp>\n      2011-09-08T15:25:25Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Software architecture visualization : an evaluation framework and its application.<\/dc:title><dc:creator>\n        Gallagher, K.<\/dc:creator><dc:creator>\n        Hatch, A.<\/dc:creator><dc:creator>\n        Munro, M.<\/dc:creator><dc:description>\n        In order to characterize and improve software architecture visualization practice, the paper derives and constructs a qualitative framework, with 7 key areas and 31 features, for the assessment of software architecture visualization tools. The framework is derived by the application of the Goal Question Metric paradigm to information obtained from a literature survey and addresses a number of stakeholder issues. The evaluation is performed from multiple stakeholder perspectives and in various architectural contexts. Stakeholders can apply the framework to determine if a particular software architecture visualization tool is appropriate to a given task. The framework is applied in the evaluation of a collection of six software architecture visualization tools. The framework may also be used as a design template for a comprehensive software architecture visualization tool.<\/dc:description><dc:subject>\n        Software Architectures<\/dc:subject><dc:subject>\n         Visualization techniques<\/dc:subject><dc:subject>\n         Methodologies.<\/dc:subject><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        IEEE transactions on software engineering, 2008, Vol.34(2), pp.260-270 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2008-03-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:4832<\/dc:identifier><dc:identifier>\n        issn:0098-5589<\/dc:identifier><dc:identifier>\n        doi:10.1109\/TSE.2007.70757<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/4832\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/TSE.2007.70757<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/4832\/1\/4832.pdf<\/dc:identifier><dc:rights>\n        \u00a92008 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:0098-5589","0098-5589"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2008,"topics":["Software Architectures","Visualization techniques","Methodologies."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 October 2008\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nGallagher, K. and Hatch, A. and Munro, M. (2008) \u2019Software architecture visualization : an evaluation\nframework and its application.\u2019, IEEE transactions on software engineering., 34 (2). pp. 260-270.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/TSE.2007.70757\nPublisher\u2019s copyright statement:\n2008 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n Use policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without \nprior permission or charge, for personal research or study, educational, or not-for-profit purposes \nprovided that : \n \n\u0083 a full bibliographic reference is made to the original source \n\u0083 a link is made to the metadata record in DRO \n\u0083 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright \nholders.  \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nDurham Research Online \n Deposited in DRO:\n08 October 2008\nVersion of attached file:\nPublished\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nGallagher, K. and Hatch, A. and Munro, M. (2008) 'Software architecture visualization : an evaluation framework\nand its application.', IEEE transactions on software engineering., 34 (2), pp.\u0000260-270.\nFurther information on publishers website:\nhttp:\/\/dx.doi.org\/10.1109\/TSE.2007.70757\nPublishers copyright statement:\n\u00a92008 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material\nfor advertising or promotional purposes or for creating new collective works for resale or redistribution to servers\nor lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\u0000\u0000\nSoftware Architecture Visualization:\nAn Evaluation Framework and Its Application\nKeith Gallagher, Member, IEEE Computer Society, Andrew Hatch, and Malcolm Munro\nAbstract\u2014In order to characterize and improve software architecture visualization practice, the paper derives and constructs a\nqualitative framework, with seven key areas and 31 features, for the assessment of software architecture visualization tools. The\nframework is derived by the application of the Goal Question Metric paradigm to information obtained from a literature survey and\naddresses a number of stakeholder issues. The evaluation is performed from multiple stakeholder perspectives and in various\narchitectural contexts. Stakeholders can apply the framework to determine if a particular software architecture visualization tool is\nappropriate to a given task. The framework is applied in the evaluation of a collection of six software architecture visualization tools.\nThe framework may also be used as a design template for a comprehensive software architecture visualization tool.\nIndex Terms\u2014Software architecture, visualization, visualization methodologies, visualization assessment.\n\u00c7\n1 INTRODUCTION\nVISUALIZATION is used to enhance information under-standing by reducing cognitive overload. Using visua-\nlization tools, people are often able to understand the\ninformation presented in a shorter period of time or to a\ngreater depth. The term \u201cvisualization\u201d has two connota-\ntions. Visualization can refer to the activity that people\nundertake when building an internal picture about real-\nworld or abstract entities. Visualization can also refer to the\nprocess of determining the mappings between abstract or\nreal-world objects and their graphical representation; this\nprocess includes decisions on metaphors, environment, and\ninteractivity. This work uses the term \u201cvisualization\u201d in the\nlatter sense: the process of mapping entities to graphical\nrepresentations.\nEvaluating a particular visualization technique or tool is\nproblematic. Common practice is that some set of guide-\nlines is followed and a qualitative summary is produced. As\nthe guidelines may have been used to produce the\nvisualization, there is some bias in such an evaluation.\nMoreover, these summaries do not usually allow a\ncomparison of competing techniques or tools. A comparison\nis important because it identifies possible \u201choles\u201d in the\nresearch area or development market. Therefore, for\nexample, a software organization may have the requirement\nthat it needs to visualize their current system with an\nemphasis on being able to obtain multiple views for\nmultiple users and should also allow querying. Other\naspects of the visualization may be less important at this\npoint in time.\nThus, a framework for describing the attributes of tools is\nneeded. Once the tools have been assessed in this common\nframework, a comparison is possible. Such a framework\nwill not be complete and indeed may never be. However, a\nframework can be used for comparison, discussion, and\nformative evaluation. In this milieu, we present a frame-\nwork for software architecture visualization evaluation.\n1.1 Result Summary and Contribution\nThe major contribution of this paper is the evaluation\nframework presented in Section 3. Software architecture\nvisualization evaluation falls into seven key areas: Static\nRepresentation, Dynamic Representation, Views, Naviga-\ntion and Interaction, Task Support, Implementation, and\nRepresentation Quality. The key areas are refined further,\nwith each area having 2-10 features.\nThe framework is used to evaluate six existing software\narchitecture visualization tools. It is also used to assess tool\nappropriateness from a variety of stakeholder perspectives.\nThe stakeholder list is extended from that presented in the\nIEEE 1471 standard [15]. The framework can also be used as\ndesign guidelines for an \u201cideal\u201d tool. A preliminary version\nof these results was presented in [10].\n1.2 Outline of the Paper\nThe paper is organized as follows: Section 2 lays the\nfoundation. Section 3, the major contribution of the paper,\noutlines the framework itself and describes the rationale\nand technique of its construction. Section 4 applies the\nframework in various contexts and Section 5 concludes.\n2 RELATED WORK\nThis background section briefly surveys the three main\nareas of the contribution: architecture, visualization, and\nevaluation.\n2.1 Architecture\nArchitecture can take two roles: one describing how the\nsoftware system\u2019s architecture should be and the other\n260 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 2, MARCH\/APRIL 2008\n. The authors are with the Visualisation Research Group, Department of\nComputer Science, Durham University, South Road, Durham DH1 3LE,\nUK. E-mail: {k.b.gallagher, andrew.hatch, malcolm.munro}@durham.ac.uk.\nManuscript received 6 June 2007; revised 17 Aug. 2007; accepted 4 Sept.\n2007; published online 17 Oct. 2007.\nRecommended for acceptance by R. Taylor.\nFor information on obtaining reprints of this article, please send e-mail to:\ntse@computer.org, and reference IEEECS Log Number TSE-2007-06-0183.\nDigital Object Identifier no. 10.1109\/TSE.2007.70757.\n0098-5589\/08\/$25.00 \u0002 2008 IEEE Published by the IEEE Computer Society\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\ndescribing how a software system\u2019s architecture is. Part of\nthe usefulness of architecture analysis is to measure the\ndiscrepancy between the prescribed architecture and the\narchitecture that describes the software produced.\nThere are many definitions of architecture [6], [9], [22].\nFor this work, the IEEE 1471 standard [15] is adopted,\nwhere architecture is defined as \u201cthe fundamental organi-\nzation of a system embodied in its components, their\nrelationships to each other and to the environment, and the\nprinciples guiding its design and evolution.\u201d This is used as\nthe starting definition in this work as it has been agreed\nupon through a community vetting process. As the frame-\nwork evolved, other aspects, for example, the dynamic\naspects of architecture, needed to be incorporated into the\nframework.\nFor any software system, there are a number of\nindividuals who have some interest in the architecture.\nThese stakeholders have differing requirements of the\nsoftware architecture depending on the role that they take.\nThe left column in Table 1, from the IEEE 1471 standard\n[15], identifies a minimal collection of stakeholders that an\narchitectural description must address.\nCommunication and understanding of the architecture is\nessential in ensuring that each stakeholder can play their\nrole during the design, development, and deployment of\nthat software system.\nSoftware engineering research has examined the use of\nspecific languages to describe software architecture (see\nMedvidovic and Taylor\u2019s taxonomy [19]). These languages\nare referred to as Architecture Description Languages\n(ADLs). Rather than focusing on ADLs for capturing and\nrepresenting architectural information, the framework pre-\nsented in this paper is more concerned with the visualiza-\ntion of architectures in the large, whether they have been\nencoded with an ADL or not. Visualizations may indeed\nuse the paradigm of components and connectors, but this is\nat a lower level.\n2.2 Software Visualization\nThe most prominent types of visualization defined in the\nliterature are Scientific Visualization, Information Visualiza-\ntion, and Software Visualization. Scientific Visualization is\nconcerned with creating visualizations for physically-based\nsystems, whereas Information Visualization is concerned\nwith abstract nonphysical data [3]. Software Visualization\nhas been defined as\na discipline that makes use of various forms of imagery to\nprovide insight and understanding and to reduce complex-\nity of the existing software system under consideration [16].\nThe motivation for visualizing software is to reduce the\ncost of software development and its evolution. Software\nvisualization can support software system evolution by\nhelping stakeholders to understand the software at various\nlevels of abstraction and at different points of the software\nlife cycle. Software Visualization can be seen as the\napplication of Information Visualization techniques to\nsoftware, as the data collected from all areas of a system\ndevelopment, such as code, documentation, and user\nstudies, is abstract and, hence, has no associated physical\nstructure.\nSoftware Visualization is the process of mapping entities\nin a software system domain to graphical representations to\naid comprehension and development. It has traditionally\nbeen focused on aiding the understanding of software\nsystems by those who perform development and mainte-\nnance tasks on that software. Although Software Visualiza-\ntion supports the software development and maintenance\nprocess, this focus excludes other valid stakeholders such as\nUsers and Acquirers as listed in Table 1. Software\nArchitecture Visualization can help all stakeholders to\nunderstand the system at all points of the software life cycle.\n2.3 Evaluating Software Visualizations\nA number of taxonomies have been developed for classify-\ning software visualizations. Taxonomies define a number of\nfeatures that visualizations can be measured against. A\ncommonly used method for evaluating software visualiza-\ntions is to apply these taxonomies as an evaluation\nframework. Price et al. [20] present a taxonomy of Software\nVisualization with six distinct categories: Scope (the range\nof systems that can be visualized, platform for system, and\nscalability), Content (the subset of data from Scope that is\nactually used in the visualization: control flow, data flow,\nand algorithms), Form (the characteristics of the visualiza-\ntion: medium, level of detail, and synchronized views),\nMethod (how the data for the visualizations is gathered:\nautomatically generated visualization, code instrumenta-\ntion, and noninvasive probes), Interaction (user interaction\nand control: use of buttons and menus and navigation), and\nEffectiveness (how well the visualizations meet their\nobjectives: purpose of the visualizations, clarity, and degree\nof empirical evaluation). These categories are structured\nhierarchically, with each category expanded into subcate-\ngories. The categories were derived bottom-up, first by\nsurveying existing taxonomies, then examining current\ntools, and finally letting these observations suggest a new\nformulation.\nBassil and Keller [2] use Price et al.\u2019s framework to\nqualitatively analyze a collection of software visualization\ntools. Maletic et al. [18] enhance the Price framework with\nregard to task orientation. Task orientation is similar to our\nuse of stakeholders; however, we have a larger scope of task\nthan that presented by Maletic et al.\nGALLAGHER ET AL.: SOFTWARE ARCHITECTURE VISUALIZATION: AN EVALUATION FRAMEWORK AND ITS APPLICATION 261\nTABLE 1\nStakeholders\nThe left column shows those required by IEEE 1471 [15]. The right\ncolumn shows an expanded list that is discussed in Section 3.1.\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\n3 EVALUATION FRAMEWORK\nBefore describing the framework itself, the motivation for\nits development is given. Next, the framework itself is\ndescribed while indicating the process by which it was\nderived.\n3.1 Motivation for an Architecture Framework\nA number of frameworks and taxonomies exist for the\nevaluation of software visualizations [20], [21], [28]. As\nsoftware visualization has tended to appeal to its roots in\nprogram comprehension, these visualizations are typically\nconcerned with the representation of software at code level,\nsupporting programmers and maintainers. Existing frame-\nworks and taxonomies reflect this focus by looking at low-\nlevel areas such as source code, algorithms, and data\nstructures [11], [12], [20], [26]. The proposed framework will\nprovide a mechanism to discuss key areas and related\nfeatures of tools and will indicate the trade-offs made by the\nstakeholders. This is similar to the trade-off technique\napplied in the cognitive dimensions discussed by Green\nand Petre [12] in their work on visual programming\nenvironments.\nIn supporting developers and maintainers, software\nvisualization has been largely concerned with represent-\ning static and dynamic aspects of software at the code\nlevel. Architecture visualizations require a larger set of\nstakeholders.\nStakeholders prescribed by IEEE 1471 are general classes\nof users. For the purpose of software architecture visualiza-\ntion, the list of stakeholders from the left column in Table 1\ncan be expanded to the list in the right column in Table 1.\nThe extended list on the right in Table 1 illustrates the point\nthat architecture visualization must support a larger\nnumber of stakeholders than that supported by traditional\nsoftware visualization. The right column in Table 1 could\nalso be extended to include other intended stakeholders,\nsuch as suppliers, configuration management staff, chief\ninformation officers, and auditors.\n3.2 Framework Overview\nThe proposed framework has seven key areas for describing\nsoftware architecture visualization: Static Representation,\nDynamic Representation, Views, Navigation and Interac-\ntion, Task Support, Implementation, and Representation\nQuality. The dimensions identified in the framework are\nnot proposed as a formal representation of the character-\nistics of software architecture visualizations, but are\nnecessary for discussion about, and evaluation of, such\nvisualizations. Whether they are sufficient is an open\nquestion and the subject of future research.\nEach of the seven key areas of the proposed framework is\ndiscussed in detail below. The Goal\/Metric\/Question\n(GQM) paradigm [1] was used to identify the questions\nand to then enable the formation of the framework features.\nGQM was chosen because it defines a measurement model\non three levels:\n. Conceptual level (goal). A goal is defined for an\nobject, for a variety of reasons, with respect to\nvarious models of quality, from various points of\nview, and relative to a particular environment.\n. Operational level (question). A set of questions is\nused to characterize the assessment\/achievement\n[how] of a specific goal is going to be performed\nbased on some model.\n. Quantitative level (metric). A set of data is associated\nwith every question in order to answer it in a\nquantitative way.\nAn example of the application of GQM in this research is\ngiven later.\n3.3 Relationship to Other Frameworks\nThe proposed framework has a strong basis in software\nvisualization evaluation. Frameworks and taxonomies such\nas those by Price et al. [20], Storey et al. [28], and Roman\nand Cox [21] have been used to categorize and evaluate\nsoftware visualizations. These works have influenced the\ncreation of the framework. Our approach here is similar to\nthat by Storey et al. \u201c[A framework] can serve several\npurposes: 1) as a formative evaluation tool... 2) for potential\ntool users...; and 3) as a comparison tool...\u201d [27]. The principal\ndifference is that this work is about architecture, whereas\ntheirs is about development.\nPrice et al. [20] use a phenomenological approach to\nderive properties from existing tools, then generalize to a\nframework. The framework engenders a set of open-ended\nquestions. Our proposed framework attempts to \u201cqualita-\ntively quantify\u201d using an enumeration of possible re-\nsponses, similar to a Likert scale; such an approach leaves\nroom for judgment on the part of the responder and\nremoves the judgment from the questioner. It is also easier\nto measure. The measures are qualitative, following Bassil\nand Keller [2].\nBeing modular, the framework allows individual con-\ncerns to be addressed in comparative isolation and, so, the\napplication of the framework need not be performed in its\nentirety.\nThe proposed framework has some degree of overlap\nwith the taxonomy proposed by Price et al. [20]. The\ndistinction between Static and Dynamic Representation in this\nframework has some grounding in the \u201cData Gathering\nTime\u201d questions posed by Price et al. Static Representation is\nconcerned with the collection of static elements of the\nsoftware system (gathered at compile time) and Dynamic\nRepresentation is concerned with runtime information.\nDynamic Representation also has relationships with Price\net al.\u2019s taxonomy in its discussion of \u201cInvasiveness.\u201d Ideally,\na visualization system should be able to collect data from\nthe target system in such a way that the collection of that\ndata does not change the behavior of that system.\nA common theme running throughout both Software\nArchitecture and Software Visualization research is the\nconcept of Multiple Views. Price et al. [20] identify the need\nfor \u201cmultiple synchronized views\u201d within visualization, but\nthe proposed framework also considers the view definition,\nin line with the recommendations of the IEEE 1471\nstandard [15].\nQuestions related to Navigation in this proposed frame-\nwork attempt to condense some of the questions proposed\nby Storey et al. [28], Roman and Cox [21], and Price et al.\n[20] in relation to interaction and interface. Although there\n262 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 2, MARCH\/APRIL 2008\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\nare some elements of navigation that remain desirable\nthroughout most types of view, navigation can be depen-\ndent not only on the subject of the visualization but also on\na particular view of the subject within the visualization. The\nproposed framework ensures that a particular navigation\ntechnique is not enforced, but that suitable navigation\ntechniques are employed. The explicit inclusion of browsing\nand searching is taken from that by Sim et al. [24].\nTask Support constitutes a significant portion of the\nproposed framework. The derivation of the tasks listed is\ntaken largely from the IEEE 1471 standard, which describes\nthe uses of architectural descriptions. Task support is also\ndescribed by Price et al. [20] in their discussion on\neffectiveness.\nThe proposed framework considers Implementation be-\ncause some properties of a visualization can be better\nreasonedabout in termsof its implementation. Some research\nmakes no attempt to evaluate the implementation of a\nvisualization but focuses on the concept of the visualization\nitself, arguing that implementation is not a valid issue.\nHowever, Price et al. [20] explicitly consider generality, a\ncategory that encompasses questions regarding thehardware\nand operating systems to which the visualization caters.\nRoman et al. [21] also discuss implementation-specific\nquestions, particularly around the method of information\nretrieval, such as the use of annotations in source.\nAccurate representation is essential in information\nrepresentation and visualization [8]. Questions regarding\nthe capability of a visualization and its visual metaphor to\nmaintain fidelity are addressed in the Representation Quality\nkey area of the proposed framework.\nLooking specifically at software architecture visualiza-\ntion, there are features of existing software visualization\nframeworks that do apply, along with other features that do\nnot. For example, the framework proposed by Storey et al.\n[28] contains an item that relates to architecture visualiza-\ntion, indicating that a visualization should provide \u201cover-\nviews of the system architecture at various levels of\nabstraction.\u201d Conversely, Price et al.\u2019s taxonomy discusses\nelements that are irrelevant for architecture visualization,\nsuch as \u201cto what degree does the system visualize the\ninstructions in the algorithm\u201d [20].\n3.4 Framework Derivation\nThe primary goal of the proposed framework is to assess\nsystem architectures. The framework was derived from an\nextensive analysis of the literature in the area of software\nvisualization with special emphasis on software architec-\nture. Each of the seven key areas is a conceptual goal which\nthe framework must satisfy. It is this that makes the\napplication of the Goal Question Metric paradigm [1]\nstraightforward.\nRather than describing the complete GQM derivation for\neach subgoal of the framework, its application in the Static\nRepresentation subgoal\/key area is demonstrated only. A\ngoal needs a purpose, issue, object, and viewpoint. Thus, here,\nthe need is to assess (the purpose) the adequacy (the issue) of\nstatic representation (the object) from the researcher\u2019s perspective\n(viewpoint). Then, the question \u201cDoes the visualization\nsupport a multitude of software architectures?\u201d is posed.\nThis process yields the first question in Table 2 and feature\nSR 1 in Table 3. Continuing in a like manner yields the other\nthree questions in Table 2 and items SR 2-4 in the Static\nRepresentation portion in Table 3. Following this process in\nall key areas provides a straightforward way to generate\nquestions for use inGQM.Themetric for theGQMused is the\nLikert scale with four ordered values plus two nonvalues as\nthis does not overcomplicate the application of the frame-\nwork, and the responses have intrinsic meaning.\nGALLAGHER ET AL.: SOFTWARE ARCHITECTURE VISUALIZATION: AN EVALUATION FRAMEWORK AND ITS APPLICATION 263\nTABLE 2\nGQM Application to Static Representation\nTABLE 3\nFramework Summary and Evaluation\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\nThese values are summarized in Table 4. The response\n\u201cNot applicable\u201d (NA) is used where the question is not\nrelevant because the feature is not in the scope of the tool\nand is different from \u201cNo support\u201d (N) in which the scope\nof the tool would suggest that it should support the feature\nbut it does not. The \u201cUnable to determine\u201d (?) response is\nused where the question is relevant, but the presence or\nabsence of the feature was not determined.\n3.5 Framework Detail\nThere are some aspects of software architecture visualiza-\ntion that are not addressed at all in existing software\nvisualization evaluation frameworks. This presents an\nopportunity to develop a framework for the comparison\nof such architecture visualizations.\nThe proposed framework is divided into seven key areas.\nStatic Represenation characterizes the size and accessibility\nof the architectural information. Dynamic Representation\ncharacterizes the support for runtime collection and\nobservation of architectural information. Views characterize\nthe perspective of the observer. Navigation Interaction\ncharacterizes the ease of use of the tool. Task Support\ncharacterizes the operational use of the visualization.\nImplementation assesses the suitability of the information\nfor the particular computational environment. Representa-\ntion Quality characterizes the quality of the information\npresented to the observer.\nIn the following sections, parenthetical references refer to\nthe leftmost column in Table 3. The intent is to point the\ndiscussion of a key area to the embodiment of the feature in\nthe framework by including the GQM questions.\n3.5.1 Static Representation (SR)\nStatic Represenation is the architectural information which\ncan be extracted before runtime, for example, source code,\ntest plans, data dictionaries, and other documentation.\nIt is possible that avisualization systemwill be restricted to\na small number of possible architectures. A visualization\nneed not support amultitude of software architectures if that\nis not the intention of the visualization. (SR 1: Does the\nvisualization support a multitude of software architectures?) In\nsome cases, the software architecture is clearly defined and a\nsingle data source exists from which the visualization can\ntake its input. Often, architectural data does not reside in a\nsingle location and must be extracted from a multitude of\nsources. (SR 2: Does the visualization support the appropriate\ntypes of static software architecture data sources?)Anarchitecture\nvisualization certainly benefits from the ability to support the\nrecovery of data from a number of disparate sources.\nMoreover, with multiple data sources, there should be a\nmechanism for ensuring that the data can be consolidated\ninto a meaningful model for the visualization.\nArchitectural information may not be available directly\nbut is recovered from sources that are nonarchitectural.\n(SR 3: Does the visualization support the recovery of architectural\ninformation from sources that are not directly architectural?) For\nexample, file systems may not be directly architecturally\nrelated, but they can contain important information that\nrelates to architecture. Even more so, namespaces, modules,\nclasses, methods, and variables can all contribute to a view\nof the software architecture and, so, a visualization system\nshould support language-specific constructs.\nIf architectural data is to be retrieved fromnonarchitectur-\nal data, there is a potential for the data repository to contain\nlarge amounts of data from lower levels of abstraction. (SR 4:\nCan the visualization accommodate large amounts of architectural\ndata?) If this is the strategy employed by the visualization,\nthen the visualization should be able to deal with large\nvolumes of information, that is, the system should be\nscalable.\n3.5.2 Dynamic Representation (DR)\nDynamic Representation is the architectural information\nthat can be extracted during runtime. Some relationships\nbetween components of a system will be formed only\nduring execution due the nature of late-binding mechan-\nisms such as inheritance and polymorphism.\nRuntime information can indicate a number of aspects of\nthe software architecture. (DR 1: Does the visualization\nsupport an appropriate set of dynamic data sources?) Visualiza-\ntions should support the collection of runtime information\nfrom dynamic data sources in order to relay runtime\ninformation. Typically, for smaller software systems, this\nruntime information will only be available from one source,\nbut, for larger distributed software systems, the visualiza-\ntion may need the capability of recovering data from a\nnumber of different sources. These data sources may not\nreside on the same machine as the visualization system, so\nthe ability to use remote dynamic data sources is useful.\nSome sources may produce data of one type, where another\nsource produces different data. In this case, the visualiza-\ntion should provide a mechanism by which this data is\nmade coherent.\nWhen dynamic events occur, the visualization should be\nable to display these events appropriately and within the\ncontext of the architecture. (DR 2: Does the visualization\nsupport association of dynamic events with elements of the\nsoftware architecture, during execution of the software?) The\nvisualization must therefore be able to associate incoming\nevents with architectural entities.\nAny method of recording dynamic information from a\nsoftware system will affect that software system in some\nway. (DR 4: Does the visualization allow live collection of\ndynamic data?) At one extreme, there is the directly invasive\napproach of adding lines to the software source code. At the\nother extreme, there is retrieval of information from a\nvirtual machine. The visualization system should support a\nsuitable approach to recovery of dynamic architecture data\nin the least invasive way; disruptive behavior is not\ndesirable. (DR 3: Does the visualization support noninvasive\ncollection of dynamic data?)\n264 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 2, MARCH\/APRIL 2008\nTABLE 4\nThe Metrics: Possible Responses to Items in Table 3\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\nBy visualizing the dynamic data as it is generated, there\nmay be an affect on the software being visualized. A\n\u201cpostmortem style\u201d has the benefit of knowing the period of\ntime over which the visualization occurs. This is useful to a\nvisualization in that it can render a display for a particular\ninstance in time while knowing what will occur next. (DR 5:\nDoes the visualization allow recording of dynamic data for\nsubsequent replay?)\n3.5.3 Views (V)\nKruchten [17] identifies four specific views of software\narchitecture, whereas the IEEE 1471 standard allows for the\ndefinition of an arbitrary number of views. (V 1: Does the\nvisualization allow for multiple views of software architecture?)\nA visualization may support the creation of a number of\nviews of the software architecture and may wish to allow\nsimultaneous access to these views. In the IEEE 1471\nstandard, architectural views have viewpoints associated\nwith them. A viewpoint defines a number of important\naspects about that view, including the stakeholders and\nconcerns that are addressed by that viewpoint, along with\nthe language, modeling techniques, and analytical methods\nused in constructing the view based on that viewpoint. (V 2:\nDoes the visualization display a representation of the viewpoint\ndefinition?) A visualization may make this information\navailable to the user in order to assist in their understanding\nof the view they are using.\n3.5.4 Navigation and Interaction (NI)\nInteractive visualizations systems provide a means by\nwhich users will move within, and interact with, the\ngraphical environment. (NI 1: Can users browse the visualiza-\ntion by following concepts?) Common user navigation\ntechniques such as panning, zooming, bookmarking, and\nrotating are usually offered in both 2D and 3D environ-\nments. Interaction with the environment can involve\nselection, deletion, creation, modification, and so on.\nAn important part of the comprehension process is the\nformulation of relationships between concepts. Having the\nability to follow these relationships is fundamental. Storey\net al. [28] indicate that a software visualization system\nshould provide directional navigation. The visualization\nshould support the user being able to follow concepts in\norder to gain an understanding of the software architecture.\nSearching is the data-space navigation process that\nallows the user to locate information with respect to a set\nof criteria. (NI 2: Can users search for arbitrary architectural\ninformation?) Storey et al. [28] label this as arbitrary\nnavigation\u2014being able to move to a location that is not\nnecessarily reachable by direct links. Sim et al. [24] identify\nthe need for searching architectures for information; so, the\nvisualization should support this searching for arbitrary\ninformation.\nQuery drilling is a term that describes a method of data-\nspace navigation that is a particular hybrid of browsing and\nsearching. (NI 3: Can the user query-drill architectural\ninformation?) It allows a user to search the data space and\nthen recursively search within the resulting data set.\nArchitecture is often comprised of a number of views.\nMoving between views is essential in order to understand an\narchitecture from different viewpoints. (NI 4: Can users\nnavigate between views?) Context should also be maintained\nwhenswitchingbetweenviews so as to reducedisorientation.\nAlong with data-space navigation, the movement within a\nview is also important. Shneiderman\u2019s mantra for visua-\nlization is overview first, zoom, and filter, and then show\ndetails on demand [23]. A visualization system should\nsupport this strategy. Also, the visualization should allow\nthe user to move around so as to focus on and see the\ninformation they are looking for. Typical navigational\nsupport would be pan and zoom. While allowing the user\nto navigate, the visualization should provide orientation\nclues in order to reduce disorientation. (NI 5: Can users\nnavigate appropriately within a view?)\n3.5.5 Task Support (TS)\nTask Support is crucial for any usable software visualiza-\ntion system. This area of the framework explores the ability\nof the visualization to support stakeholders while they are\ndeveloping and understanding the software architecture.\nThe visualization should support architectural analysis\ntasks. As comprehension strategies are task dependent,\narchitecture visualizations should support either of top-\ndown or bottom-up strategies, or a combination of the two.\n(TS 2: Does the visualization support software architectural\ncomprehension?) An important comprehension task is the\nidentification of anomalies. Architectures may be broken or\nmisused and exhibit unwarranted behavior. (TS 1: Does the\nvisualization support the representation of anomalies?) The\nability to tag graphical elements in a visualization is\nimportant for various activities. Annotation can allow users\nto tag entities with information during the formulation of a\nhypothesis. (TS 3: Does the visualization support annotation?)\nVisualizations should support any number of stakeholders.\nIn order to facilitate the communication of the architecture\nto a stakeholder, the visualization must represent the\narchitecture in a suitable manner. (TS 4: Does the visualiza-\ntion support the communication of the architecture to intended\nstakeholders?) Stakeholders may require very different views\nfrom other stakeholders.\nSoftware architecture can evolve over time. Subsystems\nmay be redesigned; components replaced, new components\nadded, new connectors added, and so on. (TS 5: Does the\nvisualization show the evolution of software architecture?) An\narchitecture visualization should provide a facility to show\nthe evolution. This support may be basic, showing\narchitectural snapshots, or the support may be more\nadvanced by using animation.\nVisualizations may offer the capability for the users to\ncreate, edit, and delete objects in the visualization. In order\nto be able to fully support the construction of software\narchitecture, the visualization must be able to allow the user\nto create objects in the domain of the supported viewpoint.\n(TS 6: Does the visualization support construction of software\narchitectures?) Of course, the visualization should also then\nsupport the editing and deleting of those objects. Archi-\ntectural descriptions can be used for the planning, mana-\nging, and execution of software development [15]. In order\nfor the visualization to support this task, it should provide\nrudimentary functionality of a project management tool\u2014or\nhave the ability to communicate with an existing project\nGALLAGHER ET AL.: SOFTWARE ARCHITECTURE VISUALIZATION: AN EVALUATION FRAMEWORK AND ITS APPLICATION 265\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\nmanagement tool. (TS 7: Does the visualization support\nsoftware planning and development?)\nSoftware architecture evaluation allows the architects\nand designers to determine the quality of the software\narchitecture and to predict the quality of the software that\nconforms to the architecture description [15]. To support\nthis, a visualization should have some mechanism by which\nquality descriptions can be associated with components of\nthe software being visualized. (TS 8: Does the visualization\nsupport evaluation of software architectures?) A typical use of\nsoftware architecture visualization is the comparison of as-\nimplemented with as-designed architecture. The visualiza-\ntion should be able to support the display of these two\narchitectures and allow users to make meaningful compar-\nisons between them. (TS 9: Does the visualization support the\ncomparison of software architectures?) Software built from a\nsoftware product line is a typical scenario where compar-\nison of architectures is particularly useful.\nThe rationale for the selection of architecture and the\nselection of the individual architectures of the components\nof that architecture are included in architectural descrip-\ntions. (TS 10: Does the visualization represent rationale?)\nRationale can also be associated with each viewpoint of\nan architecture. By showing the rationale for the elements of\nthe architecture and the architecture as a whole, a\nvisualization will allow a user to have an insight into the\ndecision making process.\n3.5.6 Implementation (I)\nVisualizations should be able to be generated automatically.\n(I 1: Can the visualization be generated automatically?) If\nplatform choice prohibits remote capture of system data,\nthe visualization should be able to execute on the same\nplatform as the software it is intended to visualize. (I 2: Can\nthe visualization be executed on the platform of the target\nsystem?) Where possible, remote capture may be preferred\nfor its potential in reducing unwanted interaction with the\nsoftware. As there are many stakeholder roles in a software\nsystem, there may also be a one-to-one mapping of role to\nphysical users. Therefore, the visualization should support\nmultiple users concurrently or asynchronously. (I 3: Does the\nvisualization support multiple users?)\n3.5.7 Representation Quality (RQ)\nRepresentation Quality is an area of the framework that\ndeals with the capability of the visualization to adequately\nrepresent the software architecture. For software architec-\nture visualization, the visualization must present the\narchitecture accurately and represent all of that architecture\nif the visualization purports to do so. (RQ 1: Does the\nvisualization achieve high fidelity and completeness?) During its\nexecution, software may change its configuration in such a\nway that its architecture has changed. Software that\nchanges its architecture in such a way is labeled software\nthat has a dynamic architecture. If the visualization is able\nto support architectural views of the software at runtime,\nthen it may be capable of showing the dynamic aspects of\nthe architecture. (RQ 2: Does the visualization support the\nrepresentation of dynamically changing software architecture?)\nIn order to do so, the visualization may either support\nsnapshot views of the progression or animate the changes.\n3.6 Framework Summary\nThe two left-hand columns in Table 3 show the outcomes of\nthe application of the GQM paradigm for each key area. The\nabbreviated key area names in the leftmost column are used\nin Figs. 1 and 2. The values in the right-hand columns\n(using the values in Table 4) are discussed and developed in\nSection 4.\n4 APPLYING THE FRAMEWORK\n4.1 Tools\nThis section presents a brief summary and discussion of the\nfeatures of tools that are to be assessed using the framework.\n266 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 2, MARCH\/APRIL 2008\nFig. 1. Starplots of analyzed tools.\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\nThese tools were chosen as a representative sample of the\nsoftware architecture tools available.\n4.1.1 ArchView (AV)\nThe ArchView [9] tool uses the architecture analysis\nactivities of extraction, visualization, and calculation. It\nproduces an architecture visualization that presents the use\nrelations in software systems. The relations are stored in a\nset of files that are read by a browser. The browser reads\nlayout information files and allows the selection of shapes\nand the manual configuration of layout. A collection of tools\nis used to manipulate the set of relations to perform selected\noperations. A VRML generator creates a 3D representation\nusing the 2D layouts and layer position.\n4.1.2 The Searchable Bookshelf (SB)\nThe Searchable Bookshelf [24] visualization attempts to\ncombine both searching and browsing approaches to\nsoftware comprehension. The Searchable Bookshelf adds\nsearch capabilities to the Software Bookshelf. Users can\nbrowse the software structure from an initial overview by\nnavigating through an HTML style display and a software\nlandscape central view. Here is an example of the difference\nbetween searching and query drilling. The Searchable\nBookshelf allows searching but does not allow extended\nsearching within the resulting data space.\nThis visualization affords the user a number of different\nviews; however, the number of views is limited and the\nuser cannot add custom views. Dynamic data is not linked\nto the static representations of the architecture. The\nvisualization is therefore unable to deal with architectures\nthat change configuration during runtime.\n4.1.3 SoftArch (SA)\nSoftArch [13] is both a modeling and visualization system\nfor software, allowing information from software systems to\nbe visualized in architectural views. SoftArch supports both\nstatic and dynamic visualization of software architecture\ncomponents and does so at various levels of abstraction.\nSoftArch\u2019s implementation of dynamic visualization is that\nof annotating and animating static visual forms. SoftArch\ndefines a metamodel of available architecture component\ntypes from which software systems can be modeled. In this\nway, a system\u2019s behavior can be visualized using copies of\nstatic visualization views at varying levels of abstraction to\nshow both the highly detailed or highly abstracted running\nsystem information. SoftArch is integrated into a develop-\nment environment; thus, it addresses a key criticism of\nother visualizations: It provides a mechanism by which it\ncan be used by developers during software development.\nOther aspects of architecture such as project management,\narchitecture comparison, and architecture evaluation are\nnot directly supported in SoftArch.\n4.1.4 SoFi\nSoFi [4] is a tool that performs source code analysis in order\nto compare intended architecture with implemented archi-\ntecture. SoFi\u2019s clusters source files into a structure based on\nsource file naming schemes. SoFi relies heavily on inter-\nvention by an architect to perform restructuring. This\nrestricts the applicability of this visualization to scenarios\nthat require automated generation of a visualization of an\nexisting sytem. SoFi is focused on lower level areas of\narchitecture and does not support dynamic data. Visualiz-\ning evolution can only be supported by repeated applica-\ntion of the tool and visually comparing the differences\nbetween subsequent images.\n4.1.5 LePUS\nLePUS is a formal language dedicated to the specification of\nobject-oriented design and architecture [5], [6], [7]. LePUS\ndiagrams are intended to be used in the specification of\narchitectures and design patterns and in the documentation\nof frameworks and programs. As a visual language, LePUS\nis not concerned with the extraction of architectural\ninformation from systems but is simply a means by which\nan architect can encode software architecture for commu-\nnication to other stakeholders in that architecture. This will\nallow for some activities, such as construction, evaluation,\nand comparison, but is not suited to core visualization\nactivities such as searching and query drilling.\n4.1.6 Enterprise Architect (EA)\nEnterprise Architect [25] is a UML CASE tool that allows\nsoftware architects, designers, and analysts to design\nsoftware from several viewpoints. EA can be used from\nrequirements capture to UML modeling to testing and\nproject management. EA utilizes a graphical user interface\nthat sits above an entity-relationship repository. The\nprimary mechanism for modeling software systems in EA\nis to use diagrams. Entity templates are dragged onto a\ndiagram area, causing a new entity to be created. These\nentities can be edited using the graphical user interface.\nLinks can be formed between diagram entities. These links\ncause relationships to be formed between entities in the\nunderlying model. Existing entities can be dragged onto\nnewly formed diagrams and any existing relationships are\nautomatically shown. Thus, the entity-relationship model is\ndistinct from the visual representations that form the user-\ninterface. EA\u2019s primary use is for designing new software\nbut it also offers a broad range of other tools. For example,\nEA also allows existing software to be parsed and imported.\nEA supports many activities and is suited to a wider\naudience of stakeholders. It does not support dynamic data\nand has difficulty in showing architectural evolution. EA\ndoes permit the construction of new views.\nGALLAGHER ET AL.: SOFTWARE ARCHITECTURE VISUALIZATION: AN EVALUATION FRAMEWORK AND ITS APPLICATION 267\nFig. 2. Combined starplot of all tools.\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\n4.2 Application Summary\nTable 3 presents the evaluation of the features of the six\ntools in tabular form. Most tools do reasonably well in Static\nRepresentation. Dynamic Representation is another matter\nas only one of the surveyed tools has good support in this\nkey area. Most tools support multiple views (V 1); only one\nsupports viewpoint definition (V 2). Navigation and\nInteraction is supported by browsing (NI 1) in most tools.\nThe Enterprise Architect is the only tool that has all of the\nsearching (NI 2), querying (NI 3), and view navigation\nfeatures (NI 4 and NI 5). It seems that all tools are deficient\nin some aspect of Task Support. This is mildly surprising as\none would expect architecture tools to be closely allied with\nproject management and IDE systems. It is also surprising\nto note that not all tools have automatic generation (I 1) and\nmultiple user support (I 3). All tools support high fidelity\nvisualization (RQ 1) but not dynamically changing archi-\ntectures (RQ 2). LePUS is interesting in the context of this\nframework. As a visual language for communicating\narchitectures, it is not applicable to measure navigation\nand interaction (NA) features for it, hence, an NA results.\nFig. 1 shows the starplot representationof theevaluationof\nthe six architecture visualization tools. Each axis in the\nstarplot is scaled according to the possible responses in\nTable 4,with the \u201cyes\u201dvalue (\u201cY\u201d) beingon theouter rim. The\nstarplot can be used to make comparisons between the tools.\n4.3 Using the Stakeholder Viewpoints\nThis section gives an example application of the framework\nand applies it against a number of stakeholders. It is not\nintended to give a high degree of detail, but to simply state\nhow each stakeholder might find a matching tool for their\nrole within a software development organization.\nTable 5 summarizes the result of stakeholder analysis\nthrough consultation with practitioners and by using the\nauthors\u2019 knowledge and experience. It is representative of\nthe practices of four diverse software organizations. For the\npurposes of the table, we are taking the union of the\npossible tasks that a stakeholder might carry out. For\nexample, an architect building a new system would have a\ndifferent set of tasks from an architect rearchitecting an\nexisting system. Although the table does not show the\ncompleteness of the framework, it does illustrate that all of\nthe elements of the framework are relevant to at least one\nstakeholder, whereas some elements are relevant to all\nstakeholders. The very general approach of the process\nmakes a straight yes\/no answer appropriate.\nIn an organization, the stakeholders (job titles) vary.\nTasks assigned to a particular stakeholder vary between\norganizations as well. It is recognized that the mapping\nbetween the features of the framework against the\nstakeholders will vary. Thus, the table will look different\nfor different organizations.\nAs an example, an organization begins a project to\ndevelop a new piece of enterprise software. It is anticipated\nthat the software will evolve over time as new requirements\nare captured by the professional services team. Each\narchitecture stakeholder is considered in turn for determin-\ning tool suitability.\nIn this example, the Architect is principally concerned\nwith visualizing the implemented system once it has been\ncreated and, so, looks to tools that fare strongly in Static\nRepresentation (SR). SoFi, AchViev (AV), and Searchable\nBookshelf (SB) score strongly in this area and, so, are good\ncandidates as tools to support the Architect.\nIn order to support his design tasks, the Designer is\ninterested in a tool that supports the construction of a\nsoftware architecture and does so using a number of\ndifferent views. Here, he is interested in elements of Task\nSupport, specifically construction (TS 6), and many ele-\nments from Navigation and Interaction (NI). Enterprise\nArchitect (EA) is a clear match.\nDevelopers will work with the architecture and designs\nproduced by the Architect and Designer. During develop-\nment tasks, they are interested in understanding the design.\nDuring testing and maintenance tasks, they will be\ninterested in understanding the architectural context of\nsource code in the system and also extracting architectural\ninformation from that source code and comparing this\nagainst the design of the system. Comprehension (TS 2) and\nAnnotation (TS 3) are core to development activities,\nindicating SoftArch (SA) and Enterprise Architect (EA) as\ncandidates; however, developers also share similar require-\nments to the Architect and Software Designer, meaning\nthese tools are not entirely suitable.\nWorking closely with the Architect, Designer, and\nDevelopers, the Development Manager shares concerns\nwith all of these roles; however, no one tool provides full\nsupport. Sales and field support, system administrators,\nand end users may care little for lower levels of detail of the\nsoftware\u2019s architecture but are keen to be able to under-\nstand and discuss the architecture at a high level. Here,\nmultiple views (V) are useful along with a number of\nmethods of interaction (NI). Enterprise Architect (EA) suits\nthese types of requirements well.\nThus, to satisfy the competing demands of the stake-\nholders in this example, no one tool provides all the support\nneeded and SoftArch (SA), ArchView (AV), and Enterprise\nArchitect (EA) will be required. The framework will\nprovide the mechanism for further analysis of the support\nneeded and will assist in choosing the most appropriate tool\n(if only one is required). In practice, the framework should\nbe used in conjunction with the analysis of other context-\nspecific constraints such as organizational standards,\nexperience, and cost.\n4.4 Ideal Tool\nRepresenting architecture visualization tools through star-\nplots gives an immediate impression as to the tool\u2019s\ncapability. Each tool has its own relative merit and none\nsupports all of the framework\u2019s elements and thus\nrepresents the trade-offs made by the tool developers. This\nhighlights a potential problem, where an organization may\nwant a single tool to give all stakeholders a central\nrepository for architectural information that can be repre-\nsented in different ways to each stakeholder. Fig. 2\nillustrates a hypothetical tool that combines the features of\nall tools analyzed under the framework. A salient feature is\nthat this would still not provide full support of all elements\nof the framework. It is not the direction of this paper to\nsuggest whether or not such a \u201cperfect\u201d tool may be\npossible to construct. Further, it is undecided whether such\na tool is desirable.\n268 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 2, MARCH\/APRIL 2008\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\nWhile such a tool may, on the surface, appear to be ideal,\nthere may be a risk of introducing cognitive overload to\nsome stakeholders in the architecture. Not all stakeholders\nwill be able to make use of all features of the tool and they\nmay find that the tool is unwieldy.\n5 CONCLUSION\nSoftware architecture is the gross structure of a system; as\nsuch, it presents a different set of problems for visualization\nthan those of visualizing the software at a lower level of\nabstraction. We have developed and presented a framework\nfor the assessment of the capabilities of software architec-\nture visualization tools and evaluated six tools in this\nframework. It turns out that no one tool meets all of the\ncriteria of our framework. This is not a bad thing. Moreover,\nit may be that a one-size-fits-all approach may increase\ninformation overload and that a collection of small tools\nappropriate to each stakeholder\u2019s task may be preferable.\nA side effect of the application of the framework is that it\nhas highlighted features not present in existing tools, for\nexample, Planning and execution (TS 7) and Dynamically\nGALLAGHER ET AL.: SOFTWARE ARCHITECTURE VISUALIZATION: AN EVALUATION FRAMEWORK AND ITS APPLICATION 269\nTABLE 5\nStakeholder Analysis against the Framework\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\nchanging architecture (RQ 2). These are shown clearly in\nFig. 2 and open up the possibility of future research and\ndevelopment.\nThe question of whether or not one size fits all is\nappropriate for an architecture visualization tool is open.\nThus, we are using the framework to define and prototype\nan architecture visualization tool [14]. It seems clear that\nsuch a tool will need to be tailorable to the specific\nstakeholder in order to be of any practicable use. This\nresembles the \u201csubsetting problem\u201d of programming\nlanguage design (certain stakeholders\/users need only\ncertain subsets of the functionality) and, thus, orthogonality\nof features is paramount so that a user does not accidentally\nstumble onto a feature and its corresponding interaction\nthat was evidently unneeded.\nThe issue of the completeness and sufficiency of the\nframework is an open one and needs to be addressed by\nfurther research. One approach to increase confidence in the\nframework is by applying it to a larger population of tools.\nSoftware engineering theory and practice are evolving, and\nthe notion of software architecture is changing; thus, the\ndefinition of software architecture itself will necessarily\nchange. These new developments may give insights into the\nquestions of completeness and sufficiency.\nREFERENCES\n[1] V. Basili, G. Caldiera, and H.D. Rombach, \u201cThe Goal Question\nMetric Paradigm,\u201d Encyclopedia of Software Eng., vol. 2, pp. 528-532,\nJohn Wiley & Sons, 1994.\n[2] S. Bassil and R. Keller, \u201cA Qualitative and Quantitative Evaluation\nof Software Visualization Tools,\u201d Proc. 23rd IEEE Int\u2019l Conf.\nSoftware Eng. Workshop Software Visualization, pp. 33-37, 2001.\n[3] S. Card, J. Mackinlay, and B. Shneiderman, Reading in Information\nVisualization: Using Vision to Think. Morgan Kaufmann, 1999.\n[4] I. Carmichael, V. Tzerpos, and R. Holt, \u201cDesign Maintenance:\nUnexpected Architectural Interactions,\u201d Proc. Int\u2019l Conf. Software\nMaintenance, pp. 134-137, 1995.\n[5] A. Eden, \u201cFormal Specification of Object-Oriented Design,\u201d Proc.\nConf. Multidisciplinary Design in Eng., 2001.\n[6] A. Eden, \u201cVisualization of Object-Oriented Architectures,\u201d Proc.\nIEEE 23rd Int\u2019l Conf. Software Eng. Workshop Software Visualization,\npp. 5-10, 2001.\n[7] A. Eden, \u201cLe PUS: A Visual Formalism for Object-Oriented\nArchitectures,\u201d Proc. Sixth World Conf. Integrated Design and Process\nTechnology, June 2002.\n[8] M. Eisenstadt and M. Brayshaw, \u201cA Knowledge Engineering\nToolkit: Part I,\u201d BYTE: The Small Systems J., pp. 268-282, 1990.\n[9] L. Feijs and R. de Yong, \u201c3D Visualization of Software\nArchitectures,\u201d Comm. ACM, vol. 41, no. 12, pp. 73-78, Dec. 1998.\n[10] K. Gallagher, A. Hatch, and M. Munro, \u201cA Framework for\nSoftware Architecture Visualization Assessment,\u201d Proc. IEEE\nWorkshop Visualizing Software, pp. 76-82, Sept. 2005.\n[11] T. Green, \u201cInstructions and Descriptions: Some Cognitive Aspects\nof Programming and Similar Activities,\u201d Advanced Visual Inter-\nfaces, pp. 21-28, ACM Press, 2000.\n[12] T.R.G. Green and M. Petre, \u201cUsability Analysis of Visual\nProgramming Environments: A \u201cCognitive Dimensions\u201d Frame-\nwork,\u201d J. Visual Languages and Computing, vol. 7, no. 2, pp. 131-174,\n1996.\n[13] J. Grundy and J. Hosking, \u201cHigh-Level Static and Dynamic\nVisualisation of Software Architectures,\u201d Proc. IEEE Symp. Visual\nLanguages, pp. 5-12, Sept. 2000.\n[14] A. Hatch, \u201cSoftware Architecture Visualisation,\u201d PhD dissertation,\nUniv. of Durham, 2004.\n[15] \u201cIEEE Recommended Practice for Architectural Description of\nSoftware Intensive Systems,\u201d technical report, IEEE, 2000.\n[16] C. Knight and M. Munro, \u201cVisualising Software\u2014A Key Research\nArea,\u201d Proc. Int\u2019l Conf. Software Maintenance, p. 436, 1999.\n[17] P. Kruchten, \u201cThe 4 + 1 View Model of Software Architecture,\u201d\nIEEE Software, vol. 12, no. 6, pp. 42-50, Nov. 1995.\n[18] J. Maletic, A. Marcus, and M. Collard, \u201cA Task Oriented View of\nSoftware Visualization,\u201d Proc. IEEE Workshop Visualizing Software\nfor Understanding and Analysis, pp. 32-40, 2002.\n[19] N. Medvidovic and R. Taylor, \u201cA Classification and Comparison\nFramework for Software Architecture Description Languages,\u201d\nIEEE Trans. Software Eng., vol. 26, no. 1, pp. 70-93, Jan. 2000.\n[20] B.A. Price, R. Baecker, and I.S. Small, \u201cA Principled Taxonomy of\nSoftware Visualization,\u201d J. Visual Languages and Computing, vol. 4,\nno. 3, pp. 211-266, 1993.\n[21] G-C. Roman and K.C. Cox, \u201cA Taxonomy of Program Visualiza-\ntion Systems,\u201d Computer, vol. 26, no. 12, pp. 11-24, Dec. 1993.\n[22] M. Shaw and D. Garlan, Software Architecture: Perspectives on an\nEmerging Discipline. Prentice Hall, 1996.\n[23] B. Shneiderman, Designing the User Interface: Strategies for Effective\nHuman-Computer Interaction. Addison-Wesley, 1998.\n[24] S. Sim, C. Clarke, R. Holt, and A. Cox, \u201cBrowsing and Searching\nSoftware Architectures,\u201d Proc. Int\u2019l Conf. Software Maintenance,\npp. 381-390, Sept. 1999.\n[25] Sparx Systems, Enterprise Architect, http:\/\/www.sparxsystems.\ncom.au, 2008.\n[26] J. Stasko and C. Patterson, \u201cUnderstanding and Characterizing\nProgram Visualization Systems,\u201d Proc. IEEE Workshop Visual\nLanguages, pp. 3-10, 1992.\n[27] M. Storey, D. Cubranic, and D. German, \u201cOn the Use of\nVisualization to Support Awareness of Human Activities in\nSoftware Development: A Survey and Framework,\u201d Proc. ACM\nSymp. Software Visualization, pp. 193-202, 2005.\n[28] M. Storey, F. Fracchia, and H. Muller, \u201cCognitive Design Elements\nto Support the Construction of a Mental Model During Software\nExploration,\u201d J. Systems and Software, vol. 44, pp. 171-185, 1999.\nKeith Gallagher is the director of the Centre for\nSoftware Maintenance and Evolution and a\nmember of the Software Visualisation Group\nand the e-Science Research Institute at Durham\nUniversity, United Kingdom. He invented de-\ncomposition slicing and has investigated its\napplication in software maintenance, change\nimpact analysis, software testing, program com-\nprehension, program visualization, and general-\nized program analysis. He has been a faculty\nresearch associate at the National Institute of Standards and Technol-\nogy, Washington, D.C., and a visiting senior research engineer for the\nCommonwealth Scientific and Industrial Research Organization, Can-\nberra, Australia. He is a member of the IEEE Computer Society.\nAndrew Hatch received the BSc and PhD\ndegrees from the University of Durham, United\nKingdom. Currently, he is a teaching fellow of\nthe Centre for Excellence in Teaching and\nLearning, Active Learning in Computing in the\nDepartment of Computer Science at Durham\nUniversity. His main research interests include\ntechnology-enhanced learning, human-compu-\nter interaction, and software visualization.\nMalcolm Munro is a professor of software\nengineering. His main research interests include\nsoftware visualization, software maintenance\nand evolution, and program comprehension.\nThe concern of his research is to establish how\nLegacy Systems evolve over time and to dis-\ncover representations (visualizations) of those\nsystems to enable better understanding of\nchange. He has led a number of EPSRC funded\nprojects, including the Reconstruction of Legacy\nSystems (Release), Visualising Software in a Virtual Reality Environ-\nment (VVSRE), and Guided Slicing and Targeted Transformation\n(GUSTT). He is involved in research in Software as a Service (SaaS)\nand the application of Bayesian Networks to software testing and\nprogram comprehension.\n270 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 2, MARCH\/APRIL 2008\nAuthorized licensed use limited to: University of Durham. Downloaded on October 8, 2008 at 10:02 from IEEE Xplore.  Restrictions apply.\n"}