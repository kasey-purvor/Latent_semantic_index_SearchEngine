{"doi":"10.1007\/978-3-642-00590-9_9","coreId":"65307","oai":"oai:dro.dur.ac.uk.OAI2:6242","identifiers":["oai:dro.dur.ac.uk.OAI2:6242","10.1007\/978-3-642-00590-9_9"],"title":"An interval-based inference of variant parametric types.","authors":["Craciun, F.","Chin, W.-N.","He, G.","Qin, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Castagna, G."],"datePublished":"2009-03-01","abstract":"Variant parametric types represent the successful integration of subtype and parametric polymorphism to support a more flexible subtyping for Java like languages. A key feature that helps strengthen this integration is the use-site variance. Depending on how the fields are used, each variance denotes a covariant, a contravariant, an invariant or a bivariant subtyping. By annotating variance properties on each type argument to a parametric class, programmers can choose various desirable variance properties for each use of the parametric class. Although Java library classes have been successfully refactored to use variant parametric types, these mechanisms are often criticized, due to the difficulty of choosing appropriate variance annotations. Several algorithms have been proposed for automatically refactoring legacy Java code to use generic libraries, but none can support the full flexibility of the use-site variance-based subtyping. This paper addresses this difficulty by proposing a novel interval-based approach to inferring both the variance annotations and the type arguments. Each variant parametric type is regarded as an interval type with two type bounds, a lower bound for writing and an upper bound for reading. We propose a constraint-based inference algorithm that works on a per method basis, as a summary-based analysis","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65307.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6242\/1\/6242.pdf","pdfHashValue":"12ffed0148952badab3b1ac0e4af54537af38c06","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6242<\/identifier><datestamp>\n      2015-03-31T11:46:56Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        An interval-based inference of variant parametric types.<\/dc:title><dc:creator>\n        Craciun, F. <\/dc:creator><dc:creator>\n        Chin, W.-N.<\/dc:creator><dc:creator>\n        He, G.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:description>\n        Variant parametric types represent the successful integration of subtype and parametric polymorphism to support a more flexible subtyping for Java like languages. A key feature that helps strengthen this integration is the use-site variance. Depending on how the fields are used, each variance denotes a covariant, a contravariant, an invariant or a bivariant subtyping. By annotating variance properties on each type argument to a parametric class, programmers can choose various desirable variance properties for each use of the parametric class. Although Java library classes have been successfully refactored to use variant parametric types, these mechanisms are often criticized, due to the difficulty of choosing appropriate variance annotations. Several algorithms have been proposed for automatically refactoring legacy Java code to use generic libraries, but none can support the full flexibility of the use-site variance-based subtyping. This paper addresses this difficulty by proposing a novel interval-based approach to inferring both the variance annotations and the type arguments. Each variant parametric type is regarded as an interval type with two type bounds, a lower bound for writing and an upper bound for reading. We propose a constraint-based inference algorithm that works on a per method basis, as a summary-based analysis. <\/dc:description><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Castagna, G.  (Eds.). (2009). Programming languages and systems : 18th European Symposium on Programming, ESOP 2009 : held as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2009, York, UK, 22-29 March, 2009 ; proceedings. Berlin: Springer, pp. 112-127, Lecture notes in computer science(5502)<\/dc:source><dc:contributor>\n        Castagna, G. <\/dc:contributor><dc:date>\n        2009-03-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6242<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/978-3-642-00590-9_9<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6242\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/978-3-642-00590-9_9<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6242\/1\/6242.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/978-3-642-00590-9_9<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2009,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nCraciun, F. and Chin, W.-N. and He, G. and Qin, S. (2009) \u2019An interval-based inference of variant parametric\ntypes.\u2019, in Programming languages and systems : 18th European Symposium on Programming, ESOP 2009 :\nheld as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2009, York, UK,\n22-29 March, 2009 ; proceedings. Berlin: Springer, pp. 112-127. Lecture notes in computer science. (5502).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/978-3-642-00590-99\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nCraciun, F. and Chin, W.-N. and He, G. and Qin, S. (2009) 'An interval-based inference of \nvariant parametric types.', in Programming languages and systems : 18th European \nSymposium on Programming, ESOP 2009 : held as part of the Joint European Conferences \non Theory and Practice of Software, ETAPS 2009, York, UK, 22-29 March, 2009 ; \nproceedings. Berlin: Springer, pp. 112-127. Lecture notes in computer science. (5502). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/978-3-642-00590-9_9 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nAn Interval-based Inference of Variant Parametric\nTypes \u22c6\nFlorin Craciun1, Wei-Ngan Chin2, Guanhua He1, and Shengchao Qin1\n1 Department of Computer Science, Durham University, UK\n2 Department of Computer Science, National University of Singapore, Singapore\nAbstract. Variant parametric types represent the successful integration of sub-\ntype and parametric polymorphism to support a more flexible subtyping for Java-\nlike languages. A key feature that helps strengthen this integration is the use-site\nvariance. Depending on how the fields are used, each variance denotes a covari-\nant, a contravariant, an invariant or a bivariant subtyping. By annotating variance\nproperties on each type argument to a parametric class, programmers can choose\nvarious desirable variance properties for each use of the parametric class. Al-\nthough Java library classes have been successfully refactored to use variant para-\nmetric types, these mechanisms are often criticized, due to the difficulty of choos-\ning appropriate variance annotations. Several algorithms have been proposed for\nautomatically refactoring legacy Java code to use generic libraries, but none can\nsupport the full flexibility of the use-site variance-based subtyping. This paper ad-\ndresses this difficulty by proposing a novel interval-based approach to inferring\nboth the variance annotations and the type arguments. Each variant parametric\ntype is regarded as an interval type with two type bounds, a lower bound for\nwriting and an upper bound for reading. We propose a constraint-based inference\nalgorithm that works on a per method basis, as a summary-based analysis.\n1 Introduction\nRecently, several mainstream object-oriented languages, such as Java and C#, have suc-\ncessfully integrated traditional subtype polymorphism and parametric polymorphism to\nsupport better type-safe reusable code with significant reduction of runtime cast oper-\nations. Subtype polymorphism is a nominal relation, based on a given class hierarchy.\nParametric polymorphism allows a data or a function to be parameterized by types and\nsupports structural subtyping [1]. In handling objects with mutable fields, a crucial fea-\nture that helps strengthen the integration of subtype and parametric polymorphism is\nthe adoption of variance. Variance annotations predict the flow of values for fields and\nprovide a richer subtyping hierarchy. Depending on how the fields are being accessed,\neach variance denotes a covariant, a contravariant, an invariant or a bivariant subtyping.\nGenerics types of Java 5 (also called Wildcard Types) [23, 24, 12] are based on the vari-\nant parametric types (or VPTs) [14]. VPTs is based on use-site variance whereby each\nuse of a class type is marked with suitable variances that indicate how the fields are to\nbe accessed.\n\u22c6 The work is supported in part by the EPSRC project EP\/E021948\/1.\nVariant Parametric Types. Consider a variant parametric class Pair with two fields\nwhich are captured as type parameters:\nclass Pair\u3008A, B\u3009 { A fst; B snd; \u00b7 \u00b7 \u00b7 }\nAssume three methods to retrieve the first field, to set the second field and to swap the\ntwo fields for a Pair object. In these methods, the parameter this is the Pair object\nwhose variant parametric type must be provided with suitable variances. The type of\nthe this parameter is specified prior to delimiter \u2032|\u2032 (as in [4]):\nPair\u3008\u2295A,\u229b\u3009 | C getFst\u3008A, C\u3009() where A<:C { return this.fst; }\nPair\u3008\u229b,\u2296B\u3009 | void setSnd\u3008B, C\u3009(C y) where C<:B { this.snd=y; }\nPair\u3008\u2299A,\u2299A\u3009 | void swap\u3008A\u3009(){A y=this.fst; this.fst=this.snd; this.snd=y; }\nAs can be seen, four kinds of variance annotations (denoted by \u03b1) are possible: (i) \u03b1 = \u2295\ncaptures a flow-out from the field to support covariant subtyping; (ii) \u03b1 = \u2296 captures a\nflow-in to the field to support contravariant subtyping; (iii) \u03b1 = \u2299 captures both flow-in\nand flow-out to support invariant subtyping; and (iv) \u03b1 = \u229b captures no access for the\nfield to support bivariant subtyping. For simplicity, \u229bt can be abbreviated as \u229b. More\ngenerally, given an object with variant parametric type c1\u3008\u03b11t1\u3009, we may pass it to a\nlocation with type c2\u3008\u03b12t2\u3009, in accordance with the following subsumption relations:\nc1<:c2 \u03b11t1<:\u03b12t2\nc1\u3008\u03b11t1\u3009<:c2\u3008\u03b12t2\u3009\n(\u03b11<:\u2299) t1=t2\n\u03b11t1<:\u2299t2 \u03b11t1<:\u229bt2\n(\u03b11<:\u2295 \u2227 t1<:t2) \u2228 t2=Object\n\u03b11t1<:\u2295t2\n(\u03b11<:\u2296 \u2227 t2<:t1) \u2228 t2=\u22a5\n\u03b11t1<:\u2296t2\nThe bottom of the class hierarchy is \u22a5 denoting the type of null value, while the top\nof the class hierarchy is Object. For simplicity, the first rule assumes that each class\nconstructor has only a single inheritable type parameter. The above rules use nominal\nsubtyping c1<:c2 from traditional class hierarchy and also a reflexive and transitive vari-\nance subtyping with a simple hierarchy: \u2299<: \u2295 <: \u229b \u2299 <: \u2296 <:\u229b . The <: operator\nis overloaded to handle variance subtyping, nominal class subtyping and two VPT sub-\ntypings for t and \u03b1t, respectively. The above subsumption relations form the basis of\nthe VPT system to provide a richer subtyping system. Two provisos highlighted in the\nabove rules for parametric fields are (i) to allow each such field to be retrievable as an\nObject, and (ii) a null value (of \u22a5 type) to be written into any such field, regardless of\nits variant annotation. Types \u2295Object and \u2296\u22a5 are essentially equivalent to \u229bt.\nMotivation. Although VPT mechanisms have now been validated in the full-scale im-\nplementation of Java 5 [12] and Java library classes have been successfully refactored to\nuse variant parametric types, these mechanisms are often criticized, due to the difficulty\nof choosing appropriate variance annotations. By annotating variance properties on each\ntype argument to a parametric class, programmers can choose various desirable variance\nproperties for each use of the parametric class. For example, the types Pair\u3008\u2295A,\u2295B\u3009 or\nPair\u3008\u2299A,\u2299B\u3009 are still correct types for the receiver of the above method getFst. How-\never the best generic type is Pair\u3008\u2295A,\u229b\u3009, since the first field is read and the second\nfield is not accessed. In order to establish the most flexible correct variance annotations\n(those which do not restrict the code genericity) for a type declaration, the program-\nmer has to analyse all the places where that type declaration is used in the program.\nAlthough several algorithms have been proposed for refactoring legacy Java code [9, 8,\n7, 11], they are restricted either to parametric types [1] or to variant parametric types\nwith known variance annotations. No one can support the full flexibility of the use-site\nvariance-based subtyping. Moreover these algorithms require global analysis.\n2\nContributions. We propose a novel approach to automatically inferring the variance\nannotations and the type variables for the variant parametric types of method parameters\n(including receiver), method result and method body\u2019s local variables. In addition, the\nexpected value flow that may arise from the method body is captured as a precondition.\nThe inference is designed as a summary-based analysis that works on a per method\nbasis: the variant parametric types of a method are inferred only based on how they are\nused in the method body, while each call site is a specific instance of the method\u2019s type\ndeclaration. Our inference is guided by a dependency graph such that all the methods\nwhich are called by the current method have been already analyzed. Our inference also\nassumes that the generic class hierarchy is known. In order to support the full flexibility\nof the subtyping based on the use-site variance, our inference algorithm starts with un-\nknown variance annotations. Each variant parametric type is represented as an interval\ntype [2], namely two type bounds that allow us to distinguish a read flow from a write\nflow for each object\u2019s field. Based on a flow-based approach for VPTs [4], we reduce the\nproblem of inferring variance annotations and type arguments to the problem of solv-\ning specialized flow constraints. To the best of our knowledge this is the first algorithm\nthat decouples variance inference from the type inference itself. In order to allow more\ngeneric types for the method parameters we introduce dual types to support unknown\nvariance flow. Dual types make a distinction between flow via an object, object flow\nand the flow via the object\u2019s fields, field flow. We also use intersection and union types\nto capture the divergent flow and convergent flow, respectively. A safe yet precise ap-\nproximation is used to avoid disjunctive constraints. We also provide special solutions\nto handle runtime cast operations and method overriding.\nRelated Work. The task of introducing generics to an existing Java code [9, 8, 7, 11,\n16] consists of two distinct problems, parameterization and instantiation. Class param-\neterization selects the class fields that can be promoted as class type parameters. Since\nclass parameterization decisions may be quite hard to automate due to trade-offs in\nthe possible design outcomes, our solution is to let programmers focus on high-level\ndesign decisions for parameterization, while leaving the more tedious annotations on\nvalue flows of methods to be automatically inferred. Previous algorithms for instantia-\ntion have been restricted to parametric types based on invariant subtyping [9, 8, 7, 11].\nAlthough the most recent Java refactoring paper [16] claims being able to infer wildcard\ntypes, it conservatively assumes invariant subtyping even with wildcard types.\nAt each call site, Java compiler [12] performs a local inference of the method\u2019s\ntype parameters. The algorithm follows the local type inference designed for parametric\ntypes [17] . Recently, a significant revision of Java local inference has been proposed\nin [21]. The new proposal has introduced two bounds for a type variable similar to\nour interval types. However it does not perform variance inference since the variance\nannotations are known. Our approach is more general and subsuming the local type\ninference.\nOur variant parametric type inference algorithm produces subtyping (flow) con-\nstraints. To solve them, we work on a closed constraint graph employing techniques\nfrom [25, 18, 22, 10]. It seems also possible to formalize our constraint solver on a pre-\ntransitive graph [13] to have a more scalable implementation. In general the constraint\nsolving techniques assume that the polarities of term constructors are known. How-\never the inference of variant parametric types may generate term constructors with un-\n3\nknown polarities (variances). Therefore our approach uses an interval type (a contravari-\nant lower bound and a covariant upper bound) to represent each unknown polarity of\na term constructor. The idea of using interval types for updatable values has already\nbeen applied to reference type [20, 19] and also in the context of object calculi [2]. An\nopen problem (discussed in [2]) is whether the interval types can be used to infer types\nwith variance information from non-annotated terms. Our variance inference provides\na constraint-based solution to this open problem.\nOutline. The following section presents our interval-based view of VPTs. Section 3 in-\ntroduces the key features of our approach. Section 4 formalizes our inference algorithm.\nSection 5 solves the method overriding problem. A brief conclusion is then given.\n2 Variant Parametric Types as Interval Types\nThe underlying idea behind our solution is to view each variant parametric type \u03b1X as\nan interval (of types) with a low-bound X.L and a high-bound X.H such that X.L<:X.H.\nThe low-bound variable captures each value of type t1 that may flow into \u03b1X using the\nconstraint t1<:X.L, while the high-bound variable captures each value of type t2 that\nmay flow out of \u03b1X using X.H<:t2. By default, it is always safe for each low-bound X.L\nto be bounded by \u22a5 <:X.L and each high-bound can be bounded by X.H<:Object. For\nexample, given a variant parametric type c\u3008\u03b1X\u3009 (where X is a type variable) denoting a\nclass with a field of type \u03b1X, it can always be translated into an interval type as follows:\nX=X.H\nc\u3008\u2295X\u3009\u21d0\u21d2c\u3008[\u22a5, X.H]\u3009\nX=X.L\nc\u3008\u2296X\u3009\u21d0\u21d2c\u3008[X.L,Object]\u3009 c\u3008\u2299X\u3009\u21d0\u21d2c\u3008[X, X]\u3009\nc\u3008\u229b\u3009\u21d0\u21d2c\u3008[\u22a5,Object]\u3009\nX.L=fresh() X.H=fresh()\nc\u3008\u03b1X\u3009=\u21d2c\u3008[X.L,X.H]\u3009\nTranslation rules are bidirectional where the variance is known. The last rule is a key\nrule for variance inference, as it splits a type variable with an unknown variance into\ntwo type variables. Thus, field selection (reading) uses the type X.H, while field updating\n(writing) is based on type X.L.\nThe interval type subtyping subsumes VPT subtyping and is defined as a contravari-\nant subtyping on low-bounds and a covariant subtyping on high-bounds, as follows:\nc1<:c2 t2.L<:t1.L t1.H<:t2.H\nc1\u3008[t1.L, t1.H]\u3009<:c2\u3008[t2.L, t2.H]\u3009\nThe annotations .L and .H make a flow-based distinction among the types, such that:\n\u2013 X.L denotes a type that expects a write flow (flow in),\n\u2013 X.H denotes a type that expects a read flow (flow out),\n\u2013 X (without annotation) denotes a type that expects both read and write flows.\nUsing the flow expectations, we identified a special group of flow constraints that we\ncalled closed flow constraints. They denote a matching of a flow-out with a flow-in,\nnamely a consumption of a read flow by a write flow.\nDefinition 1 (Closed Flow Constraint). A closed flow constraint is a flow constraint\nthat has one of the following forms: X1.H<:X2.L, X1.H<:X2, X1<:X2.L, and X1<:X2, where\nX1, X2, are different from Object and \u22a5.\nProposition 1 (Variance Inference Rule-1). If a low-bound type variable X.L does not\noccur in any closed flow constraint, it is resolved to be \u22a5. If a high-bound type variable\nX.H does not occur in any closed flow constraint, it is resolved to be Object.\n4\n3 Inference of Variant Parametric Types\n3.1 Main Algorithm\nThis section illustrates the main steps of our inference algorithm using the following\nmethod of a non-generic Pair class:\nPair | Object move(Pair a) { Object y=a.getFst(); this.setSnd(y); return y; }\nOur goal is to infer its generic version that corresponds to the variant parametric class\nPair\u3008A, B\u3009. Internally, our algorithm works with interval types to generate and solve the\nflow constraints. Therefore, we use the following interval type based specifications of\nthe methods getFst and setSnd of the variant parametric class Pair\u3008A, B\u3009:\nPair\u3008[\u22a5, A.H], [\u22a5,Object]\u3009 | C getFst\u3008A.H, C\u3009() where A.H<:C {..}\nPair\u3008[\u22a5,Object], [B.L,Object]\u3009 | void setSnd\u3008B.L, C\u3009(C y) where C<:B.L {..}\nStep 0. Decoration with Fresh Interval Types. This is a pre-processing step. It con-\nsists of the annotation with fresh type variables of the non-generic types and non-\ngeneric methods. We use the following naming conventions: the letters Vi for the global\ntype variables (visible outside the method), the letter Y for the method result, the letters\nNi for the arguments of new expressions, and the letters Ti for other annotations:\nPair\u3008[V1.L, V1.H],[V2.L, V2.H]\u3009 | Y move(Pair\u3008[V3.L, V3.H],[V4.L, V4.H]\u3009 a)\n{T0 y=a.getFst\u3008T1.H, T2\u3009(); this.setSnd\u3008T3.L, T4\u3009(y); return y; }\nStep 1. Collect Flow Constraints. This step gathers the constraints from the method\nbody using the type inference rules given in Section 4.1, as follows:\nPair\u3008[V3.L, V3.H], [V4.L, V4.H]\u3009<:Pair\u3008[\u22a5, T1.H], [\u22a5,Object]\u3009\u2227T1.H<:T2 \u2227 T2<:T0 \u2227 T0<:T4\u2227\nT4<:T3.L \u2227 Pair\u3008[V1.L, V1.H], [V2.L, V2.H]\u3009<:Pair\u3008[\u22a5,Object], [T3.L,Object]\u3009 \u2227 T0<:Y\nStep 2. Simplify Flow Constraints. This is a closure algorithm that iteratively decom-\nposes the constraints into their elementary components. It primarily applies the interval\nsubtyping rules with transitivity. The closure algorithm is invoked each time a new con-\nstraint is added to the set. For brevity, in the following examples, we omit the transitivity\nand the default constraints like \u22a5<:X, X<:Object, and X.L<:X.H. The result of this step is\nthe following:\nV3.H<:T1.H \u2227 T1.H<:T2 \u2227 T2<:T0 \u2227 T0<:T4\u2227T4<:T3.L \u2227 T3.L<:V2.L \u2227 T0<:Y\nStep 3. Variance Inference. This step generates a set of closed flow constraints and\nthen applies the variance inference rule from Section 2. Since V1.L, V1.H, V4.L, V4.H, V2.H,\nV3.L do not occur in any closed flow constraint, they are accordingly solved as follows:\nV1.L=\u22a5 \u2227 V1.H=Object \u2227 V4.L=\u22a5 \u2227 V4.H=Object \u2227 V2.H=Object \u2227 V3.L=\u22a5\nStep 4. Type Variables Inference. This step solves the type variables Ti, Ni, and Y\nin term of the global type variables Vi and ground types (which are types without type\nvariables). It consists of three substeps:\n1. Cycle elimination: This causes all type variables of a cycle to be equal. Note that\nthere isn\u2019t a cycle in the current example.\n2. Ordering: The type variables are ordered based on the number of constraints in\nwhich they appear as an upper bound.\n3. Unification: Following the order defined before, the type variables are solved by\nequating to their low bounds. Type variables occuring in fewer constraints have a\nhigher priority.\n5\nFor our example, the result of the unification is summarized by the last column of the\nfollowing table. The first column contains the constraints in which the type variables\nfrom the second column occur as upper bounds. Multiple type variables in the second\ncolumn denotes type variables having the same priority.\nConstraints TVars Result\nV3.H<:T1.H {T1.H} T1.H=V3.H\nV3.H<:T2\u2227T1.H<:T2 {T2} T2=V3.H\nV3.H<:T0\u2227T1.H<:T0\u2227T2<:T0 {T0} T0=V3.H\nV3.H<:T4\u2227V3.H<:Y\u2227T1.H<:T4\u2227T1.H<:Y\u2227T2<:T4\u2227T2<:Y\u2227T0<:T4\u2227T0<:Y {T4, Y} Y=T4=V3.H\nV3.H<:T1.H<:T2<:T0<:T4<:T3.L {T3.L} T3.L=V3.H\nStep 5. Result Refining. This step simplifies the inferred types of the method. The goal\nis to reduce the number of the global type variables using the residual flow constraint\n(namely the remaining flow constraints among the global type variables). The residual\nflow constraint of the current example is: V3.H<:V2.L. These type variables can be unified\nto a fresh type variable V, such that V=V3.H=V2.L. Since V stands for both low-bound and\nhigh-bound, it is not marked with either. The result of our inference (including the above\nrefinements) is the following:\nPair\u3008[\u22a5,Object],[V,Object]\u3009 | V move\u3008V\u3009(Pair\u3008[\u22a5, V],[\u22a5,Object]\u3009 a)\n{V y=a.getFst\u3008V, V\u3009(); this.setSnd\u3008V, V\u3009(y); return y; }\nStep 6. VPT Result. This step translates the inferred interval types into VPTs:\nPair\u3008\u229b,\u2296V\u3009 | V move\u3008V\u3009(Pair\u3008\u2295V,\u229b\u3009 a)\n{V y=a.getFst\u3008V, V\u3009(); this.setSnd\u3008V, V\u3009(y); return y; }\n3.2 Interval Types versus Variant Parametric Types\nThe interval types are more expressive than variant parametric types, since they can\nsupport two different non-default bounds. A variant parametric type can only support\ntwo equal non-default bounds in the case of invariant subtyping\u2299. Note that the default\nlow-bound is \u22a5, while the default high-bound is Object. Considering the following code\nfragment, we like to infer the interval type of obj:\nclass Cell\u3008A\u3009 { A fst; \u00b7 \u00b7 \u00b7\nCell\u3008\u2295A\u3009 | A get\u3008A\u3009(){..}\nCell\u3008\u2296A\u3009 | void set\u3008A\u3009(A y){..}..}\nclass Integer extends Number{..}\nclass MyInt extends Integer{..}\n. . .\nCell\u3008[T.L, T.H]\u3009 obj = new Cell\u3008Integer\u3009(new Integer(1)); \/\/ T.L<:Integer<:T.H\nNumber n = obj.get\u3008T1\u3009(); \/\/ T.H<:T1<:Number\nMyInt m = new MyInt(2); obj.set\u3008T2\u3009(m); \/\/ MyInt<:T2<:T.L\nOur algorithm can infer the interval type Cell\u3008[MyInt, Number]\u3009 for obj. However this\ninterval type cannot be translated into a variant parametric type, since it consists of two\ndifferent bounds. In order to keep the equivalence between interval types and variant\nparametric types, we add one more rule to the variance inference:\nProposition 2 (Variance Inference Rule-2). If both bounds X.L and X.H of an interval\ntype occur in the closed flow constraints, then the default constraint of an interval type\nX.L<:X.H is strengthened to the equality X.L=X.H.\nIn our example, adding T.L=T.H to the above set of constraints will generate a cycle\nsuch that T.L<:Integer<:T.H \u2227 T.L=T.H. Cycle elimination generates T.L=Integer=T.H.\nThus new inference result is the interval type Cell\u3008[Integer, Integer]\u3009, that can be\ndirectly translated into the variant parametric type Cell\u3008\u2299Integer\u3009.\n6\n3.3 Main Flow and Conditional Flow\nCast operations give rise to conditional flow constraints (or dynamic subtype constraints\nin [9]). These constraints are conditional in the sense that they are only required to hold\nif the corresponding dynamic downcasts succeed at runtime. Our analysis separates the\nmain flow gathered from the method body without the cast operations and the condi-\ntional flow corresponding to the cast operations. Conditional constraints use a different\nsubtyping notation (<:c). One benefit of our analysis is that it can guarantee that some\nof the cast operations are redundant, and therefore they can be safely eliminated at\ncompile time. The number of the eliminated casts is used as an accuracy measure of\ngeneric type systems [8, 11, 4, 16]. The following example illustrates how our inference\nalgorithm handles the cast operations:\nOriginal code\nCell | void fill(Cell a)\n{Cell b = (Cell)a.fst;b.fst = this.fst; }\nInference Result\nCell\u3008\u2295V\u3009| void fill(Cell\u3008\u2295Cell\u3008\u2296V\u3009\u3009 a)\n{Cell\u3008\u2296V\u3009 b = a.fst;b.fst = this.fst; }\nCode annotated with Fresh Interval Types\nCell\u3008[V1.L, V1.H]\u3009 | void fill(Cell\u3008[V2.L, V2.H]\u3009 a)\n{ Cell\u3008[T1.L, T1.H]\u3009 b = (Cell\u3008[T2.L, T2.H]\u3009)a.fst; b.fst = this.fst; }\n1 . Collect Cell\u3008[T2.L, T2.H]\u3009<:Cell\u3008[T1.L, T1.H]\u3009\u2227V1.H<:T1.L\nConstraints V2.H<:cCell\u3008[T2.L, T2.H]\u3009\n2. Simplify V1.H<:T1.L<:T2.L<:T2.H<:T1.H V2.H<:cCell\u3008[T2.L, T2.H]\u3009\n3 . Infer V1.L=V2.L=\u22a5\u2227T1.H=T2.H=Object\u2227V1.H<:T1.L<:T2.L\nVariance V2.H<:cCell\u3008[T2.L,Object]\u3009\n4. Infer {T1.L} T1.L=V1.H\nType Vars {T2.L} T2.L=V1.H\n5 . Solve Conditional V2.H<:cCell\u3008[V1.H,Object]\u3009 \u21d2 V2.H<:Cell\u3008[V1.H,Object]\u3009\n6. Refine Results V=fresh() V1.H=V \u2227 V2.H=Cell\u3008[V,Object]\u3009\nThough the conditional flow is kept separately, it is still used by the variance inference in\nStep 3. If Step 3 ignores the conditional flow, it infers the incorrect result V2.H=Object.\nA new step (Step 5) is added to the main algorithm. This step combines together the\nconditional flow and the (already solved) main flow in order to find a common solution.\nIn our example, adding the conditional constraint to the main flow does not generate\nany contradiction as the type variables V2.H and V1.H are unconstrained in the main flow.\nHowever it is not always possible to find a common solution for the main and condi-\ntional flow, as illustrated by the following example:\nV3 foo2(Cell\u3008[V4.L, V4.H]\u3009 obj) {\nif(...) {... return (Integer)obj.fst; } else{... return (Float)obj.fst; }}\n\/\/Integer<:V3\u2227Float<:V3 V4.H<:cInteger\u2227V4.H<:cFloat\nIn this example the conditional constraints can be added to the method precondition to\nbe checked at each call site where the casts could be selectively eliminated (with the\nhelp of a polyvariant program specializer):\nNumber foo2(Cell\u3008[\u22a5, V4.H]\u3009 obj) where V4.H<:cInteger\u2227V4.H<:cFloat\n3.4 Convergent Flow and Divergent Flow\nMultiple low bounds denote a convergent flow, while multiple high bounds denote a\ndivergent flow. Our analysis uses union types for multiple low bounds and intersection\ntypes for multiple high bounds. An union type t1|t2 represents the least upper bound\n7\nof t1 and t2, while an intersection type t1&t2 is the greatest lower bound of t1 and t2.\nSome of their subtyping rules may generate disjunctions. In order to keep our analysis\nsimple, we propose a safe yet precise approximation that avoids those disjunctions:\nAND rules OR rules\nt1|t2<:t\nt1<:t \u2227 t2<:t\nt<:t1|t2\nt<:t1 \u2228 t<:t2\nt<:t1&t2\nt<:t1 \u2227 t<:t2\nt1&t2<:t\nt1<:t \u2228 t2<:t\nOur OR rules\nt<:t1|t2 T1=fresh()\nt<:T1 \u2227 t1<:T1 \u2227 t2<:T1\nt1&t2<:t T2=fresh()\nT2<:t1 \u2227 T2<:t2 \u2227 T2<:t\nwhere T1 and T2 are fresh type variables. Another solution to avoid disjunctions is the\ntautology t1&t2<:t1|t2, but sometimes this approximation may lead to no solutions.\nOne benefit of using union and intersection types is that they are more expressive so\nthat more casts can be directly eliminated as the following example (from [8, 4]) can\nillustrate:\nclass B1 extends A implements I {..}; class B2 extends A implements I {..};\nOriginal code\nvoid foo(Boolean b){\nCell c1 = new Cell(new B1());\nCell c2 = new Cell(new B2());\nCell c = b?c1 : c2;\nA a = (A) c.get();\nI i = (I) c.get();\nB1 b1 = (B1) c1.get();\nB2 b2 = (B2) c2.get(); }\nCode annotated with Fresh Interval Types\nvoid foo(Boolean b){\nCell\u3008[T1.L, T1.H]\u3009 c1 = new Cell\u3008N1\u3009(new B1());\nCell\u3008[T2.L, T2.H]\u3009 c2 = new Cell\u3008N2\u3009(new B2());\nCell\u3008[T3.L, T3.H]\u3009 c = b?c1 : c2;\nA a = (A) c.get\u3008T4\u3009();\nI i = (I) c.get\u3008T5\u3009();\nB1 b1 = (B1) c1.get\u3008T6\u3009();\nB2 b2 = (B2) c2.get\u3008T7\u3009(); }\nThe following table contains the inference steps for the above code with interval types.\nAt the step 4.4, T3.H is resolved as to the union type B1|B2 due to two distinct flows\nconverging to it, B1<:T3.H \u2227 B2<:T3.H. The solutions of the main flow can prove that all\nconditional constraints succeed, and therefore all casts can be eliminated.\n1. Collect B1<:N1\u2227Cell\u3008[N1, N1]\u3009<:Cell\u3008[T1.L, T1.H]\u3009\u2227\nConstraints B2<:N2\u2227Cell\u3008[N2, N2]\u3009<:Cell\u3008[T2.L, T2.H]\u3009\u2227\nCell\u3008[T1.L, T1.H]\u3009<:Cell\u3008[T3.L, T3.H]\u3009\u2227Cell\u3008[T2.L, T2.H]\u3009<:Cell\u3008[T3.L, T3.H]\u3009\n\u2227T3.H<:T4\u2227T3.H<:T5\u2227T1.H<:T6\u2227T2.H<:T7\nT4<:cA\u2227T5<:cI\u2227T6<:cB1\u2227T7<:cB2\n2. Simplify B1<:N1\u2227T1.L<:N1<:T1.H\u2227B2<:N2\u2227T2.L<:N2<:T2.H\u2227T3.L<:T1.L\u2227T1.H<:T3.H\n\u2227T3.L<:T2.L\u2227T2.H<:T3.H\u2227T3.H<:T4\u2227T3.H<:T5\u2227T1.H<:T6\u2227T2.H<:T7\nT4<:cA\u2227T5<:cI\u2227T6<:cB1\u2227T7<:cB2\n3. Infer T1.L=T2.L=T3.L=\u22a5 \u2227 B1<:N1<:T1.H\u2227B2<:N2<:T2.H\u2227\nVariance T1.H<:T3.H\u2227T2.H<:T3.H\u2227T3.H<:T4\u2227T3.H<:T5\u2227T1.H<:T6\u2227T2.H<:T7\nT4<:cA\u2227T5<:cI\u2227T6<:cB1\u2227T7<:cB2\n4 . Infer {N1, N2} N1=B1\u2227N2=B2\nType Vars {T1.H, T2.H} T1.H=B1\u2227T2.H=B2\n{T6, T7} T6=B1\u2227T7=B2\n{T3.H} T3.H=B1|B2\n{T4, T5} T5=T4=B1|B2\n5. Solve B1|B2<:cA B1|B2<:cI\nConditional B1<:cB1 B2<:cB2\n8\n3.5 Field Flow and Object Flow\nA key feature of our approach is the distinction between the flow via an object, called\nobject flow and the flow via the fields of that object, called field flow. We introduce a\nspecial type notation, that we called dual type to support these two views: (1) object\nas a black box, and (2) object as a glass box. For example, a dual type for a Pair is of\nthe form X .=Pair\u3008[V1.L, V1.H], [V2.L, V2.H]\u3009, where the type variable X (called object part)\nis used for the flow of the entire object, while Pair\u3008[V1.L, V1.H], [V2.L, V2.H]\u3009 (called field\npart) caters to the flow via its fields. This dualism can improve the genericity of our\ninference results. Specifically, given the following method dup (from [4, 14]):\nPair dup(Pair a) { Pair p = new Pair(a, a); return p; }\nWithout using the dual types, our inference can get the following types:\nPair\u3008\u229b,\u229b\u3009 dup(Pair\u3008\u229b,\u229b\u3009 a){\nPair\u3008\u229b,\u229b\u3009 p=new Pair\u3008Pair\u3008\u229b,\u229b\u3009,Pair\u3008\u229b,\u229b\u3009\u3009(a, a); return p; }\nThe type of the method result is too imprecise, but still correct as fields are not accessed\n(bivariant \u229b) in the method body. Using dual types our approach can get more precise\ntypes by inferring an intersection type for the method parameter a, namely:\nPair\u3008\u2299X1,\u2299X1\u3009 dup\u3008X1\u3009(X1&Pair\u3008\u229b,\u229b\u3009 a) {\nPair\u3008\u2299X1,\u2299X1\u3009 p = new Pair\u3008X1, X1\u3009(a, a); return p; }\nThe type variable X1 plays an important role, it allows the unknown variance to flow\nunchanged, such that the variance annotations of the parameter a fields are preserved in\nthe type of the method result. As can be seen below, the type variable X1 comes from\nthe object part of the dual type:\nY dup(X1\n.\n=Pair\u3008[V1.L, V1.H], [V2.L, V2.H]\u3009 a) {\nX2\n.\n=Pair\u3008[T1.L, T1.H], [T2.L, T2.H]\u3009 p = new Pair\u3008N1, N2\u3009(a, a); return p; }\n1. Collect X1\n.\n=Pair\u3008[V1.L,V1.H],[V2.L,V2.H]\u3009<:N1\u2227X1\n.\n=Pair\u3008[V1.L,V1.H],[V2.L,V2.H]\u3009<:N2\nConstraints \u2227Pair\u3008[N1,N1],[N2, N2]\u3009<:X2\n.\n=Pair\u3008[T1.L,T1.H],[T2.L,T2.H]\u3009\n\u2227X2\n.\n=Pair\u3008[T1.L, T1.H], [T2.L, T2.H]\u3009<:Y\n2 . Simplify X1<:N1\u2227X1<:N2\u2227Pair\u3008[N1, N1], [N2, N2]\u3009<:X2\nDual Types \u2227Pair\u3008[N1, N1], [N2, N2]\u3009<:Pair\u3008[T1.L, T1.H], [T2.L, T2.H]\u3009\u2227X2<:Y\n3. Simplify X1<:N1\u2227X1<:N2\u2227Pair\u3008[N1, N1], [N2, N2]\u3009<:X2<:Y\n\u2227T1.L<:N1<:T1.H\u2227T2.L<:N2<:T2.H\n4. Infer V1.L=V2.L=T1.L=T2.L=\u22a5\u2227V1.H=V2.H=T1.H=T2.H=Object\nVariance X1<:N1\u2227X1<:N2\u2227Pair\u3008[N1, N1], [N2, N2]\u3009<:X2<:Y\n5. Infer {N1, N2} N1=X1\u2227N2=X1\nType Vars {X2} X2=Pair\u3008[X1, X1], [X1, X1]\u3009\n{Y} Y=Pair\u3008[X1, X1], [X1, X1]\u3009\n6 . Refine X1\n.\n=Pair\u3008[\u22a5,Object], [\u22a5,Object]\u3009\u21d2X1&Pair\u3008[\u22a5,Object], [\u22a5,Object]\u3009\nResults Pair\u3008[X1,X1],[X1,X1]\u3009\n.\n=Pair\u3008[\u22a5,Object],[\u22a5,Object]\u3009\u21d2Pair\u3008[X1,X1],[X1,X1]\u3009\nA new step (Step 2) is added to the main algorithm in order to simplify the dual types.\nThe simplification rules always prefer the object flow over the field flow (e.g. first con-\nstraint of Step 1 is reduced to X1<:N1). However, when the type variables of the field\npart are used by the other constraints, both flows are generated (e.g. the third constraint\nof Step 1 is decomposed into two constraints). The last step is adapted to refine the dual\ntypes. A dual type can be refined to an intersection type (e.g. first line of Step 6). Since\nan intersection type is the greatest lower bound of its parts, it could be further simplified\n(e.g. the second line of Step 6).\n9\n4 Inference Algorithm\nProgram\nP ::= def\u2217\ndef ::= class c\u3008K\u2217\u3009 extends c1\u3008pi11 ,..,pi1k\u3009\n... cn\u3008pin1 , .., pink\u3009 {(pi f)\u2217 mth\u2217}\nmth ::= \u03ba | \u03ba mn\u3008V \u2217\u3009((\u03ba v)\u2217) where \u03c8 {e}\ne ::= null | v | v.f | v = e | v.f = e\n| {\u03ba v = e1 ; e2} | e1 ; e2 | (\u03ba)v\n| new c\u3008\u03ba\u2217\u3009(v\u2217) | if v then e1 else e2\n| while v do e | v0.mn\u3008\u03ba\n\u2217\u3009(v\u2217)\nVariant Parametric Type\n(VPT)\npi ::= \u03b1\u03ba | K\n\u03ba ::= V | c\u3008pi1, .., pin\u3009 | c\n| \u03ba&\u03ba | \u03ba|\u03ba | \u22a5\n\u03b1 ::= \u2299 | \u2295 | \u2296 | \u229b\nVPT Subtyping Constraint\n\u03c8 ::= \u03ba1<:\u03ba2 | \u03ba1<:c\u03ba2\n| \u03c8\u2227\u03c8 | true\nFig. 1. SYNTAX OF VARIANT CORE-JAVA\nWe design our inference algorithm as a summary-based analysis, on a per method basis\nguided by a global method call graph. Our approach is flow-insensitive within each\nmethod, but context-sensitive across the methods. The algorithm takes as input a well-\ntyped non-generic program and the VPT class hierarchy, before it outputs a program\nthat uses VPTs.\nWe use two assumptions to avoid recursive constraints: (1) no F-bounded quantifi-\ncation over the VPT class hierarchy, and (2) no polymorphic recursion for the classes\nand the methods. Techniques for avoiding recursive constraints are presented in [4, 5].\nNevertheless, our algorithm can cope with F-bounds, as long as we use constraint solv-\ning techniques that support recursive constraints and inductive simplification (from [25,\n18]). Our current approach can infer generic types for mutually-recursive methods un-\nder the monomorphic recursion assumption.\nWe formalize the algorithm on Variant Core-Java (Fig. 1), a core calculus for Java-\nlike languages. Both input and output programs are encoded in Core-Java since VPTs\ncan subsume non-generic types. For ease of presentation, the features related to static\nmethods, exception handling, inner classes and overloading are omitted. Multiple inter-\nface inheritance is supported as in Java [12], each class may extend from a single su-\nperclass but may implement multiple interfaces. VPT\u2019s syntax is also shown in Fig. 1.\nThere are two kinds of type variables: K denoting a variance and a type together, and\nV denoting only a type. For simplicity, primitive types (e.g. bool, void) are represented\nby their corresponding classes (such as Bool, Void). Specifically, for each method our\nanalysis can be divided into two main steps: (1) gathering the flow constraints based on\nthe type inference rules (Section 4.1), and (2) solving the flow constraints (Section 4.2).\n4.1 Type Inference Rules\nThe inference process is driven by the following main rule for each method:\nG\u22a2 ci \u21dbdcr ti G; {(vi:ti)\nn\ni=2, this:t1} \u22a2 e\u21dbe e\n\u2032:t, \u03d50\nY=fresh() Q1=\n\u22c3\nn\ni=1\nfv(ti) G \u22a2 \u03d50\u2227t<:Y ;Q1 \u21dbsolver \u03d5;Q;\u03c3\n\u03c3t1|\u03c3Y mn\u3008Q\u3009((\u03c3ti vi)ni=2) where \u03d5 {\u03c3e\u2032}\u21dbvpt \u03ba1|\u03ba mn\u3008Q\u2032\u3009((\u03bai vi)ni=2) where \u03c8 {e\u2032\u2032}\nG \u22a2 c1|c0 mn((ci vi)ni=2) {e} \u21db \u03ba1|\u03ba mn\u3008Q\u2032\u3009((\u03bai vi)ni=2)) where \u03c8 {e\u2032\u2032}\nthat takes a non-generic method and the VPT class hierarchy G, decorates the method\nparameters (\u21dbdcr) with fresh interval types, collects the flow constraints (\u21dbe) from the\nmethod body, and then passes the constraints to the constraint solver (\u21dbsolver). The solver\n10\nInterval Type\n\u03c4 ::= t | t.L | t.H\nt ::= X | d | c\u3008[\u03c41L, \u03c41H ], .., [\u03c4nL, \u03c4nH ]\u3009\nc | t1&t2 | t1|t2 | \u22a5 | Object\nX ::= V | T | N | Y\nDual Type\nd ::= X\n.\n=c\u3008[\u03c41L, \u03c41H ], ..., [\u03c4nL, \u03c4nH ]\u3009\nFlow Constraint\n\u03d5 ::= \u03c41<:\u03c42 | \u03c41<:c\u03c42 | \u03d5\u2227\u03d5 | true\nSubstitution\n\u03c3 ::= X=\u03c4 | X.L=\u03c4 | X.H=\u03c4 | d=t\nClosed Flow Constraint\n\u03c6 ::= t1.H<:t2.L | t1<:t2.L | t1.H<:t2\n| t1.H<:ct2.L | t1<:ct2.L | t1.H<:ct2\nFig. 2. INFERENCE TYPES AND FLOW CONSTRAINTS\n(Section 4.2) returns the list of method type parameters Q and a substitution \u03c3. The sub-\nstitution maps the type variables (introduced by the decoration) either to ground types\nor to the type variables from Q. Interval types (and dual types), their flow constraints and\nthe substitutions \u03c3 are detailed in Fig. 2. The final step\u21dbvpt translates the interval types\ninferred for the method into VPTs. We summarize below the main judgments employed\nby this phase of our analysis (a complete description is in [5]):\n\u2013 G\u22a2c\u21dbdcrt denotes the decoration with fresh type variables of a non-generic class c\nwith respect to its parameterized version from VPT class hierarchy G. The result t\nis either a dual type, or the class c (when c is not parameterized), or a type variable.\n\u2013 \u03c1\u22a2\u03ba\u21db\u03batt and \u03c1\u22a2pi\u21db\u03c0\u03c4\u03c4 denote the translation of a VPT into an interval type with\nrespect to a substitution \u03c1. A substitution \u03c1 maps a type variable K (denoting a type\nand a variance) into two bounds [\u03c4L, \u03c4H].\n\u2013 G\u22a2t, fn\u21dbfld[\u03c4L,\u03c4H] returns the low-bound and high-bound [\u03c4L,\u03c4H] of a field fn with\nrespect to an interval type t and the VPT class hierarchy G.\n\u2013 G\u22a2t, mn\u21dbmthmth returns the interface mth (with fresh interval types) of a method mn\nwith respect to a receiver t and the VPT class hierarchy G.\n\u2013 G; \u0393\u22a2e\u21dbee\n\u2032:t, \u03d5 denotes the type inference for the expression e with respect to the\ntype environment \u0393 and the VPT class hierarchy G. The inference result consists of\nthe expression e\u2032 annotated with interval types, its interval type t and the derived\nflow constraint \u03d5. The type environment \u0393 consists of the interval types generated\nby\u21dbdcr.\n4.2 Constraint Solver\nThe constraint solver takes as input a flow constraint \u03d50, a set of visible type variables\nQ0, a VPT class hierarchy G and performs the following sequence of steps:\n\u22a2\u03d50\u21dbsetC0 \u22a2C0\u21dbtrC1 G\u22a2C1\u21dbsimplifyC2 \u22a2C2\u21dbdualC3;D G\u22a2C3\u21dbsimplifyC4\n\u22a2C4;Q0\u21dbvarianceC5;Q1;\u03c31 \u22a2C5;Q1;\u21dbtypvarC6;Q2;\u03c32 G\u22a2C6\u21dbcondC7\nG\u22a2C7;D;Q2;\u03c32\u25e6\u03c31\u21dbrefineC8;Q;\u03c3 \u22a2C8\u21dbcnj\u03d5\nG\u22a2\u03d50;Q0\u21dbsolver\u03d5;Q;\u03c3\nThe goal is first to simplify the constraints\u03d50 to atomic constraints among type variables\nand ground types and then to solve the type variables in term of the ground type and\nthe visible type variables Q. The result consists of a residual constraint \u03d5 among the\nvisible type variables, a reduced set of type variables Q and the solution itself given as\na substitution \u03c3. Since our solver internally works with a set of constraints C instead of\na conjunction \u03d5, the judgments\u21dbset and\u21dbcnj make the corresponding translations. We\nsummarize below the main steps of our solver (a complete description is in [5]).\n11\nTransitive Closure ( \u21dbtr). The constraint set is always closed by transitivity such that\nthis step is performed each time a new constraint is added. The transitivity takes into\naccount the conditional constraints, it generates a conditional constraint from a condi-\ntional constraint and non-conditional constraint. VPT subtyping (and also interval type\nsubtyping) is transitive since the VPT class declarations are well-formed as in [15].\nSimplification (\u21dbsimplify). It consists of a constraint decomposition \u21dbs followed by a\ntransitive closure: G\u22a2C0\u21dbsC\u2032 \u22a2C\u2032\u21dbtrC\nG\u22a2C0\u21dbsimplifyC\nConstraint decomposition\u21dbs is performed with respect to the class subtyping given by\nthe VPT class hierarchy G, the interval subtyping rule and the subtyping rules for in-\ntersection and union types. Using the mechanism presented before the intersection and\nunion types constraints always decompose into conjunctions. A conditional constraint\nis decomposed into new conditional constraints. The step is performed until the con-\nstraint set remains unchanged. In the solver, the first call of \u21dbsimplify step decomposes\nthe outermost intersection and union types to reduce the complexity of the step\u21dbdual.\nDual Types Simplification(\u21dbdual). It decomposes all the dual types from the input con-\nstraint set C0. The result consists of a new constraint set C and the list of the decomposed\ndual types D:\n\u22a2C0\u21dbdD;C1 \u22a2C1\u21dbtrC\n\u2032\n1 D\u22a2C\n\u2032\n1\u21dbcdC2 \u22a2C2\u21dbtrC\n\u22a2C0\u21dbdualC;D\nThe process is performed in two stages. In the first stage (\u21dbd), all the flow constraints\nwith dual types are decomposed. When it needs to choose,\u21dbd prefers the flow through\nthe object part of a dual type rather than that through the field part. In the second stage\n(\u21dbcd), the flow through the field part is selectively added to the constraint set when it is\nrequired by the other constraints.\nVariance Inference (\u21dbvariance). It computes the high-bound type variables and the low-\nbound type variables that do not occur in the closed flow constraints, and resolves them\nto their default values by the substitutions \u03c3H and \u03c3L respectively.\nLH={V.H | V.H<:V1.L\u2208C0 \u2228 V.H<:V2\u2208C0 \u2228 V.H<:cV3.L\u2208C0 \u2228 V.H<:cV4\u2208C}\nLL={V.L | V1.H<:V.L\u2208C0 \u2228 V2<:V.L\u2208C0 \u2228 V3.H<:cV.L\u2208C0 \u2228 V4<:cV.L\u2208C0}\n\u03c3H=[[V.H 7\u2192Object] | V.H\u2208fv(C0) \u2227 V.H 6\u2208LH ]\n\u03c3L=[[V.L7\u2192 \u22a5] | V.L\u2208fv(C0) \u2227 V.L6\u2208LL]\n\u03c3HL=[[V.L7\u2192V, V.H 7\u2192V ] | V.H\u2208LH \u2227 V.L\u2208LL]\nQ=Q0\u222aran(\u03c3HL)\\(dom(\u03c3L)\u222adom(\u03c3H)\u222adom(\u03c3HL)) C=\u03c3H\u25e6\u03c3L\u25e6\u03c3HLC0\n\u22a2C0;Q0\u21dbvarianceC;Q;\u03c3H\u25e6\u03c3L\u25e6\u03c3HL\nThe substitution \u03c3HL implements the second variance inference rule, making equal the\nbounds of an interval when both of them occur in the closed flow constraints. The initial\nlist of the visible type variables Q can be affected by the variance inference. This step\nworks on all constraints, either from conditional flow or from main flow.\nType Variables Inference (\u21dbtypvar). This step solves the non-visible type variables in\nterms of the visible type variables Q0:\n\u22a2C0;Q0\u21dbcycleC1;Q1;\u03c31 \u22a2C1;Q1\u21dborderL \u22a2L;C1\u21dbunifyC;\u03c32 Q=Q1\u222afv(C)\n\u22a2C0;Q0\u21dbtypvarC;Q;\u03c32\u25e6\u03c31\nFirst substep (\u21dbcycle) makes equal all the type variables of a cycle. This process may also\naffect the visible type variables, resulting in a new set Q1. We use techniques from [10]\n12\nto eliminate the cycles. The non-visible type variables are then solved (\u21dbunify) in an\norder given by the number of their low bounds (\u21dborder). The substep \u21dborder iteratively\ncomputes the order taking into account the situations when the low bounds are class\ntype parameterized with type variables. The substep \u21dbunify unifies the type variables\nwith their low-bounds producing a substitution \u03c32. Multiple low-bounds are combined\ntogether as an union type. Non-visible type variables of final constraint set C are pro-\nmoted as visible in Q. Though this step works only on the main flow constraints, its\ncomputed substitutions are also applied on the constraints of the conditional flow.\nSolving conditional constraints (\u21dbcond). This step translates the conditional con-\nstraints into non-conditional constraints if the non-conditional constraints hold. Since\nit is always safe to add more constraints on the method interface type variables and\nthe constraint set is transitively closed, this step only checks (\u22a2?) the conditional con-\nstraints with the ground types with respect to the class hierarchy G. First check is for\nground constraints, while the last two are to verify if an intersection and an union type\ncan exist in G. If the checks do not hold, the conditional constraints are not translated.\nB={c1<:cc2 | c1<:cc2\u2208C0} G\u22a2?B\n\u2200V \u2208fv(C0).G\u22a2?{c | V <:cc\u2208C0}&{c | V <:c\u2208C0}\n\u2200V \u2208fv(C0).G\u22a2?{c | c<:cV \u2208C0}|{c | c<:V \u2208C0}\nC\u2032={\u03c41<:\u03c42|\u03c41<:c\u03c42\u2208C0} C\n\u2032\n0=C0\\{\u03c41<:c\u03c42|\u03c41<:c\u03c42\u2208C0}\nG\u22a2C0\u21dbcondC\n\u2032\u222aC\u20320\nRefining the results (\u21dbrefine). The goal of this step is to reduce the number of visible\ntype variables of a method interface. The first three substitutions are based on the closed\nflow constraints which are in C0. The last two substitutions are for the high bound (low\nbound) type variables occurring on low bound (high bound) positions. Dual types are\nalso translated into intersection types by the substitution \u03c3d.\n\u03c31=[V1.H 7\u2192V, V2.L7\u2192V |V1.H<:V2.L\u2208C0 \u2227 V=fresh()] \u03c32=[V.H 7\u2192t|V.H<:t\u2208\u03c31C0]\n\u03c33=[V.L7\u2192t|t<:V.L\u2208\u03c32\u25e6\u03c31C0] \u03c34=[V 7\u2192t|t<:V \u2208\u03c33\u25e6\u03c32\u25e6\u03c31C0 \u2228 V <:t\u2208\u03c33\u25e6\u03c32\u25e6\u03c31C0]\n\u03c3\u2032=\u03c33\u25e6\u03c32\u25e6\u03c31\u25e6\u03c3t G\u22a2\u03c3\n\u2032D\u21dbrefinedual \u03c3d\n\u03c3\u20321=[V.H 7\u2192V |V1.L7\u2192V.H\u2208\u03c3\n\u2032 \u2227 V=fresh()] \u03c3\u20322=[V.L7\u2192V |V1.H 7\u2192V.L\u2208\u03c3\n\u2032 \u2227 V=fresh()]\n\u03c3=\u03c3\u20322\u25e6\u03c3\n\u2032\n1\u25e6\u03c3d\u25e6\u03c3\n\u2032\nG\u22a2C0;D;Q0;\u03c30\u21dbrefine\u03c3C0;\u03c3Q0;\u03c3\n5 Method Overriding\nConsider the following method overriding example, where the method boo of the class\nCell is overridden by the subclass Pair (note that class Pair extends Cell{..}):\nCell | Object boo(Cell a) {this.fst = a.fst; return a.fst; }\nPair | Object boo(Cell a) {a.fst = this.fst; this.snd = a.fst; return a.fst; }\nApplying our inference to each method, we obtain the following results:\nCell\u3008\u2296P\u3009 | P boo(Cell\u3008\u2295P\u3009 a){..} Pair\u3008\u2295P1,\u2296P1\u3009 | P1 boo(Cell\u3008\u2299P1\u3009 a){..}\nThe method overriding is sound only if the overriding method is a subtype of the over-\nridden method and the overriding method\u2019s receiver is a subtype of the overridden\nmethod\u2019s receiver [3]. As can be seen, this property does not hold for the above in-\nferred methods:\nPair\u3008\u2295P1,\u2296P1\u3009<:Cell\u3008\u2296P\u3009 Cell\u3008\u2295P\u3009<:Cell\u3008\u2299P1\u3009 P1<:P\nTo ensure this property, we augment our inference algorithm with the following con-\nsiderations: (i) we can strengthen the receiver type and the result type of the overriding\nmethod; (ii) we can strengthen the parameters types and the precondition of the over-\nridden method. Thus the method overriding problem is solved as follows:\n13\n1. Infer the overridden method as: Cell\u3008[P,Object]\u3009 | P boo(Cell\u3008[\u22a5,P]\u3009 a)\n2. Undo the variance of the overridden method parameters by using fresh interval type\nvariables (P1.H and P1.L) that keep the relation with the other type variables of the\nreceiver and the result: Cell\u3008[P,Object]\u3009 | P boo(Cell\u3008[P1.L,P1.H]\u3009 a) where P1.H<:P\n3. Do inference for the overriding method: The process starts with the sound overrid-\ning assumptions (Step 1):\nPair\u3008[V1.L,V1.H],[V2.L,V2.H]\u3009 | Y boo(Cell\u3008[V3.L,V3.H]\u3009 a)\n{a.fst=this.fst;this.snd=a.fst;return a.fst;}\n1.Overriding Assumptions Pair\u3008[V1.L,V1.H],[V2.L,V2.H]\u3009<:Cell\u3008[P,Object]\u3009\u2227Y<:P\u2227\nCell\u3008[P1.L,P1.H]\u3009<:Cell\u3008[V3.L,V3.H]\u3009\u2227P1.H<:P\n2.Collect Constraints V1.H<:V3.L\u2227V3.H<:V2.L\u2227V3.H<:Y\n3.Simplify P<:V1.L\u2227Y<:P\u2227V3.L<:P1.L\u2227P1.H<:V3.H\u2227P1.H<:P\nV1.H<:V3.L\u2227V3.H<:V2.L\u2227V3.H<:Y\n4.Infer Variance V2.H=Object\u2227V1.L=V1.H\u2227V3.L=V3.H\u2227P1.L=P1.H\n5.Infer Type Vars P=P1.H=P1.L=V1.H=V1.L=V2.L=V3.H=V3.L\n4. The result of the previous step is applied on both overridden and overriding methods\nand we obtain the following sound result:\nCell\u3008\u2296P\u3009 | P boo(Cell\u3008\u2299P\u3009 a) Pair\u3008\u2299P,\u2296P\u3009 | P boo(Cell\u3008\u2299P\u3009 a)\n6 Conclusion\nWe have formalized a novel constraint-based algorithm to infer variant parametric types\nfor non-generic Java code. In contrast to the previous refactoring algorithms [9, 8, 7,\n11, 16] which mainly support invariant subtyping and are designed as whole program\nanalyses, our approach offers full support for use-site variance based subtyping and it\nis designed as a summary-based analysis that works on a per method basis. The main\ntechnical novelty of our approach is a systematic variance inference based on interval\ntypes. With the full support for use-site variance based subtyping, our approach can\ngenerate better generic types than those derived by existing systems. For instance, none\nof the previous algorithms can automatically infer the examples from Section 3.4 and\nSection 3.5.\nAlthough our inference algorithm internally works with sophisticated mechanisms,\nits output is expressed in terms of variant parametric types extended with restricted\nforms of intersection\/union types as used in [4]. We have proven the soundness of our\ninference algorithm with respect to our variant parametric type system in [4]. However\nthe completeness requirement is a difficult problem since the decidability of nominal\nsubtyping with use-site variance is still an open problem as was discussed in [15].\nWe have built an inference prototype which works for a core subset of Java. Our\nprevious VPT checker from [4] is used to validate the inferred results. In our initial\nexperiments we have tested the quality of our inference system results on a small set\nof non-generic programs by comparing the inferred generic types with the best generic\ntypes that one can manually provide. In all the cases, our system was able to infer the\nsame types as those manually provided. The inference time was less than one second\nfor each test program. Currently we are working to extend our experiments to larger\nprograms by using our translator of Java to a core subset [6].\n14\nReferences\n1. G. Bracha, M. Oderski, D. Stoutamire, and P. Wadler. Making the future safe for the past:\nAdding genericity to the Java programming language. In ACM OOPSLA, 1998.\n2. M. Bugliesi and S. M. P. Geertsen. Type inference for variant object types. Information and\nComputation, 177(1), 2002.\n3. G. Castagna. Covariance and contravariance: Conflict without a cause. ACM TOPLAS, 17(3),\n1995.\n4. W. N. Chin, F. Craciun, S.C. Khoo, and C. Popeea. A flow-based approach for variant\nparametric types. In ACM OOPSLA, 2006.\n5. F. Craciun, W. N. Chin, , G. He, and S. Qin. An Interval-based Inference of Variant Para-\nmetric Types. Technical report, Department of Computer Science, Durham University, UK.,\nDecember 2008. Available at http:\/\/www.durham.ac.uk\/shengchao.qin\/papers\/VPTinfer.pdf.\n6. F. Craciun, H. Y. Goh, and W. N. Chin. A framework for object-oriented program analyses\nvia Core-Java. In IEEE Internationl Conference on Intelligent Computer Communication\nand Processing, 2006.\n7. D. Dincklage and A. Diwan. Converting Java Classes to use Generics. In ACM OOPSLA,\n2004.\n8. A. Donovan, A. Kiezun, M. S. Tschantz, and M.D. Ernst. Converting Java Programs to Use\nGeneric Libraries. In ACM OOPSLA, 2004.\n9. D. Duggan. Modular Type-based Reverse Engineering of Parameterized Types in Java Code.\nIn ACM OOPSLA, 1999.\n10. M. Fa\u00a8hndrich, J. S. Foster, Z. Su, and A. Aiken. Partial online cycle elimination in inclusion\nconstraint graphs. In ACM PLDI, 1998.\n11. R. Fuhrer, F. Tip, A. Kiezun, J. Dolby, and M. Keller. Efficiently Refactoring Java Applica-\ntions to Use Generic Libraries. In ECOOP, 2005.\n12. J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language Specification. Addison-\nWesley, 2005.\n13. N. Heintze and O. Tardieu. Ultra-fast aliasing analysis using cla: A million lines of c code\nin a second. In ACM PLDI, 2001.\n14. A. Igarashi and M. Viroli. Variant parametric types: A flexible subtyping scheme for gener-\nics. ACM TOPLAS, 28(5), 2006.\n15. A. Kennedy and B. Pierce. On Decidability of Nominal Subtyping with Variance. In\nFOOL\/WOOD, 2007.\n16. A. Kiez\u02d9un, M. D. Ernst, F. Tip, and R.M. Fuhrer. Refactoring for parameterizing Java classes.\nIn ICSE, 2007.\n17. M. Odersky. Inferred Type Instantiation for GJ, January 2002. Notes, 2002.\n18. F. Pottier. Simplifying Subtyping Constraints. In ACM ICFP, 1996.\n19. F. Pottier. Type inference in the presence of subtyping: from theory to practice. PhD thesis,\nUniversite Paris 7, 1998.\n20. J. C. Reynolds. Preliminary design of the programming language Forsythe. Technical report,\nCMU-CS-88-159,Carnegie Mellon, 1988.\n21. D. Smith and R. Cartwright. Java type inference is broken: Can we fix it? In ACM OOPSLA,\n2008.\n22. Z. Su, M. Fahndrich, and A. Aiken. Projection merging: Reducing redundancies in inclusion\nconstraint graphs. In ACM POPL, 2000.\n23. M. Torgersen, E. Ernst, C. P. Hansen, P. von der Ahe, G. Bracha, and N. Gafter. Adding\nWildcards to the Java Programming Language. JOT, 3(11), 2004.\n24. M. Torgersen, E. Ernst, and C.P. Hansen. WildFJ. In FOOL, 2005.\n25. V. Trifonov and S. Smith. Subtyping Constrained Types. In SAS, 1996.\n15\n"}