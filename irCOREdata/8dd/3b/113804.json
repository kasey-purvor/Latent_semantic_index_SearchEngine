{"doi":"10.1109\/DEST.2007.371961","coreId":"113804","oai":"oai:epubs.surrey.ac.uk:1983","identifiers":["oai:epubs.surrey.ac.uk:1983","10.1109\/DEST.2007.371961"],"title":"Automata Semantics and Analysis of BPEL","authors":["Zheng, Yongyan","Krause, Paul J."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-02-21","abstract":"<p>Web service is an emerging paradigm for distributed computing. In order to verify web services rigorously, it is important to provide a formal semantics for flow-based web service languages such as BPEL. A suitable formal model should cover most features of BPEL. The existing formal models either abstract from data, cover a simple subset of BPEL, or omit the interactions between BPEL activities. This paper presents Web Service Automata, an extension of Mealy machines, to fulfil the formal model requirements of the web service domain. Secondly, the paper analyses the control handling and data handling of BPEL, so that these can be verified in a clear manner.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1983<\/identifier><datestamp>\n      2017-10-31T14:03:54Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1983\/<\/dc:relation><dc:title>\n        Automata Semantics and Analysis of BPEL<\/dc:title><dc:creator>\n        Zheng, Yongyan<\/dc:creator><dc:creator>\n        Krause, Paul J.<\/dc:creator><dc:description>\n        <p>Web service is an emerging paradigm for distributed computing. In order to verify web services rigorously, it is important to provide a formal semantics for flow-based web service languages such as BPEL. A suitable formal model should cover most features of BPEL. The existing formal models either abstract from data, cover a simple subset of BPEL, or omit the interactions between BPEL activities. This paper presents Web Service Automata, an extension of Mealy machines, to fulfil the formal model requirements of the web service domain. Secondly, the paper analyses the control handling and data handling of BPEL, so that these can be verified in a clear manner.<\/p><\/dc:description><dc:date>\n        2007-02-21<\/dc:date><dc:type>\n        Conference or Workshop Item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1983\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Zheng, Yongyan and Krause, Paul J.  (2007) Automata Semantics and Analysis of BPEL  In: 2007 Inaugural IEEE-IES Digital EcoSystems and Technologies Conference.     <\/dc:identifier><dc:relation>\n        10.1109\/DEST.2007.371961<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1983\/","10.1109\/DEST.2007.371961"],"year":2007,"topics":[],"subject":["Conference or Workshop Item","PeerReviewed"],"fullText":"2007 Inaugural IEEE International Conference on Digital Ecosystems and Technologies (IEEE DEST 2007)\nAutomata Semantics and Analysis ofBPEL\nYongyan ZHENG, Paul KRAUSE\nDepartment of Computing, University of Surrey\nGuildford, GU2 7XH, UK\n{y.zheng, p.krause}gsurrey.ac.uk\nAbstract-Web service is an emerging paradigm for distrib-\nuted computing. In order to verify web services rigorously, it is\nimportant to provide a formal semantics for flow-based web\nservice languages such as BPEL. A suitable formal model\nshould cover most features of BPEL. The existing formal mod-\nels either abstract from data, cover a simple subset of BPEL,\nor omit the interactions between BPEL activities. This paper\npresents Web Service Automata, an extension of Mealy ma-\nchines, to fulfil the formal model requirements of the web ser-\nvice domain. Secondly, the paper analyses the control handling\nand data handling of BPEL, so that these can be verified in a\nclear manner.\nIndex Terms- Web service, BPEL, finite state machine, de-\nsign model analysis.\nI. INTRODUCTION\nThe web service paradigm provides a flexible, re-usable,\nand loosely coupled model for distributed computing. Web\nservice architectures have been actively researched in recent\nyears, and various web service standards have been pro-\nposed. BPEL [1] is one of the de-facto orchestration lan-\nguages to model business processes as coordinated sets of\nweb service interactions. Since BPEL is a semi-formal flow\nlanguage, various formal semantics have been proposed, so\nthat BPEL models can be verified rigorously. However,\nmost current formal models do not cover the BPEL data\nflow analysis, and ignore the internal interactions of BPEL\nactivities.\nExisting model checking tools can be reused for the pur-\npose of verification and testing of BPEL. Our formal model\nis intended to be used by such verification tools. With\nmodel checking, a BPEL model can not only be a design\nmodel for verification, but also be a test model for deriving\ntest cases. The formal semantics proposed to date for BPEL\ncan be categorized as process algebra based, Petri-net\nbased, and automata based. We follow the automata-based\napproach, in order to facilitate the use of model checking\ntools. We propose a Web Service Automaton (WSA), an\nextension of Mealy machine, which covers data, supports\nmessage passing communication, and adapts the asynchro-\nnous interleaving semantics. We justify the suitability of\nWSA for BPEL on three counts. First, its propositional in-\nput events capture most features of the BPEL language,\nwhile most automata-based formal models for BPEL only\ncover the core subset features ofBPEL. Second, its message\npassing communication provides a uniform semantics for\nboth BPEL internal and external interactions. Third, the\nmodel analyzes BPEL control and data flows in separation.\nThe rest of the paper is organized as follows. Section II\npresents our web service automata semantics. Section III\nanalyses BPEL data and control flows. Section IV reviews\nrelated work, and Section V concludes the paper.\nII. WEB SERVICE AUTOMATON\nIn the following, we give the formal definition for the\nstatic semantics and briefly describe the dynamic semantics\nof a web service automaton.\nDefinition 1. We assume that we have available a enumer-\nable infinite set V of variables and sets AX BY of assign-\nment expressions and Boolean expressions respectively, to-\ngether with a set D of values. We also assume that we have\na set of functions Env where geEnv: V->D assigns variable\nof V with a value from D. Given an expression exp: We\nneed three functions:\n* defAX-* V, where def (exp) e V returns the assigned\nvariable on the left hand side of the assignment.\n* cuses:AX-*g(V), where V(V) the power is set of V\nand cuses(exp)cz V returns the used variables on the\nright hand side of the assignment.\n* puses:BX-*g(V), where puses(exp)czV returns the\nused variables in the Boolean expression.\nDefinition 2. A Web Service Automaton (WSA) M is a\nfinite state machine, consisting of WSM=(I,S4,Sf TM,&).\nAs a convention, we omit the subscript of M such that\nM=(I,S,Sf,T,5).\n1) I is the signature of M, denoted as a three tuple\nI=(E,L,O), where E, L, 0 are pair-wise disjoint and\nrepresent a set of input events, internal events, and\noutput events, respectively. Let Msg-(LuEuO) to be\nthe set of events, we refer to the elements of LinuLo-,t\nas internal input and internal output events, and to\nthose of internal events and to those ofEuO as exter-\nnal events.\n2) S is a set of states, soeS is the initial state, Sf ciS is a set\nof final states.\n3) TczINxBXx(g(AX)uOUT) is a set of transitions,\nwhere IN=(EuLinuJ{Q}) and OUT=(L01ut uOu{Q}).\nFor each t-(m,g,a)e T (graphically denoted as m[g]la),\nmczIN is a triggering event, geBX is the guard predi-\ncate, and ac(g((AX)uuOUT) is the action set com-\nposed of assignments and output events. Here Q indi-\ncates the omission of either an event. We could repre-\n1-4244-0470-3\/07\/$20.00 \u00a92007 IEEE 147\n2007 Inaugural IEEE International Conference on Digital Ecosystems and Technologies (IEEE DEST 2007)\nsent a transition by Q[g]\/ Q which simply determines\na state change and nothing else.\n* The events of the transition input event set\nt.m c IN are linked the by logical operation con-\njunction, disjunction, or negation, denoted as\nAND: elAe2. A. .ee, OR: e1ve2..v..en, and NOT:\n--e1, respectively.\n* The data structure of machine M is the form of\n(VM,AXM,BXM), which can be retrieved from T.\n4) &z Sx Tx S is the transition relation.\nFor the dynamic semantics, the message-passing based\nasynchronous communication model is used in WSA. The\nmachine composition adapts asynchronous interleaving se-\nmantics. A machine is associated with a multi-set buffer\nwith FIFO queue for each message. We use symbols !,? as\na convention in diagrams to indicate whether an event is\ninput, output, denoted as ?e E E and !e E 0, respectively.\nIII. ANALYSIS OF BPEL FEATURES IN WSA\nBPEL consists of basic and structured activities. Basic\nactivities are atomic actions. Structured activities impose\ncontrol dependencies on the executions of either the basic\nor structured activities within them. A structured activity\ncan contain an arbitrary depth of sub-activities. BPEL has\nstructured activities including the pick, switch, while, se-\nquence, flow, scope, eventHandlers, faultHandlers, and a\ncompensationHandler structured activity to reverse com-\npleted activities. BPEL handles data using a blackboard ap-\nproach, where a set of variables is shared by the enclosed\nactivities.\nIn this section, we analyse the main features ofBPEL and\ndescribe how to capture these features in WSA. The de-\ntailed mapping from BPEL to WSA can be found in [13].\nWe use machine as shorthand for a web service automaton,\nand call the machine associated with BPEL x activity as x\nmachine. In state machine diagrams, an initial state is\npointed by an arrow starting with a filled black circle, and a\nfinal state is shaded.\nA. Motivating Scenario\nWe use a scenario to show the importance of analysing\nboth BPEL control flow and data flow. In BPEL, variables\nand links may affect the control flow, variables may appear\nin expressions on the conditions in switch and while, and\nmay also be used in the condition to fire particular links in\nthe source element. So taking into account variables is es-\nsential in the formal model. There are two types of vari-\nables in BPEL: BPEL variables and links. BPEL variables\nare declared in the variables tag of either process or scope\nactivity. Links are Boolean variables declared in the links\ntag of the flow activity. The output link of an activity is de-\nfined as true if the activity completes normally, otherwise\nthe link is defined false. The link synchronization feature\nwill be covered in subsection G. BPEL variables and links\ncan be used and defined by the process or scope enclosed\nactivities, and the flow enclosed activities, respectively.\nprocess\nflow\npick\nel 2\nAs B\nvarl\nSWitch\n[g]s s[!g] var2\nAND-join- i2\nlinkl K\nFig. 1 Unreachable and deadlock activities\nIn Fig. 1, the boxes, the solid arcs, and the dashed arcs\ndenote BPEL activities, control flow, and data flow, respec-\ntively. The process activity encloses a flow, activity which\nin turn includes pick, switch, and E activities running con-\ncurrently. The example contains unreachable and deadlock\nactivities. Firstly, B and E are unreachable. B is unreachable\ndue to the interaction between data flow and control flow.\nIn the pick, A and B are mutually exclusive in control flow,\nbut the output ofA is the input of B in data flow, so B can\nnever be executed. E is unreachable due to the fault design\nof links. In the switch, C and D are mutually exclusive in\ncontrol flow, so the linkl and link2 cannot be both true to\nsatisfy the AND-join condition. Therefore, E can never be\nexecuted. Secondly, there is a deadlock between switch and\nE, which is caused by the cyclic data flow between them.\nOn the one hand, E waits for both linkI and link2 to be true\nbut this condition can never be satisfied. On the other hand,\nthe switch waits for its input var2 to be defined but var2\ncannot be defined by E because of the falsity of either linkl\nor link2. This illustrates the necessity to verify both control\nflow and data flow.\nB. Loan Approval Example\nWe use a loan approval process [1] as a running example\nto illustrate our data flow model and the control flow\nmodel, shown in Fig. 2. There exist three web services:\nloanapproval, assessor, and approver. A customer asks for a\nloan of a specified amount. Based on the request's amount,\nthe loanapproval invokes either assessor or approver. If the\nassessor is invoked, based on the returned risk, the loanap-\nproval either assigns the approval value itself or invokes the\napprover. The final approval value is relayed to the cus-\ntomer. The arrows represent message flow in this scenario\ndiagram.\nreq ,\nreq m<l:: 1 00 receive req .m >=1 0*00\nf~~~~~\\~i -req \/\nassessor nvokel nv approver\nr sk=\" approval\napproval\n< k~~~rel loanapproval\napproval--,\nFig.2 Loan approval example\nThe BPEL model for the loanapproval service uses a\nprocess activity, flow activity and activities receive, in-\nvoke], invoke2, assign, reply running concurrently within\nthe flow. It has global variables request, risk, approval and\n6 flow links to control which path the model will execute.\n1-4244-0470-3\/07\/$20.00 \u00a92007 IEEE 148\n2007 Inaugural IEEE International Conference on Digital Ecosystems and Technologies (IEEE DEST 2007)\nC. Control Flow Model\nA WSA has no hierarchy. We simulate the hierarchical\nrelationships of BPEL activities by adding start message\nand done message as common administration messages be-\ntween machines. A machine can play the role of parent or\nchild. For a machine M, its parent machine is the one who\nsends a start message to M, while its child machine is the\none who receives a start message from M. A child machine\nwill send a done message to its parent machine when reach-\ning one of its final states. If machine M sends a start mes-\nsage to machine N, thenM is the parent machine ofN andN\nis the child machine ofM. A child machine will send a done\nmessage to its parent machine when reaching one of its final\nstates. Each machine has zero or one parent machine, and\nzero or many children machines. Since the BPEL basic ac-\ntivity is atomic and a BPEL structured activity is hierarchi-\ncal, the machine for a BPEL basic activity has no child, and\nthe machine for a BPEL structured activity has O..* chil-\ndren.\nFig.3 An example of machine control-flow model\nFig. 3 shows the machine control flow of the loan ap-\nproval service. The machine without an incoming dark ar-\nrow (start message) is the process machine. The machine\nwithout an incoming hollow arrow (done message) is a ba-\nsic machine. The process machine is the parent of the flow\nmachine, and the flow is the parent of receivelinkWrapper\nmachine, which in turn is the parent of receive machine. In\na flow activity, when an enclosed activity contains links,\nthis activity will be associated with a core machine and a\nlinkWrapper machine. The rationale for this is covered in\nsubsection G.\nD. Data Flow Model\nData flow captures the relations between inputs and out-\nputs of BPEL activities. In this paper, we focus on the data\nflow model of the internal BPEL activities. BPEL handles\ndata by a blackboard approach, where data is shared by\nBPEL activities. By message passing, there are two possible\nways to construct data flow from a BPEL model. One ap-\nproach is to simulate the shared data access by adding data\nwriting to and reading from the blackboard. The other ap-\nproach is to analyse the BPEL model to discover data de-\npendencies among activities. The data flows identified from\nthese two approaches are called centralized and decentral-\nized data flow, respectively. Fig. 4 shows the difference be-\ntween them.\ncentralized data flow mnodel decentralized data flow mndel\nFig.4 An example of machine data-flow models\nIn the centralized data-flow model, all the data exchanges\nbetween activities need to be via a variable or link centre. In\nthe decentralized data-flow model, activities can exchange\ndata directly. We choose the decentralized approach be-\ncause it is more efficient in terms of data communication.\nE. Concurrency, Fault Propagation, and Interruption\nIn this subsection, we show that a machine's input events\nwith logical AND, OR, NOT can capture various BPEL fea-\ntures.\nparent?start\/ childl !done & child2?done\nchild1 !start;..;childn!start ..&..childn!done\/parent!done\n(1)) si 5]s\n(2) jchild1 faultl child2?fault2 ..I..childn!faultn\/parent!faulti\n(3, ti.0: parent?stop(3i<ti. 1: child?fault &\n-parent?stop\nti.2: ?e & -child?fault &\n-parent?stop\nFig.5 Propositional input events\nConcurrency\nBPEL flow, scope, and eventHandler activities allow the\nenclosed activities to perform concurrently. We use flow\nactivity as an illustration here. When the flow enters, all the\nenclosed activities start. The flow ends when all the en-\nclosed activities end. We model this by two transitions,\nshown in (1) Fig. 5. On the left of (1), the flow machine\nstarts all its children as a transition action, so that all child\nmachines will start at the same time. On the right of (1), a\nlogical-AND operator is added to the transition input\nevents, so that the flow machine will not end until all its\nchildren end by sending done messages.\n* Fault propagation\nWhen a structured machine receives a fault message from\nits children, it forwards the fault message to its parent. Sup-\npose the structured activity encloses more than one activity.\nThe fault is propagated as long as one of the enclosed ac-\ntivities raises a fault. We model this by adding a logical-OR\noperator to the transition input events, shown in (2) of Fig.\n5. Instead of using a queue for each fault, we use one FIFO\nqueue to store all fault messages, so the fault message sent\nfrom the activity machine to its parent depends on which\nchild's fault comes first.\n1 -4244-0470-3\/07\/$20.00 \u00a92007 IEEE 149\n2007 Inaugural IEEE International Conference on Digital Ecosystems and Technologies (IEEE DEST 2007)\n* Interruptions\nBPEL has two kinds of Interruptions. First, when a ter-\nmination message is thrown when a terminate activity is\nreached, the process machine ends abnormally, and a stop\nmessage is propagated downstream. Second, when a fault is\nthrown by a throw activity, the normal activity needs to stop\nbefore the fault handler starts. The fault is propagated up-\nstream until it can be caught by a scope or process activity\nthat has the fault handler for this fault. When a structured\nactivity is stopped, all its children need to be stopped first.\nThis is modelled by propagating a stop message down-\nstream. The priority of a stop message is captured by adding\nlogical-AND together with logical-NOT to transition input\nevents. A stop message has higher priority than a fault mes-\nsage, which in turn has higher priority than a normal mes-\nsage. In (3) of Fig. 5, transition ti.o is triggered when either a\nstop or a term message arrives. The ti.1 will be triggered\nwhen it does not receive a fault message from its child, and\nonly when neither stop nor term message arrives. It indi-\ncates that a fault will not be propagated when the machine\nis asked to stop or terminate. The ti2 indicates that a fault or\ninterruption message has higher priority than a normal in-\ncoming message.\nF. Common structured machine layout\nWith consideration to fault propagation and machine in-\nterruption, BPEL structured activities have a common ma-\nchine layout, shown in Fig. 6.\nFig.6 The common structured machine layout\nEach structured activity machine has a stopStatus local\nvariable. When the machine receives the children's done\nmessages, based on the value of stopStatus, the machine\nenters a normal or abnormal final state. Suppose M is a\nstructured machine, we can derive three scenarios from the\ncommon machine structure: 1) when M receives the chil-\ndren's done messages and the stopStaus is false (t1.2), it ends\nat normal final state s5,,; 2) when Mreceives a stop message\nfrom its parent, it propagates the message to its children\n(ti.0) and update the stopStatus to true. Given the true value\nof stopStatus, M enters the abnormal final state s1 after re-\nceiving its children's done messages (ti.1); 3) when M re-\nceives a fault from its children, it and forwards the message\nto its parent (t43), and follows the 2) scenario.\nG. Synchronization ofConcurrent Activities and Dead-\nPath-Elimination\nA set of links can be declared in the flow construct to ex-\npress the synchronization dependencies between activities\nwithin a flow. A link is a Boolean variable, and each link is\nassociated with a pair of source activity and target activity.\nFor instance, ifM and N are source and target activities of\nlinkl, respectively, linkl is Ms outgoing link with source\ntag, and As incoming link with target tag.\nThe synchronization between source and target activities\nis realized by setting and getting the link value. The source\nactivity sets the link to be true or false, and the target activ-\nity gets the link value. The target activity can start when 1)\nall the incoming links' values are defined by the source ac-\ntivities, and 2) its associated join-condition is satisfied,\nwhich is either an AND or OR logical constraint on link\nvalues. If the join-condition is false, the target activity will\nnot be executed and this effect will be propagated down-\nstream in the flow model. This is called Dead-Path-\nElimination in BPEL. We capture the dead-path-elimination\nfeature by updating the related links to false, and sending\nthe setLink messages to the target machines.\nThe target tag and source tag are standard elements of\nBPEL constructs, indicating each BPEL activity may or\nmay not have incoming links and outgoing links. To cap-\nture this feature, we use a separate linkWrapper machine to\nhandle links. When an activity has incoming or outgoing\nlinks, it will associate with a linkWrapper machine and a\ncore machine. The linkWrapper will be the core machine's\nparent. When an activity has no link, it is only associated\nwith a core machine. This separation simplifies the structure\nof a machine, and allows BPEL activities to share a com-\nmon machine structure for link handling.\ntype 1 - with targetLinks type 2 - no targetLink\nFig.7 The linkWrapper machines\nFig. 7 shows the two types of linkWrapper machine\nstructures, which covers the cases when an activity has tar-\nget links and no target link. We use the typel linkWrapper\nstructure as an illustration. Suppose B is the core machine\nand A is the linkWrapper machine for an activity, several\nscenarios can be derived from the machine structure.\nFirst, a normal scenario follows the path (to 1't 22 2t3.2tt)\nMachine A starts by receiving a start message from its par-\nent to1. It receives target link values from the link's source\nmachine, and if the links' values satisfy the join-condition, it\nstarts B (t22). Machine A sends its done message to its par-\nent after receiving B's done message (t3.2). If x and y are B's\ninput and output, respectively, then A will send x to B and\nreceive y from B. Thereafter, machine A sets the corre-\nsponding source link to true and the other source links to\nfalse, and sends the setlink messages to the links' target ma-\nchines (t4.,). Each outgoing transition of state S4 corre-\nsponds to a source link.\nSecond, alternative scenarios can be: 1) A is interrupted\nby a stop message from its parent (t2.o); 2) when the join-\ncondition is false, A updates all the source links to false and\nsends them to the links' target machines, and A ends abnor-\n1-4244-0470-3\/07\/$20.00 \u00a92007 IEEE 150\n2007 Inaugural IEEE International Conference on Digital Ecosystems and Technologies (IEEE DEST 2007)\nmally (t2 1); 3) when A is interrupted by a stop message from\nits parent after B started, it stops B(t3.0). After receiving B's\ndone message, A sends a done message to its parent (t3.1); 4)\nwhen A receives fault from B, it forwards the fault to its\nparent (t33) and follows scenario 3).\nH. Scope, Compensation and Fault Handling\nA scope has a primary activity that defines its normal be-\nhaviour, and it can optionally enclose eventHandlers (EHS),\nfaultHandlers (FH), and compensationHandler (CH) activi-\nties. In a scope, EHS runs concurrently with a primary ac-\ntivity. The right of Fig. 8 shows the hierarchy of invoking a\nCH. Only CH and FH are allowed to send a compensate\nmessage, and the target machine of this message must be a\nscope (scope2) immediately enclosed in the current scope\n(scopel). When receiving a compensation message, scope2\nstarts its CH to do the compensation.\nscope machine with EHS, FH, CH invoking compensation handler\nFig.8 Scope and Compensation\nThe left of Fig. 8 shows a scope machine with EHS, FH,\nand CH. When the scope is started, it starts the primary ma-\nchine and EHS (to1), it waits for the primary machine to fin-\nish at state S3. When it receives primary machine's done\nmessage, it disables EHS (t2.2). The machine enters S7 when\nthe EHS is done message (t3.2). If the scope does not receive\na compensate message when its EHS ends at S7, the execu-\ntion path is (t 1,t22, t3.2, t7.1). Otherwise, the execution path is\n(to. It2.2 t3.2 t7.02) A scope's CH is available for invocation\nonly when the scope completes normally. We model this by\nt7.0 and t8.2. When the scope receives a compensate message,\nit starts its CH (t7.0). The scope is done after the CH is done\n(t8.2).\nAlternatively, when the scope receives a fault, it stops its\nchildren and starts the FH (t2.3). When the primary machine\nand the EHS finish, it enables the FH (t4.0). The scope may\nreceive a fault re-throw from the FH, and it forwards the\nfault to its parent (t5.1). The scope ends when the FH fin-\nishes (t5.0). When the scope is interrupted to stop, the im-\nplicit 'bpws:forceTermination' faultHandler will run. For\nsimplicity, we do not model this implicitfaultHandler and\ninstead we use the stop message to stop its children, and the\ncommon machine structure for BPEL structured activities is\nalso used in scope.\nI. Multiple Threads ofMessage Event Handlers\nThe eventHandlers activity consists of a set of concurrent\nactivities onMessage and onAlarm activities. The onMes-\nsage and onAlarm activities handle external message events\nand system alarm events, respectively. An alarm event is\ncarried out at most once, while a message event can occur\nmultiple times when the scope is active. We model this by\nassociating the eventHandlers activity with EHS machine,\neach onMessage activity with a message event handler ma-\nchine (MEH), each onAlarm activity with an alarm event\nhandler machine (AEH), and each thread of onMessage ac-\ntivity with a MEH thread machine (MEHT). Each thread\ntakes care of one message instance.\nto. ME4H to6.0\nt2.F t2.4 so t2 ms2 2is2st2 2.2 t2.3 . t61\nt3.1\n~~~~~t3.1 4st t3. sh s4 s6\nt3. t3.0O.t3.2 t3.2 t63.O t4 0 t.\ns4 EHS MEH\nFig.9 EHS and MEH machines\nFig. 9 shows the EHS, MEH, and MEHT machines. For\nthe EHS machine, we only show the normal scenario for\nsimplicity. The parent of EHS is a scope machine and the\nchildren of EHS are MEHs and AEHs. When receiving a\nstart message from the scope, EHS starts its children (to.1).\nThe EHS will not end until it receives a disable message\nfrom the scope. When EHS receives a disable message, it\nforwards the message to its children (t22). When EHS re-\nceives its children's done messages, it sends a done message\nto its parent (t3.2).\nFor the MEH machine, since a MEH may start a thread\nfor each message event instance, and the thread number is\nunknown, we model this by adding local variables count for\nthe current thread number.\nThe normal scenario of MEH is (to, t1Z t23 tl3o t3.2)\nWhen it receives a start message from the parent, the count\nis initiated to zero (to1). When it receives an external mes-\nsage, it increases the \\textit{countj by 1 and starts a new\nthread as a child machine (t21). The machines waits for an\nexternal message event to arrive at s2, a new thread is cre-\nated for each message instance (t21). When it receives a dis-\nable message from its parent and the count is not zero, it\nenters state s3 to wait for its child machine to finish (t2.3).\nWhen one of its children finishes, it decreases the count by\n1, until all the children finish (t3.0). When the count is zero,\nMEH ends at a normal final state (t3.2).\nAn alternative scenario is (to 1, t2 where the machine is\ndisabled before starting any thread. The other two alterna-\ntive scenarios contain transition sequence (t40, t4 1, t6O, t6 1),\nwhen the machine is interrupted by a stop message (t2.2, t3.1),\nit stops its child machine one by one until all the children\nhave been stopped (t4.0), then it enters state S6 to wait for its\nchildren to finish (t41). Similar to t3.0 and t3.2, when one of\nits children finishes, it decreases the count by 1 until all the\nchildren finish (t6.0). MEH ends at a normal final state (t61).\nIV. RELATED WORK\nIn the literature, there are a number of proposals for\n1-4244-0470-3\/07\/$20.00 \u00a92007 IEEE 151\n2007 Inaugural IEEE International Conference on Digital Ecosystems and Technologies (IEEE DEST 2007)\nBPEL fornal semantics, such as process algebras, petri\nnets, and automata. [8,10] give good reviews of the existing\nweb services techniques. Ferrara [4] uses the process alge-\nbra LOTOS as the fornal model and toolbox CADP is used\nas the verification engine. In LOTOS, rendezvous is used\nfor the process communication model, and the disabling\noperator is used to capture the BPEL interruptions. Xu [12]\napplies process algebra Pi-calculus as the fornal model and\nNuSMV model checker as the verification engine. The\nprocess algebra approaches cover most BPEL features.\nWombacher [11] maps BPEL into deterninistic finite state\nautomata for the matchmaking of web service composition.\nFoster [5] uses FSPs (Finite State Processes) as the BPEL\nfornal semantics. Both fornalisms abstract from data. Fu\nand Bultan [6] propose guarded automata (GA) with data\nand abstract from internal BPEL activity, and use the SPIN\nmodel checker as the verification engine. Their GA only\ncovers a core subset of BPEL, and they omit the interac-\ntions between internal BPEL activities.\nProcess algebra approaches have the advantage that the\ncomposition operators of process algebras are convenient in\ncapturing the semantics of BPEL structured activities, and\nthey support simulation and bi-simulation analysis, which\nare useful for model substitution and refinement. However,\nfor the purpose of verification and testing, the automaton\nfornalism is especially attractive due to the straight usage\nof model checking tools. The model substitution and re-\nfinement is not the focus of our test framework. Therefore,\nwe have investigated the usability of automata approaches.\nWe summarize our differences from the existing works as\nfollows. 1) WSA supports propositional input events, which\ncan reduce unnecessary machine state space and can capture\nmost BPEL features. Most automata based approaches only\ncover a core subset of BPEL. 2) WSA captures both BPEL\ncontrol flow and data flow explicitly, so that either control\nor date related errors in BPEL can be verified. 3) Most ap-\nproaches do not consider the interactions between internal\nBPEL activities explicitly, but leave them to interact implic-\nitly by shared variables. In the theoretical point of view, we\nbelieve it is clearer and simpler to provide a uniforn means\nof interaction, instead of considering both shared variable\nand message passing mechanisms.\nV. CONCLUSION AND FUTURE WORK\nWe present Web Service Automata as a fornal semantics\nfor web services, and analyse various features of BPEL.\nThe web service automaton is more general than the exist-\ning automata-based semantics in that it can model most fea-\ntures of BPEL and it allows verification of BPEL control\nand data flows. We encoded the web service automata into\nXML files. Also, we implemented a front end mapping\nfrom BPEL to web service automata, and the back end\nmapping from web service automata to the input languages\nof NuSMV and SPIN model checkers [2,7]. Based on test\ngeneration framework was developed as an Eclipse plug-in\n[14], and it is part of the DBEStudio delivery for the EU\nproject [3].\nAn open issue is to ensure the correctness of fornal\nmodels, i.e. preservation of the BPEL semantics. We can\npartially verify the fornal models, by defining some BPEL\nfeatures as system properties in temporal logic and model\ncheck the fornal models against these properties. An exten-\nsion of this work is to apply our fornal model to a choreog-\nraphy language such as WS-CDL[9]. We believe the same\napproach can be used due to the similar features of WS-\nCDL and BPEL.\nACKNOWLEDGMENT\nThis work is supported by the EU FP6 funded project\nDigital Business Ecosystem (project No. 507953).\nREFERENCES\n[1] T. Andrews, F. Curbera, H. Dholakia, Y. Goland, J. Klein, F. Ley-\nmann, K. Liu, D. Roller, S. Thatte, and S. Weerawarana. Business\nprocess execution language for web services version 1.1. May 2003.\n[2] A. Cimatti, E. M. Clarke, F. Giunchiglia, and M. Roveri, \"Nusmv:a\nnew symbolic model verifier,\" in Proc. of CA V. Springer-Verlag,\n1999, p. 495.\n[3] Digital Business Ecosystems (DBE)., available: http:\/\/www.digital-\necosystem.org.\n[4] A. Ferrara, \"Web services:a process algebra approach,\" in Proc. Of\nICSOC. ACM Press, 2004, p. 242.\n[5] H. Foster, S. Uchitel, J. Magee, and J. Kramer, \"Model-based analysis\nof obligations in web service choreography,\" in Proc. ofAICT-ICIW.\nIEEE Computer Society, 2006, p. 149.\n[6] X. Fu, T. Bultan, and J. Su, \"Synchronizability of conversations\namong web services,\" IEEE Transactions on Software Engineering,\nvol. 31, no. 12, pp. 1042-1055, 2005.\n[7] G. J. Holzmann, The SPIN Model Checker: Primer and Reference\nManual. Addison-Wesley Professional, 2003.\n[8] R. Hull and J. Su, \"Tools for design of composite web services,\" in\nProc. ofSIGMOD. ACM Press, 2004, p. 958.\n[9] N. Kavantzas, D. Burdett, and G. Ritzinger. Web services choreogra-\nphy description language version 1.0. April 2004.\n[10] N. Milanovic and M. Malek, \"Current solutions for web service com-\nposition,\" IEEE Internet Computing, vol. 08, no. 6, pp. 51-59, 2004.\n[11] A. Wombacher, P. Fankhauser, and E. Neuhold, \"Transforming bpel\ninto annotated deterministic finite state automata for service discov-\nery,\" in Proc. ofICWS. IEEE Computer Society, 2004, p. 316.\n[12] K. Xu, Y. Liu, and G. Pu, \"Formalization, verification and restructur-\ning of bpel models with pi calculus and model checking,\" IBM,\nTechnical Rep., 2006.\n[13] Y. Zheng and P. Krause, \"An automatic test generation framework\nfor bpel web services,\" University of Surrey, Technical Rep., 2006.\n[14] Y. Zheng and P. Krause, \"A model checking based test case genera-\ntion framework for web services,\" in Proc. ofITNG. IEEE Computer\nSociety, 2007.\ncoverage criteria such as state coverage and transition cov-\nerage for control flow, and du-path coverage for data flow,\nmodel checkers can generate counter-examples. The test\ncases can be extracted from the counterexamples. This test\n1-4244-0470-3\/07\/$20.00 \u00a92007 IEEE 152\n"}