{"doi":"10.1017\/S0960129507006299","coreId":"193712","oai":"oai:lra.le.ac.uk:2381\/1818","identifiers":["oai:lra.le.ac.uk:2381\/1818","10.1017\/S0960129507006299"],"title":"An Algebraic Semantics of Event-based Architectures","authors":["Fiadeiro, Jos\u00e9 Luiz","Lopes, Ant\u00f3nia"],"enrichments":{"references":[{"id":44674542,"title":"(eds.) Model Checking Software.","authors":[],"date":null,"doi":"10.1007\/3-540-44829-2","raw":"and Rajamani, S. (eds.) Model Checking Software. Springer-Verlag Lecture Notes in Computer Science 2648 166\u2013180.","cites":null},{"id":44674537,"title":"A Formal Approach to Service Component Architecture.","authors":[],"date":"2006","doi":"10.1007\/11841197_13","raw":"Fiadeiro, J. L., Lopes, A. and Bocchi, L. (2006) A Formal Approach to Service Component Architecture. In: Bravetti, M., Nez, M. and Zavattaro, G. (eds.) Web Services and Formal Methods, Third International Workshop. Springer-Verlag Lecture Notes in Computer Science 4184 193\u2013213.","cites":null},{"id":44674540,"title":"A mathematical semantics for architectural connectors.","authors":[],"date":"2003","doi":"10.1007\/978-3-540-45191-4_5","raw":"Fiadeiro, J. L., Lopes, A. and Wermelinger, M. (2003) A mathematical semantics for architectural connectors. In: Backhouse, R. and Gibbons, J. (eds.) Generic Programming. Springer-Verlag Lecture Notes in Computer Science 2793 190\u2013234.","cites":null},{"id":44674545,"title":"A superimposition control construct for distributed systems.","authors":[],"date":"1993","doi":"10.1145\/169701.169682","raw":"Katz, S. (1993) A superimposition control construct for distributed systems. ACM TOPLAS 15 (2) 337\u201335.","cites":null},{"id":44674548,"title":"Adding mobility to software architectures.","authors":[],"date":"2006","doi":"10.1016\/j.scico.2005.10.010","raw":"Lopes, A. and Fiadeiro, J. L. (2006) Adding mobility to software architectures. Science of Computer Programming 61 (2) 114\u2013135.","cites":null},{"id":44674547,"title":"Algebraic semantics of design abstractions for context-awareness.","authors":[],"date":"2005","doi":"10.1007\/978-3-540-31959-7_5","raw":"Lopes, A. and Fiadeiro, J. L. (2005) Algebraic semantics of design abstractions for context-awareness. In: Fiadeiro, J. L., Mosses, P. and Orejas, F. (eds.) Algebraic Development Techniques. SpringerVerlag Lecture Notes in Computer Science 3423 79\u201393.","cites":null},{"id":44674544,"title":"Categorical foundations for general systems theory.","authors":[],"date":"1973","doi":"10.1007\/978-1-4757-0555-3_18","raw":"Goguen, J. (1973) Categorical foundations for general systems theory. In: Pichler, F. and Trappl, R. (eds.) Advances in Cybernetics and Systems Research, Transcripta Books 121\u2013130.","cites":null},{"id":44674533,"title":"Categories for Software Engineering,","authors":[],"date":"2004","doi":null,"raw":"Fiadeiro, J. L. (2004) Categories for Software Engineering, Springer-Verlag.","cites":null},{"id":44674550,"title":"Computation orchestration: A basis for wide-area computing.","authors":[],"date":"2006","doi":"10.1007\/s10270-006-0012-1","raw":"Misra, J. and Cook, W. (2006) Computation orchestration: A basis for wide-area computing. Journal of Software and Systems Modelling 6 (1) 83\u2013110.","cites":null},{"id":44674529,"title":"Design and evaluation of a wide-area event notification service.","authors":[],"date":"2001","doi":"10.1109\/fits.2003.1264940","raw":"Carzaniga, A., Rosenblum, D. and Wolf, A. (2001) Design and evaluation of a wide-area event notification service. ACM Transactions on Computer Systems 19 283\u2013331.","cites":null},{"id":44674528,"title":"Evaluating and improving the automatic analysis of implicit invocation systems. In:","authors":[],"date":"2003","doi":"10.1145\/949952.940083","raw":"Bradbury, J. and Dingel, J. (2003) Evaluating and improving the automatic analysis of implicit invocation systems. In: Proceedings of the 11th ACM SIGSOFT Symposium on Foundations of Software Engineering 2003 held jointly with 9th European Software Engineering Conference, ACM Press 78\u201387.","cites":null},{"id":44674543,"title":"Formalizing design spaces: Implicit invocation mechanisms.","authors":[],"date":"1991","doi":"10.1007\/3-540-54834-3_5","raw":"Garlan, D. and Notkin, D. (1991) Formalizing design spaces: Implicit invocation mechanisms. In: Prehn, S. and Toetenel, W. J. (eds.) VDM\u201991: Formal Software Development Methods. SpringerVerlag Lecture Notes in Computer Science 551 31\u201344.","cites":null},{"id":44674531,"title":"Fundamentals of Algebraic Specification 1: Equations and Initial Semantics,","authors":[],"date":"1985","doi":"10.1007\/978-3-642-69962-7_4","raw":"Ehrig, H. and Mahr, B. (1985) Fundamentals of Algebraic Specification 1: Equations and Initial Semantics, EATCS Monographs on Theoretical Computer Science 6.","cites":null},{"id":44674526,"title":"Generic support for distributed applications.","authors":[],"date":"2004","doi":"10.1007\/978-3-662-10876-5","raw":"Alonso, G., Casati, F., Kuno, H. and Machiraju, V. (2004) Web Services, Springer-Verlag. Bacon, J., Moody, K., Bates, J., Hayton, R., Ma, C., McNeil, A., Seidel, O. and Spiteri, M. (2000) Generic support for distributed applications. IEEE Computer 33 (3) 68\u201376.","cites":null},{"id":44674535,"title":"IP address: 143.210.121.140 An algebraic semantics of event-based architectures 1073","authors":[],"date":"2013","doi":null,"raw":"http:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140 An algebraic semantics of event-based architectures 1073 Fiadeiro, J. L. and Lopes, A. (2006) A formal approach to event-based architectures. In: Baresi, L. and Heckel, R. (eds.) Fundamental Aspects of Software Engineering. Springer-Verlag Lecture Notes in Computer Science 3922 18\u201332.","cites":null},{"id":44674541,"title":"Model checking publish-subscribe systems.","authors":[],"date":"2003","doi":"10.1007\/3-540-44829-2_11","raw":"Garlan, D., Khersonsky, S. and Kim, J. (2003) Model checking publish-subscribe systems. In: Ball, T.","cites":null},{"id":44674539,"title":"Modules for service-component architectures.","authors":[],"date":"2007","doi":"10.1007\/978-3-540-71998-4_3","raw":"Fiadeiro, J. L., Lopes, A. and Bocchi, L. (2007) Modules for service-component architectures. In: Fiadeiro, J. and Schobbens, P-Y. (eds.) Current Trends in Algebraic Development Techniques. Springer-Verlag Lecture Notes in Computer Science 4409 37\u201355.","cites":null},{"id":44674551,"title":"Reconciling environment integration and software evolution.","authors":[],"date":"1992","doi":"10.1145\/131736.131744","raw":"Sullivan, K. and Notkin, D. (1992) Reconciling environment integration and software evolution. ACM TOSEM 1 (3) 229\u2013268.","cites":null},{"id":44674534,"title":"Semantics of architectural connectors.","authors":[],"date":"1997","doi":"10.1007\/bfb0030622","raw":"Fiadeiro, J. L. and Lopes, A. (1997) Semantics of architectural connectors. In: Bidoit, M. and Dauchet, M. (eds.) TAPSOFT: Theory and Practice of Software Development. Springer-Verlag Lecture Notes in Computer Science 1214 505\u2013519.","cites":null},{"id":44674546,"title":"Superposition: composition versus refinement of nondeterministic action-based systems.","authors":[],"date":"2004","doi":"10.1007\/s00165-003-0021-6","raw":"Lopes, A. and Fiadeiro, J. L. (2004) Superposition: composition versus refinement of nondeterministic action-based systems. Formal Aspects of Computing 16 (1) 5\u201318.","cites":null},{"id":44674549,"title":"Taxonomy of distributed event-based programming systems. In:","authors":[],"date":"2002","doi":"10.1109\/icdcsw.2002.1030833","raw":"Meier, R. and Cahill, V. (2002) Taxonomy of distributed event-based programming systems. In: Proceedings of the International Workshop on Distributed Event-Based Systems, IEEE Computer Society 585\u2013588.","cites":null},{"id":44674532,"title":"The many faces of publish\/subscribe.","authors":[],"date":"2003","doi":"10.1145\/857076.857078","raw":"Eugster, P., Felber, P., Guerraoui, R. and Kermarrec, A.-M. (2003) The many faces of publish\/subscribe. ACM Computing Surveys 35 (2) 114\u2013131.","cites":null},{"id":44674530,"title":"Towards a formal treatment of implicit invocation.","authors":[],"date":"1998","doi":"10.1007\/s001650050011","raw":"Dingel, J., Garlan, D., Jha, S. and Notkin, D. (1998) Towards a formal treatment of implicit invocation. Formal Aspects of Computing 10 193\u2013213.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-09-21","abstract":"We propose a mathematical semantics for event-based architectures that serves two main purposes: to characterise the modularisation properties that result from the algebraic structures induced on systems by this discipline of coordination; and to further validate and extend the categorical approach to architectural modelling that we have been building around the language CommUnity with the \u2018implicit invocation\u2019, also known as \u2018publish\/subscribe\u2019 architectural style. We then use this formalisation to bring together synchronous and asynchronous interactions within the same modelling approach. We see this effort as a first step towards a form of engineering of architectural styles. Our approach adopts transition systems extended with events as a mathematical model of implicit invocation, and a family of logics that support abstract levels of modelling.Peer-reviewedPublisher Versio","downloadUrl":"http:\/\/journals.cambridge.org\/action\/displayAbstract?fromPage=online&aid=1395560","fullTextIdentifier":"https:\/\/lra.le.ac.uk\/bitstream\/2381\/1818\/1\/10.1017_S0960129507006299.pdf","pdfHashValue":"606f58f278d146f477f91f49e979319334edede3","publisher":"Cambridge University Press (CUP)","rawRecordXml":"<record><header><identifier>\n        \n            \n                oai:lra.le.ac.uk:2381\/1818<\/identifier><datestamp>\n                2014-03-08T02:01:21Z<\/datestamp><setSpec>\n                com_2381_316<\/setSpec><setSpec>\n                com_2381_9549<\/setSpec><setSpec>\n                col_2381_1116<\/setSpec>\n            <\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:doc=\"http:\/\/www.lyncode.com\/xoai\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n            \nAn Algebraic Semantics of Event-based Architectures<\/dc:title><dc:creator>\nFiadeiro, Jos\u00e9 Luiz<\/dc:creator><dc:creator>\nLopes, Ant\u00f3nia<\/dc:creator><dc:description>\nWe propose a mathematical semantics for event-based architectures that serves two main purposes: to characterise the modularisation properties that result from the algebraic structures induced on systems by this discipline of coordination; and to further validate and extend the categorical approach to architectural modelling that we have been building around the language CommUnity with the \u2018implicit invocation\u2019, also known as \u2018publish\/subscribe\u2019 architectural style. We then use this formalisation to bring together synchronous and asynchronous interactions within the same modelling approach. We see this effort as a first step towards a form of engineering of architectural styles. Our approach adopts transition systems extended with events as a mathematical model of implicit invocation, and a family of logics that support abstract levels of modelling.<\/dc:description><dc:description>\nPeer-reviewed<\/dc:description><dc:description>\nPublisher Version<\/dc:description><dc:date>\n2009-12-08T16:14:04Z<\/dc:date><dc:date>\n2009-12-08T16:14:04Z<\/dc:date><dc:date>\n2007-09-21<\/dc:date><dc:type>\nArticle<\/dc:type><dc:identifier>\nMathematical Structures in Computer Science, 2007, 17 (5), pp.1029-1073<\/dc:identifier><dc:identifier>\n0960-1295<\/dc:identifier><dc:identifier>\nhttp:\/\/hdl.handle.net\/2381\/1818<\/dc:identifier><dc:identifier>\nhttp:\/\/journals.cambridge.org\/action\/displayAbstract?fromPage=online&aid=1395560<\/dc:identifier><dc:identifier>\n10.1017\/S0960129507006299<\/dc:identifier><dc:identifier>\n1469-8072<\/dc:identifier><dc:language>\nen<\/dc:language><dc:relation>\nRAE 2007<\/dc:relation><dc:rights>\nCopyright \u00a9 2007, Cambridge University Press (CUP). Deposited with reference to the publisher\u2019s open access archiving policy.<\/dc:rights><dc:publisher>\nCambridge University Press (CUP)<\/dc:publisher>\n<\/oai_dc:dc>\n<\/metadata>\n        <\/record>","journals":[{"title":null,"identifiers":["0960-1295","1469-8072","issn:0960-1295","issn:1469-8072"]}],"language":{"code":"en","id":9,"name":"English"},"relations":["RAE 2007"],"year":2007,"topics":[],"subject":["Article"],"fullText":"Mathematical Structures in Computer\nScience\nhttp:\/\/journals.cambridge.org\/MSC\nAdditional services for Mathematical Structures in\nComputer Science:\nEmail alerts: Click here\nSubscriptions: Click here\nCommercial reprints: Click here\nTerms of use : Click here\nAn algebraic semantics of event-based architectures\nJOS\u00c9 LUIZ FIADEIRO and ANT\u00d3NIA LOPES\nMathematical Structures in Computer Science \/ Volume 17 \/ Issue 05 \/ October 2007, pp 1029 - 1073\nDOI: 10.1017\/S0960129507006299, Published online: 21 September 2007\nLink to this article: http:\/\/journals.cambridge.org\/abstract_S0960129507006299\nHow to cite this article:\nJOS\u00c9 LUIZ FIADEIRO and ANT\u00d3NIA LOPES (2007). An algebraic semantics of event-based\narchitectures. Mathematical Structures in Computer Science, 17, pp 1029-1073 doi:10.1017\/\nS0960129507006299\nRequest Permissions : Click here\nDownloaded from http:\/\/journals.cambridge.org\/MSC, IP address: 143.210.121.140 on 03 Sep 2013\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nMath. Struct. in Comp. Science (2007), vol. 17, pp. 1029\u20131073. c\u00a9 2007 Cambridge University Press\ndoi:10.1017\/S0960129507006299 Printed in the United Kingdom\nAn algebraic semantics of event-based architectures\nJOS E\u00b4 LUIZ FIADEIRO\u2020 and ANTO\u00b4NIA LOPES\u2021\n\u2020Department of Computer Science, University of Leicester, University Road,\nLeicester LE1 7RH, U.K.\nEmail: jose@mcs.le.ac.uk\n\u2021Department of Informatics, Faculty of Sciences, University of Lisbon, Campo Grande,\n1749-016 Lisboa, Portugal\nEmail: mal@di.fc.ul.pt\nReceived 2 May 2006; revised 11 December 2006; first published online 21 September 2007\nWe propose a mathematical semantics for event-based architectures that serves two main\npurposes: to characterise the modularisation properties that result from the algebraic\nstructures induced on systems by this discipline of coordination; and to further validate and\nextend the categorical approach to architectural modelling that we have been building\naround the language CommUnity with the \u2018implicit invocation\u2019, also known as\n\u2018publish\/subscribe\u2019 architectural style. We then use this formalisation to bring together\nsynchronous and asynchronous interactions within the same modelling approach. We see\nthis effort as a first step towards a form of engineering of architectural styles. Our approach\nadopts transition systems extended with events as a mathematical model of implicit\ninvocation, and a family of logics that support abstract levels of modelling.\n1. Introduction\nEvent-based interactions are now established as a major paradigm for large-scale distrib-\nuted applications (see, for example, Bacon et al. (2000), Carzaniga et al. (2001), Eugster\net al. (2003), Garlan and Notkin (1991) and Meier and Cahill (2002)). In this paradigm,\ncomponents may declare their interest in being notified when certain events are published\nby other components of the system. Typically, components publish events in order to\ninform their environment that something has occurred that is relevant for the behaviour\nof the entire system. Events can be generated either in the internal state of the components\nor in the state of other components with which they interact.\nAlthough Sullivan and Notkin\u2019s seminal paper (Sullivan and Notkin 1992) focuses on\ntool integration and software evolution, the paradigm is much more general: components\ncan be all sorts of run-time entities. What is important is that components do not know the\nidentity, or even the existence, of the publishers of any events they subscribe to, or the sub-\nscribers of any events that they publish. In particular, event notification and propagation\nare performed asynchronously, that is, the publisher cannot be prevented from generating\nan event by the fact that given subscribers are not ready to react to the notification.\nEvent-based interaction has also been recognised as an \u2018abstract\u2019 architectural style,\nthat is, as a means of coordinating the behaviour of components during high-level design.\nThe advantages of adopting such a style so early in the development process stem from\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1030\nexactly the same properties recognised for middleware:\n\u2014 loose coupling allows better control on the structural and behavioural complexity of\nthe application domain;\n\u2014 domain components can be modelled independently and easily integrated or removed\nwithout disturbing the whole system.\nPrecisely these claims can be found in Sullivan and Notkin (1992) applied to the\ndevelopment of integrated environments but, as already mentioned, they should derive\nfrom the structural properties that the paradigm induces in more general classes of\nsystems.\nHowever, in spite of these advantages and its wide acceptance, implicit invocation\nremains relatively poorly understood. In particular, its structural properties as an archi-\ntectural style remain to be clearly stated and formally verified. Despite the merits of\nseveral efforts towards providing methodological principles and formal semantics such as\nDingel et al. (1998), including recent incursions in the use of model-checking techniques\nfor reasoning about such systems (Bradbury and Dingel 2003; Garlan et al. 2003), we are\nstill far from an accepted \u2018canonical\u2019 semantic model over which all these efforts can be\nbrought together to provide effective support and to formulate methodological principles\nthat can steer development independently of specific choices of middleware.\nThis paper is an extended version of Fiadeiro and Lopes (2006) in which we presented\ninitial contributions in this direction by investigating how event-based interactions can be\nformalised in a categorical setting similar to the one that we started developing in Fiadeiro\nand Lopes (1997) around the language CommUnity. As with CommUnity, our goal is not\nto provide a full-fledged architectural description language but to restrict ourselves to a\ncore set of primitives and a reduced notation that can capture the bare essentials of an\narchitectural style. The use of category theory (Fiadeiro 2004) is justified by the fact that\nit provides a mathematical toolbox geared to formalising notions of structure, namely\nthose that arise in system modelling in a wide sense such as superposition (Katz 1993).\nWe take this formalisation effort a step further in this paper and address two different\nbut interrelated aspects of event-based architectures. On the one hand, we provide a\nmathematical model of the computational aspects using a new extension of transition\nsystems with event publication, notification and handling. On the other hand, we address\n\u2018implicit-invocation\u2019 as a discipline of decomposition and interconnection, that is, we\ncharacterise the modularisation properties that result from the algebraic structures induced\non systems by this discipline of coordination. In particular, we justify a claim made\nin Sullivan and Notkin (1992) about the externalisation of mediators: \u2018Applying this\napproach yields a system composed of a set of independent and visible [tool] components\nplus a set of separate, or externalised, integration components, which we call mediators\u2019.\nOur interest is in investigating and assigning a formal meaning to notions such as\n\u2018independent\u2019, \u2018separate\u2019 and \u2018externalised\u2019, and in characterising the way they can be\nderived from implicit invocation. Finally, we use the proposed formal model to investigate\nextensions of event-based interactions with i\/o-communication and action synchronisation\n(rendezvous) as available in CommUnity. We see this as a first step towards a formal\napproach to the engineering of architectural styles.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1031\nOrganisation of the paper\nIn Section 2, we introduce our primitives for modelling publish\/subscribe interactions\nusing a minimal language in the style of CommUnity, which we call e-CommUnity. In\nSection 3, we provide a mathematical semantics for this language that is based on transition\nsystems extended with events, including their publication and handling. In Section 4, we\ndefine the category over which we formalise architectural properties. We show how the\nnotion of morphism can be used to identify components within systems and the way\nin which they can subscribe events published by other components. We also show how\nevent bindings can be externalised and made explicit in configuration diagrams. Section 5\ndefines the notion of refinement through which under specification may be removed from\ndesigns and investigates compositionality of refinement with respect to superposition as\ncaptured through the morphisms studied in Section 4. In Section 6, we analyse how we can\nuse the categorical formalisation to combine event-based interactions with synchronous\ncommunication, namely i\/o interconnections and action synchronisation as available in\nCommUnity. Appendix A provides a glossary collecting together the different terms used\nin the definition of the syntax and semantics of e-CommUnity. Finally, the proofs of the\nmain results of Section 5 are given in Appendix B.\n2. Event-based designs\nIn e-CommUnity, we model components that keep a local state and perform services\nthat can change their state and publish given events. Although we are addressing service-\noriented architectures with similar mathematical techniques (for preliminary work in this\ndirection, see Fiadeiro et al. (2006; 2007)), this paper is concerned only with event-based\ninteractions in general. Therefore, we will use the term service in a rather loose way, that\nis, without committing to a full service-oriented approach in the sense of, say, web-services\n(Alonso et al. 2004) or wide-area computing (Misra and Cook 2006).\nComponents can also subscribe to a number of events. Upon notification that a\nsubscribed event has taken place, a component invokes one or more services. If, when\nscheduled for execution, a service is enabled, it is executed, which may change the local\nstate of the component and publish new events.\nWe begin the discussion of our approach by showing how we can model what is\nconsidered to be the \u2018canonical\u2019 example of event-based interactions: the set-counter.\nConsider first the design presented in Figure 1. This is the design of a component Set that\nkeeps a set elems of natural numbers as part of its local state. This component subscribes\ntwo kinds of events, doInsert and doDelete, each of which carries a natural number as a\nparameter. Two other kinds of events, inserted and deleted, are published by Set. Each of\nthese events also carries a natural number as a parameter.\nAs a component, Set can perform two kinds of services: insert and delete. These services\nare invoked upon notification of events doInsert and doDelete, respectively. When invoked,\ninsert checks if the parameter of doInsert is already in elems; if not, it adds it to elems\nand publishes an inserted event with the same parameter. The invocation of delete has a\nsimilar behaviour.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1032\ndesign Set is\npublish inserted\npar which:nat\npublish deleted\npar which:nat\nsubscribe doInsert\npar which:nat\ninvokes insert\nhandledBy insert?\nwhich=insert.lm\nsubscribe doDelete\npar which:nat\ninvokes delete\nhandledBy delete?\nwhich=delete.lm\nstore elems: set(nat)\nprovide insert\npar lm:nat\nassignsTo elems\nguardedBy [lm elems,false]\neffects elems\u2019={lm} elems\ninserted! inserted.which=lm\nprovide delete\npar lm:nat\nassignsTo elems\nguardedBy lm elems\neffects elems\u2019=elems\\{lm}\ndeleted! deleted.which=lm\nFig. 1. The design of Set\nWe formalise the languages that are used for specifying component behaviour in\nSection 3, together with a denotational semantics for the underlying computational\nmodel. Meanwhile, we will just provide an informal overview of all the aspects involved:\n\u2014 The events that the component publishes are declared under publish. Events are\npublished when services execute. The way a service publishes a given event e is\ndeclared in the specification provide of the service under effects using the proposition\ne! to denote the publication of e.\n\u2014 The events that the component subscribes are declared under subscribe. The services\nthat can be invoked when handling such an event are declared under invokes. Given a\nservice s, we use s? to denote its invocation when specifying how the notification that\nthe event has taken place is handled, which we do under handledBy.\n\u2014 Parameter passing is made explicit through the expressions used when specifying how\nevent notifications are handled and events are published. For instance, the clause\ninserted.which = lm in the definition of the effects of insert means that the event\ninserted is published with its parameter which equal to the value of the parameter\nlm of insert. In a similar way, the clause which = insert.lm in the specification of\ndoInsert means that the parameter which is passed on to the service insert with the\nsame value as lm. Because we are providing high-level designs of components, we are\nnot saying how such properties are guaranteed, that is, what mechanism is being used\nfor parameter passing.\n\u2014 Designs can be under specified, leaving room for further design decisions to be made\nduring development. Therefore, we allow for arbitrary expressions to be used when\nspecifying how parameters are passed, events are handled and services change the\nstate.\n\u2014 Under store, we identify the state variables (variables for short) of the component;\nstate is local in the sense that the services of a component cannot change the state\nvariables of other components.\n\u2014 We use assignsTo to identify the state variables that a service may change when it is\nexecuted, what we normally call the write-frame or domain of the service. Note that\nbecause designs can be under specified, the write frame of a service cannot be inferred\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1033\ndesign Set&Counter is\nstore elems: set(nat),\nvalue:nat\npublish&subscribe inserted\npar which:nat\ninvokes inc\nhandledBy inc?\npublish&subscribe deleted\npar which:nat\ninvokes dec\nhandledBy dec?\nsubscribe doInsert\npar which:nat\ninvokes insert\nhandledBy insert?\nwhich=insert.lm\nsubscribe doDelete\npar which:nat\ninvokes delete\nhandledBy delete?\nwhich=delete.lm\nprovide insert\npar lm:nat\nassignsTo elems\nguardedBy [lm elems,false]\neffects elems\u2019={lm} elems\ninserted! inserted.which=lm\nprovide delete\npar lm:nat\nassignsTo elems\nguardedBy lm elems\neffects elems\u2019=elems\\{lm}\ndeleted! deleted.which=lm\nprovide inc\nassignsTo value\neffects value\u2019=value+1\nprovide dec\nassignsTo value\neffects value\u2019=value-1\nFig. 2. The design of Set&Counter\nfrom the specification of its effects; it is possible for a specification not to state any\nproperties of the effects that a service has on a state variable belonging to its write\nframe, meaning that the specification is still open for further refinement.\n\u2014 When specifying the effects of services, we use primes to denote the values that state\nvariables take after the service is executed; as already mentioned, it is possible that\nthe effects of some services are not fully specified.\n\u2014 We use guardedBy to specify the enabling condition of a service, that is, the set of\nstates in which its invocation is accepted and the service is executed, implementing\nwhichever effects are specified. The specification consists of a pair of conditions [l, u]\nsuch that u implies l: when false, the lower-guard l implies that the service is not\nenabled; when true, the upper-guard u implies that the service is enabled. For instance,\nthe lower-guard of insert is lm \/\u2208elems meaning that the invocation of insert is refused\nwhen the element whose insertion is requested already belongs to the set; because the\nupper-guard is false, there is no commitment as to when the service is actually enabled.\nThis allows us to model sets that are bounded without committing to a specific bound,\nas well as sets that are subject to restrictions that we may wish to refine at later stages\nof development or leave to be decided at run time. When the two guards are the same,\nwe only indicate one condition \u2013 the enabling condition proper. This is the case for\ndelete, which is specified to be enabled if and only if the element whose deletion is\nbeing requested belongs to the set.\nConsider now the design presented in Figure 2. This is the design of a system in which\na counter subscribes inserted and deleted to count the number of elements in the set. This\ndesign illustrates how given events may be published and subscribed within the same\ncomponent; this is the case of inserted and deleted. Indeed, there are no restrictions as to\nthe size and role that components may take within a system: designs address large-grained\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1034\ndesign Set&Counter&Adder is\nstore elems: set(nat),\nvalue:nat, sum:nat\npublish&subscribe inserted\npar which:nat\ninvokes inc\nhandledBy inc?\ninvokes add\nhandledBy add?\nwhich=add.lm\npublish&subscribe deleted\npar which:nat\ninvokes dec\nhandledBy dec?\ninvokes sub\nhandledBy sub?\nwhich=sub.lm\nsubscribe doInsert\npar which:nat\ninvokes insert\nhandledBy insert?\nwhich=insert.lm\nsubscribe doDelete\npar which:nat\ninvokes delete\nhandledBy delete?\nwhich=delete.lm\nprovide insert\npar lm:nat\nassignsTo elems\nguardedBy [lm elems,false]\neffects elems\u2019={lm} elems\ninserted! inserted.which=lm\nprovide delete\npar lm:nat\nassignsTo elems\nguardedBy lm elems\neffects elems\u2019=elems\\{lm}\ndeleted! deleted.which=lm\nprovide inc\nassignsTo value\neffects value\u2019=value+1\nprovide add\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum+lm\nprovide sub\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum-lm\nprovide dec\nassignsTo value\neffects value\u2019=value-1\nFig. 3. The design of Set&Counter&Adder\ncomponents, what are sometimes called sub-systems, not just atomic components. We will\ndiscuss the mechanisms that are available for structuring and composing systems in\nSection 4.\nWe can keep extending the system by bringing in new components that subscribe given\nevents. For instance, we may wish to keep a record of the sum of all elements of the\nset by adding an adder that also subscribes inserted and deleted. This is captured by the\ndesign presented in Figure 3.\nThis example illustrates how a subscribed event can invoke more than one service\nand also how we can declare more than one handler for a given event subscription. For\ninstance, the event inserted invokes two services \u2013 inc, as before, but also add \u2013 and uses\ntwo handlers: one handler invokes add and the other invokes inc. Because each invocation\nhas a separate handler, they are independent in the sense that they take place at different\ntimes. This is different from declaring just one handler:\ninvokes inc, add\nhandledBy inc? add?  which=add.lm\nSuch a handler would require synchronous invocation of both services; this is useful\nwhen one wants to enforce given invariants, for which it may be important to make sure\nthat separate state components are updated simultaneously. For instance, we may wish to\nensure that the values of sum and value apply to the same set of elements so that we can\ncompute the average value of the elements in the set.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1035\nAs a design, Set&Counter&Adder (SCA) does not seem to provide any structure for the\nunderlying system: we seem to have lost the original Set as an autonomous component;\nand also where are the Counter and the Adder? Later in the paper, we show how\nthis system can be designed by interconnecting separate and independent components,\nincluding mediators in the sense of Sullivan and Notkin (1992). However, before we do\nthat, we will formalise the notion of design and propose a mathematical semantics for\nevent publication\/subscription and service invocation\/execution.\n3. A formal model for event-based designs\nIn order to provide a formal model for designs in e-CommUnity, we follow the categorical\nframework that we have adopted in previous papers for defining the syntax and semantics\nof specification and design languages (Fiadeiro 2004).\n3.1. Signatures\nWe begin by formalising the language that we use for defining designs, starting with\nthe data types and data type constructors. As can be seen in the examples discussed in\nthe previous section, data structures are used for defining the computational aspects of\ncomponent behaviour as well as for supporting interactions through parameter passing.\nIn order to remain independent of any specific language for the definition of the data\ncomponent of designs, we work over a fixed data signature \u03a3 = \u3008D, F\u3009, where D is a set\n(of sorts) and F is a D\u2217 \u00d7 D indexed family of sets (of operations), and a collection \u03a6 of\nfirst-order sentences specifying the functionality of the operations. We refer to this data\ntype specification by \u0398. We will refrain from expanding further on the algebraic aspects\nof data type specification, the theory of which can be found in textbooks such as Ehrig\nand Mahr (1985).\nFrom a mathematical point of view, designs are structures defined over signatures.\nDefinition 3.1. A signature is a tuple Q = \u3008V , E, S, P , T , A, G,H\u3009 where:\n\u2014 V is a D-indexed family of mutually disjoint finite sets (of state variables).\n\u2014 E is a finite set (of events).\n\u2014 S is a finite set (of services).\n\u2014 P assigns a D-indexed family of mutually disjoint finite sets (of parameters) to every\nservice s\u2208 S and to every event e\u2208E.\n\u2014 T : E \u2192 {pub, sub, pubsub} is a function classifying events as published (only),\nsubscribed (only) or both published and subscribed. We use Pub(E) to denote the\nset {e\u2208E : T (e) \u0007= sub} and Sub(E) for the set {e\u2208E : T (e) \u0007= pub}.\n\u2014 A : S \u2192 2V is a function returning the write frame (or domain) of each service.\n\u2014 H is a Sub(E)-indexed family of mutually disjoint finite sets (of handlers).\n\u2014 G assigns to every subscribed event e\u2208 Sub(E) and handler h\u2208H(e), a set G(e, h) \u2286 S\nconsisting of the services that can be invoked by that event through that handler.\nGiven that the sets H(e) are mutually disjoint, we simplify the notation and use G(h)\ninstead of G(e, h).\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1036\ndesign P is\nstore V\npublish e\npar p\np P( e )\ne Pub( E)\npar p\np P( e )\ninvokes s\nhandled By ( h)\nh H( e )\npublish&subscribe  e\ne Sub(E)\npar p\np P( e )\ninvokes  s\nhandled By ( h)\nh H( e )\nprovide  s\ne PubSub ( E)\npar p\np P( s )\nassignsTo A( s )\nguardedBy l ( s ) , u( s )\neffects ( s )\ns S\nsubscribe  e\n\u03b3 \u03b3\n\u03b7\n\u03b7\nFig. 4. An e-CommUnity design.\nEvery state variable v is typed with a sort, which is an element of D and which we\ndenote by sort(v); the set of variables whose type is d is Vd. All these sets are mutually\ndisjoint, meaning that variables of different sorts have different names.\nThe mapping P defines, for every event and service, the name and the type of its\nparameters, that is, P (s)d (respectively, P (e)d) is the set of parameters of service s\n(respectively, event e) that are of sort d; as for variables, we use sort(p) to indicate\nthe sort of parameter p. Again, the sets (P (s)d\u2208D)s\u2208S and (P (e)d\u2208D)e\u2208E are assumed to be\nmutually disjoint. This is why, for ease of presentation, we have used the \u2018dot-notation\u2019\naccording to which the \u2018official\u2019 name of, for instance, the parameter which of event\ninserted is inserted.which.\nWe also assume that the sets of variables and parameters are mutually disjoint and\ndisjoint from the sets of events, services and handlers. In other words, the same name\ncannot be used for different entities.\nWe use T to classify events as pub (published only), sub (subscribed only) or pub-sub\n(both published and subscribed). For instance, in SCA we have:\n\u2014 ESCA = {inserted, deleted, doInsert, doDelete}\n\u2014 TSCA(inserted) = TSCA(deleted) = pubsub\n\u2014 TSCA(doInsert) = TSCA(doDeleted) = sub\n\u2014 SubSCA(E) = {inserted, deleted, doInsert, doDelete}\n\u2014 PubSCA(E) = {inserted, deleted}.\nAnd in Set (S) we have:\n\u2014 ES = {inserted, deleted, doInsert, doDelete}\n\u2014 TS (inserted) = TS (deleted) = pub\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1037\n\u2014 TS (doInsert) = TS (doDeleted) = sub\n\u2014 SubS (E) = {doInsert, doDelete}\n\u2014 PubS (E) = {inserted, deleted}.\nFor every service s, we define a set A(s) \u2013 its domain or write frame \u2013 that consists\nof the state variables that can be affected by instances of s. These are the variables\nindicated under assignsTo. For instance, AS (insert) = {elems}. We extend the notation to\nstate variables so that A(v) is taken to denote the set of services that have v in their write\nframe, that is, A(v) = {s\u2208 S |v \u2208A(s)}. Hence, AS (elems) = {insert, delete}.\nWhen a notification that a subscribed event has been published is received, a component\nreacts by invoking services. For every subscribed event e, we use H(e) to denote the\nmechanisms (handlers) through which notifications that e has occurred are handled.\nEach handler h defines a specific way that the component can react to the notification\nthat e has been published, which may involve the invocation of one or more services\ndeclared in G(h). For instance, HSC(inserted) has only one handler, which invokes inc,\nbut HSCA(inserted) has two handlers: one invokes inc and the other invokes add. As for\nwrite frames, we also extend the notation to services so that G(s) for a service s is taken\nto denote the set of handlers that can invoke s regardless of the way the invocation is\nactually handled.\nNote that the functions A, G and H just declare the state variables and services that\ncan be changed and invoked, respectively. The events that can be published are those in\nPub(E). Nothing in the signature states how state variables are changed, or how and in\nwhat circumstances events are published or services invoked. This is left to the body of\nthe design, as discussed later in Section 3.3.\n3.2. Interpretation structures\nSignatures are interpreted over a semantic model based on transition systems in which\nexecution steps are performed by synchronisation sets of services. Such interpretation\nstructures require a model for the underlying data types, which we take as a \u03a3-algebra D\nthat validates the specification \u0398 (see Ehrig and Mahr (1985) for details):\n\u2014 Each data sort d\u2208D is assigned a set dD (the data values of sort d).\n\u2014 Each operation f : d1, . . . , dn \u2192 d\u2032 is assigned a function fD : (d1)D \u00d7 . . .\u00d7 (dn)D \u2192 d\u2032D.\nThe first step in the definition of our semantic domain is the construction of the\nlanguage and space of states, events and services. We assume a fixed signature Q =\n\u3008V , E, S, P , T , A, G,H\u3009 throughout this section.\nDefinition 3.2. A Q-space consists of:\n\u2014 The extension \u03a3Q of the data signature \u03a3 with:\n\u2013 for every event e\u2208E, a new sort de and, for every parameter p\u2208P (e)d of sort d, an\noperation dp : de \u2192 d;\n\u2013 for every service s\u2208 S , a new sort ds and, for every parameter p\u2208P (s)d of sort d,\nan operation dp : ds \u2192 d;\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1038\n\u2013 for every subscribed event e\u2208 Sub(E), handler h\u2208H(e) and service s\u2208G(h) that\ncan be invoked, an operation invh,s : de \u2192 ds;\n\u2013 for every service s\u2208 S and published event e\u2208Pub(E), an operation pubs,e : ds \u2192 de.\n\u2014 An algebra U for \u03a3Q that extends the \u03a3-algebra D in the sense that D is the reduct\nof U for the inclusion \u03a3 \u2286 \u03a3Q and, in addition, assigns mutually disjoint carrier sets\nto services, and, also, to events.\nAccording to this definition, each event e\u2208E and service s\u2208 S defines a sort, which\nwe take to consist of their run-time instances. We require that these sorts are assigned\nmutually disjoint domains so that reducts, as defined in Section 5.2, can forget invocations\nand pending events.\nThe parameters of events and services define operations that assign data values to\nevery instance: the value that they carry when the corresponding events occur or services\nare invoked. In aaddition to these operations that return data values, we define two\nother kinds of operations: inv, which return the service instances invoked by every event\noccurrence; and pub, which return the event instances published by every service execution.\nNotice that we are defining a \u2018declarative\u2019 or \u2018denotational\u2019 semantics, not an operational\none: we are not saying how parameters are assigned to events\/services, or how pub\/inv\ngenerate instances of published events and invoked services; parameters are passed at\nrun time, and the specific event\/service instances that pub\/inv return are also determined\nduring execution. However, from a declarative point of view, we can say that these\nfunctions exist between the sets of all possible instances that can ever take place.\nAll these sets and operations extend the algebra that interprets the data type specific-\nation. We assume that this extension does not affect the original algebra, that is, it does\nnot interfere with the sets of data and the operations on data. In other words, U and D\ncoincide in the interpretation that they provide for the data signature \u03a3.\nAs already mentioned, the sorts associated with events and services are populated with\nidentifiers of their run-time instances. These are used for the definition of the execution\nmodel associated with our approach. For the rest of this section, we consider a fixed\nQ-space.\nDefinition 3.3. An execution state consists of a pair \u3008VAL, PDN\u3009 where:\n\u2014 VAL (valuation) is a mapping that, to every data sort d\u2208D and state variable v \u2208Vd,\nassigns a value VAL(v)\u2208dD.\n\u2014 PDN is a set whose elements (pending invocations) are triples \u3008t, h, u\u3009 where:\n\u2013 t is an event instance, that is, an element of for some event e\u2208Sub(E).\n\u2013 h is a handler for e, that is, h\u2208H(e).\n\u2013 u is a service instance invoked by t through h, that is, u = invh,sU (t) for some s\u2208G(h).\nThe proposed notion of state includes, as usual, the values that the variables take in that\nstate \u2013 this is provided by the mapping VAL. In addition to this, we have also provided\nstates with information on the service invocations that are pending in that state \u2013 this\nis provided by the set PDN. As discussed below, a service invocation becomes pending,\nand is added to PDN, when an event is published that includes the service in its list of\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1039\ninvocations. Each pending invocation is a structure that records both the event instance\nthat triggered the invocation and the handler through which the invocation is controlled.\nNot all pending invocations need to be selected for actual invocation in a given step; as\nwe shall see, only a subset is chosen according to a policy that depends on the run-time\nplatform. The subsets that can be chosen need to satisfy some conditions.\nDefinition 3.4. Given an execution state, a subset INV \u2286 PDN of actual service invocations\nsatisfies:\n\u2014 For any invocation \u3008t, h, u\u3009 \u2208 INV , if \u3008t, h, u\u2032\u3009 \u2208 PDN, then \u3008t, h, u\u2032\u3009 \u2208 INV .\n\u2014 For every pair of services s and s\u2032 and different service invocations \u3008t, h, u\u3009 and \u3008t\u2032, h\u2032, u\u2032\u3009\nin INV with u\u2208 dsU and u\u2032 \u2208 ds\u2032U, we have A(s) \u2229 A(s\u2032) =\u0001.\nThat is, all the services invoked by the same event instance and controlled by the\nsame handler need to be grouped together; this is because, as already motivated, all such\ninvocations need to be discarded in the same state; service invocations that do not need\nto be discarded simultaneously should be assigned to different handlers.\nFurthermore, instances of services that have intersecting domains cannot be selected\ntogether; this is because they cannot both write on the same part of the state within an\n(atomic) execution step. A particular case is when they are both instances of the same\nservice: it does not make sense to fulfil two pending invocations of inc, corresponding to\ninsertions of different elements, by executing the increment only once: clearly, we want\nthe number of elements in the set to be incremented twice.\nIn addition to the notion of execution state, we need to define the state transitions that\ncharacterise the way a system can evolve.\nDefinition 3.5. An execution step is a tuple \u3008SRC,TRG, INV , EXC, PUB,NXT \u3009 where:\n\u2014 SRC (the source) and TRG (the target) are two execution states;\n\u2014 INV is a subset of PDNSRC (the set of actual service invocations);\n\u2014 EXC is a set of service instances (these correspond to the actual service invocations\nthat are enabled in SRC);\n\u2014 PUB is a set whose elements are the event instances published at that step;\n\u2014 NXT is a subset of PDNTRG (the set of next service invocations);\nsatisfying the following properties:\n\u2014 for every u\u2208EXC there is \u3008t, h, u\u3009 \u2208INV ;\n\u2014 for every \u3008t, h, u\u3009 \u2208 NXT , t\u2208PUB, that is, only services invoked by published events\ncan become pending;\n\u2014 PDNTRG = PDNSRC\\INV \u222a NXT , that is, we discard the invoked services from the\nset of pending ones, and we add the set of services invoked by handlers of published\nevents;\n\u2014 for every v \u2208V such that VALTRG(v) \u0007= VALSRC(v), there is u\u2208EXC with u\u2208 dsU such\nthat v \u2208A(s), that is, a state variable can only change during an execution step if a\nservice in its domain is executed during that step.\nThe proposed notion of execution step captures the main aspects of the computational\nmodel that we are adopting. On the one hand, a number of event instances are published\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1040\nFig. 5. Representation of the elements involved in the execution steps.\nduring an execution step, which is captured by the set PUB; and these published events add\npending invocations to the target state, which is captured by NXT and the functions inv.\nOn the other hand, each step discards a number of the invocations pending in the source\nstate, which is captured through INV. Services belonging to the discarded invocations that\nare enabled in the source state are executed, which is captured by the \u2018subset\u2019 EXC of\nINV. The actual service executions in EXC are responsible for the publication of events\nand changes performed on the state variables in ways that are discussed in the next\nsub-section.\nFinally, one generally assumes that the selection process is fair in the sense that\ninvocations cannot remain pending forever; they must eventually be selected and executed\nif enabled. Notice that this is not a property of any individual execution step but of the\nglobal execution model; therefore, this is not captured in the above definition.\nThe picture presented in Figure 5 summarises some of the relationships between the\nentities involved in an execution step. Note that events may be published that do not\nresult from service execution: these instances are generated by the environment. However,\nall pending service invocations result necessarily from an event published in PUB and\none of its handlers; that is, services of a component cannot be invoked directly from\nthe environment, only as a result of the publication of an event. A similar kind of\nencapsulation is enforced on the state component: a state variable can only change value\nif a service that includes the variable in its domain has been executed.\nIn summary, we are saying that interaction between a component and its environment is\nreduced to the publication and subscription of events: the state structures and the services\nthat operate on them cannot be acted upon directly from outside the component. More\nprecisely, what these encapsulation mechanisms imply is that state variables and services\ncan only be shared together with the events that manipulate them. We shall discuss this\nfurther in later sections.\nA model for a signature consists of a set of execution steps that satisfy a number of\nclosure conditions that capture the fact that service execution is deterministic: the effects\non the state and the enabling condition of every service is fully determined.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1041\nDefinition 3.6. A model of a signature Q is a Q-space \u3008\u03a3Q,U\u3009 together with a directed\nacyclic graph \u3008N,R\u3009 where N is the set of nodes and R is a set of pairs of nodes (directed\narcs) and a labelling function L that assigns an execution state to every node and an\nexecution step to every arc satisfying the following conditions:\n\u2014 For every arrow r = \u3008n1, n2\u3009, L(r) is of the form \u3008L(n1),L(n2), , , , \u3009.\n\u2014 VALTRG(v) = VALTRG\u2032(v) for every state variable v \u2208 V and every pair of ar-\nrows r = \u3008n, m\u3009 and r\u2032 = \u3008n, m\u2032\u3009 such that there are s\u2208A(v) and u\u2208 dsU \u2229 EXC \u2229\nEXC \u2032, where L(r) is of the form \u3008 , TRG, , EXC, , \u3009 and L(r\u2032) is of the form\n\u3008 , TRG\u2032, , EXC \u2032, , \u3009.\n\u2014 For any two arrows r = \u3008n, m\u3009 and r\u2032 = \u3008n, m\u2032\u3009 where L(r) is of the form \u3008 , , INV ,\nEXC, , \u3009 and L(r\u2032) is of the form \u3008 , , INV \u2032, EXC \u2032, , \u3009, and service instance u\nsuch that \u3008 , , u\u3009 \u2208INV and \u3008 , , u\u3009 \u2208INV \u2032, u\u2208EXC if and only if u\u2208EXC \u2032.\nNote that in order to improve readability, we use underscores \u2018 \u2019 in lieu of parameters\nthat do not play a role in the definitions or propositions.\nThe first condition simply means that the labelling function respects sources and targets\nof execution steps. The second condition means that the effects on any state variable are\nfully determined by the execution of an instance of a service that has the variable in its write\nframe. A particular case is when the execution sets of the two steps are the same, meaning\nthat service instances have a deterministic effect on the state. The same does not apply to\nthe publication of events because we allow the environment to publish events as well.\nThe third condition reflects the fact that the set EXC of service executions is fully\ndetermined by the selected invocations INV and the source state. Intuitively, what\ndetermines if an invoked service will be executed in the source state is what we call\nits enabling condition. In Section 3.3 we discuss how the lower and upper guards are\ninterpreted as requirements on the enabling condition.\nAs a result, branching in a model, that is, the existence of more than one execution step\nfrom the same state, reflects a degree of non-determinism that results from the fact that\nthe behaviour of the component is open to the environment.\n3.3. Designs and their models\nSignatures provide the \u2018syntax\u2019 of designs. However, note that signatures include typing\ninformation that is sometimes associated with the \u2018semantics\u2019 such as the encapsulation\nof state change and service invocation. In brief, as we will explain later in the paper,\nsignatures need to include all and only the typing information required for establishing\ninterconnections. Hence, for instance, it is important to include in the signature information\nabout which state variables are in the domain of which services but not the way services\naffect the state variables; it is equally important to know the structure of handlers for\neach subscribed event but not the way each subscription is handled.\nThe additional information that pertains to the individual behaviour of components is\ndefined in the bodies of designs through three different structures, each of which involves\nsentences in a different language. We begin with the language we use to specify the guards\nof services.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1042\nDefinition 3.7. Given a signature Q = \u3008V , E, S, P , T , A, G,H\u3009 and a service s\u2208 S , we define\nthe state language SLQ,s associated with s as the first-order language generated by the\ndata signature \u03a3 = \u3008D, F\u3009 enriched with:\n\u2014 for every d\u2208D, each parameter p\u2208P (s)d as a constant of sort d;\n\u2014 for every d\u2208D, each state variable v \u2208Vd as a constant of sort d.\nGiven a valuation VAL of the state variables and an instance u \u2208 D, we evaluate the\nsentences of SLQ,s in the extension of the \u03a3-algebra D with\n\u2014 pD = dpU(u);\n\u2014 vD = VAL(v).\nThat is, we extend the first-order language associated with the data signature with the\nparameters of the service and the state variables. We call it a \u2018state\u2019 language because it\ndoes not concern state transitions \u2013 sentences can be evaluated on a single state, which\nis what we require for determining if a service is enabled. An example is the sentence\ndelete.lm \u2208 elems in the state language of delete; this sentence involves the parameter\ndelete.lm as well as the state variable elems.\nConsider now the language we use to specify the effects of services.\nDefinition 3.8. Given a signature Q = \u3008V , E, S, P , T , A, G,H\u3009 and a service s\u2208S , we define\nthe transition language TLQ,s associated with s as the first-order language (with equality)\ngenerated by the data signature \u03a3 = \u3008D, F\u3009 enriched with:\n\u2014 for every d\u2208D, each parameter p\u2208P (s)d as a constant of sort d;\n\u2014 for every d \u2208 D, each parameter p\u2208P (e)d of every published event e\u2208Pub(E) as a\nconstant of sort d;\n\u2014 for every d\u2208D, each state variable v \u2208Vd as a constant of sort d;\n\u2014 for every d\u2208D and state variable v \u2208A(s)d, v\u2032 as a constant of sort d;\n\u2014 for every published event e\u2208Pub(E), the atomic proposition e!.\nGiven an execution step and an instance u\u2208dsU, we evaluate the sentences of TLQ,s in the\nextension of the \u03a3-algebra D with:\n\u2014 pD= dpU(u) for p\u2208P (s).\n\u2014 pD= dpU(pub\ns,e\nU (u)) for p\u2208P (e) and e\u2208Pub(E).\n\u2014 vD= VALSRC(v) for v \u2208V .\n\u2014 v\u2032D= VALTRG(v) for v \u2208A(s).\n\u2014 e! is true if and only if pubs,eU (u)\u2208PUB.\nThis time, the extension includes not only the state variables and the parameters of the\nservice, but also the events that the service can publish (and their parameters) and primed\nversions of the state variables that belong to the domain of the service. This is because we\nneed to be able to specify the effects of the execution of the service on the state variables,\nfor which we use their primed versions, as well as the circumstances in which events are\npublished, which includes the specification of how parameters are passed. Such sentences\nno longer specify properties of single execution states but of execution steps; this is why\nwe call it a \u2018transition\u2019 language.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1043\nAn example is the sentence\n(elems\u2032 = {insert.lm} \u222a elems \u2227 inserted! \u2227 inserted.which = insert.lm)\nin the transition language of insert. This sentence uses elems\u2032 to indicate that, when\nexecuted, insert adds its parameter to the set stored in the state variable elems; this is\nbecause primed variables are evaluated in the target state TRG of the execution step.\nAs already mentioned, inserted! is used to indicate that the event inserted is published:\nsuch propositions specify properties of the set PUB associated with the execution step.\nIndeed, a typical sentence of the form \u03c8 \u2283 (e! \u2227 \u03c6) in the transition language holds of a\nstep for an instance u of a service s if and only if, when \u03c8 is true, \u03c6 is also true and an\nevent publication is added to PUB for the instance pubs,eU (u) of e generated by u. Notice\nthat, typically, \u03c8 (the pre-condition in the sense of the Hoare calculus) involves the state\nvariables, which are evaluated at the source state, and \u03c6 (the post-condition) involves the\nprimed state variables, which are evaluated in the target state TRG, thus establishing how\nthe state changes as a result of the execution of the service. In the event-based approach,\nthe post-condition includes conditions on the parameters of t and pubs,eU (t), which are\nevaluated in the algebra U.\nWhen a state sentence determines the value of a primed variable as a function of the\nstate variables and the parameters of the service, we obtain an assignment, in which case\nwe tend to use the common programming language notation v := F(s, v) for v\u2032 = F(s, v).\nFinally, we define the language we use to specify the event handlers.\nDefinition 3.9. Given a signature Q = \u3008V , E, S, P , T , A, G,H\u3009 and a handler h \u2208H(e) of\nan event e\u2208E, we define the handling language HLQ,h associated with h as the first-order\nlanguage generated by the data signature \u03a3 = \u3008D, F\u3009 enriched with:\n\u2014 for every d\u2208D, each parameter p\u2208P (e)d as a constant of sort d;\n\u2014 for every d\u2208D, each parameter p\u2208P (s)d of every service s\u2208G(h) invoked by h as a\nconstant of sort d;\n\u2014 for every service s\u2208G(h) invoked by h, the atomic proposition s?.\nGiven an execution step and an instance t\u2208deU, we evaluate the sentences of HLQ,h in the\nextension of the \u03a3-algebra D with:\n\u2014 pD= dpU(t) for p\u2208P (e).\n\u2014 pD= dpU(inv\nh,s\nU (t)) for p\u2208P (s) and s\u2208G(h).\n\u2014 s? is true if and only if \u3008t, h, invh,sU (t)\u3009 \u2208NXT .\nHandling languages are not associated with services but with events and their handlers;\nthey provide the means for specifying how the publication of the associated events are\nhandled. A typical handling requirement for an event e is of the form \u03c8 \u2283 (s?\u2227\u03c6), which\nestablishes the fact that s is invoked with property \u03c6 if condition \u03c8 holds on notification\nthat an instance of e has occurred. This describes the circumstances in which services\nare invoked, including how parameters are passed. An example in the handling language\nassociated with doInsert in SCA is the sentence (insert? \u2227 doInsert.which = insert.lm);\nthis sentence uses insert? to indicate that the service insert is invoked when doInsert is\npublished; furthermore, the parameter lm of this invocation of insert has the same value\nas the parameter which of doInsert.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1044\nSentences of this form specify properties of the set NXT of service invocations associated\nwith the execution step. Indeed, \u03c8 \u2283 (s? \u2227 \u03c6) holds for an instance t of an event e and\nhandler h for e if and only if when \u03c8 is true, \u03c6 is also true and a service invocation is\nadded to NXT for the instance invh,sU (t) of s invoked by t through h. Notice that, typically,\nboth \u03c8 and \u03c6 are properties of the parameters of t and invh,sU (t), which are evaluated in the\nalgebra U. This is because handling languages do not include state variables, reflecting\nthe fact that typical publish\/subscribe mechanisms do not use state information of the\ncomponents to decide which services are to be invoked. However, this does not mean that\nthe invoked services will necessarily be executed as they may not be enabled.\nWe can now define the notion of a design.\nDefinition 3.10. A design is a pair \u3008Q,\u2206\u3009 where Q is a signature and \u2206, the body of the\ndesign, is a triple \u3008\u03b7, \u03c1, \u03b3\u3009 where:\n\u2014 \u03b7 assigns to every handler h\u2208H(e) of a subscribed event e\u2208 Sub(E) a sentence in the\nhandling language HLQ,h associated with h.\n\u2014 \u03c1 assigns to every service s\u2208 S a sentence in the transition language TLQ,s associated\nwith s.\n\u2014 \u03b3 assigns to every service s\u2208 S a pair of sentences [\u03b3l(s), \u03b3u(s)] in the state language\nSLQ,s associated with s.\nGiven this, the body of a design is defined in terms of:\n\u2014 For every subscribed event e, a set H(e) of handling requirements expressed through\nsentences \u03c1(h) for every handler h\u2208H(e).\nEvery handling requirement (handling for short) is enforced when the event is\npublished. Each handler consists of service invocations and other properties that\nneed to be observed on invocation (for example, for parameter passing) or as a pre-\ncondition for invocation (for example, in the case of filters for discarding notifications).\n\u2014 For every service s, an enabling interval [\u03b3l(s), \u03b3u(s)] defining constraints on the states\nin which the invocation of s can be accepted.\nThese are the conditions that we specify under guardedBy. The invocation is accepted\nwhen \u03b3u(s) holds and is refused when \u03b3l(s) is false.\n\u2014 For every service s, a sentence \u03c1(s) defining the state changes that can be observed due\nto the execution of s.\nAs shown in the examples, this sentence may include the publication of events and\nparameter passing. This is the condition that we specify under effects.\nThis intuitive semantics is formalised as follows.\nDefinition 3.11. A model of a design \u3008Q,\u2206\u3009 where \u2206 = \u3008\u03b7, \u03c1, \u03b3\u3009 is a model of Q such that\nany execution step \u3008SRC,TRG, INV , EXC, PUB,NXT \u3009 that is the label of an arrow of\nthe underlying graph satisfies the following conditions:\n\u2014 For every u\u2208EXC with u\u2208 dsU, we have \u03b3l(s) holds for u at SRC.\n\u2014 For every \u3008t, h, u\u3009 \u2208INV and u\u2208 dsU, if \u03b3l(s) holds for u at SRC, then u\u2208EXC .\n\u2014 For every u\u2208EXC with u\u2208 dsU, we have \u03c1(s) holds for u at that step.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1045\n\u2014 For every t\u2208PUB where t\u2208 deU and h\u2208H(e), we have \u03b7(h) holds for t and h at that\nstep.\nA complete execution in a model is a sequence of steps L(\u3008ni, mi\u3009)i\u2208\u03c9 such that mi = ni+1\nfor every i\u2208\u03c9. We say that an execution is fair if and only if, for every i\u2208\u03c9 and\n\u3008t, h, u\u3009 \u2208 PDNi, there is k \u0001 i such that \u3008t, h, u\u3009 \u2208INVk .\nBecause each model is fully deterministic apart from the possible interference of the\nenvironment, the existence of more than one model for a given design reflects under\nspecification. In other words, each such model reflects a possible choice of implementation.\nThe degree of under specification can be reduced by refining the design. Refinement\nsupports a stepwise development process in which design decisions are made because re-\nquirements are made more specific, for example, as in product-lines, or as knowledge of the\ntarget run-time platform becomes more precise. This topic is discussed further in Section 5.\n4. Structuring event-based systems\nIn a categorical approach to software architecture (Fiadeiro and Lopes 1997; Fiadeiro\net al. 2003), the structure of systems is captured through morphisms. These are maps\nbetween designs that identify ways in which the source is a design of a component of the\nsystem described by the target. Morphisms induce operations on models of designs that\nexplain how the behaviour of the component can be restricted by that of the system.\n4.1. Identifying components of systems\nWe start by defining how morphisms act on signatures.\nDefinition\/Proposition 4.1. A morphism \u03c3 : Q1 \u2192 Q2 for\nQ1 = \u3008V1, E1, S1, P1, T1, A1, G1, H1\u3009\nand\nQ2 = \u3008V2, E2, S2, P2, T2, A2, B2, G2, H2\u3009\nis a tuple \u3008\u03c3st, \u03c3ev, \u03c3sv, \u03c3par\u2212ev, \u03c3par\u2212sv, \u03c3hr\u2212ev\u3009, where:\n\u2014 \u03c3st : V1 \u2192 V2 is a function on state variables;\n\u2014 \u03c3ev : E1 \u2192 E2 is a function on events;\n\u2014 \u03c3sv : S1 \u2192 S2 is a function on services;\n\u2014 \u03c3par\u2212ev maps every event e to a function \u03c3par\u2212ev,e : P1(e) \u2192 P2(\u03c3ev(e)) on its parameters;\n\u2014 \u03c3par\u2212sv is like \u03c3par\u2212ev but for service parameters, that is, \u03c3par\u2212sv,s : P1(s) \u2192 P2(\u03c3sv(s));\n\u2014 \u03c3hr\u2212ev maps every subscribed event e to a function. \u03c3hr\u2212ev,e : H1(e) \u2192H2(\u03c3ev(e)) on its\nhandlers;\nsatisfying the following conditions:\n\u2014 sort2(\u03c3st(v)) = sort1(v) for every v \u2208V1, that is, the sorts of state variables are preserved;\n\u2014 \u03c3ev preserves kinds, that is:\n\u2013 \u03c3ev(e)\u2208Pub(E2) for every e\u2208Pub(E1);\n\u2013 \u03c3ev(e)\u2208 Sub(E2) for every e\u2208Sub(E1);\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1046\ndesign Counter is\nsubscribe doInc\ninvokes inc\nhandledBy inc?\nsubscribe doDec\ninvokes dec\nhandledBy dec?\nstore value: nat\nprovide inc\nassignsTo value\neffects value\u2019=value+1\nprovide dec\nassignsTo value\neffects value\u2019=value-1\nFig. 6. The design of Counter\n\u2014 A2(\u03c3st(v)) = \u03c3sv(A1(v)) for every v\u2208V1, that is, domains are preserved;\n\u2014 \u03c3sv(G1(h)) \u2286 G2(\u03c3hr\u2212ev(h)) for every e\u2208E1 and h\u2208H1(e), that is, services invoked by\nhandlers carry through;\n\u2014 \u03c3hr\u2212ev(G1(s)) = G2(\u03c3sv(s)) for every s\u2208S1, that is, invocation of services is preserved;\n\u2014 sort2(\u03c3par\u2212ev,e(p)) = sort1(p) for every e \u2208 E1 and p\u2208P1(e), that is, event parameter\nsorts are preserved;\n\u2014 sort2(\u03c3par\u2212sv,s(p)) = sort1(p) for every s \u2208 S1 and p\u2208P1(s), that is, service parameter\nsorts are preserved.\nSignatures and their morphisms constitute a category SIGN.\nA morphism \u03c3 from Q1 to Q2 supports the identification of a way in which a component\nwith signature Q1 is embedded in a larger system with signature Q2. Morphisms map state\nvariables, services and events of the component to corresponding state variables, services\nand events of the system, preserving data sorts and kinds. An example is the inclusion of\nSet in SCA. All the mappings are inclusions: all names used in Set are preserved in SCA.\nNotice that it is possible that an event that the component subscribes is bound to an\nevent published by some other component in the system, thus becoming pubsub in the\nsystem. This is why we have TS (inserted) = sub but TSCA(inserted) = pubsub: in SCA, the\nevent inserted is published by the service insert.\nThe constraints on domains are of the form A2(\u03c3st(v)) = \u03c3sv(A1(v)) and imply that the\ndomain in Q2 of an \u2018old\u2019 variable, that is, a variable of the form \u03c3st(v), is the image of the\ndomain of that variable in Q1. Therefore, new services introduced in the system cannot\nassign to state variables of the component. This is what makes state variables \u2018private\u2019\nto components. The same applies to the invocation of services through the constraints\n\u03c3hr\u2212ev(G1(s)) = G2(\u03c3sv(s)): events subscribed by the system but not by the component\ncannot invoke services of the component; if other parts of the system want to invoke\nservices of the component, they must do so by publishing events to which the component\nsubscribes. Notice that the condition \u03c3sv(G1(h)) \u2286 G2(\u03c3hr\u2212ev(h)) allows a subscribed event\nto invoke more services in the system through the same handler; however, the previous\nconstraint implies that these new invocations cannot be for services of the component.\nAs a result of these encapsulation mechanisms, we cannot identify components of a\nsystem by grouping state variables, services and events in an arbitrary way; we have to\nmake sure that variables are grouped together with all the services that can assign to\nthem, and we have to group those services with all the events that can invoke them.\nFor instance, we can identify a counter as a component of SCA that manages the state\nvariable value (see Figure 6).\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1047\nIf we map doInc to inserted and doDec to deleted, we define a morphism between the\nsignatures of Counter and SCA. Indeed, sorts of state variables are preserved, and so are\nthe kinds of the events. The domain of the state variable value is also preserved because\nthe other services available in SCA (insert, delete, add, sub) do not assign to it. The same\napplies to the invocation of its services: inc and dec are not invoked by the new events\nsubscribed in SCA (doInsert and doDelete).\nComponents are meant to be \u2018reusable\u2019 in the sense that they are designed without\na specific system or class of systems in mind. In particular, it is not necessary that\nthe components that are responsible for publishing events or those that will subscribe\npublished events, are fixed at design time. This is why, in our language, all names are\nlocal and morphisms have to account for any renamings that are necessary to establish\nthe bindings that may be required. For instance, as already mentioned, the morphism that\nidentifies Counter as a component of SCA needs to map doInc to inserted and doDec to\ndeleted. Do notice that the binding also implies that inserted and deleted are subscribed\nwithin SCA. As a result, our components are independent in the sense of Sullivan and\nNotkin (1992): they do not explicitly invoke any component other than themselves.\nIn order to identify components in systems, the bodies of their designs also have to be\ntaken into account, that is, the \u2018semantics\u2019 of the components have to be preserved. In\nthis sense, morphisms capture relationships between designs that are similar to what in\nparallel program design languages is known as \u2018superposition\u2019 (Lopes and Fiadeiro 2004).\nDefinition\/Proposition 4.2. A superposition morphism \u03c3 : \u3008Q1,\u22061\u3009 \u2192 \u3008Q2,\u22062\u3009 consists of a\nsignature morphism \u03c3 : Q1 \u2192 Q2 such that, for every model of \u3008Q2,\u22062\u3009 and execution\nstep:\n\u2014 Handling requirements are preserved: (\u03b72(\u03c3hr\u2212ev,e(h)) \u2283 \u03c3(\u03b71(h))) holds for every event\ne\u2208E1 and handling h\u2208H1(e).\n\u2014 Effects are preserved: (\u03c12(\u03c3sv(s)) \u2283 \u03c3(\u03c11(s))) holds for every s\u2208 S1.\n\u2014 Lower guards are preserved: (\u03b3l2(\u03c3sv(s)) \u2283 \u03c3(\u03b3l1(s))) holds for every s\u2208 S1.\n\u2014 Upper guards are preserved: (\u03b3u2(\u03c3sv(s)) \u2283 \u03c3(\u03b3u1(s))) holds for every s\u2208 S1.\nDesigns and their morphisms constitute a category sDSGN. We use sign to denote the\nforgetful functor from sDSGN to SIGN that forgets everything from designs except their\nsignatures.\nWe use \u03c3 to denote the translations that the morphism \u03c3 induces on the languages\nthat we use in the body of designs. The definition of such translations is quite straight-\nforward (but tedious) using induction on the structure of the terms and sentences. See\nFiadeiro (2004) for examples.\nNote that the first condition allows for more handling requirements to be added and,\nfor each handling, subscription conditions to be strengthened. In other words, as a result\nof being embedded in a bigger system, a component that publishes a given event may\nacquire more handling requirements but also more constraints on how to handle previous\nrequirements, for instance on how to pass new parameters.\nIt is easy to see that these conditions are satisfied by the signature morphisms that\nidentify Set and Counter as components of SCA. However, in general, it may not be trivial\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1048\nFig. 7. A simple configuration of set\u2013counter.\nto prove that a signature morphism extends to a morphism between designs. After all,\nsuch a proof corresponds to recognising a component within a system, which is likely\nto be a highly complex task unless we have further information on how the system was\nput together. This is why it is important to support an architectural approach to design\nthrough which systems are put together by interconnecting independent components. This\nis the topic of Section 4.3.\n4.2. Externalising the bindings\nAs explained in Fiadeiro and Lopes (1997) and Fiadeiro et al. (2003), one of the advantages\nof a categorical formalisation of architectural design is that it allows us to support a design\napproach based on superposing separate components (or connectors) over independent\nunits. These separate components are called mediators in Sullivan and Notkin (1992).\nHere we take \u2018separate\u2019 and \u2018independent\u2019 in the same sense as used in Sullivan and\nNotkin (1992): mediators are separate in the sense that they are components in their own\nright, and they interconnect components that are independent, as already explained: they\ndo not explicitly invoke any component other than themselves.\nFor instance, using a graphical notation for the interfaces of components \u2013 the events\nthey publish and subscribe, and the services that they can perform \u2013 we are able to start\nfrom separate Set and Counter components and externally superpose the bindings through\nwhich Counter subscribes the events published by Set (see Figure 7).\nAs in Fiadeiro (2004), we explore the \u2018graphical\u2019 nature of Category Theory to model\ninterconnections as \u2018boxes and lines\u2019. In our case, the lines need to be accounted for\nby special components that perform the bindings between the event published by one\ncomponent and subscribed by the other:\ndesign Binding_0 is\npublish&subscribe event\nThe binding has a single event that is both published and subscribed. The intercon-\nnection between Set, Binding 0 and Counter is performed by an even simpler kind of\ncomponent: cables that attach the bindings to the events of the components. These are of\nthe form\ndesign CableP is\npublish.\ndesign CableS is\nsubscribe.\nBecause names are local, the identities of events in cables are not relevant: they are just\nplaceholders for the projections to define the relevant bindings. This is why we represent\nthem through the symbol \u2022. The configuration presented in Figure 7 corresponds to the\ndiagram (labelled graph) in the category sDSGN of designs presented in Figure 8.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1049\nCableP CableS\nBinding_0\nSet Counter\nBinding_0\nCableP CableS\ninserted \u2022 event event \u2022 doInc\ndeleted \u2022 event event \u2022 doDec\nFig. 8. A categorical diagram expressing the system configuration presented in Figure 7.\ndesign Filter is\npublish target\nprovide service\neffects target!\nsubscribe source\npar n:nat\ninvokes service\nhandledBy\nisEven(n) service?\nFig. 9. The design of Filter.\nIn Category Theory, diagrams are mathematical objects and, as such, can be manip-\nulated in a formal way. One of the constructs that are available on certain diagrams\ninternalises the connections in a single (composite) component. In the above case this\nconsists of computing the colimit of the diagram (Fiadeiro 2004), which returns the\ndesign Set&Counter discussed in Section 2. In fact, the colimit also returns the morphisms\nthat identify both Set and Counter as components of Set&Counter. We will discuss these\nconstructions in Section 4.3.\nBindings can be more complex. Just for illustration, consider the case in which we want\nto count only the even elements that are inserted. Instead of using Binding 0 to connect\nSet and Counter directly, we would use the more elaborate connector (mediator) Filter\npresented in Figure 9. This is a generic component that subscribes to an event source that\ncarries a natural number, and invokes the service source when and only when that natural\nnumber is even. The effect of executing service is to publish an event target. That is, what\nwe are filtering is source events, passing on only those that carry an even parameter.\nWhat we want now is for this filter to be connected to inserted events at the source, and\nto doInc at the target.\nThis connector, which is presented in Figure 10, is made explicit in the configuration\nas a mediator between Set and Counter, replacing the simple binding. Notice that the\nconnections between Filter and the other two components, Set and Counter, is still\nestablished through bindings, which we have abstracted in the picture through the same\nsolid lines as we used before. The categorical diagram corresponding to this configuration\nis presented in Figure 11.\nThe connection to Set requires a more sophisticated binding to ensure that the parameter\nis transmitted. We need the interconnection presented in Figure 12 with the binding defined\nin Figure 13 and the cables defined in Figure 14. The other connections are established in\na similar way.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1050\nFig. 10. A configuration involving Filter: only the insertions of even numbers are counted.\nCableP CableS\nBinding_0\nFilter Counter\ntarget \u2022 event event \u2022 doInc\nFig. 11. Interconnection of Filter and Counter.\nCableP_1P CableS_1P\nBinding_1\nSet Filter\nwhich \u2022 p\ninserted \u2022 event\np \u2022 n\nevent \u2022 source\nFig. 12. Interconnection of Set and Filter.\ndesign Binding_1 is\npublish&subscribe event\npar p:nat\nFig. 13. The binding involved in Figure 12.\ndesign CableP_1P is\npublish \u00b7\npar \u00b7:nat\ndesign CableS_1P is\nsubscribe \u00b7\npar \u00b7:nat\nFig. 14. The cables involved in Figure 12\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1051\ndesign Adder is\nprovide add\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum+lm\nprovide sub\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum-lm\nstore sum:nat\nsubscribe doAdd\npar which:nat\ninvokes add\nhandledBy add? which=add.lm\nsubscribe doSub\npar which:nat\ninvokes sub\nhandledBy sub? which=sub.lm\nFig. 15. The design of Adder.\nFig. 16. A configuration of set\u2013counter involving Adder.\nThe same design approach can be applied to the addition of an Adder, defined in\nFigure 15. The required configuration is shown in Figure 16. We will abstain from\ntranslating the configuration to a categorical diagram. The colimit of that diagram\nreturns the design SCA discussed in Section 2 and the morphisms that identify Set, Adder\nand Counter as components.\nNote that the categorical approach allows for systems to be reconfigured by plugging\nin and out bindings, components, connectors, mediators, and so on. For instance, we can\nsuperpose Filter to count only insertions of even numbers, or we could have superposed\nAdder to the previous configuration with Filter, presented in Figure 17.\nFig. 17. A configuration of set\u2013counter involving Filter and Adder.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1052\n4.3. The universal properties of designs\nWe have already mentioned that we rely on so-called universal constructions, namely\ncolimits, to give semantics to configuration diagrams following the same principles as\nhave been used in other areas, including CommUnity. These are operations that, when\napplied to a (categorical) diagram, return an object (a design in our case) that captures\nthe global behaviour of the configured system, together with the morphisms that indicate\nhow the objects of the diagram are now components of the system. For instance, we\nhave already mentioned how the more complex designs of Section 2 result from the\nconfigurations developed in Section 4.2.\nProposition 4.3. The functor sign defines sDSGN as a coordinated category, that is, it is\nfaithful, lifts colimits and has discrete structures.\nThe proof of this property is too long to be included in this paper. However, it is\nuseful to explain what being coordinated means and why it is meaningful in this context.\nThe fact that e-CommUnity has discrete structures means that every signature Q has a\n\u2018canonical realisation\u2019 (a discrete lift) as a design dsgn(Q) = \u3008Q,\u2206\u3009 where the body \u2206 is\nthe tuple \u3008\u03b7, \u03c1, \u03b3\u3009 with:\n\u2014 For every service s, \u03c1(s) is the proposition true: that is, we make no commitments\nabout the effects of the execution of the service.\n\u2014 For every service s, both guards \u03b3l(s) and \u03b3u(s) are the proposition true: that is, we\nmake no commitments about the bounds of the enabling condition of the service.\n\u2014 For every event handler h, \u03b7(h) is the proposition true: that is, we make no requirements\nabout how subscribed events are handled.\nIn other words, dsgn(Q) is completely under specified. This canonical realisation is\nsuch that every morphism \u03c3 : Q \u2192 sign(\u3008Q\u2032,\u2206\u2032\u3009) is also a morphism of designs dsgn(Q)\u2192\n\u3008Q\u2032,\u2206\u2032\u3009. Hence, the cables in a configuration diagram are, basically, signatures and, indeed,\nthe calculation of a colimit takes place, essentially, in the underlying diagram of signatures:\nonce the signature of the colimit is computed, the body is \u2018lifted\u2019 in a canonical way from\nthe body of the components.\nThe colimit construction operates over signatures by amalgamating the events involved\nin each pub\/sub interconnection established by the configuration. From a mathematical\npoint of view, these events represent the quotient sets of events defined by the equivalence\nrelation that results from the pub\/sub interconnections. The corresponding sets of\nparameters are amalgamated in a similar way, as are services and their parameters.\nLifting the colimit of a diagram of signatures back to a design operates as follows. Let\n{s1, . . . , sn} be the quotient set of amalgamated services of the components of a system, and\n\u03c3ij be the signature morphism that identifies the component to which service sj belongs\nwithin the system. Then:\n\u2014 The transformations performed by an amalgamated service are specified by the\nconjunction of the specifications of the local effects of each of the services in the\nquotient set. That is, we have \u03c1({s1, . . . , sn}) = \u03c3i1 (\u03c1i1 (S1)) \u2227 . . . \u2227 \u03c3in (\u03c1in(sn)).\n\u2014 Guards operate in the same way, that is, \u03b3l({s1, . . . , sn}) = \u03c3i1 (\u03b3li1 (s1)) \u2227 . . . \u2227 \u03c3in(\u03b3lin(sn))\nand \u03b3ui1 ({s1, . . . , sn}) = \u03c3i1 (\u03b3ui1 (s1)) \u2227 . . . \u2227 \u03c3in(\u03b3uin (sn)).\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1053\n\u2014 The set of handlers of a subscribed event is also obtained through amalgamated sums\nand the handling requirement of a quotient set of handlers is also a conjunction:\n\u03b7({h1, . . . , hn}) = \u03c3i1 (\u03b7i1 (h1)) \u2227 . . . \u2227 \u03c3in (\u03b7in(hn)).\nThis explains the colimits that we have already computed in the paper for various\nconfiguration diagrams.\n5. Refinement and compositionality\nIn this section we define a formal notion of refinement that supports incremental\ndevelopment by removing under specification. As in Lopes and Fiadeiro (2004), we\ndistinguish between composition and refinement as design dimensions and formalise them\nthrough different notions of morphism, giving rise to two different but related categories\nof designs. We also show that this notion of refinement is compositional in the sense\nthat designs may be refined independently of the other components and the way they are\ninterconnected in a configuration.\n5.1. Refining designs\nWe define the notion of refinement in much the same way as in CommUnity, that is, by\ndefining a notion of morphism between designs through which we can add detail and\nremove under specification.\nDefinition\/Proposition 5.1. A refinement morphism \u00b5 : \u3008Q1,\u22061\u3009 \u2192 \u3008Q2,\u22062\u3009 consists of a\nsignature morphism \u00b5 : Q1 \u2192 Q2 such that:\n\u2014 The interface with the environment is preserved: the functions \u00b5ev , \u00b5sv , \u00b5par\u2212ev,e, \u00b5par\u2212sv,s,\n\u00b5hr\u2212ev,e, for every e\u2208E1 and s\u2208 S1, are injective.\n\u2014 Handling requirements are preserved: (\u03b72(\u00b5hr\u2212ev,e(h)) \u2283 \u00b5(\u03b71(h))) holds for every event\ne\u2208E1 and handling h\u2208H1(e).\n\u2014 Effects are preserved: (\u03c12(\u00b5sv(s)) \u2283 \u00b5(\u03c11(s))) holds for every s\u2208 S1.\n\u2014 Lower guards are preserved: (\u03b3l2(\u00b5sv(s)) \u2283 \u00b5(\u03b3l1(s))) holds for every s\u2208 S1.\n\u2014 Upper guards are reflected: (\u00b5(\u03b3u1(s)) \u2283 \u03b3u2(\u00b5sv(s))) holds for every s\u2208S1.\nDesigns and their refinement morphisms constitute a category rDSGN.\nA refinement morphism \u00b5 from designs C1 to C2 captures the way in which the\ndesign C1 of a given component is refined by a more concrete design C2 (of the same\ncomponent). Although refinement morphisms are based on the same signature mappings\nas superposition morphisms, there are some significant differences.\n\u2014 Every event and service of C1 is represented by a distinct event and service in C2; the\nsame applies to the set of event and service parameters, as well as event handlers. This\nmeans that refinement preserves the interface of the component: design decisions may\nbe made that add new events, services, parameters and handlers without collapsing\nthem since this would change the way other components may have been connected\nthrough the more abstract design.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1054\ndesign Actuator is\nsubscribe doAction\ninvokes action\nhandledBy action?\nprovide action\nFig. 18. The design of Actuator.\ndesign FBActuator is\nsubscribe doAction\ninvokes action\nhandledBy action?\npublish actioned\nprovide action\neffects actioned!\nFig. 19. The design of FBActuator.\n\u2014 The intervals provided by the guards for the enabling conditions of services are\npreserved in the sense that the refined interval is included in the abstract one. This\nmeans that refinement reduces the degree of under specification on enabling conditions.\nNote that superposition morphisms allow for this interval to be shifted to reflect the\nfact that a service shared by two components requires that both enabling conditions\nare true for the service to be executed.\nOtherwise, the conditions on the effects of services and the handling of events are the\nsame because they reduce the degree of under specification present in the abstract design.\nThis reflects the fact that superposition identifies ways in which complex components\nshare simpler components; as a result, their designs may complement each other where\nthey were under specified.\nAs an example, consider the high-level design of a typical Actuator, defined in Figure 18,\nthat provides a service action that can only be invoked through the publication of the\nevent doAction, the publication of which guarantees that action is indeed invoked.\nNote that in this description we do not provide any details of what exactly the action\ndoes or when it is enabled, that is, the execution of action is totally under specified.\nThis design can be regarded as an abstract description of Set. This is because if we map\ndoAction to doInc and action to inc, we define a refinement morphism from Actuator to\nSet. In fact, there are two ways of identifying Set as a refinement of Actuator because\nif we map doAction to doDec and action to dec, we also define a refinement morphism.\nSimilarly, Counter and Adder also refine Actuator in several ways.\nA more informative abstract description of Set is provided by the design FBActuator\npresented in Figure 19. This design refines Actuator by including feedback on the execution\nof action in the form of the publication of a new event actioned.\nNotice that this design is no longer refined by either Counter or Adder.\nAn abstraction of Set that is more specific in the way it can relate to other components\nis presented in Figure 20. Apart from the state variables, this design has the same signature\nas Set up to renaming. As result, it offers the same interactions with the environment as\nSet but is more abstract in the sense that it does not specify its state component.\nRefinement morphisms support the definition of hierarchies of \u2018kinds\u2019 or classes of\ncomponents, which is useful for defining architectural connectors as illustrated in Fiadeiro\net al. (2003). Figure 21 presents an example with the components involved in our running\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1055\ndesign 2FBActuator&Par is\nsubscribe doAction1\npar par:nat\ninvokes action1\nhandledBy action1?\naction1.which=par\nsubscribe doAction2\npar par:nat\ninvokes action2\nhandledBy action2?\naction2.which=par\npublish actioned1\npar par:nat\npublish actioned2\npar par:nat\nprovide action1\npar which:nat\neffects actioned1!\nactioned1.par=which\nprovide action2\npar which:nat\neffects actioned2!\nactioned2.par=which\nFig. 20. The design of 2FBActuator&Par.\nActuator\nCounter Adder\nFBActuator\n2FBActuator&Par\nSet\nFig. 21. Hierarchy of components of our running example.\nexample. Notice that, in order to represent refinement morphisms in diagrams, we use a\ndifferent arrow from the one we use for superposition.\n5.2. Reducts\nRefinement morphisms act on models of the corresponding designs through what is\nusually called a reduct mapping (or just reduct, for short). The definition of a reduct\nrequires that we are able to relate the semantic structures of both designs. In the rest of\nthe paper, we assume a fixed a refinement morphism \u00b5 : \u3008Q1,\u22061\u3009 \u2192 \u3008Q2,\u22062\u3009.\nProposition 5.2. A data signature morphism \u00b5 : \u03a31 \u2192 \u03a32 is defined by the morphism \u00b5\nbetween the corresponding extensions of the data signature \u03a3 by mapping:\n\u2014 every sort and operation of \u03a3 into itself;\n\u2014 de into d\u00b5(e), for every e\u2208E1;\n\u2014 dp : de \u2192 d into d\u00b5(p) : d\u00b5(e) \u2192 d, for every e\u2208E1, p\u2208P1(e)d and sort d in \u03a3;\n\u2014 invh,s : de \u2192 ds into inv\u00b5(h),\u00b5(s) : d\u00b5(e) \u2192 d\u00b5(s), for every e \u2208 Sub(E1), h\u2208H1(e) and\ns\u2208G1(h);\n\u2014 dp : ds \u2192 d into d\u00b5(p) : d\u00b5(s) \u2192 d, for every s\u2208 S1, p\u2208P1(s)d and sort d in \u03a3;\n\u2014 pubs,e : ds \u2192 de into pub\u00b5(s),\u00b5(e) : d\u00b5(s) \u2192 d\u00b5(e), for every s\u2208S1 and e\u2208Pub(E1).\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1056\nEvery such signature morphism \u00b5 : \u03a31 \u2192 \u03a32 induces a reduct functor |\u00b5 from the\nalgebras of \u03a32 to the algebras of \u03a31 (Ehrig and Mahr 1985). Such reducts extend to\nspaces in the sense that, applied to a Q2-space \u3008\u03a32,U\u3009, we get \u3008\u03a32,U|\u00b5\u3009 as a Q1-space.\nWe omit the proof of this result because it is quite simple. However, we would like to\npoint out that the injectivity of the functions \u00b5ev and \u00b5sv is necessary to ensure that the\nreducts of algebras extend to spaces.\nFrom now on, we assume a fixed Q2-space with an algebra U.\nDefinition 5.3. The \u00b5-reduct of a set of invocations INV , which we denote by INV |\u00b5, is\nthe set of triples \u3008t, h, u\u3009 such that:\n\u2014 t is an element of deU for some event e\u2208\u00b5ev(Sub(E1));\n\u2014 h\u2208H1(e);\n\u2014 u = inv\u00b5(h),sU (t) for some s\u2208\u00b5sv(G1(h));\n\u2014 \u3008t, \u00b5hr\u2212ev,e(h), u\u3009 \u2208INV .\nThat is, we get the set INV |\u00b5 by \u2018forgetting\u2019 those invocations in INV that result from\nthe handling of new events, or invoke new services, or result from a new handler for an\n\u2018old\u2019 event.\nDefinition 5.4. The \u00b5-reduct of an execution state EST = \u3008VAL, PDN\u3009 for Q2, which we\ndenote by EST |\u00b5, consists of:\n\u2014 the mapping that, to every data sort d\u2208D and state variable v \u2208V1d , assigns the value\nVAL(\u00b5st(v));\n\u2014 the \u00b5-reduct PDN |\u00b5 of PDN.\nThat is, variables are evaluated in the reduct of a state in the same way that their\ntranslations are evaluated in the original state. With regard to pending invocations, as\nmentioned earlier, the reduct \u2018forgets\u2019 those that result from the handling of new events,\nor invoke new services, or result from a new handler for an \u2018old\u2019 event. The following\nresults reflect the fact that what we obtain is an execution state for the source signature.\nProposition 5.5. The \u00b5-reduct of an execution state EST for Q2, in the sense that it satisfies\nthe conditions of Definition 3.3, is an execution state for Q1. Moreover, the \u00b5-reduct of\nany set of actual service invocations of EST , in the sense that it satisfies the conditions\nof Definition 3.4, is a set of actual invocations of EST |\u00b5.\nThe proof of this result is straightforward. We can now define how reducts act on\nexecution steps.\nDefinition\/Proposition 5.6. Given an execution step \u3008SRC,TRG, INV , EXC, PUB, NXT \u3009\nof Q2, its \u00b5-reduct is the execution step \u3008SRC |\u00b5, TRG |\u00b5, INV |\u00b5, EXC |\u00b5, PUB |\u00b5, NXT |\u00b5\u3009\nof Q1 where:\n\u2014 EXC |\u00b5 is the set of service instances u\u2208EXC such that u\u2208 dsU for some s\u2208 \u00b5sv(S1),\nthat is, that are instances of services in Q1.\n\u2014 PUB |\u00b5 is the set of event instances t\u2208PUB such that t\u2208 deU for some e\u2208 \u00b5ev(E1), that\nis, that are instances of events in Q1.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1057\nIn this case, we simply apply the reduct componentwise to each element of the execution\nstep. The sets EXC |\u00b5 of executed services and PUB |\u00b5 of published events are obtained\nby \u2018forgetting\u2019 the services and events that are not generated within Q1.\nDefinition\/Proposition 5.7. Given a model M of a signature Q2, its \u00b5-reduct is the model\nof Q1 obtained by taking the \u00b5-reduct of the Q2-space of M together with the direct\nacyclic graph of M and the labelling function L|\u00b5 that results from the application of\nthe reduct to the labels provided by L (that is, L|\u00b5 assigns the execution state L(n) |\u00b5 to\na node n and the execution step L(r) |\u00b5 to an arrow r).\nIn this way, the structure of the original model is preserved. The reduct only affects the\nlabelling of nodes and arrows, which is obtained by applying the corresponding reducts\nto the labels of the original model.\nFinally, we state the result that states that refinement morphisms are model preserving.\nDefinition\/Proposition 5.8. Given a model M of a design \u3008Q2,\u22062\u3009, its \u00b5-reduct M|\u00b5 is a\nmodel of the design \u3008Q1,\u22061\u3009.\nAs required, the refinement of a design may only eliminate models, reflecting the fact\nthat the degree of under specification is reduced. As a result, any refinement of a design\npreserves its properties. The proofs of Definitions\/Propositions 5.6, 5.7 and 5.8 are given\nin the Appendix.\n5.3. Compositionality\nRefinement and composition are handled through different kinds of morphisms, but\nthey can be related by a compositionality property according to which it is possible to\nrefine designs that are part of a configuration without interfering with either the other\ncomponents or the interconnections that are in place. We state and prove our results for\na special kind of colimits \u2013 pushouts \u2013 as this simple case generalises to the colimit of\nany finite diagram (Fiadeiro 2004).\nProposition 5.9. Let \u3008\u03c31 : dsgn(Q0) \u2192 D1, \u03c32 : dsgn(Q0) \u2192 D2\u3009 be a pair of superposition\nmorphisms in sDSGN with pushout \u3008\u03b11 : D1 \u2192 D, \u03b12 : D2 \u2192 D\u3009. Given a pair \u3008\u00b51 : D1 \u2192\nD\u20321, \u00b52 : D2 \u2192 D\u20322\u3009 of refinement morphisms in rDSGN, there exists a unique refinement\nmorphism \u00b5 : D \u2192 D\u2032 satisfying \u03b11; \u00b5 = \u00b51; \u03b1\u20321 and \u03b12; \u00b5 = \u00b52; \u03b1\u20322 in the category SIGN,\nwhere \u3008\u03b1\u20321 : D\u20321 \u2192 D\u2032, \u03b1\u20322 : D\u20322 \u2192 D\u2032\u3009 is the pushout of \u3008\u03c31; \u00b51, \u03c32; \u00b52\u3009 in sDSGN and\n(\u03c3i; \u00b5i) are the morphisms obtained by lifting the composition of the underlying signature\nmorphisms to sDSGN.\nNote that the fact that sDSGN is coordinated over SIGN ensures that any intercon-\nnections of designs can be established via their signatures, which is why we used dsgn(Q0)\nas a middle object in the given configuration (see Figure 22). As discussed in Section 4.3,\nthis design is a canonical realisation of a signature. The fact that this simplification does\nnot constitute a limitation is proved in Fiadeiro (2004).\nMore information on the relationship between refinement and superposition, and the\ncompositionality results that relate them can be found in Lopes and Fiadeiro (2004).\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1058\ndsgn(Q0)\nD1 D2\nD1' D2'\nD'\n1 2\nD\u00b5\n\u03c3\n\u03b1 \u03b1\n\u03b1 \u03b1\n\u03c3\n1 \u00b52\n1 2\n\u00b5\n1' 2'\nFig. 22. Compositionality of refinement with respect to superposition.\n6. Adding synchronous interactions\nAnother advantage of the categorical formalisation of publish\/subscribe is that it allows\nus to use this style in conjunction with other architectural modelling techniques, namely\nsynchronous interactions as in CommUnity. For instance, suppose we are now interested\nin restricting the insertion of elements in a set to keep the sum below a certain limit LIM.\nChanging the service add of Adder to\nprovide add\npar lm:nat\nassignsTo sum\nguardedBy sum+lm<LIM\neffects sum\u2019=sum+lm\ndoes not solve the problem because inserted, to which Adder subscribes, is published after\nthe element has been inserted in the set. What we need is to change the service insert of\nSet so as to strengthen its enabling condition with sum+ lm < LIM, and ensure that sum\nis updated by insert and delete. However, in order to do this within sDSGN, we would\nhave to redesign the whole system. Ideally, we would like to remain within the incremental\ndesign approach through which we superpose separate components to induce required\nbehaviour.\nOne possibility is to use action synchronisation and i\/o-communication as in Com-\nmUnity. More precisely, the idea is to synchronise Set and Adder to ensure that sum is\nupdated when insertions and deletions are made, and superpose a regulator to check the\nsum before allowing the insertion invocation to proceed. In CommUnity, actions capture\nsynchronisation sets of service invocations, something that is not intrinsic to implicit\ninvocation as an architectural style and, therefore, cannot be expressed in the formalism\npresented in the previous sections. Similarly, input and output channels are needed to\nmake sure that data is exchanged synchronously. This is why we will now extend the\nnotion of design in e-CommUnity with synchronisation constraints and communication\nchannels.\nAs an example, consider the revision of SCA given in Figure 23. Through the new\nprimitive synchronise we provide a sentence that defines the synchronisation sets of service\nexecution that can be observed at run time. For instance, through the sentence a \u2261 b, we\ncan specify that two given services a and b are always executed simultaneously. Hence, in\nthe example, insert and add are always performed synchronously.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1059\ndesign syncSet&Counter&Adder is\nstore elems: set(nat),\nvalue:nat, sum:nat\noutput mysum:nat\npublish&subscribe inserted\npar which:nat\ninvokes inc\nhandledBy inc?\npublish&subscribe deleted\npar which:nat\ninvokes dec\nhandledBy dec?\nsubscribe doInsert\npar which:nat\ninvokes insert\nhandledBy insert?\nwhich=insert.lm\nsubscribe doDelete\npar which:nat\ninvokes delete\nhandledBy delete?\nwhich=delete.lm\nsynchronise insert add\ninsert.lm=\n=\nadd.lm\nsub delete\nsub.lm=delete.lm\nconvey mysum=sum\nprovide insert\npar lm:nat\nassignsTo elems\nguardedBy\n[lm elems lm+mysum<LIM,false]\neffects elems\u2019={lm} elems\ninserted! inserted.which=lm\nprovide delete\npar lm:nat\nassignsTo elems\nguardedBy lm elems\neffects elems\u2019=elems\\{lm}\ndeleted! deleted.which=lm\nprovide inc\nassignsTo value\neffects value\u2019=value+1\nprovide add\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum+lm\nprovide sub\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum-lm\nprovide dec\nassignsTo value\neffects value\u2019=value-1\n\u2228\n\u2228\n\u2228\n\u2228\n\u2228\n\u2228\n\u2228\n\u2228\n\u2228\n\u2228\n\u2228\nFig. 23. The design of syncSet&Counter&Adder.\nThrough convey we establish how the output channels relate to the state variables. In\nthe example, we are just making the sum directly available to be read by the environment\nthrough mysum. The idea is that sum \u2018belongs\u2019 to the adder but needs to be observed\nby the set in order to determine if insertions are allowed. The output channel mysum\ndoes exactly this, that is, it allows a component to make data available synchronously to\nother components in the same system (as above) or the environment. This is why we can\nstrengthen the guard of insert with the condition lm+ mysum < LIM.\nWe can now formalise the extension, starting with signatures.\nDefinition 6.1. We define an extended signature QI,O to be a signature Q together with two\nD indexed families I and O of mutually disjoint finite sets (of input and output channels,\nrespectively).\nOur next step deals with the semantic model. Basically, we have to provide the structures\nthrough which we can interpret channels and synchronisation constraints. This concerns\nboth execution states and steps.\nCommunication channels are interpreted over execution states by extending the valu-\nation mappings.\nDefinition 6.2. An extended execution state for an extended signature QI,O is an execution\nstate for Q with its valuation mapping VAL extended to I and O, that is, to every data\nsort d\u2208D and channel c\u2208 Id \u2229 Od, VAL assigns a value VAL(c)\u2208dD.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1060\nFig. 24. Representation of the elements involved in extended execution steps.\nExecution steps are extended with an additional set RZV of service instances corres-\nponding to the executions that result from synchronisation constraints. These additional\nexecutions have to satisfy the requirement that there can be no more than one execution\nof an instance of any service at any given step.\nDefinition 6.3. An extended execution step for an extended signature QI,O is an execution\nstep for Q together with a set RZV of service instances such that, for every s\u2208 S , there is\nat most one u\u2208 dsU \u2229 RZV .\nThe set RZV contains the service instances that are executed during that step. It may\nexclude some of the instances in EXC , that is, instances that have been invoked and are\nenabled. This may happen, for instance, because the excluded services are synchronised\nwith other services that are not enabled. That is, the synchronisation requirements may\nimpose the execution of services that were not directly invoked, but they may also exclude\ninvoked services that would otherwise be executed. However, as discussed in the definition\nof a model, we impose a \u2018maximality\u2019 constraint on RZV with respect to EXC that\nmakes sure that only as many enabled invocations are discarded as necessary to satisfy\nthe synchronisation constraints.\nThe Figure 24 reflects the structure of an extended execution step.\nWe can now define the languages over which we can specify both observation and\nsynchronisation constraints \u2013 the former involves output channels and state variables.\nDefinition 6.4. Given an extended signature QI,O we define the observation language OLQ,I,O\nassociated with Q as the first-order language generated by the data signature \u03a3 = \u3008D, F\u3009\nenriched with:\n\u2014 for every sort d\u2208D, each output channel o\u2208Od as a constant of sort d;\n\u2014 for every sort d\u2208D, each state variable v\u2208Vd as a constant of sort d.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1061\nGiven an extended execution state, we evaluate the sentences of OLQ,I,O in the extension\nof the \u03a3-algebra D using:\n\u2014 oD = VAL(o).\n\u2014 vD = VAL(v).\nThe synchronisation constraints are expressed in a language that involves services and\ntheir parameters.\nDefinition 6.5. Given an extended signature QI,O , we define the synchronisation language\nSLQ,I,O associated with Q as the first-order language generated by the data signature\n\u03a3 = \u3008D, F\u3009 enriched with:\n\u2014 for every s\u2208 S and d\u2208D, each parameter p\u2208P (s)d as a constant of sort d;\n\u2014 for every service s\u2208 S , the atomic proposition s.\nGiven an extended execution step, we evaluate the sentences of SLQ,I,O in the extension\nof the \u03a3-algebra D with:\n\u2014 pD = dpU(u) for s\u2208 S , p\u2208P (s) and u\u2208 dsU such that u\u2208 dsU \u2229 RZV if dsU \u2229 RZV \u0007=\u0001.\n\u2014 s is true if and only if dsU \u2229 RZV \u0007=\u0001.\nWe use s as a proposition to denote the fact that an instance of service s is executed\nduring a step, either in response to an invocation or as a result of a synchronisation. Note\nthat this is different from the invocation of s, which we denoted by s?; the invocation is\nevaluated over NXT , whereas the execution refers to RZV .\nFinally, we extend the state and transition languages defined in Section 3 in order to\nallow communication channels to be used both in guards and in the specification of the\neffects of services.\nDefinition 6.6. The state and transition languages associated with QI,O are those of Q\nextended with each input channel i\u2208 Id as a constant of sort d, and every output channel\no\u2208Od as a state variable of sort d. For every execution state, we extend every \u03a3-algebra\nD with iD = VAL(i) and, for every execution step, oD = VALSRC(o) and o\u2032D = VALTRG(o).\nGiven this, we can define designs in extended signatures.\nDefinition 6.7. An extended design over QI,O is a tuple \u3008\u03b7, \u03c1, \u03b3, \u03b2, \u03c7\u3009 where \u3008\u03b7, \u03c1, \u03b3\u3009 is a\ndesign for Q in which I and O can be used in the languages of \u03c1 and \u03b3, and:\n\u2014 \u03b2 \u2208OLQ,I,O is a sentence establishing what observations of the local state are made\navailable through the output channels.\n\u2014 \u03c7\u2208 SLQ,I,O is a sentence establishing dependencies between service execution that need\nto be observed at every step.\nThe corresponding notion of model is as follows.\nDefinition 6.8. A model of an extended design \u3008QI,O,\u2206\u3009 where \u2206 = \u3008\u03b7, \u03c1, \u03b3, \u03b2, \u03c7\u3009 is a model\nof QI,O such that any label \u3008SRC,TRG, INV , EXC,RZV , PUB,NXT \u3009 of an arrow of\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1062\nthe underlying graph satisfies the following conditions:\n\u2014 For every u\u2208EXC with u\u2208 dsU, we have \u03b3l(s) holds for u at SRC .\n\u2014 For every \u3008t, h, u\u3009 \u2208INV and u\u2208 dsU, if \u03b3u(s) holds for u at SRC , then u\u2208EXC .\n\u2014 For every u\u2208RZV with u\u2208 dsU, we have \u03b3l(s) holds for u at SRC .\n\u2014 For every u\u2208RZV with u\u2208 dsU, we have \u03c1(s) holds for u at that step.\n\u2014 For every t\u2208PUB where t\u2208 deU and h\u2208H(e), we have \u03b7(h) holds for t and h at that\nstep.\n\u2014 \u03b2 is true at TRG.\n\u2014 \u03c7 is true at that step.\n\u2014 If u\u2208EXC and u \/\u2208 RZV , there is no step \u3008SRC, , INV , EXC,RZV \u2032, , \u3009 with\nRZV \u2032 \u2287 RZV and u\u2208RZV \u2032 such that all the previous conditions hold for that step.\n\u2014 There is no step \u3008SRC, , INV , EXC,RZV \u2032, , \u3009 with RZV \u2032 \u2282 RZV such that all\nthe previous conditions hold for that step.\n\u2014 If u\u2208EXC and u \/\u2208 RZV , and there is a step \u3008SRC, , INV , EXC,RZV \u2032, , \u3009 such\nthat u\u2208RZV \u2032 and all the previous conditions hold for that step, then there is an arrow\nof the underlying graph that has the same source node and is labelled with that step.\nThe first and second condition repeat what we defined for models of the original\ndesigns. The third condition is like the first but applied to RZV . The fourth condition\nrepeats the requirements for models of the original designs but applied to RZV instead\nof EXC; this is because the services that are executed are those in RZV , which may\ninclude only some of those in EXC . The fifth condition is also as for the original designs.\nThe sixth and seventh conditions address the new sets of requirements on observations\nand synchronisations. The eighth condition captures, in a sense, a notion of \u2018maximality\u2019\nwith respect to EXC: invoked services that can be executed in spite of synchronisation\nconstraints should be part of a step. The ninth condition captures a notion of \u2018minimality\u2019\nof RZV : no more services should be executed than those necessary for fulfilling the\nsynchronisation constraints. Finally, the tenth condition adds to the maximality property\ngiven by the eighth condition the fact that all options should be reflected in the same\nmodel.\nNote that because service synchronisations are specified through a sentence in which\nservices are used as atomic propositions, every model defines a number of sets of services \u2013\nthose that correspond to the propositional models of the synchronisation constraint. For\ninstance, in a language of propositions (services) {a, b, c}, the (synchronisation) constraint\n(a \u2283 b) admits as models the subsets {}, {c}, {b}, {b, c},{a, b} and {a, b, c}. In other words,\nit excludes the sets that contain a but not b.\nThese propositional models correspond to the synchronisation sets used for interpreting\nactions in CommUnity. The difference is that in e-CommUnity we are not synchronising\nactions as sets of service executions, but imposing constraints on the way these service can\nbe executed with respect to each other. In other words, whereas by binding action names,\nCommUnity offers an \u2018operational\u2019 account of synchronisation through its universal\nconstructions, e-CommUnity is \u2018declarative\u2019; the bindings established in e-CommUnity\nthrough cables do not synchronise independent services, they identify them. We will\nresume this discussion at the end of this section.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1063\ndesign syncAdder is\nprovide add\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum+lm\nprovide sub\npar lm:nat\nassignsTo sum\neffects sum\u2019=sum-lm\nstore sum:nat\noutput mysum:nat\nconvey mysum=sum\nFig. 25. The design of syncAdder.\nIt remains to show how we can externalise the extension in much the same way as we\ndid in Section 4. The following design captures the synchronisation:\ndesign sync is\nsynchronise a b\na.p=b.p\nprovide a\npar p:nat\nprovide b\npar p:nat\nIn order to strengthen the guard of insert, we need a component that reads the state of\nAdder to determine if insert can proceed:\ndesign control is\ninput i:nat\nprovide s\npar n:nat\nguardedBy n+i<LIM\nThis leads us to a new configuration, presented in Figure 26, in which syncAdder is\nmodelled as a component prepared for synchronous interaction (see Figure 25).\nNotice that sync and control are, like mediators, separate components that interconnect\nindependent components: syncAdder and Set are unaware that they are being synchronised,\nand syncAdder does not know who is connected to its output channel; we can replace sync\nby another interaction protocol without disturbing syncAdder and Set. Therefore, we can\nclaim that we have not increased the degree of coupling and compromised the evolutionary\nproperties of systems by adding synchronous interactions to implicit invocations.\nThe proposed extension of e-CommUnity is supported by the following notion of\nmorphism.\nDefinition 6.9. A morphism \u03c3 between extended signatures\n\u3008V1, E1, S1, P1, T1, A1, G1, H1, I1, O1\u3009\nand\n\u3008V2, E2, S2, P2, T2, A2, G1, H2, I2, O2\u3009\nis a morphism between signatures\n\u3008V1, E1, S1, P1, T1, A1, G1, H1\u3009\nand\n\u3008V2, E2, S2, P2, T2, A2, G2, H2\u3009\ntogether with \u03c3in : I1 \u2192 I2 \u2229 O2 and \u03c3out : O1 \u2192 O2.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1064\nFig. 26. A new configuration of set\u2013counter.\nThat is, as in CommUnity, input channels may become output channels of the system,\nbut not the other way around.\nDefinition 6.10. A morphism between \u3008\u03b71, \u03c11, \u03b31, \u03b21, \u03c71\u3009 and \u3008\u03b72, \u03c12, \u03b32, \u03b22, \u03c72\u3009 is a morph-\nism between \u3008\u03b71, \u03c11, \u03b31\u3009 and \u3008\u03b72, \u03c12, \u03b32\u3009 such that the observation and synchronisation\ndependencies are preserved: \u03a6 \u0011 \u03b22 \u2283 \u03c3(\u03b21) and \u03a6 \u0011 \u03c72 \u2283 \u03c3(\u03c71).\nNotice that this is an extension of the previous notion of morphism, that is, morphisms\nbetween designs that do not involve communication channels and synchronisations\nare as before. According to this notion of morphism, synchronisation and observation\ndependencies can be strengthened, that is, a system may impose new synchronisations\namong services of the component and new observations of the state of the component.\nHowever, note that, at the level of synchronisation sets, morphisms operate in a\ncontravariant way: the inverse image \u03c3\u22121ac (ss2) of every synchronisation set ss2 of P2 is\na synchronisation set of P1. To understand why this is so, consider the case in which\nthe morphism is an inclusion over services. This means that the implication (\u03c72 \u2283 \u03c71)\nholds, which implies that every model (synchronisation set) of \u03c72 projects to a model\nof \u03c71 by discarding the propositions (services) that are not in the language of S1. This\ncontravariant behaviour reflects the way signature morphisms were used in the previous\ngeneration of CommUnity.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1065\nIn terms of the colimit construction, synchronisation dependencies are also composed\nas a conjunction of the dependencies of the components: \u03c7 = \u03c31(\u03c71) \u2227 . . . \u2227 \u03c3n(\u03c7n). Again,\nthis reflects the fact that colimits operate on synchronisation sets through fibred products:\nthese compute intersections of inverse images of synchronisation sets of components,\nwhich is the way actions are synchronised in CommUnity.\nEvery design in e-CommUnity is also an extended design in a canonical way by\nconsidering that the set of communication channels is empty, and including observation\nand synchronisation constraints that are tautological. However, note that this relationship\ndoes not extend to an adjunction: there is an adjunction between the corresponding\ncategories of signatures, but it does not lift to designs, much in the same way that, in\nlogics, adjunctions between categories of signatures lift to the categories of theories but\nnot of presentations (Fiadeiro 2004).\nOn the other hand, every model of a design provides a model for its canonical extended\ndesign by making RZV equal to EXC . Furthermore, the maximality and minimality\nconditions ensure that this is the only possible choice for RZV : on the one hand, we\ncannot exclude enabled invocations from RZV because of the eighth condition; on the\nother hand, we cannot add more invocations because of the ninth condition. In other\nwords, every design and its canonical extended design have essentially the same models,\nmeaning that the extension is \u2018conservative\u2019 in a model-theoretic sense.\n7. Conclusions and further work\nIn this paper, we have presented an extended account of the formalisation of the\narchitectural style known as \u2018publish\/subscribe\u2019 or \u2018implicit invocation\u2019 that we started in\nFiadeiro and Lopes (2006). Other formal models (see, for example, Dingel et al. (1998)\nand Garlan et al. (2003)) exist that abstract away from concrete notions of event and\nrelated notification mechanisms, but they just address the computational aspects of the\nparadigm, which is necessary for supporting, for instance, several forms of analysis. Our\nwork addresses both the computational and the architectural properties of the paradigm,\nthat is, how connectors can be defined and superposed over components to coordinate\ntheir interactions.\nFor the computational model, we have proposed a mathematical semantics based on\ntransition systems extended with the publication of events and invocation of (atomic)\nservices. As mentioned in Section 2, we are now extending this framework to address\nthe full expressive power of conversational services in the sense of Service-Oriented\nArchitectures (Alonso et al. 2004). See Fiadeiro et al. (2006; 2007) for a preliminary\naccount of this approach.\nWe have defined several logics that support the high-level specification of different\naspects of component behaviour. However, such logics do not support verification of\nproperties as such; we are currently developing a modal logic that supports the analysis\nof several classes of properties. This modal logic semantics should also give rise to a\nfunctor that captures the way properties emerge from interconnections.\nFor the architectural model, our formalisation has allowed us to characterise key\nstructural properties of the architectural style for the externalisation of bindings and\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1066\nmediators previously claimed in papers such as Sullivan and Notkin (1992). Terms like\n\u2018separate\u2019 and \u2018independent\u2019 were given a precise interpretation in our framework, which\nwe claim is faithful to the one given in Sullivan and Notkin (1992): mediators are separate\ncomponents in the sense that they are defined as first-class citizens that maintain a state\nand can publish and subscribe events as required to coordinate the behaviour of other\ncomponents; components remain independent in the sense that they do not invoke any\nother component (including mediators) other than themselves. The ability to support a\ndesign approach in which mediators can be dynamically superposed over such independent\ncomponents derives from the externalisation of bindings. From a mathematical point of\nview, these properties derive from the fact that the (forgetful) functor that maps the\ncategory of designs to that of signatures has the strong structural property of being\ncoordinated, as explained in Fiadeiro (2004).\nFurthermore, the proposed categorical semantics has allowed us to propose extensions\nto what is normally available in event-based languages. On the one hand, e-CommUnity\nsupports under specification and refinement, that is, the ability to design systems in\nwhich components, mediators and their interconnections have been established but not\nthe circumstances in which they actually publish events, how they subscribe events or\nhow their services operate. Refinement is the process through which we can add detail to\nthe designs of these components in a stepwise fashion. We have proved that this process\nis compositional with respect to superposition, that is, that the designs of components\ncan be refined independently of the way they are interconnected. We believe that the\nseparation between superposition and refinement as design dimensions is an essential one,\nand that compositionality results are key for any architectural style to be able to address\nthe complexity of software development (Lopes and Fiadeiro 2004).\nThe second extension that we proposed concerns the way in which implicit invocation\ncan be used together with synchronous forms of interconnection as previously formalised\nthrough the language CommUnity. More precisely, we have added channels for (syn-\nchronous) input\/output communication, and a rendez vous style of synchronisation of\nservice executions. We have shown how these new forms of interaction do not increase the\ndegree of coupling nor compromise the evolutionary properties of implicit invocation. In\nparticular, we have shown how synchronous interactions may themselves be externalised in\nseparate mediators, and how communication channels are not connected through explicit\nnaming but through external bindings. Again, the proposed categorical formalisation was\nkey for showing how all these dimensions can be brought together.\nFurther work is going on towards exploiting this categorical framework to support\nthe integration of several architectural styles. For instance, we should be able to extend\ne-CommUnity with the primitives that we used for extending CommUnity to capture\ndistribution and mobility (Lopes and Fiadeiro 2006) as well as context-awareness (Lopes\nand Fiadeiro 2005). However, we are still in the initial stages of what could be called\n\u2018architectural engineering\u2019, by which we mean the ability to identify, characterise and\ncompose architectural \u2018aspects\u2019 to define an architectural style for a particular class of\napplications. Our current work on providing an algebraic approach to service-oriented\narchitecture (Fiadeiro et al. 2007) should provide us with more insight into the engineering\nof architectural styles.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1067\nAppendix A. Notation\nSignatures\nA(s) The write frame (or domain) of service s, that is, the state variables that any\nexecution of s can change.\nThis set is declared under assignsTo.\nA(v) The set of services that can change the state variable v.\ns \u2208 A(v) if and only if v \u2208 A(s).\nD The set of data sorts.\nE The set of all the events either published or subscribed to by a component.\nF Family of operations on data.\nG(h) The set of services that can be invoked through handler h.\nThis set is declared under invokes.\nG(s) The set of handlers that can invoke s.\nh \u2208 G(s) if and only if s \u2208 G(h).\nH(e) The set of handlers that react to the notifications that e has occurred.\nEach handler h declares, under invokes, the set G(h) of services that it can\ninvoke and, under handledBy, the condition \u03b7(h) that specifies how such services\nare invoked.\nId The set of input channels of sort d.\nA channel i \u2208 Id is declared under input i:d.\nOd The set of output channels of sort d.\nA channel o \u2208 Od is declared under output o:d.\nP (e)d The set of parameters of event e that are of sort d.\nA parameter p \u2208 P (e)d is declared under par p:d.\nP (s)d The set of parameters of service s that are of sort d.\nA parameter p \u2208 P (s)d is declared under par p:d.\nS The set of all services of a component.\nEach service is declared under provide.\nT (e) The type of event e: pub (published only), sub (subscribed only) or pubsub\n(published and subscribed).\nVd The set of state variables of sort d.\nA variable v \u2208 Vd is declared under store v : d.\nDesign bodies\n\u03b2 A sentence that establishes what observations of the local state are made\navailable through the output channels.\nThis sentence is declared under convey.\n\u03b3l(s) The lower guard of service s, that is, a sentence that, when false, implies that\nthe execution of s is not enabled.\nThis sentence is declared under guardedBy as part of a pair [\u03b3l(s), \u03b3u(s)].\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1068\n\u03b3u(s) The upper guard of service s, that is, a sentence that, when true, implies that\nthe execution of s is enabled.\nThis sentence is declared under guardedBy as part of a pair [\u03b3l(s), \u03b3u(s)].\n\u03b7(h) A sentence that specifies how the services in G(h) are invoked by h.\nThis sentence is declared under handledBy.\n\u03c1(s) A sentence that specifies how the execution of service s changes the state\nvariables declared in A(s) and publishes the events declared in B(s).\nThis sentence is declared under effects.\n\u03c7 A sentence that establishes synchronisation dependencies on the execution of\nservices.\nThis sentence is declared under synchronise.\nSemantic models\nEXC Invoked service instances that are enabled.\ninv\nh,s\nU (t) The instance of s invoked by handler h for the event instance t.\nINV Service invocations selected for an execution step.\nNXT Service invocations generated by an execution step.\nPDN Service invocations pending in a given state.\npub\ns,e\nU (u) The instance of e published when the instance u of service s is executed.\nPUB Event instances published during an execution step.\nRZV Service instances that result from the synchronisation constraints applied to\nEXC .\nSRC Source state of an execution step.\nTRG Target state of an execution step.\nVAL(v) Value of state variable v in a given state.\nAppendix B. Proofs\nDefinition 5.6 Given an execution step\nSTP = \u3008SRC,TRG, INV , EXC, PUB,NXT \u3009\nof Q2, its \u00b5-reduct is the execution step\n\u3008SRC |\u00b5, TRG |\u00b5, INV |\u00b5, EXC |\u00b5, PUB |\u00b5, NXT |\u00b5\u3009\nof Q1 where\n\u2014 EXC |\u00b5 is the set of service instances u\u2208EXC such that u\u2208 dsU for some s\u2208 \u00b5sv(S1),\nthat is, that are instances of services in Q1.\n\u2014 PUB |\u00b5 is the set of event instances t\u2208PUB such that t\u2208 deU for some e\u2208 \u00b5ev(E1), that\nis, that are instances of events in Q1.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1069\nProof. We prove that STP |\u00b5 is indeed an execution step of Q1. This requires us to\nprove that:\n\u2014 For every u\u2208EXC |\u00b5 there is \u3008t, h\u2032, u\u3009 \u2208 INV |\u00b5: If u\u2208EXC |\u00b5, then u\u2208 for some\ns\u2208 \u00b5sv(S1) and u\u2208EXC . Supose that s\u2032 \u2208 S1 and \u00b5(s\u2032) = s. Because STP is an execution\nstep of Q2, there exists \u3008t, h, u\u3009 \u2208INV such that:\n\u2013 t\u2208 deU for some e\u2208 Sub(E2).\n\u2013 h\u2208H2(e).\n\u2013 u = invh,sU (t) and s\u2208G2(h); this is because algebras of spaces assign disjoint carrier\nsets to different services and u\u2208 dsU, that is, the service that invokes e must be an\ninstance of s.\nOn the one hand, from \u00b5(s\u2032) = s\u2208G2(h) and the fact that \u00b5 is a refinement morphism,\nit follows that there is h\u2032 \u2208G1(s\u2032) such that \u00b5(h\u2032) = h. This implies that s\u2032 \u2208G1(h\u2032). On\nthe other hand, \u00b5(h\u2032) = h\u2208H2(e) and the fact that \u00b5 is a refinement morphism implies\nthat e\u2208 \u00b5(Sub(E1)) and, hence, there is e\u2032 \u2208E1 such that \u00b5(e\u2032) = e and h\u2032 \u2208H1(e\u2032). It\nthen follows that \u3008t, h\u2032, u\u3009 \u2208INV |\u00b5.\n\u2014 For every \u3008t, h\u2032, u\u3009 \u2208NXT |\u00b5, t\u2208PUB |\u00b5.\nIf \u3008t, h\u2032, u\u3009 \u2208 NXT |\u00b5, then \u3008t, \u00b5(h\u2032), u\u3009 \u2208 NXT and t\u2208 dsU for some e\u2208 \u00b5(Sub(E1)).\nBecause STP is an execution step of Q2, we have t\u2208PUB, so t\u2208PUB |\u00b5.\n\u2014 PDNTRG |\u00b5= PDNSRC |\u00b5 \\INV |\u00b5 \u222aNXT |\u00b5.\nThis is a simple consequence of a general result: for every pair A,B of sets of\ninvocations, (A \u222a B) |\u00b5= A |\u00b5 \u222aB |\u00b5 and (A\\B) |\u00b5= A |\u00b5 \\B |\u00b5.\n\u2014 For every v \u2208V1 such that VALTRG |\u00b5 (v) \u0007= VALSRC |\u00b5 (v), there is u\u2208EXC |\u00b5 with\nu\u2208 dsU|\u00b5 such that v \u2208A1(s).\nIf VALTRG |\u00b5 (v) \u0007= VALSRC |\u00b5 (v), then VALTRG(\u00b5(v)) \u0007= VALSRC(\u00b5(v)). Because STP\nis an execution step of Q2, there is u\u2208EXC with u\u2208 dsU such that \u00b5(v)\u2208A2(s\u2032). Because\n\u00b5 is a refinement morphism, \u00b5(v)\u2208A2(s\u2032) implies that there is s\u2208 S1 such that \u00b5(s\u2032) = s\nand v\u2208A1(s). This also implies that u\u2208EXC |\u00b5.\nDefinition 5.7 Given a model M of a signature Q2, its \u00b5-reduct is the model of Q1 obtained\nby considering the \u00b5-reduct of the Q2-space of M together with the direct acyclic graph\nof M and the labelling function L|\u00b5 that results from the application of the reduct to the\nlabels provided by L (that is, L|\u00b5 assigns the execution state L(n) |\u00b5 to a node n and the\nexecution step L(r) |\u00b5 to an arrow r).\nProof. We prove that M|\u00b5 is indeed a model of Q1. This requires the proof of the\nfollowing:\n\u2014 For every arrow r = \u3008n1, n2\u3009, L|\u00b5 (r) is of the form \u3008L|\u00b5 (n1),L|\u00b5 (n2), , , , \u3009.\nThis follows trivially from the definition of L|\u00b5 and the fact that, because M is a\nmodel of Q2, L(r) is of the form \u3008L(n1),L(n2), , , , \u3009.\n\u2014 VALTRG |\u00b5 (v) = VALTRG\u2032 |\u00b5 (v) for every state variable v \u2208V1 and every pair of\narrows r = \u3008n, m\u3009 and r\u2032 = \u3008n, m\u2032\u3009 such that there are s\u2208A1(v), u\u2208 dsU|\u00b5 \u2229 EXC |\u00b5\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1070\n\u2229EXC \u2032 |\u00b5, where L|\u00b5 (r) and L|\u00b5 (r\u2032) are of the form \u3008 , TRG |\u00b5, , EXC |\u00b5, , \u3009 and\n\u3008 , TRG\u2032 |\u00b5, , EXC \u2032 |\u00b5, , \u3009, respectively.\nIt follows from the hypothesis and the fact that \u00b5 is a refinement morphism that\nthere are \u00b5(s)\u2208A2(\u00b5(v)), u\u2208 d\u00b5(s)U \u2229 EXC \u2229 EXC \u2032, where L(r) and L(r\u2032) are of the\nform \u3008 , TRG, , EXC, , \u3009 and \u3008 , TRG\u2032, , EXC \u2032, , \u3009, respectively. Given that\nM is a model of Q2, we have that VALTRG(\u00b5(v)) = VALTRG(\u00b5(v)), which implies that\nVALTRG |\u00b5 (v) = VAL\u2032TRG |\u00b5 (v).\n\u2014 For any two arrows r = \u3008n, m\u3009 and r\u2032 = \u3008n, m\u2032\u3009 where L|\u00b5 (r) and L|\u00b5 (r\u2032) are of\nthe form \u3008 , , INV |\u00b5, EXC |\u00b5, , \u3009 and \u3008 , , INV \u2032 |\u00b5, EXC \u2032 |\u00b5, , \u3009, respectively,\nand service instance u such that \u3008 , , u\u3009 \u2208 INV |\u00b5 and \u3008 , , u\u3009 \u2208 INV \u2032 |\u00b5, we have\nu\u2208EXC |\u00b5 if and only if u\u2208EXC \u2032 |\u00b5.\nThe hypothesis implies that L(r) and L(r\u2032) are of the form \u3008 , , INV , EXC, , \u3009\nand \u3008 , , INV \u2032, EXC \u2032, , \u3009, respectively. Furthermore, \u3008 , , u\u3009 \u2208INV and u\u2208 dsU for\nsome s\u2208 \u00b5sv(S1). Given that M is a model of Q2, u\u2208EXC if and only if u\u2208EXC \u2032.\nGiven that u\u2208 dsU for some s\u2208 \u00b5sv(S1), we conclude that u\u2208EXC |\u00b5 if and only if\nu\u2208EXC \u2032 |\u00b5.\nDefinition 5.8 Given a model M of a design \u3008Q2,\u22062\u3009, its \u00b5-reduct M|\u00b5 is a model of the\ndesign \u3008Q1,\u22061\u3009.\nProof. We begin by stating some auxiliary results related to the satisfiability of the\ntranslation of sentences in the languages HLQ1 ,h, SLQ1 ,s and TLQ1 ,s induced by refinement\nmorphisms in the corresponding interpretation structures and the satisfiability of the\noriginal formulas in the corresponding reducts.\nLet h be a handler of an event e in Q1, t\u2208 dsU|\u00b5 , s be a service in Q1, u\u2208 deU|\u00b5 , and\nSTP = \u3008SRC,TRG, INV , EXC, PUB,NXT \u3009 be an execution step for Q2.\n\u2014 Every sentence \u03c6 in HLQ1 ,h holds for t and h at STP |\u00b5 if and only if \u00b5(\u03c6) holds for t\nand \u00b5(h) at STP .\n\u2014 Every sentence \u03c6 in SLQ1 ,s holds for u at SRC |\u00b5 if and only if \u00b5(\u03c6) holds for u at\nSRC .\n\u2014 Every sentence \u03c6 in TLQ1 ,s holds for u at STP |\u00b5 if and only if \u00b5(\u03c6) holds for u at\nSTP .\nIn order to prove that M|\u00b5 is indeed a model of \u3008Q1,\u22061\u3009, we must prove that for every\nexecution step STP |\u00b5= \u3008SRC |\u00b5, TRG |\u00b5, INV |\u00b5, EXC |\u00b5, PUB |\u00b5, NXT |\u00b5\u3009 that is the label\nof an arrow of the underlying graph, the following properties hold:\n\u2014 For every u\u2208EXC |\u00b5 with u\u2208 dsU|\u00b5 , we have \u03b3l1(s) holds for u at SRC |\u00b5.\nIf u\u2208EXC |\u00b5, then u\u2208 dsU for some s\u2208 \u00b5sv(S1) and u\u2208EXC . Given that M is a model\nof \u3008Q2,\u22062\u3009 and dsU|\u00b5 = d\n\u00b5(s)\nU , we have \u03b3l2(\u00b5(s)) holds for u at SRC . Given that \u00b5 is\na refinement morphism, \u03b3l2(\u00b5sv(s)) \u2283 \u00b5(\u03b3l1(s)) holds and, hence, \u00b5(\u03b3l1(s)) holds for u at\nSRC . As a consequence of the auxiliary result enunciated above, \u03b3l1(s) holds for u at\nSRC |\u00b5.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1071\n\u2014 For every \u3008t, h, u\u3009 \u2208INV |\u00b5 and u\u2208 dsU|\u00b5 , if \u03b3u1(s) holds for u at SRC |\u00b5, then u\u2208EXC |\u00b5.\nOn the one hand, if \u3008t, h, u\u3009 \u2208INV |\u00b5 and u\u2208 dsU|\u00b5 , then \u3008t, \u00b5(h), u\u3009 \u2208INV and u\u2208 dsU for\nsome s\u2208 \u00b5sv(S1). On the other hand, as a consequence of the auxiliary result enunciated\nabove, if \u03b3u1(s) holds for u at SRC |\u00b5, then \u00b5(\u03b3u1(s)) holds for u at SRC . Given that \u00b5\nis a refinement morphism, \u00b5(\u03b3u1(s)) \u2283 \u03b3u2(\u00b5sv(s)) holds, so \u03b3u2(\u00b5sv(s)) holds for u at SRC .\nGiven that M is a model of \u3008Q2,\u22062\u3009 and dsU|\u00b5 = d\n\u00b5(s)\nU , we know that u\u2208EXC . Because\nu\u2208 dsU for some s\u2208 \u00b5sv(S1), we conclude that u\u2208EXC |\u00b5.\n\u2014 For every u\u2208EXC |\u00b5 with u\u2208 dsU|\u00b5 , we have \u03c11(s) holds for u at STP |\u00b5.\nIf u\u2208EXC |\u00b5, then u\u2208 dsU for some s\u2208 \u00b5sv(S1) and u\u2208EXC . Given that M is a model\nof \u3008Q2,\u22062\u3009 and dsU|\u00b5 = d\n\u00b5(s)\nU , we have \u03c12(\u00b5(s)) holds for u at STP . Given that \u00b5 is a\nrefinement morphism, \u03c12(\u00b5sv(s)) \u2283 \u00b5(\u03c11(s)) holds, so \u00b5(\u03c11(s)) holds for u at STP . As a\nconsequence of the auxiliary result stated above, \u03c11(s) holds for u at STP |\u00b5.\n\u2014 For every t\u2208PUB |\u00b5 where t\u2208 deU|\u00b5 and h\u2208H1(e), we have \u03b71(h) holds for t and h at\nSTP |\u00b5.\nIf t\u2208PUB |\u00b5, then t\u2208 deU for some e\u2208 \u00b5ev(E1) and t\u2208PUB. Moreover, because \u00b5 is a\nrefinement morphism, h\u2208H1(e) implies that \u00b5(h)\u2208H2(\u00b5(e)). Given that M is a model\nof \u3008Q2,\u22062\u3009 and deU|\u00b5 = d\n\u00b5(e)\nU , we have \u03b72(\u00b5(h)) holds for t and \u00b5(h) at STP . Again\nbecause \u00b5 is a refinement morphism, \u03b72(\u00b5(h)) \u2283 \u00b5(\u03b71(h)) holds, so \u00b5(\u03b71(h)) holds for t\nand \u00b5(h) at STP . As a consequence of the auxiliary result stated above, \u03b71(h) holds\nfor t and h at STP |\u00b5.\nDefinition 5.9 Let \u3008\u03c31 : dsgn(Q0) \u2192 D1, \u03c32 : dsgn(Q0) \u2192 D2\u3009 be morphisms in sDSGN\nwith pushout \u3008\u03b11 : D1 \u2192 D, \u03b12 : D2 \u2192 D\u3009. Given a pair \u3008\u00b51 : D1 \u2192 D\u20321, \u00b52 : D2 \u2192 D\u20322\u3009 of\nrefinement morphisms in rDSGN, there exists a unique refinement morphism \u00b5 : D \u2192 D\u2032\nin rDSGN satisfying \u03b11; \u00b5 = \u00b51; \u03b1\n\u2032\n1 and \u03b12; \u00b5 = \u00b52; \u03b1\n\u2032\n2 in the category SIGN, where \u3008\u03b1\u20321 :\nD\u20321 \u2192 D\u2032, \u03b1\u20322 : D\u20322 \u2192 D\u2032\u3009 is the pushout of \u3008\u03c31; \u00b51 : dsgn(Q0) \u2192 D\u20321, \u03c32; \u00b52 : dsgn(Q0) \u2192 D\u20322\u3009\nin sDSGN and (\u03c3i; \u00b5i) are the morphisms obtained by lifting the composition of the\nunderlying signature morphisms to sDSGN.\nProof. We begin by noting that there is a forgetful functor rsign from rDSGN to SIGN\nthat forgets everything from designs except their signatures. The fact that dsgn(Q0) is a\ndiscrete lift ensures that signature morphisms sign(\u03c3i); rsign(\u00b5i) give rise to morphisms\n\u03c3i; \u00b5i : dsgn(Q0) \u2192 D\u2032i in sDSGN.\nGiven that sign preserves pushouts, we have that \u3008sign(\u03b11), sign(\u03b12)\u3009 is a pushout of\n\u3008sign(\u03c31), sign(\u03c32)\u3009 in SIGN. Because \u3008sign(\u03b1\u20321), sign(\u03b1\u20322)\u3009 is a candidate for being a different\npushout, from the universal property of pushouts, it follows that there exists a unique\nmorphism \u00b5 : sign(D) \u2192 sign(D\u2032) in SIGN satisfying \u03b11; \u00b5 = \u00b51; \u03b1\u20321 and \u03b12; \u00b5 = \u00b52; \u03b1\u20322. It\nremains to prove that \u00b5 also defines a morphism \u00b5 : D \u2192 D\u2032 in sDSGN. We will only\nprove that \u00b5 satisfies the conditions of refinement morphisms that do not necessarily hold\nfor morphisms in sDSGN; the other conditions follow straightforwardly.\n\u2014 The functions \u00b5ev , \u00b5sv , \u00b5par\u2212ev,e, \u00b5par\u2212sv,s, \u00b5hr\u2212ev,e, for every e\u2208E and s\u2208S , are injective.\nThis is just a simple consequence of a general result about pushouts in the category\nof sets and functions.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nJ. L. Fiadeiro and A. Lopes 1072\n\u2014 Upper guards are reflected, that is, (\u00b5(\u03b3u(s)) \u2283 \u03b3\u2032u(\u00b5sv(s))) holds for every s\u2208 S .\nAs explained at the end of Section 4, if we use {s1, . . . , sn} to denote a quotient set\nof amalgamated services, we have \u03b3u({s1, . . . , sn}) = \u03b1i1 (\u03b3ui1 (s1)) \u2227 . . . \u2227 \u03b1in (\u03b3uin(sn)) where\n\u03b1\u2032ij is either \u03b11 or \u03b12, depending on whether sj belongs to S1 or S2. Similarly, if we\nuse {s\u20321, . . . , s\u2032m} to denote a quotient set of amalgamated services of designs D\u20321 and\nD\u20322, we have \u03b3\u2032u(s\u20321, . . . , s\u2032n) = \u03b1\u2032i1 (\u03b3\nu\ni1\n(s\u20321)) \u2227 . . . \u2227 \u03b1\u2032in (\u03b3uin (s\u2032n)) where \u03b1\u2032ij is either \u03b1\u20321 or \u03b1\u20322,\ndepending on whether s\u2032j belongs to S \u20321 or S \u20322. We prove that, for every s\u2032j in the\nquotient set corresponding to \u00b5(s) (that is, s\u2032j in D\u20321 or D\u20322 such that \u03b1ij (s\u2032j) = \u00b5sv(s)),\n\u00b5(\u03b1i1 (\u03b3\nu\ni1\n(s1))) \u2227 . . . \u2227 \u00b5(\u03b1in (\u03b3uin (sn))) \u2283 \u03b1\u2032ij (\u03b3\u2032uij (s\u2032j)) holds.\nIt is not difficult to conclude that for every s\u2032j in the quotient set corresponding to\n\u00b5(s) there exists an sj in the quotient set corresponding to s such that \u00b5ij (sj) = s\n\u2032\nj .\nBecause \u00b5ij is a refinement morphism, we have that \u00b5ij (\u03b3\nu\nij\n(sj)) \u2283 \u03b3\u2032uij (\u00b5ij (sj))) holds, that\nis, \u00b5ij (\u03b3\nu\nij\n(sj)) \u2283 \u03b3\u2032uij (s\u2032j) holds. Then, \u03b1\u2032ij (\u00b5ij (\u03b3uij (sj))) \u2283 \u03b1\u2032ij (\u03b3\u2032uij (s\u2032j)) also holds. The result\nfollows trivially from the equalities \u03b1i; \u00b5 = \u00b5i; \u03b1\n\u2032\ni.\nAcknowledgements\nThis work was partially supported through the IST-2005-16004 Integrated Project SEN-\nSORIA: Software Engineering for Service-Oriented Overlay Computers. Anto\u00b4nia Lopes\nwas partially supported by a grant from Fundac\u00b8a\u02dco para a Cie\u02c6ncia e Tecnologia during an\nextended stay at the University of Leicester. This work was developed while Jose\u00b4 Fiadeiro\nwas on study leave.\nReferences\nAlonso, G., Casati, F., Kuno, H. and Machiraju, V. (2004) Web Services, Springer-Verlag.\nBacon, J., Moody, K., Bates, J., Hayton, R., Ma, C., McNeil, A., Seidel, O. and Spiteri, M. (2000)\nGeneric support for distributed applications. IEEE Computer 33 (3) 68\u201376.\nBradbury, J. and Dingel, J. (2003) Evaluating and improving the automatic analysis of implicit\ninvocation systems. In: Proceedings of the 11th ACM SIGSOFT Symposium on Foundations of\nSoftware Engineering 2003 held jointly with 9th European Software Engineering Conference, ACM\nPress 78\u201387.\nCarzaniga, A., Rosenblum, D. and Wolf, A. (2001) Design and evaluation of a wide-area event\nnotification service. ACM Transactions on Computer Systems 19 283\u2013331.\nDingel, J., Garlan, D., Jha, S. and Notkin, D. (1998) Towards a formal treatment of implicit\ninvocation. Formal Aspects of Computing 10 193\u2013213.\nEhrig, H. and Mahr, B. (1985) Fundamentals of Algebraic Specification 1: Equations and Initial\nSemantics, EATCS Monographs on Theoretical Computer Science 6.\nEugster, P., Felber, P., Guerraoui, R. and Kermarrec, A.-M. (2003) The many faces of\npublish\/subscribe. ACM Computing Surveys 35 (2) 114\u2013131.\nFiadeiro, J. L. (2004) Categories for Software Engineering, Springer-Verlag.\nFiadeiro, J. L. and Lopes, A. (1997) Semantics of architectural connectors. In: Bidoit, M. and\nDauchet, M. (eds.) TAPSOFT: Theory and Practice of Software Development. Springer-Verlag\nLecture Notes in Computer Science 1214 505\u2013519.\nhttp:\/\/journals.cambridge.org Downloaded: 03 Sep 2013 IP address: 143.210.121.140\nAn algebraic semantics of event-based architectures 1073\nFiadeiro, J. L. and Lopes, A. (2006) A formal approach to event-based architectures. In: Baresi, L.\nand Heckel, R. (eds.) Fundamental Aspects of Software Engineering. Springer-Verlag Lecture\nNotes in Computer Science 3922 18\u201332.\nFiadeiro, J. L., Lopes, A. and Bocchi, L. (2006) A Formal Approach to Service Component\nArchitecture. In: Bravetti, M., Nez, M. and Zavattaro, G. (eds.) Web Services and Formal\nMethods, Third International Workshop. Springer-Verlag Lecture Notes in Computer Science\n4184 193\u2013213.\nFiadeiro, J. L., Lopes, A. and Bocchi, L. (2007) Modules for service-component architectures. In:\nFiadeiro, J. and Schobbens, P-Y. (eds.) Current Trends in Algebraic Development Techniques.\nSpringer-Verlag Lecture Notes in Computer Science 4409 37\u201355.\nFiadeiro, J. L., Lopes, A. and Wermelinger, M. (2003) A mathematical semantics for architectural\nconnectors. In: Backhouse, R. and Gibbons, J. (eds.) Generic Programming. Springer-Verlag\nLecture Notes in Computer Science 2793 190\u2013234.\nGarlan, D., Khersonsky, S. and Kim, J. (2003) Model checking publish-subscribe systems. In: Ball, T.\nand Rajamani, S. (eds.) Model Checking Software. Springer-Verlag Lecture Notes in Computer\nScience 2648 166\u2013180.\nGarlan, D. and Notkin, D. (1991) Formalizing design spaces: Implicit invocation mechanisms. In:\nPrehn, S. and Toetenel, W. J. (eds.) VDM\u201991: Formal Software Development Methods. Springer-\nVerlag Lecture Notes in Computer Science 551 31\u201344.\nGoguen, J. (1973) Categorical foundations for general systems theory. In: Pichler, F. and Trappl, R.\n(eds.) Advances in Cybernetics and Systems Research, Transcripta Books 121\u2013130.\nKatz, S. (1993) A superimposition control construct for distributed systems. ACM TOPLAS 15 (2)\n337\u201335.\nLopes, A. and Fiadeiro, J. L. (2004) Superposition: composition versus refinement of non-\ndeterministic action-based systems. Formal Aspects of Computing 16 (1) 5\u201318.\nLopes, A. and Fiadeiro, J. L. (2005) Algebraic semantics of design abstractions for context-awareness.\nIn: Fiadeiro, J. L., Mosses, P. and Orejas, F. (eds.) Algebraic Development Techniques. Springer-\nVerlag Lecture Notes in Computer Science 3423 79\u201393.\nLopes, A. and Fiadeiro, J. L. (2006) Adding mobility to software architectures. Science of Computer\nProgramming 61 (2) 114\u2013135.\nMeier, R. and Cahill, V. (2002) Taxonomy of distributed event-based programming systems. In:\nProceedings of the International Workshop on Distributed Event-Based Systems, IEEE Computer\nSociety 585\u2013588.\nMisra, J. and Cook, W. (2006) Computation orchestration: A basis for wide-area computing. Journal\nof Software and Systems Modelling 6 (1) 83\u2013110.\nSullivan, K. and Notkin, D. (1992) Reconciling environment integration and software evolution.\nACM TOSEM 1 (3) 229\u2013268.\n"}