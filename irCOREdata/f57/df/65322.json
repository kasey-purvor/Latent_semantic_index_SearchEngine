{"doi":"10.1109\/ICECCS.2007.17","coreId":"65322","oai":"oai:dro.dur.ac.uk.OAI2:6223","identifiers":["oai:dro.dur.ac.uk.OAI2:6223","10.1109\/ICECCS.2007.17"],"title":"Automated verification of shape, size and bag properties.","authors":["Chin, W.-N.","David, C.","Nguyen, H.H.","Qin, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-07-01","abstract":"In recent years, separation logic has emerged as a contender for formal reasoning of heap-manipulating imperative programs. Recent works have focused on specialised provers that are mostly based on fixed sets of predicates. To improve expressivity, we have proposed a prover that can automatically handle user-defined predicates. These shape predicates allow programmers to describe a wide range of data structures with their associated size properties. In the current work, we shall enhance this prover by providing support for a new type of constraints, namely bag (multi-set) constraints. With this extension, we can capture the reachable nodes (or values) inside a heap predicate as a bag constraint. Consequently, we are able to prove properties about the actual values stored inside a data structure","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65322.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6223\/1\/6223.pdf","pdfHashValue":"4cb3c9d3b22546f4d9f28abcf866c80296583ff9","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6223<\/identifier><datestamp>\n      2010-11-08T11:05:09Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Automated verification of shape, size and bag properties.<\/dc:title><dc:creator>\n        Chin, W.-N.<\/dc:creator><dc:creator>\n        David, C.<\/dc:creator><dc:creator>\n        Nguyen, H.H.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:description>\n        In recent years, separation logic has emerged as a contender for formal reasoning of heap-manipulating imperative programs. Recent works have focused on specialised provers that are mostly based on fixed sets of predicates. To improve expressivity, we have proposed a prover that can automatically handle user-defined predicates. These shape predicates allow programmers to describe a wide range of data structures with their associated size properties. In the current work, we shall enhance this prover by providing support for a new type of constraints, namely bag (multi-set) constraints. With this extension, we can capture the reachable nodes (or values) inside a heap predicate as a bag constraint. Consequently, we are able to prove properties about the actual values stored inside a data structure. <\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        (2007). 12th IEEE International Conference on Engineering of Complex Computer Systems, 11-14 Jul 2007, Auckland, New Zealand ; proceedings. Los Alamitos, CA: IEEE, pp. 307-320<\/dc:source><dc:date>\n        2007-07-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6223<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6223\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/ICECCS.2007.17<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6223\/1\/6223.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2007 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2007,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nChin, W.-N. and David, C. and Nguyen, H.H. and Qin, S. (2007) \u2019Automated verification of shape, size and\nbag properties.\u2019, in 12th IEEE International Conference on Engineering of Complex Computer Systems, 11-14\nJul 2007, Auckland, New Zealand ; proceedings. Los Alamitos, CA: IEEE, pp. 307-320.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/ICECCS.2007.17\nPublisher\u2019s copyright statement:\n2007 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nAutomated Verification of Shape, Size and Bag Properties\nWei-Ngan Chin1,2 Cristina David1 Huu Hai Nguyen2 Shengchao Qin3\n1 Department of Computer Science, National University of Singapore\n2 Computer Science Programme, Singapore-MIT Alliance\n3 Department of Computer Science, Durham University\n{chinwn,davidcri,nguyenh2}@comp.nus.edu.sg shengchao.qin@durham.ac.uk\nAbstract\nIn recent years, separation logic has emerged as a con-\ntender for formal reasoning of heap-manipulating impera-\ntive programs. Recent works have focused on specialised\nprovers that are mostly based on fixed sets of predicates. To\nimprove expressivity, we have proposed a prover that can\nautomatically handle user-defined predicates. These shape\npredicates allow programmers to describe a wide range of\ndata structures with their associated size properties. In the\ncurrent work, we shall enhance this prover by providing\nsupport for a new type of constraints, namely bag (multi-\nset) constraints. With this extension, we can capture the\nreachable nodes (or values) inside a heap predicate as a\nbag constraint. Consequently, we are able to prove proper-\nties about the actual values stored inside a data structure.\n1 Introduction\nSeparation logic supports reasoning about shared muta-\nble data structures. Therefore, specification of memory op-\nerations with advanced pointer usage is enabled. While the\nfoundations of separation logic have been laid in seminal\npapers by Reynolds [23] and Isthiaq and O\u2019Hearn [11], new\nautomated reasoning tools based on separation logic, such\nas [2, 9], are beginning to appear. Several recent works,\nsuch as [1, 8], have developed specialised solvers that work\nfor a fixed set of predicates (e.g. lseg). The level of expres-\nsivity for an automated verification system was raised by\nour previous work [20] where we support automated rea-\nsoning of user-defined predicates. The main goal of our\ncurrent paper is to enhance the prover proposed in [20] by\nproviding support for bag constraints. We make the follow-\ning technical contributions towards this overall goal :\n\u2022 We provide a shape predicate specification mechanism\nthat can capture a wide range of data structures to-\ngether with size and bag properties, such as various\nheight-balanced trees, priority heap, sorted list, etc.\nMoreover, we provide a mechanism to soundly ap-\nproximate each shape predicate by a heap-independent\ninvariant which plays an important role in entailment\nchecking (Secs 2 and 4.1).\n\u2022 We improve the expressiveness of our automatic ver-\nification tool by allowing it to capture both the size\nproperties and the bag of values from each shape\npredicate. The numeric properties capture sophisti-\ncated data structure invariants, such as orderedness (for\nsorted list\/trees) and also balanced height properties\n(for AVL-trees). The bag constraints enable express-\ning reachability properties, such as the preservation of\nthe elements inside a list after sorting.\n\u2022 We design a new procedure to check entailment of\nseparation heap constraints. This procedure uses un-\nfold\/fold reasoning to deal with shape definitions.\nWhile the unfold\/fold mechanism is not new, we have\nidentified sufficient conditions for soundness and ter-\nmination of the procedure in the presence of recursive\nuser-defined shape predicates. (Secs 3.1, 4 and 5)\n\u2022 We have implemented a prototype verification system\nwith the above features and have also proven both its\nsoundness and termination (Secs 6 and 7).\n2 User-Definable Shape Predicates\nSeparation logic [23, 11] extends Hoare logic to support\nreasoning about shared mutable data structures. It adds two\nmore connectives to classical logic : separating conjunction\n\u2217, and separating implication \u2212\u2212\u2217. h1 \u2217 h2 asserts that two\nheaps described by h1 and h2 are domain-disjoint. h1\u2212\u2212\u2217h2\nasserts that if the current heap is extended with a disjoint\nheap described by h1, then h2 holds in the extended heap.\nIn this paper we use only separating conjunction.\nWe propose an intuitive mechanism based on induc-\ntive predicates (or relations) to allow user specification of\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nshapely data structures with size and reachability proper-\nties. Our shape specification is based on separation logic\nwith support for disjunctive heap states. Furthermore, each\nshape predicate may have pointer, integer or bag parame-\nters to capture relevant properties of data structures. We use\nthe following data node declarations for the examples in the\npaper. They are recursive data declarations with different\nnumber of fields.\ndata node { int val; node next }\ndata node2 { int val; node2 prev; node2 next }\ndata node3 { int val; node3 left; node3 right;\nnode3 parent }\nWe use p::c\u3008v\u2217\u3009 to denote two things in our system.\nWhen c is a data name, p::c\u3008v\u2217\u3009 stands for singleton heap\np\u0005\u2192[(f:v)\u2217] where f\u2217 are fields of data declaration c. When\nc is a predicate name, p::c\u3008v\u2217\u3009 stands for the formula\nc(p, v\u2217). The reason we distinguish the first parameter from\nthe rest is that each predicate has an implicit parameter\nself as the first one. Effectively, self is a \u201croot\u201d pointer to\nthe specified data structure that guides data traversal and fa-\ncilitates the definition of well-founded predicates (Sec 3.1).\nAs an example, a singly linked list with length n is described\nby :\nll\u3008n\u3009\u2261(self=null\u2227n=0)\u2228(\u2203i, m, q \u00b7 self::node\u3008i, q\u3009\n\u2217q::ll\u3008m\u3009\u2227n=m+1) inv n\u22650\nNote that the parameter n captures a derived value. The\nabove definition asserts that an ll list can be empty (the\nbase case self=null) or consists of a head data node\n(specified by self::node\u3008i, q\u3009) and a separate tail data\nstructure which is also an ll list (q::ll\u3008m\u3009). The \u2217 connec-\ntor ensures that the head node and the tail reside in disjoint\nheaps. We also specify a default invariant n\u22650 that holds\nfor all ll lists. Our predicate uses existential quantifiers for\nlocal values and pointers, such as i, m, q.\nA more complex shape, doubly linked-list with length n,\nis described by :\ndll\u3008p, n\u3009\u2261(self=null\u2227n=0)\u2228(self::node2\u3008 , p, q\u3009\n\u2217q::dll\u3008self, n\u22121\u3009) inv n\u22650\nThe dll shape predicate has a parameter p that represents\nthe prev field of the first node of the doubly linked-list. It\ncaptures a chain of nodes that are to be traversed via the\nnext field starting from the current node self. The nodes\naccessible via the prev field of the self node are not part\nof the dll list. This example also highlights some shortcuts\nwe may use to make shape specification shorter. We use un-\nderscore to denote an anonymous variable. Non-parameter\nvariables in the RHS of the shape definition, such as q, are\nconsidered existentially quantified. Furthermore, terms may\nbe directly written as arguments of shape predicate or data\nnode.\nUser-definable shape predicates provide us with more\nflexibility than some recent automated reasoning systems\n[1, 3] that are designed to work with only a small set of fixed\npredicates. Furthermore, our shape predicates can describe\nnot only the shape of data structures, but also their size and\nbag properties. This capability enables many applications,\nespecially to support data structures with sophisticated in-\nvariants. For example, we may define a non-empty sorted\nlist as below. The predicate also tracks the length, the mini-\nmum and maximum elements of the list.\nsortl\u3008n, min, max\u3009 \u2261\n(self::node\u3008min, null\u3009 \u2227 min=max \u2227 n=1)\n\u2228 (self::node\u3008min, q\u3009 \u2217 q::sortl\u3008n\u22121, k, max\u3009 \u2227 min\u2264k)\ninv min\u2264max \u2227 n\u22651\nThe constraint min\u2264k guarantees that sortedness property\nis adhered between any two adjacent nodes in the list. We\nmay now specify (and then verify) the following insertion\nsort algorithm :\nnode insert(node x, node vn) where\nx::sortl\u3008n, mi, ma\u3009 \u2217 vn::node\u3008v, \u3009 \u2217\u2192\nres::sortl\u3008n+1, min(v, mi), max(v, ma)\u3009\n{ if (vn.val\u2264x.val) then { vn.next:=x; vn }\nelse if (x.next=null) then\n{ x.next:=vn; vn.next:=null; x }\nelse { x.next:=insert(x.next, vn); x }}\nnode insertion sort(node y) where\ny::ll\u3008n\u3009 \u2227 n>0 \u2217\u2192 res::sortl\u3008n, , \u3009\n{ if (y.next=null) then y\nelse { y.next:=insertion sort(y.next);\ninsert(y.next, y) }}\nWe use the notation \u03a6pr \u2217\u2192\u03a6po to capture a precondi-\ntion \u03a6pr and a postcondition \u03a6po of a method. Note that we\nuse an expression-oriented language where the last subex-\npression (e.g. e2 from e1;e2) denotes the result of an ex-\npression. A special identifier res is used in the postcon-\ndition to denote the result of a method. The postcondition\nof insertion sort shows that the output list is sorted and\nhas the same number of nodes as the input list.\n2.1 Bag of Values\/Addresses\nThe earlier specification of sorting captures neither the\nin-situ reuse of memory cells nor the fact that all the ele-\nments of the list are preserved by sorting. The reason is\nthat the shape predicate captures only pointers and num-\nbers but does not capture the set of reachable nodes in a\nheap predicate. A possible solution to this problem is to\nextend our specification mechanism to capture either a set\nor a bag of values. For generality and simplicity, we pro-\npose to use only the bag (or multi-set) notation that permits\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nduplicates, though set notation could also be supported. In\nthe rest of the paper, we will use the following bag opera-\ntors: bag union unionsq, bag intersection \u000e, bag subsumption \u0002,\nand bag cardinality |B|. The shape specifications from the\nprevious section are revised as follows:\nll2\u3008n, B\u3009 \u2261 (self=null\u2227n=0\u2227B={})\n\u2228(self::node\u3008 , q\u3009\u2217q::ll2\u3008n\u22121, B1\u3009\u2227B=B1unionsq{self})\ninv n\u22650\u2227|B|=n\nsortl2\u3008B, mi, ma\u3009 \u2261\n(self::node\u3008mi, null\u3009\u2227mi=ma\u2227B={self})\n\u2228 (self::node\u3008mi, q\u3009\u2217q::sortl2\u3008B1, k, ma\u3009\n\u2227B=B1unionsq{self} \u2227 mi\u2264k)\ninv mi\u2264ma \u2227 B\u000f={}\nEach predicate of the form ll2\u3008n, B\u3009 or\nsortl2\u3008B, mi, ma\u3009 now captures a bag of addresses\nB for all the data nodes of its data structure (or heap\npredicate). With this extension, we can provide a more\ncomprehensive specification for in-situ sorting, as follows :\nnode insert(node x, node vn) where\nx::sortl2\u3008B, mi, ma\u3009 \u2217 vn::node\u3008v, \u3009 \u2217\u2192\nres::sortl2\u3008Bunionsq{vn}, min(v, mi), max(v, ma)\u3009\n{\u00b7 \u00b7 \u00b7 }\nnode insertion sort(node y) where\ny::ll2\u3008n, B\u3009 \u2227 B\u000f={} \u2217\u2192 res::sortl2\u3008B, , \u3009\n{\u00b7 \u00b7 \u00b7 }\nWe stress that the bag mechanism used to capture the reach-\nable nodes in a shape predicate is quite general. Instead of\nheap addresses, we may also revise our views to capture a\nbag of reachable values, as well as the length. For example:\nll3\u3008n, B\u3009 \u2261 (self=null\u2227n=0\u2227B={})\u2228\n(self::node\u3008a, q\u3009\u2217q::ll3\u3008n\u22121, B1\u3009\u2227B=B1unionsq{a})\ninv n\u22650 \u2227 |B|=n\nCapturing a bag of values allows us to reason about the\ncollection of values in a data structure, and permits rele-\nvant properties to be automatically verified. Both universal\nand existential properties over bags may be expressed and\nproven, when implemented with an appropriate constraint\nsolver, as highlighted below :\ndata pair{node v1; node v2}\npair partition(node x, int p) where\nx::ll3\u3008n, A\u3009 \u2217\u2192 res::pair\u3008r1, r2\u3009 \u2217 r1::ll3\u3008n1, B1\u3009\u2217\nr2::ll3\u3008n2, B2\u3009\u2227A=B1unionsqB2 \u2227 n=n1 + n2 \u2227 (\u2200a\u2208B1\u00b7a\u2264p)\n\u2227(\u2200a\u2208B2\u00b7a>p)\n{ if (x=null) then new pair(null, null)\nelse { pair t; t:=partition(x.next, p);\nif (x.val\u2264p) then { x.next:=t.v1; t.v1:=x }\nelse { x.next:=t.v2; t.v2:=x };\nt } }\nbool allPos(node x) where\nx::ll3\u3008n, B\u3009 \u2217\u2192 x::ll3\u3008n, B\u3009 \u2227 ((\u2200a\u2208B\u00b7a\u22650)\u2227res\n\u2228 (\u2203a\u2208B\u00b7a<0)\u2227\u00acres)\n{ if (x=null) then true\nelse if (x.val<0) then false\nelse allPos(x.next) }\nThe first example returns a pair of lists that have been\npartitioned from a single input list according to an integer\npivot. This partition function and its pre\/post specification\ncan be used to prove the total correctness of quicksort al-\ngorithm. The second example uses existentially and univer-\nsally quantified formulae to determine if at least one nega-\ntive number is present in an input list, or not.\n3 Automated Verification\nIn this section, we first introduce a core object-based im-\nperative language and then propose a set of forward verifi-\ncation rules to systematically check that preconditions are\nsatisfied at call sites, and that the declared postcondition is\nsuccessfully verified (assuming the precondition) for each\nmethod definition.\n3.1 Language\nWe provide a simple imperative language in Figure 1.\nOur language is strongly typed and we assume programs\nand constraints are well-typed. The language supports data\ntype declaration via datat, and shape predicate definition\nvia spred. For each shape definition spred, we also de-\nclare a heap-independent invariant \u03c00 over the parameters\n{self, v\u2217} that holds for each instance of the predicate.\nEach method meth and while loop is declared with pre-\nand post-conditions of the form \u03a6pr \u2217\u2192\u03a6po. For simplicity,\nwe assume that variable names declared in each method are\nall distinct and that parameters are passed by-value. Primed\nnotation is used to denote the latest value of variables and\nmay appear in the postcondition of loops. For example, a\nsimple loop with pre\/post conditions is shown below:\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nP ::= tdecl\u2217 meth\u2217 tdecl ::= datat | spred\ndatat ::= data c { field\u2217 } field ::= t v t ::= c | \u03c4\n\u03c4 ::= int | bool | float | void\nspred ::= c\u3008v\u2217\u3009 \u2261 \u03a6 inv \u03c00\nmeth ::= t mn ((t v)\u2217) where\n\u2227\n(\u03a6pr \u2217\u2192\u03a6po)\u2217 {e}\ne ::= null | k\u03c4 | v | v.f | v:=e | v1.f :=v2 | new c(v\u2217)\n| e1; e2 | t v; e | mn(v\u2217) | if v then e1 else e2\n| while v where \u2227 (\u03a6pr \u2217\u2192\u03a6po)\u2217 do e\n\u03a6 ::=\n\u2228\n(\u2203v\u2217\u00b7\u03ba\u2227\u03c0)\u2217 \u03c0 ::= \u03b3\u2227\u03c6\n\u03b3 ::= v1=v2 | v=null | v1 \u000f=v2 | v \u000f=null | \u03b31\u2227\u03b32\n\u03ba ::= emp | v::c\u3008v\u2217\u3009 | \u03ba1 \u2217 \u03ba2\n\u0394 ::= \u03a6 | \u03941\u2228\u03942 | \u0394\u2227\u03c0 | \u03941\u2217\u03942 | \u2203v\u00b7\u0394\n\u03c6 ::= \u03d5 | b | a | \u03c61\u2227\u03c62 | \u03c61\u2228\u03c62 | \u00ac\u03c6 | \u2203v \u00b7 \u03c6 | \u2200v \u00b7 \u03c6\nb ::=true | false | v | b1=b2\na ::=s1=s2 | s1\u2264s2\ns ::= kint | v | kint\u00d7s | s1+s2 | \u2212s | max(s1,s2)\n| min(s1,s2) | |B|\n\u03d5 ::= v\u2208B | B1=B2 | B1\u0002B2 | \u2200v\u2208B\u00b7\u03c6 | \u2203v\u2208B\u00b7\u03c6\nB ::= B1unionsqB2 | B1\u000eB2 | B1\u2212B2 | {} | {v}\nFigure 1. A Core Imperative Language\nwhile x<0 where true \u2217\u2192 (x>0\u2227x\u2032=x) \u2228 (x\u22640\u2227x\u2032=0)\ndo { x:=x+1 }\nHere x and x\u2032 denote the values of variable x at the entry\nand exit of the loop, respectively.\nThe separation constraints we use are in a disjunctive\nnormal form \u03a6. Each disjunct consists of a \u2217-separated\nheap constraint \u03ba, referred to as heap part, and a heap-\nindependent formula \u03c0, referred to as pure part. The pure\npart does not contain any heap nodes and is presently re-\nstricted to pointer equality\/disequality \u03b3, Presburger arith-\nmetic \u03c6 and bag constraint \u03d5. Furthermore, \u0394 denotes a\ncomposite formula that could always be normalised into the\n\u03a6 form (see Figure 3). The semantic model for the separa-\ntion constraints is left in the technical report [19].\nSeparation constraints are used in pre\/post conditions\nand shape definitions. In order to handle them correctly\nwithout running into unmatched residual heap nodes, we re-\nquire each separation constraint to be well-formed, as given\nby the following definitions:\nDefinition 3.1 (Accessible) A variable is said to be acces-\nsible w.r.t. a shape predicate if it is a parameter or it is a\nspecial variable, either self or res.\nDefinition 3.2 (Reachable) Given a heap constraint\n\u03ba = p::c\u3008v\u2217\u3009 \u2217 \u03ba1, node p::c\u3008v\u2217\u3009 is reachable from a\nvariable q if and only if the following relation holds:\nreach(\u03ba, q, p::c\u3008v\u2217\u3009) =df (p=q)\n\u2228(\u03ba1=q::cq\u3008.., r, ..\u3009\u2217\u03ba2 \u2227 reach(\u03ba2, r, p::c\u3008v\u2217\u3009))\nDefinition 3.3 (Well-Formed Constraint) A separation\nconstraint \u03a6 is well-formed if (i) every data node and shape\npredicate are reachable from their accessible variables, (ii)\nit is in a disjunctive normal form\n\u2228\n(\u2203v\u2217\u00b7\u03ba\u2227\u03b3\u2227\u03c6)\u2217 where \u03ba\nis for heap nodes, \u03b3 is for pointer constraint, and \u03c6 is for\narithmetic formula.\nThe primary significance of the well-formed condition is\nthat all heap nodes of a heap constraint are reachable from\naccessible variables. This allows the entailment checking\nprocedure to correctly match nodes from the consequent\nwith nodes from the antecedent of an entailment relation.\nArbitrary recursive shape relation can lead to non-\ntermination in unfold\/fold reasoning. To avoid that prob-\nlem, we propose to use only well-founded shape predicates\nin our framework.\nDefinition 3.4 (Well-Founded Predicate) A shape predi-\ncate is said to be well-founded if it satisfies four conditions,\nnamely: (i) it is a well-formed constraint, (ii) the parameter\nselfmay only be bound to a data node and not a predicate,\n(iii) only self is allowed to be bound to a data node and\n(iv) every predicate is reachable from self.\nNote that the definitions above are syntactic and can eas-\nily be enforced. An example of well-founded shape pred-\nicates is avl - binary tree with near balanced heights, as\nfollows :\navl\u3008n, h\u3009 \u2261 (self=null \u2227 n=0 \u2227 h=0)\n\u2228 (self::node2\u3008 , p, q\u3009 \u2217 p::avl\u3008n1, h1\u3009\u2217q::avl\u3008n2, h2\u3009\n\u2227n=1+n1+n2\u2227 h=1+max(h1, h2) \u2227 \u22121\u2264h1\u2212h2\u22641)\ninv n, h\u22650\nIn contrast, the following three shape definitions are not\nwell-founded.\nfoo\u3008n\u3009 \u2261 self::foo\u3008m\u3009 \u2227 n=m+1\ngoo\u3008\u3009 \u2261 self::node\u3008 , \u3009 \u2217 q::goo\u3008\u3009\ntoo\u3008\u3009 \u2261 self::node\u3008 , q\u3009 \u2217 q::node\u3008 , \u3009\nFor foo, the self identifier is bound to a shape predicate.\nFor goo, the heap node pointed by q is not reachable from\nvariable self. For too, an extra data node is bound to a\nnon-self variable. The first example may cause infinite\nunfolding, while the second example captures an unreach-\nable (junk) heap that cannot be located by our entailment\nprocedure. The last example is just a syntactic restriction to\nfacilitate termination of proof reasoning, and can be easily\novercome by introducing intermediate predicates.\n3.2 Forward Verification\nWe use P to denote the program being checked. With\npre\/post conditions declared for each method in P , we can\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\n[FV\u2212PRED]\nXPure0(\u03a6) =\u21d2 [0\/null]\u03c00\n\u0013 c\u3008v\u2217\u3009 \u2261 \u03a6 inv \u03c00\n[FV\u2212VAR]\n\u03941=(\u0394\u2227res=v\u2032)\n\u0013 {\u0394} v {\u03941}\n[FV\u2212NEW]\n\u03941=(\u0394 \u2217 res::c\u3008v\u20321, .., v\u2032n\u3009)\n\u0013 {\u0394} new c(v1, .., vn) {\u03941}\n[FV\u2212ASSIGN]\n\u0013 {\u0394} e {\u03941}\n\u03942=\u2203res\u00b7(\u03941\u2227{v}v\u2032=res)\n\u0013 {\u0394} v:=e {\u03942}\n[FV\u2212CALL]\nt mn((ti vi)ni=1) where \u03a6pr \u2217\u2192\u03a6po {..} \u2208 P\n\u03c1=[v\u2032i\/vi] \u0394\u0013\u03c1\u03a6pr \u2217\u03941 \u03942=(\u03941 \u2217 \u03a6po)\n\u0013 {\u0394}mn(v1..vn) {\u03942}\n[FV\u2212METH]\nV ={v1..vn} W=prime(V ) \u0394=\u03a6pr\u2227nochange(V )\n\u0013 {\u0394} e {\u03941} (\u2203W\u00b7\u03941)\u0013\u03a6po \u2217\u03942\n\u0013 t0 mn(t1 v1, .., tn vn) where \u03a6pr \u2217\u2192 \u03a6po {e}\nFigure 2. Some Forward Verification Rules\napply modular verification to a method\u2019s body using Hoare-\nstyle triples \u0013 {\u03941} e {\u03942}. These are forward verifica-\ntion rules that expect \u03941 to be given before computing \u03942.\nSome rules are given in Fig 2 while others are left in the\ntechnical report [19]. They are used to track heap states\nas accurately as possible with path-, flow-, and context-\nsensitivity. For each call site, [FV\u2212CALL] ensures that the\ncallee\u2019s precondition is satisfied. For each method defini-\ntion, [FV\u2212METH] checks that its postcondition holds for\nthe method body assuming its precondition. A method post-\ncondition may capture only part of the heap at the end of\nthe method, leaving the residue heap nodes in \u03942. For each\nshape definition, [FV\u2212PRED] checks that its given invari-\nant is a consequence of the well-founded heap formula. The\nsoundness of the forward verification is also left in the tech-\nnical report.\nWe now explain the operators\/functions used in our ver-\nification rules. The operator \u2227{v} used in the assignment\nrule is an instance of composition with update operators.\nGiven a state \u03941, a state change \u03942, and a set of variables\nto be updated X={x1, . . . , xn}, the composition operator\n\u2295X is defined as:\n\u03941 \u2295X \u03942 =df \u2203 r1..rn \u00b7 \u03c11 \u03941 \u2295 \u03c12 \u03942\nwhere r1, . . . , rn are fresh variables;\n\u03c11 = [ri\/x\u2032i]\nn\ni=1 ; \u03c12 = [ri\/xi]\nn\ni=1\nNote that \u03c11 and \u03c12 are substitutions that link each latest\nvalue of x\u2032i in \u03941 with the corresponding initial value xi in\n\u03942 via a fresh variable ri. The binary operator\u2295 is either \u2227\nor \u2217. The function nochange(V ) returns a formula asserting\nthat the unprimed and primed versions of each variable in\nV are equal; prime(V ) returns the primed form of all vari-\nables in V . [e\u2217\/v\u2217] represents substitutions of v\u2217 by e\u2217.\nA special case is [0\/null], which denotes replacement of\nnull by 0. Normalization rules for separation constraints\nare given in Figure 3. XPure is described in the next section.\n3.3 Forward Verification Example\nWe present the detailed verification of the first branch\nof the insert function from Sec 2. Note that pro-\ngram variables appear primed in formulae whereas\nlogical variables unprimed. The proof is straightfor-\nward, except for the last step where a disjunctive heap\nstate is folded to form a shape predicate. The proce-\ndure to perform the folding step is presented in Sec 4.\n{x\u2032::sortl\u3008n, mi, ma\u3009 \u2217 vn\u2032::node\u3008v, \u3009} \/\/ precondition\nif (vn.val \u2264 x.val) then {\n{(x\u2032::node\u3008mi, null\u3009 \u2217 vn\u2032::node\u3008v, \u3009 \u2227 mi=ma \u2227 n=1\n\u2227 v\u2264mi) \u2228 (\u2203q, k \u00b7 x\u2032::node\u3008mi, q\u3009\u2217q::sortl\u3008n\u22121, k, ma\u3009\n\u2217vn\u2032::node\u3008v, \u3009 \u2227 mi\u2264k \u2227 mi\u2264ma \u2227 n\u22652 \u2227 v\u2264mi)}\n\/\/ unfold and conditional\nvn.next := x;\n{(x\u2032::node\u3008mi, null\u3009 \u2217 vn\u2032::node\u3008v, x\u2032\u3009 \u2227 mi=ma \u2227 n=1\n\u2227 v\u2264mi) \u2228 (\u2203q, k \u00b7 x\u2032::node\u3008mi, q\u3009 \u2217 q::sortl\u3008n\u22121, k, ma\u3009\n\u2217vn\u2032::node\u3008v, x\u2032\u3009 \u2227 mi\u2264k \u2227 mi\u2264ma \u2227 n\u22652 \u2227 v\u2264mi)}\n\/\/ field update\nvn\n{(x\u2032::node\u3008mi, null\u3009 \u2217 vn\u2032::node\u3008v, x\u2032\u3009 \u2227 mi=ma \u2227 n=1\n\u2227 v\u2264mi \u2227 res=vn\u2032) \u2228 (\u2203q, k \u00b7 x\u2032::node\u3008mi, q\u3009\n\u2217 q::sortl\u3008n\u22121, k, ma\u3009 \u2217 vn\u2032::node\u3008v, x\u2032\u3009 \u2227 mi\u2264k \u2227 mi\u2264ma\n\u2227n\u22652 \u2227 v\u2264mi \u2227 res=vn\u2032)} \/\/ returned value\n}\n{res::sortl\u3008n+1, min(v, mi), max(v, ma)\u3009}\n\/\/ fold to postcondition\n4 Entailment\nWe present in this section the entailment checking rules\nfor the class of constraints used by our verification system.\n4.1 Separation Constraint Approximation\nEntailment between separation formulae (detailed in sec-\ntion 4.2) is reduced to entailment between pure formulae by\nsuccessively removing heap nodes from the consequent un-\ntil only a pure formula remains. When the consequent is\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\n(\u03941 \u2228\u03942) \u2227 \u03c0 \u0003 (\u03941 \u2227 \u03c0) \u2228 (\u03942 \u2227 \u03c0)\n(\u03941 \u2228\u03942) \u2217\u0394 \u0003 (\u03941 \u2217\u0394) \u2228 (\u03942 \u2217\u0394)\n(\u03ba1\u2227\u03c01) \u2217 (\u03ba2\u2227\u03c02) \u0003 (\u03ba1\u2217\u03ba2)\u2227(\u03c01\u2227\u03c02)\n(\u03ba1\u2227\u03c01) \u2227 (\u03c02) \u0003 \u03ba1\u2227(\u03c01\u2227\u03c02)\n(\u03b31\u2227\u03c61) \u2227 (\u03b32\u2227\u03c62) \u0003 (\u03b31\u2227\u03b32) \u2227 (\u03c61\u2227\u03c62)\n(\u2203x \u00b7\u0394) \u2227 \u03c0 \u0003 \u2203y \u00b7 ([y\/x]\u0394 \u2227 \u03c0)\n(\u2203x \u00b7\u03941) \u2217\u03942 \u0003 \u2203y \u00b7 ([y\/x]\u03941 \u2217\u03942)\nFigure 3. Normalization Rules\npure, the heap formula in the antecedent is soundly approxi-\nmated by function XPuren. The function XPuren(\u03a6), whose\ndefinition is given in Fig 4, returns a sound approxima-\ntion of \u03a6 as formula ex i\u2217\u00b7\u2228(\u2203v\u2217\u00b7\u03c0)\u2217 where i\u2217 are (non-\nnull) distinct symbolic addresses of heap nodes of \u03a6. The\nfunction IsData(c) returns true if c is a data node, while\nIsPred(c) returns true if c is a shape predicate.\nWe illustrate how these functions work by computing\nXPure1(p::ll\u3008n\u3009). Let \u03a6 be the body of the ll predicate.\nInv0(p::ll\u3008n\u3009) =df n \u2265 0\nXPure0(\u03a6) =df ex j \u00b7 (self = 0 \u2227 n = 0)\n\u2228(self = j \u2227 j > 0 \u2227 n\u2212 1 \u2265 0)\nInv1(p::ll\u3008n\u3009) =df [p\/self]XPure0(\u03a6)\nXPure1(p::ll\u3008n\u3009) =df ex i \u00b7 [i\/j]Inv1(p::ll\u3008n\u3009)\n\u0003 \u2203i \u00b7 (p = 0 \u2227 n = 0) \u2228 (p = i \u2227 i > 0 \u2227 n > 0)\n= (p = 0 \u2227 n = 0) \u2228 (p > 0 \u2227 n > 0)\nThe following normalization rules are also used :\n(ex I \u00b7\u03c61)\u2228(ex J \u00b7\u03c62) \u0003 ex I\u222aJ \u00b7 (\u03c61 \u2228 \u03c62)\n\u2203 v \u00b7 (ex I \u00b7\u03c6) \u0003 ex I \u00b7 (\u2203 v \u00b7\u03c6)\n(ex I \u00b7\u03c61)\u2227(ex J \u00b7\u03c62) \u0003 ex I\u222aJ \u00b7\u03c61\u2227\u03c62\u2227\n\u2227\ni\u2208I,j\u2208J i\u000f=j\nThe ex i\u2217 construct is converted to \u2203 i\u2217 when the formula\nis used as a pure formula. The soundness of XPuren is for-\nmalized by :\nLemma 4.1 (Sound Invariant) Given a shape predicate\nc\u3008v\u2217\u3009\u2261\u03a6 inv \u03c00, we have \u03a6 |= Invn(self::c\u3008v\u2217\u3009) if\nXPure0(\u03a6) =\u21d2 [0\/null]\u03c00. \u03c00 is said to be sound.\nProof: By structural induction on \u03a6.\nLemma 4.2 (Sound Abstraction) Given a separation\nconstraint \u03a6 where the invariants of the predicates appear-\ning in \u03a6 are sound, we have \u03a6 |= XPuren(\u03a6).\nProof : By structural induction on \u03a6.\nLemma 4.1 ensures that a supplied invariant that passes\n[FV\u2212PRED] is a semantic consequence of the predicate.\nLemma 4.2 asserts that it is safe to approximate an an-\ntecedent by using XPure if all the predicate invariants are\nsound. They also allow the possibility of obtaining a more\nprecise invariant by applying XPure one or more times. For\nexample, when given a pure invariant n\u22650 for the predicate\nll\u3008n\u3009, a single application returns ex i\u00b7(self=0\u2227n=0 \u2228\nself=i\u2227i>0\u2227n>0) which is sound and more precise, as\nit relates the nullness of the self pointer with the size n of\nthe list.\n(c\u3008v\u2217\u3009 \u2261 \u03a6 inv \u03c00) \u2208 P\nInv0(p::c\u3008v\u2217\u3009) = [p\/self, 0\/null]\u03c00\n(c\u3008v\u2217\u3009 \u2261 \u03a6 inv \u03c00) \u2208 P\nInvn(p::c\u3008v\u2217\u3009) = [p\/self, 0\/null]XPuren\u22121(\u03a6)\nXPuren(\n\u2228\n(\u2203v\u2217\u00b7\u03ba\u2227\u03c0)\u2217) =df\n\u2228\n(\u2203v\u2217\u00b7XPuren(\u03ba)\u2227[0\/null]\u03c0)\u2217\nXPuren(emp) =df true\nIsData(c) fresh i\nXPuren(p::c\u3008v\u2217\u3009) =df ex i\u00b7(p=i\u2227i>0)\nIsPred(c) fresh i\u2217 Invn(p::c\u3008v\u2217\u3009) = ex j\u2217 \u00b7\n\u2228\n(\u2203u\u2217\u00b7\u03c0)\u2217\nXPuren(p::c\u3008v\u2217\u3009) =df ex i\u2217 \u00b7 [i\u2217\/j\u2217]\n\u2228\n(\u2203u\u2217\u00b7\u03c0)\u2217\nXPuren(\u03ba1 \u2217 \u03ba2) =df XPuren(\u03ba1) \u2227 XPuren(\u03ba2)\nFigure 4. XPure : Translating to Pure Form\nThe invariants associated with shape predicates play an\nimportant role in our system. Without the knowledge m\u22650,\nthe entailment x::node\u3008 , y\u3009 \u2217 y::ll\u3008m\u3009 \u0013 x::ll\u3008n\u3009 \u2227 n\u22651\nwould not have succeeded due to n\u22651. Without the more\nprecise derived invariant using XPure for predicate ll, the\nentailment x::ll\u3008n\u3009 \u2227 n>0 \u0013 x\u000f=null would not have suc-\nceeded either.\n4.2 Separation Constraint Entailment\nWe express the main procedure for heap entailment by\nthe relation\n\u0394A\u0013\u03baV \u0394C \u2217\u0394R\nwhich denotes \u03ba \u2217\u0394A\u0013\u2203V \u00b7(\u03ba \u2217\u0394C) \u2217\u0394R.\nThe purpose of heap entailment is to check that heap\nnodes in the antecedent \u0394A are sufficiently precise to cover\nall nodes from the consequent \u0394C , and to compute a resid-\nual heap state \u0394R. \u03ba is the history of nodes from the an-\ntecedent that have been used to match nodes from the conse-\nquent, V is the list of existentially quantified variables from\nthe consequent. Note that k and V are derived. The en-\ntailment checking procedure is invoked with \u03ba = emp and\nV = \u2205. The entailment checking rules are given in Fig 5.\nWe discuss the matching rule in what follows, and leave un-\nfold\/fold rules to Sec 5.\nThe procedure works by successively matching up heap\nnodes that can be proven aliased. As the matching process is\nincremental, we keep the successfully matched nodes from\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\n[ENT\u2212EMP]\n\u03c1=[0\/null]\nXPuren(\u03ba1\u2217\u03ba)\u2227\u03c1\u03c01=\u21d2\u03c1\u2203V\u00b7\u03c02\n\u03ba1\u2227\u03c01\u0013\u03baV \u03c02 \u2217 (\u03ba1\u2227\u03c01)\n[ENT\u2212MATCH]\nXPuren(p1::c\u3008v\u22171\u3009\u2217\u03ba1\u2217\u03c01)=\u21d2p1=p2 \u03c1=[v\u22171\/v\u22172 ]\n\u03ba1\u2227\u03c01\u2227freeEqn(\u03c1, V )\u0013\u03ba\u2217p1::c\u3008v\n\u2217\n1 \u3009\nV\u2212{v\u22172} \u03c1(\u03ba2\u2227\u03c02) \u2217\u0394\np1::c\u3008v\u22171\u3009\u2217\u03ba1\u2227\u03c01\u0013\u03baV (p2::c\u3008v\u22172\u3009\u2217\u03ba2\u2227\u03c02) \u2217\u0394\n[ENT\u2212RHS\u2212EX]\n\u03941\u0013\u03baV \u222a{w}([w\/v]\u03942) \u2217\u03943\nfresh w \u0394=\u2203 w \u00b7\u03943\n\u03941\u0013\u03baV (\u2203 v \u00b7\u03942) \u2217\u0394\n[ENT\u2212FOLD]\nIsPred(c2)\u2227IsData(c1) (\u0394r, \u03bar, \u03c0r)\u2208fold\u03ba(p1::c1\u3008v\u22171\u3009\u2217\u03ba1\u2227\u03c01, p2::c2\u3008v\u22172\u3009)\nXPuren(p1::c1\u3008v\u22171\u3009\u2217\u03ba1\u2217\u03c01)=\u21d2p1=p2 (\u03c0a, \u03c0c)=split{v\n\u2217\n2}\nV (\u03c0\nr) \u0394r\u2227\u03c0a\u0013\u03barV (\u03ba2\u2227\u03c02\u2227\u03c0c) \u2217\u0394\np1::c1\u3008v\u22171\u3009\u2217\u03ba1\u2227\u03c01\u0013\u03baV (p2::c2\u3008v\u22172\u3009\u2217\u03ba2\u2227\u03c02) \u2217\u0394\n[ENT\u2212LHS\u2212EX]\n[w\/v]\u03941\u0013\u03baV \u03942 \u2217\u0394\nfresh w\n\u2203v \u00b7\u03941\u0013\u03baV \u03942 \u2217\u0394\n[ENT\u2212UNFOLD]\nXPuren(p1::c1\u3008v\u22171\u3009\u2217\u03ba1\u2217\u03c01)=\u21d2p1=p2 IsPred(c1)\u2227IsData(c2)\nunfold(p1::c1\u3008v\u22171\u3009)\u2217\u03ba1\u2227\u03c01\u0013\u03baV (p2::c2\u3008v\u22172\u3009\u2217\u03ba2\u2227\u03c02) \u2217\u0394\np1::c1\u3008v\u22171\u3009\u2217\u03ba1\u2227\u03c01\u0013\u03baV (p2::c2\u3008v\u22172\u3009\u2217\u03ba2\u2227\u03c02) \u2217\u0394\n[ENT\u2212LHS\u2212OR]\n\u03941\u0013\u03baV \u03943 \u2217\u03944\n\u03942\u0013\u03baV \u03943 \u2217\u03945\n\u03941\u2228\u03942\u0013\u03baV \u03943 \u2217 (\u03944\u2228\u03945)\n[ENT\u2212RHS\u2212OR]\n\u03941\u0013\u03baV \u0394i \u2217\u0394Ri\n\u03941\u0013\u03baV (\u03942\u2228\u03943) \u2217\u0394Ri\ni\u2208{2, 3}\nFigure 5. Separation Constraint Entailment\nantecedent in \u03ba for better precision. For example, consider\nthe following (valid) proof:\n(((p=null \u2227 n=0) \u2228 (p\u000f=null \u2227 n>0))\n\u2227n>0 \u2227 m=n) =\u21d2 p\u000f=null\n\u0394R = (n>0 \u2227 m=n)\nn>0 \u2227 m=n \u0013p::ll\u3008n\u3009 p\u000f=null \u2217 \u0394R\np::ll\u3008n\u3009 \u2227 n>0 \u0013 p::ll\u3008m\u3009 \u2227 p\u000f=null \u2217 \u0394R\nHad the predicate p::ll\u3008n\u3009 not been kept and used, the proof\nwould not have succeeded. Such an entailment would be\nuseful when, for example, a list with positive length n is\nused as input for a function that requires a non-empty list.\nAnother feature of the entailment procedure is exempli-\nfied by the transfer of m=n to the antecedent (and subse-\nquently to the residue). In general, when a match occurs\n(rule [ENT\u2212MATCH]) and an argument of the heap node\ncoming from the consequent is free, the entailment proce-\ndure binds the argument to the corresponding variable from\nthe antecedent and moves the equality to the antecedent. In\nour system, free variables in consequent are variables from\nmethod preconditions. Hence these bindings act as substitu-\ntions that have to be kept in antecedent to allow subsequent\nprogram state (from residual heap) to be aware of their val-\nues. This process is formalized by the function freeEqn be-\nlow, where V is the set of existentially quantified variables:\nfreeEqn([ui\/vi]ni=1, V ) =df\nlet \u03c0i = (if vi\u2208V then true else vi=ui) in\n\u2227n\ni=1 \u03c0i\nFor soundness, we perform a preprocessing step to ensure\nthat variables appearing as arguments of heap nodes and\npredicates are i) distinct and ii) if they are free, they do\nnot appear in the antecedent by adding (existentially quan-\ntified) fresh variables and equalities. This guarantees that\nthe generated substitutions are well-defined. It also guar-\nantees that the formula generated by freeEqn does not in-\ntroduce any additional constraints over existing variables in\nthe antecedent, as one side of each equation does not appear\nanywhere else in the antecedent.\n5 Unfold\/Fold Mechanism\nUnfold\/fold operations can be used to handle well-\nfounded inductive predicates in a deductive manner. In par-\nticular, we can unfold a predicate that appears in the an-\ntecedent if it matches with a data node in the consequent.\nCorrespondingly, we fold a predicate that appears in the\nconsequent if it matches with a data node in the antecedent.\nThe well-founded condition is sufficient to ensure termina-\ntion.\n5.1 Unfolding a Shape Predicate in the\nAntecedent\nWe apply an unfold operation on a predicate in the an-\ntecedent that matches with a data node in the consequent.\nConsider :\nx::ll3\u3008n, B\u3009\u2227n>2 \u0013 (\u2203r\u00b7x::node\u3008r, y\u3009\u2227y\u000f=null\n\u2227r \u2208 B) \u2217 \u0394R\nwhere \u0394R captures the residue of entailment. For the entail-\nment to succeed, we would first unfold the ll3\u3008n, B\u3009 predi-\ncate in the antecedent:\n\u2203q1, v \u00b7x::node\u3008v, q1\u3009\u2217q1::ll3\u3008n\u22121, B1\u3009\u2227n>2\n\u2227B=B1 \u222a {v} \u0013 (\u2203r\u00b7x::node\u3008r, y\u3009\u2227y\u000f=null \u2227 r \u2208 B) \u2217 \u0394R\nAfter removing the existential quantifiers, we obtain:\nx::node\u3008v, q1\u3009\u2217q1::ll3\u3008n\u22121, B1\u3009\u2227n>2 \u2227 B=B1 \u222a {v}\n\u0013 (x::node\u3008r, y\u3009\u2227y\u000f=null \u2227 r \u2208 B) \u2217 \u0394R\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nThe data node in the consequent is then matched up, giving:\nq1::ll3\u3008n\u22121, B1\u3009\u2227n>2\u2227B=B1 \u222a {v}\u2227q1=y\n\u0013 (q1 \u000f=null \u2227 v \u2208 B) \u2217 \u0394R\nDue to the well-founded condition, each unfolding ex-\nposes a data node that matches the data node in the con-\nsequent. Thus a reduction of the consequent immediately\nfollows, which contributes to the termination of the entail-\nment check. A formal definition of unfolding is given by\nthe [UNFOLDING] rule:\n[UNFOLDING]\nc\u3008v\u2217\u3009\u2261\u03a6 \u2208 P\nunfold(p::c\u3008v\u2217\u3009) =df [p\/self]\u03a6\n5.2 Folding a Shape Predicate in the Con-\nsequent\nWe apply a fold operation when a data node in the an-\ntecedent matches with a predicate in the consequent. An\nexample is :\nx::node\u30081, q1\u3009\u2217q1::node\u30082, null\u3009\u2217y::node\u30083, null\u3009\n\u0013 (x::ll3\u3008n, B\u3009\u2227n>1\u22271 \u2208 B) \u2217 \u0394R\nThe fold step may be recursively applied but is guaranteed\nto terminate for well-founded predicate as it will reduce a\ndata node in the antecedent for each recursive invocation.\nThis reduction in the antecedent cannot go on forever. Fur-\nthermore, the fold operation may introduce bindings for the\nparameters of the folded predicate. In the above, we ob-\ntain \u2203n1, n2 \u00b7 n = n1 + 1 \u2227 n1 = n2 + 1 \u2227 n2 = 0 and\n\u2203B1, B2 \u00b7 B = B1 \u222a {2} \u2227 B1 = {1} \u222a B2 \u2227 B2 = {},\nwhere n1, n2, B1, B2 are existential variables introduced by\nthe folding process, and are subsequently eliminated. Each\nof the previous formulae may be transferred to the an-\ntecedent if n and B are free, respectively. Otherwise, they\nwill be kept in the consequent. Since n and B are indeed\nfree, our folding step would finally derive:\ny::node\u30083, null\u3009 \u2227 n = 2 \u2227 B = {1, 2}\n\u0013 (n>1 \u2227 1 \u2208 B) \u2217 \u0394R\nThe effects of folding may seem similar to unfolding the\npredicate in the consequent. However, there is a subtle dif-\nference in their handling of bindings for free derived vari-\nables. If we choose to use unfolding on the consequent\ninstead, these bindings may not be transferred to the an-\ntecedent. Consider the example below where n is free :\nz=null \u0013 z::ll3\u3008n, B\u3009 \u2227 n>\u22121 \u2217 \u0394R\nBy unfolding the predicate ll\u3008n\u3009 in the consequent, we ob-\ntain :\nz=null \u0013 (z=null\u2227n=0\u2227B = {}\u2227n>\u22121)\n\u2228(\u2203q, v\u00b7z::node\u3008v, q\u3009\u2217q::ll3\u3008n\u22121, B1\u3009\n\u2227B = B1 \u222a {v}\u2227n>\u22121) \u2217 \u0394R\nThere are now two disjuncts in the consequent. The second\none fails because it mismatches. The first one matches but\nstill fails as the derived binding n=0 was not transferred to\nthe antecedent.\nWhen a fold to a predicate p2::c2\u3008v\u22172\u3009 is performed, the\nconstraints related to variables v\u22172 are important. The split\nfunction projects these constraints out and differentiates\nthose constraints based on free variables.\nsplit{v\n\u2217\n2}\nV (\n\u2227n\ni=1 \u03c0\nr\ni ) =\nlet \u03c0ai , \u03c0\nc\ni = if FV(\u03c0\nr\ni ) \u2229 v\u22172 = \u2205 then (true, true)\nelse if FV(\u03c0ri ) \u2229 V = \u2205 then (\u03c0ri , true)\nelse (true, \u03c0ri )\nin (\n\u2227n\ni=1 \u03c0\na\ni ,\n\u2227n\ni=1 \u03c0\nc\ni )\n[FOLDING]\nc\u3008v\u2217\u3009\u2261\u03a6 \u2208 P Wi=Vi\u2212{v\u2217, p}\n\u03ba\u2227\u03c0\u0013\u03ba\u2032{p,v\u2217}[p\/self]\u03a6 \u2217 {(\u0394i, \u03bai, Vi, \u03c0i)}ni=1\nfold\u03ba\n\u2032\n(\u03ba\u2227\u03c0, p::c\u3008v\u2217\u3009) =df {(\u0394i, \u03bai,\u2203Wi\u00b7\u03c0i)}ni=1\nA formal definition of folding is specified by rule\n[FOLDING]. Some heap nodes from \u03ba are removed by the\nentailment procedure so as to match with the heap formula\nof predicate p::c\u3008v\u2217\u3009. This requires a special version of en-\ntailment that returns three extra things: (i) consumed heap\nnodes, (ii) existential variables used, and (iii) final conse-\nquent. The final consequent is used to return a constraint for\n{v\u2217} via \u2203Wi\u00b7\u03c0i. A set of answers is returned by the fold\nstep as we allow it to explore multiple ways of matching\nup with its disjunctive heap state. Our entailment also han-\ndles empty predicates correctly with a couple of specialised\nrules.\n6 Soundness of Entailment\nThe following theorems state that our entailment check\nprocedure (given in Fig. 5) is sound and terminating. Proofs\nare given in the technical report [19].\nTheorem 6.1 (Soundness) If entailment check\n\u03941\u0013\u03942 \u2217\u0394 succeeds, we have: for all s, h, if s, h |= \u03941\nthen s, h |= \u03942 \u2217\u0394.\nTheorem 6.2 (Termination) The entailment check\n\u03941\u0013\u03942 \u2217\u0394 always terminates.\n7 Implementation\nWe have built a prototype system using Objective Caml.\nThe proof obligations generated by our verification are dis-\ncharged using either a constraint solver or a theorem prover.\nThis is organised as an option in our system and currently\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\ncovers automatic provers of Omega Calculator [22], Is-\nabelle [21], and MONA [13].\nFigure 6 summarizes a suite of programs tested. These\nexamples use complicated recursion and data structures\nwith sophisticated shape, size and bag properties. They\nshow that our approach is general enough to handle interest-\ning data structures such as sorted lists, sorted trees, priority\nqueues, balanced trees, etc. in a uniform way. Verification\ntime of a function includes time to verify all functions that\nit calls.\nArithmetic Constraints.The time required for shape and\nsize verification is mostly within a couple of seconds when\nusing the Omega Calculator to discharge the proof obliga-\ntions (third column). In order to have a reference point for\nthe Omega timings, we tried solving the same constraints\nwith two other theorem provers : Isabelle (fourth column)\nand MONA (fifth column). From the former, we only used\nan automatic but incomplete prover, which caused some\nproofs to fail. The latter is an implementation of the weak\nmonadic second-order logics WS1S and WS2S. Therefore,\nfirst-order variables can be compared and subjected only\nto addition with constants. As Presburger arithmetic al-\nlows the addition of arbitrary linear arithmetic terms, we\nconverted its formulas into WS1S by encoding naturals as\nBase-2 bit strings. MONA translates WS1S and WS2S for-\nmulas into minimumDFAs (Deterministic Finite Automata)\nand GTAs (Guided Tree Automata), respectively. However,\nthis translation may cause a state-space explosion. In our\ncase, we confronted such a problem when verifying the\nquick sort method, where the size of its corresponding\nautomaton exceeded the available space.\nBag\/Set Constraints. Bag constraints were solved using\nthe multiset theory of Isabelle (sixth column), while weak\nmonadic second-order theory of 1 successor WS1S from\nMONA was used to handle set constraints (seventh col-\numn). Due to the incompletness of the automatic prover\nthat we used from Isabelle, some of the proofs failed\n(quick sort, delete max from priority queue heap and\ninsert into a red-black tree). On the other hand, MONA\nseemed to provide satisfactory results when handling set\nconstraints.\nFrom our experiments, we may conclude that verification\nprocess is dominated by entailment proving of pure formu-\nlas that are fast with specialised solvers, such as Omega for\nPresburger constraint and MONA for set constraints. The\ntimings for verifying shapes only (without size\/bag prov-\ning) are benign, as reflected in the second column. An\nimportant future work is to design a combination strategy\nthat allows specialised solvers to work well with mixed con-\nstraints and to handle large programs. We expect code mod-\nularity, decomposed shape views and multi-core parallelism\nto be important techniques in performance engineering of\nautomated verification system.\n8 Related Work\nSeparation Logic. The general framework of separation\nlogic [23, 11] is highly expressive but undecidable. Like-\nwise, [17] formalised the proof rules for handling abstract\npredicates (with scopes on visibility of predicates) but pro-\nvided no automated procedure for checking the user sup-\nplied specifications. In the search for a decidable fragment\nof separation logic for automated verification, Berdine et\nal. [1] supports only a limited set of predicates without size\nproperties, disjunctions and existential quantifiers. Simi-\nlarly, Jia and Walker [12] postponed the handling of recur-\nsive predicates in their recent work on automated reasoning\nof pointer programs. Our approach is more pragmatic as\nwe aim for a sound and terminating formulation of auto-\nmated verification via separation logic but do not aim for\ncompleteness in the expressive fragment that we handle.\nOn the inference front, Lee et al. [16] has conducted an\nintraprocedural analysis for loop invariants using grammar\napproximation under separation logic. Their analysis can\nhandle a wide range of shape predicates with local sharing\nbut is restricted to predicates with two parameters and with-\nout size properties. A recent work [9] has also formulated\ninterprocedural shape inference but is restricted to just the\nlist segment shape predicate. Sims [26] extends separation\nlogic with fixpoint connectives and postponed substitution\nto express recursively defined formulae to model the anal-\nysis of while-loops. However, it is unclear how to check\nfor entailment in their extended separation logic. While our\nwork does not address the inference\/analysis challenge, we\nhave succeeded in providing direct support for automated\nverification via an expressive shape and size specification\nmechanism.\nShape Checking\/Analysis. Many formalisms for shape\nanalysis have been proposed for checking user programs\u2019\nintricate manipulations of shapely data structures. One\nwell-known work is Pointer Assertion Logic [18] by\nMoeller and Schwartzbach where shape specifications in\nmonadic second-order logic are given by programmers\nfor loop invariants and method pre\/post conditions, and\nchecked by their MONA tool. For shape inference, Sa-\ngiv et al. [25] presented a parameterised framework, called\nTVLA, using 3-valued logic formulae and abstract interpre-\ntation. Based on the properties expected of data structures,\nprogrammers must supply a set of predicates to the frame-\nwork which are then used to analyse that certain shape in-\nvariants are maintained. However, most of these techniques\nwere focused on analysing shape invariants, and did not at-\ntempt to track the size properties of complex data structures.\nAn exception is the quantitative shape analysis of Rugina\n[24] where a data flow analysis was proposed to compute\nquantitative information for programs with destructive up-\ndates. By tracking unique points-to reference and its height\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nPrograms Without Omega Isabelle MONA Isabelle MONA\nsize\/bag Calculator Prover Prover Prover Prover\nLinked List verifies size\/length verifies bag\/set\ndelete 0.02 0.09 8.35 0.33 5.00 0.34\nreverse 0.02 0.07 3.28 0.21 3.01 0.20\nCircular Linked List verifies size + cyclic structure verifies bag\/set + cyclic structure\ndelete (first) 0.01 0.09 5.46 0.26 7.17 0.40\ncount 0.04 0.16 14.99 0.71 21.01 2.29\nDoubly Linked List verifies size + double links verifies bag\/set + double links\nappend 0.05 0.16 28.18 0.83 23.73 0.93\nflatten (from tree) 0.08 0.30 158.3 6.65 55.78 2.03\nSorted List verifies size + min + max + sortedness verifies bag\/set + sortedness\ndelete 0.02 0.13 34.09 26.68 51.39 0.60\ninsertion sort 0.07 0.27 41.17 18.22 27.34 0.73\nselection sort 0.10 0.41 79.08 20.62 221.7 1.10\nbubble sort 0.16 0.64 358.7 9.36 221.2 2.84\nmerge sort 0.11 0.61 342.9 105.1 150.1 21.75\nquick sort 0.19 0.59 642.0 out of memory failed 3.40\nBinary Search Tree verifies min + max + sortedness verifies bag\/set + sortedness\ninsert 0.03 0.20 failed 11.92 99.57 0.95\ndelete 0.06 0.38 97.5 6.86 943.5 3.03\nPriority Queue Heap verifies size + height + max-heap verifies bag\/set + size + max-heap\ninsert 0.15 0.45 520.8 41.55 416.2 6.45\ndelete max 0.55 7.17 failed 290.7 failed 626.1\nAVL Tree verifies size + height + height-balanced verifies bag\/set + height + height-balanced\ninsert 1.04 5.06 failed 36.02 1973 7.38\nRed-Black Tree verifies size + black-height + height-balanced verifies bag\/set + black-height + height-balanced\ninsert 0.44 1.53 2992 352.4 failed 392.8\nFigure 6. Verification Times (in seconds) for Data Structures with Arithmetic and Bag\/Set Constraints\nproperty, their algorithm is able to handle AVL-like tree\nstructures. Even then, the author acknowledged the lack\nof a general specification mechanism for handling arbitrary\nshape\/size properties.\nSize Properties. In another direction of research, size prop-\nerties have been most explored for declarative languages\n[10, 28, 6] as the immutability property makes their data\nstructures easier to analyse statically. Size analysis was later\nextended to object-based programs [7] but was restricted to\ntracking either size-immutable objects that can be aliased\nand size-mutable objects that are unaliased, with no sup-\nport for complex shapes. The Applied Type System (ATS)\n[5] was proposed for combining programs with proofs. In\nATS, dependent types for capturing program invariants are\nextremely expressive and can capture many program prop-\nerties with the help of accompanying proofs. Using linear\nlogic, ATS may also handle mutable data structures with\nsharing. However, users must supply all expected proper-\nties, and precisely state where they are to be applied, with\nATS playing the role of a proof-checker. Comparatively,\nwe use a more limited class of constraint for shape and size\nanalysis but supports automated modular verification.\nSet\/Bag Properties. Set-based analysis has been proposed\nto verify data structure consistency properties in [14], where\na decision procedure is given for a first order theory that\ncombines set and Presburger arithmetic. This result may\nbe used to build a specialised mixed constraint solver but\ncurrently has high algorithmic complexity. In [15], Lahiri\nand Qadeer reported an intra-procedural reachability analy-\nsis for well-founded linked lists using first-order axiomati-\nzation. Reachability analysis is related to set\/bag property\nthat we capture but implemented by transitive closure at the\npredicate level.\nUnfold\/Fold Mechanism. Unfold\/fold techniques were\noriginally used for program transformation [4] on purely\nfunctional programs. A similar technique called unroll\/roll\nwas later used in alias types [27] to manually witness the\nisomorphism between a recursive type and its unfolding.\nHere, each unroll\/roll step must be manually specified by\nprogrammer, in contrast to our approach which applies\nthese steps automatically during entailment checking. In\n[1], an automated procedure that uses unroll\/roll was given\nbut it was hardwired to work for only lseg and tree predi-\ncates. Furthermore, it performs rolling by unfolding a pred-\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nicate in the consequent which would miss bindings on free\nvariables. Our unfold\/fold mechanism is general, auto-\nmatic and terminates for heap entailment checking.\n9 Conclusion\nWe have presented a new approach to verifying pointer-\nbased programs that can precisely track shape, size and bag\nproperties. Our approach is built on well-founded shape re-\nlations and well-formed separation constraints from which\nwe have designed a sound procedure for heap entailment.\nOur automated deduction mechanism is based on the un-\nfold\/fold reasoning of user-definable predicates that has\nbeen proven to be sound and terminating.\nAcknowledgement\nThis work is supported by the Singapore-MIT Alliance and\nNUS research grant R-252-000-213-112.\nReferences\n[1] J. Berdine, C. Calcagno, and P. W. O\u2019Hearn. Symbolic Ex-\necution with Separation Logic. In APLAS. Springer-Verlag,\nNovember 2005.\n[2] J. Berdine, C. Calcagno, and P. W. O\u2019Hearn. Smallfoot:\nModular automatic assertion checking with separation logic.\nIn FMCO, Springer LNCS 4111, 2006.\n[3] J. Bingham and Z. Rakamaric. A Logic and Decision Pro-\ncedure for Predicate Abstraction of Heap-Manipulating Pro-\ngrams. In VMCAI, Springer LNCS 3855, pages 207\u2013221,\nCharleston, U.S.A, January 2006.\n[4] R.M. Burstall and J. Darlington. A transformation system for\ndeveloping recursive programs. Journal of ACM, 24(1):44\u2013\n67, January 1977.\n[5] C. Chen and H. Xi. Combining Programming with Theorem\nProving. In ACM SIGPLAN ICFP, Tallinn, Estonia, Septem-\nber 2005.\n[6] W.N. Chin and S.C. Khoo. Calculating sized types. In ACM\nSIGPLAN PEPM, pages 62\u201372, Boston, United States, Jan-\nuary 2000.\n[7] W.N. Chin, S.C. Khoo, S.C. Qin, C. Popeea, and H.H.\nNguyen. Verifying Safety Policies with Size Properties and\nAlias Controls. In ACM SIGSOFT ICSE, St. Louis, Missouri,\nMay 2005.\n[8] D. Distefano, P. W. O\u2019Hearn, and H. Yang. A Local Shape\nAnalysis based on Separation Logic. In TACAS. Springer-\nVerlag, March 2006.\n[9] A. Gotsman, J. Berdine, and B. Cook. Interprocedural\nShape Analysis with Separated Heap Abstractions. In SAS,\nSpringer LNCS, Seoul, Korea, August 2006.\n[10] J. Hughes, L. Pareto, and A. Sabry. Proving the correctness\nof reactive systems using sized types. In ACM POPL, pages\n410\u2013423. ACM Press, January 1996.\n[11] S. Isthiaq and P.W. O\u2019Hearn. BI as an assertion language for\nmutable data structures. In ACM POPL, London, January\n2001.\n[12] L. Jia and D. Walker. ILC: A foundation for automated rea-\nsoning about pointer programs. In 15th ESOP, March 2006.\n[13] Nils Klarlund and Anders Mller. Mona version 1.4 - user\nmanual.\n[14] V. Kuncak, H. H. Nguyen, and M. Rinard. An algorithm for\ndeciding bapa: Boolean algebra with presburger arithmetic.\nIn 20th International Conference on Automated Deduction\n(CADE-20), Tallinn, Estonia, Jul 2005.\n[15] S. Lahiri and S. Qadeer. Verifying Properties of Well-\nFounded Linked Lists. In ACM POPL, South Carolina, Jan-\nuary 2006.\n[16] O. Lee, H. Yang, and K. Yi. Automatic verification of pointer\nprograms using grammar-based shape analysis. In ESOP.\nSpringer Verlag, April 2005.\n[17] M.J.Parkinson and G.M.Bierman. Separation logic and ab-\nstraction. In ACM POPL, pages 247\u2013258, 2005.\n[18] A. Moeller and M. I. Schwartzbach. The Pointer Assertion\nLogic Engine. In ACM PLDI, June 2001.\n[19] H.H. Nguyen, C. David, S.C. Qin, and W.N. Chin. Au-\ntomated Verification of Shape, Size and Bag Properties via\nSeparation Logic. Technical report, SoC, Natl Univ. of Sin-\ngapore, July 2006. avail. at http:\/\/www.comp.nus.edu.sg\/\n\u223cchinwn\/papers\/verify-report.pdf.\n[20] H.H. Nguyen, C. David, S.C. Qin, and W.N. Chin. Auto-\nmated Verification of Shape And Size Properties via Separa-\ntion Logic. In VMCAI, Nice, France, January 2007.\n[21] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel.\nIsabelle\/HOL \u2014 A Proof Assistant for Higher-Order Logic,\nvolume 2283 of LNCS. Springer, 2002.\n[22] W. Pugh. The Omega Test: A fast practical integer program-\nming algorithm for dependence analysis. Communications\nof the ACM, 8:102\u2013114, 1992.\n[23] J. Reynolds. Separation Logic: A Logic for Shared Mutable\nData Structures. In IEEE LICS, Copenhagen, Denmark, July\n2002.\n[24] R. Rugina. Quantitative Shape Analysis. In SAS, Springer\nLNCS, Verona, Italy, August 2004.\n[25] S. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis\nvia 3-valued logic. ACM TOPLAS, 24(3), May 2002.\n[26] E\u00b4-J. Sims. Extending separation logic with fixpoints and\npostponed substitution. Theoretical Computer Science,\n351(2):258\u2013275, 2006.\n[27] D. Walker and G. Morrisett. Alias Types for Recursive Data\nStructures. In TIC, Springer LNCS 2071, pages 177\u2013206,\n2000.\n[28] H. Xi. Dependent Types in Practical Programming. PhD\nthesis, Carnegie Mellon University, 1998.\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\n"}