{"doi":"10.1109\/PERCOMW.2007.21","coreId":"70169","oai":"oai:eprints.lancs.ac.uk:12994","identifiers":["oai:eprints.lancs.ac.uk:12994","10.1109\/PERCOMW.2007.21"],"title":"An Experimental Comparison of Event Driven and Multi-Threaded Sensor Node Operating Systems","authors":["Duffy, Cormac","Roedig, Utz","Herbert, John","Sreenan, Cormac J."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-03","abstract":"Two different operating system types are currently considered for sensor networks: event driven and multi-threaded. This paper compares the two well-known operating systems TinyOS (event driven) and MANTIS (multi-threaded) regarding their memory usage, power consumption and processing capabilities. TinyOS and MANTIS are both ported to the DSYS25 sensor platform. Both operating systems are used to execute the same sensor network application and the aforementioned parameters of interest are measured. The results presented in this paper show for which set of applications each operating system is preferable","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/70169.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/12994\/1\/persens07duffy(2).pdf","pdfHashValue":"f935e3b42f2ea6103248af34a815b9bb69c48efc","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:12994<\/identifier><datestamp>\n      2018-01-24T02:10:28Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D626F6F6B5F73656374696F6E<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        An Experimental Comparison of Event Driven and Multi-Threaded Sensor Node Operating Systems<\/dc:title><dc:creator>\n        Duffy, Cormac<\/dc:creator><dc:creator>\n        Roedig, Utz<\/dc:creator><dc:creator>\n        Herbert, John<\/dc:creator><dc:creator>\n        Sreenan, Cormac J.<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        Two different operating system types are currently considered for sensor networks: event driven and multi-threaded. This paper compares the two well-known operating systems TinyOS (event driven) and MANTIS (multi-threaded) regarding their memory usage, power consumption and processing capabilities. TinyOS and MANTIS are both ported to the DSYS25 sensor platform. Both operating systems are used to execute the same sensor network application and the aforementioned parameters of interest are measured. The results presented in this paper show for which set of applications each operating system is preferable.<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:date>\n        2007-03<\/dc:date><dc:type>\n        Contribution in Book\/Report\/Proceedings<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/eprints.lancs.ac.uk\/12994\/1\/persens07duffy(2).pdf<\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1109\/PERCOMW.2007.21<\/dc:relation><dc:identifier>\n        Duffy, Cormac and Roedig, Utz and Herbert, John and Sreenan, Cormac J. (2007) An Experimental Comparison of Event Driven and Multi-Threaded Sensor Node Operating Systems. In: Pervasive Computing and Communications Workshops, 2007. PerCom Workshops '07. Fifth Annual IEEE International Conference on. IEEE, pp. 267-271. ISBN 0-7695-2788-4<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/12994\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":null,"relations":["http:\/\/dx.doi.org\/10.1109\/PERCOMW.2007.21","http:\/\/eprints.lancs.ac.uk\/12994\/"],"year":2007,"topics":["QA75 Electronic computers. Computer science"],"subject":["Contribution in Book\/Report\/Proceedings","NonPeerReviewed"],"fullText":"An Experimental Comparison of Event Driven and Multi-Threaded Sensor Node\nOperating Systems\nCormac Duffy, John Herbert, Cormac Sreenan\nComputer Science Department\nUniversity College Cork, Ireland\n{c.duffy|j.herbert|c.sreenan}@cs.ucc.ie\nUtz Roedig\nInfoLab21\nLancaster University, UK\nu.roedig@lancaster.ac.uk\nAbstract\nTwo different operating system types are currently con-\nsidered for sensor networks: event driven and multi-\nthreaded. This paper compares the two well -known op-\nerating systems TinyOS (event driven) and MANTIS (multi-\nthreaded) regarding their memory usage, power consump-\ntion and processing capabilities. TinyOS and MANTIS are\nboth ported to the DSYS25 sensor platform. Both operat-\ning systems are used to execute the same sensor network\napplication and the aforementioned parameters of interest\nare measured. The results presented in this paper show for\nwhich set of applications each operating system is prefer-\nable.\n1. Introduction\nCurrently, operating systems for sensor nodes follow ei-\nther one of two different design concepts, event-driven and\nmulti-threaded. In event-driven systems every action an op-\nerating system has to perform is triggered by an event (e.g.\na timer, an interrupt indicating new sensor readings or an\nincoming radio packet). The tasks associated with each\nevent are processed sequentially until the operating system\nis idle and can be sent into an energy-efficient sleep state.\nAs events are processed in order, expensive context switch-\ning between tasks is not necessary. An example of such\nan operating system is TinyOS [1]. The second approach\nfollows the multi-threaded operating system concept. The\noperating system multiplexes execution time between the\ndifferent tasks, implemented as threads. While switching\nfrom one thread to another, the current context has to be\nsaved and the new context must be restored. This consumes\ncostly resources in the constrained sensor node. An exam-\nple of such an operating system for sensor nodes is MAN-\nTIS [2].\nIt is generally assumed that an event-driven operating\nsystem is very suitable for sensor networks because few re-\nsources are needed, resulting in an energy-efficient system\n[1]. However, the exact figures are unknown and therefore\nthis paper quantifies precisely the resource usage. It is also\nclaimed that a multi-threaded operating system has com-\nparatively better event processing capabilities in terms of\nmeeting processing deadlines [2]. Again, an in-depth anal-\nysis is currently missing and is therefore conducted. For\nthe comparisons, the event-based system TinyOS and the\nmulti-threaded system MANTIS both execute the same sen-\nsor network applications on the DSYS25 [3] sensor plat-\nform. Memory requirements, energy consumption patterns\nand the event processing capabilities of the two operating\nsystems are investigated in this paper. The results presented\ncan be used to decidewhich type of operating system should\nbe used for a specific sensor network application. The re-\nsults also show that for a number of application areas a\nthread-based sensor network operating system is actually\nfeasible and even preferable.\nHistorically, there has been much debate on whether an\nevent-based or multi-threaded architecture is more efficient.\nHowever, none of these discussions consider the sensor net-\nwork domain which dictates very specific constraints. Ex-\nisting work targets only a subset of aspects investigated in\nthis paper. For example papers analyzing or describing one\nspecific operating system (e.g. [1, 2, 4]), or publications\ncomparing only one aspect (e.g. memory usage in [5]). As\neach single existing analysis is based on different assump-\ntions and experimental setups, it is not possible to extract\nan objective comparison. For an objective comparison of\nthe operating systems, a complete study presented as in this\npaper, is required. Due to space restrictions, existing related\nwork is not discussed in more detail.\nThe rest of the paper is organized as follows. Section 2\ngives an overview of the operating systems TinyOS and\nMANTIS. Section 3 describes the test application imple-\nment on our sensor nodes, for the comparative study. Sec-\ntion 5 presents the experimental comparison of the operat-\ning systems. Section 7 concludes the paper.\nAlgorithm 1 TinyOS structure\n1: component_A\n2: task do(){...}\n3: command X(){...}\n4: event Y(){...}\n5: int_A\n6: ...\n7: post_task(A)\n8: TOSH_run_task()\n9: while(TOSH_run_next_task())\n10: TOSH_sleep()\n2. Sensor Node Operating Systems\nIn order to compare the event driven and multi-threaded\noperating system concepts, a well known and widely used\nimplementation of each is selected, namely TinyOS and\nMANTIS.\nTinyOS The operating system and specialized applica-\ntions are written in the programming language nesC and are\norganized in self-contained components. A simplified view\nof this component structure is shown in Alg. 1. Components\nconsist of interfaces in the form of command and event\nfunctions. Components are assembled together, connect-\ning interfaces used by components to interfaces provided\nby others, forming a customized sensor application. The re-\nsulting component architecture facilitates event-based pro-\ncessing by implementing event-handlers and TinyOS tasks.\nTinyOS tasks are deferred function calls and are placed in a\nsimple FIFO task-queue for execution (see Alg. 1, line 8).\nTinyOS tasks are taken sequentially from the queue and are\nrun to completion. Once running, the TinyOS task can not\nbe interrupted (preempted) by another TinyOS task. Event-\nhandlers are triggered in response to a hardware interrupt\nand are able to preempt the execution of a currently running\nTinyOS task (see Alg. 1, line 5). Event-handlers perform\nthe minimum amount of processing to service the event.\nFurther non time-critical processing is performed within a\nTinyOS task that is created by the event handler. After all\nTinyOS tasks in the task queue are executed, the TinyOS\nsystem enters a sleep state to conserve energy (see Alg. 1,\nline 10). The sleep state is terminated if an interrupt occurs.\nMANTIS Each task the operating system must support\ncan be implemented - using standard C - as a separate\nMANTIS thread. A simplified view of this thread struc-\nture is shown in Alg. 2. A new thread is initialized and\nthread processing is started (line 1). Processing might\nbe halted using the function mos_semaphore_wait when\na thread has to wait for a resource to become available\n(line 3). An interrupt handler (line 4) using the function\nmos_semaphore_post (line 5) is used to signal the waiting\nAlgorithm 2MANTIS structure\n1: thread_A\n2: while(running)\n3: ...;mos_semaphore_wait(A1);...\n4: int_A\n5: ...;mos_semaphore_post(A1);...\n6:dispatch_thread()\n7: PUSH_THREAD_STACK()\n8: CURRENT_THREAD = readyQ.getThread()\n9: CURRENT_THREAD.state=RUNNING\n10: POP_THREAD_STACK()\nthread that the resource is now available and thread pro-\ncessing is resumed. While a thread is waiting on a re-\nsource to become available, other threads might be acti-\nvated or, if no other processing is required, a power sav-\ning mode is entered. Power saving is handled by a thread\ncalled idle-task which is scheduled when no other threads\nare active. Thread scheduling is performed within the ker-\nnel function dispatch_thread shown in Alg. 2, line 6. This\nfunction searches a data structure called readyQ for the\nhighest prioritized thread and activates it. When the dis-\npatch_thread function is called, the current active thread is\nsuspended calling PUSH_THREAD_STACK (line 7) which\nsaves CPU register information. The highest priority thread\nis then selected from the readyQ (line 8) and its register\nvalues are restored by the POP_THREAD_STACK function\n(line 10). Before the dispatch_thread function is called,\nthe readyQ structure is updated. Threads that are currently\nsleeping or that are waiting on a semaphore (resource)\nare excluded from the readyQ. The scheduling through the\ndispatch_thread function can be initiated by two different\nmeans. Dispatch_threadis called when a semaphore op-\neration is called (e.g. to let the current thread wait on a\nresource). Dispatch_threadis also called periodically by a\ntime slice timer to ensure processing of all threads accord-\ning to their priority.\n3. Evaluation Setup\nFor the evaluation, TinyOS and MANTIS are ported to\nthe DSYS25 [3] platform and measurement facilities are in-\ntegrated in both operating systems (see [6], for more de-\ntailed information on the evaluation setup) . To actually\nperform the comparative evaluation, an abstract application\nscenario is defined. Depending on a sensor node\u2019s role\nwithin this scenario (leaf node vs. forwarding node) and\nthe configuration of the scenario itself (high sensing task\nvs. small sensing task), a node is stressed differently. The\nperformance of a single node, exposed to the different stress\nsituations is measured while using the two different operat-\ning systems. In the following paragraphs, the abstract ap-\nplication scenario is motivated and described.\nn=3\nn=1\nn=2\nFigure 1. Binary Tree\nApplication Scenario In many cases, a sensor network is\nused to collect periodically obtained measurement data at a\ncentral point (sink or base-station) for further analysis. The\nsensor nodes in such a network execute two major tasks.\nFirst a sensor nodes perform a sensing operation and second\nthe node must forward the gathered data hop-by-hop to the\nsink. The execution time of the sensing task will depend on\nthe nature of the physical phenomenon monitored and the\ncomplexity of the algorithm used to analyze it. Therefore,\nthe position of the node in such a network and the complex-\nity of the sensing task define the operating system load of\nthe sensor node.\nThe complexity of the sensing operation depends on the\nphenomenon monitored, the sensor device used and the\ndata preprocessing required. As a result, the operating sys-\ntem can be stressed very differently. If, for example, an\nATMEGA128 CPU with a processing speed of 4Mhz is\nconsidered, a simple temperature sensing task processed\nthrough the Analog to Digital Converter can be performed\nin less than a millisecond. If the same device is used in con-\njunction with a camera, image processing might take up to\n100ms [7] before a decision is made. Note that a long sens-\ning task can be split-up into several sub-tasks but in practice\nthis is not always possible[7].\nThe complexity of a packet forwarding operation de-\npends on the transceiver type, the MAC-layer and routing\nprotocols used. On the DSYS25 platform with a Nordic\ntransceiver approximately 4000 clock cycles are necessary\nto read a packet from the transceiver, perform routing and\nre-send the packet over the transceiver. The amount of\npacket forwarding tasks depends obviously on the node un-\nder consideration and the current network topology.\nTopology It is assumed that a binary tree topology is\nformed in the network (see Fig. 1). Depending on the po-\nsition n in the tree, a sensor node might process varying\namounts of packets. In the experiments, the behavior of a\nsingle node at all possible positions n is emulated and mea-\nsured by applying the sensing pattern and network traffic as\ndescribed next.\nSensing Pattern A homogeneous activity in the sensor\nfield is assumed for the abstract application scenario. Each\nsensor gathers data with a fixed frequency fs. Thus, ev-\nery ts = 1\/fs a sensing task of the duration ls has to be\nprocessed. The duration ls is variable between ls = 4000\nOS Program Size (KB) Required RAM (B)\nTinyOS 9 283\nMANTIS 13.1 287\nTable 1. Memory Usage\nand ls = 400000 clock cycles depending on the type of\nsensing task under consideration (Which corresponds to\n1ms\/100ms on a 4MHz CPU).\nTraffic Pattern Depending on the position n of a node\nin the tree, varying amounts of forwarding tasks have to\nbe performed. It is assumed that no time synchronization\namong the sensors in the network exists. Thus, even if each\nsensor produces data with a fixed frequency, data forward-\ning tasks are not created at fixed points in time. The ar-\nrival rate \u03bbn of packets at a node at tree-level n is modeled\nas a Poisson process. As the packet forwarding activity is\nrelated to the sensing activity in the field, \u03bbn is given by:\n\u03bbn = (2n \u2212 1) \u00b7 fs. It is assumed that the duration (com-\nplexity) lp of the packet-processing task, is lp = 4000 clock\ncycles.\n4. Memory Usage\nThe memory footprint of the operating system has to be\nas small as possible. The more complex an application is\n(with respect to memory requirements), the more likely a\nmore capable Memory\/CPU chip will be required to host\nthe application.\nIn order to determine the memory usage of each oper-\nating system, we use the GNU project binary utility avr-\nsize. Avr-size is a flash image reader that outputs the pro-\ngram size and static memory (global variables) required\nby each operating system. However, the compilation pro-\ncedure for both operating systems is somewhat different.\nA specialized custom compiler (nesC) provided with the\nTinyOS framework, exploits the component-based architec-\nture to include only components required by the applica-\ntion\u2019s wiring schema in the compiled program image. Fur-\nthermore, the nesC compiler can deduce and remove any\nunused component functions within the application. Thus,\nto provide a fair memory comparison of both operating\nsystems, the MANTIS application and operating system is\nstripped before compiling of all functionality that is not\nused for the abstract application .\nResults The results in Table 1 show that the MANTIS\noperating system takes 30% extra programmable memory\nspace compared to the TinyOS operating system. It has to\nbe noted that both operating systems require additional flash\nmemory to cater for the stack which is not shown in Table 1.\nFurthermore, the MANTIS scheduler dynamically allocates\na memory pool to store the stack and processor registers for\neach thread.\nThe results show that both operating systems have very\nsimilar memory requirements. Thus, conventional micro-\nprocessors combining CPU and memory can normally hold\neither of the investigated operating systems.\n5. Event Processing\nIt is assumed that the packet-processing task within the\nnodes has priority so that deadlines regarding packet for-\nwarding can be met. Thus, in the MANTIS implementa-\ntion, the packet-processing task has a higher priority than\nthe sensing task. In the TinyOS implementation, no prior-\nitization is implemented as this feature is not provided by\nthe operating system.\nTo characterize processing performance of the operating\nsystem, the average task execution time Et of the packet\nforwarding task, is measured. During the experiment, J\npacket-processing times ej are recorded. To do so, the task\nstart time estart and the task completion time estop are mea-\nsured and the packet-processing time is recorded as e =\nestop \u2212 estart. The average task execution time Et is cal-\nculated at the end of the experiment as: Et =\n\u2211\nej\/J . For\neach tree position n, the experiment is run until J = 25000\npacket-processing events are recorded.\nResults In the experiment, the average task execution\ntime Et is determined for TinyOS and MANTIS support-\ning the abstract application scenario (see Fig. 2).\nWhere MANTIS is used, it can be observed that the av-\nerage packet-processing time is independent of the sensing\ntask execution time. Furthermore, Et is also independent\nfrom the position n of the node in the tree. The average\nprocessing time increases slightly, under a heavy load. This\nis due to the fact that under heavy load packet forwarding\ntasks have to be queued (see Fig. 2 a)).\nWhere TinyOS is used, the average processing time for\nthe packet forwarding task Et depends on the length of the\nsensing ls of the sensing task. In addition, under heavy\nload the queuing effects of the packet forwarding tasks also\ncontribute somewhat to the average processing time (see\nFig. 2 b)).\nThe variance in the packet-processing time Et is also\nrecorded but not shown due to space restrictions. It has to be\nnoted that this variance is significantly smaller in MANTIS\nthan in TinyOS (e.g. with n = 8 and ls = 75ms, there is a\n8.3ms variation of packet processing time in TinyOS com-\npared with a 0.4ms variation in MANTIS). Thus, MANTIS\nis better able to support scenarios which require predictable\nprocessing behavior.\n 2\n 4\n 6\n 8\n 10\n 12\n 14\n 16\n 18\n 1  2  3  4  5  6  7  8\nAv\ner\nag\ne \nPr\noc\nes\nsin\ng \nTi\nm\ne \nE t\n \n(m\ns)\nTree Position [n]\nMANTIS Et, ls=1msMANTIS Et, ls=5msMANTIS Et, ls=10msMANTIS Et, ls=25msMANTIS Et, ls=50msMANTIS Et, ls=75msMANTIS Et, ls=100ms\na) MANTIS\n 2\n 4\n 6\n 8\n 10\n 12\n 14\n 16\n 18\n 1  2  3  4  5  6  7  8\nAv\ner\nag\ne \nPr\noc\nes\nsin\ng \nTi\nm\ne \nE t\n \n(m\ns)\nTree Position [n]\nTinyOS Et, ls=1msTinyOS Et, ls=5msTinyOS Et, ls=10msTinyOS Et, ls=25msTinyOS Et, ls=50msTinyOS Et, ls=75msTinyOS Et, ls=100ms\nb) TinyOS\nFigure 2. Average packet-processing time Et\nThe thread prioritization capability of MANTIS is\nclearly visible in the experimental results. Packet process-\ning times are independent of the concurrently executed and\nlower priority sensing task. In TinyOS, sensing and packet\nforwarding task delays are coupled, and the influence of the\nsensing activity on the packet forwarding activity is clearly\nvisible.\n6. Energy Consumption\nTo evaluate power-efficiency, This study investigates the\navailable idle time in which low-power operations can be\nscheduled. Thus the comparative effectiveness of specific\npower management policies can be gauged on the amount\nof potential low-power (idle) time available.\nIn the experiment, the abstract application scenario is ex-\necuted by the sensor node running TinyOS or MANTIS.\nThe duration of the experiment T and the duration ik of\nK idle time periods during the experiment is recorded. i\nis defined as i = istop \u2212 istart . All idle periods ik are\nsummarized and the percentage idle time, It, the percent\nof experiment time, in which the processor is idle, which\nis calculated as follows: It = (\n\u2211\nik\/T ) \u00b7 100. Again, for\neach tree position n, the experiment is run until J = 25000\npacket-processing events are recorded.\nResults In the first experiment, the percentage idle time\nIt is determined for TinyOS and MANTIS supporting the\nabstract application scenario. (see Fig. 3).\n 40\n 50\n 60\n 70\n 80\n 90\n 100\n 1  2  3  4  5  6  7  8\nPe\nrc\nen\nta\nge\n Id\nle\n T\nim\ne \nI t \n(%\n of\n T)\nTree Position [n]\nMANTIS Ik, ls=1msMANTIS Ik, ls=5msMANTIS Ik, ls=10msMANTIS Ik, ls=25msMANTIS Ik, ls=50msMANTIS Ik, ls=75msMANTIS Ik, ls=100ms\na) MANTIS\n 40\n 50\n 60\n 70\n 80\n 90\n 100\n 1  2  3  4  5  6  7  8\nPe\nrc\nen\nta\nge\n Id\nle\n T\nim\ne \nI t \n(%\n of\n T)\nTree Position [n]\nTinyOS Ik, ls=1msTinyOS Ik, ls=5msTinyOS Ik, ls=10msTinyOS Ik, ls=25msTinyOS Ik, ls=50msTinyOS Ik, ls=75msTinyOS Ik, ls=100ms\nb) TinyOS\nFigure 3. Percentage idle time It\nThe time spent in idle mode drops exponentially for both\noperating systems with the increasing node position in the\ntree described by the parametern. This behavior is expected\nas the number of packet tasks increases accordingly. Less\nobvious is the fact that the available idle time drops faster\nin MANTIS than in TinyOS. The fast drop in idle time is\ncaused by the context switches in the MANTIS operating\nsystem. The more packet forwarding tasks are created, the\nmore likely it is that a sensing task is currently running\nwhen a packet interrupt occurs. Subsequently, a context\nswitch to the higher prioritized forwarding task is needed.\nIt is clearly visible that TinyOS is more energy efficient\nthan MANTIS; especially under a high system load.\n7. Conclusion\nBoth operating systems fit on standard microprocessors\ncombining CPU and memory. However MANTIS uses\n30% more space, but both systems are well within rea-\nsonable bounds for today\u2019s microprocessors. The experi-\nmental results show that MANTIS is more predictable than\nTinyOS. Specifically, the packet forwarding task execution\ntime in MANTIS has a low variation and is independent\nof other activity such as the sensing task. Thus, MANTIS\nwould be preferable in situations that need deterministic and\ntimely processing. However, as the experiments show, the\nMANTIS system is not as power-efficient as TinyOS. Thus,\nTinyOS would seem preferable if energy consumption is\ndeemed to be of primary importance.\nIn general, the experiments confirm what one would ex-\npect. However, an interesting and not obvious fact is high-\nlighted by the experiments. If the system is not loaded\n(leaf node with n = 1 and a sensing task with the size of\nls = 1ms) a difference of only 0.1% in idle time is mea-\nsured (compared to a difference of 6.9% under heavy load\nwith n = 8 and ls = 100ms). Thus, MANTIS would be\na good choice in cases where the sensor network is idle for\nlong periods and suddenly high activity is encountered that\nrequires timely processing of sensor information. For these\nkinds of applications, MANTIS combines both important\nsensor network design goals, i.e. energy efficiency and pre-\ndictive behavior.\nReferences\n[1] J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and\nK. Pister, \u201cSystem architecture directions for networked\nsensors,\u201d in ACM SIGOPS Operating Systems Review,\nvol. 34, pp. 93\u2013104, December 2000.\n[2] S. Bhatti, J. Carlson, H. Dai, J. Deng, J. Rose, A. Sheth,\nB. Shucker, C. Gruenwald, A. Torgenson, and R. Han,\n\u201cMANTIS OS: An embedded multithreaded operat-\ning system for wireless micro sensor platforms,\u201d ACM\nkluwer Mobile Networks & Applications Journal, spe-\ncial Issue on Wireless Sensor Networks, August 2005.\n[3] A. Barroso, J. Benson, T. Murphy, U. Roedig,\nC. Sreenan, J. Barton, S. Bellis, B. O\u2019Flynn, and\nK. Delaney, \u201cDemo abstract: The DSYS25 sensor plat-\nform,\u201d in 2nd international conference on Embedded\nnetworked sensor systems, pp. 314\u2013314, November\n2004.\n[4] A. Dunkels, B. Gronvall, and T. Voigt, \u201cContiki - a\nlightweight and flexible operating system for tiny net-\nworked sensors,\u201d in 29th Annual IEEE International\nConference on Local Computer Networks, pp. 455\u2013462,\nNovember 2004.\n[5] C. Han, R. Kumar, R. Shea, E. Kohler, and M. Srivas-\ntava, \u201cA dynamic operating system for sensor nodes,\u201d in\n3rd International Conference on Mobile Systems, Ap-\nplications, and Services, pp. 117\u2013124, June 2005.\n[6] C. Duffy, U. Roedig, J. Herbert, and C. Sreenan, \u201cA\nperformance analysis of TinyOS and MANTIS,\u201d Tech.\nRep. CS-2006-27-11, University College Cork, Ireland,\nNovember 2006.\n[7] M. Rahimi, R. Baer, O. I. Iroezi, J. C. Garcia, J. Warrior,\nD. Estrin, and M. Srivastava, \u201cCyclops: In situ image\nsensing and interpretation in wireless sensor networks,\u201d\nin In proc. 3rd international conference on Embedded\nNetworked Sensor Systems,, pp. 192\u2013204, November\n2005.\n"}