{"doi":"10.1007\/s10462-007-9051-4","coreId":"64292","oai":"oai:kar.kent.ac.uk:14531","identifiers":["oai:kar.kent.ac.uk:14531","10.1007\/s10462-007-9051-4"],"title":"Expressiveness of Temporal Query Languages: On the Modelling of Intervals, Interval Relationships and States","authors":["Gomez, Rodolfo","Ausguto, Juan Carlos"],"enrichments":{"references":[{"id":1109581,"title":"A guided tour through some extensions of the event calculus. Computational Intelligence 16(2):307\u2013347 Chittaro L, Montanari A","authors":[],"date":"2000","doi":"10.1111\/0824-7935.00115","raw":"In: Proceedings EDBT 96, Lecture Notes in Computer Science 1057, pp 325\u2013341 Cervesato I, Franceschet M, Montanari A (2000) A guided tour through some extensions of the event calculus. Computational Intelligence 16(2):307\u2013347 Chittaro L, Montanari A (1996) Ef\ufb01cient temporal reasoning in the cached event calculus. Computational Intelligence 12(3):359\u2013382 Chomicki J (1990a) Functional Deductive Databases: Query Processing in the Presence of Limited Functional Symbols. PhD thesis, Rutgers University, New Brunswick, New Jersey Chomicki J (1990b) Polynomial time query processing in temporal deductive databases. In: Proceedings of the seventh ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems, pp 379\u2013391 Chomicki J (1994) Temporal query languages: a survey. In: Proceedings of ICTL\u201994, LNCS, vol 827, Springer-Verlag, pp 506\u2013534 Clifford J, Dyreson CE, Isakowitz T, Jensen CS, Snodgrass RT (1997) On the semantics of \u201cnow\u201d in databases. ACM Transactions on Database Systems 22(2):171\u2013214 Cobo ML, Augusto JC (1999) EMTPL: A Programming Language for Temporal Deductive Data Bases.","cites":null},{"id":1109580,"title":"Maintaining Knowledge about Temporal Intervals.","authors":[],"date":"1989","doi":null,"raw":"Abadi M, Manna Z (1989) Temporal Logic Programming. Symbolic Computation 8:277 \u2013 295 Allen JF (1983) Maintaining Knowledge about Temporal Intervals. Communications of the ACM 26, No. 11:832 \u2013 843 Allen JF (1984) Towards a General Theory of Action and Time. Arti\ufb01cial Intelligence 23:123 \u2013 154 Artale A, Fisher M, Theodoludis B (eds) (2002) Proceedings of the Ninth International Workshop on Temporal Representation and Reasoning, IEEE Computer Society Press, Manchester, UK22 Baudinet M (1989) Temporal logic programming is complete and expressive. In: Sixteenth ACM Symposium on Principles of Programming Languages, Austin, Texas, pp 267\u2013280 Baudinet M (1992) A simple proof of completeness of temporal logic programming. In: nas del Cerro LF, Penttonen M (eds) Intensional Logics for Programming, Oxford University Press, pp 50\u201383 Baudinet M(1995) Onthe Expressiveness ofTemporal Logic Programming. Information and Computation 117(2):157\u2013180 Baudinet M, Niezette M, Wolper P (1991) On the representation of in\ufb01nite temporal data and queries (extended abstract). In: PODS \u201991: Proceedings of the tenth ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems, ACM Press, pp 280\u2013290 Baudinet M, Chomiki J, Wolper P (1993) Temporal Deductive Databases. In: Tansel A, Clifford J, Gadia S, Jajodia S, Segev A, Snodgrass R (eds) Temporal Data Bases (Theory, Design and Implementation), The Benjamin Cummings Pub. Co., California Bettini C, Montanari A (eds) (2001) Proceedings of the Eigth International Workshop on Temporal Representation and Reasoning, IEEE Computer Society Press, Cividale del Friuli, Italy Bettini C, Dyreson CE, Evans WS, Snodgrass RT, Wang XS (1998a) A Glossary of Time Granularity Concepts. In: Etzioni O, Jajodia S, Sripada S (eds) Temporal Databases: Research and Practice, Springer Verlag Bettini C, Wang XS, Jajodia S (1998b) Temporal semantic assumptions and their use in databases. IEEE Transactions on Knowledge and Data Engineering 10(2) Bohlen M, Chomicki J, Snodgrass RT, TomanD (1996) Querying TSQL2Databases with Temporal Logic.","cites":null},{"id":1109582,"title":"The effects of the aspectual class on the temporal structure of discourse.","authors":[],"date":"1986","doi":null,"raw":"In: Proceedings de la XIX International Conference of the Chilean Computer Science Society, Talca, Chile, pp 170\u2013178 Dowty D (1986) The effects of the aspectual class on the temporal structure of discourse. Linguistics and Philosophy 9(1):37\u201361 Dyreson CE, Snodgrass RT (1998) Supporting valid-time indeterminacy. ACM Transactions on Database Systems 23(1):1\u201357 Etzioni O, Jajodia S, Sripada S (eds) (1998) Temporal Databases: Research and Practice. Springer-Verlag Freksa C (1992) Temporal reasoning based on semi-intervals. Arti\ufb01cial Intelligence 54(1):199\u2013227 Gallaire H, Minker J, Nicolas JM (1984) Logic and databases: A deductive approach. ACM Computing Surveys 16(2):153\u2013185 Galton A (2005) Eventualities. In: M Fisher DG, Vila L (eds) Handbook of Temporal Reasoning in Arti\ufb01-cial Intelligence, Elsevier Galton A, Augusto JC (2002) Two approaches to event de\ufb01nition. In: A Hameurlain RC, Traunm\u00a8 uller R (eds) Proceedings of 13th International Conference on Database and Expert Systems Applications (DEXA 2002), Springer-Verlag, Aix-en-Provence, France, pp 547\u2013556 G\u00b4 omez RS, Augusto JC (2000) Un An\u00b4 alisis comparativo de Lenguajes de Consulta para Bases de Datos Temporales. In: Proceedings del VI Congreso Argentino de Cs. de la Computaci\u00b4 on, CACiC2000, Usuahia, 2 al 7 de octubre de 2000, pp 111\u2013122 G\u00b4 omez RS, Augusto JC (2004) Durative event composition in active databases. In: Proceedings of 6th International Conference on Enterprise Information Systems, INSTICC Press, Porto, Portugal, vol 1, pp 306\u2013311 Goodwin S, Trudel A (eds) (2000) Proceedings of the Seventh International Workshop on Temporal Representation and Reasoning, IEEE Computer Society Press, Cape Breton, Canada23 Grant J, Minker J (1992) The impact of logic programming on databases. Communications of the ACM 35(3):66\u201381 Hamblin CL (1972) Instants and Intervals. In: J Fraser FH, Muller G (eds) The Study of Time, Springer Verlag, New York, pp 324\u2013328 Jensen CS, Snodgrass RT (1996) Semantics of Time-varying information. Information Systems 21(4):311\u2013 Jensen CS, Dyreson CE, Bohlen M, Clifford J, Elmasri R, Gadia SK, Grandi F, Hayes P, Jajodia S, Kafer W, Kline N, Lorentzos N, Mitsopoulos Y, Montanari A, Nonen D, Peressi E, Pernici B, Roddick JF, Sarda NL, Scalas MR, Segev A, Snodgrass RT, Soo MD, Tansel A, Tiberio P, Wiederhold G (1998) A Glossary of Time Granularity Concepts. In: Etzioni O, Jajodia S, Sripada S (eds) Temporal Databases: Research and Practice, Springer Verlag Kowalski R (1992) Database updates in the event calculus. Journal of Logic Programming 12:121\u2013146 Kowalski R, Sergot M (1986) A logic-based calculus of events. New Generation Computing 4:67\u201395 Lloyd JW (1987) Foundations of Logic Programming, second edition edn. Springer-Verlag, Berlin McKenzie E, Snodgrass R (1989) An Evalution ofAlgebras Incorporating Time. Tech. rep., TheUniversity of Arizona Morris R, Khatib L (eds) (1999) Proceedings of the Sixth International Workshop on Temporal Representation and Reasoning, IEEE Computer Society Press, Los Alamitos, California, USA Revesz P (1993) A closed-form evaluation for Datalog queries with integer (gap)-order constraints. Theoretical Computer Science 116(1):117\u2013149 Reynolds M, Sattar A (eds) (2003) Proceedings of the Tenth International Workshop on Temporal Representation and Reasoning and Fourth Interantional Conference on Temporal Reasoning, IEEE Computer Society Press, Cairns, Queensland, Australia Snodgrass RT (1987) The Temporal Query Languaje TQuel. ACM Transactions on Database Systems 12(2):247\u2013298 Snodgrass RT (ed) (1995) The TSQL2 Temporal Query Language. Kluwer Academic Publishers, Berlin Snodgrass RT, Ahn I (1986) Temporal Databases. IEEE Computer 19, No. 9:35 \u2013 42 Stonebraker M, Wong E, Kreps P, Held G (1976) The Design and Implementation of INGRES. ACM Transactions on Database Systems 1, No. 3:189 \u2013 222 Tansel A, Tin E (1998) Expressive Power of Temporal Relational Query Languages and Temporal Completeness. In: Etzioni O, Jajodia S, Sripada S (eds) Temporal Databases: Research and Practice, Springer Verlag Tansel A, Clifford J, Gadia S, Jajodia S, Segev A, Snodgrass RT (1993) Temporal Data Bases (Theory, Design and Implementation). The Benjamin Cummings Pub. Co., California Terenziani P (2000) Is Point-Based Semantics Always Adequate for Temporal DataBases? In: Proceedings of the Seventh International Workshop on Temporal Representation and Reasoning (Time-00), pp 191\u2013199 Toman D (1996) Point-based vs. Interval-based Temporal Query Languages. In: Proceedings ACM PODS 1996, pp 58\u201367 Toman D, Niwinski D (1996) First-Order Temporal Queries Inexpressible in Temporal Logic. In: Proceedings EDBT\u201996, Lecture Notes in Computer Science 1057, pp 307\u2013324 Toman D, Chomicki J, Rogers D (1994) Datalog with integer periodicity constraints. In: ILPS \u201994: Proceedings of the 1994 International Symposium on Logic programming, MIT Press, pp 189\u2013203","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2006-12","abstract":"Storing and retrieving time-related information are important, or even critical, tasks on many areas of Computer Science (CS) and in particular for Artificial Intelligence (AI). The expressive power of temporal databases\/query languages has been studied from different perspectives, but the kind of temporal information they are able to store and retrieve is not always conveniently addressed. Here we assess a number of temporal query languages with respect to the modelling of time intervals, interval relationships and states, which can be thought of as the building blocks to represent and reason about a large and important class of historic information. To survey the facilities and issues which are particular to certain temporal query languages not only gives an idea about how useful they can be in particular contexts, but also gives an interesting insight in how these issues are, in many cases, ultimately inherent to the database paradigm. While in the area of AI declarative languages are usually the preferred choice, other areas of CS heavily rely on the extended relational paradigm. This paper, then, will be concerned with the representation of historic information in two well known temporal query languages: it Templog in the context of temporal deductive databases, and it TSQL2 in the context of temporal relational databases. We hope the results highlighted here will increase cross-fertilisation between different communities. This article can be related to recent publications drawing the attention towards the different approaches followed by the Databases and AI communities when using time-related concepts","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/64292.pdf","fullTextIdentifier":"http:\/\/kar.kent.ac.uk\/14531\/1\/Expressiveness_of_Temporal_Query_Languages_On_the.pdf","pdfHashValue":"9a9f902ee6c42e97e059ac1b7a89ec81146dce35","publisher":"Springer Netherlands","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:kar.kent.ac.uk:14531<\/identifier><datestamp>\n      2017-06-26T18:35:45Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413736<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D466163756C74696573:3132303030:3132323030:31323230302F37<\/setSpec><\/header><metadata><rioxx xmlns=\"http:\/\/www.rioxx.net\/schema\/v2.0\/rioxx\/\" xmlns:ali=\"http:\/\/ali.niso.org\/2014\/ali\/1.0\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:dcterms=\"http:\/\/purl.org\/dc\/terms\/\" xmlns:rioxxterms=\"http:\/\/docs.rioxx.net\/schema\/v2.0\/rioxxterms\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.rioxx.net\/schema\/v2.0\/rioxx\/ http:\/\/www.rioxx.net\/schema\/v2.0\/rioxx\/rioxx.xsd\" ><ali:free_to_read>\n    \n      <\/ali:free_to_read><dc:description>Storing and retrieving time-related information are important, or even critical, tasks on many areas of Computer Science (CS) and in particular for Artificial Intelligence (AI). The expressive power of temporal databases\/query languages has been studied from different perspectives, but the kind of temporal information they are able to store and retrieve is not always conveniently addressed. Here we assess a number of temporal query languages with respect to the modelling of time intervals, interval relationships and states, which can be thought of as the building blocks to represent and reason about a large and important class of historic information. To survey the facilities and issues which are particular to certain temporal query languages not only gives an idea about how useful they can be in particular contexts, but also gives an interesting insight in how these issues are, in many cases, ultimately inherent to the database paradigm. While in the area of AI declarative languages are usually the preferred choice, other areas of CS heavily rely on the extended relational paradigm. This paper, then, will be concerned with the representation of historic information in two well known temporal query languages: it Templog in the context of temporal deductive databases, and it TSQL2 in the context of temporal relational databases. We hope the results highlighted here will increase cross-fertilisation between different communities. This article can be related to recent publications drawing the attention towards the different approaches followed by the Databases and AI communities when using time-related concepts.<\/dc:description><dc:format>application\/pdf<\/dc:format><dc:identifier>http:\/\/kar.kent.ac.uk\/14531\/1\/Expressiveness_of_Temporal_Query_Languages_On_the.pdf<\/dc:identifier><dc:language>en<\/dc:language><dc:publisher>Springer Netherlands<\/dc:publisher><dc:relation>http:\/\/dx.doi.org\/10.1007\/s10462-007-9051-4<\/dc:relation><dc:relation>http:\/\/www.springerlink.com\/content\/r3347p646152351m\/<\/dc:relation><dc:source>0269-2821<\/dc:source><dc:subject>QA76<\/dc:subject><dc:title>Expressiveness of Temporal Query Languages: On the Modelling of Intervals, Interval Relationships and States<\/dc:title><rioxxterms:apc>unknown<\/rioxxterms:apc><rioxxterms:author>Gomez, Rodolfo<\/rioxxterms:author><rioxxterms:author>Ausguto, Juan Carlos<\/rioxxterms:author><rioxxterms:project funder_name=\"notused\" >notused<\/rioxxterms:project><rioxxterms:publication_date>2006-12<\/rioxxterms:publication_date><rioxxterms:type>Journal Article\/Review<\/rioxxterms:type><rioxxterms:version>NA<\/rioxxterms:version><rioxxterms:version_of_record>http:\/\/dx.doi.org\/10.1007\/s10462-007-9051-4<\/rioxxterms:version_of_record><\/rioxx><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1007\/s10462-007-9051-4","http:\/\/www.springerlink.com\/content\/r3347p646152351m\/"],"year":2006,"topics":["QA76"],"subject":["QA76"],"fullText":"Artificial Intelligence Review manuscript No.\n(will be inserted by the editor)\nExpressiveness of Temporal Query Languages: On the\nModelling of Intervals, Interval Relationships and States\u22c6\nRodolfo Saba\u00b4s Go\u00b4mez \u00b7 Juan Carlos Augusto\nReceived: date \/ Revised version: date\nAbstract Storing and retrieving time-related information are important, or even crit-\nical, tasks on many areas of Computer Science (CS) and in particular for Artificial\nIntelligence (AI). The expressive power of temporal databases\/query languages has\nbeen studied from different perspectives, but the kind of temporal information they\nare able to store and retrieve is not always conveniently addressed. Here we assess a\nnumber of temporal query languages with respect to the modelling of time intervals,\ninterval relationships and states, which can be thought of as the building blocks to\nrepresent and reason about a large and important class of historic information. To\nsurvey the facilities and issues which are particular to certain temporal query lan-\nguages not only gives an idea about how useful they can be in particular contexts,\nbut also gives an interesting insight in how these issues are, in many cases, ultimately\ninherent to the database paradigm.\nWhile in the area of AI declarative languages are usually the preferred choice,\nother areas of CS heavily rely on the extended relational paradigm. This paper, then,\nwill be concerned with the representation of historic information in two well known\ntemporal query languages: Templog in the context of temporal deductive databases,\nand TSQL2 in the context of temporal relational databases. We hope the results high-\nlighted here will increase cross-fertilisation between different communities. This ar-\nticle can be related to recent publications drawing the attention towards the different\napproaches followed by the Databases and AI communities when using time-related\nconcepts.\nKeywords Temporal Deductive Databases \u00b7 Temporal Relational Databases \u00b7\nKnowledge Representation \u00b7 Temporal Logic\n\u22c6 Final version: R.S.Gomez and J.C.Augusto, \u201cExpressiveness of Temporal Query Languages:\nOn the modelling of intervals, interval relationships and states\u201d. In: Artificial Intelligence Review,\nSpringer Netherlands, ISSN 0269-2821 (Print) 1573-7462 (Online), DOI 10.1007\/s10462-007-9051-4\n(http:\/\/www.springerlink.com\/content\/r3347p646152351m).\nComputing Laboratory, University of Kent, CT2 7NF Canterbury, Kent, UK E-mail:\nR.S.Gomez@kent.ac.uk \u00b7 School of Computing and Mathematics, University of Ulster at Jordanstown,\nBT37 0QB Newtownabbey, Co. Antrim, UK E-mail: jc.augusto@ulster.ac.uk\n21 Introduction\nTemporal databases has recently become an active research area in computer science\n(Tansel et al 1993; Etzioni et al 1998; Morris and Khatib 1999; Goodwin and Trudel\n2000; Bettini and Montanari 2001; Artale et al 2002; Reynolds and Sattar 2003)).\nThis kind of databases offers the possibility to associate time to data and to deal with\nit in a way that non-temporal systems cannot handle, or in a much more convenient\nway. For example, in a medical database it is useful to store information related to\nthe different stages a patient\u2019s health goes through. A banking system requires to\nstore the time each transaction is done as well as expiration dates for its loans. A\npublic transportation system must keep track of departing and arriving times for each\nunit. These are just a few from a plethora of contexts where dealing with time is\nfundamental for the success of the system.\nThere exist multiple levels to consider temporal issues in databases (Snodgrass\nand Ahn 1986). For example, database manager systems (DBMS) have traditionally\noffered some support for what is termed user time; this is usually represented with a\nspecial data type (e.g. date) but it is handled just as any other non-temporal attribute.\nFor example, a company database may store the period in which every employee has\nheld a particular position, by using a tuple with attributes such as the employee id, the\nname of the position and two attributes denoting the start and end dates of the period\nthat position was held. However, in a conventional DBMS there are no primitives to\ndeal with this information in such a way temporal consistency is preserved (e.g. tuple\nupdate or removal), neither are there primitives to conveniently perform complex\nforms of temporal reasoning. Valid time databases consider associate each tuple a\nvalidity period for that information (informally, the period in which the information\nis regarded as valid in the \u201creal world\u201d). Transaction time databases keep track of\nthe time when information arrives to the database manager (also when it is deleted).\nBitemporal databases support both valid and transaction time. In this paper, we will\nbe concerned only with valid time.\nThe expressiveness of temporal database models and query languages has been\nstudied from different perspectives. For instance, (Bohlen et al 1996) discusses a rela-\ntionship between TSQL2 and Temporal Logic, (Toman and Niwinski 1996) describes\nthe class of first order queries that cannot be expressed in Temporal Logic, (Toman\n1996) compares point-based vs. interval-based query languages, and (Baudinet et al\n1993) surveys some languages regarding infinite temporal extensions. Other works\naddressing expressiveness issues include (McKenzie and Snodgrass 1989; Tansel and\nTin 1998; Cobo and Augusto 1999). However, we believe that some important is-\nsues remain overlooked. The formal characterisation of a query language\u2019s expressive\npower usually receives the focus of attention, but the kind of temporal information\nthat a query language is well suited to model and retrieve not always can be inferred\ndirectly from its expressive power, and language pragmatics often results poorly sur-\nveyed. For instance, knowing that a pair of languages are as expressive as a particular\ntemporal logic does not always suffice to answer questions like What kind of problems\neach language is best suited to deal with?, Are both languages prepared to handle\nthe same problems? or Is similar information as easy to model and retrieve in one\nlanguage as it is in the other?. It is worth mentioning that query languages are not\n3considered in isolation but related to a data model through their data manipulation\nprimitives.\nThis paper addresses the facilities provided by temporal query languages for\nmodelling time intervals, Allen\u2019s interval relationships and states (Allen 1983, 1984;\nDowty 1986). These concepts are deeply related and are of paramount importance\nin valid time databases. Firstly, states stand for a possible way in which facts can be\nassigned temporal semantics. Briefly, facts are regarded as valid during time intervals\naccording to point-based semantics (Jensen and Snodgrass 1996), which happens to\nbe the kind of information that is usually required to be stored in valid time databases.\nTherefore the closer the query language expressions resemble states, the more natu-\nral it is to modelling temporal information. Finally, Allen\u2019s interval relationships can\nbe thought of as powerful retrieval tools as they describe all possible relative loca-\ntions (in time) between two intervals, and hence how a pair of facts may be located\non the time axis. In addition, these relationships naturally arise in a wide range of\napplication environments.\nThis paper, then, will be concerned with the representation of intervals, inter-\nval relationships and states in two well known temporal query languages: Templog\n(Abadi and Manna 1989) in the context of temporal deductive databases, and TSQL2\n(Snodgrass 1995) in the context of temporal relational databases. We will also con-\ntrast Templog with Datalog1S (Chomicki 1990a), and TSQL2 with TQuel (Snodgrass\n1987). A comparison between these languages serves to complement existing sur-\nveys, and helps in realising how subtle differences in expressive power, data repre-\nsentation models or even the choice of predefined temporal operators impact on the\nmodelling of intervals, interval relationships and states.\nFrom a wider perspective this work adds to previous contributions (Go\u00b4mez and\nAugusto 2000; Galton and Augusto 2002; Go\u00b4mez and Augusto 2004) rasing aware-\nness in the Databases and AI communities about the potential benefits that consider-\ning the mutual approaches may bring to each other.\nThe paper is organised as follows. Section 2 describes a formalisation of time\nintervals, interval relationships and states; and discusses the importance of these con-\ncepts on revealing the value of temporal query languages from a user\u2019s perspective.\nAt this respect, Templog and TSQL2 are analysed in sections 3 and 4, respectively.\nAmong other issues, a comparison between Templog and Datalog1S is offered in sec-\ntion 3.5. Similarly, TSQL2 and TQuel are compared in section 4.5. Conclusions are\ngiven in section 5.\n2 Interval, Interval Relationships and States\nThis section defines intervals, interval relationships and states in their most usual in-\nterpretation, and their relevance in representing valid time information. In accordance\nwith the consensus glossaries presented in (Jensen et al 1998; Bettini et al 1998a), we\ndefine a time domain as a couple \u3008T ,\u2264\u3009 where T is a non-empty set of time in-\nstants and \u2264 is a total order on T . Bounded and unbounded discrete-time models can\nbe defined over this domain. For instance, in models with initial time there exists a\ndistinctive instant o \u2208 T such that o \u2264 i for all i \u2208 T .\n4Definition 1 A time interval is a set of consecutive instants. A closed interval I with\nbounding instants i\u2212, i+ \u2208 T , i\u2212 \u2264 i+, is defined as I = [i\u2212, i+] = {i \u2208 T | i\u2212 \u2264\ni \u2264 i+}.\nIntervals can be thought as being one of the building blocks of valid time infor-\nmation. Query languages that are well suited to handle intervals provide a compact\nrepresentation of temporal validity, i.e., an efficient way of assigning temporal se-\nmantics to facts. Later in this section we will see their relevance on defining states.\nExample 1 Intervals are handled in TSQL2 (see details in section 4) through the\nPERIOD predefined data type. For instance, PERIOD \u2019[2002, 2003]\u2019.\nNote, also, that our time domain is general enough to support chronons and\ngranules (Jensen et al 1998; Bettini et al 1998a). A chronon is defined as a non-\ndecomposable time interval of some fixed, minimum duration (which is typically set\nby applications). Data models related to some query languages represent the time line\nby a sequence of chronons, and granularities, e.g., days or years, are built by indexing\nsets of consecutive chronons.\nInterval relationships were proposed by Hamblin (Hamblin 1972) and later ex-\nplored by Allen (Allen 1983, 1984) in the context of temporal reasoning, where inter-\nvals are the temporal primitives and facts can be assigned to them with such different\nmeanings as properties, processes and events. They can be defined over T as follows:\nDefinition 2 An interval relationship is a predicate over I \u00d7 I, where I is the set of\nall closed intervals over T . Let I = [i\u2212, i+] and J = [j\u2212, j+] be two intervals, then\ninterval relationships are interpreted as follows (inverse relationships can be mod-\nelled by swapping predicate arguments):\nT |= before(I, J) iff T |= i+ < j\u2212\nT |= meets(I, J) iff T |= i+ = j\u2212\nT |= overlaps(I, J) iff T |= i\u2212 < j\u2212 < i+ < j+\nT |= during(I, J) iff T |= j\u2212 < i\u2212 < i+ < j+\nT |= starts(I, J) iff T |= i\u2212 = j\u2212 < i+ < j+\nT |= finishes(I, J) iff T |= j\u2212 < i\u2212 < i+ = j+\nT |= equals(I, J) iff T |= i\u2212 = j\u2212 < i+ = j+\nExample 2 The TSQL2 predefined functionPRECEDES, which can be used in WHERE-\nclauses of SELECT statements (see details in section 4), is semantically equivalent to\nthe interval relationship before(). For instance, the following expression is true:\nPERIOD \u2019[1999, 2000]\u2019 PRECEDES PERIOD \u2019[2002, 2003]\u2019\nInterval relationships describe every possible way in which two intervals may\nbe positioned on the time axis, and by extension between a pair of facts if they are\nassigned temporal validity over intervals. This completeness makes the relationship\nset a sound vehicle to compare how conveniently temporal query languages retrieve\ninformation.\nStates can be thought of as one of many possible ways in which information can\nbe assigned temporal semantics. They have been studied by areas such as Philosophy,\n5Linguistics and Artificial Intelligence. For instance, they are considered one of the\nclasses in which human beings capture reality through language expressions, e.g., as\nstative sentences (Dowty 1986); or, from other perspective, as a way in which facts\ncan be associated to time (Allen 1984; Galton 2005).\nStates may be regarded as statements which are considered true over time inter-\nvals, called validity intervals. For example, the sentence John worked for the company\nfrom 1990 to 1998 denotes a state in which the fact John works for the company is\nconsidered true over the interval than ranges from 1990 to 1998. Moreover, states\nhold a distinctive property, usually known in the TDB an AI communities as down-\nward hereditary (Allen 1984; Bettini et al 1998b); if a state holds over interval I ,\nthen it also holds over any subinterval of I . For example, that John worked for the\ncompany from 1990 to 1998 implies that John worked for the company from 1995 to\n1997. States can be expressed by temporal databases if facts are assigned intervals ac-\ncording to point-based semantics (Jensen and Snodgrass 1996; Bettini et al 1998b); a\nfact is true over a given interval if and only if it is true at every instant of that interval.\nFormally, states can be defined as follows:\nDefinition 3 Let the pair \u3008D, T \u3009 represent the structure of a given temporal query\nlanguageL, whereD denotes the data model, i.e., a set of facts which are expressible\nby the language, and T its temporal structure. In addition, let I denote the set of all\npossible intervals over T . We will say that states can be modelled in L if a mapping\nS : D \u2192 2I can be defined, such that for every pair (d, {I1, . . . , In}) \u2208 S the fact d\nis considered valid over every instant i \u2208 Ij , for all 1 \u2264 j \u2264 n.\nExample 3 The following tuple, extracted from a TSQL2 valid time table (see details\nin section 4), can be thought of as modelling the state \u201cAnn Smith worked for the\ncompany from 1990 to 1994, and then again from 1998 until 2002\u201d. TSQL2 regards\nthe information encoded by this tuple as valid during every year in {1990, . . . , 1994,\n1998, . . . , 2002}.\nNAME VALID TIME\nAnn Smith {\u2019[1990-1994]\u2019 \u222a \u2019[1998-2002]\u2019}\nInformation in temporal databases are very often required to be stored as states.\nQuery languages that can handle states are thus able to model a wide range of sit-\nuations, which adds real value from the user\u2019s perspective. In what follows we will\nassess how some well known temporal query languages handle intervals, interval re-\nlationships and states. Let us note that this paper will not deal with issues such as\nthe implication of open intervals in databases (Clifford et al 1997), relationships on\nopen-intervals (Freksa 1992) or indeterminacy of information (Dyreson and Snod-\ngrass 1998). While all of these aspects are certainly interesting, we believe their in-\nclusion in this paper will make it exceed a reasonable length.\n3 Intervals, Interval Relationships and States in Templog\nThis section is devoted to show how intervals, interval relationships and states are\nsupported by Templog. This fact may seem surprising since Allen\u2019s relationships and\n6states are build over intervals, and Templog does not provide them as a primitive\nconcept. However, we will see that under certain modelling assumptions intervals\ncan be implicitly represented if we relate them to the occurrence of certain context-\ndependent events. In addition, the representation of states in Templog is made pos-\nsible as the language assigns validity to predicates according to point-based seman-\ntics. Therefore, we will see that Allen\u2019s relationships can be expressed by comparing\nthe interval bounding events by means of temporal logic operators such as 3; and\nthat states can be represented as facts whose validity extends between two bounding\nevents, by means of Templog\u2019s inference rules and recursion.\n3.1 Language overview\nTemplog (Abadi and Manna 1989; Baudinet 1989, 1992) is a syntactic extension of\nlogic programming to linear-time temporal logic. Time is then isomorphic to N, i.e.,\nlinear, discrete, with initial time and unbounded future. In this language, predicates\nmay vary with time, but the time point they refer to is defined implicitly by temporal\noperators rather by an explicit temporal argument.\nThe only temporal operators used in Templog are f (next), which refers to the\nnext time instant, 2 (always), which refers to the present and all the future time\ninstants, and 3 (eventually), the dual of 2, which refers to the present or to some\nfuture time instant.\nThe abstract syntax for Templog clauses is defined by the following grammar,\nwhere A stands for an atom; \u03b5 denotes an empty formula, \u201c\u2190\u201d the logical implication\noperator and a comma \u201c,\u201d in a body the conjunction operator. N stands for a next-\natom, that is, we will use fnA to denote f. . . f\n\ufe38 \ufe37\ufe37 \ufe38\nn times\nA.\nBody: B ::= \u03b5|A|B1, B2| fB|3B\nInitial Clause: IC ::= N \u2190 B|2N \u2190 B\nPermanent Clause: PC ::= 2(N \u2190 B)\nProgram Clause: O ::= IC|PC\nGoal Clause: G ::= \u2190 B\nInitial clauses describe statements that holds at the initial time; permanent clauses\nexpress statements that hold at any time instant. Program and goal clauses are as-\nsumed to be universally quantified, as in classical logic programming (Lloyd 1987).\nEach Templog program is a finite set of program clauses. Computation in Templog\nprograms is based on a temporal logic resolution method, termed TSLD-resolution\n(Abadi and Manna 1989; Baudinet 1995). Semantics for temporal logic formulas are\nprovided w.r.t. a temporal interpretation D that is an infinite sequence D0, D1, . . .\nof classical first-order interpretations (one classical interpretation for each time in-\nstant). In Templog, only predicates symbols have time-varying meanings; constants\nand function symbols are assumed to be independent of time. Templog operators are\ninterpreted as follows:\n|=Di\nfF iff |=Di+1 F\n|=Di 2F iff for every j \u2208 N, |=Di+j F\n|=Di 3F iff for some j \u2208 N, |=Di+j F\n7start work(m1)\nd start work(m2)\n2( d2 stop work(m1) \u2190 start work(m1))\n2( d4 stop work(m2) \u2190 start work(m2))\n2( d2 start work(M) \u2190 stop work(M))\nFig. 1 A simple Templog program.\nA formula F is satisfiable in a given interpretation D iff |=D0 F . A formula is valid\nif it is satisfiable in all possible interpretations.\nTemplog cannot (naturally) deal with contexts where the use of explicit time ref-\nerences, or database updates are the rule rather than the exception (Kowalski 1992).\nBecause of its roots in temporal logic, Templog is best suited to deductive databases\nand, in general, applications where temporal reasoning and the concise representation\nof relative, possibly infinite information is required (e.g. periodic information). Thus,\nour elaboration on how intervals, Allen\u2019s relationships and states can be represented\nin Templog will take into account those contexts where the language would find a\nmore natural application.\nFigure 1 shows a Templog program where the alternating use of two machines,\nm1 and m2, is represented. The program depicts a cycle where m1 starts initially, m2\nstarts 1 time units after that, m1 works in periods of 2 time units (and m2 in periods\nof 3 time units), and both machines idle for 2 time units between working periods.\n3.2 Time intervals in Templog\nSince explicit temporal references are not supported by Templog, we will assume that\nintervals will be related to states, i.e. a certain fact which is considered valid on a\ngiven period of time. Intervals, then, can be represented by a pair of predicates which\ndenote the occurrence of those events which bound the corresponding state. Because\nthe same bounding event may have multiple occurrences, these occurrences are also\nused to uniquely identify a given interval. Thus, intervals can be represented by a pair\nof predicates begin(i) and end(i), where i represents a list of attributes which\nuniquely identify the interval in question, e.g. a state name, and a particular instance\nnumber which is related to a specific occurrence of bounding events (a full character-\nisation of states will be discussed later, in section 3.4). Notice that more convenient\nrepresentations may exist. Since, in general, this will depend on the problem being\nmodelled, we have proposed just a possible solution which might accommodate a\nnumber of commonly found scenarios.\nFigure 2 shows how the program of Figure 1 can be modified to represent those\nintervals where each machine is operational. Such a state (working) is bounded by\nthe events corresponding to a machine starting and stopping. Correspondingly, the\npredicates start work and stop work now feature an extra parameter (a natural\nnumber) identifying the event occurrence. Notice that the program offers, indeed,\na concise representation of infinitely periodic intervals, e.g. that the machine m1 is\noperational during [4k, 4k + 2], k \u2208 N.\n8start work(m1,1)\nd start work(m2,1)\n2( d2 stop work(m1,N) \u2190 start work(m1,N))\n2( d4 stop work(m2,N) \u2190 start work(m2,N))\n2( d2 start work(M,N+1) \u2190 stop work(M,N))\n2(begin(working,M,N) \u2190 start work(M,N))\n2(end(working,M,N) \u2190 stop work(M,N))\nFig. 2 Representing time intervals in Templog.\n3.3 Modelling interval relationships\nSince Allen\u2019s relationships are defined in such a way that actual temporal spans be-\ntween intervals are abstracted away, Templog\u2019s modal operators provide a natural way\nof representing the relative position between two intervals by comparing the bound-\ning events (see semantics of Allen\u2019s relationships in def. 2). Notice that we use \u201c3\u25e6\u201d\nto denote \u201c3 f\u201d, which in turn represents the relational operator \u201c<\u201d (3 is reflexive)\nbetween a pair of instants. Let i, j be the list of attributes which uniquely identify\nintervals I and J , respectively. Intervals relationships can be modelled by predicates\nbefore, meets, etc., as shown below. Without loss of generality, we assume that\nthese predicates are time-independent.\n2 before(i,j)\n\u2190 3(end(i),3\u25e6begin(j))\n2 meets(i,j)\n\u2190 3(end(i),begin(j))\n2 overlaps(i,j)\n\u2190 3(begin(i),3\u25e6(begin(j),3\u25e6(end(i),3\u25e6end(j))))\n2 during(i,j)\n\u2190 3(begin(j),3\u25e6(begin(i),3\u25e6(end(i),3\u25e6end(j))))\n2 starts(i,j)\n\u2190 3(begin(i),begin(j),3\u25e6(end(i),3\u25e6end(j)))\n2 finishes(i,j)\n\u2190 3(begin(j),3\u25e6(begin(i),3\u25e6(end(i),end(j))))\n2 equals(i,j)\n\u2190 3(begin(i),begin(j),3\u25e6(end(i),end(j)))\nNotice that these predicates are just templates, which have to be adapted to par-\nticular contexts. For example, and following the example shown in Figure 2, suppose\nthat we want to check whether it is possible that machine m1 finishes its task be-\nfore m2 starts working on its own. This check could be done by asserting predicate\nbefore\/4, as shown in Figure 3, and querying the goal\n\u2190 before(m1,N,m2,N).\n9start work(m1,1)\nd start work(m2,1)\n2( d2 stop work(m1,N) \u2190 start work(m1,N))\n2( d4 stop work(m2,N) \u2190 start work(m2,N))\n2( d2 start work(M,N+1) \u2190 stop work(M,N))\n2(begin(working,M,N) \u2190 start work(M,N))\n2(end(working,M,N) \u2190 stop work(M,N))\n2 before(M1,N1,M2,N2) \u2190 3(end(working,M1,N1),\n3\u25e6begin(working,M2,N2))\nFig. 3 Representing interval relationships in Templog.\nstart work(m1,1)\nd start work(m2,1)\n2( d2 stop work(m1,N) \u2190 start work(m1,N))\n2( d4 stop work(m2,N) \u2190 start work(m2,N))\n2( d2 start work(M,N+1) \u2190 stop work(M,N))\n2(begin(working,M,N) \u2190 start work(M,N))\n2(end(working,M,N) \u2190 stop work(M,N))\n2 (valid(working,M,N) \u2190 begin(working,M,N))\n2 ( d valid(working,M,N) \u2190 valid(working,M,N),\n3\u25e6 end(working,M,N))\n2 (state(working,M) \u2190 valid(working,M,N))\nFig. 4 Representing states in Templog.\n3.4 Modelling states\nStates can be modelled in Templog by a program where a) the state\u2019s validity intervals\nhave been asserted, and b) a predicate denoting the state in question is made valid\nat every point included in a validity interval. We have shown, already, that validity\nintervals can be modelled by asserting a pair of predicates begin, end denoting the\ninterval\u2019s bounding events. For example, Figure 4 shows how the state of a machine\nbeing operational (working) could be represented. Notice that the predicate valid\nis used to assert the validity of state at every point in time between begin and\nend.\n3.5 Discussion\nTemplog and Datalog1S. The expressiveness of the function-free subset of Templog\nis known to be equivalent to that of Datalog1S (Chomicki 1990a), a minimal exten-\nsion of Datalog (Gallaire et al 1984; Grant and Minker 1992) (the subset of function-\nfree Horn-clause logic programs) where predicates are allowed to contain one tempo-\nral argument where a successor function can be applied. Consequently, both Templog\nand Datalog1S have been proposed as suitable query languages for temporal deduc-\ntive databases (Baudinet et al 1993). However, the limitation of Datalog1S to allow\nthe successor function to be applied to at most one predicate argument severely limits\n10\nstart work(m1,0).\nstart work(m2,1).\nstart work(m3,0).\nstop work(m3,5).\nstop work(m1,T+2) :- start work(m1,T).\nstop work(m2,T+4) :- start work(m2,T).\nstart work(M,T+2) :- stop work(M,T).\nbegin(working,M,T) :- start work(M,T).\nend(working,M,T) :- stop work(M,T).\nFig. 5 The limits of Datalog1S .\nthe modelling of intervals (and consequently, that of Allen\u2019s relationships and states).\nFor example, Figure 5 shows a Datalog1S program similar to that of Figure 2, but\nextended with a third machine m3 working just during the interval [0, 5]. Here, the\nlast argument in every predicate is assumed to be the temporal parameter. Notice\nthat predicates begin\/3 and end\/3 correctly represent the single working inter-\nval for m3 ([0, 5]), but they cannot distinguish the working intervals for m1 or m2\nbecause a pair [begin, end] does not necessarily correspond to a matching pair\n[start work, stop work]. For example, they represent both [0, 2] and [0, 6], al-\nthough the proper intervals were meant to be [0, 2], [4, 6], . . . [4k, 4k + 2], k \u2208 N.\nNotice that [0, 6] is represented as a consequence of pairing the first occurrence of\nstart work at time 0 and the second occurrence of stop work at time 6. This\nproblem is the result of Datalog1S not being expressive enough to distinguish be-\ntween different occurrences of the same bounding event, which in Templog was made\npossible by adding an extra data parameter and a rule to increment it every time a new\noccurrence was identified (see Figure 2).\nHowever, Datalog1S is expressive enough to deal with settings where states are\nnot only assumed to be represented by a pair of bounding events, but also where mul-\ntiple occurrences of the same event do not happen. If this is so, then the following\nqueries can be expressed in Datalog1S: a) whether the validity intervals correspond-\ning to two different states satisfy a given Allen\u2019s relationship, b) whether a given state\nis valid at a particular point in time, and c) whether a given state is valid at a particular\ninterval. All of these are recognition queries (i.e. they have yes\/no answers). Gener-\nation queries are also possible (e.g. those which returns the set of states which hold\nsimultaneously at a particular point in time), but generation queries with infinite an-\nswers require a more involved evaluation technique. This includes the generation of\na finite model both for the Herbrand model of the program in question, and for the\nanswer to the query (Baudinet et al 1993).\nFigure 6 shows a Datalog1S program where the database is composed of 3 pairs\nof tuples [start work\/2, stop work\/2] denoting the working intervals [0, 2],\n[5, 9] and [7, 11], for the machines m1, m2 and m3 respectively. The state of a ma-\nchine being operational is represented by the predicate working\/2. This predicate\nis assigned temporal validity by conjoining two auxiliary predicates forward\/2\nand backward\/2, to represent those time points where a machine starts or has\nstarted, and stopped or will stop (respectively). The remaining auxiliary predicates\nsupport the definition of before\/2 and overlaps\/2, which in turn represent\n11\nthe corresponding Allen\u2019s relationships between the working intervals of two ma-\nchinesX and Y. For example,before(X,Y) holds if Allen\u2019s relationship before(I,J)\nholds, where I and J are the working intervals of machines X and Y, respectively. The\ndifficulty in expressing Allen\u2019s relationships in Datalog1S (notice the definition of\noverlaps\/2) comes from the fact that the relation < between time points is not\ndirectly available in the language. Thus, predicate started(M,T) (respectively\nstopped(M,T)) holds at all time-points T after machine M started (stopped). Sim-\nilarly, predicate started started(X,Y,T) (stopped stopped(X,Y,T))\nholds at all T after both machines X and Y have started (stopped), provided X started\n(stopped) before Y; and predicate started stopped(X,Y,T) denotes all time-\npoints T after Y stopped, provided X started before.\nWith these auxiliary predicates, overlaps(X,Y) can be intuitively understood\nto hold if there exist a number of time points t1 < t2 < t3 < t4 such that X started at\nt1, Y started at t2, X stopped at t3 and Y stopped at t4. Indeed, if this is the case, then\nT = t4 satisfies started started(X,Y,T), started stopped(X,Y,T)\nand stopped stopped(X,Y,T). Figure 7 depicts the situation. Notice that the\nvalidity intervals for the state of a machine being operational are, for X and Y, I =\n[t1, t3] and J = [t2, t4] (respectively), and effectively overlaps(X,Y) holds if\noverlaps(I, J) holds (compare with the semantics given for the Allen\u2019s relationship\noverlaps(I, J) in section 2). Finally, the following queries are possible:\n\u2013 Is the machine m1 working at time 1?\n(Goal \u201c:- working(m1,1)\u201d)\n\u2013 Is the machine m2 working during [6, 8]?\n(Goal \u201c:- working(m2,6), working(m2,8)\u201d)\n\u2013 Do working intervals for machines m2 and m3 overlaps?\n(Goal \u201c:- overlaps(m2,m3)\u201d)\nIt is worth mentioning that other extensions of Datalog have been proposed in the\nliterature, in which the modelling of intervals, Allen\u2019s relationships and states might\nbecome an easier task. These extensions include stratified negation (Baudinet et al\n1993; Chomicki 1994), and integer and periodicity constraints (Revesz 1993; Toman\net al 1994). However, these languages are still not expressive enough as to model\nstates where bounding events can have multiple occurrences. Other extensions over-\ncome this problem, such as adding integer constraints and stratified negation (Revesz\n1993), or allowing predicates to have an arbitrary number of temporal parameters\n(where a successor function can be applied) (Baudinet et al 1991); but query evalu-\nation for these languages is, in general, not guaranteed to terminate (they bring the\nexpressive power of Turing-computable functions).\nTemplog and the Event Calculus. Readers would acknowledge that our approach\nfor modelling intervals and states has much in common with the representation of\ntime periods and relationships in the Event Calculus (Kowalski and Sergot 1986;\nKowalski 1992). Some features of the Event Calculus, such as negation and explicit\ntemporal references, make the representation of these temporal entities easier to ex-\npress than it is in Templog. However in general this depends on the intended appli-\ncation, and Templog might be the preferred choice when infinite databases must be\n12\n% -- the database (no multiple occurrences for the same bounding event)\nstart work(m1,0).\nstop work(m1,2).\nstart work(m2,5).\nstop work(m2,9).\nstart work(m3,7).\nstop work(m3,11).\n% -- representing the \"working\" state\nforward(M,T) :- start work(M,T).\nforward(M,T+1) :- forward(M,T).\nbackward(M,T) :- stop work(M,T).\nbackward(M,T) :- backward(M,T+1).\nworking(M,T) :- forward(M,T), backward(M,T).\n% -- representing Allen\u2019s relationships (\"before\" and \"overlaps\")\nstarted(M,T+1) :- start work(M,T).\nstarted(M,T+1) :- started(M,T).\nstopped(M,T+1) :- stop work(M,T).\nstopped(M,T+1) :- stopped(M,T).\nstarted started(X,Y,T) :- start work(Y,T), started(X,T).\nstarted started(X,Y,T+1) :- started started(X,Y,T).\nstarted stopped(X,Y,T) :- stop work(Y,T), started(X,T).\nstarted stopped(X,Y,T+1) :- started stopped(X,Y,T).\nstopped stopped(X,Y,T) :- stop work(Y,T), stopped(X,T).\nstopped stopped(X,Y,T+1) :- stopped stopped(X,Y,T).\nbefore(X,Y) :- start work(Y,T), stopped(X,T).\noverlaps(X,Y) :- started started(X,Y,T), started stopped(Y,X,T),\nstopped stopped(X,Y,T).\nFig. 6 Allen\u2019s relationships and states in Datalog1S .\nstart_work(X,T)\nstart_stop(Y,X,T)started(X,T)\nstop_work(X,T)\nstart_start(X,Y,T)\nstart_work(Y,T) stop_work(Y,T)\nstop_stop(X,Y,T)\nFig. 7 Intuitive interpretation of overlaps(X,Y).\n13\nrepresented. We will not extend the comparison between Templog and the Event Cal-\nculus any further, but the reader will find extensive research done on both theory and\napplications of the Event Calculus in the literature (Chittaro and Montanari 1996;\nCervesato et al 2000).\nCoalescing in Templog. It turns out that because intervals have to be \u201cprogrammed\u201d\nad-hoc in Templog by using the language primitives, maximal intervals cannot be\nfeasibly enforced (usually known as coalescing (Tansel et al 1993)). We have seen\nthat, since explicit time-references are not supported, intervals could be represented\nby predicates asserting the occurrence of bounding events. Then, coalescing would\ninvolve a revision of the database which, as discussed by (Kowalski 1992), may result\nin a number of update operations which is disproportionate w.r.t. the complexity of\nthe coalescing itself. Also, it is not difficult to see that this problem is even worse for\ndatabases representing periodic information. For example, given the following two\nintervals:\nbegin(working,m1,1)\nf2 end(working,m1,1)\nf3 begin(working,m1,2)\nf5 end(working,m1,2)\nwe can see that, in this case, the state of working is related to [0, 2] \u222a [3, 5], instead\nof the maximal interval [0, 5] (time in Templog is discrete). Thus, coalescing these\ntwo non-maximal intervals requires two predicate removals ( f2 end\/3 and f3\nbegin\/3) and one attribute update (the occurrence number in f5 end\/3 is set to\n1 instead of 2), giving:\nbegin(working,m1,1)\nf5 end(working,m1,1)\nFinally, let us mention that coalescing is not supported in Datalog1S , either.\nComputability of Templog. Baudinet (Baudinet 1989) showed that TSLD-resolution\nis both sound and complete for Templog. However, a number of results appear in\n(Baudinet et al 1993) which might help to have a better account of the implications\nof evaluating Templog programs. For one thing, it is suggested that TSLD-resolution\nwould require a form of term-size check to guarantee termination in the presence of\nfunctional symbols. For the function-free subset of Templog, TSLD-resolution ter-\nminates for queries with finite answers. Also, it is shown how bottom-up evaluation\n(as for Datalog1S) can be modified to deal with queries with infinite answers; but it\nis not clear how this could be applied for a top-down evaluation technique such as\nTSLD-resolution. Regarding the complexity of evaluating a given recognition query,\nthe function-free subset of Templog is PSPACE-complete in terms of the size of the\ndatabase (extrapolating results given for Datalog1S). Although we are not aware of\nsuch results, we conjecture that tractable subsets might be found for Templog which\ncan be evaluated in polynomial time (as done for Datalog1S in (Chomicki 1990b)).\n14\n4 Intervals, Interval Relationships and States in TSQL2\nIntervals, interval relationships and states are all concepts which can be considered\nprimitive in TSLQ2 (Snodgrass 1995); thus, we will see that contexts in which these\nconcepts play a central role, can be modelled quite naturally. The presentation of\nTSLQ2 in this section will focus in the contrast between this language, which is rep-\nresentative of the relational database paradigm, and Templog\/Datalog1S as deduc-\ntive approaches. The general syntax of TSLQ2 specifications, and further syntactic\nand behavioral details of TSLQ2 operators presented in this section, can be found in\n(Snodgrass 1995).\n4.1 Language overview\nTSQL2 is a temporal relational query language, based on the SQL-92 standard (Tansel\net al 1993). It supports user-defined, valid and transaction times. The temporal struc-\nture is linear, discrete and bounded. Time references are stored in fixed-size struc-\ntures called timestamps. The time line is partitioned into chronons, and several gran-\nularities and calendars, both predefined an user-defined, can be built over chronons\nwith different grouping schemas. Timestamps are expressed as values with associated\ngranularity and calendar. For example, the expression DATE \u201918\/06\/2003\u2019 is a\ntimestamp denoting a specific day in the calendar (18 June, 2003).\n4.2 Modelling time intervals\nIntervals in TSQL2 are supported via the data type PERIOD. Conceptually, intervals\nare sets of consecutive granules represented by a pair of timestamps in the same\ngranularity (denoting the interval boundaries). For example, the expression PERIOD\n\u2019[1\/2003-6\/2003]\u2019 denotes the set {Jan\/03, Feb\/03, . . ., Jun\/03}.\nUnlike in Templog, intervals are entities themselves, not necessarily attached to\nfacts. TSLQ2 provides a number of functions to manipulate intervals. Among other\noperations, BEGIN and END return the interval timestamps; and INTERSECT and\n+ return, respectively, the intersection and union of two intervals. Notice that the the\nunion of two intervals may result into a set of intervals. For example,\nPERIOD \u2019[3\/2002-5\/2002]\u2019 + PERIOD \u2019[7\/2002-12\/2002]\u2019\nyields the set,\n{ \u2019[3\/2002-5\/2002]\u2019 \u222a \u2019[7\/2002-12\/2002]\u2019 }\nTSQL2 can also handle sets of intervals as entities (called temporal elements), and\nprovides the usual set operations (e.g. intersection, union and difference) and the\nfunctions FIRST and LAST to return the first and last interval of a set (in chrono-\nlogical order).\n15\nTable 1 Interval relationships in TSQL2.\nInterval relationship Equivalent TSQL2 expression\nbefore(I,J) I PRECEDES J\nmeets(I,J) END(I) = BEGIN(J)\noverlaps(I,J) BEGIN(I) PRECEDES BEGIN(J) AND\nEND(I) PRECEDES END(J)\nduring(I,J) BEGIN(J) PRECEDES BEGIN(I) AND\nEND(I) PRECEDES END(J)\nstarts(I,J) BEGIN(I) = BEGIN(J) AND END(I) PRECEDES END(J)\nfinishes(I,J) BEGIN(J) PRECEDES BEGIN(I) AND END(I) = END(J)\nequals(I,J) I = J\n4.3 Modelling interval relationships\nInterval relationships can be easily defined via the relational operators = (equals) and\nPRECEDES, which compares two timestamps, and the functions BEGIN and END\nto extract the timestamp from the interval in question. These definitions can be seen\nin Table 1 (Snodgrass 1995), where I and J denote two intervals.\n4.4 Modelling states\nStates can be expressed as valid time tuples. TSQL2 supports valid time tables (called\nstate tables), where tuples are assigned a set of maximal, non adjacent intervals (valid\ntime elements). Coalescing is automatically handled by the DBMS whenever valid\ntime elements are updated.\nThe information expressed in the tuple attributes is considered valid, according\nto point-based semantics, in each interval included in valid time element. A func-\ntion VALID is provided which extracts the valid time element from a tuple. If single\nintervals must be handled instead, valid time elements can be partitioned into their\nset of constituent intervals. This can be done by specifying option (PERIOD) in a\nFROM-clause. Example 4 illustrates the representation of states in TSLQ2.\nExample 4 The following TSLQ2 sentence creates a valid time table, EFile, where\ntuples store the name of an employee (attribute NAME); the department where she\/he\nhas worked or is currently working (attribute DEPT); and a valid time element which\nstores the periods where the employee in question has worked in the corresponding\ndepartment.\nCREATE TABLE EFile (NAME CHARACTER, DEPT CHARACTER)\nAS VALID STATE TO MONTH\nA possible instance for EFile is shown next (where predefined timestamp FOREVER\nis used to represent a future-open interval),\n16\nNAME DEPT VALID TIME\nJohn Roberts Books {\u2019[1\/2002-6\/2002]\u2019,\n\u2019[1\/2003-FOREVER]\u2019}\nJohn Roberts Bazar {\u2019[7\/2002-12\/2002]\u2019}\nAnn Smith Bazar {\u2019[3\/2002-5\/2002]\u2019}\nBy way of example, the following TSLQ2 query returns the list of departments where\nJohn Roberts worked, before he entered to work in the Bazar department,\nSELECT DISTINCT T1.DEPT\nFROM EFile(PERIOD) AS T1 T2\nWHERE T1.NAME = \u2019John Roberts\u2019 AND\nT2.NAME = T1.NAME AND\nT2.DEPT = \u2019Bazar\u2019\nAND VALID(T1) PRECEDES VALID(T2)\nNotice in the previous query (example 4 above), that the construct EFile(PERIOD)\nin the FROM-clause, decomposes every valid time element into single periods, and\nso the query is actually evaluated with respect to the following table representation,\nNAME DEPT VALID TIME\nJohn Roberts Books \u2019[1\/2002-6\/2002]\u2019\nJohn Roberts Books \u2019[1\/2003-FOREVER]\u2019\nJohn Roberts Bazar \u2019[7\/2002-12\/2002]\u2019\nAnn Smith Bazar \u2019[3\/2002-5\/2002]\u2019\n4.5 Discussion\nRelative information in TSQL2. So far we have seen that TSQL2 deals with inter-\nvals, interval relationships and states where the information is absolute, in the sense\nthat interval boundaries are explicit and known only with respect to the correspond-\ning fact. Interestingly enough, TSQL2 also provides a limited way to model situations\nwhere the temporal validity of certain facts is only known to be relative to some other\ninformation in the database.\nIn TSLQ2, relative timestamps can be constructed by adding or subtracting time\nspans to\/from other timestamps. Time spans are represented by the INTERVAL data\ntype, e.g. INTERVAL \u20193\u2019 MONTH denotes a time span of 3 months. TSLQ2 also\nprovides a way to construct new states from other states, as it is illustrated by exam-\nple 5 below,\nExample 5 The next sentence adds a new tuple to the table EFile (see example 4\nagain), which denotes that Mike Thompson started to work for the Toys department\ntwo months after John Roberts started to work for Books, and that Mike Thompson\nworked for Toys until Ann Smith stopped working for the Bazar department.\nNotice, in the specification of this state, the absence of absolute temporal refer-\nences; all we know is that the working period of Mike Thompson is relative to the\nfirst working period of John Roberts at Toy, and the last period of Ann Smith at Bazar.\nThe TSLQ2 sentence which inserts this state in EFile, is as follows,\n17\nINSERT INTO EFile\nSELECT \u2019Mike Thompson\u2019,\u2019Toys\u2019\nVALID PERIOD\n(BEGIN(VALID(J))+INTERVAL \u20192\u2019 MONTH,\nEND(LAST(VALID(D)))\nFROM EFile AS J A\nWHERE J.NAME = \u2019John Roberts\u2019 AND\nJ.DEPT = \u2019Books\u2019 AND\nA.NAME = \u2019Ann Smith\u2019 AND\nA.DEPT = \u2019Bazar\u2019\nRelative references may also appear in queries. For example, the following TSLQ2\nquery returns the department for which John Roberts was working, six months after\nMike Thompson started to work for Toys,\nSELECT J.DEPT\nFROM EFile AS J M\nWHERE J.NAME = \u2019John Roberts\u2019 AND\nM.NAME = \u2019Mike Thompson\u2019 AND\nM.DEPT = \u2019Toys\u2019 AND\nVALID(J) CONTAINS\n(BEGIN(FIRST(VALID(M))) + INTERVAL \u20196\u2019 MONTH)\nwhere the predefined function CONTAINS checks for temporal inclusion between\nintervals.\nWe have seen that contexts where the temporal information is relative, can be mod-\nelled naturally in Templog (see, e.g. Figure 1). However, compared with Templog, the\nfacilities provided in TSLQ2 to handle this kind of situations is limited. Generally\nspeaking, and as the following example shows, the TSLQ2 constructs which allows\nfor the representation of relative information, are best regarded as syntactic facilities.\nIn particular, if the base information changes, then the relative facts are not updated to\nreflect the changes. Instead, the user is supposed to check for possible inconsistencies\nand updated the necessary information.\nExample 6 Consider the simple Templog program,\nstart work(m1)\n2( f start work(m2) \u2190 start work(m1))\n2( f2 stop work(M) \u2190 start work(M))\nwhich denotes that machine m1 started working initially, that m2 always starts work-\ning 1 time-unit after m1 starts, and that both machines always works for 2 time-units.\nClearly, information is given relative to the time when machines start working, and\nin particular to the time when m1 starts.\nNow assume the representation of the same information in TSLQ2, in which we\nassume a valid time table Machines denoting the working periods of machines.\n18\nAssume, as well, that the table has only one data attribute, NAME, that the granularity\nis given in days, and that the tuple corresponding to the working period of machine m1\nhas already been inserted in the table. Then, the following sentence will add a tuple\ncorresponding to machine m2, whose working period (as we have seen) is relative to\nthe start of m1 ( BEGIN(VALID(M1))).\nINSERT INTO Machines\nSELECT \u2019m2\u2019\nVALID PERIOD ( BEGIN(VALID(M1))+INTERVAL \u20191\u2019 DAY,\nBEGIN(VALID(M1))+INTERVAL \u20192\u2019 DAY )\nFROM Machines AS M1\nWHERE M1.NAME = \u2019m1\u2019\nNow, consider a change in the original starting time for m1, in which this happens\n3 days later than initially asserted. This update is easy in Templog, yielding a new\nprogram,\nf3start work(m1)\n2( f start work(m2) \u2190 start work(m1))\n2( f2 stop work(M) \u2190 start work(M))\nIt is not difficult to note that the working period of the second machine, m2, is kept\nconsistent with this new information. However, this will not be the case in our TSLQ2\ntable, Machines. The problem is, that a clause like,\nVALID PERIOD ( BEGIN(VALID(M1))+INTERVAL \u20191\u2019 DAY,\nBEGIN(VALID(M1))+INTERVAL \u20192\u2019 DAY )\nis evaluated at insertion time, and so an expression such as,\nBEGIN(VALID(M1))+INTERVAL \u20191\u2019 DAY\nreturns, actually, just an absolute temporal reference. Therefore, changing the valid\ntime of the tuple M1 will not affect the timestamps stored for \u2019m2\u2019.\nTSQL2 and TQuel. TQuel (Snodgrass 1987; Tansel et al 1993) is a minimal exten-\nsion to Quel, the relational query language for the system Ingres (Stonebraker et al\n1976). It supports user-defined, valid and transaction times. The temporal structure is\nalso similar to that of TSQL2: a linear, discrete, and bounded set of chronons. Times-\ntamps are explicit and may be specified in different granularities. However, a few\ndifferences exist between TSQL2 and TQuel which may impact on the modelling of\nintervals, interval relationships and states.\nOne of these differences is in the modelling of interval relationships; these are\nmore difficult to express in TQuel, as the relational operator < to compare times-\ntamps is not directly available in the language. Instead, the predefined TQuel opera-\ntor precedes implements \u2264, and so negation (not) has to be used in conjunction\nto get the proper semantics for Allen\u2019s relationships. Table 2 shows the definition of\n19\nTable 2 Interval relationships in TQuel.\nInterval relationship Equivalent TQuel expression\nbefore(I,J) I precede J and not (end of I equal begin of J)\nmeets(I,J) end of I equal begin of J\noverlaps(I,J) begin of I precede begin of J and\nbegin of J precede end of I and\nend of I precede end of J and\nnot (begin of I equal begin of J) and\nnot (end of I equal end of J)\nduring(I,J) begin of J precede begin of I and\nend of I precede end of J and\nnot (I equal J)\nstarts(I,J) begin of I equal begin of J and\nend of I precede end of J and\nnot (I equal J)\nfinishes(I,J) begin of J precede begin of I and\nend of I equal end of J and\nnot (I equal J)\nequals(I,J) I equal J\nAllen\u2019s relationships in TQuel: I and J denote intervals, and functions begin of\nand end of return the timestamps of a given interval. Notice, in contrast with ta-\nble 1, that expressions are not as straightforward as in TSQL2.\nProbably the most important difference between TQuel and TSLQ2, is the rep-\nresentation of states with multiple validity intervals. Unlike TSQL2 with valid time\nelements, TQuel does not handle interval sets as single entities. Then, tuples in valid\ntime databases are assigned only a single validity interval, and modelling states with\nmultiple intervals would require one tuple for every such interval. This does not only\ncause redundancy in data attributes, but also makes certain queries more difficult to\nexpress. In particular, this is the case when the query works with some, but not all,\nvalidity intervals related to the same state. Aggregate functions would be needed to\nsearch over all tuples (which may result in nested queries), just to collect the relevant\nintervals.\nThis issue occurs in the following TQuel query, which returns the department for\nwhich John Roberts was working, six months after Mike Thompson started to work\nfor Toys (introduced for TSQL2 in example 5),\n20\nrange of J is Efile\nrange of M is Efile\nrange of T is Efile\nretrieve (J.Dept)\nwhere J.Name = \"John Roberts\" and\nM.Name = \"Mike Thompson\" and\nM.Dept = \"Toys\" and\nJ overlaps (begin of M + %6 month%) and\nM equals earliest(T where\nT.Name=\"Mike Thompson\" and\nT.Dept = \"Toys\")\nwhere earliest is an aggregate function which retrieves the first of all of those\nintervals where Mike Thompson used to work at Toys (tuple T). If we compare this\nwith the equivalent query in TSQL2, which we revisit below, we will notice that\nnested queries are not necessary, as the set of relevant intervals is already available\nwhen the tuple (M) is found.\nSELECT J.DEPT\nFROM EFile AS J M\nWHERE J.NAME = \u2019John Roberts\u2019 AND\nM.NAME = \u2019Mike Thompson\u2019 AND\nM.DEPT = \u2019Toys\u2019 AND\nVALID(J) CONTAINS\n(BEGIN(FIRST(VALID(M))) + INTERVAL \u20196\u2019 MONTH)\nNotice that the construct,\nFIRST(VALID(M))\nhas the same purpose that the aggregate function earliest in the TQuel query, i.e.\nto return the first intervals related to Mike Thompson working for Toys. However, in\nthe TSQL2 query these intervals are already available as the valid time element of M\n(and so are returned by VALID(M)). On the other hand, in TQuel a nested query is\nneeded to collect all these intervals,\nT where T.Name=\"Mike Thompson\" and T.Dept=\"Toys\"\n5 Conclusions\nWe think the main contribution of this paper is in evaluating well known temporal\nquery languages, such as Templog and TSQL2, from a novel perspective. Surveys\non formal expressiveness of temporal query languages have populated the literature;\nhowever, the issue of how naturally valid time information can be modelled, has been\nmostly overlooked. To complement existing accounts, Templog and TSQL2 have been\nevaluated from a different perspective, based upon the concepts of time intervals,\ninterval relationships and states.\n21\nWe have worked on the hypothesis that these concepts are general enough to\nrepresent a wide class of valid time information. Therefore, evaluating the languages\n(and related data models) with respect to these concepts gives an idea of the kind of\nissues which may arise in practice, in commonly found modelling tasks. In addition,\nand particularly in those cases in which the language does not naturally model certain\nconcept, we have offered possible ways in which this can be achieved.\nDeductive languages are not generally expected to deal with absolute temporal\nreferences. We have, therefore, assessed the modelling of interval, interval relation-\nships and states in more natural contexts, e.g. in those where the application will\ntypically need to reason about relative facts, or periodic information. Also, the fact\nthat a deductive language such as Templog does not support intervals as primitive\ntemporal elements, is a hindrance for the modelling of states. In addition, and among\nother issues, we have elaborated on the differences between Templog and Datalog1S\nwhen modelling states. This is interesting as reveals modelling limitations which are\nnot obvious under different evaluation contexts.\nOn the other hand, relational query languages such as TSQL2 will efficiently deal\nwith absolute intervals (and consequently, relationships and states), as intervals are\nprimitive blocks of valid time information. Nevertheless, we have shown that contexts\nin which relative information play a crucial role, might not be so straightforward\nto deal with. We have also compared TSQL2 with TQuel, in order to reveal how\nsmall differences in the languages data models and predefined operators, may have\nimportant consequences in practice when modelling states.\nWe conclude this paper by pointing out further research. We believe that a promis-\ning line of research may consider extending the expressiveness criterion in order\nto cover other kinds of temporal information, such as events and processes (Gal-\nton 2005). One work conducted in this area is that of Terenziani (Terenziani 2000).\nHe addressed some problems in TSQL2 regarding the modelling of telic facts, i.e.,\nfacts can be valid over intervals but they are not considered valid at any subinterval\nin question.\nThis work also complements previous reports in the technical literature (Galton\nand Augusto 2002; Go\u00b4mez and Augusto 2004) rasing awareness in the Databases and\nAI communities about the potential benefits that considering the mutual approaches\nmay bring to each other. In an era of specialisation, there is a potential danger of the\nareas becoming \u201dtoo introspective\u201d. We have observed that phenomenon regarding\ntemporal concepts in AI and Databases. This article, as well as other previously men-\ntioned, are part of an effort to encourage interaction between the areas and to increase\nthe benefits deriving from each others\u2019 findings.\nReferences\nAbadi M, Manna Z (1989) Temporal Logic Programming. Symbolic Computation 8:277 \u2013 295\nAllen JF (1983) Maintaining Knowledge about Temporal Intervals. Communications of the ACM 26, No.\n11:832 \u2013 843\nAllen JF (1984) Towards a General Theory of Action and Time. Artificial Intelligence 23:123 \u2013 154\nArtale A, Fisher M, Theodoludis B (eds) (2002) Proceedings of the Ninth International Workshop on\nTemporal Representation and Reasoning, IEEE Computer Society Press, Manchester, UK\n22\nBaudinet M (1989) Temporal logic programming is complete and expressive. In: Sixteenth ACM Sympo-\nsium on Principles of Programming Languages, Austin, Texas, pp 267\u2013280\nBaudinet M (1992) A simple proof of completeness of temporal logic programming. In: nas del Cerro LF,\nPenttonen M (eds) Intensional Logics for Programming, Oxford University Press, pp 50\u201383\nBaudinet M (1995) On the Expressiveness of Temporal Logic Programming. Information and Computation\n117(2):157\u2013180\nBaudinet M, Niezette M, Wolper P (1991) On the representation of infinite temporal data and queries\n(extended abstract). In: PODS \u201991: Proceedings of the tenth ACM SIGACT-SIGMOD-SIGART sym-\nposium on Principles of database systems, ACM Press, pp 280\u2013290\nBaudinet M, Chomiki J, Wolper P (1993) Temporal Deductive Databases. In: Tansel A, Clifford J, Gadia\nS, Jajodia S, Segev A, Snodgrass R (eds) Temporal Data Bases (Theory, Design and Implementation),\nThe Benjamin Cummings Pub. Co., California\nBettini C, Montanari A (eds) (2001) Proceedings of the Eigth International Workshop on Temporal Rep-\nresentation and Reasoning, IEEE Computer Society Press, Cividale del Friuli, Italy\nBettini C, Dyreson CE, Evans WS, Snodgrass RT, Wang XS (1998a) A Glossary of Time Granularity Con-\ncepts. In: Etzioni O, Jajodia S, Sripada S (eds) Temporal Databases: Research and Practice, Springer\nVerlag\nBettini C, Wang XS, Jajodia S (1998b) Temporal semantic assumptions and their use in databases. IEEE\nTransactions on Knowledge and Data Engineering 10(2)\nBohlen M, Chomicki J, Snodgrass RT, Toman D (1996) Querying TSQL2 Databases with Temporal Logic.\nIn: Proceedings EDBT 96, Lecture Notes in Computer Science 1057, pp 325\u2013341\nCervesato I, Franceschet M, Montanari A (2000) A guided tour through some extensions of the event\ncalculus. Computational Intelligence 16(2):307\u2013347\nChittaro L, Montanari A (1996) Efficient temporal reasoning in the cached event calculus. Computational\nIntelligence 12(3):359\u2013382\nChomicki J (1990a) Functional Deductive Databases: Query Processing in the Presence of Limited Func-\ntional Symbols. PhD thesis, Rutgers University, New Brunswick, New Jersey\nChomicki J (1990b) Polynomial time query processing in temporal deductive databases. In: Proceedings\nof the seventh ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems, pp\n379\u2013391\nChomicki J (1994) Temporal query languages: a survey. In: Proceedings of ICTL\u201994, LNCS, vol 827,\nSpringer-Verlag, pp 506\u2013534\nClifford J, Dyreson CE, Isakowitz T, Jensen CS, Snodgrass RT (1997) On the semantics of \u201cnow\u201d in\ndatabases. ACM Transactions on Database Systems 22(2):171\u2013214\nCobo ML, Augusto JC (1999) EMTPL: A Programming Language for Temporal Deductive Data Bases.\nIn: Proceedings de la XIX International Conference of the Chilean Computer Science Society, Talca,\nChile, pp 170\u2013178\nDowty D (1986) The effects of the aspectual class on the temporal structure of discourse. Linguistics and\nPhilosophy 9(1):37\u201361\nDyreson CE, Snodgrass RT (1998) Supporting valid-time indeterminacy. ACM Transactions on Database\nSystems 23(1):1\u201357\nEtzioni O, Jajodia S, Sripada S (eds) (1998) Temporal Databases: Research and Practice. Springer-Verlag\nFreksa C (1992) Temporal reasoning based on semi-intervals. Artificial Intelligence 54(1):199\u2013227\nGallaire H, Minker J, Nicolas JM (1984) Logic and databases: A deductive approach. ACM Computing\nSurveys 16(2):153\u2013185\nGalton A (2005) Eventualities. In: M Fisher DG, Vila L (eds) Handbook of Temporal Reasoning in Artifi-\ncial Intelligence, Elsevier\nGalton A, Augusto JC (2002) Two approaches to event definition. In: A Hameurlain RC, Traunmu\u00a8ller R\n(eds) Proceedings of 13th International Conference on Database and Expert Systems Applications\n(DEXA 2002), Springer-Verlag, Aix-en-Provence, France, pp 547\u2013556\nGo\u00b4mez RS, Augusto JC (2000) Un Ana\u00b4lisis comparativo de Lenguajes de Consulta para Bases de Datos\nTemporales. In: Proceedings del VI Congreso Argentino de Cs. de la Computacio\u00b4n, CACiC2000,\nUsuahia, 2 al 7 de octubre de 2000, pp 111\u2013122\nGo\u00b4mez RS, Augusto JC (2004) Durative event composition in active databases. In: Proceedings of 6th\nInternational Conference on Enterprise Information Systems, INSTICC Press, Porto, Portugal, vol 1,\npp 306\u2013311\nGoodwin S, Trudel A (eds) (2000) Proceedings of the Seventh International Workshop on Temporal Rep-\nresentation and Reasoning, IEEE Computer Society Press, Cape Breton, Canada\n23\nGrant J, Minker J (1992) The impact of logic programming on databases. Communications of the ACM\n35(3):66\u201381\nHamblin CL (1972) Instants and Intervals. In: J Fraser FH, Muller G (eds) The Study of Time, Springer\nVerlag, New York, pp 324\u2013328\nJensen CS, Snodgrass RT (1996) Semantics of Time-varying information. Information Systems 21(4):311\u2013\n352\nJensen CS, Dyreson CE, Bohlen M, Clifford J, Elmasri R, Gadia SK, Grandi F, Hayes P, Jajodia S, Kafer\nW, Kline N, Lorentzos N, Mitsopoulos Y, Montanari A, Nonen D, Peressi E, Pernici B, Roddick JF,\nSarda NL, Scalas MR, Segev A, Snodgrass RT, Soo MD, Tansel A, Tiberio P, Wiederhold G (1998) A\nGlossary of Time Granularity Concepts. In: Etzioni O, Jajodia S, Sripada S (eds) Temporal Databases:\nResearch and Practice, Springer Verlag\nKowalski R (1992) Database updates in the event calculus. Journal of Logic Programming 12:121\u2013146\nKowalski R, Sergot M (1986) A logic-based calculus of events. New Generation Computing 4:67\u201395\nLloyd JW (1987) Foundations of Logic Programming, second edition edn. Springer-Verlag, Berlin\nMcKenzie E, Snodgrass R (1989) An Evalution of Algebras Incorporating Time. Tech. rep., The University\nof Arizona\nMorris R, Khatib L (eds) (1999) Proceedings of the Sixth International Workshop on Temporal Represen-\ntation and Reasoning, IEEE Computer Society Press, Los Alamitos, California, USA\nRevesz P (1993) A closed-form evaluation for Datalog queries with integer (gap)-order constraints. Theo-\nretical Computer Science 116(1):117\u2013149\nReynolds M, Sattar A (eds) (2003) Proceedings of the Tenth International Workshop on Temporal Rep-\nresentation and Reasoning and Fourth Interantional Conference on Temporal Reasoning, IEEE Com-\nputer Society Press, Cairns, Queensland, Australia\nSnodgrass RT (1987) The Temporal Query Languaje TQuel. ACM Transactions on Database Systems\n12(2):247\u2013298\nSnodgrass RT (ed) (1995) The TSQL2 Temporal Query Language. Kluwer Academic Publishers, Berlin\nSnodgrass RT, Ahn I (1986) Temporal Databases. IEEE Computer 19, No. 9:35 \u2013 42\nStonebraker M, Wong E, Kreps P, Held G (1976) The Design and Implementation of INGRES. ACM\nTransactions on Database Systems 1, No. 3:189 \u2013 222\nTansel A, Tin E (1998) Expressive Power of Temporal Relational Query Languages and Temporal Com-\npleteness. In: Etzioni O, Jajodia S, Sripada S (eds) Temporal Databases: Research and Practice,\nSpringer Verlag\nTansel A, Clifford J, Gadia S, Jajodia S, Segev A, Snodgrass RT (1993) Temporal Data Bases (Theory,\nDesign and Implementation). The Benjamin Cummings Pub. Co., California\nTerenziani P (2000) Is Point-Based Semantics Always Adequate for Temporal DataBases? In: Proceedings\nof the Seventh International Workshop on Temporal Representation and Reasoning (Time-00), pp\n191\u2013199\nToman D (1996) Point-based vs. Interval-based Temporal Query Languages. In: Proceedings ACM PODS\n1996, pp 58\u201367\nToman D, Niwinski D (1996) First-Order Temporal Queries Inexpressible in Temporal Logic. In: Proceed-\nings EDBT\u201996, Lecture Notes in Computer Science 1057, pp 307\u2013324\nToman D, Chomicki J, Rogers D (1994) Datalog with integer periodicity constraints. In: ILPS \u201994: Pro-\nceedings of the 1994 International Symposium on Logic programming, MIT Press, pp 189\u2013203\n"}