{"doi":"10.1007\/s00779-005-0039-2","coreId":"91437","oai":"oai:eprints.lancs.ac.uk:12700","identifiers":["oai:eprints.lancs.ac.uk:12700","10.1007\/s00779-005-0039-2"],"title":"Supporting Ordering and Consistency in a Distributed Event Heap for Ubiquitous Computing","authors":["Storz, Oliver","Friday, Adrian","Davies, Nigel"],"enrichments":{"references":[{"id":16518848,"title":"A design for a fault-tolerant, distributed implementation of Linda.","authors":[],"date":"1989","doi":null,"raw":"A. Xu and B. Liskov: A design for a fault-tolerant, distributed implementation of Linda. Nineteenth International Symposium on Fault-Tolerant Computing (FTCS19), pp. 199\u2013206. Jun. 1989.","cites":null},{"id":16518821,"title":"A reliable multicast framework for light-weight sessions and application level framing.","authors":[],"date":"1995","doi":null,"raw":"S. Floyd, V. Jacobson et al.: A reliable multicast framework for light-weight sessions and application level framing. Proceedings of the conference on Applications, technologies, architectures, and protocols for computer communication, pp. 342\u2013356. ACM Press, 1995. ISBN 0-89791-711-1.","cites":null},{"id":16518827,"title":"Application Coordination Infrastructure for Ubiquitous Computing Rooms.","authors":[],"date":"2003","doi":null,"raw":"B. Johanson: Application Coordination Infrastructure for Ubiquitous Computing Rooms. Ph.D. thesis, Stanford University, Dec. 2003.","cites":null},{"id":16518845,"title":"Bonita: A set of tuple space primitives for distributed coordination.","authors":[],"date":"1997","doi":null,"raw":"A. I. T. Rowstron and A. M. Wood: Bonita: A set of tuple space primitives for distributed coordination. Proceedings of the 30th Hawaii International Conference on System Sciences, p. 379. IEEE Computer Society, 1997. ISBN 0-8186-7743-0.","cites":null},{"id":16518823,"title":"Generative communication in Linda.","authors":[],"date":"1985","doi":null,"raw":"D. Gelernter: Generative communication in Linda. ACM Transactions on Programming Languages and Systems, vol. 7(1): pp. 80\u2013112, 1985. ISSN 0164-0925.","cites":null},{"id":16518837,"title":"Hess et al.: A Middleware Infrastructure for Active Spaces.","authors":[],"date":null,"doi":null,"raw":"M. Rom\u00b4 an, C. Hess et al.: A Middleware Infrastructure for Active Spaces. IEEE Pervasive Computing, vol. 1(4): pp. 74\u201383.","cites":null},{"id":16518833,"title":"Leichter: Shared Tuple Memories, Shared Memories, Buses and LAN\u2019s \u2013 Linda Implementations across the Spectrum of Connectivity.","authors":[],"date":null,"doi":null,"raw":"J. S. Leichter: Shared Tuple Memories, Shared Memories, Buses and LAN\u2019s \u2013 Linda Implementations across the Spectrum of Connectivity. Ph.D. thesis, Department of Computer Science, Yale University, New Haven, Connecticut, U.S., Jul.","cites":null},{"id":16518818,"title":"Limbo: A Tuple Space Based Platform for Adaptive Mobile Applications.","authors":[],"date":"1997","doi":null,"raw":"N. Davies, S. Wade, A. Friday and G. Blair: Limbo: A Tuple Space Based Platform for Adaptive Mobile Applications. Joint International Conference on Open Distributed Processing and Distributed Platforms (ICODP\/ICDP \u201997). Chapman and Hall, Toronto, Canada, 1997.","cites":null},{"id":16518836,"title":"LIME: Linda meets mobility.","authors":[],"date":null,"doi":null,"raw":"G. P. Picco, A. L. Murphy and G.-C. Roman: LIME: Linda meets mobility. Proceedings of the 21st international conference on Software engineering, pp. 368\u2013","cites":null},{"id":16518825,"title":"Melinda: Linda with Multiple Tuple Spaces.","authors":[],"date":"1990","doi":null,"raw":"S. Hupfer: Melinda: Linda with Multiple Tuple Spaces. Tech. Rep. Technical Report YALEU\/DCS\/RR-766, Department of Computer Science, Yale University, New Haven, Connecticut, U.S., Feb. 1990.","cites":null},{"id":16518830,"title":"Places, Things: Web Presence for the Real World.","authors":[],"date":"2000","doi":null,"raw":"T. Kindberg, J. Barton et al.: People, Places, Things: Web Presence for the Real World. Proceedings of 3rd IEEE Workshop of Mobile Computing Systems and Applications (WMCSA 2000), pp. 19\u201330. IEEE Computer Society, Monterey, California, Dec. 2000.","cites":null},{"id":16518841,"title":"Solving the Linda multiple rd problem using the copy-collect primitive.","authors":[],"date":"1996","doi":null,"raw":"A. I. T. Rowstron and A. M. Wood: Solving the Linda multiple rd problem using the copy-collect primitive. P. Ciancarini and C. Hankin, eds., Proceedings of Coordination\u201996, Coordination Languages and Models, vol. 1061 of Lecture Notes in Computer Science, pp. 357\u2013367. Springer-Verlag, 1996.","cites":null},{"id":16518829,"title":"The Interactive Workspaces Project: Experiences with Ubiquitous Computing Rooms.","authors":[],"date":"2002","doi":null,"raw":"B. Johanson, A. Fox and T. Winograd: The Interactive Workspaces Project: Experiences with Ubiquitous Computing Rooms. IEEE Pervasive Computing Magazine, vol. 1(2), Apr. 2002.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2004-09","abstract":"The Stanford Event Heap has been shown to provide appropriate support for constructing interactive workspace applications. Given this success it is natural to consider the Event Heap as a platform to support other classes of Ubiquitous Computing applications. In this paper we argue that the distributed, spontaneous nature of these applications places additional demands on the Event Heap that require extensions to both the engineering and API. Suitable extensions are described and their use to support a typical Ubicomp application is discussed","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/91437.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/12700\/1\/distributed_event_heap.pdf","pdfHashValue":"45eba3e3e1ce2b1b35e656a9555f3e8f72cf1da1","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:12700<\/identifier><datestamp>\n      2017-09-21T01:54:32Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Supporting Ordering and Consistency in a Distributed Event Heap for Ubiquitous Computing<\/dc:title><dc:creator>\n        Storz, Oliver<\/dc:creator><dc:creator>\n        Friday, Adrian<\/dc:creator><dc:creator>\n        Davies, Nigel<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        The Stanford Event Heap has been shown to provide appropriate support for constructing interactive workspace applications. Given this success it is natural to consider the Event Heap as a platform to support other classes of Ubiquitous Computing applications. In this paper we argue that the distributed, spontaneous nature of these applications places additional demands on the Event Heap that require extensions to both the engineering and API. Suitable extensions are described and their use to support a typical Ubicomp application is discussed.<\/dc:description><dc:date>\n        2004-09<\/dc:date><dc:type>\n        Conference or Workshop Item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/eprints.lancs.ac.uk\/12700\/1\/distributed_event_heap.pdf<\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1007\/s00779-005-0039-2<\/dc:relation><dc:identifier>\n        Storz, Oliver and Friday, Adrian and Davies, Nigel (2004) Supporting Ordering and Consistency in a Distributed Event Heap for Ubiquitous Computing. In: Second Workshop on System Support for Ubiquitous Computing Workshop (Ubisys 2004), 2004-09-072004-09-10.<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/12700\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1007\/s00779-005-0039-2","http:\/\/eprints.lancs.ac.uk\/12700\/"],"year":2004,"topics":["QA75 Electronic computers. Computer science"],"subject":["Conference or Workshop Item","PeerReviewed"],"fullText":"Supporting Ordering and Consistency in a\nDistributed Event Heap for Ubiquitous\nComputing\nOliver Storz, Adrian Friday, and Nigel Davies\nComputing Department, Lancaster University, Lancaster, UK\n{oliver,adrian,nigel}@comp.lancs.ac.uk\nAbstract. The Stanford Event Heap has been shown to provide appro-\npriate support for constructing interactive workspace applications. Given\nthis success it is natural to consider the Event Heap as a platform to sup-\nport other classes of Ubiquitous Computing applications. In this paper\nwe argue that the distributed, spontaneous nature of these applications\nplaces additional demands on the Event Heap that require extensions\nto both the engineering and API. Suitable extensions are described and\ntheir use to support a typical Ubicomp application is discussed.\n1 Introduction\nRecent years have witnessed the emergence of Ubiquitous Computing as an im-\nportant and energetic research topic. As new classes of application have emerged,\nso the search for appropriate programming abstractions and associated middle-\nware to simplify the development and deployment of such applications has gained\npace. This process has yielded a number of prototype platforms including HP\u2019s\nCooltown [8], UIUC\u2019s Gaia [11], and many others.\nProbably the most successful platform to date (in terms of widespread adop-\ntion) is Stanford\u2019s Event Heap [7]. The Event Heap is based on the Tuple Space\nparadigm [4] in which data is passed between applications through the gene-\nration and consumption of tuples of data through a shared \u2018data space\u2019. The\nTuple Space paradigm provides decoupling in both time and space and hence\nis an attractive paradigm for use in environments that consist of collections of\nloosely coupled cooperating processes. The Event Heap is designed to support\nsmart room applications [6], and extends the Tuple Space paradigm in a number\nof important ways.\nGiven the success of the Event Heap API we believe it makes sense to consider\nthis as a starting point for more general Ubiquitous Computing and mobile com-\nputing applications. In this paper we suggest a series of further API extensions\nthat enable the Event Heap to move beyond its current target domain. These\nextensions include support for new semantics and disconnected operation, and\nborrow in part from the work of Davies et al. on creating Tuple Space platforms\nfor mobile environments [1].\nThis work was supported by EPSRC project Grid based Medical Devices for Everyday Health\n(GR\/R85877) and the European Union funded Simplicity project (IST-2004-507558).\n2 Tuple-Spaces, Mobile And Ubiquitous Computing\n2.1 The Tuple Space Paradigm\nThe Tuple Space paradigm was conceived by Gelernter et al. [4] as part of Linda.\nLinda augments a traditional computational language (such as C or Pascal) with\nnew operators for process creation and inter-process communication. The Linda\nmodel initially consisted of four such operators1 :-\n1. out inserts a tuple, composed of an arbitrary mix of typed fields, into the\ntuple space. Fields are termed \u2018actuals\u2019 if they contain a static value and\n\u2018formals\u2019 if they map onto program variables.\n2. in extracts a tuple from a tuple space, with its argument acting as the\ntemplate, or anti-tuple, against which to match. Actuals match fields of\nequal type and value; formals match fields of the same type. An anti-tuple\nmatches a tuple iff all corresponding fields match. When a match occurs the\ntuple is withdrawn and any actuals it contains are assigned to formals in the\ntemplate. Tuples are matched non-deterministically and in operations block\nindefinitely until a suitable tuple can be found.\n3. rd is syntactically and semantically equivalent to in except that a matched\ntuple is not withdrawn from the tuple space and hence remains visible to\nother processes.\nLinda was subsequently extended to support additional non-blocking opera-\ntors inp and rdp [9] and high performance bulk primitives [13].\n2.2 The Event Heap\nTargeting interactive workspaces, the Event Heap [7] introduced a number of\nextensions to both the API provided by conventional tuple spaces and the under-\nlying semantics of many of the operations. We briefly highlight the key aspects\nof this functionality here, please refer to Johanson\u2019s thesis [6] for a complete\ndescription.\nExtended Delivery Semantics Applications performing subsequent read op-\nerations will see events from a single source in the order that they are pro-\nduced by the source (per-source ordering). Moreover, due to the centralised\nnature of the current Event Heap implementation, events originating from\nmultiple sources are in fact delivered totally ordered2.\nPersistent Queries The platform supports non-destructive read operations\nthat persist over time, matching all known events that satisfy the constraints\nof the read template and all further matching events as they enter the Event\nHeap.\n1 We have omitted discussion of \u2018eval\u2019 for brevity as it is not important for under-\nstanding the contribution of this paper.\n2 Note that total ordering is the result of the current centralised implementation, not\na requirement of the Event Heap paradigm per se.\nEvent Notification Similar to the concept of persistent queries, applications\nmay register to be notified whenever new events matching a certain template\nenter the Event Heap.\nAdditionally, applications performing subsequent read operations are guar-\nanteed to see each event at most once, enabling applications to \u201citerate\u201d\nthrough events on a server by issuing subsequent read requests. In contrast,\nmultiple subsequent read requests issued with traditional tuple space plat-\nforms might return the same tuple over and over again, regardless of the\navailability of other matching tuples \u2014 the \u2018multiple RD problem\u2019 [12].\nIBM\u2019s T Spaces [14] was initially used to underpin the Event Heap. The\nEvent Heap was later re-engineered to remove this dependency.\n2.3 L2imbo\nL2imbo [2] is a fully decentralised distributed tuple space platform designed\nprincipally for mobile environments. Unlike approaches based on fully consistent\nreplicas [15] or mobile agents [10], replicas in L2imbo are kept consistent on-\ndemand using an IP multicast protocol based on Scalable Reliable Multicast\n[3].\nL2imbo included a number of important extensions to the standard tuple\nspace model, including the ability to associate types with tuples and extend types\nto support sub-type matching, support for multiple (possibly specialised) tuple\nspaces, and an extended range of matching primitives (including Rowstron\u2019s\nBONITA high performance bulk primitives [13] and a basic eventing API).\n3 Discussion\nWhile the Event Heap API has proved to be well suited to application develop-\nment, we believe that it lacks important facilities for constructing many types\nof Ubiquitous Computing application, as illustrated by the following scenario:\nAlice, Bob, Joe and Sue are researchers at the University of X. While\nhaving lunch at a cafe\u00b4, Alice articulates some new ideas regarding project\nY. The group decides to use their mobile devices to further explore these\nideas using a shared whiteboard application. Each member of the group\nuses his\/her own display and stylus to contribute to the discussion. The\nindividual devices are connected using a wireless ad-hoc network. After\nlunch, Alice and Joe decide to move to their office and finalise the design.\nIn their office, they resume the discussion from where they left off.\nSpontaneous Interaction and Mobility\nThe Event Heap system is based on a single server instance running within each\nUbiquitous Computing\u201cinteractive work space\u201d. However, this mode of operation\nis clearly not suitable in our scenario since the devices involved are operating in\na peer-to-peer ad-hoc mode.\nIt becomes clear that if we wish to use the Event Heap to support more\ngeneral mobile and ubiquitous computing applications where users and\/or de-\nvices spontaneously interact there is a need to offer a more highly available and\nscalable solution (namely, distributed, replicated or federated local instances). If\nindividual mobile nodes are able thus able to implement their own local Event\nHeap (or appropriate proportion thereof), then applications can operate when\nthe node is disconnected from the network. Furthermore, if local Event Heaps\ncan be synchronised with other mobile nodes then distributed applications can\noperate without the need for additional infrastructure.\nConsistent Behaviour \u2018within the Real World\u2019\nA move to a distributed Event Heap means that we no longer have a centralised\npoint of synchronisation (i.e. a single Event Heap instance) and hence we must\ntake care to respect event delivery and ordering semantics. For example, the\nchanges observable on users\u2019 displays must remain consistent with the order\nof their actions (instructions through the system) \u2014 the users\u2019 knowledge of\nthe behaviour of the system, exposed through their visual senses, places a total\nordering constraint on many of the underlying events (as events trigger actions\nand these actions are visible in the real world). This contrasts with Johanson\u2019s\nclaim that source ordering is sufficient for most classes of ubiquitous computing\napplication [7].\nWe observe that since the Event Heap offers per-source ordering, and the\nEvent Heap is currently implemented in a centralised fashion, then events are\nactually totally ordered, since the platform instance provides a single point of\nreference. However, it is clear that future Ubiquitous Computing applications will\nhave varying requirements for consistency and ordering of the events representing\nthe applications\u2019 state.\n4 Proposed Extensions\nIn order to address the two requirements raised in section 3 (i.e. distributed oper-\nation and support for ordering and consistency semantics) we have extended the\nEvent Heap API to enable dynamic creation, destruction and interaction with\nmultiple distributed Event Heaps (including support for propagating events be-\ntween Event Heaps) and to provide more sophisticated support for event ordering\nand delivery semantics.\n4.1 Support for Multiple Event Heaps\nIn the general case we do not assume a single Event Heap that is accessible by\nall clients. We allow multiple Event Heaps and provide an API for their creation\nand destruction. These operations are designed to be sufficiently lightweight as\nto encourage programmers to create new Event Heaps on the fly. As in L2imbo,\nwe provide a class of system agents, called a factory, that can create new Event\nHeaps configured to meet application specific requirements [5]. For example, in\nfuture versions of our platform we plan to allow the creation of Event Heaps\nwith support for security (user authentication), persistence and event logging\n(e.g. for accountability in safety critical systems).\nWe allow logical Event Heaps to be distributed across multiple physical hosts.\nDistributing Event Heaps makes our platform more highly available and improves\nfault tolerance, e.g. in the case of failing hosts, and mobility.\nWe also use the concept of L2imbo bridging agents to provide the means for\nlinking arbitrary Event Heaps and controlling the propagation of events between\nthem. In their simplest form, bridging agents are processes that subscribe for all\nevents in one Event Heap and generate duplicate events in the context of a\nsecond Event Heap. Bridging agents can also provide more fine grained bridging\nbased on event type and field matching3.\n4.2 Ordering and Delivery Semantics\nWe introduce two new concepts into the Event Heap API. The first is that\nof a view. Processes that share a view are guaranteed to have a consistent,\nordered view of the Event Heap with the precise semantics being configurable\non a per-view basis. Each view can be configured to provide no ordering of\nevents, per-source ordering or total ordering. In the unordered case, the view\nsimply ensures that all clients using the view will see the same (consistent) set\nof events without any guarantee of their relative ordering. Per-source ordering\noffers the same semantics as Johanson suggests for the Event Heap [7]. A totally\nordered view guarantees that all operations performed within the context of the\nview will observe events in the order they were produced by the event source\nand, critically, in the same relative order across all sources. Thus two applications\nsubscribing to events of a particular type would receive the events in exactly the\nsame order, even if the events are produced by multiple sources. This provides\ntotal ordering as it is offered by the current centralised Event Heap.\nThe second concept we introduce is that of session identifiers. Session identi-\nfiers are used to provide at-most-once semantics for event matching (the default\nbehaviour in the Event Heap). In the Stanford Event Heap this means that\nevents are never returned to the same application twice, even when they match\ndifferent templates: this may give rise to problems when applications wish to\nre-read events from the Event Heap that they have already seen.\nWe guarantee at-most-once semantics for non-destructive operations on a\nper-session identifier basis. Session identifiers can be thought of as containing a\nrecord of events that have already been seen within the context of a given session\nand hence are not to be retrieved a second time as a result of an application\n3 Note that bridging agents provide a mechanism for propagation of events between\nEvent Heaps and are not required for the propagation of events between separate\ndistributed instances of a single Event Heap.\nrequest. Session identifiers can be created with either an empty record or with\na record of events inherited from an existing session identifier. This provides an\neasy way for applications to clone session identifiers (e.g. for distributing these to\nother application instances). Clients are at liberty to discard sessions or maintain\nmultiple sessions to best suit their needs. Processes can share session identifiers\nacross hosts, enabling, for example, distributed applications to share the load of\nprocessing an event stream.\n5 Implementation And Evaluation\n5.1 Implementation\nViews and session identifiers are created in a similar fashion to new instances of\nan Event Heap, i.e. using appropriate factories: applications output an appropri-\nate creation request event into their Event Heap which is serviced by a factory on\ntheir local node. In the case of view creation these requests can be parameterised\nto specify the semantics that the view should provide, i.e. unordered, source or\ntotal ordering.\nOur implementation is based on the protocol used in L2imbo [1] to support\ndistributed tuple spaces. We have extended this protocol to support views and\nsession identifiers. L2imbo utilises application level framing concepts based on\nScalable Reliable Multicast [3] to promote scalability and avoid the need for\nfixed group membership. One of the key challenges in our platform is how to\nglobally identify events and record their relative ordering when mapping them\ninto a given session or view. We have rejected strategies based on global sequence\nnumbers, vector clocks or atomic agreement, as these all require high (e.g. quo-\nrate) simultanous availability of all end-systems, which is not appropriate for\nour chosen application domain.\nIn our prototype, session identifiers and views are represented by distributed\nstate that is kept consistent through the exchange of \u2018system events\u2019. Each system\nevent represents a token or \u2018lock\u2019 on a given session or view. Before the platform\ncan map an event matching a template into a given session it must first obtain\nthis lock. The lock exchange process triggers on-demand generation of a system\nevent representing the session, causing the replicas of the session involved to\nsynchronise. Note that any peer can snoop the current state of the session during\nthis exchange.\nLike session identifiers, views are based on single transferrable ownership of\na shared token (system event) representing the current state of the view. Upon\nview creation all existing events in the Event Heap that are visible to the view\ncreator are accessible via the view and according to the ordering requirements\nspecified at creation time. Each platform instance maps any events that it snoops\nfrom the multicast channel into all views that it owns. A view must be owned\n(the system event for the view consumed) before operations that affect the view\ncan take place (e.g. creation of new events). Any replica may cache the state of\nthe view and perform matching operations without owning the view, providing\nthat the consistency and ordering guarantees are not violated (i.e. all earlier\nsequenced events in the view have been observed or are known to have been\npreviously consumed).\n5.2 Evaluation\nFor illustrating the qualities of our platform, we will further elaborate on the dis-\ntributed whiteboard example outlined in section 3. As we will show, our platform\nnot only supports ad-hoc interactions between entities in mobile and ubiquitous\ncomputing environments: the provision of extended, flexible delivery semantics\nalso significantly simplifies the development of distributed applications.\nDuring Alice\u2019s, Bob\u2019s, Joe\u2019s and Sue\u2019s lunchtime session, each device hosts an\ninstance of the platform. These four instances form a single Distributed Event\nHeap. All participating whiteboard applications share a common view-identifier,\nspecifying total ordering as target delivery semantics. The common view en-\nsures that all applications receive all drawing events in exactly the same order,\nproviding application behaviour consistent with the users\u2019 view of the physical\nworld.\nAs the group splits and Alice and Joe resume the design meeting on their own,\nthey are both able to restore the state of their local whiteboard applications by\nre-reading the set of events stored in their local instances of the Distributed Event\nHeap. Using the same view-specifier as before, Alice\u2019s and Joe\u2019s whiteboard\napplications are able to obtain a complete replay of all drawing events.\nAs Alice and Joe continue their work, new events have to be mapped into\nthe shared view. Complications occur if neither Alice nor Joe owned the view\nduring the lunchtime meeting. In this case, the view will be cloned, i.e. a new\nview will be created offering the the same semantics as the old view. The new\nview is initialised with a complete record of the ordering information associated\nwith the old view. If either Alice or Joe \u201cowned\u201d the view during the lunch-time\nsession, they can simply continue to use that view. In either case appropriate\nfeedback needs to be provided to the users.\n6 Conclusion and Future Work\nIn this paper we have described how a popular distributed systems paradigm\nbased on the Event Heap can be extended to support distributed operation and\nselectable ordering and consistency guarantees through the concepts of shared\nviews and session identifiers.\nUsing an existing API such as that of the Event Heap is an important aspect\nof our work, since moving towards a common programming model is crucial to the\nwidespread growth of middleware support for Ubiquitous Computing. The paper\nreports on the development of a prototype distributed systems platform that\nimplements shared views and session identifiers without breaking the principal\nbenefits of time and space decoupling offered by the tuple-space paradigm.\nReferences\n1. N. Davies, A. Friday, S. Wade and G. Blair: L2imbo: A Distributed Sys-\ntems Platform for Mobile Computing . ACM Mobile Networks and Applications\n(MONET), Special Issue on Protocols and Software Paradigms of Mobile Net-\nworks, vol. 3(2): pp. 143\u2013156, 1998.\n2. N. Davies, S. Wade, A. Friday and G. Blair: Limbo: A Tuple Space Based\nPlatform for Adaptive Mobile Applications. Joint International Conference on Open\nDistributed Processing and Distributed Platforms (ICODP\/ICDP \u201997). Chapman\nand Hall, Toronto, Canada, 1997.\n3. S. Floyd, V. Jacobson et al.: A reliable multicast framework for light-weight\nsessions and application level framing . Proceedings of the conference on Applica-\ntions, technologies, architectures, and protocols for computer communication, pp.\n342\u2013356. ACM Press, 1995. ISBN 0-89791-711-1.\n4. D. Gelernter: Generative communication in Linda. ACM Transactions on Pro-\ngramming Languages and Systems, vol. 7(1): pp. 80\u2013112, 1985. ISSN 0164-0925.\n5. S. Hupfer: Melinda: Linda with Multiple Tuple Spaces. Tech. Rep. Technical\nReport YALEU\/DCS\/RR-766, Department of Computer Science, Yale University,\nNew Haven, Connecticut, U.S., Feb. 1990.\n6. B. Johanson: Application Coordination Infrastructure for Ubiquitous Computing\nRooms. Ph.D. thesis, Stanford University, Dec. 2003.\n7. B. Johanson, A. Fox and T. Winograd: The Interactive Workspaces Project:\nExperiences with Ubiquitous Computing Rooms. IEEE Pervasive Computing Mag-\nazine, vol. 1(2), Apr. 2002.\n8. T. Kindberg, J. Barton et al.: People, Places, Things: Web Presence for the\nReal World . Proceedings of 3rd IEEE Workshop of Mobile Computing Systems\nand Applications (WMCSA 2000), pp. 19\u201330. IEEE Computer Society, Monterey,\nCalifornia, Dec. 2000.\n9. J. S. Leichter: Shared Tuple Memories, Shared Memories, Buses and LAN\u2019s \u2013\nLinda Implementations across the Spectrum of Connectivity. Ph.D. thesis, Depart-\nment of Computer Science, Yale University, New Haven, Connecticut, U.S., Jul.\n1989.\n10. G. P. Picco, A. L. Murphy and G.-C. Roman: LIME: Linda meets mobility .\nProceedings of the 21st international conference on Software engineering, pp. 368\u2013\n377. IEEE Computer Society Press, 1999. ISBN 1-58113-074-0.\n11. M. Roma\u00b4n, C. Hess et al.: A Middleware Infrastructure for Active Spaces. IEEE\nPervasive Computing, vol. 1(4): pp. 74\u201383.\n12. A. I. T. Rowstron and A. M. Wood: Solving the Linda multiple rd problem using\nthe copy-collect primitive. P. Ciancarini and C. Hankin, eds., Proceedings of\nCoordination\u201996, Coordination Languages and Models, vol. 1061 of Lecture Notes\nin Computer Science, pp. 357\u2013367. Springer-Verlag, 1996.\n13. A. I. T. Rowstron and A. M. Wood: Bonita: A set of tuple space primitives for\ndistributed coordination. Proceedings of the 30th Hawaii International Conference\non System Sciences, p. 379. IEEE Computer Society, 1997. ISBN 0-8186-7743-0.\n14. P. Wyckoff, S. W. McLaughry, T. J. Lehman and D. A. Ford: T Spaces.\nIBM Systems Journal, vol. 37(3): pp. 454\u2013474, 1998.\n15. A. Xu and B. Liskov: A design for a fault-tolerant, distributed implementation of\nLinda. Nineteenth International Symposium on Fault-Tolerant Computing (FTCS-\n19), pp. 199\u2013206. Jun. 1989.\n"}