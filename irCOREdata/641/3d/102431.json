{"doi":"10.1007\/b96106","coreId":"102431","oai":"oai:epubs.surrey.ac.uk:1890","identifiers":["oai:epubs.surrey.ac.uk:1890","10.1007\/b96106"],"title":"Verifying controlled components","authors":["Schneider, Steve A.","Treharne, Helen"],"enrichments":{"references":[],"documentType":{"type":0.6666666667}},"contributors":[],"datePublished":"2004-03-05","abstract":"<p>Recent work on combining CSP and B has provided ways of describing systems comprised of components described in both B (to express requirements on state) and CSP (to express interactive and controller behaviour). This approach is driven by the desire to exploit existing tool support for both CSP and B, and by the need for compositional proof techniques. This paper is concerned with the theory underpinning the approach, and proves a number of results for the development and verification of systems described using a combination of CSP and B. In particular, new results are obtained for the use of the hiding operator, which is essential for abstraction. The paper provides theorems which enable results obtained (possibly with tools) on the CSP part of the description to be lifted to the combination. Also, a better understanding of the interaction between CSP controllers and B machines in terms of <i>non-discriminating<\/i> and <i>open<\/i> behaviour on channels is introduced, and applied to the deadlock-freedom theorem. The results are illustrated with a toy lift controller running example.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1890<\/identifier><datestamp>\n      2017-10-31T14:03:32Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1890\/<\/dc:relation><dc:title>\n        Verifying controlled components<\/dc:title><dc:creator>\n        Schneider, Steve A.<\/dc:creator><dc:creator>\n        Treharne, Helen<\/dc:creator><dc:description>\n        <p>Recent work on combining CSP and B has provided ways of describing systems comprised of components described in both B (to express requirements on state) and CSP (to express interactive and controller behaviour). This approach is driven by the desire to exploit existing tool support for both CSP and B, and by the need for compositional proof techniques. This paper is concerned with the theory underpinning the approach, and proves a number of results for the development and verification of systems described using a combination of CSP and B. In particular, new results are obtained for the use of the hiding operator, which is essential for abstraction. The paper provides theorems which enable results obtained (possibly with tools) on the CSP part of the description to be lifted to the combination. Also, a better understanding of the interaction between CSP controllers and B machines in terms of <i>non-discriminating<\/i> and <i>open<\/i> behaviour on channels is introduced, and applied to the deadlock-freedom theorem. The results are illustrated with a toy lift controller running example.<\/p><\/dc:description><dc:date>\n        2004-03-05<\/dc:date><dc:type>\n        Conference or Workshop Item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1890\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Schneider, Steve A. and Treharne, Helen  (2004) Verifying controlled components       <\/dc:identifier><dc:relation>\n        10.1007\/b96106<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1890\/","10.1007\/b96106"],"year":2004,"topics":[],"subject":["Conference or Workshop Item","PeerReviewed"],"fullText":"Verifying Controlled Components\nSteve Schneider and Helen Treharne\nDepartment of Computer Science\u0000 Royal Holloway\u0000 University of London\nAbstract\u0000 Recent work on combining CSP and B has provided ways\nof describing systems comprised of components described in both B \u0001to\nexpress requirements on state\u0002 and CSP \u0001to express interactive and con\u0003\ntroller behaviour\u0002\u0004 This approach is driven by the desire to exploit exist\u0003\ning tool support for both CSP and B\u0000 and by the need for compositional\nproof techniques\u0004 This paper is concerned with the theory underpinning\nthe approach\u0000 and proves a number of results for the development and\nveri\u0005cation of systems described using a combination of CSP and B\u0004 In\nparticular\u0000 new results are obtained for the use of the hiding operator\u0000\nwhich is essential for abstraction\u0004 The paper provides theorems which\nenable results obtained \u0001possibly with tools\u0002 on the CSP part of the de\u0003\nscription to be lifted to the combination\u0004 Also\u0000 a better understanding\nof the interaction between CSP controllers and B machines in terms of\nnon\u0000discriminating and open behaviour on channels is introduced\u0000 and\napplied to the deadlock\u0003freedom theorem\u0004 The results are illustrated with\na toy lift controller running example\u0004\n\u0000 Introduction\nMorgan\u0000s failures\u0001divergences semantics for event systems \u0002Mor\u0003\u0004\u0005 enables the\nvarious CSP semantics to be given to B machines\u0006 These CSP semantics allow\nmachines to be treated as CSP components within a concurrent system\u0007 and\nwe can combine them with other CSP components using architectural operators\nsuch as parallel composition and abstraction\u0006\nRecent work \u0002Tre\u0004\u0004\u0005 has considered the interaction between a particular kind\nof B machine and a controller written as a \brecursive\t sequential CSP process\u0006\nAn important property of a controller for a machine is that it should invoke ma\n\nchine operations only within their preconditions\u0006 Previous results \u0002Tre\u0004\u0004\u0005 have\nidenti\u000bed conditions su\fcient to guarantee P k M to be divergence\nfree for a\ncontroller P and machine M \u0007 which ensures this important property\u0006 These re\n\nsults require identi\u000bcation of a control loop invariant \bCLI\t on the state of the\nB machineM \u0007 which must be true on every recursive call\u0006 This is established by\nconsidering the semantics of the B operations as they are called within the con\n\ntroller\u0007 and essentially computing the weakest precondition required to establish\nthe CLI\u0006\nIn combining communicating B machines\u0007 we use a particular architecture\n\u0002ST\u0004\rb\u0005 to restrict the interaction between components\u0007 by ensuring that each\nB machine interacts only with its own controller\u0006 A system will be structured as\nCSP\nB\nP\n\u0000\nP\n\u0001\nM\n\u0000\nM\n\u0001 \u0000 \u0000 \u0000\n\u0000 \u0000 \u0000\nFig\u0000 \u0001\u0000 A CSP and B combined system architecture\na collection of B machines M\n\u0000\n\u0000 \u0001\u0001\u0001\u0000M\nn\n\u0007 each with its own CSP controller process\nP\n\u0000\n\u0000 \u0001\u0001\u0001\u0000P\nn\n\u0006 A controlled component is the parallel combination of a controller and\nits B machine\u0007 of the form P kM \u0006\nEach M\ni\nis under the control of the corresponding P\ni\n\u0007 and the P\ni\n\u0000s can also\ninteract with each other\u0006 This architecture is illustrated in Figure \u000e\u0006 Interaction\nacross the system can occur only between the CSP processes\u0006 This approach\nenables compositional veri\u000bcation\u0007 whereby we are able to verify properties of the\nentire system by obtaining results about smaller structures within the system\u0006\nIn particular\u0007 both CSP and B already have mature tool support\u0007 which we aim\nto apply in the veri\u000bcation of combined systems\u0006\nThe model\nchecker FDR \u0002For\u0003\u000f\u0005 performs model\nchecking on systems de\n\nscribed in CSP\u0007 and is therefore suitable for analysing the controllers\u0007 individ\n\nually and in combination\u0006 The paper provides theorems which enable results\nobtained \bpossibly with tools\t on the CSP part of the description to be lifted to\nthe combination\n\u0000\n\u0006 We obtain a number of theorems in the various CSP semantic\nmodels\u0006\nIn practice\u0007 we \u000bnd that it is often the case that a property holds in a com\n\nbined system for reasons associated with the state within the B components\u0006 In\nthis case\u0007 the CSP controller descriptions need to be augmented with the rel\n\nevant state information\u0006 This paper also provides theorems which support the\nrequired manipulations of CSP controllers\u0006 A fuller version of this paper \u0002ST\u0004\ra\u0005\ngives rigorous proofs of all the theorems and lemmas\u0006 In this paper\u0007 we provide\ninformal explanations of the theorems\u0006\n\u0001 Background\n\u0000\u0001\u0002 CSP Events\nCSP processes are de\u000bned in terms of the events that they can and cannot do\u0006\nProcesses interact by synchronising on events\u0007 and the occurrence of events is\natomic\u0006 The set of all events is denoted by \u0002\u0006\n\u0000\nThe FDR checks discussed in this paper are available at\nhttp\u0000\u0001\u0001www\u0002cs\u0002rhul\u0002ac\u0002uk\u0001research\u0001formal\u0001steve\u0001code\u0001lifts\u0002fdr\u0003\nEvents may be compound in structure\u0007 consisting of a channel name and\nsome \bpossibly none\t data values\u0006 Thus\u0007 events have the form c\u0001v\n\u0000\n\u0001\u0001\u0001v\nn\n\u0007 where c\nis the channel name associated with the event\u0007 and the v\ni\nare data values\u0006 The\ntype of the channel c is the set of values that can be associated with c to produce\nevents\u0006\nFor example\u0007 if trans is a channel name\u0007 and N\u0000Zis its type\u0007 then events\nassociated with trans will be of the form trans\u0001n\u0001z \u0007 where n \u0001 N and z \u0001Z\u0006 For\nexample\u0007 trans\u0001\u0010\u0001\u0011 is one such event\u0006\nA partial event\u0007 or \bfollowing \u0002Sca\u0003\u0011\u0005\t partially completed datatype value is a\nchannel name together with some values\u0007 but not necessarily all\u0006 For example\u0007\ntrans\u0001\u0010 is a partial event\u0006 Any channel is a special case of a partial event\u0006\nGiven a set of partial events PE \u0007 we can de\u000bne the set of events fj PE jg\nwhich are the completions of events in PE \u0007 as follows\u0012\nfj PE jg \u0013 fp\u0001w j p \u0001 PE \u0002 p\u0001w \u0001 \u0002g\nWe use alphabetised CSP\u0007 so every process has an alphabet\u0007 which is the set of\nevents whose occurrence requires its participation\u0006 The alphabet of a process P\nis denoted \u0003\bP\t\u0006 For the purposes of this paper we will require that the alphabet\nof any process is given by a set of channels C \u0007 so that \u0003\bP\t \u0013 fj C jg\u0006\n\u0000\u0001\u0000 CSP controllers\nA controller for a B machine is a particular kind of CSP process\u0006 To interact\nwith the B machine\u0007 it makes use of control channels which have both input and\noutput\u0007 and provide the means for controllers to synchronise with B machines\u0006\nFor each operation w \u0003\u0004 e\bv\t of a controlled machine with v of type T\nin\n\be\t\nand w of type T\nout\n\be\t there will be a channel e of type T\nin\n\be\t \u0000 T\nout\n\be\t\u0007 so\ncommunications on e are of the form e\u0001v \u0001w \u0006\nController descriptions may also include assertions about the values of vari\n\nables they are using\u0006 These are incorporated in CSP either as blocking assertions\n\bwhich block if the assertion is false\t or as diverging assertions \bwhich diverge if\nthe assertion is false\t\u0007 depending on the role they play in veri\u000bcation\u0006\nWhen we talk about a CSP controller P we mean a process which has a given\nset of control channels C \u0006 The controlled B machine will have exactly fj C jg as\nits alphabet\u0012 it can communicate only on channels in C \u0006\nController syntax Controllers are generated from the following subset of the\nCSP syntax\u0007 as discussed in \u0002ST\u0004\rb\u0005\u0006\nP \u0012\u0012\u0013 a \u0005 P jc\u0014x \u0005 P jd \u0015v \u0005 P je\u0015v\u0014xfE \bx \tg \u0005 P je\u0015v\u0014x hE \bx \ti \u0005 P j\nP\n\u0000\n\u0000 P\n\u0001\njP\n\u0000\nu P\n\u0001\nj\nu\nx jE\u0002x \u0003\nP j if b then P\n\u0000\nelse P\n\u0001\njS \bp\t\nwhere a and is a synchronisation event\u0007 c is a communication channel accepting\ninputs\u0007 d is a communication channel sending output values\u0007 e is a control chan\u0000\nnel\u0007 x represents all data variables on a channel\u0007 v represents all data values\nbeing passed along a channel\u0007 E \bx \t is a predicate on x \bit may be elided\u0007 in\nwhich case it is considered to be true\t\u0007 b is a boolean expression\u0007 and S \bp\t is a\nprocess expression\u0006\nThe process a \u0005 P is initially prepared to engage in an a event\u0007 after which\nit behaves as P \u0006 The input c\u0014x \u0005 P is prepared to accept any value x along\nchannel c\u0007 and then behave as P \bwhose behaviour can be dependent on x \t\u0006 The\noutput d \u0015v \u0005 P provides v as output\u0006 The operation call e\u0015v\u0014xfE \bx \tg \u0005 P\nis an interaction with an underlying B machine\u0012 the value v is passed from the\nprocess as input to the B operation\u0007 and the value x is accepted as output from\nthe B operation\u0006 If x meets the condition E \bx \t then the process behaves as P \u0006\nIf x does not meet the condition then the process diverges\u0006 On the other hand\u0007\ne\u0015v\u0014x hE \bx \ti \u0005 P only allows e\u0001v \u0001x if E \bx \t\u0007 otherwise the event is blocked\u0006\nBehaviour subsequent to e\u0001v \u0001x is that of P \u0006\nThe external choice process P\n\u0000\n\u0000 P\n\u0001\nis initially prepared to behave either\nas P\n\u0000\nor as P\n\u0001\n\u0007 and the choice is resolved on occurrence of the \u000brst event\u0006\nBinary and general internal choice are possible\u0007 though not used in the example\npresented here\u0006 The conditional choice if b then P\n\u0000\nelse P\n\u0001\nbehaves as P\n\u0000\nor P\n\u0001\ndepending on the evaluation of the condition b\u0006 Finally\u0007 the process expression\nS \bp\t expresses a recursive call\u0006\n\u0000\u0001\u0003 CSP semantic models\nThere are three semantic models used in this paper\u0012 the Tracesmodel\u0007 the Stable\nFailures model\u0007 and the Failures\u0001Divergences model\u0006 We introduce the relevant\nfeatures of them here\u0006 Full details of these models can be found in \u0002Ros\u0003\u000f\u0007Sch\u0003\u0003\u0005\u0006\nTraces A trace is a \u000bnite sequence of events\u0006 A sequence tr is a trace of a\nprocess P if there is some execution of P in which exactly that sequence of\nevents is performed\u0006 The set traces\bP\t is the set of all possible traces of process\nP \u0006 The traces model for CSP associates a set of traces with every CSP process\u0006\nIf traces\bP\t \u0013 traces\bQ\t then P and Q are equivalent in the traces model\u0007 and\nwe write P \u0013\nT\nQ \u0006\nStable Failures A stable failure is a pair \btr \u0000X \t consisting of a trace tr and a\nset of events X \u0006 Such a pair is a stable failure of a process P if there is some\nexecution of P on which tr is the sequence of events performed\u0007 reaching a state\nin which all events in X can be refused\u0007 and also no internal progress is possible\u0006\nThe set SF \u0002\u0002P \u0005\u0005 is the set of stable failures of P \u0006 The stable failures model\nfor CSP associates a set of stable failures\u0007 and a set of traces\u0007 with every CSP\nprocess\u0006 If SF \u0002\u0002P \u0005\u0005 \u0013 SF \u0002\u0002Q \u0005\u0005 and also traces\bP\t \u0013 traces\bQ\t then P and Q are\nequivalent in the stable failures model and we write P \u0013\nSF\nQ \u0006\nFailures and Divergences A divergence is a \u000bnite sequence of events tr \u0006 Such\na sequence is a divergence of a process P if it is possible for P to perform an\nin\u000bnite sequence of internal events \bsuch as a livelock loop\t on some pre\u000bx of tr \u0006\nThe set of divergences of a process P is written D \u0002\u0002P \u0005\u0005\u0006\nA failure is a pair \btr \u0000X \t consisting of a trace tr and a set of events X \u0006 It is\na failure of a process P if either tr is a divergence of P \bin which case X can be\nany set\t\u0007 or \btr \u0000X \t is a stable failure of P \u0006 The set of all possible failures of a\nprocess P is written F \u0002\u0002P \u0005\u0005\u0006 If D \u0002\u0002P \u0005\u0005 \u0013 D \u0002\u0002Q \u0005\u0005 and F \u0002\u0002P \u0005\u0005 \u0013 F \u0002\u0002Q \u0005\u0005 then P and\nQ are equivalent in the failures\u0001divergences model\u0007 written P \u0013\nFD\nQ \u0006\nThe di\u0016erent models are used to analyse CSP systems with respect to dif\n\nferent properties\u0006 This paper is concerned with the failures\ndivergences model\nis used to check for liveness properties such as divergence\nfreedom\u0006 If a system\ndescription includes the possibility of divergence \bfor example\u0007 if it includes in\n\nternal events\t\u0007 then it is necessary to use the failures divergences model to check\nfor divergence\nfreedom\u0006\nAn important relationship between the stable failures model and the failures\ndivergences model is that if a process is divergence\nfree \bi\u0006e\u0006 its set of divergences\nis empty\t\u0007 then its failures are the same as its stable failures\u0006 This is captured\nin the following theorem\u0012\nTheorem \u0002\u0001 If D \u0002\u0002P \u0005\u0005 \u0013 fg\u0002 then F \u0002\u0002P \u0005\u0005 \u0013 SF \u0002\u0002P \u0005\u0005\u0003\nThis theorem is useful because it allows us to carry out analysis in the stable\nfailures model\u0007 which is more e\fcient\u0007 and to establish results which remain valid\nin the failures divergences model\u0006 For example\u0007 if a process P is divergence\nfree\u0007\nthen to check that it is deadlock\nfree \bi\u0006e\u0006 that \btr \u0000 \u0003\bP\t\t cannot be a failure\nof P for any tr\t\u0007 it is su\fcient to check this in the stable failures model \bthat\n\btr \u0000 \u0003\bP\t\t cannot be a stable failure\t\u0006 The model\nchecker FDR \u0002For\u0003\u000f\u0005 can carry\nout divergence\nfreedom and deadlock\nfreedom checks mechanically\u0006\n\u0000\u0001\u0004 CSP semantics for B machines\nMorgan\u0000s CSP\nstyle semantics \u0002Mor\u0003\u0004\u0005 for event systems enables us to de\u000bne\nsuch semantics for B machines\u0006 A machine M thus has a set of traces T \u0002\u0002M \u0005\u0005\u0007 a\nset of failures F \u0002\u0002M \u0005\u0005\u0007 and a set of divergences D \u0002\u0002M \u0005\u0005\u0006 A sequence of operations\nhe\n\u0000\n\u0000 e\n\u0001\n\u0001 \u0001 \u0001 e\nn\ni is a trace of M if it can possibly occur\u0006 This is true precisely when\nit is not guaranteed to be blocked\u0007 or in other words it is not guaranteed to\nachieve false\u0006 In wp notation we write \u0006wp\be\n\u0000\n\u0017 e\n\u0001\n\u0017 \u0001 \u0001 \u0001 \u0017 e\nn\n\u0000 false\t\u0007 or in Abstract\nMachine Notation \u0006\b\u0002e\n\u0000\n\u0017 e\r\u0017 \u0001 \u0001 \u0001 \u0017 e\nn\n\u0005false\t\u0006 \bThe empty trace is treated as skip\t\u0006\nA sequence does not diverge if it is guaranteed to terminate \bi\u0006e\u0006 establish true\t\u0006\nThus\u0007 a sequence is a divergence if it is not guaranteed to establish true\u0007 i\u0006e\u0006\n\u0006\b\u0002e\n\u0000\n\u0017 e\r\u0017 \u0001 \u0001 \u0001 \u0017 e\nn\n\u0005true\t\u0006 Finally\u0007 given a set of events X \u0007 each event e \u0001 X\nis associated with a guard g\ne\n\u0006 A sequence with a set of events is a failure of\nM if the sequence is not guaranteed to establish the disjunction of the guards\u0006\nThus\u0007 \be\n\u0000\n\u0017 e\r\u0017 \u0001 \u0001 \u0001 \u0017 e\nn\n\u0000X \t is a failure ofM if \u0006\u0002e\n\u0000\n\u0017 e\r\u0017 \u0001 \u0001 \u0001 \u0017 e\nn\n\u0005\b\nW\ne\u0000X\ng\ne\n\t\u0006 More\ndetails of the semantics of B machines can be found in \u0002Tre\u0004\u0004\u0005\nMorgan does not give a stable failures semantics for action systems\u0006 We\nwill de\u000bne the stable failures SF \u0002\u0002M \u0005\u0005 for a machine M in terms of its failures\ndivergences semantics\u0007 as follows\u0012\nDe\u0005nition \u0002\u0001 The stable failures of a B machine are de\u0004ned as follows\u0005\nSF \u0002\u0002M \u0005\u0005 \u0013 f\btr \u0000X \t j \btr \u0000X \t \u0001 F \u0002\u0002M \u0005\u0005 \u0002 tr \u0007\u0001 D \u0002\u0002M \u0005\u0005g\nMACHINE i\u0004Lift\nVARIABLES i\u0004floor\nINVARIANT i\u0004floor \u0000 NAT\nINITIALISATION i\u0004floor \u0000\u0005 \u0006\nOPERATIONS\ni\u0004inc\u0007nn\b \u0005\nPRE nn \u0000 NAT\t\nTHEN i\u0004floor \u0000\u0005 i\u0004floor \n nn\nEND\u000b\ni\u0004dec \u0005\nPRE i\u0004floor \f \u0006\nTHEN i\u0004floor \u0000\u0005 i\u0004floor \r \t\nEND\u000b\nbb \u000e\r\r i\u0004isZero \u0005\nIF i\u0004floor \u0005 \u0006\nTHEN bb \u0000\u0005 TRUE\nELSE bb \u0000\u0005 FALSE\nEND\nEND\ni LiftCtrl \u0006\ni up\u0007y \u0000 i inc\by \u0000 i LiftCtrl\n\u0000 i down\u0007y \u0000 i DOWN \u0001y\u0002\n\u0000 i ground \u0000 i LOWER\ni DOWN \u0001n\u0002 \u0006\nif n \u0006 \t\nthen i LiftCtrl\nelse i isZero\u0007bb\u0000\nif \u0001bb \u0006 TRUE\u0002\nthen i LiftCtrl\nelse i dec\u0000 i DOWN \u0001n \u0001 \n\u0002\ni LOWER \u0006\ni isZero\u0007bb\u0000\nif \u0001bb \u0006 TRUE\u0002\nthen i LiftCtrl\nelse i dec\u0000 i LOWER\nFig\u0000 \u0002\u0000 A Lift machine i Lift and its controller i LiftCtrl\nObserve that with this de\u000bnition\u0007 Theorem \u000e also holds for B machines M \u0006\nWe have a technique \u0002Tre\u0004\u0004\u0007ST\u0004\rb\u0005\u0007 based on control loop invariants\u0007 for es\n\ntablishing that a combination P k M is divergence\nfree\u0006 In other words\u0007 previous\nresults provide a means to establish that D \u0002\u0002P kM \u0005\u0005 \u0013 fg\u0006 This paper is not con\n\ncerned with that technique\u0006 Rather we are concerned with composing together a\nnumber of P\ni\nkM\ni\npairs once we have established that D \u0002\u0002P\ni\nk M\ni\n\u0005\u0005 \u0013 fg for each\npair\u0006 Hence a number of the theorems in this paper will include an assumption\nthat D \u0002\u0002P\ni\nk M\ni\n\u0005\u0005 \u0013 fg\u0006 The assumption in particular cases can be discharged\nusing the control loop invariant technique\u0006\n\u0002 A motivating toy example\u0003 a lift controller\nAs motivation for the results presented in this paper\u0007 we consider a toy example\nof a collection of lift machines described in B\u0007 controlled by CSP controller\nprocesses\u0006 An individual lift is given in Figure \r\u0006 It describes a particular lift\u0007\nindexed by i \u0006 We will then go on to de\u000bne a system consisting of a collection of\nsuch lifts\u0006\n\u0003\u0001\u0002 Individual lifts\nThe Lift machine provides three operations\u0012 i inc\u0000nn\u0001 which moves the lift up\nnn \u0018oors\u0007 i dec which moves the lift down one \u0018oor\u0007 and a query operation\ni isZero which indicates whether or not the lift is on the ground \u0018oor\u0006\ni up\ni down\ni ground\ni inc\ni dec i isZero\ni LiftCtrl\ni Lift\nFig\u0000 \u0003\u0000 The controlled lift system\nThe CSP controller is also given in Figure \r\u0006 It interacts with a user through\nthe events i up\u0007 i down\u0007 and i ground \u0007 and controls the lift accordingly\u0012\n\u0006 on i up\u0001y \u0007 it calls i inc and moves the lift up y \u0018oors\u0006\n\u0006 on i down\u0001y \u0007 it calls i dec y times or until it reaches the ground if this is\nsooner\u0006\n\u0006 on i ground \u0007 it is required to move the lift to the ground \u0018oor\u0006 To do this\u0007 it\nrepeatedly checks \busing i isZero\t whether the lift is on the ground \u0018oor\u0007\nand if not then it moves the lift down a \u0018oor with i dec\u0006\nWe are \u000brstly interested in each controlled lift combination\ni LiftSys \u0013 \bi Lift k i LiftCtrl\t n fj i inc\u0000 i dec\u0000 i isZero jg\nwhich is pictured in Figure \u0010\u0006 We require as a minimum that this combination\nis deadlock\nfree and divergence\nfree\u0006\nThese properties are apparent in this simple example\u0006 Deadlock\nfreedom is\nimmediate because the B machine is always willing to engage in any event re\n\nquired by the controller\u0007 and the controller itself is either waiting for an interac\n\ntion from its environment or else ready to call a controller operation\u0006 Divergence\ncould arise either \bi\t from a B operation being called outside its precondition\u0007 or\n\bii\t from an in\u000bnite sequence of internal events\u0006 In the case of \bi\t\u0007 the only oper\n\nation with a non\ntrivial precondition is i dec\u0007 and the controller is constructed\nso that i dec is only ever called when the lift is not at \u0018oor \u0004\u0006 In the case of\n\bii\t\u0007 the lift will eventually reach the ground \u0018oor and so an in\u000bnite sequence of\ncalls of i dec cannot occur\u0006\nIn more complex examples the properties may not be so apparent\u0007 and it\nwould be useful to be able to apply analysis tools to carry out model\nchecking\non the combined system\u0006 However\u0007 no tools currently exist which can analyse a\ncombination of B and CSP descriptions\u0006 The best we can aim for is to analyse\nthe descriptions separately and combine results\u0006 In particular\u0007 for considering\nproperties such as deadlock and livelock we would aim to apply a tool such\nas FDR \u0002For\u0003\u000f\u0005 to the CSP part of the description\u0007 and deduce results about\nthe controlled combination\u0006 In particular\u0007 once it has been established that the\ni LiftCtrl\u000b\u0001f \u0002 \u0006\ni up\u0007y \u0000 i inc\by \u0000 i LiftCtrl\u000b\u0001f \f y\u0002\n\u0000 i down\u0007y \u0000 i DOWN \u000b\u0001f \u0001 y\u0002\n\u0000 i ground \u0000 i LOWER\u000b\u0001f \u0002\ni LOWER\u000b\u0001f \u0002 \u0006\ni isZero\u0007bb\n\u0000\n\u0001\n\u0002\n\u0003\nfbb \u0006 TRUE \u0002 f \u0006 \tg \u0000\nif \u0001bb \u0006 TRUE\u0002\nthen i LiftCtrl\u000b\u0001f \u0002\nelse i dec \u0000 i LOWER\u000b\u0001f \u0001 \n\u0002\ni DOWN \u000b\u0001f \u0001 n\u0002 \u0006\nif n \u0006 \t\nthen i LiftCtrl\u000b\u0001f \u0002\nelse i isZero\u0007bb\n\u0000\n\u0001\n\u0002\n\u0003\nfbb \u0006 TRUE \u0002 f \u0006 \tg \u0000\nif \u0001bb \u0006 TRUE\u0002\nthen i LiftCtrl\u000b\u0001f \u0002\nelse i dec\u0000\ni DOWN \u000b\u0001f \u0001 \n\u0001n \u0001 \n\u0002\nFig\u0000 \u0004\u0000 The controller with diverging assertions\ncontroller does not call operations outside their precondition\u0007 then the aim is that\nall deadlocking and divergent behaviour is essentially contained in the controller\nand can be identi\u000bed without further reference to the B machine\u0006\nIt has previously been established \u0002ST\u0004\rb\u0005 that\u0007 under appropriate condi\n\ntions\u0007 the deadlock\nfreedom of a controller P implies the deadlock\nfreedom of a\ncontrolled combination P kM \u0006 This result appears in this paper as Theorem \r\u0006\nWe also establish in this paper \bTheorem \u0010\t that\u0007 under appropriate condi\n\ntions\u0007 if P n E is divergence\nfree\u0007 then so too is \bP kM \t n E \u0006\nThese two theorems are exactly what is required\u0006 We have only to check that\ni LiftCtrl is deadlock\nfree to deduce the same for i LiftSys\u0006 And we have only\nto check that i LiftCtrl n fj i inc\u0000 i dec\u0000 i isZero jg is divergence\nfree to deduce\nthis for i LiftSys\u0006 These are both checks that are easily done using FDR\u0006\nHowever\u0007 the second check turns out not to be correct\u0006 The description of\ni LiftCtrl n fj i inc\u0000 i dec\u0000 i isZero jg in fact contains a divergence arising from\nthe in\u000bnite sequence hi ground \u0000 i isZero\u0001false\u0000 i dec\u0000 i isZero\u0001false\u0000 i dec\u0000 \u0001 \u0001 \u0001i of\ni LiftCtrl \u0006 It is the machine i Lift that ensures that this cannot occur \u0019 but\nthat machine was not included in the FDR analysis\u0006\nThe problem is that some of the control \u0018ow is dependent on the state in\n\nformation maintained in the B machine\u0007 and so the useful theorems we have\navailable are not directly applicable\u0006 We need to include the relevant state infor\n\nmation in the description of the CSP controller\u0007 and also the expectation that\nthe value true will be received on channel i isZero exactly when f \u0013 \u0004\u0006 This is\nincluded as an assertion\u0007 as shown in Figure \u001a\u0006 It is straightforward to show that\ni LiftCtrl\r\b\u0004\t is an appropriate driver for i Lift \busing control loop invariant\nf \u0013 \u0006oor\t\u0006 The proof that i LiftCtrl\r\b\u0004\t k i Lift has no divergences involves\nestablishing the truth of the assertion for the input bb on i isZero\u0006\nIntroducing a diverging assertion means that i LiftCtrl\r\b\u0004\t trivially has a\ndivergence \bi\u0006e\u0006 the behaviour when the assertion is not met\t\u0007 so it is not ap\n\npropriate to check i LiftCtrl\r\b\u0004\t n fj i inc\u0000 i dec\u0000 i isZero jg for divergence\n\nfreedom\u0006 However\u0007 in the context of i Lift we know the assertion will always be\ni LiftCtrl\r\u0001f \u0002 \u0006\ni up\u0007y \u0000 i inc\by \u0000 i LiftCtrl\r\u0001f \f y\u0002\n\u0000 i down\u0007y \u0000 i DOWN \r\u0001f \u0001 y\u0002\n\u0000 i ground \u0000 i LOWER\r\u0001f \u0002\ni LOWER\r\u0001f \u0002 \u0006\ni isZero\u0007bb\n\u0000\n\u0001\n\u0002\n\u0003\nhbb \u0006 TRUE \u0002 f \u0006 \ti \u0000\nif \u0001bb \u0006 TRUE\u0002\nthen i LiftCtrl\r\u0001f \u0002\nelse i dec \u0000 i LOWER\r\u0001f \u0001 \n\u0002\ni DOWN \r\u0001f \u0001 n\u0002 \u0006\nif n \u0006 \t\nthen i LiftCtrl\r\u0001f \u0002\nelse i isZero\u0007bb\n\u0000\n\u0001\n\u0002\n\u0003\nhbb \u0006 TRUE \u0002 f \u0006 \ti \u0000\nif \u0001bb \u0006 TRUE\u0002\nthen i LiftCtrl\r\u0001f \u0002\nelse i dec\u0000\ni DOWN \r\u0001f \u0001 \n\u0001n \u0001 \n\u0002\nFig\u0000 \u0005\u0000 The controller with blocking assertions\ntrue\u0007 so we may replace the diverging assertion by a blocking one\u0007 and yield a\ncontroller with the same behaviour in the context of i Lift \u0006 The only di\u0016erence\nis that this controller blocks rather than diverges when the assertion is false\u0007\nand since the assertion is never false in the context of i Lift \u0007 the resulting be\n\nhaviour is the same\u0006 This transformation is justi\u000bed by Corollary \u000e\u0006 Thus\u0007 we\nobtain a variant i LiftCtrl\u0010\b\u0004\t of the controller\u0007 given in Figure \u001b\u0007 such that\ni LiftCtrl\u0010\b\u0004\t k i Lift \u0013 i LiftCtrl\r\b\u0004\t k i Lift \u0006\nNow we have a transformation of the controller which is divergence\nfree when\nthe internal events are hidden\u0012 i LiftCtrl\u0010\b\u0004\t n fj i inc\u0000 i dec\u0000 i isZero jg is\ndivergence\nfree\u0007 and this can be checked using FDR \bgiven a bound on the num\n\nber of possible consecutive i up events\t\u0006 So we can conclude that \bi LiftCtrl\u0010\b\u0004\t k\ni Lift\t n fj i inc\u0000 i dec\u0000 i isZero jg is divergence\nfree\u0006\nNow Corollary \u000e also allows the assertions of i LiftCtrl\r\b\u0004\t to be dropped\ncompletely\u0007 resulting in a controller whose behaviour does not depend on the\nvalue of the parameter f at all\u0007 and which is therefore equivalent to i LiftCtrl \u0006\nThis transformation is discussed in more detail in \u0002ST\u0004\ra\u0005\u0006 We have therefore\nnow established divergence\nfreedom of the original combination \bi LiftCtrl k\ni Lift\t n fj i inc\u0000 i dec\u0000 i isZero jg\u0006\nTo sum up\u0012 we identi\u000bed two new controllers which are equivalent in the\npresence of i Lift to the original controller i LiftCtrl \u0007 and which are each used\nin a di\u0016erent part of the proof\u0006\ni LiftCtrl\r\b\u0004\t k i Lift \u0013 i LiftCtrl\u0010\b\u0004\t k i Lift \u0013 i LiftCtrl k i Lift\n\u0006 The combination i LiftCtrl\r\b\u0004\t k i Lift can be shown to be divergence\nfree\nusing techniques from \u0002ST\u0004\rb\u0005\u0006\n\u0006 i LiftCtrl\u0010\b\u0004\t n fj i inc\u0000 i dec\u0000 i isZero jg is divergence\nfree\u0007 and so\n\bi LiftCtrl\u0010\b\u0004\t k i Lift\t n fj i inc\u0000 i dec\u0000 i isZero jg is divergence\nfree\u0006\n\u0006 And i LiftCtrl\r\b\u0004\t k i Lift is equivalent to the original i LiftCtrl k i Lift \u0006\nThese results together establish the required result\u0012 that the original combination\n\bi LiftCtrl k i Lift\t n fj i inc\u0000 i dec\u0000 i isZero jg is divergence\nfree\u0006 The state\n\n LiftCtrl\n\n Lift\n\u000b LiftCtrl\n\u000b Lift\n\r LiftCtrl\n\r Lift\n\u000e LiftCtrl\n\u000e Lift\nreq\nbottom\n\u0001 up\n\u0001 down\n\u0001 ground\n\u0001 inc\n\u0001 dec\n\u0001 isZero\nsend\nreset\nDispatchCtrl\nDispatch\nFig\u0000 \u0006\u0000 The complete system Lifts\ninformation was introduced into the controller purely to enable the veri\u000bcation\nto take place\u0007 and can be removed once the result has been established\u0006\nWe also deduce that \bi LiftCtrl k i Lift\t n fj i inc\u0000 i dec\u0000 i isZero jg is\ndeadlock\nfree\u0006 This follows from deadlock\nfreedom of i LiftCtrl k i Lift \u0006\n\u0003\u0001\u0000 A collection of lifts\nWe will now combine the lifts into a single system together with a Dispatch and\nDispatchCtrl component which manages requests for lifts from buttons on the\nvarious \u0018oors\u0006 When a request for a lift is made from a particular \u0018oor\u0007 only one\nof the lifts needs to be sent\u0006 An example architecture made up of four lifts is\npictured in Figure \u001c\u0006\nThe Dispatch machine contains some algorithm for deciding which lift should\nbe sent to a particular \u0018oor\u0006 It has an operation ii \u0000 nn\u0000 dd \u0003\u0004 send\b\u0007 \t\u0006 On input\nof the \u0018oor \u0007 to send a lift to\u0007 it provides as output the lift ii to be sent\u0007 the\nnumber of \u0018oors nn and the direction dd that lift ii will need to travel \bas\ncomputed by Dispatch\t\u0006 Dispatch has another operation reset \u0007 which is called\nwhen all lifts return to the ground \u0018oor\u0006 The particular details of Dispatch are\nnot relevant to this example and will not be given here\u0006\nThe DispatchCtrl controller accepts requests along channel req \u0012 an input\nreq\u0014x is a request for a lift to go to \u0018oor x \u0006 It makes use of the Dispatch machine\nto decide which lift to allocate\u0007 and then sends the appropriate instruction to\nthe relevant lift\u0006 The controller can also accept an instruction bottom to return\nall lifts to the ground \u0018oor\u0006 It is de\u000bned as follows\u0012\nDispatchCtrl \u0013 req\u0014x \u0005 send \u0015x\u0014i\u0014n\u0014d \u0005 if d \u0013 ascend\nthen i up\u0015n \u0005 DispatchCtrl\nelse i down\u0015n \u0005 DispatchCtrl\n\u0000 bottom \u0005 \u000e ground \u0005 \r ground \u0005 \u0010 ground\n\u0005 \u001a ground \u0005 reset \u0005 DispatchCtrl\nOur overall system is then composed of the controlled lift components Lifts \u0013\nk\ni\u0004\u0000\u0000\u0000\u0005\n\bi LiftCtrl k i Lift\t interacting with the DispatchCtrl k Dispatch com\n\nponent\u0007 and with all events apart from req and bottom internal\u0012\n\b\nk\ni\u0004\u0000\u0000\u0000\u0005\n\bi LiftCtrl k i Lift\t k \bDispatchCtrl k Dispatch\t\t n Int\nInt \u0013\nS\ni\nfj i inc\u0000 i dec\u0000 i isZero\u0000 i up\u0000 i down\u0000 i groundg \b fj send \u0000 reset jg\nWe will see in Section \u001c that this system is deadlock\nfree and divergence\nfree\u0006\n\u0004 Deadlock\u0005freedom\nAn essential requirement for controlled components is deadlock\nfreedom\u0006 This is\neasily checked in FDR\u0007 but only for processes that are expressed in CSP\u0006 Thus\u0007\nwe aim to establish a theorem that allows the deadlock\nfreedom of P k M to be\ndeduced from deadlock\nfreedom of P \bwhich can then be checked using FDR\t\u0006\nIn general\u0007 parallel composition does not preserve deadlock\nfreedom\u0006 Fortu\n\nnately\u0007 in the case of CSP controllers and B machines\u0007 we are able to identify\nconditions which ensure that the processes involved interact on their common\nchannels in a particular way\u0007 ensuring that introducing a B machine cannot\nintroduce any new deadlocks\u0006 In other words\u0007 any deadlocks possible for the\ncontrolled component P k M must already have been possible in P \u0006\nOpen on possible inputs The required property of the B machine is that\nit should always be able to accept any input for any operation\u0007 and be able to\nprovide some output\u0006 The need for this property is precisely why only machines\nwith non\nblocking operations are permitted\u0006 If a machine meets this property\nthen we will say it is open on the particular operations and inputs\u0006\nIn CSP terms\u0007 this is de\u000bned formally for CSP processes Q as follows\u0012\nDe\u0005nition \u0000\u0001 A process Q is open on a set of partial events PE if\u0002 given any\n\btr \u0000X \t \u0001 SF \u0002\u0002Q \u0005\u0005 and e \u0001 PE\u0002 there is some w such that e\u0001w \u0007\u0001 X \u0003\nThis will apply to B machines as follows\u0012 given any machine operation w \u0003\u0004\ne\bv\t\u0007 we would expect the machine to be open on any partial event of the form\ne\u0001v\n\u0006\n\u0007 which corresponds to passing the input v\n\u0006\nto operation e\u0006 In other words\u0007\nthere should be some output w\n\u0006\nwhich is made available by the machine \band\nhence does not appear in the refusal set X \t\u0006\nThe set of possible inputs for a machine will be all those partial events which\ncorrespond to operations being called with some input\u0006 The events are partial\nbecause they do not include the output values\u0006\nDe\u0005nition \u0003\u0001 Given a B machine M with operations w\ni\n\u0003\u0004 e\ni\n\bv\ni\n\t\u0002 the set\npi\bM \t of possible inputs for M is de\u0004ned by\npi\bM \t \u0013\nS\ni\nfe\ni\n\u0001v\ni\nj v\ni\n\u0001 T\nin\n\be\ni\n\tg\nExample \b\u0003 The set of partial inputs for the machine i Lift is given in terms of\nthe three operations as follows\u0012\npi\bi Lift\t \u0013 fj i inc\u0001i j i \u0001Zjg \b fj i dec jg \b fj i isZero jg\nObserve that in the cases of i inc and i dec there are no outputs\u0007 so the partial\nevents are in fact complete events\u0006 Being open on these events means that they\ncannot be refused \bsince their output \u000beld is empty\t\u0006 There are two completions\nof the partial event i isZero\u0012 i isZero\u0001true and i isZero\u0001false\u0006 i Lift being open\non this partial event means that at any stage at least one of these completions\ncannot be refused by i Lift \u0006\nThe key property of non\nblocking machines is that they will always be open\non their possible inputs\u0012\nLemma \u0002\u0001 Any \tnon\u0000blocking\n B machine M is open on pi\bM \t\u0003\nThis states in CSP semantics terms that any operation call with any input should\nalways produce some result\u0006\nNon\u0007discriminating controllers The condition on a controller P is that\u0007\nwhenever it calls an operation of the controlled B machine M \u0007 it should be able\nto accept any output provided by M \u0006 We call this property non\u0000discriminating\u0007\nand it can be expressed formally in CSP terms with the following de\u000bnition\u0012\nDe\u0005nition \u0004\u0001 A CSP process P is non\ndiscriminating on a set of partial events\nPE if\u0002 for any failure \btr \u0000X \t \u0001 SF \u0002\u0002P \u0005\u0005 and subset CV \t PE\u0002 we have that\n\b\n c\u0001v \u0001 CV \u000b \fw \u000b c\u0001v \u0001w \u0001 X \t\r \btr \u0000X \b fj CV jg\t \u0001 SF \u0002\u0002P \u0005\u0005\nThis de\u000bnition states that if any event c\u0001v \u0001w can be refused \bi\u0006e\u0006 appears in\nthe refusal set X \t\u0007 then all the inputs on channel c\u0001v \bi\u0006e\u0006 outputs from the B\nmachine\t could be refused\u0012 thus the refusal X can be augmented with fj c\u0001v jg\u0006\nExample \u000b\u0003 The control process i LiftCtrl is non\ndiscriminating on i isZero\u0012 at\nany stage\u0007 i LiftCtrl can either refuse all of fj i isZero jg\u0007 or else none of it\u0006 In\nterms of the de\u000bnition\u0007 whenever some event from fi isZero\u0001true\u0000 i isZero\u0001falseg\ncan be refused\u0007 then all can be refused\u0006\nObserve that i LiftCtrl is also non\ndiscriminating on fi inc\u0001i j i \u0001Zg and on\ni dec\u0006 In fact a process will trivially be non\ndiscriminating on complete events\u0006\nThe approach is restricted to non\u0000blocking B machines\u0006 In other words\u0007 oper\n\nations w \u0003\u0004 e\bv\t must always be enabled \bthough they might be called outside\ntheir preconditions\u0007 which leads to divergence\t and on any input they must pro\n\nvide some output\u0006\nControllers which do not include blocking assertions on the control channels\nare able to accept any output from the associated B machine whenever they call\nan operation with any particular inputs\u0006 Thus\u0007 they will be non\ndiscriminating\non the possible inputs to the machine\u0006 This is expressed by the following lemma\u0012\nLemma \u0000\u0001 If P is a controller for machine M with no blocking assertions on\nany channels of M \u0002 then P is non\u0000discriminating on the set pi\bM \t of M \fs pos\u0000\nsible inputs\u0003\nObserve that this lemma is illustrated by i LiftCtrl in Example \r above\u0006\nEstablishing Deadlock\u0007freedom We now have ingredients which are su\f\n\ncient to deduce deadlock\nfreedom of P k Q from deadlock\nfreedom of P \u0006 The\nidea is that the interface between P and Q is de\u000bned by a set of partial events\nPE \u0012 P should be non\ndiscriminating on these partial events\u0007 and Q should be\nopen on them\u0006 We can show that if P k Q can deadlock\u0007 then so can P \u0006\nIf P k Q does have a deadlock state\u0007 then all events can be simultaneously\nrefused in that state\u0006 For any partial event e\u0007 Q is open on e so Q cannot refuse\nall of fj e jg\u0006 Hence P must be refusing some event in fj e jg\u0007 and so because P\nis non\ndiscriminating\u0007 P can refuse all of fj e jg\u0006 Thus\u0007 we \u000bnd that all events in\nthe interface can be refused by P in this state\u0007 and P cannot perform any other\nevents either\u0006 Hence P is in a deadlocked state\u0006\nConsider this reasoning in the context of a controlled component\u0006 Consider\na state of P kM \u0006 If P in this state is not deadlocked\u0007 then either\n\u000e\u0006 P is ready to perform an event outside \u0003\bM \t\u0006 In this case\u0007M cannot prevent\nthat event\u0007 and the combination P k M is ready to perform the event\u0007 and\nhence is not deadlocked\u0017 or\n\r\u0006 P is ready to perform an interaction with M \u0006 In this case\u0007 it is an operation\ncall c with some input v \u0006 P is ready to accept any output from this operation\ncall\u0007 since it is non\ndiscriminating on c\u0001v \u0006 M is ready to provide an output\nw in response to c\u0001v \u0007 since it is open on c\u0001v \u0006 Hence\u0007 the combination P kM\nis ready to perform c\u0001v \u0001w \u0007 and so is not in a deadlocked state\u0006\nThe lemma that this reasoning establishes is the following\u0012\nLemma \u0003\u0001 If\n\b\u0003 P is non\u0000discriminating on a set of partial events PE\r and\n\u000b\u0003 Q is open on PE\r and\n\u000e\u0003 \u0003\bQ\t \u0013 fj PE jg\r\nthen\u0005 if P is deadlock\u0000free in the stable failures model\u0002 then so too is P k Q\nFor a particular controlled component P k M \u0007 we already have the conditions\nfor Lemma \u0010\u0012 P is non\ndiscriminating on pi\bM \t \bfrom Lemma \r\t\u0017 M is open on\npi\bM \t \bfrom Lemma \u000e\t\u0017 and \u0003\bM \t \u0013 fj pi\bM \t jg\u0006\nFinally\u0007 we obtain the following theorem for controlled components\u0012\nTheorem \u0000\u0001 If P is a CSP controller for M with no blocking assertions on any\nchannels of M \u0002 and P is deadlock\u0000free in the stable failures model\u0002 then P k M\nis deadlock\u0000free in the stable failures model\u0003\nThis theorem is exactly what is required to establish deadlock\nfreedom of P kM\nfrom deadlock\nfreedom of P \u0006 In fact a direct proof of this theorem in terms of the\nCSP semantics has previously been presented\u0007 in \u0002ST\u0004\rb\u0005\u0006 However\u0007 we \u000bnd the\nidenti\u000bcation of the properties non\ndiscriminating and open yields more under\n\nstanding as to why the theorem works and allows an easier proof of Theorem \r\nand others\u0006\nExample \u000e\u0003 For example\u0007 consider the combination i LiftCtrl k i Lift \u0007 in a\nstate after some trace tr \u0007 in which fi isZero\u0001true\u0000 i isZero\u0001falseg is refused\u0006 We\nknow that i Lift is open on fj i isZero jg\u0007 so it cannot refuse the whole set\nfi isZero\u0001true\u0000 i isZero\u0001falseg\u0006 Since the parallel combination does refuse that\nwhole set\u0007 it must be that i LiftCtrl is refusing at least one of i isZero\u0001true\u0007\ni isZero\u0001false\u0006 But i LiftCtrl is non\ndiscriminating on i isZero\u0007 so this means\nthat it can itself refuse the whole set fj i isZero jg\u0006\nThe same reasoning applies to all partial events in the interface between\ni LiftCtrl and i Lift \u0006 Thus\u0007 if i LiftCtrl k i Lift could reach a deadlock state\u0007\nthen all events in the interface would be refused by i LiftCtrl k i Lift \u0007 and so\nthey could also be refused purely by i LiftCtrl \u0006 Thus\u0007 i LiftCtrl would also have\na deadlock state\u0006\nAs observed previously\u0007 i LiftCtrl is deadlock\nfree\u0006 Hence Theorem \r allows\nus to deduce that i LiftCtrl k i Lift is deadlock\nfree\u0006\n\u0006 Restricting events to prevent divergence\nThe use of abstraction is essential in the compositional development of large sys\n\ntems\u0006 We will therefore generally need to hide control channels within controlled\ncomponents\u0006\nSince hiding has the potential to introduce divergence\u0007 we need to be able to\nestablish when this does not occur\u0006 In particular\u0007 it would be useful to be able\nto check divergence\nfreedom of a controller P n C using FDR\u0007 and to be able to\ndeduce divergence\nfreedom of the controlled component \bP kM \t n C \u0006\nThe following theorem on CSP processes P and Q gives such a condition\u0012\nTheorem \u0003\u0001 If P k Q is divergence\u0000free\u0002 and C \t \u0003\bP\t\u0002 and P n C is\ndivergence\u0000free\u0002 then \bP k Q\t n C is divergence\u0000free\u0003\nThis is immediately applicable to controlled components\u0007 since C \t \u0003\bP\t as\na consequence of our architecture\u0006 Thus\u0007 divergence\nfreedom of \bP k M \t n C\nfollows directly from divergence\nfreedom of P n C \u0006\nHowever\u0007 in practice it will often be the case that P n C turns out not to be\ndivergence\nfree\u0007 even if \bP k M \t n C is\u0006 For instance\u0007 in the lift example we found\nthat i LiftCtrl n fj inc\u0000 dec\u0000 isZero jg was not divergence\nfree\u0007 and instead we\nhad to transform the controller description to i LiftCtrl\u0010\b\u0004\t in order to obtain\na controller such that i LiftCtrl\u0010\b\u0004\t n fj inc\u0000 dec\u0000 isZero jg is divergence\nfree\u0006 So\nit is necessary to identify theorems which justify such transformations\u0006\nOur approach is to identify behaviours of controller P which cannot occur in\nthe context of the machine M under control\u0006 We then aim to \u000bnd P\n\u0001\nsuch that\n\u000e\u0006 P\n\u0001\nis the same as P except \bpossibly\t on the behaviours that have been\nidenti\u000bed\u0007 and\n\r\u0006 P\n\u0001\nn C is divergence\nfree\nThus\u0007 P\n\u0001\nk M will be the same as P k M \u0007 which by assumption is divergence\n\nfree\u0006 Theorem \u0010 applied to P\n\u0001\nyields that \bP\n\u0001\nk M \t n C is divergence\nfree\u0007 and\nhence \bP kM \t n C is divergence\nfree\u0006\nThis is the approach that was taken in the lift example\u0006 The relevant be\n\nhaviour that cannot occur in the context of i Lift is the output of false from\nisZero when the lift is at the ground \u0018oor\u0006 This behaviour is blocked in i LiftCtrl\u0010\b\u0004\t\u0006\nHowever\u0007 i LiftCtrl\u0010\b\u0004\t is the same as i LiftCtrl for all behaviours that are pos\n\nsible in parallel with i Lift \u0006\nThe way we identify traces that cannot occur is to require divergence when\n\never they do occur\u0007 and then look for divergences\u0006 If we are concerned with a set\nof traces T \t A\n\u0002\n\u0007 then we can express this by de\u000bning a new process DIV\nA\n\bT \t\nwhich behaves as RUN\nA\nexcept that it diverges on any trace in T \u0012\nF \u0002\u0002DIV\nA\n\bT \t\u0005\u0005 \u0013 f\btr \u0000 fg\t j tr \u0001 A\n\u0002\ng \b f\btr\na\ntr\n\u0001\n\u0000X \t j tr \u0001 T \u0002 tr\n\u0001\n\u0001 A\n\u0002\n\u0002 X \t Ag\nD \u0002\u0002DIV\nA\n\bT \t\u0005\u0005 \u0013 ftr\na\ntr\n\u0001\nj tr \u0001 T \u0002 tr\n\u0001\n\u0001 A\n\u0002\ng\nObserve that DIV\nA\n\bfg\t \u0013 RUN\nA\nand DIV\nA\n\bA\n\u0002\n\t \u0013 DIV\nA\n\u0006\nThe process DIV\nA\n\bT \t can then be used to mask behaviour in a process P \u0006\nThe process P k DIV\nA\n\bT \t behaves exactly as P \u0007 except that whenever a trace\nin T is performed then it diverges\u0006 Thus\u0007 if P k DIV\nA\n\bT \t \u0013 P\n\u0001\nk DIV\nA\n\bT \t\u0007\nthen P and P\n\u0001\nhave the same behaviour except possibly with regard to traces\nin T \u0007 which are masked by the introduction of divergence\u0006\nThe following theorem allows a process P to be replaced by an alternative\nprocess P\n\u0001\nin the context of another process Q \u0006 In particular\u0007 if P does not\ndiverge in the context of Q \bi\u0006e\u0006 P k Q is divergence\nfree\t\u0007 and P\n\u0001\nis the same\nas P except on divergent traces of P \u0007 then P and P\n\u0001\nhave the same executions\nwhen executed in parallel with Q \bsince none of P \u0000s divergent traces will be\nperformed\t\u0006\nTheorem \u0004\u0001 If P\u0002 P\n\u0001\nand Q are such that\n\b\u0003 P k Q is divergence\u0000free\u0002\n\u000b\u0003 P \u0013\nFD\nP\n\u0001\nk DIV\n\u0001\u0002P\u0003\n\bD \u0002\u0002P \u0005\u0005\t\n\u000e\u0003 \u0003\bP\t \u0013 \u0003\bP\n\u0001\n\t\nthen P k Q \u0013 P\n\u0001\nk Q\u0003\nThis states that if P\n\u0001\nis di\u0016erent to P only with respect to where P diverges\u0007\nand P k Q does not diverge\u0007 then P and P\n\u0001\nbehave the same in the context of\nQ \u0006 This follows because if P k Q does not diverge\u0007 then none of the traces of P\nwhich lead to divergence are possible when executing in parallel with Q \u0006 Since\nP\n\u0001\nis exactly the same as P except for these traces\u0007 and Q prevents such traces\nfrom occurring\u0007 it follows that P\n\u0001\nk Q is the same as P k Q \u0006\nExample \u000f\u0003 As an example to illustrate Theorem \u001a\u0007 consider the following pro\n\ncesses\u0006 P and P\n\u0001\nhave alphabet A \u0013 fa\u0000 b\u0000 cg\u0007 and Q has alphabet fa\u0000 bg\u0006\nP \u0013 \ba \u0005 \bb \u0005 DIV\nA\n\u0000 a \u0005 c \u0005 P\t\t\nP\n\u0001\n\u0013 \ba \u0005 \bb \u0005 c \u0005 P\n\u0001\n\u0000 a \u0005 c \u0005 P\n\u0001\n\t\t\nQ \u0013 \ba \u0005 a \u0005 Q\t \u0000 \bb \u0005 STOP\t\n\u0006 Firstly\u0007 we see that P k Q can only ever perform a and c events\u0007 and is\ndeadlock\nfree\u0006 In particular\u0007 the process Q prevents P from performing the\nb event\u0007 the only event that can lead to divergence\u0007 since there is no point\nat which P and Q can agree to perform b\u0006\n\u0006 The behaviour of P\n\u0001\nafter b occurs is di\u0016erent to that of P \bwhich is diver\n\ngent\t\u0007 but if b does not occur then P and P\n\u0001\nbehave the same\u0006 Thus\u0007 P and\nP\n\u0001\nare the same except on the divergences of P \u0006\n\u0006 Finally\u0007 note that P and P\n\u0001\nhave the same alphabet\u0006\nThus\u0007 we can conclude that P k Q \u0013 P\n\u0001\nk Q \u0006\nThe reason this result is useful is because it supports the introduction and\nmanipulation of assertions on the control channels\u0006 If we introduce a divergent\nassertion on a control channel between P and M \u0007 and we then establish that\nP k M is divergence\nfree \busing CLI techniques\t\u0007 then we can alter the behaviour\nof P when the assertion is false \bin which case P diverges\t and obtain a related\ncontroller P\n\u0001\nwhich matches P outside P \u0000s divergences\u0007 and for which P k M \u0013\nP\n\u0001\nk M \u0006 The aim is to obtain a controller P\n\u0001\nin this way for which P\n\u0001\nn C is\ndivergence\nfree\u0006\nThe next lemma lists some ways in which diverging assertions within a con\n\ntroller can be transformed\u0006\nLemma \u0004\u0001 If a controller P\n\u0001\nis obtained from controller P by replacing clauses\nof the form e\u0015v\u0014xfE \bx \tg \u0005 R\bx \t with one of\u0005\n\b\u0003 e\u0015v\u0014xfE\n\u0001\n\bx \tg \u0005 R\bx \t where \n x \u0001E \bx \t\r E\n\u0001\n\bx \t\n\u000b\u0003 e\u0015v\u0014x \u0005 if E \bx \t then R\bx \t else Q\bx \t\n\u000e\u0003 e\u0015v\u0014x \u0005 R\bx \t\n\u000f\u0003 e\u0015v\u0014x hE \bx \ti \u0005 R\bx \t\nthen P \u0013\nFD\nP\n\u0001\nk DIV\n\u0001\u0002P\u0003\n\bD \u0002\u0002P \u0005\u0005\t\nThus\u0007 we obtain the following corollary for controlled components\u0012\nCorollary \u0002\u0001 If P kM is divergence\u0000free\u0002 then behaviour in P following an in\u0000\nput which fails a diverging assertion can be changed in accordance with Lemma \u000f\nwithout a\u0007ecting the behaviour of the parallel combination\u0003\nThis means that diverging assertions in P \u0007 once they have been discharged in\na context M \u0007 can be replaced with blocking assertions\u0007 or else removed com\n\npletely\u0006 This is precisely the justi\u000bcation for the transformation of i LiftCtrl\r\bi\t\nto i LiftCtrl\u0010\bi\t\u0012 in the context of i Lift \u0007 i LiftCtrl\r\b\u0004\t does not diverge\u0006\n\u0007 Parallel combinations of controlled components\nAll the results of the previous sections have been presented as applying to a\nsingle CSP controller process P in parallel with a single B machineM \u0006 However\u0007\nsystems we are generally concerned with \bsuch as the combination of lifts\t have\nthe form\nk\ni\n\bP\ni\nk M\ni\n\t\u0007 as illustrated in Figure \u000e\u0006 Many of the results we have\nobtained for a single controlled component can be lifted to combinations of\ncomponents\u0007 and we will consider some of these in this section\u0006\nDivergence\u0007freedom Firstly\u0007 we consider divergence\nfreedom\u0006 It is straightfor\n\nward to establish divergence\nfreedom of a combined system\u0007 using the following\ntheorem from \u0002ST\u0004\rb\u0005\u0012\nTheorem \b\u0001 If P\ni\nk M\ni\nare divergence\u0000free for each i\u0002 then\nk\ni\n\bP\ni\nk M\ni\n\t is\ndivergence\u0000free\u0003\nThis follows immediately from the semantics for parallel composition\u0007 which\npreserves divergence\nfreedom\u0006 Thus\u0007 we need only establish divergence\nfreedom\nfor the component pairs\u0007 and the result follows\u0006\nExample \u0010\u0003 In the parallel lift system\u0007 since each of the controlled lift compo\n\nnents is divergence\nfree\u0007 and since we are given that the controlled dispatcher\ncomponent is divergence\nfree\u0007 it follows that the overall parallel combination of\nall the components of the multiple lift system is divergence\nfree\u0006\nEstablishing deadlock\u0007freedom Associativity and commutativity of the par\n\nallel operator means that we can group the controller processes together and the\nmachines together\u0007 rearranging the parallel composition as follows\u0012\nk\ni\n\bP\ni\nkM\ni\n\t \u0013 \b\nk\ni\nP\ni\n\t k \b\nk\ni\nM\ni\n\t\nNow we can consider \b\nk\ni\nP\ni\n\t as a CSP process\u0007 and \b\nk\ni\nM\ni\n\t as another CSP pro\n\ncess\u0017 and we are concerned with the parallel combination of these two processes\u0006\nThe reason for grouping the components in this way is that the properties\n\u001dnon\ndiscriminating\u0000 and \u001dopen\u0000 are preserved by parallel composition in CSP\u0006\nWe can thus obtain the following two lemmas\u0012\nLemma \b\u0001 If P\ni\nis a collection of controllers for machines M\ni\nrespectively\u0002\nwhere each P\ni\nhas no blocking assertions on any channels of its associated M\ni\n\u0002\nthen\nk\ni\nP\ni\nis non\u0000discriminating on the set\nS\ni\n\bpi\bM\ni\n\t\t\u0003\nLemma \t\u0001 Any collection of \tnon\u0000blocking\n B machines M\ni\nhas that\nk\ni\nM\ni\nis\nopen on\nS\ni\n\bpi\bM\ni\n\t\t\u0003\nLemma \u001c states that if each machine is able to engage in any of its operations\u0007\nthen the parallel combination of all the machines is able to engage in any of the\noperations of any of its machines\u0006\nThese two lemmas mean that the conditions for Lemma \u0010 are met for con\n\ntrollers with no blocking assertions\u0012\n\u000e\u0006\nk\ni\nP\ni\nis non\ndiscriminating on the set\nS\ni\n\bpi\bM\ni\n\t\t\u0006\n\r\u0006\nk\ni\nM\ni\nis open on\nS\ni\n\bpi\bM\ni\n\t\t\u0006\n\u0010\u0006 \u0003\b\nk\ni\nM\ni\n\t \u0013 fj\nS\ni\n\bpi\bM\ni\n\t\t jg\u0006\nThis means that Lemma \u0010 is directly applicable to a collection of parallel con\n\ntrolled components\u0007 in which deadlock\nfreedom of the overall parallel combina\n\ntion follows from deadlock\nfreedom of the combination of controllers\u0006\nPQ\n\n LiftCtrl\n\n Lift\n\u000b LiftCtrl\n\u000b Lift\n\r LiftCtrl\n\r Lift\n\u000e LiftCtrl\n\u000e Lift\nreq\nbottom\nDispatchCtrl\nDispatch\nFig\u0000 \u0007\u0000 Splitting the system into P and Q to verify divergence\u0003freedom\nTheorem \t\u0001 Given a collection of CSP controllers P\ni\nand corresponding con\u0000\ntrolled machines M\ni\n\u0002 such that no controller has any blocking assertions on the\ncontrol channels\u0005 then if\nk\ni\nP\ni\nis deadlock\u0000free in the stable failures model\u0002 then\nso too is k\ni\n\bP\ni\nkM\ni\n\t\u0003\nIn the example lift system\u0007 we have therefore only to check that\n\b\nk\ni\u0004\u0000\u0000\u0000\u0005\ni LiftCtrl\t k DispatchCtrl\nis deadlock\nfree \bwhich is easily shown\t to deduce this for the complete system\u0006\nDivergence\u0007freedomof Lift System We are really concerned with divergence\n\nfreedom of\n\b\nk\ni\u0004\u0000\u0000\u0000\u0005\n\bi LiftCtrl k i Lift\t k \bDispatchCtrl k Dispatch\t\t n Int\nTheorem \u0010 is the appropriate theorem to apply here\u0006 We need to split the\nsystem into P and Q such that P k Q is divergence\nfree\u0007 and P n C is divergence\n\nfree\u0006 The natural approach would take P as the combination of CSP controllers\u0007\nandQ as the combination of B machines\u0017 veri\u000bcation could indeed be established\nby introducing assertions into the controllers along the lines of Section \u0010\u0006\nHowever\u0007 we have already established the individual lifts are divergence\nfree\u0007\nso we can re\nuse this result by splitting the system di\u0016erently\u0007 as pictured in\nFigure \u000f\u0006 P is DispatchCtrl \u0007 Q is the rest of the system\u0007 and C is the interface\nbetween P and Q \u0012\nP \u0013 DispatchCtrl\nQ \u0013\nk\ni\ni LiftSys k Dispatch\nC \u0013\n\u0000\ni\nfj i up\u0000 i down\u0000 i ground jg \b fj send \u0000 reset jg\nWe can check the conditions for Theorem \u0010\u0012\n\u000e\u0006 Each i LiftSys is divergence\nfree \bas established earlier\t\u0007 and alsoDispatchCtrl k\nDispatch is divergence\nfree\u0007 so the parallel combinationP k Q \u0013\nk\ni\ni LiftSys k\nDispatch k DispatchCtrl is divergence\nfree \bsince divergence\nfreedom is pre\n\nserved by parallel composition\t\u0006\n\r\u0006 C \t \u0003\bP\t\n\u0010\u0006 P n C is divergence\nfree\u0006 \bThis is easily checked with FDR\u0006\t\nThus Lifts \u0013 \bP k Q\t n C is divergence\nfree\u0006\n\b Discussion\nThis paper has been concerned with providing the CSP underpinnings for devel\n\noping controlled components consisting of B machines controlled by CSP con\n\ntrollers under a particular architecture\u0006 The work builds on the control loop\ninvariant method for verifying individual controlled components in the context\nof the B Method\u0007 and develops results for combining such veri\u000bed components\u0006\nAll of the results presented in this paper have been developed using the CSP\nsemantics of all the component processes\u0006 The emphasis has been on obtaining\ncompositional results which enable existing CSP veri\u000bcation methods and tools\nto apply to our combined systems\u0006 These results enable a particular strategy\nfor veri\u000bcation\u0012 transform system descriptions to equivalent forms which are\namenable to CSP checking\u0006 In the simplest case\u0007 if the combination P k M is\nequivalent to P\n\u0001\nkM \u0007 and properties of P\n\u0001\nk M can be established by analysing\nP\n\u0001\n\bwith CSP tools\t\u0007 then those same properties can be deduced for P kM \u0006 So\nour approach is to transform a controller P to a process P\n\u0001\nwhich behaves the\nsame way in the context of M \u0006\nTransforming system descriptions to enable pure CSP analysis may involve\nthe introduction of state information within the CSP controller descriptions\u0007 so\nthat the behaviour in the context of the underlying B machine is not a\u0016ected\u0006\nIn this paper we have illustrated the use of this technique\u0006\nOngoing work \u0002ST\u0004\ra\u0005 has obtained further results for this framework\u0006 Firstly\u0007\nit is often the case that controlled components are only correct in the context of\nthe rest of the system\u0006 In this situation we will need to introduce assertions on the\nchannels between CSP controllers\u0007 in order to establish divergence\nfreedom of the\nindividual controlled components\u0006 Treating assertions as blocking or diverging\nin particular cases is a delicate issue and depends on the particular veri\u000bcation\nunder consideration\u0006 We have developed theorems \u0002ST\u0004\ra\u0005 which justify the use\nof particular kinds of assertions\u0006 Secondly\u0007 we have results \bwhose proofs use\nthe notions of non\ndiscriminating and open\t concerning re\u000bnement in the stable\nfailures model\u0012 if SPEC v P n \u0003\bM \t then SPEC v \bP k M \t n \u0003\bM \t under the\nappropriate conditions\u0006 This enables speci\u000bed properties to be veri\u000bed of com\n\nbined systems\u0006 These results have been applied to a Bounded Retransmission\nProtocol \u0002EST\u0004\u0010\u0005 for bu\u0016er\nstyle properties\u0007 and in the Bank case study\u0002TSB\u0004\u0010\u0005\u0006\nThere are several other approaches to combining a process\nstyle controller\nwith a state\nbased system description \be\u0006g\u0006 \u0002But\u0004\u0004\u0007FL\u0004\u0010\u0007WC\u0004\u000e\u0007SD\u0004\u000e\u0005\t\u0006 The ap\n\nproach closest to ours is Butler\u0000s csp\rB tool \u0002But\u0004\u0004\u0005\u0007 which allows a CSP process\nto be conjoined to a B machine in a way which corresponds to a controller for an\nunderlying machine\u0006 However\u0007 none of the other approaches exploit the semantic\nmodels for CSP in the way presented here\u0006 The ability to develop theory and tap\ninto existing tool support on both the concurrency side and the state\nbased side\nis an important driver of the approach presented in this paper\u0007 and originally\nmotivated the choices of CSP and B as the methods we chose to integrate\u0006\nAcknowledgements Thanks are due to Neil Evans\u0007 Susan Stepney\u0007 Fiona Po\n\nlack and R\u001eegine Laleau for discussions on this work\u0007 and also to Neil for com\n\nments on drafts of this paper\u0006\nReferences\n\u000fBut\t\t\u0010 M\u0004 Butler\u0004 csp\u000bB\u0011 A practical approach to combining CSP and B\u0004 Formal\nAspects of Computing\u0000 \n\u000b\u0000 \u000b\t\t\t\u0004\n\u000fEST\t\r\u0010 N\u0004 Evans\u0000 S\u0004 A\u0004 Schneider\u0000 and H\u0004 E\u0004 Treharne\u0004 Investigating a \u0005le transmis\u0003\nsion protocol using CSP and B\u0004 In proceedings of ST\u0002EVE workshop\u0000 \u000b\t\t\r\u0004\n\u000fFL\t\r\u0010 M\u0004 Frappier and R\u0004 Laleau\u0004 Proving event ordering properties for information\nsystems\u0004 In ZB\u0003\u0004\u0004\u0005\u0000 \u000b\t\t\r\u0004\n\u000fFor\u0012\u0013\u0010 Formal Systems \u0001Europe\u0002 Ltd\u0004 Failures\u0000Divergences Re\u0006nement\u0007 FDR\u0003 Man\u0000\nual\u0000 \n\u0012\u0012\u0013\u0004\n\u000fMor\u0012\t\u0010 C\u0004 C\u0004 Morgan\u0004 Of wp and CSP\u0004 In W\u0004H\u0004J\u0004 Feijen\u0000 A\u0004 J\u0004 M\u0004 van Gesteren\u0000\nD\u0004 Gries\u0000 and J\u0004 Misra\u0000 editors\u0000 Beauty is our Business\u0007 a birthday salute to\nEdsger J\u0002 Dijkstra\u0004 Springer\u0003Verlag\u0000 \n\u0012\u0012\t\u0004\n\u000fRos\u0012\u0013\u0010 A\u0004 W\u0004 Roscoe\u0004 The Theory and Practice of Concurrency\u0004 Prentice\u0003Hall\u0000 \n\u0012\u0012\u0013\u0004\n\u000fSca\u0012\u0014\u0010 B\u0004 Scattergood\u0004 The Semantics and Implementation of Machine\u0000Readable CSP\u0004\nD\u0004 Phil thesis\u0000 Oxford University\u0000 \n\u0012\u0012\u0014\u0004\n\u000fSch\u0012\u0012\u0010 S\u0004A\u0004 Schneider\u0004 Concurrent and Real\u0000time Systems\u0007 The CSP approach\u0004 Wiley\u0000\n\n\u0012\u0012\u0012\u0004\n\u000fSD\t\n\u0010 G\u0004 Smith and J\u0004 Derrick\u0004 Speci\u0005cation\u0000 re\u0005nement and veri\u0005cation of concur\u0003\nrent systems \u0003 an integration of Object\u0003Z and CSP\u0004 Formal Methods in System\nDesign\u0000 \n\u0014\u0001\r\u0002\u0000 \u000b\t\t\n\u0004\n\u000fST\t\u000ba\u0010 S\u0004 Schneider and H\u0004 Treharne\u0004 CSP theorems for communicating B machines\u0004\nTechnical Report CSD\u0003TR\u0003\t\u000b\u0003\t\u0015\u0000 Royal Holloway\u0000 University of London\u0000 \u000b\t\t\u000b\u0004\n\u000fST\t\u000bb\u0010 S\u0004A\u0004 Schneider and H\u0004E\u0004 Treharne\u0004 Communicating B machines\u0004 In ZB\u0003\u0004\u0004\u0003\u0000\nvolume LNCS \u000b\u000b\u0013\u000b\u0000 \u000b\t\t\u000b\u0004\n\u000fTre\t\t\u0010 H\u0004 E\u0004 Treharne\u0004 Combining control executives and software speci\u0006cations\u0004 PhD\nthesis\u0000 Royal Holloway\u0000 University of London\u0000 \u000b\t\t\t\u0004\n\u000fTSB\t\r\u0010 H\u0004E\u0004 Treharne\u0000 S\u0004A\u0004 Schneider\u0000 and M\u0004 Bramble\u0004 Combining speci\u0005cations\nusing communication\u0004 In ZB\u0003\u0004\u0004\u0005\u0000 \u000b\t\t\r\u0004\n\u000fWC\t\n\u0010 J\u0004 C\u0004 P\u0004 Woodcock and A\u0004 L\u0004 C\u0004 Cavalcanti\u0004 A concurrent language for re\u0005ne\u0003\nment\u0004 In \bth Irish Workshop on Formal Methods\u0000 \u000b\t\t\n\u0004\n"}