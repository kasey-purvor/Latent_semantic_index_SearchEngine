{"doi":"10.1109\/TASE.2007.41","coreId":"65324","oai":"oai:dro.dur.ac.uk.OAI2:6221","identifiers":["oai:dro.dur.ac.uk.OAI2:6221","10.1109\/TASE.2007.41"],"title":"Realizing live sequence charts in SystemVerilog.","authors":["Wang, H.","Qin, S.","Sun, J.","Dong, J. S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-06-01","abstract":"The design of an embedded control system starts with an investigation of properties and behaviors of the process evolving within its environment, and an analysis of the requirement for its safety performance. In early stages, system requirements are often specified as scenarios of behavior using sequence charts for different use cases. This specification must be precise, intuitive and expressive enough to capture different aspects of embedded control systems. As a rather rich and useful extension to the classical message sequence charts, live sequence charts (LSC), which provide a rich collection of constructs for specifying both possible and mandatory behaviors, are very suitable for designing an embedded control system. However, it is not a trivial task to realize a high-level design model in executable program codes effectively and correctly. This paper tackles the challenging task by providing a mapping algorithm to automatically synthesize SystemVerilog programs from given LSC specifications","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65324.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6221\/1\/6221.pdf","pdfHashValue":"7c47e9aa5ad8d8fcbcc6fd66b0ab25d3a96417c0","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6221<\/identifier><datestamp>\n      2010-11-08T10:47:41Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Realizing live sequence charts in SystemVerilog.<\/dc:title><dc:creator>\n        Wang, H.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Sun, J.<\/dc:creator><dc:creator>\n        Dong, J. S.<\/dc:creator><dc:description>\n        The design of an embedded control system starts with an investigation of properties and behaviors of the process evolving within its environment, and an analysis of the requirement for its safety performance. In early stages, system requirements are often specified as scenarios of behavior using sequence charts for different use cases. This specification must be precise, intuitive and expressive enough to capture different aspects of embedded control systems. As a rather rich and useful extension to the classical message sequence charts, live sequence charts (LSC), which provide a rich collection of constructs for specifying both possible and mandatory behaviors, are very suitable for designing an embedded control system. However, it is not a trivial task to realize a high-level design model in executable program codes effectively and correctly. This paper tackles the challenging task by providing a mapping algorithm to automatically synthesize SystemVerilog programs from given LSC specifications. <\/dc:description><dc:publisher>\n        IEEE <\/dc:publisher><dc:source>\n        (2007). 1st Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering : June 6-8 2007, Shanghai ; proceedings. Los Alamitos, CA: IEEE , pp. 379-388<\/dc:source><dc:date>\n        2007-06-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6221<\/dc:identifier><dc:identifier>\n        doi:10.1109\/TASE.2007.41<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6221\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/TASE.2007.41<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6221\/1\/6221.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2007 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2007,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nWang, H. and Qin, S. and Sun, J. and Dong, J. S. (2007) \u2019Realizing live sequence charts in SystemVerilog.\u2019, in\n1st Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering : June 6-8 2007, Shanghai ;\nproceedings. Los Alamitos, CA: IEEE , pp. 379-388.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/TASE.2007.41\nPublisher\u2019s copyright statement:\n2007 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nRealizing Live Sequence Charts in SystemVerilog\nHai H. Wang\nSchool of Electronics and Computer Science\nUniversity of Southampton\nhw@ecs.soton.ac.uk\nShengchao Qin\nDepartment of Computer Science,\nDurham University.\nshengchao.qin@durham.ac.uk\nJun Sun\nSchool of Computing\nNational University of Singapore\nsunj@comp.nus.edu.sg\nJin Song Dong\nSchool of Computing\nNational University of Singapore\ndongjs@comp.nus.edu.sg\nAbstract\nThe design of an embedded control system starts with\nan investigation of properties and behaviors of the process\nevolving within its environment, and an analysis of the re-\nquirement for its safety performance. In early stages, sys-\ntem requirements are often speci\u0002ed as scenarios of behav-\nior using sequence charts for different use cases. This spec-\ni\u0002cation must be precise, intuitive and expressive enough to\ncapture different aspects of embedded control systems. As a\nrather rich and useful extension to the classical message se-\nquence charts, Live Sequence Charts (LSC), which provide\na rich collection of constructs for specifying both possible\nand mandatory behaviors, are very suitable for designing\nan embedded control system. However, it is not a trivial\ntask to realize a high-level design model in executable pro-\ngram codes effectively and correctly. This paper tackles the\nchallenging task by providing a mapping algorithm to au-\ntomatically synthesize SystemVerilog programs from given\nLSC speci\u0002cations.\n1 Introduction\nThe design of an embedded control system is ideally de-\ncomposed into a progression of related phases. It starts with\nan investigation of properties and behaviors of the process\nevolving within its environment, and an analysis of the re-\nquirement for its safety performance. From these is derived\na speci\u0002cation of program-centered components of the sys-\ntem. The process then may go through a series of design\nphases, ending in a program expressed in a high level lan-\nguage. After translation into a machine code of a chosen\ncomputer, it can be executed at a high speed by electronic\ncircuits. In order to achieve time performance required by\ncustomers, additional application-speci\u0002c hardware devices\n(e.g., ASICs or FPGAs) may be added to embed the com-\nputer into the system which it controls. The derivation of\nlow-level implementation from high-level, referred as syn-\nthesis, is a complicated process which requires tool assis-\ntance.\nIn early stages of system engineering, system require-\nments are often speci\u0002ed as scenarios of behavior using use\ncases or sequence charts. A use case is an informal de-\nscription of a collection of possible scenarios involving the\nsystem\u2019s components and its environment, while sequence\ncharts provide a formal means for specifying the scenar-\nios that instantiate the use cases. As a popular require-\nments language, sequence charts like UML Sequence Di-\nagrams [25] and ITU standard Message Sequence Charts\n(MSCs) [15] have been used to capture the desired interre-\nlationships between system components and between them\nand the environment. These sequence charts often state\nwhat might possibly occur, not what must occur, which\nmeans that they are not enough if we want to specify the\nactual behavior of a reactive system in a scenario-based\nfashion. To overcome this potential limitation in expressive\npower, Damm and Harel [8] extended MSCs to incorpo-\nrate liveness properties, yielding a new sequence-based lan-\nguage called Live Sequence Charts (LSCs). LSCs may state\nscenarios that must occur. For instance, a universal chart,\npossibly preceded with a pre-chart, speci\u0002es mandatory be-\nhaviors globally, i.e., once the system behavior matches its\npre-chart, the subsequent behavior must follow the main\nchart. On the level of a chart, events and conditions and\nlocations are also labelled with modalities. LSCs also pro-\nvide structuring constructs, like sub-charts, branching and\niterations, to build scenarios hierarchically.\nAs a rather rich and useful extension to MSCs, LSCs\nprovide a rich collection of constructs for specifying both\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\npossible and mandatory behaviors. The play engine for\nLSCs [12] provides an intuitive and easy way for system de-\nsigners to play in expected scenarios of behavior and play\nout LSC speci\u0002cations for veri\u0002cation and validation pur-\nposes. For these reasons, we have decided to take LSCs\nas the behavioral speci\u0002cationlanguage in our framework\nfor embedded system design. In [23], a method of gener-\nating Verilog programs from Statechart [9] has been pro-\nposed. Compared to Statechart, LSC serves a natural nota-\ntion for stating scenario-based system requirements, which\nis involved in even earlier stage of system development.\nAfter an LSC speci\u0002cation has been played-in and ver-\ni\u0002ed\/tested using the play-out engine, an immediate ques-\ntion is, how can we generate executable program code in\norder to proceed to the next development stage? This\npaper is to tackle this challenging problem by provid-\ning a mapping algorithm to automatically synthesize Sys-\ntemVerilog programs from given LSC speci\u0002cations. We\nchoose SystemVerilog as a target language for our synthe-\nsis process partly because our overall aim is to develop\nhardware\/software mixed embedded systems, whereas Sys-\ntemVerilog is a language suitable for both behavioral and\nstructural speci\u0002cations of such systems. Moreover, Sys-\ntemVerilog supports assertions which can potentially be\nused to specify certain requirement constraints carried over\nfrom LSC speci\u0002cations including liveness properties and\nnon-functional constraints. The tool supports available for\nSystemVerilog also allows u to verify\/simulate the system\ndesign before the hardware\/software partitioning process.\nMost importantly, SystemVerilog is popular in industry,\ne.g., it has been standardized by IEEE.\nThis remainder of the paper is organized as follows. Sec-\ntion 2.1 brie\u0003y introduces the notion of LSC. Section 2.2\nreview the relevant features of SystemVerilog. Section 3\nis devoted to a mapping from LSC speci\u0002cations to Sys-\ntemVerilog programs and a brief discussion of its correct-\nness. Section 4 concludes the paper and discusses possible\nfuture works.\n2 Background\n2.1 Live Sequence Charts\nThere are two kinds of charts in LSC. Existential charts\nare mainly used to describe possible scenarios of a system\nin the early stage of system development, i.e., the same role\nplayed by MSC except that existential charts are scoped.\nIn later stages, knowledge becomes available about when\na system run has progressed far enough for a speci\u0002c us-\nage of the system to become relevant. Universal charts are\nthen used to specify behaviors that should always be ex-\nhibited. A universal chart is typically preceded with a pre-\nchart, which serves as the activation condition of the main\nchart. Whenever a communication sequence matches the\npre-chart, the system must proceed as speci\u0002ed by the main\nchart. A system run may activate a universal chart more\nthan once and some of the activations might overlap [18].\nUniversal chart Figure 1 shows a universal chart as part of\nthe mobile phone speci\u0002cation. This scenario OpenCover\nillustrates the interaction between the objects when the user\nopens the cover. Once the cover is opened by the user, the\nmain chart is activated. The chip is noti\u0002ed that the cover\nis opened. If the phone is not playing music, the chip re-\nquests the display to display the main menu. Otherwise,\nthe music menu shall be displayed. The dot-lined diamond\nshape denotes a cold condition. We remark that all vertical\nlines are dotted in this chart and, therefore, all locations are\ncold. Lastly, the display carries out a respective local ac-\ntion, setMainMenu or setMP3Menu, to initialize the phone\nscreen. \u0002\nIn this work, we focus on universal charts. Existential\ncharts are used for generating test benches in later stages.\nEach chart is associated with a set of visible events. Only\nevents visible to a chart are constrained by the chart. A\nchart typically consists of multiple instances (for instance,\nUser, Cover, Chip and Display), which are represented as\nvertical lines graphically. Along with each line, there is a\n\u0002nite number of locations. A location carries the tempera-\nture annotation for progress within an instance. Intuitively,\nlocations can be thought as the joint points of instance lines\nand message lines. A location may be labelled as either cold\nor hot. A hot location means that a system run reaching this\nlocation has to move beyond. A system run may stay put\nat a cold location forever. Similarly, messages and condi-\ntions are also labelled. A hot message must be received,\nwhereas a cold one may get lost. A hot condition must be\nmet, whereas violation of a cold condition terminates the\nchart. A location is labelled with a \u0002nite number of events\n(more than one if it is a co-region) and at most one condi-\ntion.\nMobile phone speci\u0002cation The universal charts in Fig-\nure 2 and the one in Figure 1 constitute a self-containing\nset of scenarios, which specify a mobile phone speci\u0002ca-\ntion. This example is partially inspired by the phone sys-\ntem speci\u0002cation presented in [13]. The system consists of\nsix participating objects, a user, the cover, the display, the\nspeaker, the chip and the environment where the incoming\ncalls are from. Figure 2 illustrates scenarios of the system\nbesides OpenCover, i.e., the user closes the cover, an in-\ncoming call arrives and the user picks up the phone and\ntalks. All vertical lines in the charts are dotted, which means\nthat all locations along the lines are cold and, therefore, the\nsystem may pause at any point of execution forever. This is\npossible because unexpected events like the battery runs out\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\nUser Cover Chip\nOpenCover\nopen\ncoverOpened\nDisplay\nstatus!=mp3\ndisplayMainMenu\ndisplayMP3Menu\nsetMainMenu\nsetMP3Menu\nFigure 1. Phone System Scenario: OpenCover\nor the system breaks down may occur at any time. The set\nof visible events for each chart are exactly those appeared\nin the diagram except the scenario Talk. The message close\nfrom the user to the cover is forbidden in the scenario Talk,\ni.e., in order to carry out the scenario successfully, the user\nshould not close the cover before the scenario completes. \u0002\nLSC also supports advanced MSC features like co-\nregion, hierarchy, etc. Moreover, symbolic instances and\nmessages are used to group scenarios effectively. For a de-\ntailed introduction on a complete list of features of LSC,\nrefer to [12]. LSC is far more expressive than MSC, which\nmakes it capable of expressing complicated scenario-based\nrequirements. However, we remark that the ability to spec-\nify hot and cold messages, i.e., whether a message is re-\nquired to be received or may get lost, is redundant because\nof the facility for describing hot and cold locations. Es-\nsentially, the temperature of the locations takes precedence\nover the temperature of messages, so whether or not the\nmessage is received is determined entirely by the tempera-\nture of the message input. This questionable feature of LSC\nis recognized by Harel and Marelly who list the possible\ncases and conclude that the temperature of messages has no\nsemantic meaning [12]. Thus, in the following discussion,\nthe temperature of messages is discarded.\n2.2 SystemVerilog\nSystemVerilog, as one of the latest releases from IEEE\nfor the hardware design languages, extended Verilog by\ncombining the Veri\u0002cation capabilities of HVL (Hardware\nVeri\u0002cation Language) with ease of Verilog to provide a sin-\ngle platform for both design and veri\u0002cation.\nA SystemVerilog model is composed of modules,\nwhich de\u0002ne nets connected by wires. Nets are com-\nposed of processes (threads of executions), which execute\nstatements. The statements in SystemVerilog can be divided\ninto two groups \u2013 blocking statements and non-blocking\nstatements. Each individual statement can be labelled.\nBlocking assignments, which may or may not being at-\ntached with a time speci\u0002cation, block the execution of a\nprocess until their completion. When a blocking assign-\nment is executed, an event e is generated and added to the\nglobal event queue EventQ. Blocking assignment state-\nments are sequential statements. Non-blocking assignment\nstatements, like always, fork...join, and implicit wire as-\nsignment statements, generate non-blocking region update\nevents. Non-blocking assignment statements are concurrent\nassignments. The statements can be grouped into a single\nbegin\u2212 end or fork \u2212 join block.\nThe modules in SystemVerilog are often connected us-\ning interfaces, which provides a high level of abstraction\nof connections. An interface is de\u0002ned independent from\nmodules.\nSystemVerilog has a set of build-in datatypes and users\ncan also de\u0002ne their own complex data structures. Sys-\ntemVerilog also provides several powerful ways for syn-\nchronizing parallel activities within a design or a test bench.\nFor more information about SystemVerilog, please refer\nto [1].\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\ndisplayTime\ncoverClosed\nclose\nCloseCover\nDisplayChipCoverUser\nsetDisplayTime\ndisplayCallerID\nstartRing\nincomingCall\nSpeakerChipEnv\nReceive\nDisplay\nsetDisplayCaller\nUser Cover Chip SpeakerEnv Display\nopen\ncoverOpened\nstartRing\nspeakerOff\ndisplayTimer\nTalk\ntalk\ncloseLSC\nForbidden Elements\nsetDisplayTimer\nFigure 2. Mobile phone system scenarios\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\n3 From LSCs to SystemVerilog\nIn this section, we build a link between LSC speci\u0002-\ncations and SystemVerilog programs, i.e., an LSC speci\u0002-\ncation is mapped into a corresponding SystemVerilog pro-\ngram. We show that such a mapping can be conducted in\na compositional manner. Moreover, the SystemVerilog pro-\ngram is modular and, therefore, allows possible later soft-\nware\/hareware partitioning.\n3.1 The Synthesis Problem\nIn an LSC speci\u0002cation, an object may participate in\nmultiple universal charts playing different roles, e.g., the\nobject Chip in the universal charts. A good practice of im-\nplementing the system, however, is that the behaviors of\neach object should be encapsulated in one package (a class\nor module) for easy maintenance as well as code reusing.\nIn this work, we not only want to systematically construct\na SystemVerilog program which is equivalent to the LSC\nmodel, but also to do it in such a way that each object in\nthe LSC speci\u0002cation is mapped to a module in the Sys-\ntemVerilog program. Thus, the module groups all roles\nthat the object plays in the universal charts. The system\nthen consists of instances of all object modules running in\nparallel. In another words, we are tackling an instance of\nthe distributed synthesis problem. Distributed synthesis is\ncomputationally expensive in general [19] and in the case\nof LSC [6]. The approach we use follows the practical\nsolution offered in [20] and later in [21], which sacri\u0002ces\ncompleteness in exchange of an ef\u0002cient and sound way of\nsynthesizing a distributed system. The key idea is of us-\ning a \u0002xed implementation template to avoid undecidabil-\nity, i.e., using a bounded set of synchronization events to\nmonitor global completion of universal charts locally so that\nthe global state machine is never constructed. However, the\nworks in [20, 21] never yield any executable program like\nSystemVerilog. By using unique constructors like always\noffered in SystemVerilog, we show that we are able to not\nonly realize their solution but also make the solution even\nsimpler.\n3.2 SystemVerilog Realization\nIn the following, we will walk through the mappings in-\nformally using the cell phone examples. A set of mapping\nrules will be presented later in this section.\nFigure 3 shows the top-level module of the SystemVer-\nilog program synthesized from the phone system speci\u0002ca-\ntion. It encapsulates everything about the phone speci\u0002ca-\ntion. The parameters specify the communication interface.\nThis is necessary because reactive systems constantly inter-\nact with their environments. Through the ports, this sys-\n1. module Phone (...ports...);\n2. \/\/ports\n3. \/\/variables\n4. \/\/tasks and functions\n5. \/\/control processes\n6. User user(...ports...);\n7. Env env(...ports...);\n8. Cover cover(...ports...);\n9. Chip chip(...ports...);\n10. Display display(...ports...);\n11. Speaker speaker(...ports...);\n12. endmodule\nFigure 3. Top-level module example\ntem can be connected to its environment. For instance, the\nports will be connected to a test bench during system sim-\nulation. After the input\/outputs de\u0002nitions, all global vari-\nables (including variables dedicated to a universal chart) are\ndeclared, which will be wired to the relevant object (as we\nshall see later). This top level module also contains a set\nof tasks and function de\u0002nitions, which correspond to the\nexternal functions and conditions in the universal charts. In\naddition, there is a set of controlling processes to ensure the\ncorrect order of execution. For the moment, we omit the\ndetails.\nThe key point here is that there should be one module\nde\u0002ned for each object type in the system and an object is\nde\u0002ned as an instance of the module (which is de\u0002ned in the\ntop-level module). For instance, we have a module named\nCover corresponding to the object Cover in the speci\u0002ca-\ntion. The object cover is de\u0002ned as an instance of the mod-\nule Cover. The module de\u0002ning the object type shall group\nall its roles in different universal charts, e.g., instance cover\nshall be able to participate in all three charts shown in Fig-\nure 2. Moreover, we shall be able to identify which role to\nact dynamically during system runs. The details of the mod-\nule Cover will be shown later. All the objects are running\nconcurrently.\nWe do have modules de\u0002ned the two environmental ob-\njectsUser and Env. This may suggest that we only deal with\nclosed systems, i.e., environmental objects are manipulated\nas if they are parts of the system. We remark that we do\nhandle open systems. The users (or system speci\u0002ers) are\nasked to distinguish the environmental objects from system\nobjects. The modules synthesized for the environmental ob-\njects are indeed processes which monitor the interaction be-\ntween the system and its environment so as to trigger the\ncontrolling events at the right execution point. This is a\npractical approach to avoid the undecidability of the distrib-\nuted synthesis problem for open systems. In other words,\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\n1. module Cover (\u00b7 \u00b7 \u00b7 ports \u00b7 \u00b7 \u00b7);\n2. \/\/ports\n3. \/\/variables\n4. \/\/controlling process\n5. \/\/for the role in chart OpenCover\n6. always@(open) begin \u00b7 \u00b7 \u00b7 end\n7. \/\/for the role in chart CloseCover\n8. always@(close) begin \u00b7 \u00b7 \u00b7end\n9. \/\/for the role in chart Talk\n10. always@(open) begin \u00b7 \u00b7 \u00b7 end\n11. endmodule\nFigure 4. Object type module example\nwe achieve a correct-by-construction method by paying a\nreasonable price. A related work on adding liveness as-\nsumption on the environment to ease the distributed syn-\nthesis problem was discussed in [6]. The work in [21] dis-\ncussed a similar approach using a partial modelling of the\nenvironment.\nGrouping different roles of an object in one module re-\nquires identifying which role an object is to play dynami-\ncally. According to LSC semantics, all visible events of a\nchart shall be monitored constantly. Whenever the pre-chart\nof a universal chart is matched, the participating objects\nshall cooperate to proceed as speci\u0002ed by the main chart,\ni.e., the objects shall play their roles corporately. Thus,\nwe need controlling processes which dynamically decide\nwhether a pre-chart has been matched and if all participat-\ning objects in the universal chart are ready to proceed to the\nmain chart.\nInside the module for an instance, there are ports de\u0002n-\nitions, variable de\u0002nitions as well as controlling processes.\nBesides, there is one always block for each role which the\nobject could play in the universal charts. For instance, in the\nmodule presented in Figure 4, there is one always block for\neach role which theCover plays in the charts. The role is ac-\ntivated only if the sequence of events on the instance in the\npre-chart of the universal chart is matched. For instance, the\nalways block for the role in OpenCover is activated only if\nthe event open is engaged. Once activated, the object must\nplay its role in the main chart.\n1. always @(open)\n2. begin\n3. cover open cover main =\n!cover open cover main;\n4. open cover activated = 1;\n5. end\nThe above is the process capturing the role of the object\nCover in the pre-chart of chart OpenCover. Whenever the\nevent open is monitored, the process signals the control-\nling process in the module Phone (the third line above). It\nsays that the object Cover is now ready to proceed to the\nmain chart of the chart OpenCover (by negating the value\nof cover open cover main). The fourth line sets a \u0003ag to\nindicate that the chart OpenCover has been activated.\n1. always@(cover open cover main)\n2. begin\n3. @user open cover main;\n4. open cover main =!open cover main;\n5. end\nThe above is a controlling process in the top-level mod-\nule. There is such a process for each and every universal\nchart. Once the object cover declares that it is ready to\nenter the main chart (by event @cover open cover main),\nthe process waits for other participating objects to declare\nthe same. Once all objects are ready, it triggers the event\n@open cover main so that all object enters the main simul-\ntaneously.\n1. always @((open cover main or\ncancel open cover)\n2. iff open cover activated == 1)\n3. if (open cover main) begin\n4. coverOpened = !coverOpened;\n5. end else begin\n6. if (cancel open cover) begin\n7. $display(\u2032\u2032Chart canceled.\u201d);\n8. end\n9. end\nOnce all the instances are ready to participate in the sce-\nnario, the controlling process synchronizes the entering\nof the main chart among all participating instances. In\nthe modules for each participating objects, there is an\nalways block like the above which responds to either\nopen cover main (meaning the object shall proceed to the\nmain chart of OpenCover) or cancel open cover (meaning\nthe activation has been terminated). The activation of the\nchart may be terminated if an unexpected event (associated\nwith this object or other objects) is engaged. For instance,\nthe trace \u3008open, speakerOff \u3009 shall trigger and then terminate\nthe chart Talk. In that case, the event cancel open cover\nis synchronized among the activated instances so that the\ncorresponding processes will be terminated. If the event\nopen cover main is engaged (the third line), the events in\nthe main chart occur in the time step (the fourth line). The\nduration of a time step can be set as a user option. In one\ntime step, a super step of the LSC speci\u0002cation [12] is car-\nried out unless there is explicit delay (speci\u0002ed using time-\nout construct in LSC) in the chart. We do require that the in-\nternal computation and communication shall be faster than\nthe arrival of external stimuli.\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\ne2\ne\ne1\ni2i1\ne2\ne3\ne\ni2i1\nFigure 5. Example charts: synchronization\nAs you have seen, events in LSC are mapped to primitive\nSystemVerilog commands. For instance, message sending\nis mapped to event output and message receiving is mapped\nto event input. So are those compositional constructs like\nsub-chart, iteration and conditional branch, which have their\nexact images in the SystemVerilog language.\nOne problem we face when we do the mapping is that\nSystemVerilog lacks the support for barrier synchronization\namong multiple processes. Yet, it is unavoidable in LSC\nmodels and necessary for synthesizing SystemVerilog pro-\ngrams. For instance, each and every horizontal line in the\nspeci\u0002cation represents a barrier synchronization, e.g., the\nhorizontal line right after the pre-chart synchronizes the en-\ntering of the main chart among all participating instances.\nA shared condition, e.g., the cold condition in the chart\nOpenCover, synchronizes multiple instances as well, e.g.,\nChip and Display. We have already discussed how to syn-\nchronize the entering of a main chart. The same strategy\nis applied for other barrier synchronization. That is, before\nentering a sub-chart, all participating objects shall signal a\ncontrolling process in the Phone module, and later enter the\nsub-chart at once. Furthermore, barrier synchronization is\nneeded for events visible to multiple universal charts. An\nevent visible to multiple universal charts are allowed to en-\ngage if and only if all activations of the universal charts are\nready to engage in the event.\nExample In Figure 5, after the occurrence of event e1 and\ne2, the event e can only be engaged after event e3 because\ne is synchronized by the two charts. The problem can be\nfurther complicated as the event could be visible to multi-\nple universal charts and each chart may be activated many\ntimes. \u0002\nIn general, there could be in\u0002nite overlapping activations\nof the same chart. The good news is that there is always a\nsymmetry reduction which reduces the in\u0002nite overlapping\nactivations to \u0002nite many1. We make use of the simple event\n1In [6], Bontemps and Schobbens have shown that every LSC has an\nequivalent deterministic Bu\u00a8chi automaton that contains at most exponen-\ntially more states than there are locations in the LSC.\nsynchronization in SystemVerilog to simulate the effect of\nbarrier synchronization. Each event (as well as local ac-\ntions) is associated with an event handler. Only the handler\nis capable of engaging the event. Whenever an activated\nrole of an instance enters the main chart of the respective\nuniversal chart, it will register the set of visible events of\nthe chart that are associated with the instance. It is done by\nsynchronizing a set of special events with the event handlers\nassociated with the events. Whenever a role of the instance\nis ready to engage in a common event, it synchronizes with\nthe event handler. The event handler checks whether all reg-\nistered roles are ready to engage in the event. If they do, the\ncontrolling process will engage in the event and so all the in-\nstances proceed. Otherwise, the event handler simply waits.\nFor instance, if both e1 and e2 have engaged, because e has\nbeen registered by different roles, it can be engaged only\nafter e3.\nExample For simplicity, we use the example in Figure 6\nto illustrate our solution to the barrier synchronization.\nIt is a simple program generated from the charts in Fig-\nure 5.2 Once event e1 is engaged, counter e is incremented.\ncounter e is incremented again after event e2 is engaged.\nThen object i1 declares that it is ready to engage e by en-\ngaging in event ready e. Since counter e is greater than 1,\nit will be decremented by 1. Later, the object i2 declares it\nis ready to engage e. Because now counter e is of value 1,\nthe event \u0002re e is engaged, which gives the permission for\nthe objects to engage in event e. \u0002\nAll variables in the LSC speci\u0002cation are mapped to vari-\nables in the top level module of the SystemVerilog program.\nThey are wired to the relevant instance module if necessary.\nLocal actions and conditions in the LSC speci\u0002cation are\nmapped to tasks and functions in the top-level module. We\nremark that making the variable globally accessible is un-\navoidable if we are to support shared conditions in LSC.\nFor instance, the following is a task and function de\u0002nition\nappeared in the chart OpenCover:\n2To save space, we have removed synchronization on entering the main\nchart, the module structure, etc.\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\n1. bit e1, e2, e3, e, \u0002re e, ready e;\n2. byte unsigned counter e;\n3. always@(ready e iff counter e == 1)\n4. begin\n5. \u0002re e = !\u0002re e;\n6. counter e = 0;\n7. end\n8. always@(ready e iff counter e > 1)\n9. counter e = counter e\u2212 1;\n10. always@(e1)\n11. begin\n12. counter e = counter e+ 1;\n13. e2 =!e2;\n14. ready e = !ready e;\n15. @\u0002re e e =!e;\n16. end\n17. always@(e2)\n18. begin\n19. counter e = counter e+ 1;\n20. e3 =!e3;\n21. @\u0002re e e =!e;\n22. end\nFigure 6. Barrier synchronization example\n1. function bit Con1();\n2. if (state! = mp3) begin\n3. return 1;\n4. end else\n5. begin\n6. return 0;\n7. end\n8. endfunction\n9. tasksetMainMenu();\n10. \/\/procedural codes\n11. endtask\nWe summarize our transformation rules as follows:\n\u2022 Rule 1: Top-level module\n\u2013 An LSC speci\u0002cation is mapped to a top-level\nSystemVerilog module.\n\u2013 An object is mapped to an instance of the object\ntype module in the top-level module.\n\u2013 Variables and functions are mapped to variables\nand tasks in the top-level module.\n\u2022 Rule 2: Object type module\n\u2013 Each object type in the LSC speci\u0002cation is\nmapped to a module in the SystemVerilog pro-\ngram.\n\u2013 For each role which the object could play in the\nuniversal charts, there is one always block.\n\u2013 Events, variables, functions visible to the object\nare wired from the top-level module to the object\ntype module.\n\u2022 Rule 3: Existential charts\n\u2013 Existential charts are mapped to test benches.\n3.3 Discussion\nIn this section, we brie\u0003y discuss the soundness of the\ntransformation. We adapted the LSC semantics presented\nin [8] and extended in [22]. In a nutshell, the semantics\nof a basic chart, i.e., Basic-MSC [15], is de\u0002ned to consist\nof all runs compatible with the partial ordering induced by\nthe chart and its annotations. The semantics of existential\ncharts is different from that of basic charts because existen-\ntial charts, as universal charts, are scoped. Events invisible\nto the chart may occur freely between any two successive\nevents in an execution of the chart. In this work, existential\ncharts are used to illustrate test cases only. Lastly, a trace\nviolates a universal chart if and only if it completes the pre-\nchart but fails to conform to the main chart.\nIn [20], Sun and Dong have proved that distributed\nprocesses can be synthesized by using a bounded set of sys-\ntemization events. Their idea is to monitor possible comple-\ntion of the pre-charts and trigger synchronization events at\nthe proper execution time. A similar idea has been adapted\nin this work. Furthermore, using SystemVerilog allows us\nto simplify the task of monitoring possible matching of a\npre-chart because of the distinguishable always construct.\nThat is, an always-block is activated if a given event se-\nquence occurs, which closely corresponds to the semantics\nof pre-chart. Therefore, the soundness of our approach is a\nconsequence of the result proved in [20] and the semantics\nof the always construct.\n4 Conclusion\nIn this work, we have developed a strategy for systemat-\nically generating a SystemVerilog program from LSC spec-\ni\u0002cations. In our system development process, system engi-\nneers shall specify the system requirements using the notion\nof LSC. After an LSC speci\u0002cation has been played-in and\nveri\u0002ed\/tested using the play-out engine, a prototype Sys-\ntemVerilog program is generated for the next stage of sys-\ntem development. System engineers are encouraged to use\nassertion offered by SystemVerilog tools to simulate, verify\nand re\u0002ne the generated prototype if necessary. Once the\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\nsystem design is fully veri\u0002ed, SystemVerilog tools can be\nused for software\/hardware partition process. As for future\nworks, we plan to develop a reliable tool support for our ap-\nproach. Furthermore, the natural problem we want to tackle\nis to \u0002nd a systematic and ef\u0002cient partition strategy.\nAs mentioned earlier, we made the assumption that all\nmessage passing are all synchronized for simplicity. Asyn-\nchronous message passing can be supported by explicitly\nmodelling the behaviors of the communication buffer. Us-\ning advanced features like interfaces in SystemVerilog, we\nbelieve it should be reasonably straightforward.\nOur mapping does omit some features of LSC, for in-\nstance, the modality of locations and existential charts. The\nmodality of locations, i.e., whether the system shall move\nbeyond the location, is indeed liveness constraints. We be-\nlieve it is not something to be taken care of during the syn-\nthesis process. Rather, it shall be tested or asserted using\nassertions after the SystemVerilog program is synthesized.\nOur generation is based on universal charts. Existential\ncharts are used to generate test benches. For instance, Fig-\nure 7 shows an existential chart illustrating the most com-\nmon scenario of the phone system. The difference between\nclassic MSCs and existential charts is that existential charts\nare more abstract, i.e., only visible events are required to\noccur in the speci\u0002ed sequence. We make use of the Sys-\ntemVerilog language construct $monitor to monitor the vis-\nible events only and test whether the events happen in the\ngiven order.\nAs for related works, the synthesis problem of MSC has\nbeen studied extensively [3, 2, 17, 24, 16, 17, 14]. The syn-\nthesis problem of LSC is initially discussed by Harel and\nKugler in [10], in which they tackled the problem by de\u0002n-\ning the notion of consistency of LSC models. Their ap-\nproach starts with constructing a global system automaton\nand decomposes it by different means (refer to [10] for de-\ntails). Their approach suffers from the state explosion prob-\nlem due to the construction of the global system automaton,\nwhich is often of huge size because of the distributed na-\nture of LSC and the underlying weak partial order seman-\ntics. The characteristic of our work is that we synthesize a\nmodular SystemVerilog program which allows a reasonably\nlarge set of behaviors permitted by the LSC speci\u0002cation.\nIn [7], Bontemps, Schobbens and Lo\u00a8ding discussed the\nsynthesis problem for a small subset of LSC (LSC without\nconditions, structuring constructs, modalities on locations\nand messages). They proposed a game-based semantics for\nLSC, which leads to the notion of consistency of their LSC.\nTheir work is later extended to handle all LSC constructs\nbut unbounded loop in [4]. In our approach, almost all LSC\nconstructs are supported except complex time-related ones.\nIn [6], Bontemps and Schobbens investigated the complex-\nity of various problems associated with LSC. The results\nare pretty negative, i.e., they showed that centralized model-\nchecking of LSC is Co-NP-complete, the distributed model-\nchecking is PSPACE complete and the distributed realiza-\ntion problem is undecidable. In our work, we use a set of\nspecial events (bounded by the maximum number of over-\nlapping activation of the universal charts and the number\nof the universal charts) to avoid undecidability. Thus, our\nwork can be viewed as a lightweight approach.\nIn [11], Harel, Kugler and Pnueli re-investigated the syn-\nthesis problem of LSC by adopting a lightweight approach\nas well, i.e., they generate Statecharts from LSC and then\nverify them for correctness, and thus avoid undecidability.\nA similar approach is evidenced in [5], where Bontemps\nand Egyed proposed a technique coupling translation and\nveri\u0002cation to cope with undecidability. We remark that\nsuch an approach certainly works for our approach as well\nexcept that we must deal the complexity of model-checking\nof complicated distributed systems. In our approach, there\nis a cheaper way to make sure that our synthesized program\ndoes satisfy all the universal charts. That is, we generate\nSystemVerilog monitoring processes (one for each univer-\nsal chart) from the same LSC speci\u0002cation and simulate the\nprogram alongside the monitoring processes. In [20], Dong\nand Sun tackled the synthesis problem of LSC using the no-\ntion of CSP and its algebraic laws. The difference between\ntheir work and ours is that we target at concrete implemen-\ntation which favors later development.\nAcknowledgment\nHai H. Wang is supported in part by the EU-funded TAO\nproject (IST-2004-026460). Shengchao Qin is supported in\npart by the EPSRC funded project EP\/E021948\/1.\nReferences\n[1] Accellora Org. SystemVerilog 3.1a Language Ref-\nerence Manual . http:\/\/www.eda.org\/sv\/\nSystemVerilog$\\ $3.1a.pdf, 2001.\n[2] R. Alur, K. Etessami, and M. Yannakakis. Inference of Mes-\nsage Sequence Charts. In Proceedings of the 22nd Interna-\ntional Conference on Software Engineering, pages 304\u2013313.\nACM Press, 2000.\n[3] R. Alur and M. Yannakakis. Model Checking of Message Se-\nquence Charts. In Proceedings of the 10th International Con-\nference on Concurrency Theory, pages 114\u2013129. Springer,\n1999.\n[4] Y. Bontemps. Relating Inter-Agent and Intra-Agent Spec-\ni\u0002cations (The Case of Live Sequence Charts). PhD the-\nsis, Faculte\u00b4s Universitaires Notre-Dame de la Paix, Insti-\ntut d\u2019Informatique (University of Namur, Computer Science\nDept), April 2005.\n[5] Y. Bontemps, P. Heymans, and P. Schobbens. Lightweight\nFormal Methods for Scenario-Based Software Engineering.\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\nReceive&Talk\ntalk\nspeakerOff\nstartRing\nopen\nincomingCall\nCoverSpeakerChipUserEnv\nFigure 7. Existential chart\nIn S. Leue and T. Systa, editors, Scenarios, volume 3466 of\nLecture Notes in Computer Science, pages 174\u2013192, 2005.\n[6] Y. Bontemps and P. Schobbens. The Complexity of Live Se-\nquence Charts. InFoundations of Software Science and Com-\nputational Structures, 8th International Conference, FOS-\nSACS 2005, pages 364\u2013378, 2005.\n[7] Y. Bontemps, P. Schobbens, and C. Lo\u00a8ding. Synthesis of\nOpen Reactive Systems from Scenario-Based Speci\u0002cations.\nFundamenta Informaticae, 62(2):139\u2013169, July 2004.\n[8] W. Damm and D. Harel. LSCs: Breathing Life into Mes-\nsage Sequence Charts. Formal Methods in System Design,\n19(1):45\u201380, 2001.\n[9] D. Harel. Statecharts: A Visual Formulation for Complex\nSystems. Science of Computer Programming, 8(3):231\u2013274,\n1987.\n[10] D. Harel and H. Kugler. Synthesizing State-Based Object\nSystems from LSC Speci\u0002cations. International Journal on\nFoundations of Computer Science, 13(1):5\u201351, 2002.\n[11] D. Harel, H. Kugler, and A. Pnueli. Synthesis Revisited:\nGenerating Statechart Models from Scenario-Based Require-\nments. In Formal Methods in Software and Systems Model-\ning, pages 309\u2013324, 2005.\n[12] D. Harel and R. Marelly. Come, Let\u2019s Play - Scenario-Based\nProgramming Using LSCs and Play-Engine. Springer, 2003.\n[13] D. Harel and R. Marelly. Play-Engine User\u2019s Guide, 2003.\n[14] O. Haugen and K. St\u00f8len. STAIRS - Steps to Analyze In-\nteractions with Re\u0002nement Semantics. In Perdita Stevens,\nJon Whittle, and Grady Booch, editors, UML 2003, volume\n2863 of Lecture Notes in Computer Science, pages 388\u2013402.\nSpringer, 2003.\n[15] ITU. Message Sequence Chart(MSC), Nov 1999. Series Z:\nLanguages and general software aspects for telecommunica-\ntion systems.\n[16] P. Kosiuczenko and M. Wirsing. Formalizing and Executing\nMessage Sequence Charts via Timed Rewriting. Electrical\nNotes on Theoretical Computer Science, 25:1\u201325, 1999.\n[17] K. Koskimies and E. Ma\u00a8kinen. Automatic Synthesis of\nState Machines from Trace Diagrams. Softw. Pract. Exper.,\n24(7):643\u2013658, 1994.\n[18] R. Marelly, D. Harel, and H. Kugler. Multiple Instances and\nSymbolic Variables in Executable Sequence Charts. In Pro-\nceedings of OOPSLA\u201902, pages 83\u2013100, 2002.\n[19] A. Pnueli and R. Rosner. Distributed Reactive Systems are\nHard to Synthesize. In Proceedings 31st IEEE Symposium\non Foundation of Computer Science, 1990.\n[20] J. Sun and J. S. Dong. Synthesis of Distributed Processes\nfrom Scenario-Based Speci\u0002cations. In J. Fitzgerald, I. J.\nHayes, and A. Tarlecki, editors, Formal Methods 2005, vol-\nume 3582 of Lecture Notes in Computer Science, pages 415\u2013\n431. Springer, 2005.\n[21] J. Sun and J. S. Dong. Design Synthesis from Interaction\nand State-Based Speci\u0002cations. IEEE Trans. Software Eng.,\n32(6):349\u2013364, 2006.\n[22] J. Sun and J. S. Dong. From Live Sequence Charts\nto Implementation. Technical Report TRA1\/07,\nNational University of Singapore, January 2007.\nhttp:\/\/www.comp.nus.edu.sg\/\u02dcsunj\/Reports\/proof.ps.\n[23] Viet-Anh Vu Tran, Shengchao Qin, and Wei-Ngan Chin. An\nAutomatic Mapping from Statecharts to Verilog. In Zhim-\ning Liu and Keijiro Araki, editors, First International Collo-\nquium on Theoretical Aspects of Computing (ICTAC 2004),\nvolume 3407 of Lecture Notes in Computer Science, pages\n187\u2013203. Springer, 2004.\n[24] S. Uchitel and J. Kramer. A Workbench for Synthesising Be-\nhaviour Models from Scenarios. In ICSE 2001, pages 188\u2013\n197. IEEE Computer Society, 2001.\n[25] UML Group. OMG UML Version 1.5. http:\/\/www.uml.org\/,\nJune 2002.\nFirst Joint IEEE\/IFIP Symposium on Theoretical Aspects of Software Engineering(TASE'07)\n0-7695-2856-2\/07 $20.00  \u00a9 2007\n"}