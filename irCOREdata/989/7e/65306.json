{"doi":"10.1109\/APSEC.2008.72","coreId":"65306","oai":"oai:dro.dur.ac.uk.OAI2:6243","identifiers":["oai:dro.dur.ac.uk.OAI2:6243","10.1109\/APSEC.2008.72"],"title":"A heap model for Java bytecode to support separation logic.","authors":["Luo, C.","He, G.","Qin, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2008-12-01","abstract":"Memory usage analysis is an important problem for resource-constrained mobile devices, especially under mission- or safety-critical circumstances. Program codes running on or being downloaded into such devices are often available in low-level bytecode forms. We propose in this paper a formal heap model for Java bytecode language, on top of which we can then provide separation logic support for further memory usage verification. Our low-level heap model for Java bytecode would allow us to reason about the size and alignment properties of primitive values stored in the heap. To support type-related reasoning such as guaranteeing type and alignment safety, this model is also lifted with both base types and user-defined classes. Based on such model, we have also defined a separation logic proof system whose assertions are interpreted using the lifted heap with types. We envision, with further extension, the system would provide good support for memory usage analysis and verification for mobile devices","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65306.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6243\/1\/6243.pdf","pdfHashValue":"4cf8a6b4750c91ffb884c56079f857ddab7407f0","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6243<\/identifier><datestamp>\n      2010-11-08T12:01:37Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        A heap model for Java bytecode to support separation logic. <\/dc:title><dc:creator>\n        Luo, C.<\/dc:creator><dc:creator>\n        He, G.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:description>\n        Memory usage analysis is an important problem for resource-constrained mobile devices, especially under mission- or safety-critical circumstances. Program codes running on or being downloaded into such devices are often available in low-level bytecode forms. We propose in this paper a formal heap model for Java bytecode language, on top of which we can then provide separation logic support for further memory usage verification. Our low-level heap model for Java bytecode would allow us to reason about the size and alignment properties of primitive values stored in the heap. To support type-related reasoning such as guaranteeing type and alignment safety, this model is also lifted with both base types and user-defined classes. Based on such model, we have also defined a separation logic proof system whose assertions are interpreted using the lifted heap with types. We envision, with further extension, the system would provide good support for memory usage analysis and verification for mobile devices.<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        (2008). 15th Asia-Pacific Software Engineering Conference, 2-5 December 2008, Beijing, China ; proceedings. Los Alamitos, CA: IEEE, pp. 127-134<\/dc:source><dc:date>\n        2008-12-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6243<\/dc:identifier><dc:identifier>\n        doi:10.1109\/APSEC.2008.72 <\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6243\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/APSEC.2008.72<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6243\/1\/6243.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2008 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2008,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nLuo, C. and He, G. and Qin, S. (2008) \u2019A heap model for Java bytecode to support separation logic.\u2019, in 15th\nAsia-Pacific Software Engineering Conference, 2-5 December 2008, Beijing, China ; proceedings. Los Alamitos,\nCA: IEEE, pp. 127-134.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/APSEC.2008.72\nPublisher\u2019s copyright statement:\n2008 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nA Heap Model for Java Bytecode to Support Separation Logic \u2217\nChenguang Luo Guanhua He Shengchao Qin\nDepartment of Computer Science, Durham University\n{chenguang.luo, guanhua.he, shengchao.qin}@durham.ac.uk\nAbstract\nMemory usage analysis is an important problem for\nresource-constrained mobile devices, especially under\nmission- or safety-critical circumstances. Program codes\nrunning on or being downloaded into such devices are of-\nten available in low-level bytecode forms. We propose in\nthis paper a formal heap model for Java bytecode language,\non top of which we can then provide separation logic sup-\nport for further memory usage verification. Our low-level\nheap model for Java bytecode would allow us to reason\nabout the size and alignment properties of primitive val-\nues stored in the heap. To support type-related reasoning\nsuch as guaranteeing type and alignment safety, this model\nis also lifted with both base types and user-defined classes.\nBased on such model, we have also defined a separation\nlogic proof system whose assertions are interpreted using\nthe lifted heap with types. We envision, with further exten-\nsion, the system would provide good support for memory\nusage analysis and verification for mobile devices.\n1 Introduction\nAt present Java bytecode is widely applied in diverse ar-\neas. Its key features, including platform independence and\nrelative downloading security, agree with the need of the\nmarket and lead to its success.\nCurrently tens of kinds of micro-devices are running\nJava bytecode. Though with different shapes and func-\ntions, these micro-devices share some similarities. Gener-\nally, such a device has a processor and some memory to run\na Java virtual machine for downloaded bytecode to execute.\nThe resource of these micro-devices for bytecode programs,\nsuch as the memory space, is usually quite limited. A case\nin point is that many brands of mobile phones provide a\nmemory not more than one megabyte, which is several hun-\ndredth to one thousandth of that of modern personal com-\nputers. Because of this resource restriction, it is preferable\n\u2217This work is supported in part by the EPSRC project EP\/E021948\/1.\nto ensure that a piece of downloaded bytecode will not re-\nquire more memory resource than the micro-device can pro-\nvide before we actually load the code and execute it, so as to\navoid a crash due to an OutOfMemoryError. However,\nthe static analysis and verification of a bytecode\u2019s memory\nusage is a challenging topic, not only because it is difficult\nto infer accurately by a termination-guaranteed approxima-\ntion, but also because the verifier does not have access to\nthe more structured and human-readable Java source codes\nwhen working on the assembly-level bytecode.\nDespite these difficulties, there are already a few ap-\nproaches [2, 6, 8]1 for bytecode memory resource analy-\nsis. Our aim in this paper is also to provide some the-\noretical support for a proposed framework for Java byte-\ncode memory resource analysis, which consists of a seman-\ntic model, a separation logic built on it, and some verifi-\ncation and analysis mechanisms on top of the logic. Until\nnow some progress has been achieved on the latter two as-\npects [4, 11, 3]. In those works, the traditional separation\nlogic\u2019s semantic model and syntax were adapted in con-\nstructing a verification framework for heap-related proper-\nties. For more accuracy, we would like to reconstruct that\nframework upon a better mimicry of the heap for Java byte-\ncode, and hence we set up this heap model. It simulates the\ndata in the memory cells (where a piece of data can take\nup several memory cells and an object may contain many\npieces of data as its fields) and records the data\u2019s types af-\nter a lifting. We anticipate that more precise result will be\ngained with the extra expressiveness of the separation logic\nfounded on this model.\nThe main features of our proposed heap model are sum-\nmarized below:\n\u2022 It introduces a low-level model of the memory into\nseparation logic to increase its expressiveness and to\nsupport reasoning about both low-level and high-level\nproperties (such as values represented with bytes, their\ntypes and their nesting objects). Compared with this\nmodel, the one to support the traditional semantics of\nseparation logic does not care for most of these prop-\n1More discussions on these works will be given in Section 5.\n2008 15th Asia-Pacific Software Engineering Conference\n1530-1362\/08 $25.00 \u00a9 2008 IEEE\nDOI 10.1109\/APSEC.2008.72\n127\nerties like bytes in memory and variables\u2019 types.\n\u2022 It provides sufficient flexibility to cater for diverse Java\nvirtual machine implementations. To illustrate, the\nlength of a reference, or different alignments, can be\nchosen for a specified virtual machine implementation.\n\u2022 The model is loosely coupled with the axiomatic sys-\ntem, in the sense that they are explicitly distinguished\nin different levels in the whole system. Thus it is rel-\natively easy to extend the separation logic (in high-\nlevel) to facilitate reasoning about various heap prop-\nerties within the range of expressiveness of the model\n(in low-level).\nThe remainder of this paper is organized as follows. Sec-\ntion 2 illustrates the low-level crude heap model only with\nthe bytes information. Then in Section 3 it will be lifted\nwith types added to each allocated heap cell and also to the\nnon-dangling references. Section 4 focuses on the separa-\ntion logic system built on this model, which deals with as-\nsertions and Hoare triples abstracted from the heap states,\nand illustrates the application of the proof rules by an exam-\nple. The last two sections discuss related work and conclude\nthis paper.\n2 Heap with Bytes\nIn this section, we propose a memory model for Java\nbytecode. Such model will concentrate on the low-level\nmemory representation of variables and objects in Java. It\nalso acts as a foundation of our separation logic implemen-\ntation. In what follows, we will define the model itself and\nrelative functions for the model to work.\n2.1 Heap Definition\nAt a lower level, our heap model is a simulation\nof the logical memory, which is a repository numbered\nwith addresses to store primitive values in the form of\nbytes. Such primitive values can be of standard base\ntypes in bytecode, which corresponds to the BaseType =\n{B,C,D,F, I, J, S,Z, L, [} (which types represent byte,\nchar, double, float, int, long, short, boolean,\nobject reference and array reference, respectively) in the\nJava virtual machine specification.\nBased on the description above, our heap model is de-\nfined to be a mapping from memory addresses to primitive\nvalues in bytes. Hence the memory addresses and byte val-\nues should be formalized in advance:\nmax-addr = 232 \u2212 1\nmax-byte = 28 \u2212 1\nAddress = {r | r \u2208 N \u2227 r \u2264 max-addr}\nByte = {b | b \u2208 N \u2227 b \u2264 max-byte}\nwhich represents 32-bits memory address and 8-bits byte\nvalue, respectively. In the implementation of this model,\nthese parameters should be changed to cater for the real Java\nvirtual machine implementation, such as 32-bits or 64-bits\nmemory address.\nAlong with such foundations comes the definition for our\nheap model:\nheap :: Address \u21c0 Byte\nNote that we use \u21c0 for partial mappings, compared with\nthe \u2192 for total ones. For this model, given an aforesaid\nbase type, two mappings are utilized to convert any value in\nthat type to its byte representation, and vice versa:\nvalue-byte :: BaseType\u2192 Value \u2192 [Byte]\nbyte-value :: BaseType\u2192 [Byte] \u21c0 Value\nwhere BaseType is the set of all base types in bytecode,\nValue is the set of all primitive values, and [T ] is the set\nof all lists over values in type T . Note that the second map-\nping is partial since not every byte list has a corresponding\nvalue in any base type. To ensure the correct conversion,\nthe lifting of the heap will also carry the type information,\nwhich is introduced in the next section.\nBesides the relationship between primitive values and\ntheir byte forms, the size consumption of an element of base\ntypes, and the alignment of Java virtual machine, are de-\nfined as follows:\nsize-of :: BaseType \u2192 N\nalignment \u2208 N\nwhere the result is measured in bytes. For these two con-\ncepts the following axioms hold that\n0 < size-of t \u2264 max-addr\nalignment | (max-addr+1)\nwhere | is the divisibility judgment operator. These axioms\nare directly derived from the Java virtual machine specifi-\ncation, and are subject to certain implementations. As an\nexample, for Sun\u2019s 32-bits implementation of Java virtual\nmachine, we have size-of int = 4, and alignment = 8.\nThe reference type (including L and [) is the way for\nJava to deal with heap memory. In our model, a reference\ntype has an Address typed value. For the operations over\nthe reference type, since Java does not allow direct address\narithmetic (thus a developer is not able, and also does not\nneed, to add an arbitrary address value to a reference), a\nmeans to get an offset from a reference and another base\ntype is provided.\nref-plus :: Address \u2192 BaseType \u21c0 Address\nref-plus r t = r + size-of t\n128\n--\n10\n10\n21\n190\n188\n254\n202\n-\nheap-list-read\nheap-list-write\n10\n21\n190\n188\n254\n202\nbyte-value\n5386\nvalue-byte\n\u2013 889275714\n-\n-\n10\n10\n21\n190\n188\n254\n202\n-\n-\n-\nB\nS\nN\nI\nN\nN\nN\n-\nC\n-\n-\n-\n-\n-\n-\n-\n-\n-\nref-aligned\nref-aligned\nref-aligned\n(a) heap with bytes (b) heap with types\nFigure 1. An example of our model\nwhich is lifted to function to deal with a list of types:\nref-plus-list :: Address \u2192 [BaseType] \u21c0 Address\nref-plus-list r [ ] = r\nref-plus-list r (t : ts) = ref-plus-list (ref-plus r t) ts\nThis function will be useful in the field access in the follow-\ning sections.\n2.2 Heap Access\nBefore we introduce the heap access mechanism, we\nneed a function to construct a list from a series of specified\naddresses:\nheap-list-read :: Heap \u2192 Address \u2192 N\u2192 [Byte]\nheap-list-read h r 0 = [ ]\nheap-list-read h r n = if r+n > 1+max-addr then [ ]\nelse heap-list-read h r (n\u22121) ++ [h (r+n\u22121)]\nheap-list-write :: Heap\u2192 [Byte] \u2192 Address \u2192 Heap\nheap-list-write h [ ] r = h\nheap-list-write h (v : vs) r = if r+length(v : vs) > 1+\nmax-addr then h else heap-list-write (h(r \u0007\u2192 v)) vs r+1\nwhere Heap is the set of all possible heaps, ++ means list\nconcatenation, and h(r \u0007\u2192 v) stands for the same heap as\nh except that r is mapped to v. Then the operations to\nread\/write data from\/to any heap are defined as:\nheap-read :: Heap \u2192 Address \u2192 BaseType \u21c0 Value\nheap-read h r t = byte-value t\n(heap-list-read h r (size-of t))\nheap-write :: Heap \u2192 Value \u2192 Address \u2192 BaseType\n\u2192 Heap\nheap-write h v r t = heap-list-write h (value-byte t v) r\nThe composition and application of the functions are illus-\ntrated in Figure 1 (a).\nNote that in our low-level representation of the heap\nmodel, the access to the heap needs explicit specification\nof data types, since the heap itself contains no such infor-\nmation. This is an ideal simulation of the memory storage\nduring bytecode execution and useful for inferring its fea-\ntures such as size of data structures; however, as a strongly\ntyped language, Java calls for a lifting from this crude heap\nto a typed one, which is introduced in the next section.\n3 Heap with Types\nUnlike C or C++, Java virtual machine has a special re-\nquirement for its heap space. That is, no primitive value\n(such as an integer or a character) can appear solely in\nthe heap; it must be encapsulated as a field in an ob-\nject. To illustrate, a Java programmer cannot apply for\nsome space in the heap directly to fit in an integer using\nsome syntax like int i = new int();. (While in C\nor C++ a programmer is allowed to allocate any size of\nheap in any primitive type, such as int * i = (int\n*) malloc(sizeof(int)).) However, a Java user is\nable to write Integer i = new Integer(); to as-\nsign some heap space for an object of Integerwhich con-\ntains a primitive integer.\nTo simulate Java heap space, our type of heap data has\ntwo levels of meaning. First, each allocated heap cell must\nbe assigned a base type for the primitive value stored in that\ncell. Moreover, since such values should be encapsulated as\nobjects\u2019 fields, a reference, whose value corresponds to an\nobject in the heap, is linked to a series of contiguous heap\ncells holding the fields of that object.2\nAs a result, our lifting of the heap model with types com-\nprises two main issues accordingly. The first is to assign a\nbase type for each primitive value located in any allocated\nheap space. The second is to assign a class type for each\nobject allocated in the heap to enclose the primitive values\nas the fields of the object.\nFirst the types for primitive values are added to the heap\nas follows:\nheap-type :: Address \u21c0 BaseType \u222a {N,\u22a5}\nheap-type r =\n\u23a7\u23aa\u23aa\u23a8\n\u23aa\u23aa\u23a9\n\u22a5, if heap r = \u22a5;\nt \u2208 BaseType, if heap r is the first byte\nof a value typed t;\nN, otherwise.\nThus for any allocated heap portion corresponding to a\nprimitive value, the type of its first byte will be stamped\nas its base type, while the rest bytes are marked N.\nFor the analysis of a particular bytecode program, the\ntype of any primitive value on the heap can be inferred from\n2Note that the Java virtual machine requires the continuity of an ob-\nject\u2019s heap space.\n129\nthe field descriptors of a class (since this value itself must be\na field defined in some class). Therefore, during the process\nof analysis, when an instance of such class is created on\nthe heap, the location and size information of all its fields\ncan be deducted from both the instance\u2019s descriptors and\nthe reference to it. For this purpose, a mapping from heap\naddress to the type of the object located in that address is\nmaintained statically:\nref-type :: Address \u21c0 Type\nwhere Type is the set of all classes used in a program. If\nthe reference has multiple types which consist of one class\nC and all its inherited classes (but no classes extending C),\nthen ref -type will map it to its exactly defined type in the\nprogram, say, a reference defined as java.util.List\nl; will have the type Ljava\/util\/List, even it is instantiated\nas a linked list. Figure 1 (b) exemplifies this typed heap.\nAs a semantic support of the later separation logic pred-\nicate \u201cpointing-to\u201d, we will introduce the field offsets of a\nclass. By scanning a bytecode program, we may achieve a\nmapping from classes in that program to their fields and the\ntypes of their fields:\nfields-of :: Type \u2192 [Field\u00d7 BaseType]\nwhere Field is the set of possible field names, and all the ref-\nerences (regardless of objects of other classes or arrays) are\ntreated as of base types. We also make an assumption that\nthe fields are in the order which is maintained in the mem-\nory by the Java virtual machine, for example, some Java\nvirtual machine will keep an ascending sequence of an ob-\nject\u2019s fields in memory by the sizes of the fields. As an illus-\ntration, a class definition class C {int x; byte y;\nlong z;} will be mapped to a list [(y,B), (x, I), (z, J)].\nWith the fields-of mapping, the reference to a field of an\nobject on the heap (referred to by r) can be computed using\nthe functions below:\noffset :: [Field\u00d7BaseType] \u2192 Field \u2192 Address \u21c0 Address\noffset [ ] f n = \u22a5\noffset ((f, t) : fs) f n = 0\noffset ((f \u2032, t) : fs) f n = if size-of t \u2264 n then\nsize-of t + offset fs f (n\u2212 size-of t)\nelse n + offset ((f \u2032, t) : fs) f alignment\nfield-ref :: RefType \u2192 Address \u2192 Field \u21c0 Address\nfield-ref rt r f = r + reserved\n+ offset (fields-of(rt r)) f alignment\nwhere the RefType is the set of all reference type map-\npings, and reserved is the size for an object of the type\nLjava\/lang\/Object, whose value is often alignment in im-\nplementation.\nIn a similar way as above, the size of an object during\nruntime can be calculated as:\nlist-size :: [Field\u00d7 BaseType] \u2192 N\nlist-size [ ] n = 0\nlist-size ((f, t) : fs) n = if size-of t \u2264 n then\nsize-of t + list-size fs (n\u2212 size-of t)\nelse n + list-size ((f, t) : fs) alignment\nref-size :: Type \u2192 N\nref-size t = let s = list-size (fields-of t) in\nif alignment | s then reserved + s\nelse reserved + s + alignment\n\u2212 s mod alignment end\nWhen a program allocates new heap space, or all the ref-\nerences to an address are eliminated (so it should be col-\nlected as garbage), the mappings mentioned above are to be\nmodified with the following process:\nheap-type-list-clear :: HeapType \u2192 [Address] \u2192 HeapType\nheap-type-list-clear ht [ ] = ht\nheap-type-list-clear ht (r : rs) = heap-type-list-clear\nht(r \u0007\u2192 N) rs\nheap-type-write :: HeapType \u2192 Address \u2192 BaseType\n\u2192 HeapType\nheap-type-write ht r t = heap-type-list-clear ht(r \u0007\u2192 t)\n[r + 1, . . . , r\u22121+size-of(ht r)]\nwhere the HeapType contains all possible heap type map-\npings. The functions first \u201cclear\u201d the type mapping to N,\nand then write the first byte\u2019s mapping as t. Compared with\nthis, the function to change the reference\u2019s type mapping is\nsimpler, which only needs to modify the only byte\u2019s map-\nping:\nref-type-write :: RefType \u2192 Address \u2192 Type \u2192 RefType\nref-type-write rt r t = rt(r \u0007\u2192 t)\nHowever, when reasoning about the allocating or reclaiming\nan object, both functions must be utilized.\nThe type information allows us to define type-related\nguards on heaps. A type-safe guard on a field reference\nguarantees that each byte of the value pointed to by this ref-\nerence has the correct mapping of heap-type:\nheap-safe ht r = \u2203t \u2208 BaseType . ht r = t \u2227\n\u2200s \u2208 {r+1, . . . , r\u22121+size-of t} . ht s = N\nwhich can still be lifted to another guard, saying that all of\nan object\u2019s fields are correctly mapped:\nheap-list-safe ht rt r [ ] = true\nheap-list-safe ht rt r (f : fs) = heap-safe ht\n(field-ref rt r f) \u2227 heap-list-safe ht rt r fs\nref-safe ht rt r = heap-list-safe ht rt r (fields-of(rt r))\nMoreover, the Java virtual machine requires certain\nalignment of the memory addresses referred to by the ref-\nerences, which results in that each object\u2019s size must be a\n130\nmultiple of the alignment. A guard can be defined to guar-\nantee this as\nref-aligned r = alignment | r\nand it should be ensured that this guard holds for the cre-\nation of a new object.\nWith the information of both base and object types\nadded, we have founded a typed heap model lifted from the\nbyte-based low-level heap. This model guarantees the type-\nsafety and the alignment properties for bytecode execution,\nand is ready to serve as the semantics of our separation logic\nsystem.\n4 Separation Logic\nSeparation logic [7, 12] is now prevalent in reason-\ning about programs mainly concerned with reference-based\nheap models. It enhances the original Hoare logic with\nthe new logical operator, separation conjunction, to express\nheap-related program states. The separation conjunction\nfollows the idea that the heap can be divided into disjoint\nparts, and each part can be described by an assertion. If\nso, then the conjunction of such assertions is a \u201cseparation\nconjunction\u201d of them since the domains of the assertions\nare separated. In this way pointer aliases can be speci-\nfied explicitly with ease, and program reasoning can also\nbe restricted to a minimum heap part without interference\nof other parts.\nSince separation logic is a powerful contender for for-\nmal reasoning of heap-manipulating imperative programs,\nwe have utilized it in our former works to construct our ver-\nification framework for heap properties. The original in-\ntention of this work is to provide a semantic model for our\nseparation logic system to be built on and to verify and in-\nfer heap-related properties, such as size of data structures\nwhich is closely linked to program memory consumption.\nIn this section, an embedding of separation logic over\nthis memory model will be introduced. To begin with, the\nassertion language for our separation logic is as follows:\nP =df true | false | \u00acP | P\u2227P | P\u2228P | P\u21d2P | r = r\u2032 |\nP\u2217P | P\u2212\u2217P | emp | r :: C | r.f \u0007\u2192 r\u2032 | r.f \u21aa\u2192 r\u2032\nGenerally, for Java bytecode verification, the assertions\nshould describe three aspects of program runtime status: the\noperand stack, the variable stack and the heap. To focus on\nour real interest, we will pay less attention to the first part\n(which is well investigated by other works [4, 3]), and hence\nthe assertions used in our system are interpreted as functions\non Heap, HeapType and RefType to return a boolean value,\nwhich mainly concern the heap status of the program.\nemp states that no part of the heap is allocated and thus\nall the mappings are undefined:\nemp = \u03bb h ht rt . \u2200 r . h r=\u22a5 \u2227 ht r=\u22a5 \u2227 rt r=\u22a5\nr :: C is a novel assertion to specify that an object of\nclass C resides at r. Traditional separation logic does not\nhave this since its model has no type information. It is de-\nfined as\nr::C = \u03bb h ht rt . rt r=C\nOr we can still require that such assertion be safer with the\nfollowing restricted definition\nr::C = \u03bb h ht rt . rt r=C \u2227 ref-safe ht rt r \u2227 ref-aligned r\nwhich depends on user demand.\nAccording to the definition in separation logic, the se-\nmantics of the singleton heap assertion r.f \u0007\u2192 r\u2032 is that the\nheap contains exactly one cell located at r\u2032:\nr.f \u0007\u2192 r\u2032 = \u03bb h ht rt . heap-read h\n(field-ref rt r f) (ht r) = r\u2032 \u2227\ndom rt = {r} \u2227 domh = domht =\n{r + reserved, . . . , r \u2212 1 + ref-size (rt r\u2032)}\nFor the separation conjunction and implication, their se-\nmantics are direct translations from the classical ones to a\nversion in this model. First comes the definition of two op-\nerations over the three mappings for our model.\nh1\u22a5h2 = domh1 \u2229 domh2 = \u2205\nh1 unionmulti h2 = {r \u0007\u2192 a | r\u2208 domh1\u222a domh2 \u2227 (r\u2208 domh1\n\u21d2 a=h1 r \u2227 r\/\u2208 domh1 \u21d2 a=h2 r)}\nwhere the first one describes that the two heaps (modeled\nas mappings) are disjoint, and the second is a union of two\n(disjoint) heaps. Note that these operations are polymor-\nphic and thus are applicable for all three mappings (bytes\nand types). They assist in the expression of the separation\nconnectives semantics:\nP \u2217Q = \u03bb h ht rt . \u2203 h1 h2 ht1 ht2 rt1 rt2 . h1\u22a5h2\u2227\nh=h1unionmultih2 \u2227 ht1\u22a5ht2 \u2227 ht=ht1unionmultiht2 \u2227 rt1\u22a5rt2\n\u2227rt=rt1unionmultirt2 \u2227 P h1 ht1 rt1 \u2227Q h2 ht2 rt2\nP\u2212\u2217Q = \u03bb h ht rt . \u2200 h\u2032 ht\u2032 rt\u2032 . h\u22a5h\u2032 \u2227 ht\u22a5ht\u2032 \u2227 rt\u22a5rt\u2032\n\u2227P h\u2032 ht\u2032 rt\u2032 \u21d2 Q (hunionmultih\u2032) (htunionmultiht\u2032) (rtunionmultirt\u2032)\nThe following predicates do not increase the expressive-\nness of the logic, but are present for convenience or histori-\ncal reasons. The first is the intuitive \u201cpointing-to\u201d r.f \u21aa\u2192 r\u2032,\nwhich is equivalent as\nr.f \u21aa\u2192 r\u2032 = r.f \u0007\u2192 r\u2032 \u2217 true\nwhere true has its meaning based on the heap. And the\nfollowing existential \u201cpointing-to\u201d\u2019s (the pointing-to asser-\ntions with the heap value pointed to being existentially\nquantified) are also useful:\nr.f \u0007\u2192 \u2212 = \u03bb h ht rt . \u2203r\u2032 . (r.f \u0007\u2192 r\u2032) h ht rt\nr.f \u21aa\u2192 \u2212 = \u03bb h ht rt . \u2203r\u2032 . (r.f \u21aa\u2192 r\u2032) h ht rt\n131\nIn such separation logic, the Hoare triples are in the form\n{P h ht rt} S {Q h ht rt}\nwhich has a canonical semantics based on our storage\nmodel. We may omit the parameters to abbreviate them as\n{P} S {Q} for convenience if no confusion is caused.\nFor the verification of Java bytecode, the separation logic\nrules are presented according to bytecode instructions. Here\nwe still concentrate on the heap-related rules. First is the\nnew rule to allocate a new object on the heap:\n{emp} new C {\u2203 r . r :: C} (new)\nThis is a local rule which only considers the newly allo-\ncated part of the heap. Later we will see that it can be ex-\ntended to the global heap using the frame rule. Mean-\nwhile, since Java virtual machine specification does not\nspecify any memory management strategy, the newly allo-\ncated r is existentially quantified instead of calculated as a\nconcrete value.\nThe assignment rule (of object fields) in this separation\nlogic system is:\n{r.f \u0007\u2192 \u2212} putfield r.f {r.f \u0007\u2192 e} (assign-1)\nunder the assumption that r.f and e are loaded onto the\noperand stack. Since the operation does not change any\nother part of the heap except for the f of r, this local version\nof assignment can be extended to a global one as\n{r.f \u0007\u2192 \u2212 \u2217R} putfield r.f {r.f \u0007\u2192 e \u2217R} (assign-2)\nwhere R cannot mention r.f for the assertion to hold.\nMeanwhile, like the classical Hoare logic, we provide yet\nanother backward assignment rule:\n{r.f \u0007\u2192 \u2212 \u2217(r.f \u0007\u2192e\u2212\u2217P )} putfield r.f {P} (assign-3)\nThe global assignment rule is an instantiation of the\nlocal assignment and another rule of particular significance,\nviz. the frame rule, which is the bridge over local and\nglobal reasonings. It is in the following form\n{P} S {Q}\n{P \u2217R} S {Q \u2217R} (frame)\nwhere mods(S) \u2229 dom(R) = \u2205\nand deps(S) \u2229 dom(R) = \u2205.\nHere mods(S) and deps(S) represent the very part\nof heap, heap type and reference type mappings that S\nmodifies and depends on, respectively. This rule guaran-\ntees that S never modifies the (part of) heap mapping or\nheap\/reference type mappings referred to freely by R, and it\nclass Node { int value; Node next; ... }\nclass List {\nprivate Node head;\npublic void add(int i) {\nNode n = new Node(i, head);\nthis.head = n;\n}\npublic void addTwo(int i) {\nadd(i);\nadd(i);\n}\n}\nFigure 2. Java source code example\nnever depends on the two type mappings inside the domain\nof R in any of its expression. With this rule, when we rea-\nson about a triple, we can safely ignore the parts of the pre-\nand postconditions irrelative to S to focus on the minimum\nheap part that S modifies and\/or depends on. For example,\nwhen verifying a specification of a method which invokes\nother methods, if we know that these method calls refer to\ndisjoint parts of the heap, then we can verify those method\nspecifications separately and conjoin them afterwards.\nFor modular reasoning, we also need a rule to ver-\nify method invocations initiated by bytecode instruction\ninvokevirtual. Supposing that we have already ver-\nified the specification of the method to be invoked, we can\nuse it to verify the invocation, with some simple variable\nsubstitutions:\n{P} C.m : (x) {Q}\n{\u03b8(P )} invokevirtual y.m {\u03b8(Q)} (inv-v)\nwhere \u03b8 = [e, y \/ x,this] and e\nshould be loaded onto operand stack.\nAnd the class constructor\u2019s invocation is a special case\nof virtual method invocation, where the \u03b8 and e are still the\nsame as above:\n{P} C.\"<init>\" : (x) {Q}\n{\u03b8(P )} invokespecial y.\"<init>\" {\u03b8(Q)} (inv-s)\nHere is an example to illustrate the verification per-\nformed by our system. Consider the Java source code in\nFigure 2 where List.add will add one node to the head\nof the list, and List.addTwo will add two nodes to the\nlist\u2019s head at once. Figure 3 shows its compiled bytecode.\nGiven that class Node\u2019s constructor initializes its two\nfields value and next with the values from parameters,\nthe methods List.add and List.addTwo in the byte-\ncode may have the following triples as their specifications,\nrespectively:\n{this.head \u0007\u2192 r}\nList.add(int i)\n{\u2203 r1 . this.head \u0007\u2192 r1 \u2217 r1.next \u0007\u2192 r}\n132\npublic void add(int);\nCode:\n1 new Node;\n2 dup\n3 iload_1\n4 aload_0\n5 getfield head:LNode;\n6 invokespecial Node.\"<init>\":(ILNode;)V;\n7 astore_2\n8 aload_0\n9 aload_2\n10 putfield head:LNode;\n11 return\npublic void addTwo(int);\nCode:\n1 aload_0\n2 iload_1\n3 invokevirtual add:(I)V;\n4 aload_0\n5 iload_1\n6 invokevirtual add:(I)V;\n7 return\nFigure 3. Corresponding bytecode example\n{this.head \u0007\u2192 r}\nList.addTwo(int i)\n{\u2203 r1, r2 . this.head \u0007\u2192 r1\n\u2217 r1.next \u0007\u2192 r2 \u2217 r2.next \u0007\u2192 r}\nHere we present a sketch of forward verification of these\nspecifications. First, for the verification of List.add, us-\ning new rule for Line 1, we have\n{emp} new Node {\u2203 r1 . r1 :: Node}\nWith the preparation from Line 2 to Line 5 (which has little\ndirect relevance with the heap) and the inv-s rule to link the\nspecification of Node.\"<init>\"with the call site, we get\nfor Line 6 its postcondition as\n\u2203 r1 . r1.next \u0007\u2192 r\nAgain, Lines 7 to 9 are not related to the heap, but their ef-\nfects on the operand stack can be verified by other rules out\nof the scope of this paper. Following these lines, Line 10\ncan be verified using the assignment rule, with the post-\ncondition\n\u2203 r1 . this.head \u0007\u2192 r1 \u2217 r1.next \u0007\u2192 r\nto complete the verification for List.add.\nVerification for method List.addTwo mainly utilizes\nthe inv-v rule to discharge the two subgoals concerning the\ntwo invokevirtual\u2019s. The postcondition of the first fol-\nlows directly the specification of List.add as above. The\nsecond invokevirtual can also be verified in a simi-\nlar manner, except that, to change global reasoning to local\nreasoning, the frame rule should be used as\n{this.head \u0007\u2192 r2} invokevirtual\n{\u2203 r1 . this.head \u0007\u2192 r1 \u2217 r1.next \u0007\u2192 r2}\n{\u2203 r2 . this.head \u0007\u2192 r2 \u2217 r2.next \u0007\u2192 r}\ninvokevirtual\n{\u2203 r1, r2 . this.head \u0007\u2192 r1\n\u2217 r1.next \u0007\u2192 r2 \u2217 r2.next \u0007\u2192 r}\nto gain the postcondition of Line 6:\n\u2203 r1, r2 . this.head \u0007\u2192 r1\n\u2217 r1.next \u0007\u2192 r2 \u2217 r2.next \u0007\u2192 r\nwhich is also the postcondition of the method specification.\nSince our semantic model is loosely coupled with the\naxiomatic verification system, the latter is still extensible\nby adding new assertion constructs, as long as the new con-\nstruct does not exceed the expressiveness of the lower levels\nof the model. For example, we may define used-heap-size s\nto specify the heap size that is consumed by the program as\nref-size \u22a5 = 0\nsize-count :: RefType \u2192 Address \u2192 N\nsize-count rt r = if r < max-addr then ref-size (rt r)+\nsize-count rt (r+1)\nelse ref-size (rt r)\nused-heap-size s = \u03bb h ht rt . ref-size rt 0 = s\nwhere we first redefine that for ref-size, the \u201cundefined\u201d ref-\nerence types have size zero, to avoid the judgment whether\nan address has a reference type defined on it. Then the\nfunction size-count should be incorporated in the lower\nmodel (typed heap) to support our newly added assertion\nused-heap-size. With this assertion, another version of\nmethod specification for List.addTwo can be written as\n{used-heap-size s}\nList.addTwo(int i)\n{used-heap-size (s + 2\u00d7 ref-size Node)}\nwhich may be verified in an analogous way to the one\nabove, with an extra effort for the theorem prover to infer\nthat the size-count of the heap has its value changed by the\ntwo add\u2019s in the method body.\n5 Related Work\nAs is aforementioned, this work is part of an extension\nfor our former works [4, 11, 3]. Our direct motivation to\nbuild a low-level model for Java bytecode comes from Tuch\net al. [14], which has a similar idea of such a model for\n133\nthe C language. Compared with their work, our model de-\npicts not only the base types of the heap, but also the refer-\nence types due to the object-oriented essence of Java. Also\nour verification rules are based on bytecode instructions but\nnot source code. The original storage model for separation\nlogic, proposed in Reynolds [12], could be substituted with\nours in order to simulate the memory usage of bytecode ex-\necution to get more precise bounds of heap consumption.\nThere are many approaches for the verification of byte-\ncode and for its memory consumption. Due to Leroy [9], the\ndataflow analysis is a significant means utilizing the type\nalgebra to construct an order over the subtyping relation-\nship, which is a bit complicated and calls for too much re-\nsource for memory requirement analysis, however. There-\nfore, as a substitute, Klohs and Kastens [8] attempts to use\nthe proof carrying code technique to embed proof of safety\nrules and properties into the compiled bytecode and pro-\nvides an mechanism to check the proof on-card. Giambi-\nagi and Schneider [6] provides a slightly different solution\nwith a model of constraints on bytecode instructions and an\nalgorithm to operate on that model, which is similar as a\nCSP model on bytecode to some extent. Albert has two pa-\npers [1, 2] concentrating on the heap space consumption of\na bytecode program by constructing the control flow graph\nof that program and changing it to some equations and rela-\ntions to solve. Comparedwith their works, ours also focuses\non the heap memory and is adept at reasoning about the ref-\nerence relationship of objects and their fields, and heap size\nconsumption of the program. With the help of the frame-\nwork built up by Nguyen et al. [11], our system will be ca-\npable to deal with recursively defined data structures and\ntheir related algorithms.\n6 Conclusion\nIn this paper we have proposed a low-level heap model\nas the storage semantics for Java bytecode, which allows us\nto reason about the size and alignment properties of primi-\ntive values. Then this model is lifted with both base types\nand user-defined classes to support type-related reasoning,\nsuch as type and alignment safety. We have also described a\nverification system upon separation logic whose assertions\nare interpreted with such heap model with types, to verify\nthe heap-related properties of bytecode programs.\nThis paper is part (and the semantic foundation) of our\nmain work at present, which consists of an integrated frame-\nwork to analyze and verify the memory consumptions of\nJava bytecode. As we have already completed some work\nto verify programs\u2019 shape and size properties based on the\ntraditional heapmodel of separation logic [4, 11, 3], the next\nstep is to extend such work with the model presented in this\npaper to improve its expressiveness and precision.\nReferences\n[1] E. Albert, P. Arenas, S. Genaim, G. Puebla, and D. Zanar-\ndini. Cost analysis of Java bytecode. In Proceedings of 16th\nEuropean Symposium on Programming (ESOP\u201907). LNCS\n4421, Springer, March 2007.\n[2] E. Albert, S. Genaim, and M. Go\u00b4mez-Zamalloa. Heap space\nanalysis for Java bytecode. In Proceedings of the 6th Inter-\nnational Symposium on Memory Management (ISMM\u201907),\npages 105\u2013116, Montre\u00b4al, Que\u00b4bec, Canada, October 2007.\n[3] W.-N. Chin, H. Nguyen, C. Popeea, and S. Qin. Analysing\nmemory resource bounds for low-level programs. In Pro-\nceedings of the 7th International Symposium on Mem-\nory Management (ISMM\u201908), Tucson, Arizona, USA, June\n2008.\n[4] W.-N. Chin, H. Nguyen, S. Qin, and M. Rinard. Memory us-\nage verification for OO programs. In Proceedings of the 12th\nInternational Static Analysis Symposium (SAS\u201905), London,\nUK, 2005.\n[5] J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java(tm)\nlanguage specification. Addison Wesley, third edition, 2005.\n[6] P. Giambiagi, and G. Schneider. Memory consumption\nanalysis of Java smart cards. In Proceedings of the XXXI\nLatin American Informatics Conference (CLEI\u201905), pages\n12\u201323, Cali, Colombia, October 2005.\n[7] S. Isthiaq and P. O\u2019Hearn. BI as an assertion language for\nmutable data structures. In Proceedings of the 28th ACM\nSIGPLAN-SIGACT Symposium on Principles of Program-\nming Languages (POPL\u201901), London, UK, January 2001.\n[8] K. Klohs, and U. Kastens. Memory requirements of Java\nbytecode verification on limited devices. Electronic Notes in\nTheoretical Computer Science, 132 (2005): 95\u2013111.\n[9] X. Leroy. Java bytecode verification: an overview. In Pro-\nceedings of the 13th International Conference on Computer\nAided Verification (CAV\u201901). LNCS 2102, Springer, 2001.\n[10] T. Lindholm and F. Yellin. The Java(tm) virtual machine\nspecification. Addison Wesley, second edition, 1999.\n[11] H. Nguyen, C. David, S. Qin, and W.-N. Chin. Automated\nverification of shape and size properties via separation logic.\nIn Proceedings of the 8th International Conference on Veri-\nfication, Model Checking and Abstract Interpretation (VM-\nCAI\u201907), Nice, France, January 2007.\n[12] J. Reynolds. Separation logic: a logic for shared mutable\ndata structures. In Proceedings of 17th Annual IEEE Sympo-\nsium on Logic in Computer Science. Springer-Verlag, 2002.\n[13] R. Sta\u00a8rk, J. Schmid, and E. Bo\u00a8rger. Java and the Java vir-\ntual machine \u2014 definition, verification, validation. Springer-\nVerlag, 2001.\n[14] H. Tuch, G. Klein, and M. Norrish. Types, bytes, and sep-\naration logic. In Proceedings of the 34th ACM SIGPLAN-\nSIGACT Symposium on Principles of Programming Lan-\nguages (POPL\u201907), Nice, France, January 2007.\n134\n"}