{"doi":"10.1109\/FOCS.2007.53","coreId":"65734","oai":"oai:dro.dur.ac.uk.OAI2:4961","identifiers":["oai:dro.dur.ac.uk.OAI2:4961","10.1109\/FOCS.2007.53"],"title":"Parameterized proof complexity.","authors":["Dantchev, S.","Martin, B.","Szeider, S."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-10-01","abstract":"We propose a proof-theoretic approach for gaining evidence that certain parameterized problems are not fixed-parameter tractable. We consider proofs that witness that a given propositional CNF formula cannot be satisfied by a truth assignment that sets at most k variables to true, considering k as the parameter (we call such a formula a parameterized contradiction). One could separate the parameterized complexity classes FPT and W(M. Cesati, 2006) by showing that there is no fpt-bounded parameterized proof system, i.e., that there is no proof system that admits proofs of size f(k)nO(1) where f is a computable function and n represents the size of the propositional formula. By way of a first step, we introduce the system of parameterized tree-like resolution, and show that this system is not fpt-bounded. Indeed we give a general result on the size of shortest tree-like resolution proofs of parameterized contradictions that uniformly encode first-order principles over a universe of size n. We establish a dichotomy theorem that splits the exponential case of Riis's complexity-gap Theorem into two sub-cases, one that admits proofs of size f(k)nO(1) and one that does not. We also discuss how the set of parameterized contradictions may be embedded into the set of (ordinary) contradictions by the addition of new axioms. When embedded into general (DAG-like) resolution, we demonstrate that the pigeonhole principle has a proof of size 2kn2. This contrasts with the case of tree-like resolution where the embedded pigeonhole principle falls into the \"non-FPT\" category of our dichotomy.\\ud\n\\u","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65734.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/4961\/1\/4961.pdf","pdfHashValue":"b2f33d396573652eb96acb15e31c795a5b03ba06","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:4961<\/identifier><datestamp>\n      2010-11-08T12:08:03Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Parameterized proof complexity.<\/dc:title><dc:creator>\n        Dantchev, S.<\/dc:creator><dc:creator>\n        Martin, B.<\/dc:creator><dc:creator>\n        Szeider, S.<\/dc:creator><dc:description>\n        We propose a proof-theoretic approach for gaining evidence that certain parameterized problems are not fixed-parameter tractable. We consider proofs that witness that a given propositional CNF formula cannot be satisfied by a truth assignment that sets at most k variables to true, considering k as the parameter (we call such a formula a parameterized contradiction). One could separate the parameterized complexity classes FPT and W(M. Cesati, 2006) by showing that there is no fpt-bounded parameterized proof system, i.e., that there is no proof system that admits proofs of size f(k)nO(1) where f is a computable function and n represents the size of the propositional formula. By way of a first step, we introduce the system of parameterized tree-like resolution, and show that this system is not fpt-bounded. Indeed we give a general result on the size of shortest tree-like resolution proofs of parameterized contradictions that uniformly encode first-order principles over a universe of size n. We establish a dichotomy theorem that splits the exponential case of Riis's complexity-gap Theorem into two sub-cases, one that admits proofs of size f(k)nO(1) and one that does not. We also discuss how the set of parameterized contradictions may be embedded into the set of (ordinary) contradictions by the addition of new axioms. When embedded into general (DAG-like) resolution, we demonstrate that the pigeonhole principle has a proof of size 2kn2. This contrasts with the case of tree-like resolution where the embedded pigeonhole principle falls into the \"non-FPT\" category of our dichotomy.\\ud\n\\ud\n<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        (2007). 48th Annual IEEE Symposium on Foundations of Computer Science, FOCS '07, 21-23 October 2007, Providence, RI ; proceedings. Los Alamitos, CA: IEEE, pp. 150-160, IEEE Symposium on Foundations of Computer Science<\/dc:source><dc:date>\n        2007-10-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:4961<\/dc:identifier><dc:identifier>\n        doi:10.1109\/FOCS.2007.53<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/4961\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/FOCS.2007.53<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/4961\/1\/4961.pdf<\/dc:identifier><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2007,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nDantchev, S. and Martin, B. and Szeider, S. (2007) \u2019Parameterized proof complexity.\u2019, in 48th Annual IEEE\nSymposium on Foundations of Computer Science, FOCS \u201907, 21-23 October 2007, Providence, RI ;\nproceedings. Los Alamitos, CA: IEEE, pp. 150-160. IEEE Symposium on Foundations of Computer Science.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/FOCS.2007.53\nPublisher\u2019s copyright statement:\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nParameterized Proof Complexity\u2217\nStefan Dantchev, Barnaby Martin, and Stefan Szeider\nDepartment of Computer Science\nDurham University, Durham, England, UK\n[s.s.dantchev,b.d.martin,stefan.szeider]@durham.ac.uk\nAbstract\nWe propose a proof-theoretic approach for gaining evi-\ndence that certain parameterized problems are not fixed-\nparameter tractable. We consider proofs that witness that\na given propositional CNF formula cannot be satisfied by\na truth assignment that sets at most k variables to true,\nconsidering k as the parameter (we call such a formula a\nparameterized contradiction). One could separate the pa-\nrameterized complexity classes FPT and W[2] by showing\nthat there is no fpt-bounded parameterized proof system,\ni.e., that there is no proof system that admits proofs of size\nf(k)nO(1) where f is a computable function and n repre-\nsents the size of the propositional formula.\nBy way of a first step, we introduce the system of pa-\nrameterized tree-like resolution, and show that this system\nis not fpt-bounded. Indeed we give a general result on the\nsize of shortest tree-like resolution proofs of parameterized\ncontradictions that uniformly encode first-order principles\nover a universe of size n. We establish a dichotomy the-\norem that splits the exponential case of Riis\u2019s Complexity\nGap Theorem into two sub-cases, one that admits proofs of\nsize f(k)nO(1) and one that does not.\nWe also discuss how the set of parameterized contradic-\ntions may be embedded into the set of (ordinary) contradic-\ntions by the addition of new axioms. When embedded into\ngeneral (DAG-like) resolution, we demonstrate that the pi-\ngeonhole principle has a proof of size 2kn2. This contrasts\nwith the case of tree-like resolution where the embedded pi-\ngeonhole principle falls into the \u201cnon-FPT\u201d category of our\ndichotomy.\n1 Introduction\nIn recent years parameterized complexity and fixed-\nparameter algorithms have become an important branch of\nalgorithm design and analysis; hundreds of research papers\n\u2217Research supported by Engineering and Physical Sciences Research\nCouncil, UK, Projects EP\/C526120\/1 and EP\/E001394\/1.\nhave been published in the area (see, e.g., the references\ngiven in [2, 6, 8, 11]). In parameterized complexity one con-\nsiders computational problems in a two-dimensional set-\nting: the first dimension is the usual input size n, the second\ndimension is a positive integer k, the parameter. A prob-\nlem is fixed-parameter tractable if it can be solved in time\nf(k)nO(1) where f denotes a computable, possibly expo-\nnential, function. Several NP-hard problems have natural\nparameterizations that admit fixed-parameter tractability.\nFor example, given a graph with n vertices, one can check\nin time O(1.273k + nk) (and polynomial space) whether\nthe graph has a vertex cover of size at most k [3]. On the\nother hand, several parameterized problems such as CLIQUE\n(has a given graph a clique of size at least k?) are believed\nto be not fixed-parameter tractable. BOUNDED CNF SAT-\nISFIABILITY is a further problem that is believed to be not\nfixed-parameter tractable (and which will play a special role\nin the sequel): given a propositional formula in conjunctive\nnormal form, is there a satisfying truth assignment that sets\nat most k variables to true?\nParameterized complexity offers also a completeness\ntheory. Numerous parameterized problems that appear to\nbe not fixed-parameter tractable have been classified as be-\ning complete under fpt-reductions for complexity classes of\nthe so-called weft hierarchy W[1] \u2286 W[2] \u2286 W[3] \u2286 \u00b7 \u00b7 \u00b7 .\nFor example, CLIQUE and BOUNDED CNF SATISFIABILITY\nare complete for the first two levels of the weft hierarchy,\nrespectively. We will outline the basic notions of parame-\nterized complexity in Section 2.1; for an in-depth treatment\nof parameterized complexity classes and fpt-reduction we\nrefer the reader to Flum and Grohe\u2019s monograph [8].\nIt is widely believed that problems that are hard for the\nweft hierarchy are not fixed-parameter tractable. Up to now\nthere are mainly three types of evidence:\n1. Accumulative evidence: numerous problems are\nknown which are hard or complete for classes of the\nweft hierarchy, and for which no fixed-parameter al-\ngorithm has been found in spite of considerable ef-\nforts [2].\n48th Annual IEEE Symposium on Foundations of Computer Science\n0272-5428\/07 $25.00 \u00a9 2007 IEEE\nDOI 10.1109\/FOCS.2007.53\n150\n2. k-step Halting Problems for non-deterministic Turing\nmachines are complete for the classes W[1] (single-\ntape) and W[2] (multi-tape) [8]. A Turing machine is\nsuch an opaque and generic object that it does not ap-\npear reasonable that we should be able to decide if a\ngiven Turing machine on a given input has some ac-\ncepting path without looking at the paths.\n3. If a problem that is hard for a class of the weft hierar-\nchy turns out to be fixed-parameter tractable, then the\nExponential Time Hypothesis (ETH) fails, i.e., there is\na 2o(n) time algorithm for the n-variable 3-SAT prob-\nlem [9]. ETH is closely related to the parameterized\ncomplexity class M[1] which lies between FPT and\nW[1] (see [8]).\nWe propose a new approach for gaining further evidence\nthat certain parameterized problems are not fixed-parameter\ntractable. We generalize concepts of proof complexity to the\ntwo-dimensional setting of parameterized complexity. This\nallows us to formulate a parameterized version of the pro-\ngram of Cook and Reckhow [4]. Their program attempts to\ngain evidence for NP \u0004= co-NP, and in turn for P \u0004= NP, by\nshowing that propositional proof systems are not polynomi-\nally bounded. We introduce the concept of parameterized\nproof systems; in our program, lower bounds for the length\nof proofs in these new systems yield evidence that certain\nparameterized problems are not fixed-parameter tractable.\nIn propositional proof complexity one usually constructs\na sequence of tautologies (or contradictions), and shows\nthat the sequence requires proofs (or refutations) of super-\npolynomial size in the proof system under consideration.\nIn the scenario of contradictions and refutations, such se-\nquences of propositional formulas frequently encode a first-\norder (FO) sentence (such as the pigeon hole principle)\nwhere the n-th formula of the sequence states that the FO\nsentence has no model of size n. S. Riis [13] established a\nmeta-theorem that exactly pinpoints under which circum-\nstances a given FO sentence gives rise to a sequence of\npropositional formulas that have polynomial-sized refuta-\ntions in the system of tree-like resolution. Namely, if the\nsequence has not tree-like resolution refutations of polyno-\nmial size, then shortest tree-like resolution refutations have\nsize at least 2\u03b5n for a positive constant \u03b5 that only depends\non the FO sentence. Hence there is a gap between two pos-\nsible proof complexities. The case of exponential size pre-\nvails exactly when the FO sentence has no finite but some\ninfinite model.\nIn this paper we show a meta-theorem regarding the\ncomplexity of parameterized tree-like resolution. To this\naim we consider parameterized contradictions which are\npairs (F , k) where F is a propositional formula in CNF\nand k is an integer, such that F cannot be satisfied by a\ntruth assignment that sets at most k variables to true. Pa-\nrameterized contradictions form a co-W[2]-complete lan-\nguage. Hence FPT = co-W[2] = W[2] implies that there is\na proof system that admits proofs of size at most f(k)nO(1)\nfor parameterized contradictions (F , k) where n represents\nthe size of F . We call such a (hypothetical) proof system\nfpt-bounded.\nIn this paper we consider the relatively weak system\nof tree-like resolution. A parameterized tree-like resolu-\ntion refutation for a parameterized contradiction (F , k) has\nbuilt-in access to all clauses with more than k negated\nvariables as additional axioms. We show a meta-theorem\nthat classifies exactly the complexity of parameterized tree-\nlike resolution refutations for parameterized contradictions.\nOur theorem allows a refined view of the exponential case\nof Riis\u2019s Theorem: Consider the sequence \u3008C\u03c8,n\u3009n\u2208N of\npropositional formulas generated from a FO sentence \u03c8 that\nhas no finite but some infinite model. For a positive in-\nteger k we get a sequence of parameterized contradictions\n\u3008(C\u03c8,n, k)\u3009n\u2208N. We show that exactly one of the following\ntwo cases holds (and provide a criterion that decides which\none).\n2a. (C\u03c8,n, k) has a parameterized tree-like resolution refu-\ntation of size \u03b2kn\u03b1 for some constants \u03b1 and \u03b2 which\ndepend on \u03c8 only.\n2b. There exists a constant \u03b3, 0 < \u03b3 \u2264 1, such that for\nevery n > k, every parameterized tree-like resolution\nrefutation of (C\u03c8,n, k) is of size at least nk\u03b3 .\nWe establish the upper bound \u03b2kn\u03b1 via certain boolean\ndecision trees. For the lower bound nk\u03b3 we use a game-\ntheoretic argument.\nWe provide examples of FO sentences for each of the\nabove categories. In particular, the examples for the nk\u03b3\ncase (Examples 15 and 16) show that parameterized tree-\nlike resolution is not fpt-bounded.\nAs discussed, a parameterized tree-like resolution refu-\ntation for the parameterized contradiction (F , k) has access\nto all clauses with more than k negated variables as addi-\ntional axioms. However, these axioms are not considered\nto be a part of the input parameterized contradiction; rather\nthey are thought of as belonging to the resolution system\nitself (whence the \u201cparameterized\u201d in \u201cparameterized tree-\nlike resolution\u201d). In the final section of the paper, we con-\nsider how such axioms could be introduced to a parame-\nterized contradiction, thus creating an ordinary contradic-\ntion ripe for an ordinary proof system. In this manner, we\ncan embed the set of parameterized contradictions into the\nset of (ordinary) contradictions. Given a proof system, and\nconsidering the parameter to be preserved, this embedding\nitself gives rise to a parameterized proof system. The em-\nbedding we consider is well-behaved, in that it preserves\nthe complexity gap of parameterized tree-like resolution. In\n151\nparticular, the pigeonhole principle remains \u201chard\u201d \u2013 in cat-\negory (2b) \u2013 when embedded in tree-like resolution. How-\never, when considered with general (DAG-like) resolution,\nthe embedded pigeonhole principle has refutations of size\n2kn2.\nOwing to space limitations some technical proofs are\nomitted. Full proofs and further examples can be found in a\ntechnical report [5].\n2 Preliminaries\n2.1 Fixed-parameter Tractability\nIn the following let \u03a3 denote an arbitrary but fixed finite\nalphabet. A parameterized language is a set L \u2286 \u03a3\u2217 \u00d7 N\nwhere N denotes the set of positive integers. If (I, k) is in\na parameterized language L, then we call I the main part\nand k the parameter. We identify a parameterized language\nwith the decision problem \u201c(I, k) \u2208 L?\u201d and will therefore\nsynonymously use the terms parameterized problem and pa-\nrameterized language. A parameterized problem L is called\nfixed-parameter tractable if membership of (I, k) in L can\nbe deterministically decided in time\nf(k)|I|O(1) (1)\nwhere f denotes a computable function. FPT denotes the\nclass of all fixed-parameter tractable decision problems; al-\ngorithms that achieve the time complexity (1) are called\nfixed-parameter algorithms. The key point of this definition\nis that the exponential growth is confined to the parameter\nonly, in contrast to running times of the form\n|I|O(f(k)). (2)\nThere is theoretical evidence that parameterized problems\nlike CLIQUE are not fixed-parameter tractable. This evi-\ndence is provided via a completeness theory which is sim-\nilar to the theory of NP-completeness. This complete-\nness theory is based on the following notion of reductions:\nLet L1 \u2208 \u03a3\u22171 \u00d7 N and L2 \u2208 \u03a3\u22172 \u00d7 N be parameterized\nproblems. An fpt-reduction from L1 to L2 is a mapping\nR : \u03a3\u22171 \u00d7 N \u2192 \u03a3\u22172 \u00d7 N such that\n1. (I, k) \u2208 L1 if and only if R(I, k) \u2208 L2.\n2. R is computable by a fixed-parameter algorithm, i.e.,\nthere is a computable function f such that R(I, k) can\nbe computed in time f(k)|I|O(1).\n3. There is a computable function g such that whenever\nR(I, k) = (I \u2032, k\u2032), then k\u2032 \u2264 g(k).\nA parameterized complexity class C is the equivalence class\nof a parameterized problem under fpt-reductions. It is easy\nto see that FPT is closed under fpt-reductions, thus FPT is\na parameterized complexity class. Parameterized problems\nappear to have several degrees of intractability, as mani-\nfested by the weft hierarchy. The classes W[t] of this hi-\nerarchy form a chain\nFPT \u2286 W[1] \u2286 W[2] \u2286 \u00b7 \u00b7 \u00b7 \u2286 XP\nwhere all inclusions are assumed to be proper. Here XP de-\nnotes the class of problems solvable in time O(|I|f(k)); it is\nknown that FPT \u0004= XP [6]. Each class W[t] is defined as the\nequivalence class of a certain canonical weighted satisfia-\nbility problem for decision circuits. For W[2] the canonical\nproblem is equivalent to the following satisfiability prob-\nlem:\nWEIGHTED CNF SATISFIABILITY\nInstance: A propositional formula F in conjunc-\ntive normal form (CNF), and a positive integer k.\nParameter: k.\nQuestion: Can F be satisfied by a truth assign-\nment \u03c4 that sets exactly k variables to true? (k is\nthe weight of \u03c4 .)\nNote that if the clauses of the CNF formula are re-\nquired to contain at most three literals, we get the W[1]-\ncomplete problem WEIGHTED 3-CNF SATISFIABILITY. Let\nBOUNDED CNF SATISFIABILITY denote the problem ob-\ntained from WEIGHTED CNF SATISFIABILITY by allowing\ntruth assignments of weight at most k. It is easy to see that\nthis relaxation does not change the parameterized complex-\nity of the problem since BOUNDED CNF SATISFIABILITY\ncontains the W[2]-complete problem HITTING SET [6] as a\nspecial case.\nLemma 1. BOUNDED CNF SATISFIABILITY is complete for\nthe class W[2] under fpt-reductions.\nThe related problem BOUNDED 3-CNF SATISFIABILITY is\nactually fixed-parameter tractable; this explains why our\nstudy concerns W[2] and not W[1].\nAs in classical complexity theory, we can define for a\nparameterized complexity class C the complementary com-\nplexity class co-C = {L : L \u2208 C } where L = (\u03a3\u2217\u00d7N)\\L\nfor a parameterized problem L \u2286 \u03a3\u2217 \u00d7 N. Clearly FPT =\nco-FPT. It is easy to see that if C is closed under fpt-\nreductions, then so is co-C. Thus, in particular, each class\nW[t] of the weft hierarchy gives rise to a parameterized\ncomplexity class co-W[t].\n152\n2.2 Parameterized Proof Systems\nDefinition 2. Let L \u2286 \u03a3\u2217 \u00d7 N be a parameterized lan-\nguage. A parameterized proof system for L is an onto map-\nping \u0393 : (\u03a3\u22171 \u00d7N) \u2192 L for some alphabet \u03a31 where \u0393 can\nbe computed by a fixed-parameter algorithm.\nWe say that \u0393 is fpt-bounded if there exist computable\nfunctions f and g such that for every (I, k) \u2208 L there\nis (I \u2032, k\u2032) \u2208 \u03a3\u22171 \u00d7 N with \u0393(I \u2032, k\u2032) \u2264 (I, k), |I \u2032| =\nf(k)|I|O(1), and k\u2032 \u2264 g(k).\nNote that the problems of the classes W[t] of the weft\nhierarchy have fpt-bounded proof systems since the yes-\ninstances of these problems have small witnesses. Consider,\nfor example, the W[2]-complete problem L = BOUNDED\nCNF SATISFIABILITY. Let SF,\u03c4,k denote a string over some\nalphabet \u03a31 that encodes a CNF formula F together with a\nsatisfying truth assignment \u03c4 of weight \u2264 k for F . A proof\nsystem \u0393 for L can now be defined by setting \u0393(w, k) =\n(F , k) if w = SF,\u03c4,k, and otherwise \u0393(w, k) = (F0, k0)\nfor some fixed (F0, k0) \u2208 L. Evidently, \u0393 is fpt-bounded.\nHowever, the situation is different for the classes\nco-W[t]; specifically, in this case, for co-W[2]. We can wit-\nness that a CNF formula with n variables has no satisfying\nassignment of weight \u2264 k by listing all O(k \u00b7 nk) assign-\nments of weight \u2264 k, then checking that none is satisfying.\nHowever, this listing requires too much space and appar-\nently we cannot use it for the construction of an fpt-bounded\nproof system.\nLemma 3. Let C be a parameterized complexity class and\nlet L be a co-C-complete parameterized problem. If there\nis no fpt-bounded parameterized proof system for L, then\nC \u0004= FPT.\nThis result follows by a standard argument in which\nthe computation of a Turing machine is considered as a\nproof. In view of this lemma we suggest a program a` la\nCook-Reckhow for gaining evidence that the complexity\nclasses from the weft hierarchy are distinct from FPT. This\nprogram consists of showing that particular parameterized\nproof systems are not fpt-bounded. For such an approach\nwe would start with a weak system such as a parameter-\nized version of tree-like resolution. The consideration of\nstronger systems is left for future research.\n2.3 From First-Order to Propositional\nLogic\nNext we describe a translation of a FO sentence to a se-\nquence of propositional CNF formulas. We use the lan-\nguage of FO logic with equality but with neither function\nnor constant symbols. We omit functions and constants only\nfor the sake of a clearer exposition; note that we may simu-\nlate constants in a single FO sentence with added outermost\nexistential quantification on new variables replacing those\nconstants. We assume that the FO sentence is given as a\nconjunction of FO sentences, each of which is in prenex\nnormal form; thus, we need only explain the translation of\na single FO sentence in prenex normal form. The case of a\npurely universal sentence is easy \u2013 a sentence \u03c8 of the form\n\u2200x1, . . . , xk F(x1, . . . , xk)\nwhere F is quantifier-free, is translated into a sequence\nof propositional formulas in CNF \u3008C\u03c8,n\u3009n\u2208N, of which\nthe n-th member C\u03c8,n is constructed as follows. Let\n[n] = {1, 2, . . . , n}. For instantiations x1, . . . , xk \u2208 [n],\nwe can consider F(x1, . . . , xk) to be a propositional for-\nmula over propositional variables of two different kinds:\nR(xi1 , . . . , xip), where R is a p-ary predicate symbol, and\n(xi = xj). We transform F into CNF and then take the\nunion of all such CNF formulas for (x1, . . . , xk) ranging\nover [n]k. The variables of the form (xi = xj) evaluate\nto either true or false, thus we are left with variables of the\nform R(xi1 , . . . , xip) only.\nThe general case, a sentence \u03c8 of the form\n\u2200x1\u2203y1\u2200x2\u2203y2 . . . \u2200xk\u2203yk F(x1, . . . , xk, y1, . . . , yk),\ncan be reduced to the previous case by Skolemization. We\nintroduce Skolem relations Si(x1, . . . , xi, yi) for 1 \u2264 i \u2264\nk. Si(x1, . . . , xi, yi) witnesses yi for any given x1, . . . , xi,\nso we need to add Skolem clauses stating that such a witness\nalways exists, i.e.,\nn\u2228\nyi=1\nSi(x1, . . . , xi, yi) for all (x1, . . . , xi) \u2208 [n]i .\nThe original sentence can be transformed into the following\npurely universal sentence\n\u2200x1, . . . xk, y1, . . . yk\nk\u2228\ni=1\n\u00acSi(x1, . . . xi, yi) \u2228\nF(x1, . . . xk, y1, . . . yk).\nBy construction it is clear that, for FO sentences \u03c8, the CNF\nformula C\u03c8,n is satisfiable if and only if \u03c8 has a model\nof size n. Thus satisfiability questions on the sequence\n\u3008C\u03c8,n\u3009n\u2208N relate to questions on the existence of non-empty\nfinite models for \u03c8.\nRemark 4. Note that the size of C\u03c8,n with respect to some\nreasonable encoding is polynomial in n.\nExample 5. We consider (the negation of) the pigeonhole\nprinciple. Let \u03c8PHP be the conjunction of the following.\n\u2200x\u2203yR(x, y)\n\u2203y\u2200x\u00acR(x, y)\n\u2200x\u2200w\u2200y \u00acR(x, y) \u2228 \u00acR(w, y) \u2228 x = w.\n153\nWe translate this to the conjunction of the following univer-\nsal clauses\n\u2200x\u2200y \u00acS2(x, y) \u2228R(x, y)\n\u2200y\u2200x \u00acS1(y) \u2228 \u00acR(x, y)\n\u2200x\u2200y\u2200w \u00acR(x, y) \u2228 \u00acR(w, y) \u2228 x = w\ntogether with the Skolem clauses\n\u2200x\u2203yS2(x, y)\n\u2203yS1(y).\nFor x, y \u2208 [n] we now considerR(x, y), S2(x, y) and S1(y)\nto be propositional variables. C\u03c8PHP,n is therefore the system\nof clauses\n\u00acS2(x, y) \u2228R(x, y), \u00acS1(y) \u2228 \u00acR(x, y) and\n\u00acR(x, y) \u2228 \u00acR(w, y), for x, y, w \u2208 [n], w \u0004= x,\ntogether with the Skolem clauses\nn\u2228\ni=1\nS2(x, i), for x \u2208 [n], and\nn\u2228\ni=1\nS1(i).\n2.4 Parameterized Tree-like Resolution\nA literal is either a propositional variable or the negation of\na propositional variable. A clause is a disjunction of liter-\nals (and a propositional variable can appear only once in a\nclause). A set of clauses is a conjunction, i.e., it is satisfiable\nif there exists a truth assignment satisfying simultaneously\nall the clauses. Resolution is a proof system designed to\nrefute a given set of clauses, i.e., to prove that it is unsatis-\nfiable. This is done by means of a single derivation rule\nC \u2228 v \u00acv \u2228D\nC \u2228D ,\nwhich we use to obtain a new clause from two already exist-\ning ones. The goal is to derive the empty clause \u2013 resolution\nis known to be sound and complete, i.e., we can derive the\nempty clause from the initial clauses if and only if the initial\nset of clauses was unsatisfiable.\nIn this paper, we shall work with a restricted version of\nresolution, namely tree-like resolution. In tree-like resolu-\ntion we are not allowed to reuse any clause that has already\nbeen derived, i.e., we need to derive a clause as many times\nas we use it (this, of course, does not apply to the initial\nclauses). In other words, a tree-like resolution refutation\ncan be viewed as a binary tree whose nodes are labeled\nwith clauses. Every leaf is labeled with one of the origi-\nnal clauses, every clause at an internal node is obtained by\na resolution step from the clauses at its two children nodes,\nand the root of the tree is labeled with the empty clause. We\nmeasure the size of a tree-like resolution refutation by the\nnumber of nodes.\nIt is not hard to see that a tree-like resolution refutation\nof a given set of clauses is equivalent to a boolean deci-\nsion tree solving the search problem for that set of clauses.\nThe search problem for an unsatisfiable set of clauses is\ndefined as follows (see, e.g., Kraj\u0131\u00b4c\u02c7ek\u2019s book [10]): given\na truth assignment, find a clause which is falsified under\nthe assignment. A boolean decision tree solves the search\nproblem by querying values of propositional variables and\nthen branching on the answer. Without loss of generality,\nwe may assume that no propositional variable is questioned\ntwice on the same branch and that a branch of the tree is\nclosed as soon as a falsified clause is found, under the partial\nassignment \u2013 conjunction of facts \u2013 obtained so far along\nthat branch. When a branch is thus closed we say that an\nelementary contradiction has been obtained. Note that we\nconsider a node of the decision tree to be labeled by the con-\njunction of facts thus far obtained together with the propo-\nsitional variable there questioned. This is analogous to a\nnode in a tree-like resolution refutation being labeled with\nits clause together with the variable just resolved. Given\nthe equivalence between tree-like resolution refutations and\nboolean decision trees, we shall concentrate on the latter.\nWhenever we need to show that there is a certain tree-like\nresolution refutation of some unsatisfiable set of clauses, we\nshall construct a boolean decision tree for the correspond-\ning search problem. On the other hand, whenever we claim\na tree-like resolution lower bound, we shall prove it by an\nadversary argument against any boolean decision tree which\nsolves the search problem.\nWe give working definitions of parameterized contradic-\ntion and parameterized tree-like resolution, which we shall\nuse to state and prove the complexity gap for parameterized\ntree-like resolution.\nDefinition 6. A parameterized contradiction is a pair (F , k)\nwhere F is a propositional CNF formula and k is a positive\ninteger such that F has no satisfying assignment of weight\nat most k.\nExample 7. Let us consider an undirected graph G =\n(V,E) that does not have a vertex cover of size\u2264 k. We in-\ntroduce a propositional variable pv for every vertex v \u2208 V .\nThen the pair\n(\u2227\n{u,v}\u2208E(pu \u2228 pv), k\n)\nis a parameterized contradiction.\nLet PARAMETERIZED CONTRADICTIONS be the lan-\nguage of parameterized contradictions. Note that PA-\nRAMETERIZED CONTRADICTIONS is the complement of\nBOUNDED CNF SATISFIABILITY and, as such, is co-W[2]-\ncomplete under fpt-reductions.\nWe can now define a parameterized version of tree-like\nresolution. As we have already explained, we shall give the\ndefinition in terms of boolean decision trees.\n154\nDefinition 8. Given a parameterized contradiction P =\n(F , k), a parameterized boolean decision tree is a deci-\nsion tree that queries values of propositional variables and\nbranches on the answers; a branch of the tree is closed as\nsoon as (1) or (2) happens:\n(1) an elementary contradiction is reached, i.e., the par-\ntial assignment obtained along the branch falsifies F;\n(2) the partial assignment obtained along the branch has\nmore than k propositional variables set to true, i.e., has\nweight > k.\nThe fact that we can close branches by criterion (2) is\nequivalent to our having, built-in as axioms, all clauses of\nmore than k negated variables. This represents the differ-\nence between parameterized boolean decision trees and (or-\ndinary) boolean decision trees; hence also the difference\nbetween parameterized tree-like resolution and (ordinary)\ntree-like resolution.\n3 Complexity Gap for Parameterized Tree-\nlike Resolution\nWe first recall the complexity gap theorem for tree-like res-\nolution proven by Riis [13].\nTheorem 9. Given a FO sentence \u03c8 which fails in all finite\nmodels, consider its translation into a sequence of proposi-\ntional CNF contradictions \u3008C\u03c8,n\u3009n\u2208N. Then either 1 or 2\nholds:\n1. C\u03c8,n has polynomial-size in n tree-like resolution refu-\ntations.\n2. There exists a positive constant \u03b5 such that for every n,\nevery tree-like resolution refutation of C\u03c8,n is of size at\nleast 2\u03b5n.\nFurthermore, 2 holds if and only if \u03c8 has an infinite model.\nIn the parameterized setting, one can hope that the sec-\nond case above, the hard one, splits into two subcases. This\nis indeed true as we shall prove the following complexity\ngap theorem for parameterized tree-like resolution:\nTheorem 10. Given a FO sentence \u03c8, which fails in all\nfinite models but holds in some infinite model, consider the\nsequence of parameterized contradictions \u3008D\u03c8,n,k\u3009n\u2208N =\n\u3008(C\u03c8,n, k)\u3009n\u2208N where \u3008C\u03c8,n\u3009n\u2208N is the translation of \u03c8 al-\nready defined. Then either 2a or 2b holds:\n2a. D\u03c8,n,k has a parameterized tree-like resolution refu-\ntation of size \u03b2kn\u03b1 for some constants \u03b1 and \u03b2 which\ndepend on \u03c8 only.\n2b. There exists a constant \u03b3, 0 < \u03b3 \u2264 1, such that for\nevery n > k, every parameterized tree-like resolution\nrefutation of D\u03c8,n,k is of size at least nk\u03b3 .\nFurthermore, 2b holds if and only if \u03c8 has an infinite model\nwhose induced hypergraph has no finite dominating set.\nBy proving that Case 2b can be attained (see Examples\n15 and 16), and bearing in mind Remark 4, we derive the\nfollowing as a corollary.\nCorollary 11. Parameterized tree-like resolution is not fpt-\nbounded.\nIf we could prove that no parameterized proof system for\nPARAMETERIZED CONTRADICTIONS is fpt-bounded, then\nwe would have derived W[2] \u0004= FPT.\nBefore we prove Theorem 10, we need to give some def-\ninitions. For a model M , let |M | denote the universe of\nM . Given a model M of a FO sentence \u03c8, either finite or\ninfinite, the hypergraph induced by the model M has the\nelements of |M | as vertices and as hyperedges those sets\n{y1, . . . yl} such that (y1, . . . , yl) appears as a tuple in some\nrelation. (Recall that there are two kinds of relations \u2013 the\nextensional R relations which are present in the original\nFO sentence, and the S relations that we introduce when\nSkolemizing the sentence \u2013 both give rise to hyperedges.)\nA set of vertices is independent if it contains no hyperedge\nas a subset. Given a set X of vertices, a vertex y \/\u2208 X , and a\nset A such that X \u222a {y} \u2286 A \u2286 |M |, we say that y is A-in-\ndependent from X if and only if (i) there is no self-loop {y}\nat y, and (ii) there is no hyperedge E \u2286 A which contains y\nand intersects with X . We say that y is independent from X\nif y is |M |-independent from X; otherwise we say that X\ndominates y. Finally, a dominating set is a set X of vertices\nthat dominates every other vertex of the hypergraph.\n3.1 Case 2a of Theorem 10\nWe provide an overview of the proof method. We begin by\ndescribing the method involved in the proof of Case 1 of\nTheorem 9, before suggesting how this can be amended for\nCase 2a of Theorem 10. Whilst we do not allow constants\nin our signatures, we do refer to those elements that have\nbeen questioned in the decision tree as constants.\nFor Case 1 of Theorem 9, we construct a certain deci-\nsion tree to refute the FO sentence \u03c8. The questions of the\ndecision tree fall into two categories: I) boolean questions\non the truth of (extensional) relations R on the already wit-\nnessed constants, and II) questions that ask for a witness to\nalready witnessed constants in Skolem relations S. In the\nlatter case the potential witness may be one of the already\nwitnessed constants, or it may be a new constant. The im-\nportant point is that this decision tree is finite \u2013 of height\nh and never involving more than m constants \u2013 for, if it\nwere not, it would imply the existence of an infinite model\nfor \u03c8. It is relatively straightforward to turn this FO deci-\nsion tree into a boolean decision tree, for each propositional\n155\nC\u03c8,n, of size at most (max{m,n})h, i.e., polynomial in n\nas claimed.\nFor Case 2a of Theorem 10, we construct a certain differ-\nent decision tree to refute the FO sentence \u03c8 in a parameter-\nized setting. This decision tree adds new constants in pairs,\nunder the additional assumption that the second new con-\nstant is independent from both the first new constant and the\nset of constants already witnessed. We are able to demon-\nstrate that this tree is finite \u2013 of height h and never involving\nmore than m constants \u2013 so long as all models of \u03c8 have a\nfinite dominating set. Again, we are able to turn this into a\nparameterized boolean decision tree, for each propositional\nD\u03c8,n,k, of size at most (mabh)knh, where a is the maxi-\nmum arity of any relation of \u03c8 and b is the number of rela-\ntions of \u03c8 (including Skolem relations in both cases). The\nresult follows.\nWe conclude this section with an example of Case 2a of\nTheorem 10. This specimen provides a somewhat trivial in-\nstance, having, as it does, parameterized tree-like resolution\nrefutations not just polynomial in n, but actually indepen-\ndent of n. There are examples for Case 2a which are non-\ntrivial insofar as there the size of a smallest parameterized\ntree-like refutation depends on n (see [5]).\nExample 12. We consider the (negation of the) least number\nprinciple for total orders. Let \u03c8LNP1 be the conjunction of\nthe following.\n\u2200x \u00acR(x, x) (antireflexivity)\n\u2200x\u2200y \u00acR(x, y) \u2228 \u00acR(y, x) (antisymmetry)\n\u2200x\u2200y\u2200z \u00acR(x, y) \u2228 \u00acR(y, z) \u2228R(x, z) (transitivity)\n\u2200x\u2200yR(x, y) \u2228R(y, x) (totality)\n\u2200y\u2203x R(x, y) (no least element)\nAll models of \u03c8LNP1 have a dominating set of size 1;\nmoreover, every element of the model constitutes such\na dominating set. It is straightforward to verify that\n\u3008D\u03c8LNP1 ,n,k\u3009n\u2208N has parameterized tree-like resolution\nrefutations of size 2k, independent from n.\n3.2 Case 2b of Theorem 10\nWe now turn our attention to proving Case 2b of Theo-\nrem 10. Our argument will be facilitated by a game based\non those described by Pudla\u00b4k [12] and Riis [13] in which\nProver (female) plays against Adversary (male). In this\ngame, a strategy for Prover gives rise to a parameterized\nboolean decision tree on a set of clauses. Prover questions\nthe propositional variables that label the nodes of the tree\nand Adversary attempts to answer these so as neither to vi-\nolate any specific clause nor to have conceded that more\nthan k variables are true (\u000e), for in either of these situations\nProver is deemed the winner. Of course, assuming the set\nof clauses was unsatisfiable, Adversary is destined to lose:\nthe question is how large he can make the tree in the pro-\ncess of losing. Note that each branch of the tree corresponds\nto a play of this game, hence each parameterized decision\ntree corresponds to a Prover strategy. We will be concerned\nwith Adversary strategies that perform well over all Prover\nstrategies, and hence induce a lower bound on all parame-\nterized decision trees and, consequently, all parameterized\ntree-like resolution refutations.\nWhen considering a certain Prover strategy \u2013 a parame-\nterized decision tree \u2013 we will actually consider only a cer-\ntain subtree in which the missing branches correspond to\nplaces where Adversary has simply given up, already con-\nceding the imminent violation of a clause. In this way, there\nare two types of non-leaf nodes in this subtree, those of out-\ndegree 1 in which Adversary\u2019s decision was forced (because\nhe conceded defeat on the alternative valuation) and those of\nout-degree 2 in which he is happy to continue on either out-\ncome. In the latter case, we may consider that he has given\nProver a free choice as to the value of the relevant variable.\nThe free choice nodes play a vital role in ensuring the large\nsize of this subtree, which in turn places a lower bound on\nthe size of the parameterized decision tree of which it is a\nsubset.\nLet C\u03c8,n be the propositional translation of some FO sen-\ntence \u03c8 which has no finite models, but holds in some infi-\nnite model. We formally define the game G(C\u03c8,n, k) as fol-\nlows. At each turn Prover selects a propositional variable\nof C\u03c8,n that she has not questioned before, and Adversary\nresponds either by answering that the variable is true (\u000e) or\nthat it is false (\u22a5), or by allowing Prover a free choice over\nthose two. The Prover wins if at any point she holds infor-\nmation that contradicts a clause of C\u03c8,n or she holds more\nthan k variables evaluated true. In this formalism, given a\nProver strategy on her moves, and considering both possi-\nbilities on the free choice nodes, we generate a game tree,\nthe subtree of the parameterized decision tree alluded to in\nthe previous paragraph.\nHenceforth, we consider only the case in which some\nmodel of \u03c8 has no finite dominating set. We will give a\nstrategy for Adversary in the game G(C\u03c8,n, k) that guaran-\ntees a large game tree for all opposing Prover strategies.\nAdversary\u2019s Strategy At any point in the game \u2013 node in\nthe game tree \u2013 Adversary will have conceded certain infor-\nmation to Prover. He always has in mind two disjoint sets\nof already mentioned constants P and Q on which he has\nconceded certain information: initially these sets are both\nempty. The set Q is to be a (P \u222aQ)-independent set whose\nmembers are also (P \u222a Q)-independent from P . In some\nsense P is the only set of constants for which Adversary has\nactually conceded an interpretation; all he concedes of Q is\nthat it is a floating set with certain independence properties.\nIf X is a set of constants, let MX be the class of models\n156\nof \u03c8 that are consistent with the information Adversary has\nconceded on X . At each point Prover will ask Adversary\na question of the form Ri(c) or Sj(c). The Adversary an-\nswers as follows:\nI. If all constants of c are in P , then Adversary should\nchoose some model in MP and answer according to\nthat.\nII. If all constants of c are in P \u222a Q, and there is at least\none from Q, then Adversary should answer false (\u22a5).\nIII. If some constant in c is not in P \u222aQ then\n\u2013 if no model in MP satisfies the question, then\nAdversary should answer false (\u22a5), otherwise\n\u2013 he should give Prover a free choice on the ques-\ntion.\nIn all cases the sets P and Q remain the same, except in\nCase III Part 2. If the Prover chooses true (\u000e), then Adver-\nsary places all the constants of c in P , possibly removing\nsome from Q in the process. If the Prover chooses false\n(\u22a5), then Adversary places any constants in c that are not\nalready in P \u222a Q into Q. It turns out that, in Cases II and\nIII, the situation never arises in which Adversary is forced\nto answer true. In particular, in Case III, it will never be\nthe case that all models in MP satisfy the question. This\nis vital to the success of Adversary\u2019s strategy, and we will\nreturn to it later. We must now prove that this strategy leads\nto a large parameterized decision tree; we will need the fol-\nlowing lemma.\nLemma 13. Consider any path in the game tree of\nG(C\u03c8,n, k) from the root to a leaf. If there are k or fewer\npropositional variables evaluated to true by the leaf, then\nevery one of the n constants must have appeared in a free\nchoice node along that path.\nProof. We give a sketch proof of the lemma; for a fuller\nexplanation, see Riis\u2019s paper [13]. It is important to see\nthat Adversary plays faithfully according to some (infinite)\nmodels of \u03c8, because this means that an elementary con-\ntradiction can only be reached by the violation of a Skolem\nclause. In order to see that Adversary plays so, it becomes\nnecessary to explain why in Case II of his strategy he never\nloses any of his putative models MP and why in Case III\nhe is never forced to answer true (\u000e).\nIn Case II, Adversary never loses a model M in MP\nbecause Q can always be chosen to be independent, and\nindependent from P . Indeed, if such an interpretation is put\non Q in M , then Adversary\u2019s answer is forced to be false\n(\u22a5).\nSuppose, in Case III, that Adversary were forced to an-\nswer true (\u000e), i.e., all models M inMP satisfy the question\nRi(c) or Sj(c). By the floating nature of all elements that\nare not in P this would generate a finite dominating set of\nP \u222aQ on M . Let us dwell on this point further. Let c\u2032 be the\nsubtuple of c consisting of those constants of the latter that\nare not inP\u222aQ. Some of the constants of c\u2032 could have been\nmentioned in questions before, but only in ones for which\nAdversary\u2019s response had been forced false. Suppose that\nP \u222aQ were not a dominating set for M , then there exists an\nelement x \u2208 M , independent from P \u222aQ. But this element\nis such that it can fill the tuple c\u2032 and falsify Ri(c) or Sj(c)\nin M (and falsify any questions that previously involved it,\nwhich had already been answered false). This contradicts\nthe question having been forced true in the first place.\nRecalling that we can only reach an elementary contra-\ndiction by the violation of a Skolem clause, we can now\ncomplete the proof. Let c\u2032 be a constant that never appears\nin a free choice node in our game tree. In order to violate a\nSkolem clause, Adversary must have denied some S(c, x),\nfor each of the n constants substituted for x. But that his\ndenial of S(c, c\u2032) was forced implies a contradiction. Since\nc\u2032 is uninterpreted in any of the models in MP , it follows\nthat S(c, c\u2032\u2032) is false for all c\u2032\u2032 in any model in MP . This\ntells us thatMP is empty and, consequently, that \u03c8 had no\ninfinite model.\nWe are now in a position to argue the key lemma in this\nsection.\nLemma 14. Let a be the maximum arity of any relation in \u03c8\nand suppose that there are no more than b different relations\nin the propositional translation of \u03c8 (including Skolem re-\nlations in both cases). Following the strategy that we have\ndetailed for the game G(C\u03c8,n, k), and with p and q the car-\ndinality of the sets P and Q, respectively, Adversary cannot\nlose while both p < k1\/ab and p + q < n.\nProof. Consider the game tree of G(C\u03c8,n, k). Note that Ad-\nversary only answers true in the case that all involved con-\nstants are then added to his set P , or, of course, were already\nthere. Thus, at a certain node in the game tree, the number\nof true answers given is trivially bounded by the size of the\nset of all possible questions on P , which is certainly bound\nby pab. Hence, whilst pab < k, there must be fewer than\nk propositional variables evaluated to true. Furthermore, if\np + q < n at this node, then not all of the n constants can\nhave appeared in a free choice (since constants that have ap-\npeared in a free choice are necessarily added to either P or\nQ). It follows from the previous lemma that Adversary has\nnot yet lost.\nWe are now in a position to settle Case 2b.\nProof of Case 2b, Theorem 10. We aim to provide a lower\nbound on the size of any game tree for G(C\u03c8,n, k). Since\na lower bound on the size of a game tree induces a lower\n157\nbound on the size of a parameterized boolean decision tree,\nthe result follows.\nConsider a game tree for G(C\u03c8,n, k). Recall that, at any\nnode in this tree, Adversary has in mind two sets P and Q,\nof size p and q, respectively, and, by the previous lemma,\nwhilst p < k1\/ab and p + q < n, he has not lost. Consider,\ntherefore, any node in this game tree and the sets P and\nQ that Adversary there has in mind. Let S(p, q) be some\nmonotonic decreasing function that provides a lower bound\non the size of the subtree of the game tree rooted at the\nchosen node; whence S(0, 0) is a lower bound on the size\nof the game tree itself. In showing that S(p, q) satisfies the\nrecurrence relation\n\u2022 S(p, q) \u2265 S(p + a, q) + S(p, q + a) + 1, with\n\u2022 S(p, q) \u2265 0, when p \u2265 k1\/ab or p + q \u2265 n,\nwe are able to derive the following statement.\nLet n, k, a and b be positive integers such that (i.) a \u2265 2;\n(ii.) n > k; (iii.) n \u2265 7a + 1; (iv.) k1\/ab \u2265 (16a2)2; then\nS(0, 0) \u2265 nk\u03b3 where \u03b3 := 1\/16a3b.\nThe result follows immediately from this statement for suf-\nficiently large k (\u2265 (16a2)2ab) and n (\u2265 7a+1). By noting\nthat all parameterized boolean decision trees of Case 2b are\nof size \u2265 2, we can modify the given \u03b3 to one that works\nfor all n, k \u2265 1. Note that the assumption that (maximum\narity) a \u2265 2 is innocuous \u2013 there are no unary FO sentences\n\u03d5 which have no finite models but possess an infinite one,\ntherefore we would be in neither Case 2a nor Case 2b.\nExample 15. We consider the (negation of the) least number\nprinciple for partial orders. Let \u03c8LNP\u221e be the conjunction\nof the FO clauses given in Example 12 without the fourth\nclause (totality). \u03c8LNP\u221e has models without a finite dom-\ninating set. For example, if Z is the set of integers, then\nN\u00d7 Z under the strict partial ordering\n(n, z) \u227a (n\u2032, z\u2032) if and only if n = n\u2032 and z < z\u2032\nprovides such a model.\nExample 16. We return to the sentence \u03c8PHP defined in Ex-\nample 5. This has models without a finite dominating set:\nfor example the positive integers N, with R(x, y) \u21d4 y =\nx + 1, provides such a model.\n4 Embedding into Ordinary Proof Systems\nGiven a parameterized contradiction (F , k) we may attempt\nto derive an (ordinary) contradiction F \u2032 by directly axiom-\natizing the fact that no more than k variables of F may be\nset to true. We may then use an ordinary proof system to re-\nfute F \u2032. Considering the parameter preserved, we obtain\nfrom this embedding a new parameterized proof system.\nFormally, let PCON and CON be the classes of parameter-\nized contradictions and (ordinary) contradictions, respec-\ntively. Let e : PCON \u2192 CON be some injection such\nthat the range of e, and e\u22121 on that range, are polynomial-\ntime computable. let \u03a31 be some proof alphabet and let\n\u0393 : \u03a3\u22171 \u2192 CON be a proof system for CON. It follows that\n\u0393\u2032 : \u03a3\u22171 \u00d7 N \u2192 PCON given by\n\u0393\u2032(w, k) :=\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n(F , k) if \u0393(w) in range of e\nand (F , k) = e\u22121(\u0393(w));\n(F\u22a5, k) otherwise.\nis a parameterized proof system (where F\u22a5 is some fixed\ncontradiction, say v \u2227 \u00acv).\nNaive embeddings Suppose the variables of F are\nv1, . . . , vn; it follows that the size of F is at least n. We\nmight try to incorporate the set Nk (respectively, N \u2032k) of all\nclauses involving more than k (respectively, exactly k + 1)\nnegated variables. Both of these fail \u2013 though the latter\nless spectacularly \u2013 since the function given by (F , k) \u0014\u2192\n(F \u222a Nk) (respectively, (F , k) \u0014\u2192 (F \u222a N \u2032k)) is not fpt-\nbounded. This is because both Nk and N \u2032k are of size\n\u2265 nk+1. Consequently all proofs in this proof system fall\ninto the \u201chard\u201d category with size at least nk+1.\nEmbedding using auxiliary variables Another possibil-\nity involves the use of new auxiliary variables qvi,j for\ni \u2208 [n] and j \u2208 [k]. We now add pigeonhole clauses\n\u00acvi \u2228\n\u2228k\nl=1 qvi,l and \u00acqvi,j \u2228 \u00acqvi\u2032 ,j for i, i\u2032 \u2208 [n] (i \u0004= i\u2032)\nand j \u2208 [k]. Denote this set of clauses by N \u2032\u2032k . These\nclauses essentially specify a weak pigeonhole principle\nfrom n to k and it is fairly straightforward to see that they\ncan only be satisfied if no more than k of the variables vi is\ntrue.\nThis method of auxiliary variables results in a parameter-\nized proof system whose behavior with respect to tree-like\nresolution is similar to that of parameterized tree-like res-\nolution. Since the clauses N \u2032k can be derived from these\naxioms in a subtree of size 2k!, the \u201ceasy\u201d case (2a) is pre-\nserved, up to a possible factor of 2k!. Also the \u201chard\u201d case\n(2b) remains via the same proof.\nWe have not defined a system of parameterized resolu-\ntion, but such a definition would be a straightforward gener-\nalization. It is not clear what the complexity of the pigeon-\nhole principle would be in this system, but we can settle\nthe complexity of the pigeonhole principle when embedded\ninto resolution via the method of auxiliary variables. Re-\ncalling that the pigeonhole principle falls in the \u201chard\u201d case\n(2b) for parameterized tree-like resolution (and also when\nembedded into tree-like resolution via the method of auxil-\niary variables), it is perhaps surprising that the pigeonhole\n158\nprinciple falls into the \u201ceasy\u201d case (2a) when embedded into\nresolution.\nProposition 17. Using the method of auxiliary variables,\nthere is a resolution refutation of the (negation of the) pi-\ngeonhole principle of size 2kn2.\nProof. Note that the case k \u2265 n is straightforward; assume\nthat k < n. We recall from Example 5 that the axioms are\nF := C\u03c8PHP,n =\n\u00acS2(i, j) \u2228R(i, j), \u00acS1(j) \u2228 \u00acR(i, j) and\n\u00acR(i, j) \u2228 \u00acR(i\u2032, j), for i, i\u2032, j \u2208 [n], i \u0004= i\u2032,\nn\u2228\nj=1\nS2(i, j), for i \u2208 [n], and\nn\u2228\ni=1\nS1(i).\nLet V be the set of variables appearing in these axioms. We\nnow add the auxiliary clauses N \u2032\u2032k :=\n\u00ac\u03b1 \u2228\nk\u2228\nl=1\nq\u03b1,l and \u00acq\u03b1,j \u2228 \u00acq\u03b1\u2032,j\nfor \u03b1, \u03b1\u2032 \u2208 V , \u03b1 \u0004= \u03b1\u2032, and j \u2208 [k]. It is worth noting that,\nsince k < n, the clauses \u00acS1(j)\u2228\u00acR(i, j) and\n\u2228n\ni=1 S1(i)\nare not needed for a resolution refutation.\nIn order to generate a resolution refutation ofF\u222aN \u2032\u2032k we\nwill consider the behavior of some further new variables.\nFor i \u2208 [n] and j \u2208 [k], define:\nrij \u2261\nn\u2228\nl=1\nqR(i,l),j\nIt is not hard to see that the variables rij themselves specify\na weak pigeonhole principle from n to k and it is this prop-\nerty that we will exploit. Consider the set of clauses F \u2032\u2032 :=\n(\u00acrij \u2228 \u00acri\u2032j) and\n\u2228k\nj=1 rij , for i, i\u2032 \u2208 [n], i \u0004= i\u2032, and\nj \u2208 [k]. It is known that there exists a resolution refutation\nF \u2032\u2032 of size 2k such that no clause (other than the axioms)\ncontains more than one negated variable [1]. We will con-\nvert this refutation into one forF\u222aN \u2032\u2032k of size at most 2kn2.\nFirst we will show how to derive any axiom of F \u2032\u2032 from\nF \u222aN \u2032\u2032k . The axioms \u00acrij \u2228\u00acri\u2032j are already present as n2\ndifferent axioms of N \u2032\u2032k :\n\u00acrij \u2228 \u00acri\u2032j \u2261\n\u2227n\nl=1 \u00acqR(i,l),j \u2228\n\u2227n\nl\u2032=1 \u00acqR(i\u2032,l\u2032),j\n\u2261 \u2227nl=1\n\u2227n\nl\u2032=1(\u00acqR(i,l),j \u2228 \u00acqR(i\u2032,l\u2032),j)\nThe axioms\n\u2228k\nj=1 rij \u2261\n\u2228k\nj=1\n\u2228n\nl=1 qR(i,l),j may be gener-\nated only a little more circuitously. The axiom\n\u2228n\nj=1 R(i, j)\nmay be derived by resolving\n\u2228n\nj=1 S2(i, j) with n instances\nof \u00acS2(i, j) \u2228 R(i, j), i.e., 1 \u2264 j \u2264 n. Now this can be\nresolved with n instances of \u00acR(i, j) \u2228\u2228kl=1 qR(i,j),l, i.e.,\n1 \u2264 j \u2264 n.\nWe now demonstrate how one may simulate a resolution\nstep on the F \u2032\u2032 clauses in the F \u222aN \u2032\u2032k clauses. For this part\nit is crucial that the resolution on F \u2032\u2032 contains no clauses\nwith more than two negated literals. We will first consider\nthe simplest case in which one of the clauses to be resolved\nis strictly positive and the other contains a single negated\nvariable, that is they are of the form:\n(ri1j1 \u2228 ri2j2 \u2228 . . . \u2228 ritjt) \u2261\u2228n\nl=1 qR(i1,l),j1 \u2228\n\u2228n\nl=1 qR(i2,l),j2 \u2228 . . . \u2228\n\u2228n\nl=1 qR(it,l),jt\nand\n(\u00acri1j1 \u2228 ri\u20322j\u20322 \u2228 . . . \u2228 ri\u2032t\u2032 j\u2032t\u2032 ) \u2261\u2227n\nl=1 \u00acqR(i1,l),j1 \u2228\n\u2228n\nl=1 qR(i\u20322,l),j\u20322 \u2228. . .\u2228\n\u2228n\nl=1 qR(i\u2032t\u2032 ,l),j\n\u2032\nt\u2032\nIt is clear that the second of these is equivalent to (and may\nbe simulated by) the system of n clauses\n\u00acqR(i1,1),j1 \u2228\n\u2228n\nl=1 qR(i\u20322,l),j\u20322 \u2228 . . . \u2228\n\u2228n\nl=1 qR(i\u2032t\u2032 ,l),j\n\u2032\nt\u2032\n.\n.\n.\n\u00acqR(i1,n),j1 \u2228\n\u2228n\nl=1 qR(i\u20322,l),j\u20322 \u2228 . . . \u2228\n\u2228n\nl=1 qR(i\u2032t\u2032 ,l),j\n\u2032\nt\u2032\nIt should be clear that even the extreme case, of two negated\nliterals in each clause, may be simulated by a system of n2\nclauses.\nEach clause in the resolution refutation of F \u2032\u2032 may now\nbe replaced by at most n2 clauses to obtain a refutation of\nF \u222aN \u2032\u2032k , and the result follows.\nIt may be noted that we could have defined rij :=\u2228n\nl=1 qS2(i,l),j in the proof of the previous proposition. The\nreason we have used the qR(i,l),j variables is to show that\nthe result stands for the more usual encoding of the pigeo-\nhole principle, which avoids Skolem relations. However,\nour method can be used to demonstrate that any first-order\n\u03c8, without finite models, that translates to a propositional\nsystem involving at least one non-unary Skolem relation,\nhas a resolution refutation (using the method of auxiliary\nvariables) of size 2kn2. It is straightforward to show, if \u03c8\nhas no finite models and a propositional translation with-\nout a non-unary Skolem relation, that \u03c8 also has no infi-\nnite models. Therefore, the method of auxiliary variables\nhas made all of our parameterized contradictions \u201ceasy\u201d for\nresolution. We note that not all contradictions derive from\nfirst-order principles, and that this method of auxiliary vari-\nables may have more relevance elsewhere.\nReferences\n[1] S. R. Buss and T. Pitassi. Resolution and the weak\npigeonhole principle. In CSL \u201997: Selected Papers\nfrom the 11th International Workshop on Computer\nScience Logic, Lecture Notes in Computer Science\n1414, Springer (1998) 149\u2013156\n159\n[2] Cesati, M.: Compendium of parameterized\nproblems. http:\/\/bravo.ce.uniroma2.it\/home\/cesati\/\nresearch\/compendium.pdf (September 2006)\n[3] J. Chen, I. A. Kanj, and G. Xia. Improved param-\neterized upper bounds for vertex cover. In Proceed-\nings of the International Symposium on Mathematical\nFoundations of Computer Science (MFCS 2006), Lec-\nture Notes in Computer Science 4162, Springer (2006)\n238\u2013249\n[4] S. A. Cook and R. A. Reckhow. The relative efficiency\nof propositional proof systems. J. Symbolic Logic,\n44(1) (1979) 36\u201350\n[5] S. Dantchev and B. Martin and S. Szeider, Parameter-\nized proof complexity: a complexity gap for parame-\nterized tree-like resolution. Electronic Colloquium on\nComputational Complexity (ECCC), Technical Report\nTR07-001 (2007)\n[6] Downey, R.G., Fellows, M.R.: Parameterized Com-\nplexity. Monographs in Computer Science. Springer\n(1999)\n[7] Downey, R.G., Fellows, M.R.: Fixed-parameter\ntractability and completeness. II. On completeness for\nW [1]. Theoretical Computer Science 141(1-2) (1995)\n109\u2013131\n[8] Flum, J., Grohe, M.: Parameterized Complexity The-\nory. Volume XIV of Texts in Theoretical Computer\nScience. An EATCS Series. Springer (2006)\n[9] Impagliazzo, R., Paturi, R., Zane, F.: Which problems\nhave strongly exponential complexity? J. of Computer\nand System Sciences 63(4) (2001) 512\u2013530\n[10] Kraj\u0131\u00b4c\u02c7ek, J.: Bounded Arithmetic, Propositional\nLogic, and Complexity Theory. Cambridge University\nPress, New York, NY, USA (1995)\n[11] Niedermeier, R.: Invitation to Fixed-Parameter Algo-\nrithms. Oxford Lecture Series in Mathematics and Its\nApplications. Oxford University Press (2006)\n[12] Pudla\u00b4k, P.: Proofs as Games. American Mathematical\nMonthly, 107(6) (2000) 541\u2013550\n[13] Riis, S.: A complexity gap for tree-resolution. Com-\nputational Complexity 10(3) (2001) 179\u2013209\n160\n"}