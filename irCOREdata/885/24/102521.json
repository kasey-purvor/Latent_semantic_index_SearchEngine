{"doi":"10.1109\/ICN.2008.61","coreId":"102521","oai":"oai:epubs.surrey.ac.uk:1984","identifiers":["oai:epubs.surrey.ac.uk:1984","10.1109\/ICN.2008.61"],"title":"Improving Availability of Mobile Code Systems by Decoupling Interaction from Mobility","authors":["Koukoumpetsos, K.","Antonopoulos, N.","Zhang, K.","Exarchakos, G."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2008-04-13","abstract":"<p>Resource availability in pervasive environments is restricted by many either mobility- and\/or security-related factors. Multi-agent systems deployed in such environments would have to rely on a potentially low number of hosts allowing and supporting the arrival and execution of foreign code. To address this issue, this paper proposes to decouple interaction of executing programs and services from the actual software mobility pattern used to realize this interaction. The proposed system (MoDeS - Mobility Decision System) dynamically decides on the best mobility method to implement a series of software interactions while satisfying the appropriate software constraints. The system takes as input an interaction plan and produces the corresponding mobility plan. A series of simulations were performed on single- and multi-hop scenarios which showed that MoDeS can significantly increase the availability of software interactions even in highly constraint environments.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1984<\/identifier><datestamp>\n      2017-10-31T14:03:54Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D636F6E666572656E63655F6974656D<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1984\/<\/dc:relation><dc:title>\n        Improving Availability of Mobile Code Systems by Decoupling Interaction from Mobility<\/dc:title><dc:creator>\n        Koukoumpetsos, K.<\/dc:creator><dc:creator>\n        Antonopoulos, N.<\/dc:creator><dc:creator>\n        Zhang, K.<\/dc:creator><dc:creator>\n        Exarchakos, G.<\/dc:creator><dc:description>\n        <p>Resource availability in pervasive environments is restricted by many either mobility- and\/or security-related factors. Multi-agent systems deployed in such environments would have to rely on a potentially low number of hosts allowing and supporting the arrival and execution of foreign code. To address this issue, this paper proposes to decouple interaction of executing programs and services from the actual software mobility pattern used to realize this interaction. The proposed system (MoDeS - Mobility Decision System) dynamically decides on the best mobility method to implement a series of software interactions while satisfying the appropriate software constraints. The system takes as input an interaction plan and produces the corresponding mobility plan. A series of simulations were performed on single- and multi-hop scenarios which showed that MoDeS can significantly increase the availability of software interactions even in highly constraint environments.<\/p><\/dc:description><dc:date>\n        2008-04-13<\/dc:date><dc:type>\n        Conference or Workshop Item<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1984\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Koukoumpetsos, K., Antonopoulos, N., Zhang, K. and Exarchakos, G.  (2008) Improving Availability of Mobile Code Systems by Decoupling Interaction from Mobility  In: Seventh International Conference on Networking (icn 2008).     <\/dc:identifier><dc:relation>\n        10.1109\/ICN.2008.61<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1984\/","10.1109\/ICN.2008.61"],"year":2008,"topics":[],"subject":["Conference or Workshop Item","PeerReviewed"],"fullText":"   \nAbstract\u2014Resource availability in pervasive environments is \nrestricted by many either mobility- and\/or security-related \nfactors. Multi-agent systems deployed in such environments \nwould have to rely on a potentially low number of hosts allowing \nand supporting the arrival and execution of foreign code. To \naddress this issue, this paper proposes to decouple interaction of \nexecuting programs and services from the actual software \nmobility pattern used to realize this interaction. The proposed \nsystem (MoDeS \u2013 Mobility Decision System) dynamically decides \non the best mobility method to implement a series of software \ninteractions while satisfying the appropriate software constraints. \nThe system takes as input an interaction plan and produces the \ncorresponding mobility plan. A series of simulations were \nperformed on single- and multi-hop scenarios which showed that \nMoDeS can significantly increase the availability of software \ninteractions even in highly constraint environments. \n \nIndex Terms\u2014cooperative agents, mobility patterns, pervasive \ncomputing, mobility policies. \nI. INTRODUCTION \nERVASIVE and mobile computing environments have \nbeen proven to differ from the usual workstation internet-\nenabled environment that the average user is used to [1]. \nMobile computers have limited available resources, since they \nare empowered with small processors, small storage space and \nare usually connected through a wireless network link. \nAccordingly, pervasive computing research is strongly \ncoupled with mobile computing research. Challenges met in \nthe mobile computing community can greatly enhance the \nevolution and realisation of Mark Weiser\u2019s ubiquitous \ncomputing in our everyday life. According to M. \nSatyanarayanan one of the major challenges of pervasive \ncomputing is \u201ccyber foraging\u201d [2], the intention is to \ndynamically distribute computational demanding applications \nfrom a wireless mobile device to local compute servers that \nact as mediators or proxies and are willing to execute \nincoming applications, for the benefits of the user. The most \nadvantageous way to achieve this is by using mobile code \ninstead of the traditional client\/server paradigm, since a typical \n \nManuscript received November 07, 2007. \nK. Koukoumpetsos is with the Department of Computing, University of \nSurrey, Guildford, Surrey GU2 7XH (e-mail: kyriakk@gmail.com).  \nN. Antonopoulos is with the Department of Computing, University of \nSurrey, Guildford, Surrey GU2 7XH (e-mail: n.antonopoulos@surrey.ac.uk). \nK. Zhang is with the Department of Computing, University of Surrey, \nGuildford, Surrey GU2 7XH (e-mail: k.zhang@surrey.ac.uk). \nG. Exarchakos is with the Department of Computing, University of Surrey, \nGuildford, Surrey GU2 7XH (e-mail: g.exarchakos@surrey.ac.uk). \npervasive environment is fully heterogeneous, thus the latter \ntechnique faces implementation difficulties [3]. \nA viable solution that finds support by many researchers [3, \n4], is to use the Mobile Agent paradigm as a middleware for \nmobility-enabled devices. The concept is that mobile \napplications are represented by mobile agents that act as \nproxies on a fixed network with more processing power. \nHowever, MA systems [5, 6, 7] assume homogeneity across \nthe environment, in that all the servers are capable of \nsupporting the execution of any incoming mobile agent. \nMoreover, most systems leave it to the programmer to specify \nwhere the agents go and always assume that the best method \nof mobility is for the agent to move to the server which hosts \nthe other interacting party. Besides, in a large scale \nenvironment it is impossible for the programmer to take all the \nrelative information and requirements into consideration in \norder to implement mobility. For these reasons, the \nextensiveness of mobile code applications is limited, and \nmostly kept internally within research groups or organisations, \nbecause in a closed environment the security risks are limited \nand the execution platform is common.  \nFocusing on the above premises, it is unrealistic to assume \nthat our applications will be supported at all nearby servers, or \neven that a server exists who is willing to accept both the \napplication and the modifications needed to execute our \nrequest. Such an environment limits the availability, (i.e. the \npossibility that a server exists in which both a requester and a \nprovider are able to execute in order to complete their \ninteracting session). \nThe solution we propose is to decouple that interaction from \nmobility. So, we designed a system (MObility DEcision \nSystem, MoDeS) to decide dynamically on the best mobility \nmethod (pattern) while satisfying the appropriate constraints. \nThus, by taking these constraints into consideration prior to \nmigration we believe that availability can be increased and the \nefficiency of a mobile-code-enabled environment improved. \nThe system takes an interaction plan as input, and gives the \nmobility plan as output. \nIt is expected that in such distributed environment, system \nusers and administrators introduce Mobility constraints to \nenforce specific mobility policies that conform to their \napplication requirements. For example, a server that contains \nprivate and sensitive information can deny any incoming code; \na server that provides and stores publicly available \ninformation can accept and execute mobile code; and \napplications of specific type (e.g. specific programming \nImproving availability of Mobile Code Systems \nby decoupling Interaction from Mobility \nKoukoumpetsos K., Antonopoulos N., Zhang K., and Exarchakos G. \nP \nSeventh International Conference on Networking\n978-0-7695-3106-9\/08 $25.00 \u00a9 2008 IEEE\nDOI 10.1109\/ICN.2008.61\n602\n language) can check if the underlying execution environment \nexists at the destination. \nII. SETTING THE SCENE \nCurrent systems, upon request for interaction, will try to \nmove the requester agent to the destination\u2019s agent host. We \ncall this mobility pattern Requester-to-Provider (R2P). Hence, \na mobility pattern can be defined as a way or type of migration \nbetween two mobile entities, a requester and a provider. \nHowever, as discussed earlier, it is quite convoluted to assume \nthat all mobile code applications can be executed in every host \nin the system. With current approaches, if the destination host \nis not able (e.g. due to lack of required platform) to accept or \nexecute any incoming code then the potential of that \ninteraction is lost. In order to improve the efficiency of such a \nsystem and increase the availability of interactions, there is a \nneed to identify additional mobility patterns. \nOne solution is to consider the possibility of the provider \nagent to come to the requester (P2R). If, for instance, the \nprovider agent represents a document that does not have \ninterdependencies with other agents, then it is feasible to move \na copy of that agent to the requester for the interaction to take \nplace; assuming that the server where the requester resides is \nable to execute\/facilitate the provider agent. \nYet, if this pattern is not possible the notion of meeting \npoint servers can be used. All or specific servers of the system \ncan act as meeting points where two agents can meet to \ninteract (RP2MP). If the system knows the Mobility \nconstraints of the servers and of both the interacting agents, \nthen it is possible to find out whether a server exists which can \naccommodate the needs for the execution of the interaction. \nFurthermore, for a more refined analysis [8, 9, 10], we can \nbenefit by using mobile agents that are a collection of different \ncomponents. Some existing systems [11, 12] include this \nconcept in their computation for migration, whereby fine-grain \ntechniques decide which parts of the agent are needed at the \ndestination to complete an interaction in order to minimise \ndata traffic. By visualising the agent as a set of components, \nvarious improvements can be introduced. A major one is that \ncomponents can be used among different users or agents. In \nterms of mobility though, this separation can introduce more \nways of migration which can both affect availability and data \ntraffic savings. In [13] we presented the benefits of using \ncomponent-based agents to minimise the used bandwidth in a \nmobile system, compared to the standard technique of R2P; an \nissue which affects pervasive computing environments as \nwell. In terms of availability the use of components introduces \nfive more mobility patterns. If it is feasible, instead of moving \nthe whole agent, the components of the interacting agents can \nmigrate. Thus, Requester Component-to-Provider (Rc2P) and \nProvider Component-to-Requester (Pc2R) are two more \npossibilities. In the case of components migrating to meeting \npoints it follows like: Requester Component and Provider \nAgent move to the Meeting Point (RcP2MP), Requester Agent \nand Provider Component moves to the Meeting Point \n(RPc2MP), or both Requester and Provider Components move \nto the Meeting Point (RcPc2MP). \nPutting it all together, we assume a mobile computing \nenvironment which consists of the following entities: agent \nservers, components, and mobile agents. An agent server is a \nsystem entity which provides the necessary infrastructure for \nthe agents to be created, live and execute, communicate, \ninteract and migrate. Components can be considered like \nfunctions or methods of the agent; small programs that have a \nspecific input and specific output. Agents are instantiated at an \nagent server. This agent server is called home server and is \nresponsible to create a globally unique ID (GUID) to label \neach agent during their life. Every agent is a set of different \ncomponents and has an itinerary (interaction plan). A \nmonolithic agent is an agent with one component. In the \nsystem, there are eight (8) mobility patterns (R2P, P2R, \nRP2MP, Rc2P, Pc2R, RcP2MP, RPc2MP, RcPc2MP) \navailable for the agents to use to accomplish their task and all \nits entities are described in XML. Agents and components in \nthe system are grouped into different types\/roles depending on \nvarious characteristics. Such characteristics are: \n\u0002 Type (Agents & Components): Since agents and \ncomponents have different roles in the system, \nrestrictions can be imposed on them according to their \ntypes. For example if the type of an agent is \u2018security\u2019 or \n\u2018system\u2019 agent, and represents local security policies, \nthen it is suitable for that agent not to leave the server. \n\u0002 Owner (Agents & Components): It is possible that \nsome administrators need to block specific agents or \ncomponents from either leaving or visiting the system \ndepending on their creators or originators. \n\u0002 Language (Agents & Components): Since agents and \ncomponents can be written in different programming \nlanguages in order to accommodate greater functionality \nof the system, if the required environment is not \navailable at the destination, the relevant Mobility \nconstraints should be implemented. \n\u0002 Home Server (Agents & Components): Constraints can \nalso be enforced by the location of the home server. \n\u0002 GUID (Agents Only): Constraints can be enforced by \ndirect reference to the Global Unique ID of an agent. \n\u0002 Input or Output (Components Only): Since \ncomponents are the methods of an agent they have to \nspecify the format of the input they accept and the format \nof the output they produce. That can be in the form of \nfiles or attributes or parameters. If, for example, a \ncomponent gives output in a specific file format, and that \nformat cannot be displayed at the server, then that \ncomponent cannot execute. \nAccording to this role-based scheme, users and \nadministrators can create sets of rules for filtering and \napplying the various constraints onto groups, instead of \nindividual agents or components. \nThere are various pragmatic reasons why constraints are \nintroduced in such a system. A possible advantage will be to \nknow in advance any lack of a supporting environment; in this \ncase the system will try to find other servers that are able to \nexecute specific applications, prior to a redundant migration. \nMoreover, some servers will be able to enforce certain \n603\n constraints depending on their processing load (load \nbalancing). Also, servers that specialise in specific domain can \nimpose constraints to accept agents relevant to that domain \nand reject any other type. Finally, trust related constraint may \nneed to be enforced by the servers since it has been considered \nas an increasingly important factor in network management \n[14]. \nThere is a distinction between the user constraints and the \nsystem constraints. The owner of the mobile agent, upon \ncreation, can specify which locations his\/her agent is not \nallowed to visit. On the other hand, servers not only enforce \nlocation constraints, but can also block specific agents, \ncomponents or groups of them from migrating to that server. \nServers do that by either explicitly defining Unique IDs of the \nagents or components or by using more complex filtering \nnotations depending on their characteristics. So, in total there \nare three tables of constraints: \na) one that is created by the user(s) and specifies locations \n(destinations) where owned agents cannot visit,  \nb) one that is created by the administrators which specifies \nwhich agents or components are not allowed to come to \nthe system, and  \nc) one that is created by the administrators and specifies \nwhere local agents are not allowed to go. \nMobility constraints are described with their respective \nXML Schemas. In particular, the server constraint XML \nSchema. is split in two parts representing the afore-mentioned \ntwo tables. One for applying constraints on incoming agents \nand the other for restricting local agents to leave the server. \nBoth the incoming and the outgoing parts specify which \nagents or components cannot come or leave by using filtering \non their respective characteristics. The only difference \nbetween the incoming and outgoing server constraints is that \nthe outgoing constraints should also confer the prohibited \nlocations that agents leaving the system cannot visit.  \nIII. DESCRIBING AND ANALYSING THE ALGORITHMS \nWhen a user creates a new agent, its Mobility constraints \nare saved within the agent\u2019s XML description. There are also \ncertain constraints that can be enforced upon an agent from its \nhome server, as described in the previous section. Server \nMobility constraints have higher precedence over agent \nconstraints to ensure server integrity, and are applied in a \ncascading manner. These constraints have to be included into \nthe agent, to avoid future interactions with non-permitted \nservers. For example, if an agent changes its interaction plan \nafter an interaction that has moved him to a foreign server; \nMoDeS has to re-calculate its mobility plan and for that it will \nhave to take into consideration both the agent\u2019s and home \nserver\u2019s constraints. The algorithm iterates through the \noutgoing server constraints and looks for any possible matches \non the agent fields. If it finds a match it inserts the respective \nlocations in the agent\u2019s XML file. It continues the same \nprocess for each of its component constraints as well; and if a \nmatch is found it updates the agent file. When the process \nfinishes it removes the duplicate and initialises the agent. \nFor the system to be able to devise the possible Mobility \nPatterns the agent\u2019s (requester or provider) constraints must be \nknown as well as the constraints of their servers and possible \nmeeting point servers. And although this may seem to produce \ngreat overhead in general, there are examples of areas that \ncould use this technique. In this system there are two \napproaches that can be used for updating. One approach is \nperiodic updating and shares the concept of link-state routing \nmethod which is used in computer communications. It is \napplied by requiring each server to pass on details about its \nclosest neighbours to every other server in the network. The \nsecond is the \u2018per hop\u2019 method and works by requesting the \nrelevant information at each step of the travel plan. This can \nbe possible by using an updating protocol, which returns the \nrelevant information from the server that hosts the provider \nagent. When each server receives the above information, it \nstores the relevant XML files for each server but also builds a \nlist of the locations of all the agents of the system. Thus, when \na local agent requests interaction with a foreign agent, the \nsystem will be able to retrieve the relevant file of the provider, \nin order to load the relevant constraints. \nThe most crucial algorithm, though, is the one that \nconsiders the Mobility constraints in order to find a possible \nmethod for the interacting agents or components to meet. For \neach interaction, the system has to check which of the mobility \npatterns are available depending on the constraints. First the \nsystem has to verify that the agent about to migrate can leave \nthe server by checking the agent\u2019s constraint table and its \nhome server\u2019s outgoing table. Then the system has to verify if \nthat agent is allowed to arrive at the destination, by checking \nthe destination server\u2019s incoming table. \nIV. RUNNING AND EVALUATING THE SIMULATIONS \nA simulator was set-up in order to compare availability of \ninteraction in different mobility patterns when certain Mobility \nconstraints are applied in a mobile agent system,. The \nsimulator creates agents with random characteristics, i.e. \nnumber of components, number of constraints, home server, \nnumber of hops, etc. These agents are allocated on servers \nwhich have random constraint characteristics of their own. \nThe selected parameters to run the simulation were the \nfollowing: \n\u0002 The number of agents was picked from a set of 10, 50, \n100, 500, 1000, \n\u0002 The number of servers where the agents were distributed \nwas picked from a set of 2, 10, 50, 100, 500 \nThe number of hops, which also specifies if the agents \n\u0002 were single-hop or multi-hop was picked from a set of 1, \n2, 3, 4, 5, 10, 25. The selected number acts as an upper \nbound. Thus in a simulation there is the possibility that \nagents have less number of hops than this upper bound.  \n604\n \u0002 Finally the percentage of constraints each agent and \nserver has. This number is selected from the following \nset (25%, 50%, 75%) and represents again the upper \nbound of Mobility constraints. When the simulator \ngenerates constraints for an agent, this number will be \nrandomised as the upper limit and rounded, and the \noutcome will be the number of the prohibited locations \nfor that agent. For example, if the simulation runs with \n1000 agents, 100 servers and 50% constraints, for each \nagent the maximum outgoing constraints will be 50 \n(100servers*50%). The same corresponds to the server \nincoming constraints, but there this number does not map \nonly to locations but also to agents or components of \nagents. The possibility of any is equally distributed at \n33%. \nThe results of the simulations confirmed our expectations. \nBy having different mobility patterns in a mobile computing \nenvironment, even with high number of restrictions or \nconstraints applied, the overall availability is increased. \nCompared to the current approach of most mobile code \nsystems which rely purely on the R2P pattern (labelled as R2P \nin the simulation graphs) the availability is increased around \n25% with the MoDeS approach. According to the results some \nof which are provided in the charts attached (see Figures 1 to \n4), we can observe that MoDeS performs better in all \nsituations. \nAs constraints increase though, the benefits of using a \nsystem like MoDeS increase dramatically up to the point \nwhere more than 50% of interactions that were not possible to \nexecute with R2P are now possible. The improvement \nachieved depends on how constrained the environment is. In \ngeneral, MoDeS improves availability more significantly in \nnot very severely constrained environments because the \nMoDes system can easily bypass few constraints whereas a \nstandard algorithm is blocked straight away. The charts show \nthe number of interactions that could not complete due to \nMobility constraints. MoDeS is compared against the standard \nagent mobility approach whereby the requester always \nmigrates to the provider agent. Thus \u201cNO R2D\u201d labelled \ngraphs show the number of failed interactions in mobile agent \nsystems that use R2P as the only available pattern. In single \nhop charts the total number of interactions is the same as the \nnumber of agents. In multi-hop we have included an \nenvironment where requester agents have five different \nSingleHop,  10Servers,  25% Constraints\n0\n50\n100\n150\n200\n250\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DSingleHop,  10Servers,  50% Constraints\n0\n50\n100\n150\n200\n250\n300\n350\n400\n450\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DSingleHop,  10Servers,  75% Constraints\n0\n100\n200\n300\n400\n500\n600\n700\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2D\nSingleHop,  100Servers,  25%  Constraints\n0\n50\n100\n150\n200\n250\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DSingleHop,  100Servers,  50%  Constraints\n0\n100\n200\n300\n400\n500\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DSingleHop,  100Servers,  75%  Constraints\n0\n100\n200\n300\n400\n500\n600\n700\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2D\nFig. 1: Availability in Single-Hop with 10 Servers with (a) 25%, (b) 50% \nand (c) 75% Constraints \n \nFig. 2: Availability in Single-Hop with 100 Servers with (a) 25%, (b) 50% \nand (c) 75% Constraints \n \n605\n provider agents to interact with, so the total number of \ninteractions is the number of agents multiplied by the number \nof hops (5 in our case). \nIt must be noted that three assumptions were made for this \nsystem to work: \ni. Incoming Server constraints block agents or components \naccording to constant characteristics and not according to \nprevious visited locations. This way the application of \nconstraints becomes more scalable since the updating of \nconstraints does not need to occur frequently.  \nii. We assume that the system has global knowledge of the \nMobility constraints and that updating of these Mobility \nconstraints is not often. This assumption is realistic if we \nrealise that Mobility constraints differ from security \npolicies. Mobility constraints appear at the execution and \nimplementation layer of mobile entities and can emerge \nin situations where that execution becomes problematic. \niii. We assume that at specific instances in time some agents \nact as client agents and some others act as server agents. \nThis is a sensible approach since in a typical agent \nenvironment we have agents that play the role of a server \nby providing specific services and other agents that use \nthese services as clients. \nIt has to be emphasised that although the analysis of the \nabove is based on a mobile multi-agent environment, it does \nnot bind the benefits to that environment only. The techniques \nthat are explained can be applied in all mobile code \narchitectures as long as the required modifications are made. \nBut the mobile agent approach presents a more detailed basis \nfor analysis of the concepts. \nMoDeS uses the following protocols: \n1. The constraint sharing protocol: This protocol is used by \nthe servers to disseminate any changes on their own or \ntheir agents\u2019 constraints. The packet of this protocol \ncontains the names of the servers whose constraints it \ncarries, the last date of update and the table of constraints \nfor each server.  \n2. R2P migration protocols: When MoDeS decides R2P as \nthe appropriate mobility pattern, then the system \u2018packs\u2019 \nthe agent\u2019s XML file with any other pertinent files and \nsends them to the destination server. The destination \nhost, after receiving the agent, creates a configuration file \nfor that specific agent. This file must include information \nMultiHop,  10Servers,  25%  Constraints\n0\n200\n400\n600\n800\n1000\n1200\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DMultiHop,  10Servers,  50%  Constraints\n0\n500\n1000\n1500\n2000\n2500\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DMultiHop,  10Servers,  75%  Constraints\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2D\nMultiHop,  100Servers,  25%  Constraints\n0\n200\n400\n600\n800\n1000\n1200\n1400\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DMultiHop,  100Servers,  50%  Constraints\n0\n500\n1000\n1500\n2000\n2500\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2DMultiHop,  100Servers,  75%  Constraints\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\n10 50 100 500 1000\nAgents\nNo\nt P\no\nss\nib\nle\n In\nte\nra\nct\nio\nn\ns\nMoDeS NO R2D\nFig. 3: Availability in Multi-Hop (5 hops) with 10 Servers with (a) 25%, \n(b) 50% and (c) 75% Constraints \n \nFig. 4: Availability in Multi-Hop (5 hops) with 100 Servers with (a) 25%, \n(b) 50% and (c) 75% Constraints \n \n606\n about the host, the way in which the provider agent can \nbe contacted (e.g. local path), as well as the method of \ncommunication the relocated agent can use (i.e. message \nqueue ID, shared memory path). Then the destination \nserver is responsible to re-initiate the agent. The agent \nbefore migration has to be set to \u2018migration mode\u2019. When \nit is initiated again at the destination server, it has to \nacquire the relevant information from the configuration \nfiles, and then confirm its location.  \n3. P2R migration protocol: In the case of P2R, MoDeS has \nto inform the provider agent\u2019s host for the required \nmigration, and request the agent or component to be sent. \nThe \u2018packing\u2019 of the provider agent is done in the same \nway as in the previous case.  \nMeeting Point protocol: Furthermore, in the case of meeting \npoints, MoDeS has to \u2018pack\u2019 and send the agent to the meeting \npoint, inform and request the provider agent to move to the \nmeeting point and also inform the meeting point server that it \nwill be used as such. This last information is crucial for the \nmeeting point concept to work. If it does not happen, we may \nhave a situation where one agent arrives, is initialised and tries \nto communicate with the other party, which still has not \narrived, thus does not have a local path or access point. \nV. CONCLUSIONS \nThe current landscape of software mobility is characterised \nby the strong coupling of interactions to a specific mobility \nmethod (e.g. client program mobility in mobile agent systems; \nserver program mobility in Java applet applications). \nFurthermore, the mobile code programmer needs to specify \nnot just the interactions of its program with other programs or \nservices but also the location where these interactions will take \nplace. Mobility thus has become yet another programmer-\ndefined parameter. Although that approach can work well in \nsmall to medium scale, homogeneous, closed environments, it \ndoes increase the complexity of developing mobile code. It \nalso makes its applicability rather restricted in pervasive \ncomputing environments whose sheer scale and heterogeneity \nmakes the assumption that the programmer knows a priori the \nlocation and constraints of each service or network quite \nunrealistic. \nOur proposed solution first decouples interaction from \nmobility. It then finds all the ways that each interaction can \nactually be implemented taking into account server and agent \nconstraints. These Mobility constraints provide a single but \npowerful method for modeling the heterogeneity of pervasive \ncomputing infrastructures. They can represent hardware \nlimitations (i.e. low processing power) lack of support for \ncertain software (i.e. absence of certain language interpreters) \nand load balancing \/ specialisation restrictions (i.e. servers \ndedicated to supporting specific applications such as \nsimulations or desktop publishing). \nWe are planning to investigate interesting variations to the \nsystem we described in this paper. For example, rather than \nallowing only two possibilities with respect to whether an \nagent is allowed to go to a particular server (allow or forbid), \nwe could assign percentage values. In this way we could setup \npolicies whereby specific agents could use specific servers \npreferentially or otherwise. So, predefined types of processing \ncould be directed towards specified sets of servers and \ntherefore an administrator could effectively perform \nprocessing driven server partitioning. \nVI. REFERENCES \n[1] M. F. Kaashoek, T. Pinckney, and J. A. Tauber. \u201cDynamic Documents: \nMobile Wireless Access to the WWW.\u201d In Proceedings of the Workshop \non Mobile Computing Systems and Applications, December, 1994  \n[2] M. Satyanarayanan, \u201cPervasive computing: vision and challenges,\u201d \nIEEE Personal Communications, vol. 8, no. 4 , Aug 2001, pp. 10-17 \n[3] D. Kotz and R. S. Gray, \u201cMobile Agents and the Future of the Internet,\u201d \nACM Operating Systems Review, vol. 33, no. 3, August 1999, pp. 7-13. \n[4] P. Bellavista, A. Corradi, C. Stefanelli, C., \u201cThe ubiquitous provisioning \nof internet services to portable devices\u201d IEEE Pervasive Computing , \nvol. 1, no. 3 , 2002, pp. 81-87. \n[5] Q. H. Mahmoud, L. Yu, \"Havana: a mobile agent platform for seamless \nintegration with the existing web infrastructure,\" CCECE, May, 2004. \n[6] N. Suri, et al., \u201cNOMADS: toward an environment for strong and safe \nagent mobility,\u201d Proceedings of the Fourth International Conference on \nAutonomous Agents, 2000. \n[7] The Ajanta Project. http:\/\/www.cs.umn.edu\/Ajanta\/. \n[8] M. Gomez, E. Plaza, \u201cIntegrating knowledge modelling and multi-agent \nsystems,\u201d American Association for Artificial Intelligence, 2005. \n[9] K. Y. Wan, V. Alagar, \u201cA component-based architecture for multi agent \nsystems,\u201d Intelligent Agent Technology, 2006. \n[10] Z. Guessoum, J. -P. Briot, \u201cFrom active objects to autonomous agents,\"  \nIEEE Concurrency, vol. 7, no. 3, September 1999, pp. 68-76. \n[11] M. Jazayeri, W. Lugmayr, \u201cGypsy: a component-based mobile agent \nsystem,\u201d Euromicro Workshop on Parallel and Distributed Processing, \n1999. \n[12] Y. Chow, W. Zhu, C. -L. Wang, F. C. M. Lau, \u201cState-on-demand \nexecution for adaptive component-based mobile agent systems,\u201d \nICPADS, 2004. \n[13] K. Koukoumpetsos, N.Antonopoulos, \u201cMobility Patterns: An \nAlternative Approach to Mobility Management,\u201d Proceedings of the 6th \nWorld Multi-Conference on Systemics, Cybernetics and Informatics, 14-\n18 July 2002 \n[14] A. K. Koliousis, \u201cA Trustworthy Mobile Agent Infrastructure for \nNetwork Management,\u201d Integrated Network Management, 2007 \n \n607\n"}