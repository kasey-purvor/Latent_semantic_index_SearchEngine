{"doi":"10.1007\/3-540-45685-6_22","coreId":"66643","oai":"oai:dro.dur.ac.uk.OAI2:641","identifiers":["oai:dro.dur.ac.uk.OAI2:641","10.1007\/3-540-45685-6_22"],"title":"Weakest precondition for general recursive programs formalized in Coq.","authors":["Zhang,  X.","Munro,  M.","Harman,  M.","Hu,  L."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2002-08-23","abstract":"This paper describes a formalization of the weakest precondition, wp, for general recursive programs using the type-theoretical proof assistant Coq. The formalization is a deep embedding using the computational power intrinsic to type theory. Since Coq accepts only structural recursive functions, the computational embedding of general recursive programs is non-trivial. To justify the embedding, an operational semantics is defined and the equivalence between wp and the operational semantics is proved. Three major healthiness conditions, namely: Strictness, Monotonicity and Conjunctivity are proved as well","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66643.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/641\/1\/641.pdf","pdfHashValue":"e8bc717e47af1a020d172307ddf3937c0f524acd","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:641<\/identifier><datestamp>\n      2015-03-31T12:07:48Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Weakest precondition for general recursive programs formalized in Coq.<\/dc:title><dc:creator>\n        Zhang,  X.<\/dc:creator><dc:creator>\n        Munro,  M.<\/dc:creator><dc:creator>\n        Harman,  M.<\/dc:creator><dc:creator>\n        Hu,  L.<\/dc:creator><dc:description>\n        This paper describes a formalization of the weakest precondition, wp, for general recursive programs using the type-theoretical proof assistant Coq. The formalization is a deep embedding using the computational power intrinsic to type theory. Since Coq accepts only structural recursive functions, the computational embedding of general recursive programs is non-trivial. To justify the embedding, an operational semantics is defined and the equivalence between wp and the operational semantics is proved. Three major healthiness conditions, namely: Strictness, Monotonicity and Conjunctivity are proved as well.<\/dc:description><dc:subject>\n        Weakest precondition<\/dc:subject><dc:subject>\n         Operational semantics<\/dc:subject><dc:subject>\n         Formal verification.<\/dc:subject><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        (2002). 15th International Conference on Theorem Proving in Higher Order Logics ; proceedings. Berlin: Springer, pp. 332-347, Lecture notes in computer science(2410)<\/dc:source><dc:date>\n        2002-08-23<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:641<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/3-540-45685-6_22<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/641\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/3-540-45685-6_22<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/641\/1\/641.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/3-540-45685-6_22<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2002,"topics":["Weakest precondition","Operational semantics","Formal verification."],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 March 2010\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nZhang, X. and Munro, M. and Harman, M. and Hu, L. (2002) \u2019Weakest precondition for general recursive\nprograms formalized in coq.\u2019, in 15th International Conference on Theorem Proving in Higher Order Logics ;\nproceedings. Berlin: Springer, pp. 332-347. Lecture notes in computer science. (2410).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/3-540-45685-6\nPublisher\u2019s copyright statement:\nAdditional information:\nConference held on August 20-23, 2002, Hampton, VA, USA.\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nWeakest Precondition for General Recursive\nPrograms Formalized in Coq ?\nXingyuan Zhang1, Malcolm Munro1, Mark Harman2, and Lin Hu2\n1 Department of Computer Science, University of Durham, Science Laboratories,\nSouth Road, Durhram, DH1 3LE, U.K.\n{Xingyuan.Zhang, Malcolm.Munro}@durham.ac.uk\n2 Department of Information Systems and Computing, Brunel University, Uxbridge,\nMiddlesex, UB8 3PH, U.K.\n{Mark.Harman, Lin.Hu}@brunel.ac.uk\nAbstract. This paper describes a formalization of the weakest precondi-\ntion, wp, for general recursive programs using the type-theoretical proof\nassistant Coq. The formalization is a deep embedding using the computa-\ntional power intrinsic to type theory. Since Coq accepts only structural\nrecursive functions, the computational embedding of general recursive\nprograms is non-trivial. To justify the embedding, an operational se-\nmantics is defined and the equivalence between wp and the operational\nsemantics is proved. Three major healthiness conditions, namely: Strict-\nness, Monotonicity and Conjunctivity are proved as well.\nKeywords: Weakest Precondition, Operational Semantics, Formal Ver-\nification, Coq\n1 Introduction\nThe weakest precondition, wp, proposed by E. W. Dijkstra [5] proved to be useful\nin various areas of software development and has been investigated extensively\n[1, 13, 12]. There have been a number of attempts to support wp and refinement\ncalculus with computer assisted reasoning systems such as HOL [16, 19, 9], Is-\nabelle [14, 17, 18], Ergo [3], PVS [8] and Alf [10]. Unfortunately, among these\nworks, only Laibinis and Wright [9] deals with general recursion.\nIn this paper, an embedding of wp is given for general recursive programs\nusing the intentional type theory supported by Coq [2]. Since the computational\nmechanism peculiar to type theory is used, we name such a style of embedding\n\u2018computational embedding\u2019. The importance of computational embedding is that\nit can be seen as a bridge between deep and shallow embedding. Since wp is\ndefined as a function from statement terms to predicate transformers, before\nthe definition of wp in wp (c) is expanded, by accessing the syntax structure of\nc, we enjoy the benefit of deep embedding, so that meta-level operations such\nas program transformations (usually expressed as functions on program terms)\n? The work in this paper is sponsored by the EPSRC project GUSTT\n2can be verified. On the other hand, after expanding wp, wp (c) becomes the\nsemantics of c. With the computational mechanism taking care of the expanding\nprocess, we can focus on the semantics without worrying about syntax details,\na benefit traditionally enjoyed by shallow embedding. Therefore, computational\nembedding enables us to switch between deep and shallow embedding with ease.\nThe language investigated in this paper is general recursive in the sense\nthat it contains a statement which takes the form of a parameter-less recursive\nprocedure : proc p \u2261 c, the execution of which starts with the execution of\nthe procedure body c. When a recursive call pcall p is encountered during the\nexecution, the pcall p is replaced by the procedure body c and the execution\ncontinues from the beginning of c.\nA na\u00a8\u0131ve definition of wp (proc p \u2261 c) could be:\nwp (proc p \u2261 c)\ndef\n=\u21d2\n\u2228\nn<\u03c9\nwp\n(\nproc p \u2261 c\nn\n)\n(1)\nwhere the expansion operation proc p \u2261 c\nn\nis defined as:\n\uf8f1\uf8f2\n\uf8f3\nproc p \u2261 c\n0 def\n=\u21d2 assert(false)\nproc p \u2261 c\nn+1 def\n=\u21d2 c\n{\np\/ proc p \u2261 c\nn\n} (2)\nwhere in each round of expansion, p in c is substituted by proc p \u2261 c\nn\n.\nThe problem with this definition is that: in (1), the recursive call of wp:\nwp\n(\nproc p \u2261 c\nn\n)\nis not structural recursive, since the argument proc p \u2261 c\nn\nis structurally\nlarger than the argument proc p \u2261 c on the left. Therefore, (1) is rejected by\nthe function definition mechanism of Coq, which only accepts structural recursive\nfunctions.\nThis paper proposes a formulation of wp which solves this problem. To justify\nsuch a formulation, an operational semantics is defined and the equivalence of\nwp and the operational semantics is proved. Three major healthiness conditions\nare proved for wp as well, namely: Strictness, Monotonicity and Conjunctivity.\nFor brevity, in this paper, only the equivalence proof is discussed in full detail.\nThe rest of the paper is arranged as follows: Section 2 defines the notions\nof predicate, predicate transformer, transformer of predicate transformers to-\ngether with various partial orders and monotonicity predicates. Section 3 gives\nthe definition wp. Section 4 presents the operational semantics. Section 5 relates\noperational semantics to wp. Section 6 relates wp to operational semantics. Sec-\ntion 7 concludes the whole paper. Additional technical detail can be found in\nAppendices. The technical development of this paper has been fully formalized\nand checked by Coq. The Coq scripts are available from\nhttp : \/\/www.dur.ac.uk\/xingyuan.zhang\/tphol\n3Conventions. Because type theory [4, 15, 11] was first proposed to formalize\nconstructive mathematics, we are able to present the work in standard mathe-\nmatical notation. For brevity, we use the name of a variable to suggest its type.\nFor example, s, s\u2032, s, . . . in this paper always represent program stores.\nType theory has a notion of computation, which is used as a definition mech-\nanism, where the equation a\ndef\n=\u21d2 b represents a \u2018computational rule\u2019 used to\nexpand the definition of a to b.\nFree variables in formul\u00e6 are assumed to be universally quantified, for ex-\nample, n1 + n2 = n2 + n1 is an abbreviation of \u2200n1, n2. n1 + n2 = n2 + n1.\nFor A : Set, the exceptional set M(A) is defined as:\nA : Set\nM(A) : Set\nM formation\nA : Set\n\u22a5 : M(A)\nbottom value\nA : Set a : A\nunit (a) : M(A)\nnormal value\n(3)\nIntuitively, M(A) represents the type obtained from A by adding a special\nelement \u22a5 to represent undefined value. A normal element a of the original type\nA is represented as unit (a) in exceptional set M(A). However, the unit is usually\nomitted, unless there is possibility of confusion.\n2 Predicates and predicate transformers\nWe take the view that the predicates transformed by wp are predicates on pro-\ngram stores. Therefore, the type of predicates PD is defined as:\nPD\ndef\n=\u21d2 PS \u2192 Prop (4)\nwhere Prop is the type of propositions, PS is the type of program stores. For\nsimplicity, this paper is abstract about program stores and denotable values.\nHowever, there is a comprehensive treatment of program stores, denotable values\nand expression evaluation in the Coq scripts.\nThe type of predicate transformers PT is defined as:\nPT\ndef\n=\u21d2 PD \u2192 PD (5)\nThe type of transformers of predicate transformers PT T is defined as:\nPT T\ndef\n=\u21d2 PT \u2192 PT (6)\nThe partial order 4P between predicates is defined as:\nP1 4P P2\ndef\n=\u21d2 \u2200 s . P1 (s) \u21d2 P2 (s) (7)\nThe partial order 4pt between predicate transformers is defined as:\npt1 4pt pt2\ndef\n=\u21d2 \u2200P . pt1 (P ) 4P pt2 (P ) (8)\n4The monotonicity predicate on PT is defined as:\nmono(pt)\ndef\n=\u21d2 \u2200P1, P2. P1 4P P2 \u21d2 pt (P1) 4P pt (P2) (9)\nThe partial order on 4\u03c3 between environments is defined as:\n\u03c31 4\u03c3 \u03c32\ndef\n=\u21d2 \u2200 p . \u03c31 (p) 4pt \u03c32 (p) (10)\nThe partial order 4ptt between transformers of predicate transformers is defined\nas:\nptt1 4ptt ptt2\ndef\n=\u21d2 \u2200 pt . mono(pt) \u21d2 ptt1 (pt) 4pt ptt2 (pt) (11)\nThe corresponding derived equivalence relations are defined as:\uf8f1\uf8f4\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4\uf8f4\uf8f3\nP1 \u2248P P2\ndef\n=\u21d2 P1 4P P2 \u2227 P2 4P P1\npt1 \u2248pt pt2\ndef\n=\u21d2 pt1 4pt pt2 \u2227 pt2 4pt pt1\nptt1 \u2248ptt ptt2\ndef\n=\u21d2 ptt1 4ptt ptt2 \u2227 ptt2 4ptt ptt1\n(12)\nThe monotonicity predicate on environments is defined as:\nmono(\u03c3)\ndef\n=\u21d2 \u2200 p . mono(\u03c3 (p)) (13)\n3 Formalization of wp\nIn order to overcome the problem mentioned in the Introduction, a notion of\nenvironment is introduced, which is represented by the type \u03a3:\n\u03a3\ndef\n=\u21d2 ID \u2192 PT (14)\nwhich is a function from identifiers to predicate transformers. In this paper,\nprocedure names are represented as identifiers.\nThe empty environment \u03b5 : \u03a3, which maps all procedure names to the false\npredicate transformer \u03bbP.F, is defined as:\n\u03b5\ndef\n=\u21d2 \u03bb p. \u03bbP. F (15)\nwhere p is procedure name, P is predicate and F is the false predicate, which is\ndefined as:\nF\ndef\n=\u21d2 \u03bb s.False (16)\nwhere s is program store, False is the false proposition in Coq. Therefore, F does\nnot hold on any program store.\nThe operation \u03c3 [p 7\u2192 pt] is defined, to add the mapping p 7\u2192 pt to environ-\nment \u03c3: \uf8f1\uf8f2\n\uf8f3\n\u03c3 [p 7\u2192 pt] (p)\ndef\n=\u21d2 pt if p = p\n\u03c3 [p 7\u2192 pt] (p)\ndef\n=\u21d2 \u03c3 (p) if p 6= p\n(17)\n5C : Set\nC fmt\ni : ID e : E\ni := e : C\ns asgn\ne : E\nassert(e) : C\ns assert\nc1 : C c2 : C\nc1; c2 : C\ns seq\ne : E c1 : C c2 : C\nif e then c1 else c2 : C\ns ifs\np : ID c : C\nproc p \u2261 c : C\ns proc\np : ID\npcall p : C\ns pcall\nFig. 1. The Definition of C\n\uf8f1\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f4\uf8f3\nwpc (\u03c3, i := e)\ndef\n=\u21d2 \u03bb P, s. \u2203 v . [[e]]s = v \u2227 P\n(\ns\n[\nv i\n])\n(18a)\nwpc (\u03c3, assert(e))\ndef\n=\u21d2 \u03bb P, s. [[e]]s = true \u2227 P (s) (18b)\nwpc (\u03c3, c1; c2)\ndef\n=\u21d2 \u03bb P, s. wpc (\u03c3, c1) (wpc (\u03c3, c2) (P )) (s) (18c)\nwpc (\u03c3, if e then c1 else c2)\ndef\n=\u21d2 \u03bb P, s .([[e]]s = true \u2227 wpc (\u03c3, c1) (P ) (s))\u2228\n([[e]]s = false \u2227 wpc (\u03c3, c2) (P ) (s)) (18d)\nwpc (\u03c3, proc p \u2261 c)\ndef\n=\u21d2 \u03bb P, s. \u2203n . \u03bb pt. wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n) n\n(P ) (s) (18e)\nwpc (\u03c3, pcall p)\ndef\n=\u21d2 \u03bb P, s. \u03c3 (p) (P ) (s) (18f)\nFig. 2. The Definition of wpc\nInstead of defining wp directly, an operation wpc (\u03c3, c) is defined to compute\na predicate transformer for command c under the environment \u03c3. By using the\nenvironment \u03c3, wpc (\u03c3, c) can be defined using structural recursion. With wpc,\nthe normal wp is now defined as: wp (c)\ndef\n=\u21d2 wpc (\u03b5, c).\nThe syntax of the programming language formalized in this paper is given\nin Figure 1 as the inductive type C. The type of expressions is formalized as\nan abstract type E . The evaluation of expressions is formalized as the operation\n[[e]]s, where the expression [[e]]s = v means that expression e evaluate to value v\nunder program store s and the expression [[e]]s = \u22a5means there is no valuation of\nexpression e under program store s. The definition of wpc (\u03c3, c) is given in Figure\n2, where each command corresponds to an equation. The right-hand-side of each\nequation is a lambda abstraction \u03bbP, s. (. . .), where P is the predicate required\nto hold after execution of the corresponding command, and s is the program\nstore before execution. The operation s\n[\nv i\n]\nis the program store obtained from\nprogram store s by setting the value of variable i to v.\nEquations (18a) \u2013 (18d) are quite standard. Only (18e) and (18f) need more\nexplanation. Equation (18e) is for wpc (\u03c3, proc p \u2261 c), the originally problem-\natic case. The recursive call on the right-hand-side is wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n)\n, which\nis structural recursive with respect to the second argument. The key idea is that:\na mapping p 7\u2192 pt is added to the environment \u03c3, which maps p to the formal\n6parameter pt. By abstracting on pt, a \u2018transformer of predicate transformers\u2019:\n\u03bb pt.wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n)\n: PT \u2192 PT\nis obtained. Notice that the term \u03bb pt.wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n) n\nin (18e) is no\nlonger the expansion operation defined in (2), but a folding operation defined\nas: \uf8f1\uf8f2\n\uf8f3\nptt\n0 def\n=\u21d2 \u03bbP . F\nptt\nn+1 def\n=\u21d2 ptt\n(\nptt\nn\n) (19)\nIn place of\n\u2228\nn<\u03c9 wp\n(\nproc p \u2261 c\nn\n)\n, we write\n\u2203n . \u03bb pt.wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n) n\n(P ) (s)\nwhich is semantically identical, but expressible in Coq.\nThe equation (18f) defines wpc for pcall p, which is the predicate transformer\nassigned to p by \u03c3.\nAs a sanity checking, three healthiness conditions, namely: Strictness, Mono-\ntonicity and Conjunctivity, are proved. For brevity, only the one, which is used\nin this paper, is listed here:\nLemma 1 (Generalized Monotonicity Lemma).\n\u2200c.\n(\u03c31 4\u03c3 \u03c32 \u21d2 mono(\u03c31) \u21d2 mono(\u03c32) \u21d2\nwpc (\u03c31, c) 4pt wpc (\u03c32, c))\u2227 (20a)\n(mono(\u03c3) \u21d2 mono(wpc (\u03c3, c))) (20b)\nThe proof for other healthiness conditions can be found in the Coq scripts.\n4 The operational semantics\nTo strengthen the justification of wp, an operational semantics is defined and\na formal relationship between the operational semantics and wp is established.\nThe operational semantics is given in Figure 3 as an inductively defined relation\ns\nc\n\u2212\u2192\ncs\ns\u2032, which means that: the execution of command c transforms program\nstore from s to s\u2032. The cs is the \u2018call stack\u2019 under which c is executed. The type\nof call stack CS is defined as:\nCS : Set\nCS form\n\u03d1 : CS\nnil cs\np : ID c : C cs, cs : CS\ncs[p (c, cs)] : CS\ncons cs\n(21)\nwhere \u03d1 is the empty call stack, and cs[p  (c, cs)] is the call stack obtained\nfrom cs by pushing (p, c, cs).\n7In the rule e proc, when a recursive procedure proc p \u2261 c is executed, the\noperation cs[p  (c, cs)] pushes procedure body c together with the call stack\ncs, under which the c is going to be executed onto the call stack, and then the\nprocedure body c is executed.\nIn the rule e pcall, when a recursive call pcall p is executed, the operation\nlookup(cs, p) is used to look up the procedure body being called and the call\nstack under which it is going to be executed. Suppose (c, cs) is found, then c is\nexecuted under the call stack cs.\nThe definition of lookup is:\uf8f1\uf8f4\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4\uf8f4\uf8f3\nlookup(cs[p (c, cs)], p)\ndef\n=\u21d2 (c, cs) if p = p\nlookup(cs[p (c, cs)], p)\ndef\n=\u21d2 lookup(cs, p) if p 6= p\nlookup(\u03d1, p)\ndef\n=\u21d2 \u22a5\n(22)\n[[e]]s = true\ns\nassert(e)\n\u2212\u2212\u2212\u2212\u2212\u2192\ncs\ns\ne asrt\n[[e]]s = v\ns\ni:=e\n\u2212\u2212\u2212\u2192\ncs\ns\n[\nv i\n] e asgn\n[[e]]s = true s\nc1\u2212\u2192\ncs\ns\u2032\ns\nif e then c1 else c2\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncs\ns\u2032\ne ifs t\n[[e]]s = false s\nc2\u2212\u2192\ncs\ns\u2032\ns\nif e then c1 else c2\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncs\ns\u2032\ne ifs f\ns\nc1\u2212\u2192\ncs\ns\u2032 s\u2032\nc2\u2212\u2192\ncs\ns\u2032\u2032\ns\nc1; c2\u2212\u2212\u2212\u2212\u2192\ncs\ns\u2032\u2032\ne seq\ns\nc\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncs[p (c,cs)]\ns\u2032\ns\nproc p \u2261 c\n\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncs\ns\u2032\ne proc\nlookup(cs, p) = (c, cs) s\nc\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncs[p (c,cs)]\ns\u2032\ns\npcall p\n\u2212\u2212\u2212\u2212\u2192\ncs\ns\u2032\ne pcall\nFig. 3. Definition of the operational semantics\n5 Relating operational semantics to wp\nThe operational semantics can be related to wp by the following lemma:\nLemma 2 (operational semantics to wp).\ns\nc\n\u2212\u2192\n\u03d1\ns\u2032 \u21d2 P (s\u2032) \u21d2 wp (c) (P ) (s)\nwhich says: if the execution of c under the empty call stack yields program store\ns\u2032, then for any predicate P , if P holds on s\u2032, then the predicate wp (c) (P ) (the\npredicate P transformed by wp (c)) holds on the initial program store s.\n8Instead of proving Lemma 2 directly, the following generalized lemma is\nproved first, and Lemma 2 is treated as a corollary of Lemma 3.\nLemma 3 (\u2018operational semantics to wp\u2019 generalized).\ns\nc\n\u2212\u2192\ncs\ns\u2032 \u21d2 (23a)\ncan(cs) \u21d2 (23b)\n\u2203n .\n(\u2200P . P (s\u2032) \u21d2 wpc ({|cs|}n, c) (P ) (s)) (23c)\nwhere the predicate can is used to constrain the form of cs, so that it can be\nguaranteed that the execution s\nc\n\u2212\u2192\ncs\ns\u2032 is a sub-execution of some top level exe-\ncution s\nc\n\u2212\u2192\n\u03d1\ns\u2032. Therefore, can is formalized as the following inductively defined\npredicate:\ncan(\u03d1)\ncan nil\ncan(cs)\ncan(cs[p (c, cs)])\ncan cons (24)\nThe operation {|cs|}n is used to transform a call stack to environment. It is\ndefined as:\n\uf8f1\uf8f4\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4\uf8f4\uf8f3\n{|\u03d1|}n\ndef\n=\u21d2 \u03b5\n{|cs[p (c, cs)]|}n\ndef\n=\u21d2\n{|cs|}n\n[\np 7\u2192 \u03bb pt.wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n] (25)\nThe idea behind can and {|cs|}n is explained in detail in Section 5.1. The proof\nof Lemma 3 is given in Appendix A. The preliminary lemmas used in the proof\nare given in Appendix C.1.\nSince can(\u03d1) is trivially true, by instantiating cs to \u03d1, Lemma 2 follows di-\nrectly from Lemma 3.\n5.1 Informal explanation of Lemma 3\nIn (18e), the n is determined by the number of recursive calls to p during the exe-\ncution of c. n can be any natural number larger than this number. By expanding\nwpc in wpc (\u03c3, proc p \u2261 c) (P ) (s), we have:\n\u2203 n . \u03bb pt.wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n) n\n(P ) (s)\nIf n = n + 1, then by expanding the definition of \u00b7 \u00b7 \u00b7\nn+1\n, we have:\nwpc\n(\n\u03c3\n[\np 7\u2192 \u03bb pt.wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)\n(P ) (s) (26)\n9The natural number n is the number of recursive calls of p during the execution\nof c starting from program store s.\nAn analysis of the operational semantics in Figure 3 may reveal that: if the\nexecution s\nc\n\u2212\u2192\ncs\ns\u2032 is a sub-execution of some \u2018top level execution\u2019 s\nc\n\u2212\u2192\n\u03d1\ns\u2032, then\ncs must be of the form:\n\u03d1[p0  (c0, cs0)][p1  (c1, cs1)] . . . [pm  (cm, csm)] (27)\nwhere the [pi  (ci, csi)] (i \u2208 {0, . . . ,m}) are pushed onto cs through the\nexecution of proc pi \u2261 ci (i \u2208 {0, . . . ,m}). During the execution of c, there\nmust be a number of recursive calls on each of the procedures pi (i \u2208 {0, . . . ,m}).\nLet these numbers be np0 , np1 , . . . , npm .\nIn the design of {|cs|}n, inspired by the analysis in (26), we first intended to\ntransform cs into:\n\u03b5 [p0 7\u2192 fd({|cs0|}, np0 , p0, c0)] [p1 7\u2192 fd({|cs1|}, np1 , p1, c1)] . . .\n[pm 7\u2192 fd({|csm|}, npm , pm, cm)] (28)\nwhere fd(\u03c3, n, p, c) is the abbreviation defined as:\nfd(\u03c3, n, p, c)\ndef\n=\u21d2 \u03bb pt.wpc\n(\n\u03c3\n[\np 7\u2192 pt\n]\n, c\n) n\n(29)\nHowever, it is quite inconvenient to find the values for all the natural numbers\nnp0 , np1 , . . . , npm . Fortunately, since fd(\u03c3, n, p, c) is monotonous with respect to\nn, it is sufficient to deal only with the upper bound of them. It is usually easier\nto deal with one natural number than a group of natural numbers. Therefore,\nthe cs is finally transformed into:\n\u03b5 [p0 7\u2192 fd({|cs0|}\nnmax , nmax, p0, c0)] [p1 7\u2192 fd({|cs1|}\nnmax , nmax, p1, c1)] . . .\n[pm 7\u2192 fd({|csm|}\nnmax , nmax, pm, cm)] (30)\nwhere nmax is a natural number larger than any npi (i \u2208 {0, . . . ,m}). The n\nin Lemma 3 is actually the nmax in (30). The equation (30) also explains the\ndefinition of {|cs|}n in (25).\n6 Relating wp to operational semantics\nwp can be related to the operational semantics by the following lemma:\nLemma 4 (wp to operational semantics).\nwp (c) (P ) (s) \u21d2 \u2203 s\u2032 .\n(\ns\nc\n\u2212\u2192\n\u03d1\ns\u2032 \u2227 P (s\u2032)\n)\n10\nwhich says: for any predicate P , if the transformation of any predicate P by\nwp (c) holds on s, then the execution of c under the empty call stack terminates\nand transforms program store from s to s\u2032, and P holds on s\u2032.\nInstead of proving Lemma 4 directly, the following generalized lemma is\nproved first and Lemma 4 follows as a corollary of Lemma 5.\nLemma 5 (\u2018wp to operational semantics\u2019 generalized).\nwpc (envof(ecs), c) (P ) (s) \u21d2 (31a)\necan(ecs) \u21d2 (31b)\n\u2203 s\u2032 .\n(s\nc\n\u2212\u2212\u2212\u2212\u2212\u2192\ncsof(ecs)\ns\u2032 \u2227 (31c)\nP (s\u2032)) (31d)\nwhere, ecs is an \u2018extended call stack\u2019, the type of which \u2013 ECS is defined as:\nECS : Type\nECS form\n\u03b8 : ECS\nnil ecs\np : ID c : C ecs : ECS pt : PT ecs : ECS\necs[p \u21aa\u2192 (c, ecs, pt)] : ECS\ncons ecs\n(32)\nwhere \u03b8 is the \u2018empty extended call stack\u2019 and ecs[p \u21aa\u2192 (c, ecs, pt)] is the ex-\ntended call stack obtained by adding (p, c, ecs, pt) to the head of ecs. It is obvious\nfrom the definition of ECS that an extended call stack is a combination of call\nstack and environment, with each procedure name p being mapped to a triple\n(c, ecs, pt). Therefore, by forgetting pt in the triple, a normal call stack is ob-\ntained. This is implemented by the operation csof(ecs):\n\uf8f1\uf8f2\n\uf8f3\ncsof(\u03b8)\ndef\n=\u21d2 \u03d1\ncsof(ecs[p \u21aa\u2192 (c, ecs, pt)])\ndef\n=\u21d2 csof(ecs)[p (c, csof(ecs))]\n(33)\nBy forgetting c, ecs in the triple, a normal environment is obtained. This is\nimplemented by the operation envof(ecs):\n\uf8f1\uf8f2\n\uf8f3\nenvof(\u03b8)\ndef\n=\u21d2 \u03b5\nenvof(ecs[p \u21aa\u2192 (c, ecs, pt)])\ndef\n=\u21d2 envof(ecs) [p 7\u2192 pt]\n(34)\nThe operation lookup ecs(p, ecs) is defined to lookup (in ecs) the triple (c, ecs, pt)\nmapped to p:\n\uf8f1\uf8f4\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4\uf8f4\uf8f3\nlookup ecs(p, ecs[p \u21aa\u2192 (c, ecs, pt)])\ndef\n=\u21d2 (p, c, ecs, pt) if p = p\nlookup ecs(p, ecs[p \u21aa\u2192 (c, ecs, pt)])\ndef\n=\u21d2 lookup ecs(p, ecs) if p 6= p\nlookup ecs(p, \u03b8)\ndef\n=\u21d2 \u22a5\n(35)\n11\nThe notation \u22a5 is overloaded here, it is an undefined value in exceptional type,\ninstead of exceptional set.\nThe predicate ecan(ecs) is defined to constrain the form of ecs, so that in\neach triple (c, ecs, pt), pt can be related to the (c, ecs) in the following sense:\necan(ecs)\ndef\n=\u21d2 lookup ecs(p, ecs) = (c, ecs, pt) \u21d2\npt (P ) (s) \u21d2 \u2203 s\u2032 .\n(\ns\nproc p \u2261 c\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncsof(ecs)\ns\u2032 \u2227 P (s\u2032)\n)\n(36)\nSince lookup ecs(p, \u03b8) = \u22a5, it clear that ecan(\u03b8) holds. Therefore, by instan-\ntiating ecs to \u03b8, Lemma 4 can be proved as a corollary of Lemma 5.\nThe proof of Lemma 5 is given in Appendix B. The preliminary lemmas used\nin the proof are given in Appendix C.2.\n7 Conclusion\nWe have given a computational embedding of wp in Coq. The definition is verified\nby relating it to an operational semantics. Since such a style of embedding has\nthe benefits of both deep and shallow embedding, it can be used to verify both\nprogram transformations and concrete programs.\nLaibinis and Wright [9] treats general recursion in HOL. But that is a shallow\nembedding and there is no relation between wp and operational semantics.\nThere have been some efforts to verification imperative programs using type\ntheory. Fillitre [6] implemented an extension of Coq to generate proof obligations\nfrom annotated imperative programs. The proof of these proof obligations in\nCoq will guarantee the correctness of the annotated imperative programs. Since\nit uses shallow embedding, meta programming (such as program transformation)\ncan not be verified in Fillitre\u2019s setting.\nKleymann [7] derived Hoare logic directly from operational semantics. Since\nKleymann\u2019s treatment is a deep embedding, program transformations can be\nverified. However, because the operational semantics is formalized as an induc-\ntive relation (rather than using computation), verifying concrete programs in\nKleymann\u2019s setting is not very convenient. This paper can be seen as an effort\nto overcome this problem through a computational treatment of wp. In our set-\nting, computation mechanism can be used to simplify proof obligations when\nverifying concrete programs. Hoare triple can be defined as:\n{P1} c {P2}\ndef\n=\u21d2 P1 (s) \u21d2 wp (c) (P2) (s) (37)\nFrom this, Hoare logic rules for structure statements can be derived. For example,\nthe rule for if e then c1 else c2 is:\nLemma 6 (The proof rule for if e then c1 else c2).\n{\u03bb s. ([[e]]s = true \u2227 P1 (s))} c1 {P2} \u21d2\n{\u03bb s. ([[e]]s = false \u2227 P1 (s))} c2 {P2} \u21d2\n{P1} if e then c1 else c2 {P2}\n12\nHoare logic rules can be used to propagate proof obligations from parent state-\nments to its sub-statements. When the propagation process reaches atomic state-\nments (such as i := e), by expanding the definition of wp, the proof obligation\ncan be simplified by the computation mechanism. Since users have access to\nthe definition of wp all the time, they can choose whatever convenient for their\npurpose, either Hoare logic rules (such as Lemma 6) or the direct definition of\nwp.\nWe have gone as far as the verification of insertion sorting program. Admit-\ntedly, verification of concrete program in our setting is slightly complex than\nin Fillitre\u2019s. However, the ability to verify both program transformations and\nconcrete programs makes our approach unique. The treatment of program veri-\nfication in our setting will be detailed in a separate paper.\nAcknowledgement. I must first thank Prof. Zhaohui Luo for a lot of technical\ndirections into type theory. Dr. James McKinna provided many good comments\non an earlier version of this paper. The anonymous referees are thanked for the\nhelpful suggestions of improvement.\nA Proof of Lemma 3\nThe proof is by induction on the structure of the s\nc\n\u2212\u2192\ncs\ns\u2032 in (23a). Some pre-\nliminary lemmas used in the proof are listed in Appendix C.1. There is one\ncase corresponding to each execution rule. For brevity, only two of the more\ninteresting cases are discussed here:\n1. When the execution is constructed using e proc, we have c = (proc p \u2261 c)\nand s\nc\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncs[p (c,cs)]\ns\u2032. From the induction hypothesis for this execution and\n(23b), it can be derived that:\n\u2203n .\u2200P . P (s\u2032) \u21d2 wpc\n(\n{|cs[p (c, cs)]|}n, c\n)\n(P ) (s) (38)\nBy assigning n to n and expanding the definition of wpc, the goal (23c)\nbecomes:\n\u2200P . P (s\u2032) \u21d2 \u2203n . \u03bb pt.wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n\n(P ) (s) (39)\nBy assigning n+1 to n and expanding the definition of \u00b7 \u00b7 \u00b7\nn+1\n, it becomes:\n\u2200P . P\n(\ns\u2032\n)\n\u21d2 wpc\n(\n{|cs|}n\n[\np 7\u2192 \u03bb pt. wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)\n(P ) (s) (40)\nwhich is exactly (38) with the definition of {| \u00b7 \u00b7 \u00b7 |}n expanded.\n2. When the execution is constructed using e proc, we have c = (pcall p) and\nlookup(cs, p) = (c, cs) (41a)\ns\nc\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncs[p (c,cs)]\ns\u2032 (41b)\n13\nBy applying Lemma 7 to (23b) and (41a), it can be deduced that can(cs),\nfrom which, can(cs[p  (c, cs)]) can be deduced. By applying induction\nhypothesis for (41b) to this, it can be deduced that:\n\u2203n . \u2200P . P\n(\ns\u2032\n)\n\u21d2 wpc\n(\n{|cs|}n\n[\np 7\u2192 \u03bb pt. wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)\n(P ) (s)\n(42)\nBy assigning n + 1 to n, the goal (23c) is specialized to:\nP (s\u2032) \u21d2 {|cs|}n+1 (p)\n(\nP\n)\n(s) (43)\nBy applying Lemma 8 to (41a) and expanding the definition of \u00b7 \u00b7 \u00b7\nn+1\n, it\ncan be deduced that:\n{|cs|}n+1 (p) = wpc\n(\n{|cs|}n+1\n[\np 7\u2192 \u03bb pt. wpc\n(\n{|cs|}n+1\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)\n(44)\nAfter rewritten using (44), the goal (43) becomes:\nP\n(\ns\u2032\n)\n\u21d2 wpc\n(\n{|cs|}n+1\n[\np 7\u2192 \u03bb pt. wpc\n(\n{|cs|}n+1\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n) (\nP\n)\n(s) (45)\nBy applying (42) to the P (s\u2032) in (45), we have:\nwpc\n(\n{|cs|}n\n[\np 7\u2192 \u03bb pt.wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)(\nP\n)\n(s) (46)\nBy applying Lemma 9 to the fact that n \u2264 n+1 and (23b), it can be deduced\nthat {|cs|}n 4\u03c3 {|cs|}\nn+1. By applying Lemma 10 to this, it can be deduced\nthat:\n\u03bb pt. wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n\n4pt \u03bb pt. wpc\n(\n{|cs|}n+1\n[\np 7\u2192 pt\n]\n, c\n) n\n(47)\nBy combining {|cs|}n 4\u03c3 {|cs|}\nn+1 and (47), it can be deduced that:\n{|cs|}n\n[\np 7\u2192 \u03bb pt.wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n]\n4\u03c3\n{|cs|}n+1\n[\np 7\u2192 \u03bb pt.wpc\n(\n{|cs|}n+1\n[\np 7\u2192 pt\n]\n, c\n) n]\n(48)\nBy applying (20a) to this, it can be deduced that:\nwpc\n(\n{|cs|}n\n[\np 7\u2192 \u03bb pt.wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)\n4pt\nwpc\n(\n{|cs|}n+1\n[\np 7\u2192 \u03bb pt.wpc\n(\n{|cs|}n+1\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)\n(49)\nFrom this and (46), the goal (45) can be proved.\n14\nB Proof of Lemma 5\nThe proof is by induction on the structure of c. Some preliminary lemmas used in\nthe proof are listed in Appendix C.2. There is one case for each type of command.\nFor brevity, only two of the more interesting cases are discussed here:\n1. When c = (proc p \u2261 c), after expanding the definition of wpc, the premise\n(31a) becomes:\n\u2203n .\u2200P . \u03bb pt.wpc\n(\nenvof(ecs)\n[\np 7\u2192 pt\n]\n, c\n) n\n(P ) (s) (50)\nA nested induction on n is used to prove the goal, which gives rise to two\ncases:\n(a) When n = 0, this case can be refuted. Since\n\u03bb pt.wpc\n(\nenvof(ecs)\n[\np 7\u2192 pt\n]\n, c\n) n\nreduces to \u03bbP . F, it can not hold on P and s. And this is in contradiction\nwith (50).\n(b) When n = n+1, after expanding the definition of \u00b7 \u00b7 \u00b7\nn+1\n, (50) becomes:\nwpc\n(\nenvof(ecs)\n[\np 7\u2192 \u03bb pt. wpc\n(\nenvof(ecs)\n[\np 7\u2192 pt\n]\n, c\n) n]\n, c\n)\n(P ) (s) (51)\nwhich is exactly\nwpc\n(\nenvof(ecs[p \u21aa\u2192 (c, ecs, \u03bb pt. wpc\n(\nenvof(ecs)\n[\np 7\u2192 pt\n]\n, c\n) n\n)]), c\n)\n(P ) (s)\n(52)\nwith the definition of envof(\u00b7 \u00b7 \u00b7 ) expanded. From the nested induction\nhypothesis for n, it can be proved that:\necan(ecs[p \u21aa\u2192 (c, ecs, \u03bb pt.wpc\n(\nenvof(ecs)\n[\np 7\u2192 pt\n]\n, c\n) n\n)])\nBy applying the main induction hypothesis to this and (52), after ex-\npanding the definition of csof, it can be deduced that:\n\u2203 s . s\nc\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncsof(ecs)[p (c,csof(ecs))]\ns \u2227 P (s) (53)\nBy assigning s to s\u2032, the goal (31d) can be proved directly from the\nP (s) in (53). Also the goal (31c) can be proved by applying e proc to\nthe s\nc\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncsof(ecs)[p (c,csof(ecs))]\ns in (53).\n2. When c = (pcall p), after expanding the definition of wpc, the premise (31a)\nbecomes envof(ecs) (p) (P ) (s). By applying Lemma 11 to this, we have:\n\u2203 c, ecs . lookup ecs(p, ecs) = (c, ecs, envof(ecs) (p)) (54)\n15\nAfter expanding the definition of ecan in (31b), it can be applied to (54) and\nthe envof(ecs) (p) (P ) (s) at the beginning to yield:\n\u2203 s . s\nproc p \u2261 c\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncsof(ecs)\ns \u2227 P (s) (55)\nBy assigning s to s\u2032, the goal (31d) can be proved directly from the P (s) in\n(55). By inversion on the s\nproc p \u2261 c\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncsof(ecs)\ns in (55), we have: s\nc\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\ncsof(ecs)[p (c,csof(ecs))]\ns. By applying Lemma 12 to (54), we have: lookup(p, csof(ecs)) = (c, csof(ecs)).\nTherefore, the goal (31c) can be proved by applying e pcall to these two\nresults.\nC Preliminary lemmas\nC.1 Lemmas used in the proof of Lemma 3\nLemma 7. can(cs) \u21d2 lookup(p, cs) = (c, cs) \u21d2 can(cs)\nLemma 8. lookup(p, cs) = (c, cs) \u21d2 {|cs|}n (p) = \u03bb pt.wpc\n(\n{|cs|}n\n[\np 7\u2192 pt\n]\n, c\n) n\nLemma 9. n1 \u2264 n2 \u21d2 can(cs) \u21d2 {|cs|}\nn1 4\u03c3 {|cs|}\nn2\nLemma 10.\n\u03c31 4\u03c3 \u03c32 \u21d2 mono(\u03c31) \u21d2 mono(\u03c32) \u21d2\n\u03bb pt.wpc\n(\n\u03c31\n[\np 7\u2192 pt\n]\n, c\n) n\n4pt \u03bb pt.wpc\n(\n\u03c32\n[\np 7\u2192 pt\n]\n, c\n) n\nC.2 Lemmas used in the proof of Lemma 5\nLemma 11.\nenvof(ecs) (p) (P ) (s) \u21d2 \u2203 c, ecs .\nlookup ecs(p, ecs) = (c, ecs, envof(ecs) (p))\nLemma 12. lookup ecs(p, ecs) = (c, ecs, pt) \u21d2 lookup(p, csof(ecs)) = (c, csof(ecs))\nReferences\n1. R. J. R. Back. A calculus of refinements for program derivations. Acta Informatica,\n25(6):593\u2013624, August 1988.\n16\n2. B. Barras, S. Boutin, C. Cornes, J. Courant, J.C. Filliatre, E. Gime\u00b4nez, H. Herbelin,\nG. Huet, C. Mu noz, C. Murthy, C. Parent, C. Paulin, A. Sa\u00a8\u0131bi, and B. Werner.\nThe Coq Proof Assistant Reference Manual \u2013 Version V6.1. Technical Report 0203,\nINRIA, August 1997.\n3. D. Carrington, I. Hayes, R. Nickson, G. Watson, and J. Welsh. Refinement in\nErgo. Technical report 94-44, Software Verification Research Centre, School of\nInformation Technology, The University of Queensland, Brisbane 4072. Australia,\nNovember 1994.\n4. T. Coquand and G. Huet. The Calculus of Constructions. Information and Com-\nputation, 76:96\u2013120, 1988.\n5. E. W. Dijkstra. A Discipline of Programming. Prentice-Hall, 1976.\n6. J.-C. Fillia\u02c6tre. Proof of Imperative Programs in Type Theory. In International\nWorkshop, TYPES \u201998, Kloster Irsee, Germany, volume 1657 of Lecture Notes in\nComputer Science. Springer-Verlag, March 1998.\n7. T. Kleymann. Hoare Logic and VDM: Machine-Checked Soundness and Complete-\nness Proofs. Ph.D. thesis, University of Edinburgh, 1998.\n8. J. Knappmann. A PVS based tool for developing programs in the refinement cal-\nculus. Marster\u2019s Thesis, Christian-Albrechts-University, 1996.\n9. L. Laibinis and J. von Wright. Functional procedures in higher-order logic. Tech-\nnical Report TUCS-TR-252, Turku Centre for Computer Science, Finland, March\n15, 1999.\n10. L. Lindqvist. A formalization of Dijkstra\u2019s predicate transformer wp in Martin-Lof\ntype theory. Master\u2019s Thesis, Linkopin University, Sweden, 1997.\n11. Z. Luo. Computation and Reasoning: A Type Theory for Computer Science. Num-\nber 11 in International Series of Monographs on Computer Science. Oxford Uni-\nversity Press, 1994.\n12. C. Morgan. The specification statement. ACM Transactions on Programming\nLanguages and Systems, 10(3):403\u2013419, July 1988.\n13. J. M. Morris. A theoretical basis for stepwise refinement and the programming\ncalculus. Science of Computer Programming, 9(3):287\u2013306, December 1987.\n14. T. Nipkow. Winskel is (almost) right: Towards a mechanized semantics textbook.\nIn V. Chandru and V. Vinay, editors, Proceedings of the Conference on Founda-\ntions of Software Technology and Theoretical Computer Science, pages 180\u2013192.\nSpringer-Verlag LNCS 1180, 1996.\n15. B. Nordstro\u00a8m, K. Peterson, and J. M. Smith. Programming in Martin-Lof\u2019s Type\nTheory, volume 7 of International Series of Monographs on Computer Science.\nOxford University Press, New York, NY, 1990.\n16. R. J. R. Back and J. von Wright. Refinement concepts formalized in higher-\norder logic. Reports on Computer Science & Mathematics Series A\u201485, Insti-\ntutionen fo\u00a8r Informationsbehandling & Mathematiska Institutet, A\u02dabo Akademi,\nLemminka\u00a8inengatan 14, SF-20520 Turku, Finland, September 1989.\n17. M. Staples. A Mechanised Theory of Refinement. Ph.D. Dissertation, Computer\nLaboratory, University of Cambridge, 1998.\n18. M. Staples. Program transformations and refinements in HOL. In Y. Bertot\nG. Dowek, C. Paulin, editor, TPHOLs: The 12th International Conference on The-\norem Proving in Higher-Order Logics. LNCS, Springer-Verlag., 1999.\n19. J. von Wright and K. Sere. Program transformations and refinements in HOL. In\nMyla Archer, Jennifer J. Joyce, Karl N. Levitt, and Phillip J. Windley, editors,\nProceedigns of the International Workshop on the HOL Theorem Proving System\nand its Applications, pages 231\u2013241, Los Alamitos, CA, USA, August 1992. IEEE\nComputer Society Press.\n"}