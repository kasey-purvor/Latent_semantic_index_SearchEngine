{"doi":"10.1145\/1982185.1982285","coreId":"197451","oai":"oai:lra.le.ac.uk:2381\/9699","identifiers":["oai:lra.le.ac.uk:2381\/9699","10.1145\/1982185.1982285"],"title":"Matching Customer Requests to Service Offerings in Real-Time","authors":["Tilly, Marcel","Reiff-Marganiec, Stephan"],"enrichments":{"references":[{"id":43709454,"title":"A Graphical Editor For Complex Event Pattern Generation,&quot;","authors":[],"date":"2009","doi":"10.1145\/1619258.1619309","raw":"S. Sen, N. Stojanovic, and R. Lin, &quot;A Graphical Editor For Complex Event Pattern Generation,&quot; Third ACM international Conference on Distributed Event-Based Systems, 2009.","cites":null},{"id":43709459,"title":"A QoS Ontology Language for WebServices,&quot; Advanced Information Networking and Applications,","authors":[],"date":"2006","doi":"10.1109\/aina.2006.51","raw":"I.V. Papaioannou, D.T. Tsesmetzis, I.G. Roussaki, and M.E. Anagnostou, &quot;A QoS Ontology Language for WebServices,&quot; Advanced Information Networking and Applications, 2006. AINA 2006. 20th International Conference on, vol. 1, 2006, p. 6 pp.","cites":null},{"id":43709470,"title":"Aurora: A data stream management system,&quot;","authors":[],"date":"2003","doi":"10.1145\/872757.872855","raw":"D.J. Abadi, D. Carney, U.C. Etintemel, M. Cherniack, C. Convey, C. Erwin, E.F. Galvez, M. Hatoun, A. Maskey, A. Rasin, A. Singer, M. Stonebraker, N. Tatbul, Y. Xing, R. Yan, and S.B. Zdonik, &quot;Aurora: A data stream management system,&quot; in SIGMOD Conference, 2003.","cites":null},{"id":43709457,"title":"Consistent Streaming Through Time : A Vision for Event Stream Processing 2 . CEDR Temporal Stream Model,&quot; General Systems,","authors":[],"date":"2007","doi":null,"raw":"R.S. Barga, J. Goldstein, M. Ali, and M. Hong, &quot;Consistent Streaming Through Time : A Vision for Event Stream Processing 2 . CEDR Temporal Stream Model,&quot; General Systems, 2007.","cites":null},{"id":43709465,"title":"Efficient algorithms for Web services selection with end-to-end QoS constraints,&quot;","authors":[],"date":"2007","doi":"10.1145\/1232722.1232728","raw":"T. Yu, Y. Zhang, and K. Lin, &quot;Efficient algorithms for Web services selection with end-to-end QoS constraints,&quot; ACM Transactions on the Web, vol. 1, 2007, pp. 6-es.","cites":null},{"id":43709471,"title":"High-performance complex event processing over streams,&quot;","authors":[],"date":"2006","doi":"10.1145\/1142473.1142520","raw":"E. Wu, Y. Diao, and S. Rizvi, &quot;High-performance complex event processing over streams,&quot; Proceedings of the 2006 ACM SIGMOD international conference on Management of data - SIGMOD '06, 2006, p. 407.","cites":null},{"id":43709468,"title":"Load Shedding in Stream Databases : A Control-Based Approach,&quot; Framework,","authors":[],"date":null,"doi":null,"raw":"Y.T. Song, L. Sunil, P. Bin, and W. Lafayette, &quot;Load Shedding in Stream Databases : A Control-Based Approach,&quot; Framework, pp. 787-798.","cites":null},{"id":43709458,"title":"Non-functional property based service selection : A survey and classification of approaches,&quot;","authors":[],"date":"2008","doi":null,"raw":"H.Q. Yu and S. Reiff-Marganiec, &quot;Non-functional property based service selection : A survey and classification of approaches,&quot; Proc. of the Non Functional Properties and Service Level Agreements in SOC Workshop (NFPSLASOC), 2008.","cites":null},{"id":43709466,"title":"Pushing reactive services to XML repositories using active rules,&quot;","authors":[],"date":"2002","doi":"10.1016\/s1389-1286(02)00226-8","raw":"A. Bonifati, S. Ceri, and S. Paraboschi, &quot;Pushing reactive services to XML repositories using active rules,&quot; Computer Networks, vol. 39, 2002, pp. 645-660.","cites":null},{"id":43709456,"title":"Scalable planning for distributed stream processing systems,&quot;","authors":[],"date":"2006","doi":null,"raw":"A. Riabov and Z. Liu, &quot;Scalable planning for distributed stream processing systems,&quot; In ICAPS\u2019, vol. 06, 2006.","cites":null},{"id":43709460,"title":"Service Selection based on Non-Functional Properties,&quot; ServiceOriented Computing - ICSOC","authors":[],"date":"2007","doi":"10.1007\/978-3-540-93851-4_13","raw":"S. Reiff-Marganiec, H.Q. Yu, and M. Tilly, &quot;Service Selection based on Non-Functional Properties,&quot; ServiceOriented Computing - ICSOC 2007 Workshops, Lecture Notes in Computer Science, vol. 4907, 2009, pp. 1-14.","cites":null},{"id":43709455,"title":"The Power of Events: An Introduction to Complex Event Processing","authors":[],"date":"2002","doi":"10.1145\/766760.764027","raw":"D. Luckham, The Power of Events: An Introduction to Complex Event Processing in Distributed Enterprise Systems, Amsterdam: Addison-Wesley Longman, 2002.","cites":null},{"id":43709469,"title":"Towards expressive publish\/subscribe systems,&quot;","authors":[],"date":"2006","doi":"10.1007\/11687238_38","raw":"A.J. Demers, J. Gehrke, M. Hong, M. Riedewald, and W.M. White, &quot;Towards expressive publish\/subscribe systems,&quot; in EDBT, 2006, pp. 627-644.","cites":null},{"id":43709453,"title":"Using Events in Highly Distributed Architectures,&quot; The Architecture Journal,","authors":[],"date":"2008","doi":null,"raw":"D. Chou, &quot;Using Events in Highly Distributed Architectures,&quot; The Architecture Journal, 2008.","cites":null},{"id":43709467,"title":"Web Monitoring 2.0: Crossing Streams to Satisfy Complex Data Needs,&quot;","authors":[],"date":"2009","doi":"10.1109\/icde.2009.204","raw":"H. Roitman, A. Gal, and L. Raschid, &quot;Web Monitoring 2.0: Crossing Streams to Satisfy Complex Data Needs,&quot; 25th International Conference on Data Engineering (ICDE '09), 2009.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2011","abstract":"This paper received the SAC 2011 Best Paper award in the Engineering Category.Classic request-response Service-oriented architecture (SOA) has reached a level of maturity where SOA inspired extensions are enabling new and creative domains like the Internet of Things, real-time business or real-time Web. These new domains impose new requirements on SOA, such as a huge data volume, meditation between various data structures and a large number of sources that need to be procured, processed and provided with almost zero latency. Service selection is one of the areas where decisions have to be made based consumer requests and service offerings. Processing this data requires typical SOA behavior combined with more elaborate approaches to process large amounts of data with near-zero latency. The approach presented in this paper combines pub-sub approaches for processing service offerings and mediations with classical request-response SOA approaches for consumer requests facilitated by Complex Event Processing (CEP). This paper presents a novel approach for subscribing to dynamic service properties and receiving up-to-date information in real-time. Therefore, we are able to select services with zero latency since there is no need to pull for property values anymore. The paper shows how to map requests to streaming data, how to process and answer complex requests with low latency and how to enable real-time service selection.Peer reviewedPost prin","downloadUrl":"http:\/\/doi.acm.org\/10.1145\/1982185.1982285","fullTextIdentifier":"https:\/\/lra.le.ac.uk\/bitstream\/2381\/9699\/2\/2011-4.pdf","pdfHashValue":"9e69965591ab1b2b246901fe475cfc278c1979cb","publisher":"Association for Computing Machinery (ACM)","rawRecordXml":"<record><header><identifier>\n        \n            \n                oai:lra.le.ac.uk:2381\/9699<\/identifier><datestamp>\n                2011-09-17T01:02:12Z<\/datestamp><setSpec>\n                com_2381_316<\/setSpec><setSpec>\n                com_2381_9549<\/setSpec><setSpec>\n                col_2381_4072<\/setSpec>\n            <\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:doc=\"http:\/\/www.lyncode.com\/xoai\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n            \nMatching Customer Requests to Service Offerings in Real-Time<\/dc:title><dc:creator>\nTilly, Marcel<\/dc:creator><dc:creator>\nReiff-Marganiec, Stephan<\/dc:creator><dc:subject>\nMediation<\/dc:subject><dc:subject>\nService Selection<\/dc:subject><dc:subject>\nComplex Event Processing<\/dc:subject><dc:subject>\nNon-Functional Properties<\/dc:subject><dc:subject>\nSOA<\/dc:subject><dc:description>\nThis paper received the SAC 2011 Best Paper award in the Engineering Category.<\/dc:description><dc:description>\nClassic request-response Service-oriented architecture (SOA) has reached a level of maturity where SOA inspired extensions are enabling new and creative domains like the Internet of Things, real-time business or real-time Web. These new domains impose new requirements on SOA, such as a huge data volume, meditation between various data structures and a large number of sources that need to be procured, processed and provided with almost zero latency. Service selection is one of the areas where decisions have to be made based consumer requests and service offerings. Processing this data requires typical SOA behavior combined with more elaborate approaches to process large amounts of data with near-zero latency. The approach presented in this paper combines pub-sub approaches for processing service offerings and mediations with classical request-response SOA approaches for consumer requests facilitated by Complex Event Processing (CEP). This paper presents a novel approach for subscribing to dynamic service properties and receiving up-to-date information in real-time. Therefore, we are able to select services with zero latency since there is no need to pull for property values anymore. The paper shows how to map requests to streaming data, how to process and answer complex requests with low latency and how to enable real-time service selection.<\/dc:description><dc:description>\nPeer reviewed<\/dc:description><dc:description>\nPost print<\/dc:description><dc:date>\n2011-09-16T14:13:19Z<\/dc:date><dc:date>\n2011-09-16T14:13:19Z<\/dc:date><dc:date>\n2011<\/dc:date><dc:type>\nConference paper<\/dc:type><dc:identifier>\nTilly, Marcel and Reiff-Marganiec, Stephan, \u2018Matching Customer Requests to Service Offerings in Real-Time ' in SAC '11 Proceedings of the 2011 ACM Symposium on Applied Computing, pp. 456-461<\/dc:identifier><dc:identifier>\n978-1-4503-0113-8<\/dc:identifier><dc:identifier>\nhttp:\/\/oldwww.acm.org\/conferences\/sac\/sac2011\/<\/dc:identifier><dc:identifier>\nhttp:\/\/dl.acm.org\/citation.cfm?id=1982285<\/dc:identifier><dc:identifier>\nhttp:\/\/hdl.handle.net\/2381\/9699<\/dc:identifier><dc:identifier>\n10.1145\/1982185.1982285<\/dc:identifier><dc:language>\nen<\/dc:language><dc:rights>\n\u00a9 ACM, 2011. This is the author's version of the work. It is posted here by permission of ACM for your personal use. Not for redistribution. The definitive version was published in SAC '11 Proceedings of the 2011 ACM Symposium on Applied Computing, 2001. http:\/\/doi.acm.org\/10.1145\/1982185.1982285<\/dc:rights><dc:publisher>\nAssociation for Computing Machinery (ACM)<\/dc:publisher>\n<\/oai_dc:dc>\n<\/metadata>\n        <\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2011,"topics":["Mediation","Service Selection","Complex Event Processing","Non-Functional Properties","SOA"],"subject":["Conference paper"],"fullText":"\u00a9 ACM, 2011. This is the author's version of the work. It is posted here by permission of \nACM for your personal use. Not for redistribution. The definitive version was published in \nSAC '11 Proceedings of the 2011 ACM Symposium on Applied Computing, 2001. \nhttp:\/\/doi.acm.org\/10.1145\/1982185.1982285 \nMatching Customer Requests to Service Offerings in Real-\nTime \nMarcel Tilly \nEuropean Microsoft Innovation Center \nRitterstrasse 23 \nAachen, Germany \n \nmarcel.tilly@microsoft.com \nStephan Reiff-Marganiec \nDepartment of Computer Science \nUniversity of Leicester \nLeicester, UK \n \nsrm13@le.ac.uk \n \n \n \nABSTRACT \nClassic request-response Service-oriented architecture (SOA) has \nreached a level of maturity where SOA inspired extensions are \nenabling new and creative domains like the Internet of Things, \nreal-time business or real-time Web. These new domains impose \nnew requirements on SOA, such as a huge data volume, \nmeditation between various data structures and a large number of \nsources that need to be procured, processed and provided with \nalmost zero latency. Service selection is one of the areas where \ndecisions have to be made based consumer requests and service \nofferings. Processing this data requires typical SOA behavior \ncombined with more elaborate approaches to process large \namounts of data with near-zero latency. The approach presented in \nthis paper combines pub-sub approaches for processing service \nofferings and mediations with classical request-response SOA \napproaches for consumer requests facilitated by Complex Event \nProcessing (CEP). This paper presents a novel approach for \nsubscribing to dynamic service properties and receiving up-to-\ndate information in real-time. Therefore, we are able to select \nservices with zero latency since there is no need to pull for \nproperty values anymore. The paper shows how to map requests \nto streaming data, how to process and answer complex requests \nwith low latency and how to enable real-time service selection. \nCategories and Subject Descriptors \nH3.4 [Systems and Software]: Current awareness systems, \ndistributed systems and user profiles and alert services \nGeneral Terms \nAlgorithms \nKeywords \nMediation, Service Selection, Complex Event Processing, Non-\nFunctional Properties, SOA. \n1. INTRODUCTION \nNowadays businesses as well as the Web require for \ninformation to be available in real-time in order to reply to \nrequest, make decisions and generally stay competitive. This in \nturn requires for data to be processed in real-time. In general in \nservice-oriented architecture (SOA) we are less concerned about \nlatency of data processing. Clearly, there are investigations of \nservice-level agreements (SLA) and quality of service (QoS) to \nguarantee service delivery. Based on this, several approaches on \nmonitoring SLAs have emerged and solutions to find most \nrelevant services for a given context have been developed. Most \nof this work is assuming that the relevant information for decision \nmaking is available and accurate.  \nProperties for service selection are considered to be non-\nfunctional or functional, and the available approaches are based \non the fact that properties are pulled from service repositories \n(that is from service metadata) or possibly from the services \ndirectly before the algorithm determines the most relevant service \nfor a given context. Repositories are useful for static data and \npolling services directly works if a small number of properties of a \nsmall number of services is of interest. We believe that there is an \nemergent need to provide methods to enable the continuous \nevaluation of functional and non-functional properties especially \nin the case where the number of services is high [1]. \nLet\u201fs assume there is a user who tries to locate the nearest \nprinter with the shortest print queue because he has a deadline and \nneeds to print out an important report. Therefore, the system \nneeds the location of the user, typically part of a user profile, the \ngeographical location of the printers, and information about the \nprint queue of each printer. In service selection, an algorithm \ncompares the location of the user with the location of the printer \ntaking into account the number of documents in each print queue. \nThere are several approaches which are able to identify the most \nrelevant printer within a given context \u2013 so this is not the \nchallenge we are tackling in this paper; we are interested in \nobtaining the data that is used for the decision making. The \ngeographical location is static information \u2013 it does not change \ncontinuously over time. We will be using the term static property \nfor properties whose values are static over time. The number of \ndocuments in the print queue is not static \u2013 it is time dependent \nand changes over time as documents are printed or new \ndocuments are added to the queue. Hence the length of the print \nqueue is a dynamic property.  \nIt is quite challenging to get an accurate view of this data \nwith classic request-response approaches which are usually \nemployed in SOA. Consider the number of printers within in a \ncompany, all taxis of a company within a city, or even the shuttle \nservice on a large company campus. Here the number of possible \nservices, namely printers, taxis, or shuttles is high. In addition the \nlength of the print queue or the geo location of taxis or shuttles \nchange very frequently \u2013 they are highly dynamic properties. \nUsing a typical request-response approach every time a user asks \nfor a taxi the system has to poll all the taxis\u201f geo locations and \nother properties just to be able to identify the most relevant one \nfor the request \u2013 if we consider that this might be 50 or even 100 \ntaxis we get a feeling for the scale. In such realistic settings it is \nbecoming quite challenging to answer a simple question such as \n\u201efind the nearest shuttle to my location\u201f quickly. \nWe already identified a need for methods for continuously \nevaluating properties. We can define this more crisply as a need \nfor an approach delivering dynamic service properties at any time \nto support service selection from huge lists of services. \nIn this paper we consider the use of complex event \nprocessing to enable a real-time view of dynamic service \nproperties to enable a fast and accurate view of their values with \nan application in real-time service selection. Our approach can be \nseamlessly integrated with existing service selection approaches. \nWe present a novel architecture, data model and selection process \nto put the above into practice. \nBasically, we propose to combine existing request-response \napproaches (the pull model, Figure 1(a)) with publish-subscribe \ntechniques (the push model) (Figure 1(b)). \n \nConsumer\nProvider A\nProvider B\nProvider C\n(a) Pull model to get service propterties\nConsumer\nProvider A\nProvider B\nProvider n\n(b) Push model to get informed about service property changes\n...\nsm\na\nll\n n\nu\nm\nb\ne\nr \no\nf \np\nro\nvi\nd\ne\nrs\nb\nig\n n\nu\nm\nb\ne\nr \no\nf \np\nro\nvi\nd\ne\nrs\n \nSection 2 presents a motivating example, enforcing the need \nfor the mechanisms presented, while section 3 provides some \nessential background work. Sections 4 and 5 represent the core of \nthe paper where we introduce the architecture and selection \nprocess respectively. Section 6 points to some related work while \nsection 7 concludes the paper and provides an outlook to further \nwork. \n2. Motivating Example \nWe will introduce one example to highlight the necessity of \nour approach. This approach is useful in all scenarios in which we \nneed to select services from a large set of services which one can \nusually find in sensor networks, e.g.  \n \n Wireless traffic sensor networks to monitor vehicle traffic on \nhighways or in congested parts of a city. \n Wireless surveillance sensor networks for providing security \nin shopping malls, parking garages, and other facilities. \n Wireless parking lot sensor networks to determine which \nspots are occupied and which are free. \n \nIn fleet management, like taxi companies, with a large \namount of taxis it is almost impossible to use the classical request-\nresponse approach to find the nearest taxi for a given user \nlocation. Therefore the fleet management must be aware of the \ntaxis location at any given time. But there is usually also no need \nto store all the provided locations of all taxis forever. The \nmanagement system only requires the latest data to process a user \nrequest to locate the nearest taxi. There is no necessity to persist \nthe data for later use. \nIn the scenario (see Figure 2) there is a customer with a given \ngeo location requesting a taxi. The fleet management system has \nto identify the most relevant taxi in terms of (1) availability and \n(2) proximity to the customer\u201fs location. There are two taxis, A \nand C, which are close to the customer\u201fs location but they are not \navailable. Taxi B is the closest which is available. Of course the \nfleet management could take traffic information into account, and \nthen maybe taxi D becomes the best solution because it is \nreasonably close, available and might arrive earlier because of \nbeneficial traffic conditions. \nThis scenario shows (1) how different kind of properties of \ntaxis (here: availability and geo location) and (2) properties of \ndifferent services (here: taxi and traffic) are used to select \nservices. Furthermore, the geo location and the traffic information \nare data which changes rapidly and it does not make sense to store \nall of this data because it is only relevant when a service has to be \nselected. \n \n \n \nAnother scenario, not explored in this paper, could be using \nTwitter to explore new interesting topics. Here, the system could \nsubscribe to several twitter feeds and use semantics to identify \nkeywords. If in a given frame a hot spot around a specific term \nemerges this can be identified as important news; something is \nexplored in [2]. \n3. Background \nThe section introduces the basic ideas which we combine to \nimprove service selection and mediation approaches for consumer \nrequests in real-time. Thus, we will also provide a short \nintroduction to complex event processing (CEP) which we use to \nprocess dynamic service properties. \nMany SOA efforts are focusing on implementing \nsynchronous or asynchronous request-response interaction \npatterns. This approach works for highly centralized environments \nand create loose coupling for distributed software components. It \nFigure 1: Metaphor change from pull to push model \nFigure 2: Taxi management using geo location, availability \nand traffic information \ntends to create tight coupling and added dependencies for \nbusiness processes at functional level. \nWhile this is not true on the conceptual level it is still very \nvalid on a technical level. On the conceptual level SOA already \nachieves loose coupling this is not available on the \nimplementation level. On this level the consumer in most cases is \ncoupled to a concrete service by generating a proxy based on \ninterface definitions, such as WSDL. \nThus, in the migration towards real-time enterprises which \nare also constantly connected and always available on the web, we \nhave to rethink the current approaches and have to investigate \nalternative approaches and design patterns in addition to \nsynchronous request-driven SOA. \n3.1 Complex Event Processing \nComplex event processing (CEP) is the continuous and \nincremental processing of event streams from multiple sources \nbased on declarative query and pattern specifications in quasi real-\ntime with near-zero latency as described in [3]. CEP is a set of \ntechniques and tools helping to understand and control event-\ndriven information systems. It consists of very simple techniques \n\u2013 a set of old and new ones \u2013 from which some are well-known, \nsuch as rule-based systems and others are novel techniques, such \nas tracking causal histories of events in large distributed computer \nsystems. Therefore, the approach on using CEP for our approach \nis very promising.  \nA complex event is an event which aggregates incoming \nsource events that are related in various ways, such as by cause, \nby time, or by membership. CEP makes use of relationship \nbetween events to answer questions like: \n \n \u201cIs our system doing the things it should do?\u201d \n \u201cWill our shipment arrive on time?\u201d \n \u201cIs something going wrong in our production line?\u201d \n \nCEP is applicable to a many information systems and in fact \nis already used in e.g. analysing click-streams of users in the \ninternet. It helps to define and utilize relationships between \nevents. In addition it is also flexible because a user can specify the \nevents and their relation at any time. In these efforts, the goal is to \nbuild a data management system that handles data streams as first \nclass citizens. These systems use SQL like query languages in \norder to express queries on the data streams. We will be using \nCEP as a system to process incoming events and provide a real-\ntime view to the subscribed service properties.  \n \n4. Basic concepts \nIn our work, services offer dynamic properties to which \nconsumer can subscribe, such as the dynamic GeoLocation \nproperty of a taxis service and the number of current passengers \nfrom which the system can derive if the taxi is available or not. \n \n \n \nWe envision that our approach can be adopted easily as it \nonly requires the addition of two interfaces: (1) The publisher \nendpoint is exposed on the service side to which the consumer can \nregister or subscribe to events and (2) the subscriber endpoint is \nexposed by the consumer to enable the services to fire events in a \nfire and forget fashion (see Figure 3). \nThe publisher interface which enables the registry to subscribe to \na set of dynamic properties provides two operations:  \n \nSubscribe(topic, refresh time, endpoint): Id \n \n topic: the topic to be subscribed to, using dot notation \nsuch as Dynamic.GEOLocation \n refreshTime: how often should events be send out \n endpoint: the endpoint of the publish event operation \n Id: Unique registration id for the subscription \n \nUnsubscribe(Id) \n Id: Unique registration id \n \nThe subscriber interface offered by the consumer provides only \none operation: \n \nPublishEvent(event) \n \nAn event event is a tuple of values event=<se, ts, te, p>, \ncontaining service endpoint address se, time information ts and te, \nand payload p. The time information defines the valid start time ts \nand end time te of the event and the payload is defined by the type \nof the subscribed topic. For example the GeoLocation could be \ndefined as record with Longitude and Latitude, both of the XML \nschema type xs:int. \nAs described in [4] processing of streaming data is an \nimportant practical problem that arises in time-sensitive \napplications where the data must be analyzed as soon as they \narrive, or where the large volume of incoming data makes storing \nall data for future analysis impossible. Stream processing has \nbecome a hot research topic in several areas including stream data \nmining, stream database or continuous queries, and sensor \nnetworks. \nWe define static properties ps as constant over time, such as a \nlocation of a printer, the vendor of a printing machine, or the \nnumber of a taxi etc. Dynamic properties pd are changing over \ntime. Using these, we define non-functional properties NFP as a \ntuple of static properties and dynamic properties:  \nNFP(t)=<ps, pd>. \nFor the fleet management scenario the schema of the non-\nfunctional properties might look as follows: \n \n<NFProperties> \n  <Static> \n    <TaxiId type=\u201dxs:string\u201d\/> \n  <\/Static> \n  <Dynamic> \n    <GEOLocation> \n      <Longitude type=\u201dxs:int\u201d\/> \n      <Latitude type=\u201dxs:int\u201d\/> \n    <\/GEOLocation> \n    <PassengerNumber type=\u201dxs:int\u201d\/> \nFigure 3: Pub\/Sub endpoints \n  <\/Dynamic> \n<\/NFProperties> \n \nThis presents the static data schema; like a snapshot in time. \nTemporal aspects are covered by events and therefore we would \nsee different data at different point in time. \nSince temporal dynamic properties are defined as time \ndependent we can see them as discrete events and use standard \ntemporal algebra approaches to reason over them. Current \ntemporal algebra research and solutions are focusing on complex \nevent processing. Therefore, we can use on consumer side rule \nbased approaches to select and project events from data streams. \nSQL-like syntax can be used to express complex aggregations and \ncorrelations on those event streams, such as \n \nSelect e from s where Op(e) \n \nwith \ne: event from stream \ns:  event stream \nOp: Operation on events from stream \n5. Architecture \nAs a central instance we still use a Registry. This Registry \nencapsulates the processing of the incoming request from \nconsumer side and the incoming events from service side and \nmaps both. To setup the system there is a need that for a potential \nconsumer request (here: Find a taxi) the system has to identify all \nservices and subscribe to the relevant non-functional properties \nwhich will support our service selection during runtime (see \nFigure 4). Thus, during runtime the Registry is receiving \ncontinuous streams of events from subscribed services. Then, an \nincoming consumer request is handled as a query on subscribed \nservice properties.  \n \n \nInstead of pulling at request time all the data from all \nservices the registry knows at any time the status of all services. \nTherefore, this allows for service selection in real-time \nindependent of the number of services. \nAn event will contain metadata and payload. The metadata \ncontains information about the time when the event was created \non publisher side. We are enriching this time information also \nwith subscriber time information when the event enters the \nsubscribers system. The payload is defined by the schema of the \nsubscribed topic, such as GeoLocation containing Longitude and \nLatitude. \n5.1 Request Mediator \nThe Request Mediator exposes an endpoint to collect all \nincoming events from registered services. Its responsibility is to \nnormalize the incoming data streams. Usually, not all events \nprovide the same data structure therefore the Request Mediator \nmaintains a mapping table to transform incoming events from \nendpoints into a normalized data stream. Let\u201fs assume the \nservice1 provides events containing GEOLocation and \navailability while service service3 provides the data as \nMyLocation and Customer_Number. In our current \nimplementation we are simply using XSLT scripts to normalize \nevent streams internally before the event data is forwarded to the \nInformation Mediator. \n5.2 Information Mediator  \nThe Information Mediator maps consumer request to queries \non continuous event streams provided by the request mediator. On \nthe consumer side the framework still offers a normal Web \nService interface which internally needs to transform into a query \nwhich is executed over the event stream. Ideally this queries are \nnot hard coded somewhere but they are stored in a repository to \nbe adaptable during runtime. \nThe Information Mediator also ensures the quality of the \nevents from event streams, such as duplicated events or out-of-\norder events. Here, our approach benefits from the CEP work. The \nspecific time information we are adding to the event helps to \ncontrol the quality of events and result. While valid start time and \nvalid end time are generated at service side the Information \nMediator also added internal time information (called: System \ntime) to the events. Within the Information Mediator internal \nclock increments are used to move time forward decoupled from \nexternal sources. Thus, the order of events is guaranteed and the \nquality of the results can be ensured. Basically, this is a classical \nCEP topic (see [5]) and the approach is simply benefiting from \nusing CEP technology here. In addition the Information Mediator \nis able to detect missing events since the refresh time is set within \nthe subscription process. Here it is possible to apply different \npolicy to react on missing events, such as simply ignore missing \nevents, use the latest event until a new event arrive, or raise an \nexception because the absent of an event is an exceptional case. \nHow to handle missing events depends on the scenario and does \nnot require a general solution. \nBasically, the decoupling of information and requests helps \nto integrate flexible other work into our solution. Thus, it is easy \nto improve the request mediator with some more sophisticated \nSemantic Web Service implementation if needed. \n \n \n \n \n \n \n \n \n \nFigure 4: Concept of using pub\/sub for service selection \nRegistry\nService 1\nConsumer Request\nService 2\nService 3\nService n\n...\nContinous\nQuery\nProcessor\nRequest to \nQuery \nTranslator\nRequest a taxi Find nearest available taxi\nSubscribe to GEOLocation and \nCustomerNumber changes\n6. Validation example \nLet us go back to the taxi management scenario to illustrate \nthe presented theory with a simple example. We will not describe \nhow a service (in this case a taxi) is sending messages (\u201eevents\u201f) \nvia soap request to the request mediator. However, an event looks \nlike this: \n \nE1= <  \nse=\u2019http:\/\/www.contoso.com:8080\/taxi3\u2019; \nts=2010-08-20 10:30:30;  \nts=2010-08-20 10:30:40, \np= < \n MyLocation.Longitude=12; \n MyLocation.Latitude = 10 \n Customer_Number = 1 \n> \n> \nThe event E1 is provided by the endpoint taxi1 with a valid \ntimespan of 10 sec. (te-ts). The payload for taxi3 is MyLocation \nand Customer_Number. The Request Mediator tranforms the \npayload into the normalized payload for the query. Thus, the \nevent E1\u201f looks like: \n \nE1\u2019= <  \nse=\u2019http:\/\/www.contoso.com:8080\/taxi3\u2019; \nts=2010-08-20 10:30:30; \nts=2010-08-20 10:30:40, \np= < \n GEOLocation.Longitude=12; \n GEOLocation.Latitude = 10 \n Available = false \n> \n> \n \nThe Information Mediator adds system time information to \nthe events and checks if other events can be discarded already. \nFor a user request at a given time t we only have to take into \naccount the events in which time t is part of events\u201f valid time \ninterval (see Figure 6). In the sample this is event e13 for taxi 1, \nevent e22 for taxi 2, and event e32 for taxi 3. The Information \nMediator uses only these events to execute the query to find the \nnearest taxis for the given user location which is available. That\u201fs \nit \u2013 one simple query and a reply in real-time.  \n \n7. Related Work \nWhile much focus has been given to efficient data processing \nmethods that support complex data needs (expressed for example \nby queries or user profiles), less attention has been given to \nefficient data gathering methods in SOA for service selection and \nmediation. \nAs already mentioned there is a lot of work about service \nselection based on non-functional properties. The work [6] about \nprovides a survey and classification about service selection based \non non-functional properties. Most of the related work on using \nnon-functional properties for service selection concentrates on \ndefining QoS (Quality of Service) ontology languages and \nvocabularies and identification of various QoS metrics and their \nmeasurements with respect to semantic services. In [7] QoS \nontology models are defined while [8] separates different non-\nfunctional criteria into different service categories. This is more \nsensible than ranking all kinds of services by using the same \npredefined criteria and hence not considering the different \nattributes that occur with specific services. The key feature of this \napproach is about incorporating the Logic Scoring of Preferences \n(LSP) for ranking different services. In [9] is also a strong focus \non efficiency of the algorithm but not on gathering, collecting and \naggregating properties for the algorithm itself. \nBonifati et. al. [10] describes a very interesting approach for \nusing of active rules for pushing reactive services. The \nFigure 6: Event streams of taxi 1 to 3 \nFigure 5: General architecture of continuous event processing for service selection \ncombination of this approach with our approach would need some \nfurther investigation but looks promising as an end-to-end \nsolution for pre-filtering on service side to reduce network traffic \nand to correlate and aggregate on consumer side for real-time \nservice selection and adaptability. Roitman et. al. [11] presents a \nframework for satisfaction of complex data needs involving \nvolatile data. But the focus is on pull-based environments. \nWith push based systems, data is pushed to the system and \nthe research focus is mainly on aspects of efficient data \nprocessing, where load shedding techniques [12] can be applied in \norder to control what portions of the pushed data to process and to \nincrease latency. Such systems include publish-subscribe \n(pub\/sub) ([13]), stream processing ([14]), and complex event \nprocessing ([15]). \nBut all these systems do not combine their approach with \nSOA to improve service selection. Pub-sub systems allow the \nregistration of complex requirements at servers and focus mainly \non the trade-off between data processing efficiency and the \nexpressiveness of the queries that can be processed by the system. \nStream processing systems are also push-based in nature and \nfocus mainly on smart filtering and load shedding techniques. \nComplex event processing systems such assume the pushing of a \nstream of raw events and focus mainly on efficient complex events \nand situations identification only. \n8. Conclusions and Future Work \nWe presented a new approach which combines CEP with \nservice selection approaches to enable a new set of scenarios for \nservice selection. Our approach investigates service selection \nproblems with a huge number of potential services and highly \ndynamic service properties. We presented an easy way to \nseamlessly integrate our approach into existing service selection. \nWe presented a way to subscribe to specific dynamic properties. \nThis enables the service selection to be faster in their selection \nprocess and more accurate by having more real-time data. This \nwas achieved by replacing the classical pull approach with a push \napproach.  \nThe next steps are to provide more validation results and to \nextend it towards situations where services do not offer exactly \nthe same dynamic properties. We believe that we can easily adapt \nwork from semantic web and mediation approaches.  \nIn addition we will also investigate if the approach can also \nimprove service composition by using context information or user \ndata in real-time. \n9. References \n[1]   D. Chou, \"Using Events in Highly Distributed \nArchitectures,\" The Architecture Journal, 2008. \n[2]   S. Sen, N. Stojanovic, and R. Lin, \"A Graphical Editor \nFor Complex Event Pattern Generation,\" Third ACM \ninternational Conference on Distributed Event-Based \nSystems, 2009. \n[3]   D. Luckham, The Power of Events: An Introduction to \nComplex Event Processing in Distributed Enterprise \nSystems, Amsterdam: Addison-Wesley Longman, 2002. \n[4]   A. Riabov and Z. Liu, \"Scalable planning for distributed \nstream processing systems,\" In ICAPS\u2019, vol. 06, 2006. \n[5]   R.S. Barga, J. Goldstein, M. Ali, and M. Hong, \n\"Consistent Streaming Through Time : A Vision for \nEvent Stream Processing 2 . CEDR Temporal Stream \nModel,\" General Systems, 2007. \n[6]   H.Q. Yu and S. Reiff-Marganiec, \"Non-functional \nproperty based service selection : A survey and \nclassification of approaches,\" Proc. of the Non \nFunctional Properties and Service Level Agreements in \nSOC Workshop (NFPSLASOC), 2008. \n[7]   I.V. Papaioannou, D.T. Tsesmetzis, I.G. Roussaki, and \nM.E. Anagnostou, \"A QoS Ontology Language for Web-\nServices,\" Advanced Information Networking and \nApplications, 2006. AINA 2006. 20th International \nConference on, vol. 1, 2006, p. 6 pp. \n[8]   S. Reiff-Marganiec, H.Q. Yu, and M. Tilly, \"Service \nSelection based on Non-Functional Properties,\" Service-\nOriented Computing - ICSOC 2007 Workshops, Lecture \nNotes in Computer Science, vol. 4907, 2009, pp. 1-14. \n[9]   T. Yu, Y. Zhang, and K. Lin, \"Efficient algorithms for \nWeb services selection with end-to-end QoS \nconstraints,\" ACM Transactions on the Web, vol. 1, \n2007, pp. 6-es. \n[10]   A. Bonifati, S. Ceri, and S. Paraboschi, \"Pushing \nreactive services to XML repositories using active \nrules,\" Computer Networks, vol. 39, 2002, pp. 645-660. \n[11]   H. Roitman, A. Gal, and L. Raschid, \"Web Monitoring \n2.0: Crossing Streams to Satisfy Complex Data Needs,\" \n25th International Conference on Data Engineering \n(ICDE '09), 2009. \n[12]   Y.T. Song, L. Sunil, P. Bin, and W. Lafayette, \"Load \nShedding in Stream Databases : A Control-Based \nApproach,\" Framework, pp. 787-798. \n[13]   A.J. Demers, J. Gehrke, M. Hong, M. Riedewald, and \nW.M. White, \"Towards expressive publish\/subscribe \nsystems,\" in EDBT, 2006, pp. 627-644. \n[14]   D.J. Abadi, D. Carney, U.C. Etintemel, M. Cherniack, \nC. Convey, C. Erwin, E.F. Galvez, M. Hatoun, A. \nMaskey, A. Rasin, A. Singer, M. Stonebraker, N. Tatbul, \nY. Xing, R. Yan, and S.B. Zdonik, \"Aurora: A data \nstream management system,\" in SIGMOD Conference, \n2003. \n[15]   E. Wu, Y. Diao, and S. Rizvi, \"High-performance \ncomplex event processing over streams,\" Proceedings of \nthe 2006 ACM SIGMOD international conference on \nManagement of data - SIGMOD '06, 2006, p. 407.  \n \n"}