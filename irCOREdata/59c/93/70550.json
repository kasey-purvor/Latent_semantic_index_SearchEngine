{"doi":"10.1023\/A:1008786811660","coreId":"70550","oai":"oai:eprints.lancs.ac.uk:11664","identifiers":["oai:eprints.lancs.ac.uk:11664","10.1023\/A:1008786811660"],"title":"Experiences of Using Generative Communications to Support Adaptive Mobile Applications","authors":["Friday, Adrian","Davies, Nigel","Seitz, Jochen","Wade, Stephen"],"enrichments":{"references":[{"id":16305941,"title":"A CORBA-based Proxy Architecture for Mobile Multimedia Applications.&quot;","authors":[],"date":null,"doi":null,"raw":"Seitz, J., N. Davies, M. Ebner, and A. Friday. &quot;A CORBA-based Proxy Architecture for Mobile Multimedia Applications.&quot; Proc. 2nd IFIP\/IEEE International Conference on Management of Multimedia Networks and Services (MMNS '98), Versailles, France.","cites":null},{"id":16305943,"title":"A Design for a Fault-Tolerant, Distributed Implementation of Linda&quot;,","authors":[],"date":"1989","doi":"10.1109\/ftcs.1989.105566","raw":"A. Xu and B. Liskov, &quot;A Design for a Fault-Tolerant, Distributed Implementation of Linda&quot;, Proceedings of the 19th International Symposium on Fault-Tolerant Computing, June 1989, pages 199-206.","cites":null},{"id":16305867,"title":"A Reliable Multicast Framework for Light-Weight Sessions and Application Level Framing&quot;,","authors":[],"date":"1995","doi":"10.1145\/217382.217470","raw":"S.  Floyd,  V.  Jacobson,  S.  McCanne,  C.  Liu  and  L.  Zhang,  &quot;A  Reliable  Multicast Framework  for  Light-Weight  Sessions  and  Application  Level  Framing&quot;,  Proceeedings  of  ACM SIGCOMM '95, Cambridge, Massachusetts, U.S., August 1995, ACM Press, pages 342-356.","cites":null},{"id":16305887,"title":"Adaptation and Mobility in Wireless Information Systems.\u201d","authors":[],"date":null,"doi":"10.1109\/98.295355","raw":"Katz,  R.H.  \u201cAdaptation  and  Mobility  in  Wireless  Information  Systems.\u201d  IEEE  Personal Communications Vol. 1 No. 1, pages 6-17.","cites":null},{"id":16305869,"title":"Adapting to Network and Client Variation via On-Demand, Dynamic Distillation.&quot;","authors":[],"date":null,"doi":"10.1145\/248209.237177","raw":"Fox, A., S.D. Gribble, E.A. Brewer, and E. Amir. &quot;Adapting to Network and Client Variation via On-Demand, Dynamic Distillation.&quot; Proc. ASPLOS-VII, Boston, Masachusetts, U.S.","cites":null},{"id":16305862,"title":"An Asynchronous Distributed Systems Platform for Heterogeneous Environments.&quot;","authors":[],"date":null,"doi":"10.1145\/319195.319206","raw":"Davies, N., A. Friday, S. Wade, and G. Blair. &quot;An Asynchronous Distributed Systems Platform for Heterogeneous Environments.&quot; Proc. 8th ACM SIGOPS European Workshop: Support for Composing Distributed Applications, Sintra, Portugal, ACM Press.","cites":null},{"id":16305829,"title":"ANSA: An Engineer's Introduction to the Architecture&quot;, Architecture Projects Management Ltd.,","authors":[],"date":"1989","doi":null,"raw":"Ltd.,  A.P.M.  &quot;ANSA:  An  Engineer's  Introduction  to  the  Architecture&quot;,  Architecture Projects Management Ltd., Cambridge, U.K. November 1989.","cites":null},{"id":16305840,"title":"Bauhaus Linda, Selected Papers from ECOOP '94,","authors":[],"date":"1994","doi":"10.1007\/978-94-011-0187-5_9","raw":"N. Carriero, D. Gelernter and L. Zuck, Bauhaus Linda, Selected Papers from ECOOP '94, Bologna, Italy (July 1994) 66-76.","cites":null},{"id":16305939,"title":"Bonita: A Set of Tuple Space Primitives for Distributed Coordinartion&quot;,","authors":[],"date":"1997","doi":"10.1109\/hicss.1997.667285","raw":"A. I. T. Rowstron and A. M. Wood, &quot;Bonita: A Set of Tuple Space Primitives for Distributed  Coordinartion&quot;,  Proceedings  of  the  30th  Annual  Hawaii  International  Conference  on System Sciences, Volume 1, IEEE CS Press, 1997, pages 379-388, 1997.","cites":null},{"id":16305885,"title":"Building Reliable Mobile-Aware Applications using the Rover Toolkit&quot;,","authors":[],"date":"1996","doi":"10.1145\/236387.236420","raw":"Joseph, A.D., and M.F. Kaashoek. &quot;Building Reliable Mobile-Aware Applications using the Rover Toolkit&quot;, Technical Report M.I.T. Laboratory for Computer Science. 1996.","cites":null},{"id":16305844,"title":"CHORUS\/COOL-ORB Programmer's Guide&quot;,","authors":[],"date":"1996","doi":null,"raw":"Chorus  Syst\u00e8mes,  &quot;CHORUS\/COOL-ORB  Programmer's  Guide&quot;,  Technical  Report CS\/TR-96-2.1, Chorus Syst\u00e8mes, 1996.","cites":null},{"id":16305827,"title":"Efficient TCP over Networks with Wireless Links.&quot;","authors":[],"date":"1995","doi":"10.1109\/hotos.1995.513451","raw":"Amir, E., H. Balakrishnan, S. Seshan, and R. Katz. &quot;Efficient TCP over Networks with Wireless Links.&quot; Proc. 5th IEEE Workshop on Hot Topics in Operating Systems (HotOS-V), Rosario Resort, Orcas Island, Washington, U.S., 4-5 May 1995. IEEE Computer Society Press.","cites":null},{"id":16305872,"title":"Extensions to ANSAware for advanced mobile applications.&quot;","authors":[],"date":null,"doi":"10.1007\/978-0-387-34947-3_4","raw":"Friday, A., G.S. Blair, K.W.J. Cheverst, and N. Davies. &quot;Extensions to ANSAware for advanced  mobile  applications.&quot;  Proc.  International  Conference  on  Distributed  Platforms,  Dresden, Editor: A. Schill, C. Mittasch and O. Spaniol, Chapman and Hall, pages 29-43.","cites":null},{"id":16305945,"title":"Filters: QoS Support Mechanisms for Multipeer Communications\u201d,","authors":[],"date":"1996","doi":"10.1109\/49.536366","raw":"Yeadon,  N.,  F.  Garcia,  D.  Hutchison,  and  D.  Shepherd,  \u201cFilters:  QoS  Support Mechanisms for Multipeer Communications\u201d, Journal on Selected Areas in Communications, JSAC, Vol: 14, No. 7, pages 1245-1262, 1996.","cites":null},{"id":16305874,"title":"Generative Communication in Linda&quot;,","authors":[],"date":"1985","doi":"10.1145\/2363.2433","raw":"D.  Gelernter,  &quot;Generative  Communication  in  Linda&quot;,  ACM  Transactions  on Programming Languages and Systems, Volume 7, Number 1, January 1985, pages 80-112.","cites":null},{"id":16305933,"title":"Integrated Processor Scheduling for Multimedia.&quot;","authors":[],"date":"1995","doi":"10.1007\/bfb0019270","raw":"Nieh,  J.,  and  M.  Lam.  &quot;Integrated  Processor  Scheduling  for  Multimedia.&quot;  Proc.  5th International  Workshop  on  Network  and  Operating  System  Support  for  Digital  Audio  and  Video (NOSSDAV), Durham, New Hampshire, U.S., 19-21 April 1995.","cites":null},{"id":16305947,"title":"Intelligent Communication Filtering for Limited Bandwidth Environments.&quot;","authors":[],"date":"1995","doi":"10.1109\/hotos.1995.513450","raw":"Zenel, B., and D. Duchamp. &quot;Intelligent Communication Filtering for Limited Bandwidth Environments.&quot; Proc. 5th IEEE Workshop on Hot Topics in Operating Systems (HotOS-V), Rosario Resort, Orcas Island, Washington, U.S., 4-5 May 1995. IEEE Computer Society Press.","cites":null},{"id":16305859,"title":"L2imbo: A Distributed Systems Platform for Mobile Computing.&quot;","authors":[],"date":null,"doi":null,"raw":"Davies, N., A. Friday, S. Wade, and G. Blair. &quot;L2imbo: A Distributed Systems Platform for  Mobile  Computing.&quot;  ACM  Mobile  Networks  and  Applications  (MONET),  Special  Issue  on Protocols and Software Paradigms of Mobile Networks Vol. 3 No. 2, pages 143-156.","cites":null},{"id":16305855,"title":"Limbo: A Tuple Space Based Platform for Adaptive Mobile Applications&quot;,","authors":[],"date":"1997","doi":null,"raw":"N. Davies, S. P. Wade, A. Friday and G. S. Blair, &quot;Limbo: A Tuple Space Based Platform for Adaptive Mobile Applications&quot;, Proceedings of the International Conference on Open Distributed Processing\/Distributed Platforms (ICODP\/ICDP '97), Toronto, Canada, 27-30 May 1997, pages 291-302.","cites":null},{"id":16305865,"title":"Linda Implementation Revisited&quot;, Transputer and Occam Developments,","authors":[],"date":"1995","doi":null,"raw":"A. Douglas, A. Wood and A. Rowstron, &quot;Linda Implementation Revisited&quot;, Transputer and Occam Developments, IOS Press, 1995, pages 125-138.","cites":null},{"id":16305832,"title":"M-RPC: A Remote Procedure Call Service for Mobile Clients&quot;,","authors":[],"date":"1995","doi":"10.1145\/215530.215562","raw":"Bakre, A., and B.R. Badrinath. &quot;M-RPC: A Remote Procedure Call Service for Mobile Clients&quot;,  Technical  Report  WINLAB  TR-98,  Department  of  Computer  Science,  Rutgers  University, U.S. June 1995.","cites":null},{"id":16305880,"title":"Melinda: Linda with Multiple Tuple Spaces,","authors":[],"date":"1990","doi":null,"raw":"S.  Hupfer,  Melinda:  Linda  with  Multiple  Tuple  Spaces,  Technical  Report YALEU\/DCS\/RR-766, Department of Computer Science, Yale University, New Haven, Connecticut, U.S. (February 1990).","cites":null},{"id":16305876,"title":"Parallel Programming in Linda&quot;,","authors":[],"date":"1985","doi":null,"raw":"D.  Gelernter,  N.  Carriero,  S.  Chandran  and  S.  Chang,  &quot;Parallel  Programming  in Linda&quot;, Proceedings of the International Conference on Parallel Processing, August 1985, pages 255-263. [Gr\u00f6nvall,96] B. Gr\u00f6nvall, I. Marsh and S. Pink, &quot;A Multicast-Based Distributed File System for the Internet&quot;,  Proceedings  of  the  7th  ACM  SIGOPS  European  Workshop,  Connemara,  Ireland,  2-4 September 1996, ACM Press.","cites":null},{"id":16305837,"title":"Quality of Service Support in a Mobile Environment: An Approach Based on Tuple Spaces&quot;,","authors":[],"date":"1997","doi":"10.1007\/978-0-387-35170-4_3","raw":"G. S. Blair, N. Davies, A. Friday and S. P. Wade, &quot;Quality of Service Support in a Mobile Environment:  An  Approach  Based  on  Tuple  Spaces&quot;,  Proceedings  of  the  5th  IFIP  International Workshop  on  Quality  of  Service  (IWQoS  '97)  -  Building  QoS  into  Distributed  Systems,  Columbia University, New York, U.S., 21-23 May 1997, pages 37-48.","cites":null},{"id":16305882,"title":"Rover: A Toolkit for Mobile Information Access.&quot;","authors":[],"date":"1995","doi":"10.1145\/224057.224069","raw":"Joseph, A., A. deLespinasse, J. Tauber, D. Gifford, and M.F. Kaashoek. &quot;Rover: A Toolkit for Mobile Information Access.&quot; Proc. 15th ACM Symposium on Operating System Principles (SOSP), Copper Mountain Resort, Colorado, U.S., 3-6 December 1995. ACM Press, Vol. 29, pages 156-171.","cites":null},{"id":16305842,"title":"Services to Support Consistency in Mobile Collaborative Applications.&quot;","authors":[],"date":"1996","doi":"10.1109\/sdne.1996.502444","raw":"Cheverst, K., N. Davies, A. Friday, and G.S. Blair. &quot;Services to Support Consistency in Mobile  Collaborative  Applications.&quot;  Proc.  3rd  International  Workshop  on  Services  in  Distributed Networked Environments (SDNE), Macau, China, 3-4 June 1996. IEEE Computer Society Press, pages 27-34.","cites":null},{"id":16305931,"title":"Shared Tuple Memories, Shared Memories, Buses and LAN's - Linda Implementations across the Spectrum of Connectivity,","authors":[],"date":"1989","doi":null,"raw":"J. S. Leichter, Shared Tuple Memories, Shared Memories, Buses and LAN's - Linda Implementations across the Spectrum of Connectivity, Ph.D. Thesis, Department of Computer Science, Yale University, New Haven, Connecticut, U.S. (July 1989).","cites":null},{"id":16305937,"title":"Solving the Linda multiple rd problem.&quot;","authors":[],"date":null,"doi":"10.1007\/3-540-61052-9_56","raw":"Rowstron,  A.,  and  A.  Wood.  &quot;Solving  the  Linda  multiple  rd  problem.&quot;  Proc. Coordination Languages and Models (Coordination '96).","cites":null},{"id":16305878,"title":"Sun's JavaSpaces is foundation for future distributed systems.&quot; SunWorld","authors":[],"date":"1997","doi":null,"raw":"&quot;Sun's JavaSpaces is foundation for future distributed systems.&quot; SunWorld August 1997.","cites":null},{"id":16305849,"title":"Supporting Adaptive Services in a Heterogeneous Mobile Environment.&quot;","authors":[],"date":"1994","doi":"10.1109\/mcsa.1994.513475","raw":"Davies, N., G. Blair, K. Cheverst, and A. Friday. &quot;Supporting Adaptive Services in a Heterogeneous  Mobile  Environment.&quot;  Proc.  Workshop  on  Mobile  Computing  Systems  and Applications  (MCSA),  Santa  Cruz,  CA,  U.S.,  December  1994.  Editor:  Luis-Felipe  Cabrera  and Mahadev Satyanarayanan, IEEE Computer Society Press, pages 153-157.","cites":null},{"id":16305852,"title":"Supporting Collaborative Applications in a Heterogeneous Mobile Environment.&quot;","authors":[],"date":null,"doi":"10.1016\/0140-3664(96)01069-9","raw":"Davies, N., G.S. Blair, K. Cheverst, and A. Friday. &quot;Supporting Collaborative Applications in  a  Heterogeneous  Mobile  Environment.&quot;  Special  Issue  of  Computer  Communications  on  Mobile Computing, Vol. 19, pages 346-358.","cites":null},{"id":16305846,"title":"Supporting the Real-Time Requirements of Continuous Media","authors":[],"date":null,"doi":"10.1016\/0169-7552(94)00034-q","raw":"Coulson, G., G.S. Blair, F. Horn, L. Hazard, and J.B. Stefani. &quot;Supporting the Real-Time Requirements  of  Continuous  Media  in  Open  Distributed  Processing.&quot;  To  Appear  in  Computer Networks and ISDN Systems.","cites":null},{"id":16305946,"title":"Supporting Video in Heterogeneous Environments.&quot;","authors":[],"date":null,"doi":"10.1145\/330560.330853","raw":"Yeadon, N., N. Davies, A. Friday, and G.S. Blair. &quot;Supporting Video in Heterogeneous Environments.&quot; Proc. Symposium on Applied Computing, Atlanta, U.S.","cites":null},{"id":16305889,"title":"The Case for Wireless Overlay Networks.&quot;","authors":[],"date":"1996","doi":"10.1117\/12.235901","raw":"Katz, R., and E. Brewer. &quot;The Case for Wireless Overlay Networks.&quot; Proc. SPIE Multimedia and Networking Conference (MMNC), San Jose, California, U.S., 29-30 January 1996.","cites":null},{"id":16305935,"title":"The Design and Implementation of a Distributed Linda Tuple Space.","authors":[],"date":"1991","doi":null,"raw":"Pinakis, J. (1991) The Design and Implementation of a Distributed Linda Tuple Space. Proceedings  of  the  2nd  Department  of  Computer  Science  Research  Conference,  Department  of Computer Science, University of Western Australia, Nedlands, WA 6009.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"1999-01","abstract":"Attention has recently begun to focus on the use of asynchronous paradigms to support adaptive mobile applications. To investigate this issue the authors have developed an asynchronous distributed systems platform based on the tuple space paradigm [Gelernter,85b] coupled with extensions to support operation in mobile environments. This paper presents our experiences of developing and using this platform. The benefits of the tuple space approach are highlighted and we discuss in some detail the design, implementation and performance of our platform. We subsequently focus on the critical issues of the tuple space API and the level of support for adaptation which can be provided without compromising the elegance and simplicity of the paradigm. The paper concludes with an analysis of the suitability of platforms based on the tuple space paradigm for use in mobile environments","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/70550.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/11664\/1\/MPG%2D99%2D21_Dist_Pll_DB_S.I..pdf","pdfHashValue":"22960767573a7c6a747ad8fddad85e25ce80e799","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:11664<\/identifier><datestamp>\n      2018-01-24T00:04:21Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Experiences of Using Generative Communications to Support Adaptive Mobile Applications<\/dc:title><dc:creator>\n        Friday, Adrian<\/dc:creator><dc:creator>\n        Davies, Nigel<\/dc:creator><dc:creator>\n        Seitz, Jochen<\/dc:creator><dc:creator>\n        Wade, Stephen<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        Attention has recently begun to focus on the use of asynchronous paradigms to support adaptive mobile applications. To investigate this issue the authors have developed an asynchronous distributed systems platform based on the tuple space paradigm [Gelernter,85b] coupled with extensions to support operation in mobile environments. This paper presents our experiences of developing and using this platform. The benefits of the tuple space approach are highlighted and we discuss in some detail the design, implementation and performance of our platform. We subsequently focus on the critical issues of the tuple space API and the level of support for adaptation which can be provided without compromising the elegance and simplicity of the paradigm. The paper concludes with an analysis of the suitability of platforms based on the tuple space paradigm for use in mobile environments.<\/dc:description><dc:date>\n        1999-01<\/dc:date><dc:type>\n        Journal Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:relation>\n        http:\/\/dx.doi.org\/10.1023\/A:1008786811660<\/dc:relation><dc:identifier>\n        Friday, Adrian and Davies, Nigel and Seitz, Jochen and Wade, Stephen (1999) Experiences of Using Generative Communications to Support Adaptive Mobile Applications. Distributed and Parallel Databases, 7 (3). pp. 319-342. ISSN 0926-8782<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/11664\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1023\/A:1008786811660","http:\/\/eprints.lancs.ac.uk\/11664\/"],"year":1999,"topics":["QA75 Electronic computers. Computer science"],"subject":["Journal Article","PeerReviewed"],"fullText":"Experiences of Using Generative Communications To \nSupport Adaptive Mobile Applications  \nAdrian Friday, Nigel Davies, Jochen Seitz, Matt Storey and Stephen P. Wade \n \nDistributed Multimedia Research Group, \nComputing Department, \nLancaster University, \nBailrigg, \nLancaster, UK. \n \ntelephone: +44 (0)1524 594337 \ne-mail: adrian@comp.lancs.ac.uk \n \n \nABSTRACT \nAttention has recently begun to focus on the use of asynchronous \nparadigms to support adaptive mobile applications. To investigate this issue \nthe authors have developed an asynchronous distributed systems platform \nbased on the tuple space paradigm [Gelernter,85b] coupled with extensions \nto support operation in mobile environments. This paper presents our \nexperiences of developing and using this platform. The benefits of the tuple \nspace approach are highlighted and we discuss in some detail the design, \nimplementation and performance of our platform. We subsequently focus \non the critical issues of the tuple space API and the level of support for \nadaptation which can be provided without compromising the elegance and \nsimplicity of the paradigm. The paper concludes with an analysis of the \nsuitability of platforms based on the tuple space paradigm for use in mobile \nenvironments.  \n1. Introduction \nMobile computing environments are characterised by change [Davies,95]. More \nspecifically, in an environment in which users and end-systems are highly mobile the \nresources available to application and system components are subject to rapid and significant \nfluctuations. For example, an end-system which roams between different network overlays \n[Katz,96] may experience changes in network quality-of-service (QoS) which reduce the \neffective bandwidth by several orders of magnitude. Furthermore, these changes in resource \navailability may be mirrored by changes in service availability and, most crucially, user \nrequirements as the context within which the user and end-system operates changes. In order \nto enable systems to continue to operate in such dynamic environments it is now widely \naccepted that system and application components must be adaptive [Davies,94], [Katz,94], \ni.e. they must be able to adapt their behaviour in response to changes in their context. \nInitial approaches to supporting adaptation have focused on one of two techniques: either \nextending existing distributed systems platforms to enable applications to obtain feedback on \nnetwork QoS or using proxies to perform adaptation on behalf of applications. The first \napproach typically involves implementing new APIs which can be used to selectively remove \naspects of network transparency and thus expose QoS information. Such extensions are often \ncombined with further refinements such as message buffering which allow applications to \ncontinue operation during periods of network disconnection. This approach is typified by the \nwork of Joseph et al. on the Rover system [Joseph,96]. In contrast, approaches based on \nproxy architectures [Zenel,95], [Yeadon,96], [Fox,96], [Seitz,98] allow the instantiation of \nfiltering, caching or translation components into the communications path between clients and \nservers. Component instantiation is typically carried out either as part of the overall system \nconfiguration (usually explicitly by the user or a system administrator) or may be triggered \ntransparently in response to pre-determined or pre-configured QoS events. \nMore recently, attention has begun to focus on the use of asynchronous paradigms to \nsupport adaptive mobile applications. At Lancaster we have developed an asynchronous \ndistributed systems platform based on the tuple space paradigm [Gelernter,85b] but extended \nto support operation in mobile environments. The platform has been fully implemented and \nused to support a wide range of applications, both mobile and fixed. In this paper we report \non our experiences of developing and using the platform. In particular, we focus on the \ncritical issues of the tuple space API and the level of support for adaptation which can be \nprovided without compromising the elegance and simplicity of the paradigm. \nSection 2 presents an analysis of the theoretical benefits and shortcomings of the tuple \nspace paradigm when applied to the field of mobile computing. Section 3 then describes in \ndetail the computational and engineering models for our platform. We then consider the API \nof our platform and discuss support for adaptation in tuple space based architectures (sections \n4 and 5 respectively). Finally, we analyse our experiences and comment on the suitability of \nplatforms based on the tuple space paradigm for use in mobile environments.  \n \n2. An Analysis of the Tuple Space Approach \n2.1. Overview \nThe tuple space paradigm was conceived in the mid-1980's by researchers at Yale \nUniversity as a mechanism for coordinating the numerous processes involved in complex \nparallel computations [Gelernter,85a]. A tuple space is an abstract entity, akin to distributed \nshared memory, spread across all participant processes and\/or hosts. Inter-process \ncommunications are conducted exclusively through the generation of tuples and anti-tuples \nwhich are submitted to tuple space. This is termed generative communication. \nTuples are typed data structures, each formed from a collection of typed data fields, and \nevery tuple represents a cohesive piece of data. Tuples are comparable to structures (structs) \nin the C programming language, or objects in languages like C++ and Java. Each tuple field is \ntermed either actual or formal. Actual parameters have both a defined type and value while \nformal parameters have a defined type but no value, c.f. NULL pointers in C. Tuples of this \nform are classed as passive tuples and are composed entirely of actual and\/or formal fields \nfrom the time of their creation though to that of their destruction. A second class of tuples, \nreferred to as active tuples, is also defined by the tuple space model. In an active tuple, one \nfield or more is of neither an actual or formal nature at the time of creation. Instead, such \nfields are wholly defined by functions which require evaluation. When an active tuple is \ndeposited in tuple space, a separate process is spawned to calculate each such field and, over \ntime, the tuple evolves into a passive tuple. \nBoth active and passive tuples are persistent objects and cannot be altered by user \nprocesses while they reside in a tuple space. In order to effect changes to a tuple it must be \nexplicitly withdrawn, changed and then re-inserted [Gelernter,85b]. Placing a tuple in a tuple \nspace is analogous to transmitting a packet in an IP network and the packet remaining there \nuntil the recipient interface chooses to consume it. \nAnti-tuples are the antithesis of tuples. While tuples embody a piece of data which has \nbeen submitted to a tuple space, anti-tuples capture requests seeking to remove or copy data \nfrom the tuple space. In common with passive tuples, anti-tuples are composed from an \narbitrary mix of actual and formal fields but instead of defining a piece of data, an anti-tuple \ncontains a template against which to match tuple data. There are two flavours of anti-tuple: \ndestructive and non-destructive. Destructive anti-tuples each seek to remove a matching tuple \nfrom the tuple space. In contrast, non-destructive anti-tuples merely are satisfied by making a \ncopy of a matching tuple, thus leaving the original tuple unaffected. \nTuples are matched against anti-tuples, and vice-versa, by comparing their types, fields, \nand the values contained in such. Actuals match either formals of the same type, or actuals of \nthe same type and value. Formals only match actuals of the same type. When all the fields of \na tuple satisfy an anti-tuple a successful match is made and the formals present in the anti-\ntuple are replaced by the respective actuals in the matched tuple. \nThe process of matching of tuples to anti-tuple is performed non-deterministically and, as \nsuch, where multiple tuples that satisfy an anti-tuple are available, an arbitrary choice is \nmade. Similarly, if multiple destructive anti-tuples are in existence that match a newly \ndeposited tuple, one of these if chosen at random and satisfied. The tuple space model \nguarantees the unique withdrawal of tuples, so each tuple can satisfy at most one destructive \nanti-tuple. Each tuple may, though, rightfully service an infinite number of non-destructive \nanti-tuples prior to its departure from tuple space. \nIn itself, the tuple space paradigm is an abstract concept, so the researchers at Yale \nembodied the paradigm in a coordination language named Linda [Gelernter,85a]. Linda was \ndesigned with the goal of offering the same combination of simplicity and power to \ndistributed domains that C had offered systems programmers in the sequential one. As such \nthe language was defined with just four simple primitives: \n\u2022 eval: deposits a active tuple in a tuple space \n\u2022 in: seeks to withdraw information matching a query from a tuple space by submitting a \ndestructive anti-tuple \n\u2022 out: deposits a passive tuple in a tuple space \n\u2022 rd: seeks to copy information matching a query from a tuple space by submitting a \nnon-destructive anti-tuple \n2.2. Specific Benefits \nBecause tuples remain in tuple space from the time of insertion to that of their destructive \nconsumption, those processes producing and consuming tuples need not co-exist. This \nproperty is known as temporal decoupling. Indeed, once they have been deposited in tuple \nspace, tuples can be consumed by a client at any time, even after the demise of the server(s) \nwhich generated them. Therefore, clients and servers can interact using a tuple space without \nneeding to be synchronised with each other. This also means that instead of merely generating \ntuples in response to queries, producers can create tuples when the data they are to contain \nbecomes available. For example, a weather station which produces hourly reports may deposit \na new report tuple into tuple space once each hour, thus obviating the need to repeatedly issue \nthe same information to clients. \nTuple space communications are, by default, anonymous, meaning that the client and \nserver are normally unaware of each others identity\u2020. As a result of this, coupled with the \nabove temporal decoupling property, there is no implicit requirement to form bindings \nbetween client and server processes. Indeed, in those instances where the producer and \nconsumer of tuples do not co-exist, it would not be possible to do so. Thus, the tuple space \nmodel has a second important property, that of spatial decoupling. Producers simply deposit \ntuples into tuple space knowing that zero or more processes may access them over time. \nBecause there is no binding, any suitable process can service a tuple which satisfies a request. \nTherefore, any reachable server that is capable of dealing with the request can destructively \nwithdraw the associated tuple, perform the service and generate result tuples as appropriate. \n                                                \n\u2020 It is possible to produce tuples for an identified consumer by encapsulating destination information in \ntuples. This is termed directed communications. Several schemes to achieve this have been proposed \nincluding an approach based on Amoeba ports [Pinakis,92]. \nThe spatial decoupling property also enables tuple spaces to provide transparent support \nfor group interactions. A tuple produced by one process can be read by multiple clients in \nparallel if they all access it using non-destructive anti-tuples. Consider, for example, a \ngroupware application like the shared whiteboard wb [Floyd,95]. The whiteboard process \ncould output tuples describing each drawing operation which are read and rendered by the \nother whiteboard processes. Through the persistent nature of the tuple space, clients \n(whiteboards) could join and leave the tuple space at will, with automatic state reconciliation. \nThis greatly contrasts with existing groupware that is often based on RPC based paradigms \nwhich require additional, sophisticated group management protocols [Cheverst,96]. \n2.3. Significant Shortcomings \n2.3.1. Application Programmers Interface \nWhile the temporal decoupling of the tuple space model supports asynchronous \ncommunications between processes, Rowstron noticed that the operators which clients use to \nretrieve data from the tuple space are actually of a synchronous nature [Rowstron,97]. \nSpecifically, while out asynchronously deposits data in the tuple space, the in and rd \noperators used to retrieve such are blocking and, thus, implicitly synchronous. This means \nthat wherever a tuple matching a despatched anti-tuple is unavailable, the client becomes \nblocked. In a large number of distributed applications, this behaviour is undesirable. \nFurthermore, the problem would be further exacerbated in mobile environments where \nnetwork partitions and disconnection would mean matching tuples remaining unknown, and \nhence unavailable, for particularly lengthy times. \nAn additional, well known problem with the tuple space paradigm is often referred to as \nthe 'multiple-rd problem' [Rowstron,96]. In essence, since rd requests are matched non-\ndeterministically it is not possible for an application to be sure that it has read in all the tuples \nwhich match a given anti-tuple. If these semantics are required, the application must in each \ntuple in turn (removing it from the tuple space) and then out the tuples once no more \nmatches are found. While this provides a mechanism for achieving the desired results it \nplaces a significant burden on both the application programmer, who must write the \nappropriate code fragments, and the system which must support many, usually costly, in \noperations.  \n2.3.2. Supporting Adaptation \nMobile computing applications are subject to rapid and significant changes in the QoS \navailable from their supporting environment. Previous research has shown that mobile \ncomputing platforms should provide a QoS management architecture that facilitates \nadaptation, either through application level adaptation or the installation of proxies \n[Friday,96], [Seitz,98]. However, these approaches have typically focused on \ncommunications related QoS, which has, logically, been measured and controlled using \nbindings. Since the tuple space model does not expressly employ bindings, these existing QoS \nmanagement architectures cannot be readily integrated into the model in order to support its \nuse in mobile arenas. \n3. L2imbo \n3.1. Objectives \nGiven the potential benefits of the tuple space paradigm a number of researchers have \nattempted to build tuple space platforms based on Linda which target distributed processing \nover general purpose local-area workstation clusters [Leichter,89], [Xu,89], [Hupfer,90], \n[Pinakis,91], [Carriero,94]. These platforms have generally been designed with a very \nspecific application focus and are not considered general purpose tools for building \ndistributed applications. In our work however, we have concentrated on building a general \npurpose distributed systems platform (called L2imbo), built on the tuple space concept. Unlike \nexisting distributed tuple space platforms, L2imbo has been designed to address typical \ndistributed systems issues and function in heterogeneous hardware and software \nenvironments. Along with classic distributed systems issues such as portability and support \nfor heterogeneous environments, L2imbo has been designed to offer a lightweight, minimal \nset of services (communication, network and architecture transparency) whilst also addressing \nissues highlighted by existing distributed tuple space implementations, namely, performance \nand scalability. \nOne of the key objectives in the design of the L2imbo platform was to utilise the implicit \ntime and space decoupling of the tuple space platform to facilitate network transparency. We \nbelieve traditional platforms suffer in mobile environments because application components \nmust interact via directed synchronous communication. In a typical mobile (and thus \ncurrently failure prone) environment a mobile distributed systems platform has two new \nissues to address: firstly, in the event of failure the communication must be recovered \n(witnessed by approaches such as Rover's Q-RPC [Joseph,95]). Secondly, in heterogeneous \nnetworks consisting of wired and wireless components, platforms are required to adopt \nmechanisms to cope with the characteristics of each type of network on the communication \npath (e.g. M-RPC [Bakre,95] or Snoop-TCP [Amir,95]). However, we believe that with a \ntuple space based platform in which communications are undirected (mediated by the tuple \nspace itself) it should be possible to deal with the network characteristics on a hop-by-hop \nbasis. Moreover, since the integrity of the tuple space is the sole concern of the platform, one \nor more networks may be utilised (even simultaneously) without any implications to the \nplatform services offered to the applications. This feature of the L2imbo platform is currently \nunique among distributed systems platforms. \nIn the following sub-sections we examine the computational and engineering models \noffered by the L2imbo platform in more detail. In particular, we focus on the protocol \narchitecture and techniques which allow the platform to achieve performance comparable to \nconventional distributed systems platforms. \n3.2. Computational Model \nOur distributed systems platform provides the same basic API and features as the original \nLinda model [Gelernter,85a] but has been developed to include a number of key extensions: \n(i) Extensions to the API to support asynchronous operations \n We have extended the L2imbo API using operations based on the Bonita primitives \nproposed in [Rowstron,97]. These enable clients on each host to access tuple spaces \nasynchronously by replacing the in and rd operations by two separate operations: one to \ninitiate the operation and one to collect the results at some later time. A further operator \nallows clients to poll their tuple space interface asking whether the results for a previous \nrequest are available. Asynchronous access to the tuple space can both simplify application \ncode and structure (requiring less multi-threading to avoid blocking operations) and may yield \nimproved performance. \n(ii) Multiple local, distributed and centralised tuple spaces which may be specialised for \napplication level requirements such as consistency or security \n The original Linda model allowed only a single shared tuple space (abstracting over a \nshared area of memory). To address issues of performance, partitioning and scalability, \nL2imbo allows the creation of multiple tuple spaces. A tuple space may be one of three basic \nclasses; local (private to that host), distributed (cached at one or more hosts) and centralised \n(maintained on a single host but accessible from elsewhere). In addition, tuple spaces may be \nlinked using bridging agents which copy tuples between tuple spaces based on factors such as \ntuple types and QoS parameters [Blair,97]. \n(iii) System agents which provide services such as tuple space creation, tuple type \nmanagement, propagating tuples between tuple spaces and QoS monitoring. \n All system operations are provided by system agents which the clients interact with \nusing the standard tuple space API. A special set of system tuples are used to interaction with \nthe platform agents. \nMore details of our computation model can be found in [Blair,97], [Davies,97] and \n[Davies,98a]. \n3.3. Engineering Model \nThe L2imbo platform has been split into two parts: a small stub library, which is compiled \ninto each executable and a daemon process. The stub library maps the actual API calls to the \napplication's host language (currently bindings for C, C++ and Java exist). The current \nversion of the daemon process (version 1.3) is written solely in C and has been ported to run \non SunOS 4.1.4 (MULTICAST 4.1.4), Solaris 2.5, Linux 2.0.30 and Windows NT 4.0.  \n3.3.1. The L2imbo Daemon Process \nThe L2imbo daemon process is built using a modular architecture loosely grouped into \nfour layers (see figure 1). The uppermost layer interfaces to the API stub library and is \nresponsible for all communications between the L2imbo daemon and client processes running \nco-located on the same host. As access to all tuple spaces is via the daemon process, tuples \nand anti-tuples generated by separate applications on the same host can be matched without \ngenerating network traffic. In addition, the platform is able to gauge the demands on the \navailable network (or networks) of tuple space based applications. This information enables \nthe platform to manage congestion and load balancing more effectively, but incurs a \nperformance penalty since each message involves the overhead of additional local inter-\nprocess communications and a context switch. \nInterface to API\nDistributed Tuple Space\n(DTS) Protocol\nNetwork Scheduler\nEthernet\/WaveLAN\/GSM\nInterface Modules\nAgents\nType \nManagement \nAgent\nTuple Space\nCreation Agent Network\nAbstraction\nLayer\n \nFigure 1: Structure of the L2imbo daemon process \nBelow the API interface layer are the tuple space management protocols. In the current \nimplementation only two protocols have been implemented, the distributed tuple space \nmodule and the local tuple space module. The distributed tuple space module is responsible \nfor managing a 'conceptually centralised' tuple space between a collection of collaborating \nplatform nodes. We shall consider the distributed tuple space protocol in more detail in \nsection 3.3.2. The local tuple space module is optimised for access by local applications only \nand is typically used both for local application inter-process communication and for passing \nQoS information between the layers of the platform and local applications (see section 5). \nThe two lower layers of the platform are regarded as a network abstraction layer which \ncollectively offer a set of transport services. The transport services remain largely \nindependent of both tuple spaces and network technology. The network scheduler accepts \nprotocol messages from the tuple space protocols and, based on associated priority and \ndeadline QoS parameters, determines the order in which they are transmitted. Within each \npriority, messages are scheduled in earliest deadline first (EDF) order. Messages with the \nhighest priority (lowest number) are considered most urgent and scheduled before those of \nsuccessive priorities (even if a lower priority has an earlier deadline). This concept is based \non previous work by Nieh on thread scheduling for continuous media applications [Nieh,95]. \nThe lowest layer of the platform consists of a set of packet driver modules for each \nsupported type of network. Each driver module presents a generic interface to the platform \nbehind which details such as connection management and signalling are hidden (although \ndetailed feedback is available via the local tuple space). Packets ready for transmission are \ndelivered to an appropriate network interface module by the network scheduler. \n3.3.2. The Distributed Tuple space Protocol \nThe distributed tuple space protocol module of the platform has been designed \nspecifically to address the issues of scalability and availability of our tuple spaces. In \nparticular, we wanted to avoid solutions which introduced points of failure (poor for networks \nwith mobile elements) or consistency mechanisms based on acknowledgements or token \npassing (which would degrade performance unacceptably through artefacts such as \nacknowledgement implosion or the protracted latency of contacting all of the group \nmembers). \nIn implementing the protocol we have chosen to taken advantage of the recent \ndeployment of IP multicast together with application level framing concepts borrowed from \nwork on Scalable Reliable Multicast (SRM) which underpins wb [Floyd,95] and Jetfile \n[Gr\u00f6nvall,96]. \nThe DTS protocol consists of nine distinct protocol messages which are used in \nconjunction with a cache of tuples (OUT) and anti-tuples (IN) held on each host. Collectively, \nthese caches represent the state of the tuple space. The messages are used to ensure timely \npropagation of tuples and anti-tuples between caches. An overview of the operation of the \nprotocol is given in table 1 and the interested reader can find more details in [Davies,98a]. \nIn order to retain the semantics of the tuple space, it is essential that tuples are never \nduplicated: once a tuple is injected into the tuple space it must remain unique and must only \nbe withdrawn once by a single process. In existing distributed tuple space approaches this \nproperty is maintained by assigning or hashing certain tuples to particular network nodes \n[Douglas,95]. This approach would be undesirable in our network environment. Therefore, to \nensure the uniqueness property in our platform without penalising system performance, we \nhave introduced the concept of 'tuple ownership'. A tuple can only be removed from the tuple \nspace by its designated owner. The initial owner of a tuple is normally the host which creates \nit, although the ownership can be reassigned using a message exchange (see CHOWN_REQ \nand CHOWN_ACK in table 1) with the current owner of the tuple. By observing sequences \nof interactions, the platform can determine if a tuple is probalistically likely to be consumed \nby the originator of the last tuple and can choose to nominate that host as the owner of new \ntuples it generates. Owner nomination allows RPC-like semantics to be modelled with greater \nefficiency. Note that since rd operations copy tuples non-destructively, they need not be \nconcerned with tuple ownership and hence can be satisfied more quickly and efficiently as \nthey require less communication. In particular, groupware applications in which the same \ntuple is obtained using rd by a number of hosts are supported highly efficiently. \nAs with the SRM protocol, our platform relies on a 'local repair' mechanism for ensuring \nthat eventual consistency of the tuple space is achieved and maintained. Each protocol \nmodule maintains a cache of tuples which have been snooped from the multicast group \napplying to a particular tuple space. Each tuple has a host-unique sequence number which can \nbe used to detect missing tuples. When a tuple is unaccounted for, a repair message \n(REPAIR_REQ) is issued to request the retransmission of missing tuples and thus move \ncloser to eventual global consistency. The structure of the network and the repair transmission \nbackoff strategy implies that the 'nearest' platform who has the tuple cached will respond \n(with a REPAIR_ACK) first. If a host snoops an identical REPAIR_ACK message from \nanother host, it avoids transmitting a response itself thus preventing acknowledgement \nimplosion. \nTo speed up detection of missing tuples we use the ACCESS and DELETE messages \nwhen tuples are rd'd or in'd respectively. These messages can be considered of \ncomparatively low priority since they are used primarily to allow other hosts to detect missing \ntuples or prevent the use of stale tuples in rd requests. The earlier these messages are \ntransmitted, the faster the independent views of a tuple space converge. However, as their \ndelay does not alter the semantics of the tuple space, we can batch ACCESS's and DELETE's \nwith other protocol traffic to reduce overall communication overhead. \nThe protocol messages, their format and usage are more comprehensively explained in \nthe following table (first published in [Davies,98b]). \nMessage Format and Actions \nOUT [tuple_id, owner_id, type, tuple] \nIf we already have information about this tuple ensure that the ownership \ndetails are up-to-date. Otherwise add the tuple to our queue, satisfy any \nmatching RD requests made on the local host (transmitting an ACCESS \nmessage for each one), then look for a matching IN request. If we find one, \ncheck whether we are the current owner, transmitting a DELETE or \nCHOWN_REQ as appropriate. \nIN [client_id, request_id, type, spec] \nShould we have a matching tuple, multicast an appropriate OUT message, \notherwise add the IN request to our queue. \nRD [type, spec] \nCheck if we have a matching tuple and if so multicast an OUT message. \nCHOWN_REQ [tuple_id, client_id] \nFirst, check to see if we know about this tuple. If we don't, transmit a \nREPAIR_REQ. Should we know the tuple has been deleted, multicast a \nDELETE. If we own the tuple, we can transmit a CHOWN_ACK nominating \nthe originator of the CHOWN_REQ as the new owner, otherwise we send a \nCHOWN_ACK stating who we understand to be the current owner. \nCHOWN_ACK [tuple_id, owner_id] \nIf we know about this tuple update its ownership. If we are the new owner \nand have a pending local IN which matches, service the request and \nmulticast a DELETE message. \nDELETE [tuple_id, request_id] \nMark the unique tuple id as having been deleted and ensure both the tuple \nand the IN request it satisfied are removed from our cache. \nACCESS [tuple_id] \nIf we don't know about this tuple, transmit a REPAIR_REQ, otherwise if we \nknow it to have been deleted, multicast a DELETE message. \nREPAIR_REQ [tuple_id] \nIf we have this tuple multicast a REPAIR_ACK \nREPAIR_ACK [tuple_id, owner_id, type, tuple] \nQueue any unknown tuples. \nTable 1: Distributed Tuple Space (DTS) protocol messages \nThe protocol has been designed with a degree of duplication to allow the protocol to \nrecover from missed messages. For instance, when an application performs an in operation, \nthe message corresponding to the operation will get propagated only if it cannot be satisfied \nfrom cached data. Therefore, in the case where the tuple data has been missed, the operation \ndoes not have to block until it is repaired. The redundancy in the protocol together with the \nlocal repair consistency mechanism allows hosts to connect and disconnect from tuple spaces \nat will and will ensure that consistency is eventually achieved. However, when a host \n'reconnects' to a tuple space it can generate a flurry of repair messages. In the case of a low-\nbandwidth mobile network, this repair traffic is undesirable, particularly when the mobile \nhost's client applications are only interested in particular subset of the available tuples. For \nthis reason we have developed a simple proxy architecture which operates a split-level \ncaching algorithm, allowing effectively redundant traffic to be filtered over low-bandwidth \nlinks (see section 5). \n3.4. Status \nThe current version of the platform consists of approximately 4,000 lines of C for the \ndaemon process and 500 lines for the API stubs. Bindings exist for the API in C, C++ and \nJava. We have used the platform to build a number of applications including a collaborative \ngeographical information system (GIS), a group coordination service for a low bit rate video \nsurveillance tool and a collaborative virtual environment.  \n3.4.1. Applications \nCollaborative GIS  \nThe collaborative GIS application allows a group of users to share spatial information \nusing a shared whiteboard metaphor (see figure 2). A common map can be displayed, over \nwhich highlighting operations, such as placing text or drawing one of a variety of simple \nshapes, may be performed. \n \nFigure 2 - The Collaborative GIS Tool \nAny operation performed on one whiteboard is mirrored in all others. Each drawing \noperation is translated into a unique tuple which is propagated to a shared tuple space (the \nuniversal tuple space). Clients utilise the platform to discover new drawing operations \n(tuples). The distributed systems platform allows simple applications such as the GIS to share \ngroup state without complex group management or floor control protocols. Since tuples are \npersistent, all group state remains in the universal tuple space. This allows late entry into any \nGIS based collaboration and, furthermore, enables participants in the group activity to leave \nand later rejoin the collaboration at any point. \nVideo Application \nBased on the requirements of the Emergency Services [Yeadon,98] we have developed a \nrapidly deployable camera server demonstrator (see figure 3). This application allows users to \nquickly set-up ad-hoc surveliiance systems and view the resulting video streams on mobile \ndevices. \nEach surveillance unit is capable of capturing frames of digital video, compressing them \nusing a low-bitrate H.263 CODEC and transmitting them over a wireless local area network \n(in this case WaveLAN). A backchannel from the client allows the user to control the \nencoding process at the video source: the client may adjust the frame size and various camera \nparameters including contrast, brightness and so on. \n  \nFigure 3: The rapidly deployable camera server demonstrator \nAs new camera services become available a tuple is output describing the camera, it's \nfield of view and position together with a communications end-point. The application \nremoves the tuple from the tuple space and establishes a connection to build a low-resolution \nthumbnail view. The user of the application may choose to enhance the view if the output \nfrom the camera is of particular interest. The tuple space allows the demonstrator to be highly \nflexible, we can deploy both cameras and the application at any point of our network and the \ndemonstrator will dynamically reconfigure itself. \nVirtual Collaborative Environments \nRecent years have witnessed the use of spatial metaphhors for presenting multimedia \ninformation. This has been recognised in the Inhabited Information Spaces schema of the I3 \ninitiative. The eSCAPE project is seeking to develop more inclusive virtual environments that \nencompass and involve the citizen. More specifically, eSCAPE is developing two thematic \nplaces that act as contrasting alternative instantiations of electronic landscapes. \nIn the first of these places, the electronic realisation of where points meet in virtual space \nwill be instantiated as a Virtual Cityscape. The Cityscape provides a concrete and familiar \nmetaphor as a means of visualising the interconnection between shared virtual environments. \nThe second thematic representation will represent the interconnection of virtual places as a \nVirtual Planetarium where shared virtual environments and the connections between them can \nbe represented in more abstract forms. \nThe L2imbo platform is being used as a communications substrate to provide distributed \nsharing of components of these virtual worlds. These components, which are built using a \ntoolkit consisting of Java Beans, communicate by building tuple representations of \nthemselves which are then distributed using L2imbo. Tuples are thereby used to represent \nboth the real world data objects being modelled and their geometric virtual counterparts.  \n3.4.2. Performance \nTo evaluate the relative performance of L2imbo with respect to existing distributed \nsystems platforms, we have compared it against both the ANSAware distributed systems \nplatform (version 4.1) [A.P.M.,89] and raw BSD sockets. Our test suite consisted of three \nseparate pairs of client and server processes which carry out 1,000 timed RPC interactions \nconsisting of an n byte payload and null response. The test configuration was a pair of \nSparcStation 1 workstations networked with a moderately loaded 10Mbps Ethernet. \nAn RPC is modelled in the tuple space by the exchange of two tuples with types request \nand response respectively. It is important to note that a directed communication of this kind is \nnot well suited to the tuple space paradigm, as it represents two tightly couple tuple insertions \nand removals. However, we believe that it is important to demonstrate that the worst case \nperformance of our platform is still within acceptable bounds.  \nTo isolate the additional overhead of splitting the L2imbo platform into separate processes \n(daemon and client libraries), we have run tests for both an optimised form (in which the \ndaemon and API processes are linked into a single executable) and unoptimised (separate \nprocesses) forms of the client and server. The results are summarised in table 2. \nPayload \n(bytes) \nSockets \n(UDP) \nANSAware \n4.1 (REX) \nL2imbo \nDTS \n(linked) \nL2imbo DTS \n(separate \nprocesses) \n256 2.98 7.10 6.53 12.58 \n512 3.45 10.48 7.20 13.47 \n1024 3.93 11.17 8.64 15.10 \n2048 5.85 13.14 11.97 20.28 \n4096 9.46 21.14 18.06 28.26 \n8192 15.83 34.83 29.93 44.82 \nTable 2: Comparison of relative performance on SunOS  \nThe figures show that in optimised trim, L2imbo outperforms ANSAware RPC in all \ncases. However, the overhead of the context switch and local communication required in the \nstandard L2imbo configuration does have a significant impact on the figures. Being able to \nminimise the overheads associated with exchanging messages between the application stubs \nand the daemon process is clearly an important factor in further improving the performance of \nL2imbo. \nWe also compared our results with published figures for the Chorus Syst\u00e8mes COOL \nORB [Chorus,96] on the Linux platform. The figures suggest that the performance of L2imbo \nis comparable to conventional RPC based distributed systems platforms in RPC-like tests. \nMore specifically, the COOL benchmark report quotes 3.8 ms for a basic request exchange of \n1000 bytes in each direction. On a similar specification Linux platform, the linked version of \nL2imbo takes 4.4 ms to perform this same test (averaged over 1000 interactions). \nFurthermore, for interactions of 100 bytes in each direction, COOL is quoted as taking 2.6 \nms, whereas the optimised form of L2imbo takes just 1.9 ms. Note that we have not attempted \nto verify the published figures for COOL. \nIn considering these figures it is important to note that the test case demonstrates directed \ncommunication. In the conventional distributed systems platform the timing information is \ntaken after an initial process of binding and thus represents the best possible case for these \nplatforms. In the case of L2imbo however, the test case represents a worst case scenario; the \ntuples are being rapidly inserted and removed from the tuple space and the overhead \nassociated with matching is not strictly necessary since only two well known processes are \ncommunicating. \n4. Application Programmer Interface Issues \nOne of the most appealing features of the tuple space model is the simple yet expressive \nAPI. As discussed in section 3.1, we have implemented this fundamental set of operations \n(in, out, rd and eval) in the L2imbo platform. \nWhile it is true to say that one can construct any arbitrary application using the basic \nLinda API, we believe that performance and usability (particularly in distributed platforms) \ncan be improved through the use of some additional, carefully chosen, operations. \n4.1. Enumeration \nConsider the case where an application was required to count the number of tuples \nmatching a certain criteria. Ideally, such an application would simply access each tuple in \nturn, without removing each of them from the tuple space, using the rd operation. Using the \nstandard API calls however, the application could not guarantee that each successive rd call \nwould not return the same tuple over and over again, since both in and rd operations match \ntuples non-deterministically (this scenario is, as briefly discussed in section 2.3.1., known as \nthe multiple-rd problem). The application would therefore have to remove each of the \nmatching tuples using the in operation one at a time and, only when all of the relevant \ntuples were removed, would have to insert them back into the tuple space again. However, \nthere is a further problem. As the application can not know how many tuples are going to \nmatch its criteria, it cannot know how many tuples to read in and must take some measure to \nensure it doesn't block indefinitely. In short, using the standard API the application or \napplications generating the tuples would have to be restructured. \nTo address these problems, we have implemented four further operators: inp and rdp \n[Leichter,89], collect and copy-collect [Rowstron,97]. The first two of these are non-\nblocking versions of in and rd which evaluate to boolean values indicating their success. \nThis allows application programmers to avoid having to determine for themselves when a \nblocking in or rd operation is not going to return. \nThe collect and copy-collect operations are designed to optimise situations where \ntuple enumeration is required. Collect yields all the tuples matching a particular anti-tuple, \ncopying each of them to a particular destination tuple space. Collect returns the number of \ntuples it copied to the API allowing the application to enumerate through the results more \neasily. The copy-collect operator behaves identically to collect except it does not remove the \nmatching tuples. The two operations are analogous to in and rd respectively. \n4.2. Asynchronous Operation \nWe have implemented a superset of Rowstron\u2019s Bonita primitives [Rowstron,97]). These \nenhancements enable tuple space clients to access tuple spaces asynchronously by dispatching \nrequests using one primitive and later collecting the results using another. A further operator \nallows clients to poll the platform to determine whether the results for a previous request are \navailable. \nThe Bonita primitives have two primary uses. Firstly, the primitives allow applications to \nbe structured with less internal parallelism, since multiple operations can be executed \nsimultaneously from a single thread of execution. The second reason is one of performance \nenhancement; the asynchronous primitives are analogous to splitting the standard \nsynchronous in and rd operations into two phases; a request and yielding the results. In the \nsituation where an application needs only to determine if a certain matching tuple exists and \ndoes not need the specific actuals from the matching tuple, then it is more efficient to use the \nasynchronous operation as the results do not need to be passed to the application and \nunmarshalled into application variables. \nNote that while Rowstron proposes an overloaded dispatch primitive to issue \nasynchronous in, out and rd requests, we instead use separate out, async_in and \nasync_rd for enhanced code clarity. \n4.3 Eventing Services \nOne of the more interesting applications of the L2imbo platform has been in supporting \ncollaborative working in distributed virtual worlds under the auspices of the eSCAPE project. \nIn the eSCAPE architecture, multimedia information such as documents and video clips can \nbe exchanged using the tuple space. Furthermore, the platform is also used at a fundamental \nlevel to facilitate sharing of the actual geometric information that comprises the virtual world \nitself. \nThis work has highlighted several issues concerning using the tuple space as a medium \nfor supporting the sharing of timely information. Due to the non-deterministic matching of \ntuples with anti-tuples, it is difficult for applications to efficiently determine when new tuples \nof a certain type arrive. For example, if an application is producing a tuple describing the \ncoordinates of a moving object in a virtual world, then other collaborating applications need \nto be able to identify the most recent set of coordinates. In existing tuple space platforms this \nfunctionality could only be achieved by layering timing or sequencing information in the \ntuples themselves, then enumerating through all the available tuples to find the most recent. \nIn L2imbo we have chosen to solve this problem by adding simple eventing properties to \nthe platform. The register operation allows applications to receive notification callbacks when \nnew tuples matching a particular anti-tuple is observed in the tuple space. The register \noperation is functionally equivalent to a temporally extended rd operation (which can not \nyield the same tuple more than once). Register is functionality akin to the notify operation \nof Sun's JavaSpaces platform [Guth,97]. \n4.4. Analysis \nThe L2imbo platform API has evolved as it has been used to support more diverse \napplication domains. The full platform API (as of version 1.3) is shown in table 3 below. \nPrimitive Syntax and description \nuse ts = use(handle) \nEnsures the local tuple space daemon is operating a local cache for the \nspecified unique tuple space handle and returns a local identifier for this \ntuple space. \ndiscard discard(ts) \nUsed by clients to inform the local daemon that they no longer require \naccess to the specified tuple space. \nout out(ts,type,<ACTUAL variable|UNDECLARED>,...) \nThe standard Linda out primitive. \nasync_in rqid = async_in(ts,type,<ACTUAL variable|FORMAL \nvalue>,...) \nA non-blocking operation used to withdraw a matching tuple from tuple \nspace. async_in dispatches a request to the L2imbo platform and \nreturns a request identifier to the client. A matching reply can later be \nretrieved by the client using obtain (described below) with this \nidentifier.  \nasync_rd rqid = async_rd(ts,type,<ACTUAL variable|FORMAL \nvalue>,...) \nAs async_in, expect that matching tuples are not withdrawn from tuple \nspace. \narrived boolean = arrived(rqid) \nA non-blocking primitive which returns a boolean indicating whether a \ntuple satisfying request rqid is available from the client stub. \nobtain obtain(rqid) \nBlocks the client until a tuple satisfying request rqid is received by the \nclient stub. When a result is available, obtain populates any formal \nvariables passed in the anti-tuple of the async_in or async_rd \noperation which created rqid with the appropriate values from the \nmatched tuple. \ncancel cancel(rqid) \nUsed by clients to cancel their need for a response to a previous \nasync_in or async_rd request. \nin in(ts,type,<ACTUAL variable|FORMAL value>,...) \nThe standard Linda in primitive. \nrd rd(ts,type,<ACTUAL variable|FORMAL value>,...) \nThe standard Linda rd primitive. \ncollect collect(srcid,dstid,type,<ACTUAL variable|FORMAL \nvalue>,...) \nCollect all tuples in the source tuple space which match the specified \nanti-tuple and move them to the destination tuple space. \ncopy_collec\nt \ncopy_collect(srcid,dstid,type,<ACTUAL variable|FORMAL \nvalue>,...) \nFind all tuples in the source tuple space which match the specified anti-\ntuple and make a copy of them in the destination tuple space. \nregister register(ts, ARRIVAL|DELETION, type, callback) \nRegister for notification of the arrival\/deletion of a particular tuple type. \nPrimitive Syntax and description \nderegister deregister(tsId) \nDeregister for event notification. \nTable 3: The platform API \nExperience has shown that the most demanding application of the tuple space has been to \nsupport peer-to-peer collaborative activity. This application domain is far removed from the \nGelernter's original tuple space work. However, it is important to note that we have changed \nonly the API and not the paradigm to support these new domains. \nWhat the platform has gained in functionality however, it has lost in simplicity and \nelegance. We are therefore currently aiming to distil the concepts from the current API into a \nmore elegant set of operations. We have identified the following issues that we will need to \naddress with any new API : \n1. The API must be expressive enough to allow applications to enumerate through those \ntuples that match a given anti-tuple efficiently. Moreover, most applications require \nmore flexible matching than the simple equality tests supported by the current API. \n2. An application must be able to find out whether a particular tuple is currently \ncontained in the tuple space simply and quickly, without requiring complex \napplication semantic changes. \n3. Some applications would be easier to engineer if more complex data types were \nallowed within tuple fields (e.g. lists, sets and so on). New data types imply new \nmatching criteria, such as maximise, minimise and contained within relations. Such \nrelations are not possible in any existing tuple space API and do not obviously fit in \nmost programming languages. \n4. Lastly, the tuples in current tuple space paradigms are persistent and will remain until \nexplicitly removed. Some applications seem to require new classes of tuples which \nare 'transient', i.e. contain information which is valid only for a particular period of \ntime. The inclusion of such tuples require an adjustment to the tuple space paradigm \nand have an impact in both engineering and API terms. \nBased on our experiences of developing and using tuple space based platforms, we \nbelieve the above issues represent serious concerns for researchers considering using this \nparadigm. More specifically, before a tuple space platform can become widely applicable, \nsolutions will need to be found to these problems. \n5. Adaptation \nThe concept of adaptation is central to a modern distributed systems platform. In \nparticular, platforms which wish to support either multimedia data or mobile operation must \nbe able to adapt their behaviour in response to changes in their environment. Adaptation can \nbe divided into a number of distinct facets, i.e. QoS and context monitoring, reporting and \nadaptation. It is important to stress at this point that we are not concerned with adaptation \nsolely in response to changes in communications QoS but rather as a consequence of changes \nin a wide range of environmental factors including communications QoS and cost, physical \nlocation, power and device availability and user preferences. \nApplications\nPlatform\nProtocols\nDevices\nLocation\nService\nUser \nPrefs\n \nFigure 4 : A Local QoS Tuple Space \nOur basic approach is to use a local tuple space to support QoS reporting (see figure 4). \nMore specifically, we allow multiple, self-contained, QoS monitoring agents to deposit \ninformation into a local tuple space. This information takes the form of tuples of arbitrary \ntypes. Applications and system components which are interested in receiving this QoS \ninformation are able to carry out a rd operation on the local tuple space, thus non-\ndestructively obtaining a copy of the information. \nThere are a number of significant advantages to this approach over conventional event \nbased QoS architectures as typified by [Coulson,94]. Firstly, the local tuple space acts as an \neffective bi-directional 'layer-breaker'. This enables applications to both monitor and control \nunderlying system components without requiring existing APIs to be modified. Secondly, by \nusing a tuple space we are able to achieve temporal de-coupling between the producers and \nconsumers of QoS information. This enables, for example, QoS monitors to run as periodic \nprocesses which deposit information into the QoS tuple space for consumption by \napplications some arbitrary time in the future. Examples of such monitors include position \nsensors which sample a local GPS compass and report on the user's physical position and \ncommunications monitors which are able to report on the state of the end-system's network \ninterfaces. Finally, since QoS information is placed in the QoS tuple space as tuples they may \nbe propagated (possibly using bridging agents) to other applications and end-systems. This \nenables nodes to determine the QoS of other nodes without requiring explicit application level \nsupport. \nHowever, despite the cited advantages of our approach the tuple space paradigm presents \na number of unique challenges with respect to the support of adaptation. These challenges are \ndiscussed in detail in the following sections. \n5.1. Communications QoS Monitoring \nConventional QoS monitoring techniques rely on the establishment of end-to-end \ncommunications paths. Traffic patterns on these paths can then be measured and reported to \napplications and users to enable adaptation. For example, the MOST platform used a \nmodified version of the REX RPC package to monitor round-trip times between application \nlevel objects. These times were mapped onto estimations of latency and bandwidth and \nreported back to the applications involved in the communications. Using this technique \nprogrammers could construct applications which automatically adjusted their demands on the \nunderlying communications infrastructure in line with changes in resource availability. \nSimilar approaches have been used in a range of mobile platforms including [Joseph,95]. \nHowever, in a tuple space platform the concept of an end-to-end communications path is \nlost with the removal of the concept of directed communications and bindings. As a \nconsequence, the production of communications related QoS figures becomes problematic. \nFurthermore, the production of such figures looses much of its significance since in many \ncases the eventual consumer of a tuple is not known in advance. Hence, it is not possible to \nprovide predictions of, for example, the time taken to deliver a tuple to its destination (not \nleast because the destination will depend on the existence of matching tuple requests on \ndifferent nodes). Indeed, if we consider a scenario in which an end-system is disconnected \nthen tuples issued by an application may be matched by a local service in which case \npropagation will be nearly instantaneous or, may not be propagated until connectivity is \nrestored. \nIn spite of the difficulties outlined above it is possible to provide an indication of \nconnectivity on a per-node basis. In L2imbo this can be achieved using QoS monitoring \nagents which observe events at various points in the system including the: rate of injection of \ntuples into a given tuple space, rate of access to tuples in tuple space (through in or rd \noperations), the cost of the current channel and the level of connectivity (in terms of the raw \ncapabilities of the network interface). The results of the QoS monitoring can be placed in the \nlocal QoS tuple space and, if required, propagated to other nodes (see previous section). This \ninformation can be used to, for example, start up local proxies to service application requests \nor to adapt application behaviour.  \nFinally, we observe that if end-to-end QoS is important this can be engineered using tuple \nspaces with restricted memberships and additional QoS features such as admission control \nand traffic monitoring. An architecture for such a system is described in [Blair,97]. However, \nsuch an approach negates many of the benefits of using tuple spaces including temporal de-\ncoupling and undirected communications.  \n5.2. Adaptation \nGiven the problems in monitoring QoS in a tuple space based systems adaptation is often \ncarried out on, or by, individual end-systems in response to changes in the availability of local \nnetwork interfaces. More specifically, when an end-system is experiencing poor network \nconnectivity it may take steps to optimise its use of available network resources. The simplest \nform of adaptation is for the end-system to instantiate local proxy services to deal with \napplication requests. Such services are able to interact with applications without the need for \nadditional support since communications is, in any case, undirected.  \nA more complex form of adaptation involving the use of proxies is, however, possible. \nProxies are the subject of intense research in the mobile computing community [Zenel,95], \n[Yeadon,96], [Fox,96], [Seitz,98]. In such systems a proxy is usually defined as an entity \ninserted into a communication stream somewhere between the client and server (see figure 5). \nThis proxy can then modify the communication streams (either from client to server or vice \nversa) in order to adapt this technique to the current QoS characteristics. This adaptation can \nbe done using one or more of the following basic proxy actions: \n\u0000 Filtering: A filtering proxy can reduce the amount of data to be transmitted by \nfiltering out less relevant data making it loss-prone. An example could be the \nomission of colour information from a video stream. \n\u0000 Transforming: A transforming proxy can change the data type of the stream it \nprocesses to either reduce the data volume or to adapt the data format to be easily \npresentable on the client. For example, the proxy could transform a given PostScript \ndocument into a plain ASCII file, preserving the textual contents but omitting \nformatting information and graphics. \n\u0000 Caching: Finally, a caching proxy can be used to add asynchronicity to a \ncommunication stream decoupling it from bad transmission characteristics. Several \ncaching strategies can be implemented by a proxy: An on-demand caching proxy \ncould be used to minimise the amount of data to transmit over a link with bad QoS, \nwhile a pre-fetching proxy could utilise the link if the current QoS is good. \naccess node\n(Proxy)\nmobile computer\n(Client)\nlow bandwidth\nhigh latency\nhigh bandwidth\nlow latency\ncomputer in\nwired network\n(Server)\nwireless network\n(e.g., radio)\nwired network\n(e.g., Internet)  \nFigure 5: The concept of a proxy \nThe above functions can, of course, be easily combined to allow, for example, filtering \nand transforming proxies. Since proxies rely on being inserted into the communications path \nbetween client and server it may appear at first glance that they have little relevance for tuple \nspace platforms. However, if we view end-systems as having a point of connection to a tuple \nspace this forms a natural point for installing proxies. In the L2imbo architecture we support \nthis idea using a number of additional system services: \n(i) Tunnel agents. Tunnel agents are used to connect to a tuple space on an end-\nsystem's behalf and to propagate (a subset of) tuples and tuple requests to the \nend-system. For example, if an end-system was accessing a tuple space via a \nGSM link a tunnel agent could be used to receive the tuples on the fixed network \nand to forward them to the mobile host. Note that tunnels are distinct from the \nbridging agents described in section 3 since they are intra rather than inter tuple \nspace. Tunnel agents can be configured to only forward tuples of a specific type \nor which match a certain anti-tuple. This should be viewed as a delay in the \ntransmission of certain classes of tuples rather than a discard operation since the \ntuples will remain available in the tuple space. \n(ii) Filter Agents. Filter agents rd tuples from the tuple space and place new versions \nof the tuples back into the tuple space. For example, a generic compression filter \nagent may read in all tuples as they arrive, compress the payload and output the \ncompressed version as a new tuple.  \nSuch an architecture has a number of key advantages over a conventional proxy \narchitecture. Firstly, it maintains a clean separation between the selective transmission of \ntraffic, i.e. deciding which tuples to propagate, and the conversion of traffic (tuples). This \nseparation is important because it enables the two concerns to be addressed independently. \nMore specifically, it would be perfectly possible to set up a tunnel agent to delay tuples of a \nspecific type and to use a third party filter agent to convert tuples from this type into a more \nacceptable format which can be transmitted straight away. Secondly, the results of a tuple \nconversion are, conceptually at least, propagated to other members of the tuple space. As a \nresult, a single filter agent can carry out conversions which are of use to many tunnel agents. \nFinally, since tuples persist it is possible for clients who are connected to a tuple space to \nreceive converted tuples while connected to the tuple space by a low-speed link and to then \nretrieve the original versions of the tuples when they re-connect using a high-speed link. \nDespite many promising aspects the above architecture requires significant further work \nbefore we can claim to have addressed the issues of proxies in tuple space based platforms.  \n6. Concluding Remarks \nAt first glance the tuple space paradigm appears to offer solutions to many of the \nproblems inherent in mobile computing. In particular, the temporal de-coupling allows \napplications to survive periods of disconnection and the use of anonymous, undirected \ncommunications allows transparent rebinding to proxy services. Furthermore, the apparent \nease with which group applications may be supported makes the paradigm appear attractive \nfor use in collaborative applications running on both fixed and wireless networks. Motivated \nby these perceived benefits the authors have developed a comprehensive tuple space based \nplatform called L2imbo. The platform offers a comprehensive selection of features including \nmultiple tuple spaces, tuple typing and asynchronous operations. These features are further \nextended by the addition of a range of system services which provide facilities for tuple \nmanagement and QoS monitoring and control. Our platform has been ported to SunOS, \nSolaris, Linux, Windows 95 and Windows NT and supports C, C++ and Java APIs. It has \nbeen used to support a number of applications including collaborative editors and virtual \nenvironments.  \nThe development of this platform and its subsequent use to support a range of mobile \napplications has provided us with a valuable insight into the practical problems of using the \ntuple space paradigm to support mobile applications. \nThese problems can be divided into two distinct areas, the API and system support for \nadaptation. With respect to the API the problems focus on the suitability of the basic tuple \nspace API for constructing general distributed applications. In our experience, programmers \nhave substantial difficulties developing applications which use only the basic Linda API. \nMore significantly, the addition of new features such as asynchronous operators and solutions \nto the multiple-rd problem only partially address these problems. In particular, we believe \ndevelopers of collaborative applications require generalised event support and all application \ndevelopers require significantly extended tuple data types and matching capabilities. \nHowever, adding such features to a platform such as L2imbo effectively transforms the \nplatform into a distributed database with support for events.  \nSupporting adaptation in a tuple space based platform also causes serious problems. Most \nsignificantly, the lack of an explicit representation of the end-to-end communications path \n(i.e. a binding) makes it difficult to monitor and adapt to fluctuations in QoS. This represents \na fundamental dichotomy for developers of tuple space platforms. The absence of bindings \nbrings significant advantages in terms of transparent service rebinding etc. but makes it \nimpossible to develop adaptive applications. As a consequence we believe that tuple spaces \nrepresent only part of the solution: for many applications and communications scenarios \nexplicit bindings with QoS will be required.  \nDespite the comments we have made above, there are a number of positive features of the \ntuple space paradigm. In particular, the use of a tuple space as a means of disseminating QoS \ninformation appears extremely promising. More specifically, the undirected communications \nand temporal de-coupling appear ideally suited to the propagation of information between \napplications and system components on the local host (the ability to propagate this \ninformation using bridging agents and a distributed tuple space, while initially attractive, \nrequires significant further research since the lack of propagation guarantees inherent in tuple \nspace platforms may impinge on the general usefulness of such an approach). As a \nconsequence we are currently investigating the use of tuple spaces as a component within a \nmore generalised distributed systems framework. More specifically, we are considering the \naddition of tuple spaces to CORBA like platforms. We anticipate, in the first instance, that \nlocal tuple spaces will be used for QoS propagation. The integration of distributed tuple \nspaces into such an architecture raises significant new research issues in terms of the use of \nmultiple communications paradigms within a single application framework.  \nAcknowledgements \nThis work was carried out under the auspices of the EPSRC funded Reactive Services \nproject.  \n \n6. References \n[Amir,95] Amir, E., H. Balakrishnan, S. Seshan, and R. Katz. \"Efficient TCP over Networks with \nWireless Links.\" Proc. 5th IEEE Workshop on Hot Topics in Operating Systems (HotOS-V), Rosario \nResort, Orcas Island, Washington, U.S., 4-5 May 1995. IEEE Computer Society Press. \n[A.P.M.,89] Ltd., A.P.M. \"ANSA: An Engineer's Introduction to the Architecture\", Architecture \nProjects Management Ltd., Cambridge, U.K. November 1989. \n[Bakre,95] Bakre, A., and B.R. Badrinath. \"M-RPC: A Remote Procedure Call Service for Mobile \nClients\", Technical Report WINLAB TR-98, Department of Computer Science, Rutgers University, \nU.S. June 1995. \n[Blair,97] G. S. Blair, N. Davies, A. Friday and S. P. Wade, \"Quality of Service Support in a Mobile \nEnvironment: An Approach Based on Tuple Spaces\", Proceedings of the 5th IFIP International \nWorkshop on Quality of Service (IWQoS '97) - Building QoS into Distributed Systems, Columbia \nUniversity, New York, U.S., 21-23 May 1997, pages 37-48. \n[Carriero,94] N. Carriero, D. Gelernter and L. Zuck, Bauhaus Linda, Selected Papers from ECOOP \n'94, Bologna, Italy (July 1994) 66-76. \n[Cheverst,96] Cheverst, K., N. Davies, A. Friday, and G.S. Blair. \"Services to Support Consistency in \nMobile Collaborative Applications.\" Proc. 3rd International Workshop on Services in Distributed \nNetworked Environments (SDNE), Macau, China, 3-4 June 1996. IEEE Computer Society Press, pages \n27-34. \n[Chorus,96] Chorus Syst\u00e8mes, \"CHORUS\/COOL-ORB Programmer's Guide\", Technical Report \nCS\/TR-96-2.1, Chorus Syst\u00e8mes, 1996. \n[Coulson,94] Coulson, G., G.S. Blair, F. Horn, L. Hazard, and J.B. Stefani. \"Supporting the Real-Time \nRequirements of Continuous Media in Open Distributed Processing.\" To Appear in Computer \nNetworks and ISDN Systems. \n[Davies,94] Davies, N., G. Blair, K. Cheverst, and A. Friday. \"Supporting Adaptive Services in a \nHeterogeneous Mobile Environment.\" Proc. Workshop on Mobile Computing Systems and \nApplications (MCSA), Santa Cruz, CA, U.S., December 1994. Editor: Luis-Felipe Cabrera and \nMahadev Satyanarayanan, IEEE Computer Society Press, pages 153-157. \n[Davies,95] Davies, N., G.S. Blair, K. Cheverst, and A. Friday. \"Supporting Collaborative Applications \nin a Heterogeneous Mobile Environment.\" Special Issue of Computer Communications on Mobile \nComputing, Vol. 19, pages 346-358. \n[Davies,97] N. Davies, S. P. Wade, A. Friday and G. S. Blair, \"Limbo: A Tuple Space Based Platform \nfor Adaptive Mobile Applications\", Proceedings of the International Conference on Open Distributed \nProcessing\/Distributed Platforms (ICODP\/ICDP '97), Toronto, Canada, 27-30 May 1997, pages 291-\n302. \n[Davies,98a] Davies, N., A. Friday, S. Wade, and G. Blair. \"L2imbo: A Distributed Systems Platform \nfor Mobile Computing.\" ACM Mobile Networks and Applications (MONET), Special Issue on \nProtocols and Software Paradigms of Mobile Networks Vol. 3 No. 2, pages 143-156.  \n[Davies,98b] Davies, N., A. Friday, S. Wade, and G. Blair. \"An Asynchronous Distributed Systems \nPlatform for Heterogeneous Environments.\" Proc. 8th ACM SIGOPS European Workshop: Support for \nComposing Distributed Applications, Sintra, Portugal, ACM Press. \n[Douglas,95] A. Douglas, A. Wood and A. Rowstron, \"Linda Implementation Revisited\", Transputer \nand Occam Developments, IOS Press, 1995, pages 125-138. \n[Floyd,95] S. Floyd, V. Jacobson, S. McCanne, C. Liu and L. Zhang, \"A Reliable Multicast \nFramework for Light-Weight Sessions and Application Level Framing\", Proceeedings of ACM \nSIGCOMM '95, Cambridge, Massachusetts, U.S., August 1995, ACM Press, pages 342-356.  \n[Fox,96] Fox, A., S.D. Gribble, E.A. Brewer, and E. Amir. \"Adapting to Network and Client Variation \nvia On-Demand, Dynamic Distillation.\" Proc. ASPLOS-VII, Boston, Masachusetts, U.S. \n[Friday,96] Friday, A., G.S. Blair, K.W.J. Cheverst, and N. Davies. \"Extensions to ANSAware for \nadvanced mobile applications.\" Proc. International Conference on Distributed Platforms, Dresden, \nEditor: A. Schill, C. Mittasch and O. Spaniol, Chapman and Hall, pages 29-43. \n[Gelernter,85a] D. Gelernter, \"Generative Communication in Linda\", ACM Transactions on \nProgramming Languages and Systems, Volume 7, Number 1, January 1985, pages 80-112. \n[Gelernter,85b] D. Gelernter, N. Carriero, S. Chandran and S. Chang, \"Parallel Programming in \nLinda\", Proceedings of the International Conference on Parallel Processing, August 1985, pages 255-\n263. \n[Gr\u00f6nvall,96] B. Gr\u00f6nvall, I. Marsh and S. Pink, \"A Multicast-Based Distributed File System for the \nInternet\", Proceedings of the 7th ACM SIGOPS European Workshop, Connemara, Ireland, 2-4 \nSeptember 1996, ACM Press. \n[Guth,97] \"Sun's JavaSpaces is foundation for future distributed systems.\" SunWorld August 1997. \n[Hupfer,90] S. Hupfer, Melinda: Linda with Multiple Tuple Spaces, Technical Report \nYALEU\/DCS\/RR-766, Department of Computer Science, Yale University, New Haven, Connecticut, \nU.S. (February 1990). \n[Joseph,95] Joseph, A., A. deLespinasse, J. Tauber, D. Gifford, and M.F. Kaashoek. \"Rover: A Toolkit \nfor Mobile Information Access.\" Proc. 15th ACM Symposium on Operating System Principles (SOSP), \nCopper Mountain Resort, Colorado, U.S., 3-6 December 1995. ACM Press, Vol. 29, pages 156-171. \n[Joseph,96] Joseph, A.D., and M.F. Kaashoek. \"Building Reliable Mobile-Aware Applications using \nthe Rover Toolkit\", Technical Report M.I.T. Laboratory for Computer Science. 1996. \n[Katz,94] Katz, R.H. \u201cAdaptation and Mobility in Wireless Information Systems.\u201d IEEE Personal \nCommunications Vol. 1 No. 1, pages 6-17. \n[Katz,96] Katz, R., and E. Brewer. \"The Case for Wireless Overlay Networks.\" Proc. SPIE Multimedia \nand Networking Conference (MMNC), San Jose, California, U.S., 29-30 January 1996.  \n[Leichter,89] J. S. Leichter, Shared Tuple Memories, Shared Memories, Buses and LAN's - Linda \nImplementations across the Spectrum of Connectivity, Ph.D. Thesis, Department of Computer Science, \nYale University, New Haven, Connecticut, U.S. (July 1989). \n[Nieh,95] Nieh, J., and M. Lam. \"Integrated Processor Scheduling for Multimedia.\" Proc. 5th \nInternational Workshop on Network and Operating System Support for Digital Audio and Video \n(NOSSDAV), Durham, New Hampshire, U.S., 19-21 April 1995.  \n[Pinakis,91] Pinakis, J. (1991) The Design and Implementation of a Distributed Linda Tuple Space. \nProceedings of the 2nd Department of Computer Science Research Conference, Department of \nComputer Science, University of Western Australia, Nedlands, WA 6009. \n[Rowstron,96] Rowstron, A., and A. Wood. \"Solving the Linda multiple rd problem.\" Proc. \nCoordination Languages and Models (Coordination '96). \n[Rowstron,97] A. I. T. Rowstron and A. M. Wood, \"Bonita: A Set of Tuple Space Primitives for \nDistributed Coordinartion\", Proceedings of the 30th Annual Hawaii International Conference on \nSystem Sciences, Volume 1, IEEE CS Press, 1997, pages 379-388, 1997. \n[Seitz,98] Seitz, J., N. Davies, M. Ebner, and A. Friday. \"A CORBA-based Proxy Architecture for \nMobile Multimedia Applications.\" Proc. 2nd IFIP\/IEEE International Conference on Management of \nMultimedia Networks and Services (MMNS '98), Versailles, France. \n[Xu,89] A. Xu and B. Liskov, \"A Design for a Fault-Tolerant, Distributed Implementation of Linda\", \nProceedings of the 19th International Symposium on Fault-Tolerant Computing, June 1989, pages 199-\n206. \n[Yeadon,96] Yeadon, N., F. Garcia, D. Hutchison, and D. Shepherd, \u201cFilters: QoS Support \nMechanisms for Multipeer Communications\u201d, Journal on Selected Areas in Communications, JSAC, \nVol: 14, No. 7, pages 1245-1262, 1996. \n[Yeadon,98] Yeadon, N., N. Davies, A. Friday, and G.S. Blair. \"Supporting Video in Heterogeneous \nEnvironments.\" Proc. Symposium on Applied Computing, Atlanta, U.S. \n[Zenel,95] Zenel, B., and D. Duchamp. \"Intelligent Communication Filtering for Limited Bandwidth \nEnvironments.\" Proc. 5th IEEE Workshop on Hot Topics in Operating Systems (HotOS-V), Rosario \nResort, Orcas Island, Washington, U.S., 4-5 May 1995. IEEE Computer Society Press. \n"}