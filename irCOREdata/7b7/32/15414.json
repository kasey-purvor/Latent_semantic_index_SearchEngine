{"doi":"10.1007\/s00224-009-9200-z","coreId":"15414","oai":"oai:dro.dur.ac.uk.OAI2:7420","identifiers":["oai:dro.dur.ac.uk.OAI2:7420","10.1007\/s00224-009-9200-z"],"title":"Comparing universal covers in polynomial time.","authors":["Fiala, J.","Paulusma, Daniel"],"enrichments":{"references":[{"id":934057,"title":"Local and global properties in networks of processors.","authors":[],"date":"1980","doi":null,"raw":null,"cites":null},{"id":934056,"title":"On the complexity and combinatorics of covering finite complexes.","authors":[],"date":"1991","doi":null,"raw":null,"cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2010-05-01","abstract":"The universal cover T G of a connected graph G is the unique (possibly infinite) tree covering G, i.e., that allows a locally bijective homomorphism from T G to G. It is well-known that if a graph G covers a graph H, then their universal covers are isomorphic, and that the latter can be tested in polynomial time by checking if G and H share the same degree refinement matrix. We extend this result to locally injective and locally surjective homomorphisms by following a very different approach. Using linear programming techniques we design two polynomial time algorithms that check if there exists a locally injective or a locally surjective homomorphism, respectively, from a universal cover T G to a universal cover T H (both given by their degree matrices). This way we obtain two heuristics for testing the corresponding locally constrained graph homomorphisms. Our algorithm can also be used for testing (subgraph) isomorphism between universal covers, and for checking if there exists a locally injective or locally surjective homomorphism (role assignment) from a given tree to an arbitrary graph H","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/15414.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/7420\/1\/7420.pdf","pdfHashValue":"7108e0a124354d0696b53f063d453ca007a00aa7","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:7420<\/identifier><datestamp>\n      2013-04-03T12:19:44Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Comparing universal covers in polynomial time.<\/dc:title><dc:creator>\n        Fiala, J.<\/dc:creator><dc:creator>\n        Paulusma, Daniel<\/dc:creator><dc:description>\n        The universal cover T G of a connected graph G is the unique (possibly infinite) tree covering G, i.e., that allows a locally bijective homomorphism from T G to G. It is well-known that if a graph G covers a graph H, then their universal covers are isomorphic, and that the latter can be tested in polynomial time by checking if G and H share the same degree refinement matrix. We extend this result to locally injective and locally surjective homomorphisms by following a very different approach. Using linear programming techniques we design two polynomial time algorithms that check if there exists a locally injective or a locally surjective homomorphism, respectively, from a universal cover T G to a universal cover T H (both given by their degree matrices). This way we obtain two heuristics for testing the corresponding locally constrained graph homomorphisms. Our algorithm can also be used for testing (subgraph) isomorphism between universal covers, and for checking if there exists a locally injective or locally surjective homomorphism (role assignment) from a given tree to an arbitrary graph H. <\/dc:description><dc:subject>\n        Graph homomorphism<\/dc:subject><dc:subject>\n         Universal cover<\/dc:subject><dc:subject>\n         Computational complexity<\/dc:subject><dc:subject>\n         Degree matrix.<\/dc:subject><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Theory of computing systems, 2010, Vol.46(4), pp.620-635 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2010-05-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:7420<\/dc:identifier><dc:identifier>\n        issn:1432-4350<\/dc:identifier><dc:identifier>\n        issn: 1433-0490<\/dc:identifier><dc:identifier>\n        doi:10.1007\/s00224-009-9200-z<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/7420\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/s00224-009-9200-z<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/7420\/1\/7420.pdf<\/dc:identifier><dc:rights>\n        The original publication is available at www.springerlink.com\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn: 1433-0490","issn:1432-4350","1432-4350"," 1433-0490"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2010,"topics":["Graph homomorphism","Universal cover","Computational complexity","Degree matrix."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n07 October 2010\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nFiala, J. and Paulusma, D. (2010) \u2019Comparing universal covers in polynomial time.\u2019, Theory of computing\nsystems., 46 (4). pp. 620-635.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/s00224-009-9200-z\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nComparing universal covers in polynomial time\nJi\u02c7r\u00b4\u0131 Fiala1 and Danie\u00a8l Paulusma2\n1 Charles University, Faculty of Mathematics and Physics,\nDIMATIA and Institute for Theoretical Computer Science (ITI) ? ? ?,\nMalostranske\u00b4 na\u00b4m. 2\/25, 118 00, Prague, Czech Republic.\nfiala@kam.mff.cuni.cz\n2 Department of Computer Science, Durham University \u2020,\nScience Laboratories, South Road,\nDurham DH1 3EY, England.\ndaniel.paulusma@durham.ac.uk\nAbstract. The universal cover TG of a connected graph G is the unique\n(possible infinite) tree covering G, i.e., that allows a locally bijective ho-\nmomorphism from TG to G. Universal covers have major applications\nin the area of distributed computing. It is well-known that if a graph G\ncovers a graph H then their universal covers are isomorphic, and that the\nlatter can be tested in polynomial time by checking if G and H share the\nsame degree refinement matrix. We extend this result to locally injective\nand locally surjective homomorphisms by following a very different ap-\nproach. Using linear programming techniques we design two polynomial\ntime algorithms that check if there exists a locally injective or a locally\nsurjective homomorphism, respectively, from a universal cover TG to a\nuniversal cover TH . This way we obtain two heuristics for testing the\ncorresponding locally constrained graph homomorphisms. As a conse-\nquence, we have obtained a new polynomial time algorithm for testing\n(subgraph) isomorphism between universal covers, and for checking if\nthere exists a role assignment (locally surjective homomorphism) from a\ngiven tree to an arbitrary fixed graph H.\n1 Introduction\nIn this paper, we consider simple, undirected, possibly infinite but connected\ngraphs. See [5] for undefined graph terminology. A (graph) homomorphism f :\nG\u2192 H from a graphG = (VG, EG) to a graphH = (VH , EH) is a mapping VG \u2192\nVH such that (f(u), f(v)) \u2208 EH whenever (u, v) \u2208 EG. Graph homomorphisms\nhave a great deal of applications in graph theory, computer science and other\nfields, see the monograph [16].\nA graph homomorphism f from a graph G to a graph H can be required to\nsatisfy some local constraint [9]. If, for every u \u2208 VG the restriction of f , i.e. the\n? ? ? Supported by the Ministry of Education of the Czech Republic as project\n1M0021620808.\n\u2020 Supported by EPSRC as project EP\/D053633\/1.\nmapping fu : N(u)\u2192 N(f(u)), is bijective, we say that f is locally bijective [1,\n19], and we write G B\u2212\u2192 H. If, for every u \u2208 VG, fu is injective, we say that\nf is locally injective [10, 11], and we write G I\u2212\u2192 H. If, for every u \u2208 VG, fu is\nsurjective, we say that f is locally surjective [13, 20], and we write G S\u2212\u2192 H.\nLocally bijective homomorphisms, also called graph coverings, originally arose\nin topological graph theory [22], and have applications in distributed comput-\ning [4], in recognizing graphs by networks of processors [2], and in construct-\ning highly transitive regular graphs [3]. Locally injective homomorphisms, also\ncalled partial graph coverings, have been studied due to their applications in\nmodels of telecommunication [11], in distance constrained labelings of graphs\nwith applications to frequency assignment [12], and as indicators of the exis-\ntence of homomorphisms of derivate graphs (line graphs) [24]. Locally surjective\nhomomorphisms, also called role assignments, have applications in distributed\ncomputing [6] and social science [8, 26].\nThe main computational question is whether for every graph H the problem\nof deciding if an input graph G has a homomorphism of given type \u2217 = B, I\nor S to the fixed graph H can be classified as either NP-complete or polyno-\nmially solvable. For the locally surjective homomorphisms this classification is\nknown [13], with the problem for every connected H on at least three vertices\nbeing NP-complete. For the locally bijective and injective cases there are many\npartial results, see e.g. [11, 19], but even conjecturing a classification for these\ntwo cases is problematic. In this paper, we continue the study started in [14] in\norder to get more insight in the structure of these computational issues.\n1.1 Problem formulation\nThe existence of a locally constrained homomorphism imposes a partial order on\nthe class of connected graphs C for each of the three local constraints B, I, and\nS [14]. We can relax these three orders in two different ways. This leads to two\ndifferent heuristics for testing if G \u2217\u2212\u2192 H for two given graphs G and H under\neach type \u2217 = B, I, S.\nFirstly, we can transform the partial orders from the domain of finite graphs\nto the domain of matrices. An equitable partition of a connected graph G is a\npartition of its vertex set in blocks B1, . . . , Bk such that each vertex in each\nBi has the same number mi,j of neighbors in Bj , and we call the k \u00d7 k matrix\nM = (mi,j)1\u2264i,j\u2264k a degree matrix of G. We say that a vertex u is of the i-th\nsort if u \u2208 Bi. Equitable partitions are well-known in algebraic graph theory,\nsee e.g. [15]. Note that the degree refinement matrix of G is the degree matrix\ncorresponding to the equitable partition of G with the smallest number of blocks\n(which are ordered in a unique way), and an adjacency matrix of G can be seen\nas a degree matrix with the maximum number of rows.\nLetM be the set of all degree matrices. We define three relations (M, \u2203B\u2212\u2212\u2192),\n(M, \u2203I\u2212\u2192) and (M, \u2203S\u2212\u2192) imposed on the set of degree matrices by the existence of\ngraph homomorphisms of the corresponding local constraint, i.e.,M \u2203\u2217\u2212\u2192 N if and\nonly if there exist two graphs G,H \u2208 C with degree matrix M,N , respectively,\nsuch that G \u2217\u2212\u2192 H. All three relations are partial orders [14], and a successful\n2\nmatrix comparison of each type is a necessary condition for the corresponding\ngraph comparison.\nSecondly, we can transform the partial orders from the domain of finite graphs\nto the domain of possibly infinite trees. The universal cover TG of a connected\ngraph G is the only tree that allows a locally bijective homomorphism TG\nB\u2212\u2192 G.\nA generic construction of the universal cover takes as vertices of TG all finite\nwalks in G that start from an arbitrary fixed vertex in G and that does not\ntraverse the same edge in two consecutive steps. Two such vertices are adjacent\nin TG if the associated walks differ only in the presence of the last edge. The\nrequired homomorphism TG\nB\u2212\u2192 G can be taken as the mapping that assigns\nevery walk its last vertex. One can easily see that the universal cover is unique\nup to an isomorphism (in particular, if we take walks that start in another fixed\nvertex). As a matter of fact, if two subtrees of a universal cover rooted at two\ndifferent vertices are isomorphic to depth n\u2212 1, then they are isomorphic to all\ndepths [25]. Universal covers are also called infinite unfoldings or views of graphs\nand have applications in finite automata theory[23], distributed computing [18,\n27] and existential pebble games [7].\nAlso universal covers can be equipped with a structure that impose a neces-\nsary condition for the existence of a locally constrained homomorphism. There\nare two options: either the existence of a locally constrained homomorphism\nor a simple inclusion (as a subtree). In the latter case, TG = TH , TG \u2286 TH ,\nand TG \u2287 TH are necessary conditions for G B\u2212\u2192 H, G I\u2212\u2192 H and G S\u2212\u2192 H,\nrespectively, see [14] for more details.\nMoreover, a result in [14] states that the universal cover TG is equal to the\nuniversal cover TM of any degree matrix M of G which is constructed in the\nfollowing way. We take as root a vertex corresponding to row 1 of M , thus of\nthe 1st sort, and inductively adding a new level of vertices while maintaining the\nproperty that each vertex of the i-th sort has exactly mi,j neighbors of the j-th\nsort. Hence, a successful universal cover comparison is a necessary condition for\nthe corresponding graph comparison as well. More precisely, we have shown the\nforward implications in the following theorem.\nTheorem 1. Let G and H be connected graphs with degree matrices M and N ,\nresp. Then the following holds:\nG B\u2212\u2192 H =\u21d2M \u2203B\u2212\u2212\u2192 N \u21d0\u21d2 TG B\u2212\u2192 TH \u21d0\u21d2 TG = TH\nG I\u2212\u2192 H =\u21d2 M \u2203I\u2212\u2192 N =\u21d2 TG I\u2212\u2192 TH \u21d0\u21d2 TG \u2286 TH\nG S\u2212\u2192 H =\u21d2 M \u2203S\u2212\u2192 N =\u21d2 TG S\u2212\u2192 TH =\u21d2 TG \u2287 TH\nThe backward implications in Theorem 1 for locally bijective homomorphism are\nconsequences of the theorem of Leighton [21]. The equivalence TG\nI\u2212\u2192 TH \u21d0\u21d2\nTG \u2286 TH follows form the fact that a locally injective homomorphisms between\ntwo trees is indeed globally injective [14].\nObserve that C4 6 \u2217\u2212\u2192 C3 while both graphs allow the 1 \u00d7 1 degree matrix\nM = (2). This example excludes the implication G \u2217\u2212\u2192 H \u21d0= M \u2203\u2217\u2212\u2192 N for\n\u2217 = B, I, S. If G itself is a tree then TG = G. We then find that TG S\u2212\u2192 TH 6\u21d0=\n3\nTG \u2287 TH for the choice G = P4, H = P3, since P4 \u2287 P3 but P4 6 S\u2212\u2192 P3. This\nexample shows that the relations TG\nS\u2212\u2192 TH and TG \u2287 TH are different. By\nusing linear programming techniques, the backward implication M \u2203I\u2212\u2192 N \u21d0=\nTM\nI\u2212\u2192 TN can be excluded [14]. So, the inclusion of universal covers does not\nimply the relation on matrices for the locally injective constraint. What about\nthe remaining backward implication?\nQuestion 1. Does there exist a counter example for the backward implication\nM \u2203S\u2212\u2192 N \u21d0= TG S\u2212\u2192 TH in Theorem 1?\nThe problem of deciding G \u2217\u2212\u2192 H is NP-complete for all three local constraints,\nand remains NP-hard for many particular fixed targets H, as we mentioned ear-\nlier on. We have shown that M \u2203B\u2212\u2212\u2192 N can be verified in polynomial time, but\nso far only membership to the class NP could be shown for the matrix compar-\nison problem M \u2203\u2217\u2212\u2192 N for \u2217 = I, S [14]. It is not expected that a polynomial\nalgorithm would solve these two problems. Testing if TG = TH can be done in\npolynomial time by checking if G and H share the same the degree refinement\nmatrix [2]. Especially given the above, it would be useful to have a polynomial\nheuristic for checking the other universal problem comparisons as well.\nQuestion 2. How hard is it to decide if TG\nI\u2212\u2192 TH (or equivalently TG \u2286 TH)\nholds and to decide if TG\nS\u2212\u2192 TH holds for two given connected graphs G and H?\nIn this paper we answer Question 1 in Section 2 as well as Question 2 in Section 3.\n2 Excluding the remaining implication\nWe show that the relation TM\nS\u2212\u2192 TN lies strictly between M \u2203S\u2212\u2192 N and TM \u2287\nTN .\nProposition 1. For degree matrices\nM =\n\uf8eb\uf8ec\uf8ec\uf8ed\n2 1 0 0\n3 0 1 0\n0 1 0 2\n0 0 1 0\n\uf8f6\uf8f7\uf8f7\uf8f8 and N = (0 12 1\n)\nit holds that TM\nS\u2212\u2192 TN but M 6 \u2203S\u2212\u2192 N .\nProof. Observe first that N is a matrix of a finite tree TN and no other con-\nnected simple graph allows this degree matrix. The infinite tree TM consist of\npairwise disjoint paths that are of infinite length and induced by vertices of the\nfirst sort (white vertices). These paths are linked by vertices of the second sort\n(each is adjacent to three paths) and every vertex of the second sort is joined\nto the middle vertex of a unique P3. The trees TM and TN together with a\nhomomorphism witnessing TM\nS\u2212\u2192 TN are depicted in Fig. 1.\nThis homomorphism is obtained inductively. We first map one infinite white\npath into TN such that the sorts of the images alternate. Every vertex u of the\n4\nTM\nd\ne\nc f\nd\ne\nb e\ne c d f\nTN\na1 c1\nb2\ne2\nf1d1\nb3b2 e2d4\nf4\na4\nc4\ne3\nb b b ba a a a\nFig. 1. Showing TM\nS\u2212\u2192 TN . White vertices in TM are of the 1st sort.\nSorts of the remaining vertices are indicated by subscripts.\nsecond sort in TM must be mapped on a vertex of the second sort in TN so that\nthe homomorphism can be extended to the pending claw.\nThen, depending of whether the image of the already processed neighbor\nof u was of the first or of the second sort, we extend the mapping to the two\ninfinite white paths that contains the remaining two neighbors of u. Both cases\nare depicted in Fig. 1.\nNow, in order to obtain a contradiction, assume that a finite graph G with\ndegree matrixM and a mapping f : G S\u2212\u2192 TN exists (recall that the target graph\nTN is unique for this choice of N). Consider the vertices of the first sort of G,\ncall them red. These red vertices induce a disjoint union of cycles in G.\nDenote by a the number of red vertices u such that f(u) is of the first sort\nin TN and call them light-red. Analogously, let b be the number of red vertices v\nsuch that f(v) is of the second sort, and call them dark-red. Since N prescribes\nthat both red neighbors of every light-red u must be dark we have a \u2264 b.\nOn the other hand, due to the pending claws (which also exist in G), every\nvertex of the third sort in G is mapped to a vertex of the second sort in TN ,\nand every vertex of the fourth sort in G is mapped to a vertex of the first sort\nin TN . Then every vertex u\u2032 of the second sort in G is mapped to a vertex of\nthe second sort in TN . Since already its neighbor of the third sort is mapped to\na vertex of the second sort in TN , u\u2032 must have at least two light-red neighbors\nand, consequently, at most one dark-red neighbor. Hence, a \u2265 2b which is in\ncontradiction with a \u2264 b. We conclude that M 6 \u2203S\u2212\u2192 N . uunionsq\n3 Testing locally injective and surjective homomorphisms\nbetween universal covers\nIn this section we focus on the decision problems whether TM\n\u2217\u2212\u2192 TN holds\nfor local constraints \u2217 = I, S. As the algorithms are almost the same for both\nconstraints, we treat both cases simultaneously, pointing only at the differences\n5\nwhere the particular local constraint plays different role. We first need some new\nterminology. For an integer k \u2265 1 we define [k] := {1, 2, . . . , k} and abbreviate\n[k]\u00d7 [l] by [k \u00d7 l].\nDefinition 1. Let M and N be two degree matrices of order k and l, resp.\nWe say that a vector pr,s consisting of kl nonnegative integers is a distribution\nrow for indices (r, s) \u2208 [k \u00d7 l] if the condition 1 holds. A distribution row pr,s\nis called injective if in addition condition 2 holds. It is called surjective if in\naddition conditions 3 and 4 hold.\nl\u2211\nj=1\npr,si,j = mr,i for all i \u2208 [k], (1)\nk\u2211\ni=1\npr,si,j \u2264 ns,j for all j \u2208 [l], (2)\nns,j \u2265 1 =\u21d2\nk\u2211\ni=1\npr,si,j \u2265 ns,j for all j \u2208 [l], (3)\nns,j = 0 =\u21d2\nk\u2211\ni=1\npr,si,j = 0 for all j \u2208 [l]. (4)\nAs an example, consider the matrices M and N from Proposition 1. The locally\nsurjective homomorphism from TM and TN in Figure 1 defines exactly the follow-\ning surjective distribution rows pr,s = (pr,s1,1, p\nr,s\n1,2, p\nr,s\n2,1, p\nr,s\n2,2, p\nr,s\n3,1, p\nr,s\n3,2, p\nr,s\n4,1, p\nr,s\n4,2):\np1,1 = (0, 2, 0, 1, 0, 0, 0, 0)\np1,2 = (2, 0, 0, 1, 0, 0, 0, 0)\np2,2 = (2, 1, 0, 0, 0, 1, 0, 0)\np3,2 = (0, 0, 0, 1, 0, 0, 2, 0)\np4,1 = (0, 0, 0, 0, 0, 1, 0, 0)\nDistribution rows play a central role in the NP algorithms for the degree matrix\ncomparison problems M \u2203I\u2212\u2192 N and M S\u2212\u2192 N [14]. Suppose G \u2217\u2212\u2192 H via f is\nindeed a witness for M \u2203\u2217\u2212\u2192 N for \u2217 \u2208 {I, S}. Let f map u \u2208 VG of the r-th sort\nto v \u2208 VH of the s-th sort, and denote the number of neighbors of the i-th sort\nin NG(u) that are mapped to neighbors of the j-th sort in NH(v) by p\nr,s\ni,j . Then\nthe vector pr,s defined by entries pr,si,j is a (surjective or injective) distribution\nrow that we call suitable. Our NP algorithms try to identify suitable distribution\nrows. The difficulty is that there may be exponentially many distribution rows.\nTherefore, these algorithms could only use the nondeterministic choice of suitable\ndistribution rows to verify whether M \u2203\u2217\u2212\u2192 N holds for \u2217 = I, S, respectively,\nsee [14] for more details. However, for the decision problem on the existence\nof a locally constrained homomorphism between universal covers we prove that\nwe may reduce the number of suitable distribution rows to only a polynomial\nnumber. For showing this we need some more terminology. For a degree matrix\nM we say that matrix rows r and i are adjacent if mr,i > 0.\n6\nDefinition 2. We say that a distribution row pr,s is a witness of type (s, j) for\n(adjacent) matrix rows r and i if pr,si,j \u2265 1.\nDefinition 3. We say that a distribution row pr,s respects the allowed set X \u2286\n[k \u00d7 l] if pr,si\u2032,j\u2032 \u2265 1 implies (i\u2032, j\u2032) \u2208 X for all (i\u2032, j\u2032) \u2208 [k \u00d7 l].\nNote that if pr,s is a witness of type (s, j) for matrix rows r and i that respects an\nallowed set X then (i, j) \u2208 X. We need the following lemma for our algorithms.\nLemma 1. For given r and i the existence of an injective or surjective witness\npr,s of type (s, j) respecting an allowed set X can be tested in a polynomial time.\nProof. We can do this by translating the problem to the integer flow problem.\nIt is well-known [17] that this problem can be solved in polynomial time on flow\nnetworks with integer edge capacities (if such a network has a flow, then this\nflow may be assumed to be integer). We first define our auxiliary flow network F\nand then explain it afterwards. We let VF = {p, ui\u2032 , vj\u2032 , q | (i\u2032, j\u2032) \u2208 [k \u00d7 l]} and\nEF = {(p, ui\u2032), (ui\u2032 , vj\u2032), (vj\u2032 , q) | (i\u2032, j\u2032) \u2208 [k\u00d7 l]}. The sought flow g goes from p\nto q and must satisfy the following edge constraints:\ng(p, ui\u2032) = mr,i\u2032\ng(ui\u2032 , vj\u2032)\n\uf8f1\uf8f4\uf8f2\uf8f4\uf8f3\n\u2265 1 if (i\u2032, j\u2032) = (i, j)\n= 0 if (i\u2032, j\u2032) \/\u2208 X\n\u2265 0 otherwise\nfor \u2217 = I : g(vj\u2032 , q) \u2264 ns,j\u2032\nfor \u2217 = S : g(vj\u2032 , q)\n{\n\u2265 ns,j\u2032 if ns,j\u2032 \u2265 1\n= 0 if ns,j\u2032 = 0\nWe claim that F has an integer flow g if and only if there exists an injective, or\nrespectively, surjective witness pr,s of type (s, j) for r and i respecting X. First\nsuppose F allows an integer flow g. Choose pr,si\u2032,j\u2032 = g(ui\u2032 , vj\u2032) for all (i\n\u2032, j\u2032) \u2208 [k\u00d7\nl]. Because\n\u2211l\nj\u2032=1 p\nr,s\ni\u2032,j\u2032 =\n\u2211l\nj\u2032=1 g(ui\u2032 , vj\u2032) = g(p, ui\u2032) = mr,i\u2032 for all i\n\u2032 \u2208 [k], pr,s\nis a distribution row. For all j\u2032 \u2208 [l], \u2211ki\u2032=1 pr,si\u2032,j\u2032 = \u2211ki\u2032=1 g(ui\u2032 , vj\u2032) = g(v\u2032j , q),\nwhich is at most ns,j\u2032 if \u2217 = I, at least ns,j\u2032 if \u2217 = S and ns,j\u2032 \u2265 1, and 0\notherwise, pr,s is injective or surjective, respectively. Since pr,si,j = g(ui, vj) \u2265 1,\npr,s is a witness. Finally, since pr,si\u2032,j\u2032 = g(ui\u2032 , vj\u2032) = 0 for all (i\n\u2032, j\u2032) \/\u2208 X, pr,s\nrespects X.\nNow suppose there exists an injective, or respectively, surjective witness pr,s\nof type (s, j) for r and i respecting X. By Definition 2, pr,si,j \u2265 1. It is easy to\nverify that pr,s satisfies the other edge constraints in F as well. Hence F allows\npr,s as integer flow. uunionsq\nOur two algorithms can now be presented as one generic iterative algorithm.\n7\nAlgorithm 1: The test whether TM\n\u2217\u2212\u2192 TN holds for \u2217 = I or S\nInput: Degree matrices M and N\nParameter: Local constraint \u2217 \u2208 {I, S}\ninitialize Xr,s = {(i, j) |mr,i > 0 and ns,j > 0} for all (r, s) \u2208 [k \u00d7 l];\nrepeat\nforeach (r, s) \u2208 [k \u00d7 l] and (i, j) \u2208 Xr,s do\nif (r, i) has no witness of type (s, j) respecting Xr,s then\nremove (i, j) from Xr,s and remove (r, s) from Xi,j ;\nend\nend\nuntil no removal happens during the whole foreach loop ;\nif there exists an r \u2208 [k] with Xr,s empty for all s \u2208 [l] then\nreturn TM 6 \u2217\u2212\u2192 TN\nelse\nreturn TM\n\u2217\u2212\u2192 TN\nend\nTheorem 2. Algorithm 1 is correct and runs in polynomial time.\nProof. For each Xr,s, one iteration of Algorithm 1 takes polynomial time due\nto Lemma 1. Since the number of different allowed sets Xr,s is kl, a complete\niteration, i.e., an iteration over all Xr,s, then takes polynomial time as well. At\nthe start of the algorithm each Xr,s contains at most kl elements, and after each\ncomplete iteration the size of each Xr,s has never increased. Since the algorithm\nfinishes as soon as all Xr,s have stable size, the number of iterations is at most\nkl. We conclude that Algorithm 1 runs in polynomial time.\nWe now show that Algorithm 1 is correct. Suppose TM\n\u2217\u2212\u2192 TN via f . Then f\ninduces witnesses of type (s, j) for all adjacent matrix rows r, i such that (r, i)\nhas a witness of type (s, j) if and only if (i, r) has a witness of type (j, s). Hence\nf defines nonempty sets Xr,s for all matrix rows r.\nIt remains to show that if Algorithm 1 terminates in the affirmative state,\nthen a locally constrained homomorphism f : TM\n\u2217\u2212\u2192 TN can be constructed.\nPick an arbitrary vertex u \u2208 TM . Let u be of the r-th sort. By definition of the\nalgorithm, there exists a (final) allowed set Xr,s 6= \u2205. Define f(u) = v for any\nv \u2208 TN that is of the s-th sort. Choose an arbitrary (i, j) \u2208 Xr,s. By definition\nof Xr,s, we can find a witness pr,s for (r, i) of type (s, j) respecting Xr,s.\nWe use pr,s to extend f . By definition of pr,s, for every pr,si\u2032,j\u2032 \u2265 1, we can let f\nmap pr,si\u2032,j\u2032 different neighbors of u that all are of the i\n\u2032-th sort onto neighbors of v\nthat all are of the j\u2032-the sort in such a way that, from N(u) to N(v), f is injective\nwhen \u2217 = I, and surjective when \u2217 = S. Whenever the mapping f is defined\nalong an edge (u, u\u2032), we iteratively extend f to the whole neighborhood N(u\u2032)\nof u\u2032 by the same procedure as above in case N(u\u2032) ) {u}. We only have to make\nsure to choose a witness pi\n\u2032,j\u2032 for (i\u2032, r) of type (j\u2032, s), where u, u\u2032, f(u) and f(u\u2032)\nare of the r, i\u2032, s- and j\u2032-th sort respectively. Then pi\n\u2032,j\u2032\nr,s \u2265 1 by definition of a\n8\nwitness, and indeed we can use pi\n\u2032,j\u2032 to extend our mapping f that already maps\nu \u2208 N(u\u2032) of the r-th sort to v \u2208 N(f(u\u2032)) of the s-th sort. The reason why such\na witness pi\n\u2032,j\u2032 exists follows from the reciprocal removal of pairs (i\u2032, j\u2032) from\nXr,s and (r, s) from Xi\n\u2032,j\u2032 . When the condition of the repeat loop is satisfied,\nit holds that\n(r, i\u2032) has a witness of type (s, j\u2032) respecting Xr,s\nif and only if\n(i\u2032, r) has a witness of type (j\u2032, s) respecting Xi\n\u2032,j\u2032 .\nuunionsq\nWe are even able to construct in polynomial time a locally constrained homo-\nmorphism f : TM\n\u2217\u2212\u2192 TN if Algorithm 1 approves that TM \u2217\u2212\u2192 TN . This can\nbe seen as follows. We use the method described in the proof of Theorem 2 to\nconstruct f . Finding witnesses respecting certain allowed sets can be done in\npolynomial time using the flow network of the proof of Lemma 1. If f is defined\nalong edge (u, u\u2032) then we always choose for the same extension of f on N(u\u2032),\ni.e., how we extend f only depends on the sort of u and the sort of u\u2032. As it is\nsufficient to keep only at most kl possibilities, the claim follows.\n4 Conclusions\nWe have answered questions 1 and 2 of Section 1.1 in Proposition 1 and Theo-\nrem 2, respectively. We conclude with some other applications.\nThe H-Role Assignment problem asks whether G S\u2212\u2192 H for a graph G and\na fixed target graph H. This problem is NP-complete for all connected graphs H\non at least three vertices [13]. It becomes polynomially solvable for every fixed\ntarget H when restricted to the class of trees. This follows from Theorem 2, and\nthe fact that T 6 S\u2212\u2192 G if T is a tree and G contains a cycle, together with the\nfact that TG = T for every tree G. Since TG\nI\u2212\u2192 TH if and only if TG \u2286 TH ,\nAlgorithm 1 tests for infinite subtree isomorphism as well. Since TG = T for\nevery tree G, it can also be used for (sub-)tree isomorphism for finite trees,\nespecially if these trees can be encoded in terms of degree (refinement) matrices\nindependent of their original size (as otherwise much faster algorithms exist).\nFinally, we note that there exist matrices that are not the degree matrix of\na finite graph. If such a matrix M has the property that mi,j > 0 whenever\nmj,i > 0 then it still possible to construct a universal cover TM of M (or disjoint\nsubmatrices of M) in the same way as before. Algorithm 1 can then be used for\nuniversal cover comparison of those matrices as well.\nAcknowledgments. We thank Jan Arne Telle for fruitful discussions on this topic.\nReferences\n1. Abello, J., Fellows, M. R., and Stillwell, J. C. On the complexity and\ncombinatorics of covering finite complexes. Australian Journal of Combinatorics 4\n(1991), 103\u2013112.\n9\n2. Angluin, D. Local and global properties in networks of processors. In Proceedings\nof the 12th ACM Symposium on Theory of Computing (1980), 82\u201393.\n3. Biggs, N. Constructing 5-arc transitive cubic graphs. Journal of London Mathe-\nmatical Society II. 26 (1982), 193\u2013200.\n4. Bodlaender, H. L. The classification of coverings of processor networks. Journal\nof Parallel Distributed Computing 6 (1989), 166\u2013182.\n5. Bondy, J.A., and Murty, U.S.R. Graph Theory with Applications. Macmillan,\nLondon and Elsevier, New York, 1976.\n6. Chalopin, J., Me\u00b4tivier, Y., and Zielonka W., Local computations in graphs:\nthe case of cellular edge local computations. Fund. Inform. 74 (2006), 85\u2013114.\n7. Dantchev, S., Martin, B.D., and Stewart, I.A., On non-definability of un-\nsatisfiability, manuscript.\n8. Everett, M. G., and Borgatti, S. Role coloring a graph. Mathematical Social\nSciences 21 (1991), 183\u2013188.\n9. Fiala, J., Heggernes, P., Kristiansen, P., and Telle, J. A. Generalized H-\ncoloring and H-covering of trees. Nordic Journal of Computing 10 (2003), 206\u2013224\n10. Fiala, J., and Kratochv\u00b4\u0131l, J. Complexity of partial covers of graphs. In Algo-\nrithms and Computation, 12th ISAAC \u201901, LNCS 2223, 537\u2013549.\n11. Fiala, J., and Kratochv\u00b4\u0131l, J. Partial covers of graphs. Discussiones Mathe-\nmaticae Graph Theory 22 (2002), 89\u201399.\n12. Fiala, J., Kratochv\u00b4\u0131l, J., and Kloks, T. Fixed-parameter complexity of \u03bb-\nlabelings. Discrete Applied Mathematics 113 (2001), 59\u201372.\n13. Fiala, J., and Paulusma, D. A complete complexity classification of the role\nassignment problem. Theoretical Computer Science 349 (2005), 67-81.\n14. Fiala, J., Paulusma, D., and Telle, J.A. Locally constrained graph homomor-\nphisms and equitable partitions, to appear in European Journal of Combinatorics.\n15. Godsil, C. Algebraic Combinatorics. Chapman and Hall, 1993.\n16. Hell, P., and Nes\u02c7etr\u02c7il, J. Graphs and Homomorphisms. Oxford University\nPress, 2004.\n17. Hoffman, A.J., and Kruskal, J.B. Integral boundary points of convex polyhe-\ndra. Annals of Mathematics Studies 38 (1956), 223\u2013246.\n18. Kranakis, E., Krizanc, D., and Van den Berg, J. Computing boolean func-\ntions on anonymous networks. Information and Computation 114 (1994), 214\u2013236.\n19. Kratochv\u00b4\u0131l, J., Proskurowski, A., and Telle, J. A. Covering regular graphs.\nJournal of Combinatorial Theory B 71 (1997), 1\u201316.\n20. Kristiansen, P., and Telle, J. A. Generalized H-coloring of graphs. In Algo-\nrithms and Computation, 11th ISAAC \u201901, LNCS 1969, 456\u2013466.\n21. Leighton, F. T. Finite common coverings of graphs. Journal of Combinatorial\nTheory B 33 (1982), 231\u2013238.\n22. Massey, W. S. Algebraic Topology: An Introduction. Harcourt, 1967.\n23. Moore, E.F. Gedanken-experiments on sequential machines. Annals of Mathe-\nmatics Studies 34 (1956), 129\u2013153.\n24. Nes\u02c7etr\u02c7il, J. Homomorphisms of derivative graphs. Discrete Math. 1 (1971),\n257\u2013268.\n25. Norris, N. Universal covers of graphs: isomorphism to depth n \u2212 1 implies iso-\nmorphism to all depths. Discrete Applied Mathematics 56 (1995), 61\u201374.\n26. Roberts, F. S., and Sheng, L. How hard is it to determine if a graph has a\n2-role assignment? Networks 37, (2001), 67\u201373.\n27. Yamashita, M., and Kameda, T., Computing on anonymous networks: Part I -\nCharacterizing the solvable cases. IEEE Transactions on Parallel and Distributed\nSystems 7 (1996), 69\u201389.\n10\n"}