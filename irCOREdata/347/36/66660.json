{"doi":"10.1016\/S0304-3975(01)00183-9","coreId":"66660","oai":"oai:dro.dur.ac.uk.OAI2:606","identifiers":["oai:dro.dur.ac.uk.OAI2:606","10.1016\/S0304-3975(01)00183-9"],"title":"Program schemes, arrays, Lindstr\u00f6m quantifiers and zero-one laws.","authors":["Stewart,  I.A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2002-03","abstract":"We characterize the class of problems accepted by a class of program schemes with arrays, NPSA, as the class of problems defined by the sentences of a logic formed by extending first-order logic with a particular uniform (or vectorized) sequence of Lindstr\u00f6m quantifiers. A simple extension of a known result thus enables us to prove that our logic, and consequently our class of program schemes, has a zero-one law. However, we use another existing result to show that there are problems definable in a basic fragment of our logic, and so also accepted by basic program schemes, which are not definable in bounded-variable infinitary logic. As a consequence, the class of problems NPSA is not contained in the class of problems defined by the sentences of partial fixed-point logic even though in the presence of a built-in successor relation, both NPSA and partial fixed-point logic capture the complexity class PSPACE","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66660.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/606\/1\/606.pdf","pdfHashValue":"ff72d190e1e9ba23d53ba802bb70beff7f898417","publisher":"Elsevier","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:606<\/identifier><datestamp>\n      2011-06-14T15:42:11Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Program schemes, arrays, Lindstr\u00f6m quantifiers and zero-one laws.<\/dc:title><dc:creator>\n        Stewart,  I.A.<\/dc:creator><dc:description>\n        We characterize the class of problems accepted by a class of program schemes with arrays, NPSA, as the class of problems defined by the sentences of a logic formed by extending first-order logic with a particular uniform (or vectorized) sequence of Lindstr\u00f6m quantifiers. A simple extension of a known result thus enables us to prove that our logic, and consequently our class of program schemes, has a zero-one law. However, we use another existing result to show that there are problems definable in a basic fragment of our logic, and so also accepted by basic program schemes, which are not definable in bounded-variable infinitary logic. As a consequence, the class of problems NPSA is not contained in the class of problems defined by the sentences of partial fixed-point logic even though in the presence of a built-in successor relation, both NPSA and partial fixed-point logic capture the complexity class PSPACE.<\/dc:description><dc:subject>\n        Finite model theory<\/dc:subject><dc:subject>\n         Descriptive complexity.<\/dc:subject><dc:publisher>\n        Elsevier<\/dc:publisher><dc:source>\n        Theoretical computer science, 2002, Vol.275(1-2), pp.283-310 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2002-03<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:606<\/dc:identifier><dc:identifier>\n        issn:0304-3975<\/dc:identifier><dc:identifier>\n        doi:10.1016\/S0304-3975(01)00183-9<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/606\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1016\/S0304-3975(01)00183-9<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/606\/1\/606.pdf<\/dc:identifier><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0304-3975","issn:0304-3975"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2002,"topics":["Finite model theory","Descriptive complexity."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 October 2008\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nStewart, I.A. (2002) \u2019Program schemes, arrays, Lindstrm quantifiers and zero-one laws.\u2019, Theoretical computer\nscience., 275 (1-2). pp. 283-310.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1016\/S0304-3975(01)00183-9\nPublisher\u2019s copyright statement:\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nProgram schemes, arrays, Lindstro\u00a8m\nquantifiers and zero-one laws\u2217\nIain A. Stewart\u2020,\nDepartment of Mathematics and Computer Science,\nUniversity of Leicester, Leicester LE1 7RH, U.K.\nJune 21, 2001\nAbstract\nWe characterize the class of problems accepted by a class of program schemes with arrays,\nNPSA, as the class of problems defined by the sentences of a logic formed by extending first-\norder logic with a particular uniform (or vectorized) sequence of Lindstro\u00a8m quantifiers. A\nsimple extension of a known result thus enables us to prove that our logic, and consequently\nour class of program schemes, has a zero-one law. However, we use another existing result to\nshow that there are problems definable in a basic fragment of our logic, and so also accepted\nby basic program schemes, which are not definable in bounded-variable infinitary logic. As a\nconsequence, the class of problems NPSA is not contained in the class of problems defined by\nthe sentences of partial fixed-point logic even though in the presence of a built-in successor\nrelation, both NPSA and partial fixed-point logic capture the complexity class PSPACE.\n1 Introduction\nThis paper is a continuation of the study of the classes of problems captured by\ndifferent classes of program schemes (in this study, the particular emphasis is on\na comparison with the classes of problems defined by the sentences of well-known\nlogics from finite model theory). Program schemes form a model of computation\nthat is amenable to logical analysis yet is closer to the general notion of a program\nthan a logical formula is. Program schemes were extensively studied in the seventies\n(for example, see [3, 7, 16, 35]), without much regard being paid to an analysis of\nresources, before a closer complexity analysis was undertaken in, mainly, the eighties\n(for example, see [24, 26, 44]). There are connections between program schemes\nand logics of programs, especially dynamic logic [9, 30]. One might also view many\nquery languages from database theory as classes of program schemes, although query\n\u2217An extended abstract of this paper appeared in Proc. Computer Science Logic, Lecture Notes\nin Computer Science Vol. 1683, Springer-Verlag (1999) 374\u2013388.\n\u2020Supported by EPSRC Grants GR\/K 96564 and GR\/M 12933.\n1\nlanguages tend to operate on relations as opposed to individual elements (for example,\nsee the while language from [1, 4, 5] and the language BQL from [4, 33]).\nOne of the most basic classes of program schemes is that obtained by allowing as-\nsignments, while instructions with quantifier-free tests and non-determinism. In [6],\nthe relative expressibilities of this class of program schemes, NPS(1), in the presence\nof a built-in successor, a built-in linear-order, a built-in multiplication, a built-in ad-\ndition and combinations of such were completely classified. It was shown in [2] that\nNPS, an extension of NPS(1) obtained by allowing universally quantified program\nschemes to appear as tests in while instructions, is none other than transitive clo-\nsure logic and that a computational analysis (as opposed to a model-theoretic, and in\nparticular a game-theoretic, analysis) of such program schemes yields proper infinite\nhierarchies within NPS (and so within transitive closure logic). Also in [2], the class of\nprogram schemes obtained from NPS by allowing additional access to a stack, NPSS,\nwas shown to be none other than path system logic (which had previously been shown\nto be none other than stratified fixed point logic and stratified Datalog [28, 22]), and\nagain a computational analysis of the program schemes of NPSS was shown to yield\nproper infinite hierarchies within NPSS (and so within path system logic). Subse-\nquently, in [43], a detailed analysis of certain program schemes of NPSS yielded that\nany polynomial-time problem involving strongly-connected locally-ordered digraphs,\nconnected planar embeddings or triangulations (that is, planar graphs embeddable\nin the plane so that every face is a cycle of length 3) can be defined in (a proper\nfragment of) path system logic (without any built-in relations).\nThe results mentioned above show that the study of program schemes is inti-\nmately related with more mainstream logics from finite model theory. In [38], pro-\ngram schemes allowing assignments, while instructions with quantifier-free tests, non-\ndeterminism and access to arrays were studied but only in the presence of a built-in\nsuccessor relation (the class of problems accepted by such program schemes was shown\nto be PSPACE). It is with these program schemes and their extensions, obtained by\nallowing universally quantified program schemes to appear as tests in while instruc-\ntions, that we are concerned in this paper but in the absence of any built-in relations;\nthat is, the class of program schemes NPSA. Our class of program schemes NPSA is\nquite natural. It consists of the union of an infinite hierarchy of classes of program\nschemes\nNPSA(1) \u2286 NPSA(2) \u2286 NPSA(3) \u2286 . . .\nThe program schemes of NPSA(1) are built by allowing assignments, while instruc-\ntions with quantifier-free tests, non-determinism and access to arrays (full details\nfollow later). The program schemes of NPSA(2) are built from program schemes of\nNPSA(1) by universally quantifying free variables. The program schemes of NPSA(3)\nare built as are the program schemes of NPSA(1) except that tests in while instruc-\ntions can be program schemes of NPSA(2). The program schemes of NPSA(4) are\nbuilt from program schemes of NPSA(3) by universally quantifying free variables; and\nso on.\nWhat is crucial is our definition of the semantics. Consider, for example, a while\ninstruction in a program scheme \u03c1 of NPSA(3) where the test is a program scheme\n\u03c1\u2032 of NPSA(2). In order to evaluate whether the test is true or not, the arrays from\n\u03c1 are not \u2018passed over\u2019 to the program scheme \u03c1\u2032: the evaluation of \u03c1\u2032 has no access\nto the arrays of \u03c1. After evaluation of \u03c1\u2032 has been completed, the computation of\n2\nthe program scheme \u03c1 resumes accordingly with its arrays having exactly the same\nvalues as they had immediately prior to the evaluation of \u03c1\u2032. It is essentially our\nsemantic definition that enables us to characterize the class of problems accepted by\nthe program schemes of NPSA as the class of problems defined by the sentences of\na logic (\u00b1\u2126)\u2217[FO] formed by extending first-order logic with a particular uniform\n(or vectorized) sequence of Lindstro\u00a8m quantifiers (where this uniform sequence of\nLindstro\u00a8m quantifiers corresponds to a PSPACE-complete problem \u2126). Moreover,\nwe show that the logic (\u00b1\u2126)\u2217[FO] has a zero-one law; but not because it is a fragment\nof bounded-variable infinitary logic, as is so often the case in finite model theory, for\nwe show that there are problems definable in NPSA (in NPSA(1) even) which are not\ndefinable in bounded-variable infinitary logic. Consequently, whilst both NPSA and\npartial fixed-point logic capture the complexity class PSPACE in the presence of\na built-in successor relation, there are problems in NPSA which are not definable\nin partial-fixed point logic. If our semantics were such as to allow for universal\nquantification over arrays then we could simply guess a successor relation and hold our\nguesses in an array, use universal quantification to verify that the guessed relation was\nindeed a successor relation and subsequently use this guessed relation as our successor\nrelation throughout. Consequently, we would have captured PSPACE and not the\ninteresting logics (with zero-one laws but which are not fragments of bounded-variable\ninfinitary logic) encountered in this paper.\nSection 2 includes our preliminary definitions (with [13] serving as our basic ref-\nerence text for finite model theory). In Section 3, we establish complete problems for\nNPSA(1) via quantifier-free first-order translations with 2 constants, and in Section\n4, we use these completeness results to obtain our logical characterizations of NPSA.\nWe then use a result due to Stewart to show that NPSA(1) (and so NPSA) is not\ncontained in bounded-variable infinitary logic. In Section 5, we extend a result due\nto Dawar and Gra\u00a8del and hence show that our logics from the previous section, and\nconsequently NPSA, have a zero-one law. Finally, we present our conclusions and\ndirections for further research.\n2 Preliminaries\n2.1 Logic\nOrdinarily, a signature \u03c3 is a tuple \u3008R1, . . . , Rr, C1, . . . , Cc\u3009, where each Ri is a relation\nsymbol, of arity ai, and each Cj is a constant symbol. However, we sometimes consider\nsignatures in which there are no constant symbols; that is, relational signatures. First-\norder logic over the signature \u03c3, FO(\u03c3), consists of those formulae built from atomic\nformulae over \u03c3 using \u2227, \u2228, \u00ac, \u2200 and \u2203; and FO = \u222a{FO(\u03c3) : \u03c3 is some signature}.\nA finite structure A over the signature \u03c3, or \u03c3-structure, consists of a finite uni-\nverse or domain |A| together with a relation Ri of arity ai, for every relation symbol\nRi of \u03c3, and a constant Cj \u2208 |A|, for every constant symbol Cj (by an abuse of no-\ntation, we do not distinguish between constants or relations and constant or relation\nsymbols). A finite structure A whose domain consists of n distinct elements has size\nn, and we denote the size of A by |A| also (this does not cause confusion). We only\never consider finite structures of size at least 2, and the set of all finite structures of\nsize at least 2 over the signature \u03c3 is denoted STRUCT(\u03c3). A problem over some\n3\nsignature \u03c3 consists of a subset of STRUCT(\u03c3) that is closed under isomorphism;\nthat is, if A is in the problem then so is every isomorphic copy of A. Throughout, all\nour structures are finite.\n2.2 Lindstro\u00a8m quantifiers\nWe are now in a position to consider the class of problems defined by the sentences\nof FO: we denote this class of problems by FO also, and do likewise for other logics.\nIt is widely acknowledged that, as a means for defining problems, first-order logic\nleaves a lot to be desired especially when we have in mind developing a relationship\nbetween computational complexity and logical definability. In particular, every first-\norder definable problem can be accepted by a logspace deterministic Turing machine\nyet there are problems in the complexity class L (logspace) which can not be defined\nin first-order logic (one such being the problem consisting of all those structures,\nover any signature, that have even size). Consequently, we now illustrate one way\nof increasing the expressibility of FO: we augment FO with a uniform or vectorized\nsequence of Lindstro\u00a8m quantifiers, or operator for short (the reader is referred to [13]\nfor a fuller exposition on the limitations of FO and on a number of different methods,\nincluding this one, for increasing the expressibility of FO).\nOur illustration uses an operator derived from a problem whose underlying in-\nstances can be regarded as path systems. A path system consists of a finite set of\nvertices and a finite set of rules, each of the form (x, y, z), where x, y and z are (not\nnecessarily distinct) vertices. There is a unique distinguished vertex called the source\nand a unique distinguished vertex called the sink . The set of accessible vertices in\nany path system is built as follows. Initially, the source is deemed to be accessible\nand new vertices are shown to be accessible by applying the rules via: if x and y are\naccessible (with possibly x = y) and there is a rule (x, y, z) then z becomes accessi-\nble. The path system problem consists of all those path systems for which the sink is\naccessible from the source, and it was the first problem to be shown to be complete\nfor the complexity class P (polynomial-time) via logspace reductions [8].\nWe encode the path system problem as a problem over the signature \u03c33++ which\nconsists of the relation symbol R of arity 3 and the constant symbols source and\nsink. A \u03c33++-structure P can be thought of as a path system where the vertices of\nthe path system are given by |P|, the source is given by source, the sink is given by\nsink and the rules of the path system are given by {(x, y, z) : R(x, y, z) holds in P}.\nHence, we define the problem PS as\n{P \u2208 STRUCT(\u03c33++) : the vertex sink is accessible from the vertex\nsource in the path system P}.\nLet us return to increasing the expressibility of FO. Corresponding to the problem\nPS is an operator of the same name. The logic (\u00b1PS)\u2217[FO], or path system logic, is\nthe closure of FO under the usual first-order connectives and quantifiers and also the\noperator PS, with PS applied as follows.\nGiven a formula \u03d5(x,y, z) \u2208 (\u00b1PS)\u2217[FO] over some signature \u03c3, where the vari-\nables of the k-tuples x, y and z, for some k \u2265 1, are all distinct and free in \u03d5, the\nformula \u03a6 defined as PS[\u03bbx,y, z\u03d5](u,v), where u and v are k-tuples of (not neces-\nsarily distinct) constant symbols and variables, is also a formula of (\u00b1PS)\u2217[FO]. The\n4\nfree variables of \u03a6 are those variables in u and v together with the free variables of \u03d5\ndifferent from those in the tuples x, y and z. If \u03a6 is a sentence then it is interpreted\nin a structure A \u2208 STRUCT(\u03c3) as follows. We build a path system with vertex set\n|A|k and set of rules\n{(a,b, c) \u2208 |A|k \u00d7 |A|k \u00d7 |A|k : \u03d5(a,b, c) holds in A},\nand say that A |= \u03a6 if, and only if, the sink v is accessible in this path system from the\nsource u (the semantics can easily be extended to arbitrary formulae of (\u00b1PS)\u2217[FO]:\nsee, for example, [13] for a more detailed semantic definition of operators such as\nPS). Note that there is nothing special about the problem PS: any problem can be\nconverted into an operator and used to extend first-order logic. Syntactically, such\nlogics are very similar although their semantics depend on the operator in hand.\nIt is indeed the case that we have increased expressibility as we can define problems\nin (\u00b1PS)\u2217[FO] which can not be defined in FO (a simple Ehrenfeucht-Fra\u00a8\u0131sse\u00b4 game\nshows that PS is not definable in FO: see [13] for more on such games). In the\npresence of a built-in successor relation, we can obtain a precise complexity-theoretic\ncharacterisation of the problems definable in (\u00b1PS)\u2217[FO]. We say that we have a built-\nin successor relation if no matter over which signature we happen to be working, there\nis always a binary relation symbol succ and two constant symbols 0 and max available\nsuch that this relation symbol succ is always interpreted as a successor relation, of the\nform {(a0, a1), (a1, a2), . . . , (an\u22122, an\u22121)}, in a structure of size n, where all the ai\u2019s\nare distinct and a0 = 0 and an\u22121 = max. Note that whether a structure satisfies a\nsentence, in which the relation symbol succ or the constant symbols 0 or max appear,\nmight depend upon the particular successor relation chosen as the interpretation for\nsucc. Consequently, we only consider those sentences of (\u00b1PS)\u2217[FO] with a built-in\nsuccessor relation that define problems as being well-formed; that is, those sentences\nfor which satisfaction is independent of the particular interpretation chosen for succ.\nWe denote the logic (\u00b1PS)\u2217[FO] with a built-in successor relation by (\u00b1PS)\u2217[FOs]\n(and adopt a similar notation for other logics). As to whether (\u00b1PS)\u2217[FOs] should\nreally be called a logic is highly debatable (for example, it is undecidable as to whether\na sentence of (\u00b1PS)\u2217[FOs] is order-invariant , i.e., satisfies the property we want as\nregards succ, and so this \u2018logic\u2019 does not have a recursive syntax) and the reader is\nreferred to [13] and [34] for a detailed discussion of this and related points. However,\nit turns out that a problem is in the complexity class P if, and only if, it can be\ndefined by a sentence of (\u00b1PS)\u2217[FOs] [40].\nOur notation for (\u00b1PS)\u2217[FO] is such that \u00b1 denotes the fact that applications\nof the operator PS can appear within the scope of negation signs and \u2217 denotes the\nfact that we are allowed to nest applications of PS as many times as we like. The\nfragment (\u00b1PS)k[FO], for some k \u2265 1, is obtained by allowing at most k nestings of\napplications of PS, and the fragment PSk[FO] is obtained by further disallowing any\napplication of PS to appear within the scope of a negation sign.\nIn [40], it was shown that there is a very restricted normal form for sentences of\nPS1[FOs]. This normal form is such that any problem in P = (\u00b1PS)\u2217[FOs] can be\ndefined by a sentence of PS1[FOs] of the form\nPS[\u03bbx,y, z\u03d5(x,y, z)](0,max),\nwhere: x, y and z are k-tuples of distinct variables, for some k \u2265 1; \u03d5 is a quantifier-\n5\nfree formula of FOs; and 0 and max are k-tuples consisting of the constant symbols 0\nand max repeated k times, respectively. (Note that in the absence of built-in relations,\nthe hierarchy\nPS1[FO] \u2282 PS2[FO] \u2282 . . .\nis proper [20].)\nSaying that any problem in P can be described by a sentence of the above normal\nform is equivalent to saying that there is a quantifier-free first-order translation with\nsuccessor from any problem in P to the problem PS; that is, PS is complete for P\nvia quantifier-free first-order translations with successor. The reader is referred to\n[13] for more on logical translations where they go under the name of logical inter-\npretations. However, in [13] logical translations involving only relational signatures\nare considered. If the target problem of a logical translation, PS above, is over a\nsignature containing constant symbols then we assume that such constant symbols\nare specified by an appropriate tuple of other constant symbols (as is the case in\nthe normal form result above where the constant symbols source and sink of \u03c33++\nare specified by the k-tuples 0 and max, respectively). Naturally, we have notions\nsuch as a quantifier-free first-order translation (where succ and 0 and max are not\ninvolved) and a quantifier-free first-order translation with 2 constants (where there\nare two built-in constants, which are always interpreted differently, but no built-in\nsuccessor relation), and we can have logical translations involving formulae of other\nlogics, not just quantifier-free first-order formulae.\nA number of extensions of FO using operators corresponding to some problem \u2126\nhave been studied, as indeed has the whole notion of using such operators to extend\nFO. For example: numerous complexity classes have been \u2018captured\u2019 by (fragments\nof) logics of the form (\u00b1\u2126)\u2217[FO] (sometimes in which there are built-in relations)\nand a variety of problems have been shown to be complete for different complexity\nclasses via different logical translations (see, for example, the papers [19, 25, 36, 37]\nand the references therein); proper infinite hierarchies have been established in logics\nof the form (\u00b1\u2126)\u2217[FO] (see, for example, [2, 20, 21]); logics of the form (\u00b1\u2126)\u2217[FO]\nhave been shown to have zero-one laws [12] (we shall talk about zero-one laws for\nsuch logics in more detail later); and it has been shown that if there is a logic for P\n(where \u2018logic\u2019 is as in [13] and [34]) then there is a logic for P of the form (\u00b1\u2126)\u2217[FO]\n[11].\n2.3 Program schemes\nAn alternative and more computational means for defining classes of problems is\nto use program schemes. A program scheme \u03c1 \u2208 NPSA(1) involves a finite set\n{x1, x2, . . . , xk} of variables, for some k \u2265 1, and is over a signature \u03c3. It con-\nsists of a finite sequence of instructions where each instruction, apart from the first\nand the last, is one of the following:\n\u2022 an assignment instruction of the form \u2018xi := y\u2019, where i \u2208 {1, 2, . . . , k} and\nwhere y is a variable from {x1, x2, . . . , xk}, a constant symbol of \u03c3 or one of the\nspecial constant symbols 0 and max which do not appear in any signature;\n\u2022 an assignment instruction of the form \u2018xi := A[y1, y2, . . . , yd]\u2019 or \u2018A[y1, y2, . . . ,\nyd] := y0\u2019, for some i \u2208 {1, 2, . . . , k}, where each yj is a variable from {x1, x2,\n6\n. . . , xk}, a constant symbol of \u03c3 or one of the special constant symbols 0 and\nmax which do not appear in any signature, and where A is an array symbol of\ndimension d;\n\u2022 a guess instruction of the form \u2018GUESS xi\u2019, where i \u2208 {1, 2, . . . , k}; or\n\u2022 a while instruction of the form \u2018WHILE \u03d5 DO \u03b11;\u03b12; . . . ;\u03b1q OD\u2019, where \u03d5 is\na quantifier-free formula of FO(\u03c3 \u222a {0,max}), whose free variables are from\n{x1, x2, . . . , xk}, and where each of \u03b11, \u03b12, . . . , \u03b1q is another instruction of one\nof the forms given here (note that there may be nested while instructions).\nThe first instruction of \u03c1 is \u2018INPUT(x1, x2, . . . , xl)\u2019 and the last instruction is\n\u2018OUTPUT(x1, x2, . . . , xl)\u2019, for some l where 1 \u2264 l \u2264 k. The variables x1, x2, . . . , xl\nare the input-output variables of \u03c1, the variables xl+1, xl+2, . . . , xk are the free vari-\nables of \u03c1 and, further, any free variable of \u03c1 never appears on the left-hand side of an\nassignment instruction nor in a guess instruction. Essentially, free variables appear\nin \u03c1 as if they were constant symbols.\nA program scheme \u03c1 \u2208 NPSA(1) over \u03c3 with s free variables, say, takes a \u03c3-\nstructure A and s additional values from |A|, one for each free variable of \u03c1, as input;\nthat is, an expansion A\u2032 of A by adjoining s additional constants. The program\nscheme \u03c1 computes on A\u2032 in the obvious way except that:\n\u2022 execution of the instruction \u2018GUESS xi\u2019 non-deterministically assigns an element\nof |A| to the variable xi;\n\u2022 the constants 0 and max are interpreted as two arbitrary but distinct elements\nof |A|; and\n\u2022 initially, every input-output variable and every array element is assumed to have\nthe value 0.\nNote that throughout a computation of \u03c1, the value of any free variable does not\nchange. The expansion A\u2032 of the structure A is accepted by \u03c1, and we write A\u2032 |= \u03c1,\nif, and only if, there exists a computation of \u03c1 on this expansion such that the output-\ninstruction is reached with all input-output variables having the value max. (We can\neasily build the usual \u2018if\u2019 and \u2018if-then-else\u2019 instructions using while instructions: see,\nfor example, [38]. Henceforth, we shall assume that these instructions are at our\ndisposal.)\nWe want the sets of structures accepted by our program schemes to be problems,\ni.e., closed under isomorphism, and so we only ever consider program schemes \u03c1 where\na structure is accepted by \u03c1 when 0 and max are given two distinct values from the\nuniverse of the structure if, and only if, it is accepted no matter which pair of distinct\nvalues is chosen for 0 and max. Let us reiterate: when we say that \u03c1 is a program\nscheme of NPSA(1) we mean that \u03c1 accepts a problem and the acceptance of any\ninput structure does not depend upon the pair of distinct values we give to 0 and\nmax. This is analogous to how we build a successor relation or 2 constant symbols\ninto a logic. Indeed, we can build a successor relation into our program schemes of\nNPSA(1) so as to obtain the class of program schemes NPSAs(1). As with our logics,\nwe write NPSA(1) and NPSAs(1) to also denote the class of problems accepted by\nthe program schemes of NPSA(1) and NPSAs(1), respectively. It was proven in [38]\n7\nthat a problem is in the complexity class PSPACE (polynomial-space) if, and only\nif, it is in NPSAs(1).\nHenceforth, we think of our program schemes as being written in the style of\na computer program. That is, each instruction is written on one line and while\ninstructions (and, similarly, if and if-then-else instructions) are split so that \u2018WHILE\n\u03d5 DO\u2019 appears on one line, \u2018\u03b11\u2019 appears on the next, \u2018\u03b12\u2019 on the next, and so on (of\ncourse, if any \u03b1i is a while, if or if-then-else instruction then it is split over a number of\nlines in the same way). The instructions are labelled 1, 2, and so on, according to the\nline they appear on. In particular, every instruction is considered to be an assignment,\na guess or a test. An instantaneous description (ID) of a program scheme on some\ninput consists of a value for each variable, the number of the instruction about to be\nexecuted and values for all array elements. A partial ID consists of just a value for\neach variable and the number of the instruction about to be executed. One step in a\nprogram scheme computation is the execution of one instruction, which takes one ID\nto another, and we say that a program scheme can move from one ID to another if\nthere exists a sequence of steps taking the former ID to the latter.\n3 Complete problems\nWe begin by examining the class of problems NPSA(1) and we show that this class\nhas a complete problem via quantifier-free first-order translations with 2 constants.\nThis problem, which to our knowledge has not been studied before, is also shown to\nbe complete for PSPACE via quantifier-free first-order translations with successor.\nDefinition 1 Let the signature \u03c3TR = \u3008E,P, T, C,D\u3009, where E is a binary relation\nsymbol, P and T are unary relation symbols and C and D are constant symbols.\nWe can envisage any \u03c3TR-structure A as a digraph (possibly with self-loops) whose\nedge relation is E and with distinguished vertices C, the source, and D, the sink .\nThe relation P can be seen as providing a partition of the vertices and the relation\nT a subset of the vertices upon which tokens are initially placed. All tokens are\nindistinguishable and any vertex has upon it at most one token. Let us call a \u03c3TR-\nstructure A a token digraph.\nJust as one can traverse a path in a digraph by moving along edges, so one can\ntraverse a path in a token digraph A. However, as to how edges can be traversed is\ndifferent from the usual notion. Consider an edge (u, v) \u2208 E for which both u and\nv are in P and such that a traveller is at vertex u (the traveller traverses a path of\nedges in the digraph). The edge (u, v) can only be traversed by the traveller moving\nas follows.\n\u2022 The traveller moves from u via the edge (u, u\u2032) to a vertex u\u2032 not in P upon\nwhich exactly one token resides;\n\u2022 then from u\u2032 via the edge (u\u2032, v\u2032) to a vertex v\u2032 not in P upon which no token\nresides, if v\u2032 6= u\u2032, and at the same time taking the token previously at u\u2032 to v\u2032,\nor by moving from u\u2032 via the edge (u\u2032, u\u2032) (if it exists) to u\u2032 (so that the token\nremains at u\u2032); and finally\n\u2022 by moving from the vertex v\u2032 or u\u2032, whichever is the case, via the edge (v\u2032, v)\nor (u\u2032, v) to v.\n8\n"}