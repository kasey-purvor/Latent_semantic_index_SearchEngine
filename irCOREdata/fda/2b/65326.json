{"doi":"10.1007\/11768173_6","coreId":"65326","oai":"oai:dro.dur.ac.uk.OAI2:6216","identifiers":["oai:dro.dur.ac.uk.OAI2:6216","10.1007\/11768173_6"],"title":"Constructing property-oriented models for verification.","authors":["He, J.","Qin, S.","Sherif, A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Dunne, S.","Stoddart, B."],"datePublished":"2006-02-01","abstract":"This paper advocates a general approach to formal verification by constructing property-oriented models. We instantiate the approach using timing properties, and construct a heterogeneous untimed model in which time is abstracted away, so that we can verify timing properties in an untimed framework. The correctness of property-oriented model construction is ensured by the conformance of semantic and syntactic mappings","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65326.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6216\/1\/6216.pdf","pdfHashValue":"1d92ab3e915ff047a5822936506b6ab1fa3a14d3","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6216<\/identifier><datestamp>\n      2015-03-31T11:55:35Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Constructing property-oriented models for verification.<\/dc:title><dc:creator>\n        He, J.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Sherif, A.<\/dc:creator><dc:description>\n        This paper advocates a general approach to formal verification by constructing property-oriented models. We instantiate the approach using timing properties, and construct a heterogeneous untimed model in which time is abstracted away, so that we can verify timing properties in an untimed framework. The correctness of property-oriented model construction is ensured by the conformance of semantic and syntactic mappings.<\/dc:description><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Dunne, S. & Stoddart, B. (Eds.). (2006). Unifying theories of programming : first international symposium, UTP 2006, Walworth Castle, County Durham, UK, February 5-7, 2006 : revised selected papers. Berlin: Springer, pp. 85-100, Lecture notes in computer science(4010)<\/dc:source><dc:contributor>\n        Dunne, S.<\/dc:contributor><dc:contributor>\n        Stoddart, B.<\/dc:contributor><dc:date>\n        2006-02-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6216<\/dc:identifier><dc:identifier>\n        doi:10.1007\/11768173_6<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6216\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/11768173_6<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6216\/1\/6216.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/11768173_6<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2006,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nHe, J. and Qin, S. and Sherif, A. (2006) \u2019Constructing property-oriented models for verification.\u2019, in Unifying\ntheories of programming : first international symposium, UTP 2006, Walworth Castle, County Durham, UK,\nFebruary 5-7, 2006 : revised selected papers. Berlin: Springer, pp. 85-100. Lecture notes in computer science.\n(4010).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/117681736\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nHe, J. and Qin, S. and Sherif, A. (2006) 'Constructing property-oriented models for \nverification.', in Unifying theories of programming : first international symposium, UTP 2006, \nWalworth Castle, County Durham, UK, February 5-7, 2006 : revised selected papers. Berlin: \nSpringer, pp. 85-100. Lecture notes in computer science. (4010). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/11768173_6 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nConstructing Property-Oriented Models for Verification\nHe Jifeng1\u22c6, Shengchao Qin2\u22c6\u22c6, and Adnan Sherif3\n1 Software Engineering Institute, East China Normal University\njifeng@sei.ecnu.edu.cn\n2 Department of Computer Science, Durham University\nshengchao.qin@durham.ac.uk\n3 Centro de Informatica, Federal University of Pernambuco\nAbstract. This paper advocates a general approach to formal verification by\nconstructing property-oriented models. We instantiate the approach using tim-\ning properties, and construct a heterogeneous untimed model in which time is\nabstracted away, so that we can verify timing properties in an untimed frame-\nwork. The correctness of property-oriented model construction is ensured by the\nconformance of semantic and syntactic mappings.\n1 Introduction\nIt has been noticed that a single software development method is not sufficient to solve\nall types of problems found in complex software systems. The integration of software\ndevelopment methods has been proposed and investigated in the recent years, for exam-\nple, the integration of state-modeling and process languages has become an active area\nof research ( [19, 6, 1, 11]). Such blending of different notations can provide us more\npowerful languages for specifying very complex software systems. Unified observation-\noriented models behind the integrated languages (like [14], [23]) can ensure the sound-\nness of the integration of different notations, and can be used as a reference document\nfor developing tool supports. However, such complete models are usually very compli-\ncated and thus hard to use for the verification purpose.\nProperties to be verified or analysed can be divided into different categories, each\nkind of properties only refer to part of the whole observation model, such as safety prop-\nerties that are not time dependent, timing properties, deadlock-free properties. Recent\nwork [4] suggests a projection approach to the verification of timing properties. The\nprojection can be conducted in a syntax-directed manner, where the soundness proof\nreplies on a deep projection from the whole model to the sub-model, thus the whole\nmodel should be built first, which is usually very time-consuming. Therefore, we pro-\npose to construct (small) property-oriented models for the verification of any particular\nkind of properties. We shall guarantee that different property-oriented sub-models can\nbe integrated into the whole model in a later stage, where necessary. In this paper, we\nelaborate this general idea using timing properties. We construct an untimed hetero-\ngeneous model, where time information is abstracted away, and handled by a special\n\u22c6 Supported in part by China 973 Project 2002CB312001.\n\u22c6\u22c6 Author for Correspondence. Supported in part by China NNSFC Project 60573081.\nTimer process. With such a property-oriented model we can verify certain kind of tim-\ning properties using the simpler untimed model, either by model checking or theorem\nproving. This greatly simplifies the verification process.\nWe demonstrate our approach using a small language CZ, which is a subset of the\ncombination of CSP [7] and Z [20]. It can be regarded as a subset of the Circus [21]\nlanguage, or a subset of another powerful specification language TCOZ [11]. We shall\nfocus on timing properties that can be described in programming languages, rather than\nspecification languages, like:\n\u2013 the delay between two consecutive events should at least be t units of time;\n\u2013 a program awaits an event at most t units of time before it does something else.\nMore general timing properties that can be described in specification languages but\ndifficult in programming languages, like deadline and waituntil in TCOZ, will not be\ncovered here.\nThis paper makes the following contributions:\n\u2013 We propose a general approach to verification by constructing property-oriented\nmodels for integrated formal languages.\n\u2013 We demonstrate our approach in terms of timing properties. We build an untimed\nmodel for the verification of real-time properties.\n\u2013 We build a deep link between timed traces and untimed heterogeneous traces (with\ntimer events). From that, we can generate the provably-correct untimed model.\n\u2013 We illustrate our approach through an alarm controller example.\nThe rest of the paper is organized as follows. Section 2 introduces the illustrative\nexample. Section 3 describes the language model. The approach is presented in detail\nin Section 4, followed by related work and conclusion.\n2 An Illustrative Example\nIn this section, we use a small example to illustrate a novel approach to the verification\nof timing properties for reactive systems.\n2.1 The Alarm Controller\nThe alarm system was first used in [9]. The system is a common alarm controller that\ncan be found in buildings and cars. The controller is connected to a sensor which detects\nmovements or changes in the environment monitored by the alarm. The controller oper-\nates in two modes: when disabled, it will ignore any disturbance detected by the sensor;\nwhen enabled, the controller will sound an alarm when the sensor signals a disturbance.\nThere are two timing requirements on the alarm controller: the first states that after\nthe controller is enabled, there is a period of t1 units of time before a disturbance can\ncause the alarm to ring. The period t1 permits a person to enable the alarm and then\nleave without causing it to sound. The second requirement states that when a detected\ndisturbance is received, the controller will wait for another period of t2 units of time\nbefore activating the alarm. The period t2 leaves some time to the legal user to disable\nit before it sounds.\nLet us analyse the first timing requirement, that is, when the controller is enabled,\nthere is a delay of t1 units of time before it can receive any disturbance from its sensor.\nAs a first attempt, we can specify this requirement in terms of the following action:\nR1 =\u0302 enable \u2192 Wait t1; disturb \u2192 R\nNotice the event enable indicates the alarm system is enabled, while the event disturb\ndenotes a disturbance detected by the sensor. At this moment, we ignore the subsequent\nbehaviour after a disturbance is received and simply use R to denote it.\nThe key idea of our approach is to separate timing properties from logical properties\nby introducing a specific component, called Timer, to take care of the timing features.\nThus we can use existing untimed verification tools like model checkers to verify that\ncertain time properties are met, rather than construct a new tool for verification from\nscratch.\nFor R1, we can transform it to the following untimed action:\nR\u20321 =\u0302 enable \u2192 set! \u2192 reset? \u2192 disturb \u2192 R\nThe two new events set and reset are used to interact with the following Timer action:\nTimer =\u0302 set? \u2192 Wait t1; reset! \u2192 Skip\nNote that the Timer component is in charge of time control. It is activated by set signal,\nand after t1 time elapses, it notifies the process R\u20321 via signal reset.\nTo verify R1 meets the property that a disturbance can only be received after the\ncontroller is enabled for t1 units of time (we refer to it as t1-delay property in what\nfollows), we only need to check the following untimed property for R\u20321:\n\u2200utr0, utr1, utr2 \u00b7 ((utr = utr0 a \u3008enable\u3009a utr1 a \u3008disturb\u3009a utr2 \u2227\nutr1 \u21be {enable, disturb} = \u3008\u3009) \u21d2 utr1 = \u3008set, reset\u3009)\nIt states that there are only two timer events set and reset between an enable event and its\nconsecutive disturb event. The event set activates the timer, while reset deactivates the\ntimer, which indicates t1 time is passed. Together with the timer action, it ensures the\nt1-delay property. Note that utr denotes the (untimed) trace, i.e. a sequence of events,\nwhile utri\u2019s are segments of the trace. Formal definitions will be given in a later section.\nThe soundness for the separation of timing features from logical features can be\nspecified in terms of the following equation:\nR1 = (R\u20321|[{set, reset}]|Timer)\\{set, reset}\nThis can be easily proved using the expansion laws for parallel composition. The right\nhand side is a parallel composition of an untimed action (R\u20321) and a timer action (Timer)\nwhich communicate with each other via two internal events set and reset (hidden from\noutside). Such a parallel composition is the normal form we shall adopt for verification.\n2.2 The Normal Form\nIn this subsection, we shall deal with the complete specification for the alarm controller.\nThe complete timed specification for the alarm controller is given as follows.\nDisable =\u0302 disable \u2192 Skip\nRunning =\u0302 Disable 2 (disturb \u2192 Active)\nActive =\u0302 Disable\nt2\n\u0003 (alarm \u2192 Disable)\nAlarm =\u0302 \u00b5X \u2022 enable \u2192 (Disable t1\u0003Running); X\nNote that event disable is used to disable the controller, event alarm signals the firing\nof the alarm. For more flexibility, we allow the controller to be disabled at any point\nduring running. We use timeout constructs (defined later in Section 3.2) to capture this\nrequirement. Take Alarm as an example, once the controller is enabled, it is either dis-\nabled (and then waits for enable again), or is ready to receive any disturbance after t1\n(Running).\nAs explained in last subsection, we shall transform the timed specification Alarm to\na normal form composed of an untimed specification in parallel with a Timer action.\nWe shall use function \u03a6 to abstract away timing features from a timed action. The\ncomplete definition for \u03a6 will be given when we present the syntax of the language.\nThe following is the result after applying it to the above specification.\n\u03a6(Disable) =\u0302 disable \u2192 Skip\n\u03a6(Running) =\u0302 \u03a6(Disable) 2 (disturb \u2192 \u03a6(Active))\n\u03a6(Active) =\u0302 set!t2 \u2192\n((disable \u2192 halt! \u2192 Skip) 2 (reset? \u2192 alarm \u2192 \u03a6(Disable)))\n\u03a6(Alarm) =\u0302 \u00b5X \u2022 enable \u2192 set!t1 \u2192\n((disable \u2192 halt! \u2192 Skip) 2 (reset? \u2192 \u03a6(Running))); X\nNote that a new timer event halt is used to stop the timer when event disable arrives\nduring the ticking of the clock. There are two timing requirements in the specification,\nthus we design the general timer action as follows:\nTimer =\u0302 \u00b5X \u2022 set?x\u2192 ((halt? \u2192 Skip) 2 (Wait x; reset! \u2192 Skip)); X\nNote that when the timer is set to work, a value is passed to it (stored in x) to indicate\nthe time duration that it should count before it generates a reset signal.\nNow the timed specification Alarm is transformed to the following normal form:\n(\u03a6(Alarm)|[{set, reset, halt}]|Timer)\\({set, reset, halt}\nThe following theorem ensures the soundness of the abstraction.\nTheorem 1. We have\nAlarm = (\u03a6(Alarm)|[{set, reset, halt}]|Timer)\\{set, reset, halt}\nIt is proved using parallel expansion and hiding laws.\n2.3 Verification of Timing Properties in the Untimed Model\nIn this subsection we shall demonstrate that timing requirements can be verified in the\nuntimed framework.\nThere are two timing requirements for the alarm controller, namely,\n\u2013 once enabled, the controller should wait at least t1 units of time before it can receive\nany disturbance from the sensor.\n\u2013 once a disturbance is received, the controller should wait at least t2 units of time\nbefore it fires the alarm.\nAs timing is controlled by the timer actions in our normal form, we can abstract\naway timing from the above requirements by adding in timer events that are in charge of\nactivating\/deactivating the timers. The timing requirements are thus specified in terms\nof timer events as follows:\nR1(utr) =\u0302 \u2200utr0, utr1, utr2 \u00b7 (utr = utr0 a \u3008enable\u3009a utr1 a \u3008disturb\u3009a utr2 \u2227\nutr1 \u21be {enable, disturb} = \u3008\u3009) \u21d2 (utr1 = \u3008set.t1, reset\u3009)\nR2(utr) =\u0302 \u2200utr0, utr1, utr2 \u00b7 (utr = utr0 a \u3008disturb\u3009a utr1 a \u3008alarm\u3009a utr2 \u2227\nutr1 \u21be {disturb, alarm} = \u3008\u3009) \u21d2 (utr1 = \u3008set.t2, reset\u3009)\nThe overall timing requirement for the alarm controller is thus as below:\nReq(utr) =\u0302 R1(utr) \u2227 R2(utr)\nTo verify the timed specification (Alarm) meets the timing requirements, we only\nneed to demonstrate that the untimed specification (\u03a6(Alarm)) meets the above require-\nment, that is, \u03a6(Alarm) \u21d2 Req(utr).\nTheorem 2. Suppose \u03a6(Alarm) and Req(utr) are given as above, we have\n|[\u03a6(Alarm)]| \u21d2 Req(utr)\nwhere |[P]| denotes the observation-oriented semantics for program P.\nProof From the definition of \u03a6(Alarm),\n\u03a6(Alarm) = P;\u03a6(Alarm)\nwhere P =\u0302 enable \u2192 set!t1 \u2192 ((disable \u2192 halt! \u2192 Skip) 2 (reset? \u2192 \u03a6(Running))).\nThus the semantic predicate |[\u03a6(Alarm)]| is subject to\n|[\u03a6(Alarm)]| = |[P]|; |[\u03a6(Alarm)]|\nThat is, it is the fixed point of the equation X = \u00b5X \u00b7 (|[P]|; X).\nNote that we also use the operator (;) to represent the concatenation of two obser-\nvational predicates. The formal definition is given in [8].\nDue to the following fixed point theorem ([8]):\nF(S) \u2292 S implies \u03bdX \u00b7 F(S) \u2292 S\nand the fact that there is only one fixed point in this case, we only need to prove\n|[P]|; Req(utr) \u21d2 Req(utr)\nIt is thus straightforward as all possible traces of P lie in the following set:\ntrace(P) = {\u3008enable, set.t1, disable\u3009, \u3008enable, set.t1, disable, halt\u3009,\n\u3008enable, set.t1, reset, disable\u3009, \u3008enable, set.t1, reset, disturb, set.t2, disable\u3009,\n\u3008enable, set.t1, reset, disturb, set.t2, disable, halt\u3009}\n\u222a {utr | utr \u0016 \u3008enable, set.t1, reset, disturb, set.t2, reset, alarm, disable\u3009}\n2\nNote that the proof is much simpler and more straightforward in comparison with\nthe existing proof given in [9] due to the property-oriented model we use.\n3 The Language\nThis section introduces our language CZ that we use to instantiate our method. We\nshall give both the untimed and timed models.\n3.1 The Untimed Model\nThe syntax for CZ is given in Fig. 1.\nAction ::= Skip | Stop | Chaos\n| Communication \u2192 Action | b&Action\n| Action; Action | Action2Action | Action \u2293 Action\n| Action|[E]|Action | Action\\E | \u00b5X \u2022 Action\n| Command\nCommand ::= x := e | Action\u0001 b\u0003 Action\nCommunication ::= c?[x] | c![e] | c[.e]\nFig. 1. CZ : the untimed model\nNote that e represents an expression, while b a boolean expression. The set E denotes\nchannel names. The notation [u] indicates that term u is optional.\nSkip is a basic action that terminates immediately. Stop represents an abnormal ter-\nmination which simply puts a program in an ever waiting state. Chaos is the worst\naction, nothing can be said about its behaviour. In a guarded action (b&Action), the\naction is preceded by a predicate which has to be true for the action to take place, oth-\nerwise the guarded action behaves as Stop. An internal choice between two actions\n(Action\u2293Action) selects one of the two actions in a non-deterministic manner, whereas\nthe external choice (Action2Action) waits for any of the two actions to interact with the\nenvironment. The first action that interacts with the environment (either by synchronis-\ning on an event or terminating) is the resulting action.\nThe sequential composition of two actions (Action; Action) behaves as the first ac-\ntion, followed immediately by the second action upon termination of the first. An action\ncan be prefixed with a communication event (input or output) which will take place be-\nfore the action starts. The action waits for the other actions that need to synchronise on\nthe channel before the communication can take place. The parallel composition of two\nactions (Action|[cs]|Action) involves a set (cs) containing the events they need to syn-\nchronise on. A hiding operation also takes a set of events (cs). The set is to be excluded\nfrom the resulting observation of the action, hidden events can no longer be seen by\nother actions.\nAn observation-oriented model for the Circus language based on Hoare and He\u2019s\nUnifying Theories of Programming [8] is explored in detail in [23, 21], while the unified\nmodel for TCOZ is reported in [14]. As our language CZ is a subset of the above two\nlanguages, we can borrow the following observation variables from them.\n\u2013 ok, ok\u2032 : Boolean. When ok is true, it states that the program has started and ok\u2032 =\ntrue indicates that the program has terminated or is in an intermediate stable state.\n\u2013 wait,wait\u2032 : Boolean. When wait is true, the program starts in an intermediate state.\nWhen wait\u2032 is true the program has not terminated; when it is false, it indicates a\nfinal observation.\n\u2013 state, state\u2032 are mappings from program variable names to values. The undashed\nvariable represents the initial valuation of the program variables, while the dashed\none denotes the valuation at the final observation.\n\u2013 utr, utr\u2032 : seq Event are the sequence of observations on the program\u2019s interactions\nwith its environment. utr denotes the observations that occur before the program\nstarts, and utr\u2032 the final observation. Each element of the sequence is an event.\n\u2013 ref, ref\u2032 : PEvent stands for the set of events the program can refuse.\nA single observation is given by the combination of the above variables. A program\nis given as predicates over the observation variables. We give the semantics for basic ac-\ntions and communication events in what follows to show the use of the above semantic\nvariables. Readers can refer to [23, 14] for the complete set of semantic definitions.\nBasic Action The semantics of the action Skip is given as a program that can only\nterminate normally and has no interaction with the environment.\n|[Skip]| =\u0302 ok\u2032 \u2227 \u00acwait\u2032 \u2227 utr\u2032 = utr \u2227 state\u2032 = state\nThe action Stop is given as a predicate that waits for ever; it does not change the\nstate.\n|[Stop]| =\u0302 ok\u2032 \u2227 wait\u2032 \u2227 utr\u2032 = utr\nThe assignment attributes a value to a variable in the current state. If the variable\ndoes not exist it will be added, otherwise its value will be over written. The assignment\noperation is instantaneous and does not consume time.\n|[x := e]| =\u0302 ok\u2032 \u2227 \u00acwait\u2032 \u2227 utr\u2032 = utr \u2227 state\u2032 = state \u2295 {x 7\u2192 e}\nNote that we abuse the same e in the right hand side to denote the value of e in state.\nCommunication An action can engage in a communication if all the other actions\ninvolved in the same communication are ready to do so. We model this with the help\nof two predicates. wait com(c) models the waiting state of an action to communicate\non channel c. The only possible observation is that the communication channel cannot\nappear in the refusal set during the observation period. term com(c.e) represents the act\nof communicating a value e over a channel c.\nwait com(c) =\u0302 ok\u2032 \u2227 wait\u2032 \u2227 c \/\u2208 ref\u2032 \u2227 utr\u2032 = utr\nterm com(c.e) =\u0302 ok\u2032 \u2227 \u00acwait\u2032 \u2227 utr\u2032 = utr a \u3008c\u3009\nThe semantics of the output command is given below.\n|[c!e]| =\u0302 wait com(c) \u2228 term com(c.e) \u2227 state\u2032 = state\nThe input command can be defined in a similar manner.\n|[c?x]| =\u0302 wait com(c) \u2228 term com(c.e) \u2227 state\u2032 = state\u2295 {x 7\u2192 e}\nThe semantics of the communication prefix can be given in terms of communication\nand of the sequential composition. The action comm is either an input or an output event,\nor an abstract event name.\n|[comm \u2192 Action]| =\u0302 |[comm; Action]|\n3.2 The Timed Model\nThe timed language TCZ extends the untimed language CZ with two new time operators\ngiven in Fig. 2.\nAction ::= \u00b7 \u00b7 \u00b7\n| Wait t (time delay)\n| Action\nt\n\u0003Action (timeout)\nFig. 2. TCZ: the timed model\nThe action (Wait t) will delay the system for an amount of time determined by\nthe positive integer expression t before terminating normally. The timeout construct\n(Action\nt\n\u0003Action) takes a positive integer value as the length of the timeout. The timeout\noperator acts as a time guarded choice. It behaves as either the first or the second action.\nIf the first action performs an observable event or terminates before the specified time\nelapses, it is chosen. Otherwise, the first action will be suspended and the only possible\nobservations are those produced by the second action.\nThe semantics for the timed language is given with the same observation variables\nok, ok\u2032,wait,wait\u2032, state and state\u2032, while the variables utr, utr\u2032 and ref\u2032 are replaced by\na new pair of variables ttr, ttr\u2032 denoting communication traces in the timed model.\nThe variable ttr records the observations of communication events that occur before\nthe program starts, and ttr\u2032 records the final observation. Each element of the sequence\nrepresents an observation in one time unit. Each observation element is composed of\na tuple, where the first element of the tuple is the sequence of events that occur in the\ntime unit, and the second is the associated set of refusals at the end of the same time\nunit.\nttr, ttr\u2032 : seq(seq Event\u00d7 PEvent)\nWe maintain an auxiliary variable utr that represents a sequence of events that have\noccurred since the last observation. In this observation we are interested in recording\nonly the events without time.\nutr : seq Event\nutr = flat(ttr\u2032)\u2212 flat(ttr)\nwhere flat : seq(seq Event\u00d7 PEvent) \u2192 seq Event\nflat(\u3008\u3009) = \u3008\u3009\nflat(\u3008el, ref\u3009a S) = el a flat(S)\nWe show the use of these new variables in the definition of the (Wait d) action. The\nonly possible behaviour for this action is to wait for the specified number of units of\ntime to pass before terminating immediately.\n|[Wait d]|time =\u0302 ((ok\u2032 \u2227 wait\u2032 \u2227 (#ttr\u2032 \u2212 #ttr) < d)\n\u2228(ok\u2032 \u2227 \u00acwait\u2032 \u2227 (#ttr\u2032 \u2212 #ttr) = d)) \u2227 utr = \u3008\u3009\nThe timeout action can be defined in terms of external choice as in [17]. The fol-\nlowing is a direct definition.\n|[P t\u0003Q]|time =\u0302 (P \u2227 utr = \u3008\u3009 \u2227 #ttr\u2032\u2212#ttr \u2264 t)\u2228\n(\u2203k : #ttr < k \u2264 #ttr+t, \u2203t\u02dctr \u2022 pi1(ttr\u2032(k)) 6= \u3008\u3009 \u2227 ttr \u0016 t\u02dctr \u2227 #t\u02dctr\u2212#ttr = k\u2227\n(\u2200i : #ttr < i < #ttr+k \u2022 pi1(ttr\u2032(i)) = \u3008\u3009 \u2227 t\u02dctr(i) = ttr\u2032(i)) \u2227 P[t\u02dctr\/ttr]) \u2228\n(\u2203t\u02dctr \u2022 ttr \u0016 t\u02dctr \u2227 #t\u02dctr \u2212 #ttr = t\u2227\n(\u2200i : #ttr < i < #ttr+t \u2022 pi1(ttr\u2032(i)) = \u3008\u3009 \u2227 t\u02dctr(i) = ttr\u2032(i)) \u2227 Q[t\u02dctr\/ttr])\nNote that if P is ready to react to the environment exactly when it has waited for\ntime t, the timeout process chooses P or Q non-deterministically.\nGiven the semantic model for a TCZ program, we can use the linking function given\nin [17] to abstract away time information, and thus obtain the corresponding untimed\nmodel. This abstraction is useful when we are interested in the verification of time-\nindependent safety properties. In this paper, we shall not elaborate on this aspect but\nfocus more on timing properties.\n4 The Approach\nThis section is devoted to the general approach that we propose to the verification of\nreal-time systems. The verification framework is given in Fig. 3.\nFig. 3 shows us two different approaches. The first one is a top down approach\nwhere we start with a timed program and we are interested in checking if the timed\nprogram satisfies the time requirements. The second approach is a bottom up method\nT\rC\rz\r \rP\rr\ro\rg\rr\ra\rm\r\nC\rz\r\nP\rr\ro\rg\rr\ra\rm\r\nC\rz\r \rp\rr\ro\rg\rr\ra\rm\r\n+\r \rt\ri\rm\re\rr\r \re\rv\re\rn\rt\rs\r\nT\ri\rm\re\rr\rs\r|\r \r\nA\rb\rs\rt\rr\ra\rc\rt\ri\ro\rn\r N\ro\rr\rm\ra\rl\r \rF\ro\rr\rm\r\nH\ri\rd\ri\rn\rg\r\nS\ra\rf\re\rt\ry\r\nP\rr\ro\rp\re\rr\rt\ri\re\rs\r\nm\re\re\rt\rs\r\nT\ri\rm\ri\rn\rg\r\nP\rr\ro\rp\re\rr\rt\ri\re\rs\r\nm\re\re\rt\rs\r\n1\r\n2\r\n3\r\n4\r\n5\r\nFig. 3. The Property-Oriented Models for Verification\nwhere we start with an untimed program and add time information where requested.\nThe need for the second one is due to the fact that system development is usually done\nin stages, in the early stages of development the system designer concentrates on the be-\nhaviourial\/logical properties of the system, while leaving timing requirement to a later\nstage. Another aspect is that in some cases it is necessary to identify the hardware used\nin the implementation to have a clear understanding of the time delays and timeouts\nthat can occur in the system and the points in which they may occur. In the rest of this\nsection we present our approach in detail.\n4.1 The Validation Approach\nThis approach is concerned with the validation of the time requirements of the system\nusing the untimed model. Fig. 3 illustrates the steps for using the framework. The steps\nto carry out the validation of the time requirements are summarised as follows.\n\u2013 We start with a specification of our system in the timed model using the timed\nversion of the language. The system designer gives a complete description of the\nsystem. All the operators of the language can be used at this stage including parallel\ncomposition The timed semantic model of the language is used in this step.\n\u2013 If we need to verify untimed safety properties, we can use an abstraction function\n(e.g. the one given in [17]) to obtain an untimed version of the original specification.\nSuch an untimed program can be used to validate the behaviour requirements and\nsafety requirements that are not time dependent. We do not elaborate this aspect in\nthis paper.\n\u2013 With the help of the normal form function \u03a6, we obtain a version of the program\nthat has the same semantics as the original program but contains internal timer\nevents. In this step the expansion laws should be used as well to remove all the\nparallel compositions.\n\u2013 Time requirements can be expressed in the untimed model with timer events. We\ncan use this untimed model to prove the design meets the time requirements. This\ncan be done using theorem provers or existing (untimed) model checkers.\n4.2 The Normal Form\nUsually timed programs are implemented with timers, this can be either the system\nclock or a dedicated timer. Following the same criteria we give a normal form for the\ntime operators. The implementation of the time operators is given as a timer and an\nuntimed program that is synchronised with the timer on dedicated events.\nAs mentioned above, the events set, halt, and reset are timer events, used by the\nprogram to synchronise with and control a timer. The following is the timer program:\nTimer =\u0302 \u00b5X \u2022 set?x\u2192 ((halt? \u2192 Skip)2(Wait x; (reset! \u2192 Skip))); X\nThe timer is initiated with the event set which serves as a trigger. The behaviour of the\ntimer is as follows: after set by its environment, it waits for the set signal to set the\ntimer again if an interrupt event halt arrives before the timeout, or it emits a signal reset\nand starts to wait for another set after it has counted for the designated period of time\n(stored in x) set by the environment. The event reset is similar to other events used in\nthe language, whereas the events set and halt have special properties. We shall explore\nthese differences further in the next subsection.\nGiven the definition for a timer action, we aim to generate a function \u03a6 that takes\nas input a timed program and returns the corresponding untimed program with timer\nevents. That is, for any sequential program P, the function\u03a6 should satisfy the following\nequation:\n(\u2020) P = \u03a6(P) par Timer\nGiven actions X and Y, such that \u03b1X \u2229 \u03b1Y = {set, reset, halt},\nX par Y =\u0302 (X |[{set, reset, halt}]| Y)\\{set, reset, halt}\nNote that in the action (X par Y), X behaves as a master action, while Y acts as a slave\naction. The overall action terminates if and only if the master action X terminates.\nAs timers are not allowed to be shared by parallel actions, several timer actions are\nneeded in the equation (\u2020) in case that P is a parallel action.\nWe shall first give a mapping\u03c8 to abstract away time information from timed traces,\nwhile adding timer events properly. This can be regarded as a deep semantic link be-\ntween a timed process and a heterogeneous communicating process. We only need to\ndefine the mapping \u03c8 on maximal traces.\nDefinition 1. A timed trace ttr0 from a prefix-closed trace set is maximal, if for any\ntrace ttr1 that satisfies #ttr0 = #ttr1, and \u2200i : 1..#ttr0 \u00b7 pi1(ttr0(i)) = pi1(ttr1(i)), we\nhave \u2200i : 1..#ttr0 \u00b7 pi2(ttr0(i)) \u2287 pi2(ttr1(i)).\nDefinition 2. Given a set of timed traces TTR, and a single prefix s, we define a set of\ntimed traces \u201cafter\u201d s as follows:\nTTR\/s =\u0302 {ttr | (sa ttr) \u2208 TTR}\nGiven a trace ttr, we use pref(ttr) to denote the prefix-closed set of traces made out\nof all prefixes of ttr. We extend it to a set of traces TTR as\npref(TTR) =\u0302\n\u22c3\n{pref(ttr) | ttr \u2208 TTR}\nGiven two set of traces TTR1, and TTR2, the concatenation of them is given as\nTTR1 a TTR2 =\u0302 {ttr1 a ttr2 | ttri \u2208 TTRi, for i = 1, 2}\nDefinition 3 (Semantic Mapping). Let A denote the maximal set of events of interest,\nand A\u2217 denote the sequence closure over A. Given a set of maximal traces TTR, the\ncorresponding set of heterogeneous traces \u03c8(TTR) is defined as follows:\n\u2013 TTR = {\u3008(\u3008\u221a\u3009,X)\u3009}.\n\u03c8(TTR) =\u0302 {\u3008\u221a\u3009}.\n\u2013 \u2203ttr \u2208 TTR \u00b7 \u2200i : 1\u2264i\u2264#ttr \u00b7 pi1(ttr(i)) = A\u2217 \u2227 pi2(ttr(i)) = A.\n\u03c8(TTR) =\u0302 A\u2217.\n\u2013 \u2200ttr \u2208 TTR \u00b7 \u2200i : 1\u2264i\u2264#ttr \u00b7 pi1(ttr(i)) = \u3008\u3009 \u2227 pi2(ttr(i)) = A.\n\u03c8(TTR) =\u0302 {\u3008\u3009}.\n\u2013 TTR = pref(ttr), where ttr = \u3008(\u3008\u3009,A), .., (\u3008\u3009,A)\u3009, and #ttr = n.\n\u03c8(TTR) =\u0302 pref(\u3008set.n, reset\u3009).\n\u2013 pref(ttr) \u2286 TTR, where ttr = \u3008(\u3008\u3009,A\u2212C), .., (\u3008\u3009,A\u2212C), (\u3008\u3009,A\u2212C\u2212B), (\u3008\u3009,A\u2212B)\u3009,\n#ttr = n+1, and B and C are finite sets of events, C = {c1, .., ck}.\nLet ttri = \u3008(\u3008\u3009,A\u2212C), .., (\u3008\u3009,A\u2212C)\u3009a \u3008(si,Xi)\u3009, where head(si) = ci \u2208 C, for\ni = 1, .., k.\n\u03c8(TTR) =\u0302 pref(\u3008set.n, reset\u3009) \u222a {\u3008set.n, reset\u3009a s | s \u2208 \u03c8(TTR\/ttr)} \u222a\u22c3k\ni=1( pref(\u3008set.n, ci, halt\u3009)\n\u222a{\u3008set.n, ci, halt\u3009a tail(si) a s | s \u2208 \u03c8(TTR\/ttri)})\n\u2013 For other cases, \u03c8(TTR) =\u0302 \u222a {flat(ttr) | ttr \u2208 TTR}.\nWe assume that any sequential action can be written in the guarded normal form\n2\nn\ni=1(ci \u2192 Pi). We construct \u03a6 as follows.\nDefinition 4 (Syntactic Mapping).\n\u03a6(Skip) =\u0302 Skip\n\u03a6(Chaos) =\u0302 Chaos\n\u03a6(Stop) =\u0302 Stop\n\u03a6(x := e) =\u0302 x := e\n\u03a6(b&P) =\u0302 b&\u03a6(P)\n\u03a6(P\u0001 b\u0003 Q) =\u0302 \u03a6(P)\u0001 b\u0003 \u03a6(Q)\n\u03a6(Wait t) =\u0302 set!t\u2192 reset? \u2192 Skip\n\u03a6(2ki=1(ci \u2192 Pi)) =\u0302 21\u2264i\u2264k(ci \u2192 \u03a6(Pi))\n\u03a6(P2Q) =\u0302 \u03a6(P)2\u03a6(Q)\n\u03a6(P \u2293 Q) =\u0302 \u03a6(P) \u2293 \u03a6(Q)\n\u03a6(P; Q) =\u0302 \u03a6(P);\u03a6(Q)\n\u03a6(P\\E) =\u0302 \u03a6(P)\\E\n\u03a6((2ni=1(ci\u2192Pi))\nt\n\u0003Q) =\u0302 set!t\u2192((2ni=1(ci\u2192halt!\u2192\u03a6(Pi))) 2 (reset?\u2192\u03a6(Q)))\n\u03a6(\u00b5X \u20222ni=1(ci \u2192 Pi(X))) =\u0302 \u00b5X \u20222ni=1(ci \u2192 \u03a6(Pi(X)))\nTheorem 3. The syntactic mapping \u03a6 conforms with the semantic mapping \u03c8. That is,\ngiven any program P from TCZ, we have\n\u03c8(|[P]|time) = |[\u03a6(P)]|\nThe proof is straightforward by a structural induction on P.\nTheorem 4. The syntactic mapping \u03a6 is a homomorphic solution to the equation (\u2020).\n4.3 Algebraic Laws\nThe set of processes generated by function \u03a6 are called as heterogeneous communicat-\ning processes (HCP). It can be regarded as an extension of Communicating Sequential\nProcesses (CSP) (if we ignore state features). It enriched CSP with timer events, thus\nis also subject to the healthiness conditions for CSP (Chapter 8 of [8]). However, as\ntimer events have the same behaviour in both synchronous and asynchronous models, it\nsatisfies some additional healthiness conditions. These additional properties will yield a\nsubset of CSP processes. Therefore, although heterogeneous communicating processes\nare an extension of CSP, they can be simulated by a subset of CSP.\nWe shall present the additional properties in what follows.\nHC1 |[P]| \u2227 utr a \u3008set1, set2\u3009 \u0016 utr\u2032 = |[P]| \u2227 utr a \u3008set2, set1\u3009 \u0016 utr\u2032\nIt states that, if a heterogeneous communicating process sets two timers consecutively,\nthen it can set them in any order.\nSimilarly, we have the following healthiness conditions.\nHC2 |[P]| \u2227 utr a \u3008set1, halt2\u3009 \u0016 utr\u2032 = |[P]| \u2227 utr a \u3008halt2, set1\u3009 \u0016 utr\u2032\nHC3 |[P]| \u2227 utr a \u3008halt1, halt2\u3009 \u0016 utr\u2032 = |[P]| \u2227 utr a \u3008halt2, halt1\u3009 \u0016 utr\u2032\nThe following condition indicates that no heterogeneous communicating process can\nrefuse both events halt and reset simultaneously when the timer is activated.\nHC4 |[P]| \u2227 utr\u2032 = utr0 a \u3008set\u3009a utr1 \u2227 utr1\u21be{halt, reset}=\u3008\u3009 \u21d2 {halt, reset} * ref\u2032\nIn what follows, we give some expansion laws to transform a parallel action into a\nsequential one. Take note that timer events play different roles from normal events.\nIn the following laws, we assume P and Q are already in guarded normal forms:\nP = 2ni=1(ci \u2192 Pi), Q = 2mk=1(dk \u2192 Qk), where for all i, k, ci 6= dk, and ci, dk\nare not timer events. Let cs = (\u03b1P \u2229 \u03b1Q)\\{set, halt, reset}.\nThe following one is the standard expansion law where no timer events are involved.\nLaw 1 P|[cs]|Q =\n{2i,k:ci=dk\u2208cs(ci \u2192 (Pi|[cs]|Qk))\n22i:ci \/\u2208cs(ci \u2192 (Pi|[cs]|Q))\n22k:dk \/\u2208cs(dk \u2192 (P|[cs]|Qk))\nIf timer events are involved, we should use the following expansion laws.\nLaw 2 (set1\u2192P)|[cs]|(set2\u2192Q) =\n(set1\u2192set2\u2192(P|[cs]|Q)) \u2293 (set2\u2192set1\u2192(P|[cs]|Q))\nNote that the two output events set1 and set2 can occur in any order, which is re-\nflected by the internal choice. So do the two halt events or a mix of them, as illustrated\nby the following two laws.\nLaw 3 (set1\u2192P)|[cs]|(halt2\u2192Q) =\n(set1\u2192halt2\u2192(P|[cs]|Q)) \u2293 (halt2\u2192set1\u2192(P|[cs]|Q))\nLaw 4 (halt1\u2192P)|[cs]|(halt2\u2192Q) =\n(halt1\u2192halt2\u2192(P|[cs]|Q)) \u2293 (halt2\u2192halt1\u2192(P|[cs]|Q))\nThe events set and halt from the master process have higher priority than the reset\nevent emitted by the slave process. This is reflected in the following two laws:\nLaw 5 (set1 \u2192 P)|[cs]|(reset2 \u2192 Q) = set1 \u2192 (P|[cs]|(reset2 \u2192 Q))\nLaw 6 (halt1 \u2192 P)|[cs]|(reset2 \u2192 Q) = halt1 \u2192 (P|[cs]|(reset2 \u2192 Q))\nLaw 7 (reset1 \u2192 P)|[cs]|(reset2 \u2192 Q) =\n(reset1 \u2192 (P|[cs]|(reset2 \u2192 Q))) 2 (reset2 \u2192 ((reset1 \u2192 P)|[cs]|Q))\nTake note that different from Law 2, external choice is used here as the two in-\nput events reset1 and reset2 have to wait for the corresponding output events from the\nenvironment (Timer processes).\n5 Related Work and Conclusion\nThe two mostly related integrated formal specification languages are TCOZ [11] and\nCircus [21]. Circus is a combination of CSP and Z. It also includes specification state-\nments found in Morgan\u2019s refinement calculus [13] and Dijkstra\u2019s language of guarded\ncommands [3]. Circus has a well-defined syntax and a formal semantics [23, 21] based\non Hoare and He\u2019s unifying theories of programming [8]. Case studies using the lan-\nguage are explored in [22] to show its power of expressiveness. A development method\nfor Circus using refinement is described in [15]. A timed model for Circus was provided\nin [17]. Our untimed model CZ is a subset of Circus.\nTCOZ is a blending of Object-Z [5, 18] and Timed CSP [16, 2], aiming at specifi-\ncation for complex real-time systems. The semantic link between the two formalisms\nTimed CSP and Object-Z is reported in [12]. TCOZ was enriched with sensors\/actuators\nin [10]. A unified observation model for TCOZ is presented in [14]. Recent work\n[4] proposed a projection from TCOZ specifications to Timed Automata Patterns for\nmodel-checking timing properties using UPPAAL. Their syntactical mapping is proved\nsound under bisimulation. In our paper, we propose to verify timing properties in un-\ntimed framework by constructing a property-oriented untimed model, which, we be-\nlieve, should be much simpler than doing it within the timed model.\nInstead of using the same complex model as both semantic and reasoning models,\nwe advocate the construction of small property-oriented models, that are separated from\nthe whole semantic model, for verification of particular kinds of properties. In our in-\nstantiation in terms of timing properties, the approach does make analysis and reasoning\nabout certain timing properties simpler and easier. A deep semantic link has been built\nbetween the timed model and the untimed model in the observation level, which ensures\nthat it is safe to use a smaller property-oriented model for verification.\nReferences\n1. M. Butler. csp2B: A Practical Approach to Combining CSP and B. Formal Aspects of\ncomputing, 12:182\u2013196, 2000.\n2. J. Davies and S. Schneider. A brief history of Timed CSP. Theoretical Computer Science,\n138:243\u2013271, 1995.\n3. E. W. Dijkstra. Guarded Commands, Nondeterminacy and Formal Derivation of Programs.\nCommunications of the ACM, 18(8):453 \u2013 457, 1975.\n4. J. S. Dong, P. Hao, S.C. Qin, J. Sun, and Y. Wang. Timed Patterns: TCOZ to Timed Au-\ntomata. In 6th International Conference on Formal Engineering Methods, ICFEM 2004,\nSeattle, WA, USA, November 2004.\n5. R. Duke and G. Rose. Formal Object Oriented Specification Using Object-Z. Cornerstones\nof Computing Series. Macmillan, March 2000.\n6. C. Fischer. CSP-OZ: A combination of Object-Z and CSP. In H. Bowmann and J. Der-\nrick, editors, Formal Methods for Open Object-Based Distributed Systems (FMOODS \u201997),\nvolume 2, pages 423\u2013438. Chapman & Hall, 1997.\n7. C. A. R. Hoare. Communicating Sequential Processes. Prentice Hall, 1985.\n8. C.A.R. Hoare and J. He. Unifying Theories of Programming. Prentice-Hall, 1998.\n9. L. Li and J. He. Towards a Denotational Semantics of Timed RSL using Duration Calculus.\nTechnical Report 161, UNU\/IIST, April 1999.\n10. B. Mahony and J. S. Dong. Sensors and Actuators in TCOZ. In FM\u201999: World Congress on\nFormal Methods, volume 1709 of Lect. Notes in Comput. Sci., Toulouse, France, September\n1999. Springer-Verlag.\n11. B. Mahony and J. S. Dong. Timed Communicating Object Z. IEEE Transactions on Software\nEngineering, 26(2):150\u2013177, February 2000.\n12. B. Mahony and J. S. Dong. Deep Semantic Links of TCSP and Object-Z: TCOZ Approach.\nFormal Aspects of Computing, 13(2):142\u2013160, 2002.\n13. C. C. Morgan. Programming from Specifications. Prentice Hall, 1994.\n14. S.C. Qin, J.S. Dong, and W.N. Chin. A Semantics Foundation for TCOZ in Unifying The-\nories of Programming. In K. Araki, S. Gnesi, and D. Mandrioli, editors, Formal Methods:\nInternational Symposium of Formal Methods Europe, volume 2805 of Lect. Notes in Comput.\nSci., pages 321\u2013340. Springer, 2003.\n15. A. Sampaio, J. Woodcock, and A. Cavalcanti. Refinement in Circus. In FME2002: Interna-\ntional Symposium of Formal Methods Europe, volume 2391 of Lect. Notes in Comput. Sci.,\npages 451\u2013470. Springer-Verlag, 2002.\n16. S. Schneider, J. Davies, D. M. Jackson, G. M. Reed, J. N. Reed, and A. W. Roscoe. Timed\nCSP: Theory and practice. In J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rozen-\nberg, editors, Real-Time: Theory in Practice, volume 600 of Lect. Notes in Comput. Sci.,\npages 640\u2013675. Springer-Verlag, 1992.\n17. A. Sherif and J. He. Towards a Timed Model for Circus. In C. George and H. Miao, edi-\ntors, ICFEM\u201902 Formal Methods and Software Engineering, volume 2495 of Lect. Notes in\nComput. Sci., pages 613\u2013624. Springer-Verlag, 2002.\n18. G. Smith. The Object-Z Specification Language. Advances in Formal Methods. Kluwer\nAcademic Publishers, 2000.\n19. G. Smith and J. Derrick. Refinement and verification of concurrent systems specified in\nObject-Z and CSP. In International Conference on Formal Engineering Methods, pages\n293\u2013302. IEEE Computer Society, 1997.\n20. J. M. Spivey. The Z Notation: A Reference Manual. Prentice Hall International Series in\nComputer Science, Prentice-Hall, 1992.\n21. J. Woodcock and A. Cavalcanti. Circus: a concurrent refinement language. Technical report,\nOxford University Computing Laboratory, Wofson Building, Parks Road, Oxford OX1 3QD,\nUK, July 2001.\n22. J. Woodcock and A. Cavalcanti. The steam boiler in a unified theory of Z and CSP. In\nJ. He, Y. Li, and G. Lowe, editors, The 8th Asia-Pacific Software Engineering Conference\n(APSEC\u201901), pages 291\u2013298. IEEE Press, 2001.\n23. J. Woodcock and A. Cavalcanti. The Semantics of Circus. In 2nd International Conference\non Z and B, volume 2272 of Lect. Notes in Comput. Sci., pages 184\u2013203. Springer-Verlag,\n2002.\n"}