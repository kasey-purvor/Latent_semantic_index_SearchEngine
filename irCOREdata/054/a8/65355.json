{"doi":"10.1016\/j.dam.2009.08.013","coreId":"65355","oai":"oai:dro.dur.ac.uk.OAI2:6148","identifiers":["oai:dro.dur.ac.uk.OAI2:6148","10.1016\/j.dam.2009.08.013"],"title":"One-to-many node-disjoint paths in (n,k)-star graphs.","authors":["Stewart,  I. A.","Xiang,  Y."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2010-01-06","abstract":"We present an algorithm which given a source node and a set of n\u22121 target nodes in the (n,k)-star graph Sn,k, where all nodes are distinct, builds a collection of n\u22121 node-disjoint paths, one from each target node to the source. The collection of paths output from the algorithm is such that each path has length at most 6k\u22127, and the algorithm has time complexity O(k2n2)","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65355.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6148\/1\/6148.pdf","pdfHashValue":"35b4b260d69a3bb3a1759f26b3c7b907f7f820d8","publisher":"Elsevier","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6148<\/identifier><datestamp>\n      2016-10-03T10:00:32Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        One-to-many node-disjoint paths in (n,k)-star graphs.<\/dc:title><dc:creator>\n        Stewart,  I. A.<\/dc:creator><dc:creator>\n        Xiang,  Y.<\/dc:creator><dc:description>\n        We present an algorithm which given a source node and a set of n\u22121 target nodes in the (n,k)-star graph Sn,k, where all nodes are distinct, builds a collection of n\u22121 node-disjoint paths, one from each target node to the source. The collection of paths output from the algorithm is such that each path has length at most 6k\u22127, and the algorithm has time complexity O(k2n2).<\/dc:description><dc:subject>\n        Interconnection networks<\/dc:subject><dc:subject>\n         (n<\/dc:subject><dc:subject>\n        k)-star graphs<\/dc:subject><dc:subject>\n         Many-to-one node-disjoint paths.<\/dc:subject><dc:publisher>\n        Elsevier<\/dc:publisher><dc:source>\n        Discrete applied mathematics, 2010, Vol.158(1), pp.62-70 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2010-01-06<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6148<\/dc:identifier><dc:identifier>\n        issn:0166-218X <\/dc:identifier><dc:identifier>\n        doi:10.1016\/j.dam.2009.08.013<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6148\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1016\/j.dam.2009.08.013<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6148\/1\/6148.pdf<\/dc:identifier><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:0166-218X","0166-218x"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2010,"topics":["Interconnection networks","(n","k)-star graphs","Many-to-one node-disjoint paths."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n27 November 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nStewart, I. A. and Xiang, Y. (2010) \u2019One-to-many node-disjoint paths in (n,k)-star graphs.\u2019, Discrete applied\nmathematics., 158 (1). pp. 62-70.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1016\/j.dam.2009.08.013\nPublisher\u2019s copyright statement:\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n26 October 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nStewart, I. A. and Xiang, Y. (2010) 'One-to-many node-disjoint paths in (n,k)-star graphs.', \nDiscrete applied mathematics., 158 (1). pp. 62-70. \n \nFurther information on publisher\u2019s website: \nhttp:\/\/dx.doi.org\/10.1016\/j.dam.2009.08.013 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nOne-to-many node-disjoint paths\nin (n, k)-star graphs\nYonghong Xiang and Iain A. Stewart\nDepartment of Computer Science, Durham University,\nScience Labs, South Road, Durham DH1 3LE, U.K.\ne-mail: {yonghong.xiang,i.a.stewart}@durham.ac.uk\nAbstract\nWe present an algorithm which given a source node and a set of n\u2212 1\ntarget nodes in the (n, k)-star graph Sn,k, where all nodes are distinct,\nbuilds a collection of n \u2212 1 node-disjoint paths, one from each target\nnode to the source. The collection of paths output from the algorithm\nis such that each path has length at most 6k \u2212 7, and the algorithm\nhas time complexity O(k2n2).\nkeywords: interconnection networks; (n, k)-star graphs; one-to-many\nnode-disjoint paths.\n1 Introduction\nChiang and Chen [6] introduced (n, k)-star graphs, Sn,k, where n > k \u2265 1, as\nalternatives to n-star graphs, for which the \u2018jump\u2019 from n! nodes in an n-star\ngraph to (n+ 1)! nodes in an (n+ 1)-star graph is deemed excessive (n-star\ngraphs were devised in [1] as rivals to hypercubes in that they can incorporate\ncomparable numbers of nodes yet have smaller diameters and degrees). The\ntwo parameters, n and k, of (n, k)-star graphs allow much more precision\nwith regard to incorporating more nodes, and allow fine tuning with regard\nto a degree\/diameter trade-off.\nSince their introduction in [6], (n, k)-star graphs have been well studied\nand their basic topological and algorithmic properties are well understood.\n1\nFor example: they form a hierarchical family of graphs, each of which is node-\nsymmetric [6]; they can be recursively decomposed in a number of ways [6];\nthey have a simple shortest-path routing algorithm [6]; the node-connectivity\nof Sn,k is n \u2212 1 [7]; there is an exact formula for their diameters, and their\nfault-diameters are at most their fault-free-diameters plus 3 [7]; a cycle of\nlength n!\n(n\u2212k)!\n\u2212 f can be found in Sn,k when the number of faulty nodes f\nis at most n \u2212 3 and n \u2212 k \u2265 2 [4]; their Hamiltonicity and Hamiltonian-\nconnectedness properties are well understood in the presence of a limited\nnumber of faulty nodes and edges [12]; and Sn,k is super spanning connected\nif n \u2265 3 and n\u2212 k \u2265 2 [13].\nAs regards the node-connectivity of Sn,k, it was shown in [7] that there\nare n\u2212 1 node-disjoint paths joining any two distinct nodes of Sn,k (with an\nimplicit algorithm for construction) and that each of these paths has length\nat most the diameter, \u2206(Sn,k), of Sn,k plus 3; that is, the wide-diameter\nof Sn,k is at most \u2206(Sn,k) + 3. It was also shown in [7] that the diameter\n\u2206(Sn,k) is 2k \u2212 1, if 1 \u2264 k \u2264 \u230a\nn\n2\n\u230b, and k + \u230an\u22121\n2\n\u230b, if \u230an\n2\n\u230b + 1 \u2264 k < n.\nThe wide-diameter analysis was improved in [16, 17] to yield that: when\n2 \u2264 k < \u230an\n2\n\u230b or k = n\u2212 1, the wide-diameter of Sn,k is exactly \u2206(Sn,k) + 2;\nwhen \u230an\n2\n\u230b+1 \u2264 k < n\u2212 2, the wide-diameter of Sn,k is either \u2206(Sn,k) + 1 or\n\u2206(Sn,k) + 2; and the wide-diameter of Sn,1 is \u2206(Sn,1) + 1. Thus, the one-to-\none node-disjoint paths problem for Sn,k has been pretty much resolved (note\nthat as Sn,k is regular of degree n\u22121, there is no scope for incorporating more\nnode-disjoint paths between two nodes). In this paper, we are concerned with\nthe one-to-many node-disjoint paths problem for Sn,k; that is, we are given\nSn,k, n\u2212 1 distinct target nodes in the set T , and a source node I, different\nfrom any target node, and we wish to find n \u2212 1 node-disjoint paths, one\nfrom the source node I to each target node of T .\nThe one-to-many node-disjoint paths problem is a fundamental prob-\nlem in the design and implementation of parallel and distributed computing\nsystems and it has been extensively studied for a variety of (families of) in-\nterconnection networks. Whilst Menger\u2019s Theorem [3] implies that, given a\nsource node and n \u2212 1 distinct target nodes (different from the source) in\na graph of node-connectivity n\u2212 1, there exist n\u2212 1 node-disjoint paths to\neach of the target nodes from the source, it is sometimes difficult to identify\nand actually construct the paths, especially if the paths are to be as short\nas possible. Suppose that G is a c-connected graph. We say that G has\nc-Rabin number r if r is the minimum number for which any c + 1 distinct\n2\nnodes s, t1, t2, . . . , tc are such that there are c node-disjoint paths from s to\nt1, t2, . . . , tc, each of length at most r. It was shown in [11] that given a\nc-connected graph G, it is NP-hard to compute the c-Rabin number of G.\nHowever, in many interconnection networks, which almost always have \u2018uni-\nformity\u2019 properties such as recursive decomposability, node-symmetry, and\ndegree regularity, the situation is much more acceptable (see, for example,\n[1, 2, 5, 8, 9, 10, 11, 14, 15, 18, 19]). We only highlight here two such\nstudies of the one-to-many node-disjoint paths problem: in hypercubes and\nin n-star graphs (recall, n-star graphs were introduced as improvements to\nhypercubes, and (n, k)-star graphs as improvements to n-star graphs). In\n[19], Rabin studied the one-to-many node-disjoint paths problem in hyper-\ncubes where he showed that given a source node and n target nodes in an\nn-dimensional hypercube, there exist node-disjoint paths from the source to\neach of the target nodes such that each path has length at most 1 plus the\ndiameter of the n-dimensional hypercube (this result was slightly improved\nin [8]). In [10], Gu and Peng showed that given a source and n \u2212 1 target\nnodes in an n-star graph, there is an algorithm of time complexity O(n2)\nthat builds n\u22121 paths from the source to each of the target nodes such that\nthe length of each path is at most the diameter of the n-star graph (that is,\n\u230a3(n\u22121)\n2\n\u230b) plus 2.\nIn this paper, we prove the following theorem.\nTheorem 1 When T is a set of n \u2212 1 distinct nodes in Sn,k, where n >\nk \u2265 1, and when I is a node not in T , there is an algorithm that finds\nn \u2212 1 node-disjoint paths in Sn,k from the source I to each of the nodes in\nT . Furthermore, all paths found by this algorithm have length at most 6k\u22127\nand the time complexity of the algorithm is O(k2n2).\nWe also show that this result is optimal for the case when k = 2.\nWe present the basic definitions in Section 2 before dealing with the case\nwhen k = 2 in Section 3. In Section 4, we present the algorithm alluded\nto in Theorem 1 and its proof of correctness, and in Section 5 we consider\nthe lengths of the paths constructed by our algorithm and also its time com-\nplexity. Our conclusions are presented in Section 6, where we comment on\nour results in comparison with analogous ones for n-star graphs and hyper-\ncubes. We remark that weaker results than those presented in this paper\nwere claimed in [21]. However: the proof of the main theorem in [21] is in-\ncomplete in that the cases considered do not exhaust those that might arise,\n3\nwith the consequence that more sophistication in the construction and the\nanalysis is called for; no analysis of the lengths of the paths constructed in\n[21] was given; and the base case of the induction (see the proof of the main\ntheorem in [21]) was merely stated as being self-evident when, as we shall\nsee in Section 3, this is not the case.\n2 Basic definitions and lemmas\nIt is worthwhile beginning with an n-star graph in order that we might un-\nderstand why (n, k)-star graphs emerged. The n-star graph Sn has node set\nV (Sn) = {(u1, u2, . . . , un) : each ui \u2208 {1, 2, . . . , n} and ui 6= uj, for i 6= j},\nand there is an edge ((ui, u2, . . . , un), (v1, v2, . . . , vn)) if, and only if, u1 = vi\nand ui = v1, for some i \u2208 {2, 3, . . . , n}, with ul = vl, for all l \u2208 {2, 3, . . . , n} \\\n{i}. In order to avoid the significant jump from n! nodes in an n-star graph to\n(n+1)! nodes in an (n+1)-star graph, (n, k)-star graphs were devised, as \u2018gen-\neralized\u2019 n-star graphs. Let n > k \u2265 1. The (n, k)-star graph, denoted Sn,k,\nhas node set V (Sn,k) = {(u1, u2, . . . , uk) : each ui \u2208 {1, 2, . . . , n} and ui 6=\nuj, for i 6= j}, and there is an edge ((u1, u2, . . . , uk), (v1, v2, . . . , vk)) if, and\nonly if, either:\n\u2022 ui = vi, for 2 \u2264 i \u2264 k, and u1 6= v1 (a 1-edge);\n\u2022 u1 = vi and ui = v1, for some i \u2208 {2, 3, . . . , k}, with ul = vl, for all\nl \u2208 {2, 3, . . . , k} \\ {i} (an i-edge).\nIn consequence, Sn,k has\nn!\n(n\u2212k)!\nnodes and n\u22121\n2\n\u00d7 n!\n(n\u2212k)!\nedges. Note that Sn,n\u22121\nis isomorphic to the n-star Sn, and that Sn,1 is a clique on n nodes.\nAn important property of Sn,k, of which we make crucial use, is that it\ncan be partitioned into n node-disjoint copies of Sn\u22121,k\u22121 over one of k \u2212 1\ndimensions. In more detail, let i \u2208 {2, 3, . . . , k} and partition the nodes\nof Sn,k by fixing the ith component of each node. Thus, define S\ni\nn,k(j) =\n{(u1, u2, . . . , uk) \u2208 V (Sn,k) : ui = j}, for each j \u2208 {1, 2, . . . , n}. It is trivial\nto see that the set of nodes Sin,k(j), for j \u2208 {1, 2, . . . , n}, induces a copy of\nSn\u22121,k\u22121. Note that there are k\u22121 dimensions over which we can so partition\nSn,k.\nWe adopt the following notation throughout this paper. Let I = (u1, u2,\n. . . , uk) be an arbitrary node of Sn,k. Note that there are k\u22121 neighbours of\nI that are joined to I via an i-edge, and n\u2212k neighbours of I that are joined\n4\nto I by a 1-edge; each neighbour is characterized by its first component. We\ndenote the neighbour of I whose first component is j by Ij. Paths are written\nexplicitly as sequences of nodes, such as (x1, x2, . . . , xm) (it will be clear from\nthe context whether we are referring to a path of nodes or the components\nof a node), and we sometimes denote a specific path from node s to node t\nby \u03c1(s, t). We write x \u2208 Sn,k \\X, where X is a set of nodes of Sn,k, to denote\nthat x is a node of Sn,k different from any node in X.\nWe now give a lemma that shall be useful later.\nLemma 2 Let (x1, x2, . . . , xk) be some node of S\nk\nn,k(xk), where x1 6= y 6= xk.\nThere are n\u2212 2 distinct nodes of Skn,k(xk) each of whose first component is y\nand each of which is reachable by a path in Skn,k(xk) of length at most 3 from\n(x1, x2, . . . , xk).\nProof Suppose that xi = y, where 1 6= i 6= k. The nodes are as follows.\nFor each z where z 6\u2208 {x1, x2, . . . , xk}, define the path\n(x1, x2, . . . , xi\u22121, y, xi+1, . . . , xk), (z, x2, . . . , xi\u22121, y, xi+1, . . . , xk),\n(y, x2, . . . , xi\u22121, z, xi+1, . . . , xk).\nWhen 2 \u2264 j \u2264 k \u2212 1 and j 6= i, define the path\n(x1, x2, . . . , xi\u22121, y, xi+1, . . . , xk),\n(xj, x2, . . . , xj\u22121, x1, xj+1, . . . , xi\u22121, y, xi+1, . . . , xk),\n(y, x2, . . . , xj\u22121, x1, xj+1, . . . , xi\u22121, xj, xi+1, . . . , xk),\nand define the path\n(x1, x2, . . . , xi\u22121, y, xi+1, . . . , xk), (y, x2, . . . , xi\u22121, x1, xi+1, . . . , xk).\nSuppose that y 6\u2208 {x1, x2, . . . , xk}. The nodes are as follows. For each z\nwhere z 6\u2208 {x1, x2, . . . , xk, y}, define the path\n(x1, x2, . . . , xk), (z, x2, . . . , xk), (x2, z, x3, . . . , xk), (y, z, x3, . . . , xk).\nWhen 2 \u2264 j \u2264 k \u2212 1, define the path\n(x1, x2, . . . , xk), (xj, x2, . . . , xj\u22121, x1, xj+1, . . . , xk),\n(y, x2, . . . , xj\u22121, x1, xj+1, . . . , xk),\n5\nand define the path\n(x1, x2, . . . , xk), (y, x2, . . . , xk).\nThe result follows.\nOur intention is to build an algorithm to find n \u2212 1 node-disjoint paths\nfrom each of n \u2212 1 distinct target nodes, held in T , to a given source node\nI of Sn,k (I is never a target node). Note that hitherto we have spoken of\npaths from the source to the target nodes whereas now we are speaking of\npaths from the target nodes to the source. We have swapped the orientation\nas it turns out that our paths will actually be constructed by starting at a\ntarget node and working towards the source. Of course, this is of no practical\nconsequence.\nBefore we present our algorithm, we show that there are certain assump-\ntions that we can make.\nLemma 3 Let T be a set of n\u2212 1 target nodes in Sn,k, where k \u2265 3. There\nexists a dimension i \u2208 {2, 3, . . . , k} such that each of Sin,k(1), S\ni\nn,k(2), . . . ,\nSin,k(n) contains at most n\u2212 2 nodes of T .\nProof Suppose that for every j \u2208 {2, 3, . . . , k}, when we partition Sn,k over\ndimension j, we get that some Sjn,k(ij) contains all the target nodes from T .\nThus, all target nodes in T have the form (u, i2, i3, . . . , ik), for some u. This\nyields a contradiction as there are only n\u2212 (k \u2212 1) such nodes.\nSuppose that k \u2265 3. By Lemma 3, we can choose a dimension, i, say\n(where i \u2208 {2, 3, . . . , k}), so that when we partition the (n, k)-star Sn,k over\ndimension i to obtain the (n\u2212 1, k\u2212 1)-stars Sin,k(1), S\ni\nn,k(2), . . . , S\ni\nn,k(n), we\ncan be sure that each Sin,k(j) contains at most n \u2212 2 target nodes. Sup-\npose that i 6= k. The automorphism of Sn,k obtained by swapping the\nith and kth components of every node is such that Sin,k(j) is mapped to\nSkn,k(j). Suppose that I = (y1, y2, . . . , yk) and let \u03c3 be any permutation\nof {1, 2, . . . , n} for which \u03c3(yj) = j, for j = 1, 2, . . . , k. The permutation\n\u03c3 yields an automorphism of Sn,k by mapping each node (x1, x2, . . . , xk)\nto (\u03c3(x1), \u03c3(x2), . . . , \u03c3(xk)), so that each S\nk\nn,k(j) is mapped to S\nk\nn,k(\u03c3(j)).\nThus, we may assume that our source node I is Ik = (1, 2, . . . , k) and\nthat when we partition over dimension k, the resulting (n \u2212 1, k \u2212 1)-stars\nSkn,k(1), S\nk\nn,k(2), . . . , S\nk\nn,k(n) each contains at most n \u2212 2 target nodes. Note\n6\nthat when k = 2, we can assume that our source is Ik but not that partition-\ning over dimension k results in (n \u2212 1, k \u2212 1)-stars each containing at most\nn\u2212 2 target nodes. Henceforth, for brevity, we denote Skn,k(i) by Si (with Si\nnot to be confused with the n-star graph of the same name).\nFor i \u2208 {k + 1, k + 2, . . . , n}, we define Ii = (k, 2, 3, . . . , k \u2212 1, i) \u2208 Si; for\ni \u2208 {2, 3, . . . , k\u22121}, we define Ii = (k, 2, 3, . . . , i\u22121, 1, i+1, . . . , k\u22121, i) \u2208 Si;\nand we define I1 = (k, 2, 3, . . . , k \u2212 1, 1) \u2208 S1. For i = 1, 2, . . . , n, we denote\nthe set of target nodes of T which lie in Si, that is, T \u2229 Si, by Ti. The basic\nstructure of Sn,k can be visualized in Fig. 1.\nI\n1\nIk\nSk\n... ...\nIk\nnIk\niIk\n2\nI\n2 Ii\nIn\nSi\nSn\nS\n2\nS\n1\n...\n...\nFigure 1. The basic partition of Sn,k.\n3 The case for k = 2\nIn this section, we devise an algorithm Disjoint paths when k=2 which finds\nnode-disjoint paths in Sn,2 from n\u22121 target nodes in T to the source node I2\n(which is not a target node). (Note that the one-to-many node-disjoint paths\nproblem is trivial for Sn,1, an n-clique.) We begin with an overview of our\nalgorithm and describe how it works in an abstract way before presenting\na more detailed pseudo-code description (we link the abstract description\nwith specific lines of pseudo-code). We refer the reader to Fig. 2 for a visual\ndepiction of the general scenario.\n7\nAlgorithm overview\n1. Our algorithm begins by marking every edge from a node Ij2 \u2208 T2 to I2\nas a path to be output (thus, this deals with |T2| paths; recall, every\nSi is a clique). (lines 2\u20134)\n2. Consider some Sj, where Tj = \u2205 and where if j 6= 1 then the node\nI\nj\n2 6\u2208 T2. We might use such an Sj as a collection of \u2018transit\u2019 nodes;\nthat is, we might construct a path passing through some of these nodes\nand then on from Ij to I\nj\n2 and on to I2 (or directly to I2 if j = 1). We\ncall such an Sj a transit set. (line 5)\n3. Consider some Si, where i 6= 2 and Ti 6= \u2205 (that is, in which there is\nat least one target node). We need to build a path from every target\nnode in Si to I2. (line 6)\n4. If i = 1 or I i2 6\u2208 T2 then we choose some target in Ti, giving preference\nto the node Ii, if it is a target node, and build a path through Ii, I\ni\n2 (if\ni 6= 1) and on to I2. This deals with 1 target node of Si, though there\nmay be others. (lines 7\u201317)\n5. So, we have either |Ti| \u2212 1 or |Ti| remaining target nodes in Si to deal\nwith (depending upon whether we have just found a path to I2 from a\ntarget node in 4 above).\n6. We choose either |Ti| \u2212 1 or |Ti| (as appropriate) different transit sets\n(these transit sets will be used to build paths from the target nodes\nremaining in Si to I2; we shall prove below that we can always find the\nrequired number of transit sets). (lines 18\u201322)\n7. For every remaining target node Iji \u2208 Ti, we build a path to I2, either\ndirectly through Sj (if Sj is one of our chosen transit sets) and on to I2,\nor via some non-target node I li \u2208 Si, through the chosen transit set Sl,\nand on to I2 (if Sj is not one of our chosen transit sets). (lines 24\u201333)\n8. We no longer regard the transit sets chosen as subsequently being tran-\nsit sets; that is, available for use when we wish to construct other paths\nin future. (line 23)\n9. We repeat the above process, from 3 onwards, for each Si for which\ni 6= 2, Ti 6= \u2205, and whose target nodes we have yet to deal with.\n8\nWe now present our pseudo-code before elaborating on the description of\nour algorithm presented above.\n1 Disjoint paths when k=2(n,T,I2,paths)\n2 for every node Ij2 \u2208 T2 do\n3 add the path \u03c1(Ij2 , I2) = (I\nj\n2 , I2) to paths;\n4 od\n5 set transit := {Sj : j \u2208 {1, 3, 4, . . . , n} and Tj = \u2205, and\nif j 6= 1 then Ij2 6\u2208 T2};\n6 for i = 1, 2, . . . , n where i 6= 2 and Ti 6= \u2205 do\n7 if i = 1 or I i2 6\u2208 T2 then\n8 if Ii \u2208 Ti then\n9 add the path \u03c1(I1, I2) = (I1, I2) (resp. \u03c1(Ii, I2) =\n(Ii, I\ni\n2, I2)) to paths if i = 1 (resp. i 6= 1);\n10 sorted target := Ii;\n11 else\n12 choose some Iji \u2208 Ti and add the path \u03c1(I\nj\n1 , I2) =\n(Ij1 , I1, I2) (resp. \u03c1(I\nj\ni , I2) = (I\nj\ni , Ii, I\ni\n2, I2)) to paths\nif i = 1 (resp. i 6= 1);\n13 sorted target := Iji ;\n14 fi\n15 else\n16 sorted target := \u01eb;\n17 fi\n18 if sorted target 6= \u01eb then\n19 let good trans \u2286 transit be of size |Ti| \u2212 1;\n20 else\n21 let good trans \u2286 transit be of size |Ti|;\n22 fi\nIn the algorithm above, we write sorted target := \u01eb to denote that no node\nis associated with sorted target.\nWe need to verify that such a subset good trans exists, which we do now\n(see clause 6 in the description of our algorithm). Note that we need to verify\nthis fact for every iteration of the for-loop spanning lines 6-34 and not just\nthe first; thus, we deal with the general scenario below. Consider an iteration\nfor some value of i. Suppose that X = {l : l = 1, 3, 4, . . . , n, l < i, Tl 6= \u2205}\nwith Y \u2286 X defined as Y = {l : l \u2208 X \\{1}, I l2 \u2208 T2}, i.e., X indexes the Sl\u2019s\n9\n(with target nodes) that have so far been dealt with in the for-loop in lines\n6-34, and Y indexes those such Sl\u2019s for which I\nl\n2 blocks direct paths from Il\nto I2 (so, every path from any target node of Sl must be routed through some\nSl\u2032 for which Tl\u2032 = \u2205 and I\nl\u2032\n2 6\u2208 T , if l\n\u2032 6= 1). On an iteration of the for-loop\nfor some i where i 6= 2 and Ti 6= \u2205, any Sl from {S1, S2, . . . , Sn} \\ {S2, Si}\nfails to be in transit for exactly one of six reasons:\n1. Sl contains target nodes, 2 6= l < i, and (l 6= 1 and I\nl\n2 \u2208 T2), i.e., l \u2208 Y ;\n2. Sl contains target nodes, 2 6= l < i, and (l = 1 or I\nl\n2 6\u2208 T2), i.e.,\nl \u2208 X \\ Y ;\n3. Sl contains target nodes and l > i;\n4. Sl contains no target nodes but is used as a set of transit nodes for a\npath from some target in Sj , where j \u2208 Y ;\n5. Sl contains no target nodes but is used as a set of transit nodes for a\npath from some target in Sj , where j \u2208 X \\ Y ;\n6. Sl contains no target nodes, Sl is not used as a set of transit nodes for\na path from some target node, l 6= 1, and I l2 \u2208 T2.\nSome of the different cases are illustrated in Fig. 2, where the target nodes\nare represented in black and where i = 18 (note that all Sj \u2019s are cliques even\nthough they are not depicted as such). We can associate a target node with\nany Sl not in transit by choosing: the target node I\nl\n2 in case 1; the (unique)\ntarget node t of Sl for which the path \u03c1(t, I2) passes through Il in case 2; any\ntarget node of Sl in case 3; the unique target node t upon whose path \u03c1(t, I2)\nthe nodes of Sl are used as transit nodes in cases 4 and 5; and the target\nnode I l2 in case 6. All such target nodes are distinct and are different from\nthe target nodes in Ti. Thus, |transit| \u2265 (n\u2212 2)\u2212 ((n\u2212 1)\u2212 |Ti|) = |Ti| \u2212 1.\nFurthermore, if sorted target = \u01eb then I i2 \u2208 T2 and i 6= 1, and this target\nnode is distinct from all target nodes which were associated above; hence, in\nthis case |transit| \u2265 (n\u2212 2)\u2212 ((n\u2212 1)\u2212 |Ti| \u2212 1) = |Ti| and our claim holds.\n23 transit := transit \\ good trans;\n24 for every Iji \u2208 Ti \\ {sorted target} do\n25 if Sj \u2208 good trans then\n26 add the path \u03c1(I1i , I2) = (I\n1\ni , I\ni\n1, I1, I2) (resp. \u03c1(I\nj\ni , I2) =\n10\n(Iji , I\ni\nj, Ij , I\nj\n2 , I2)) to paths if j = 1 (resp. j 6= 1);\n27 remove Sj from good trans;\n28 else\n29 choose I li 6\u2208 Ti for which Sl \u2208 good trans;\n30 add the path \u03c1(Iji , I2) = (I\nj\ni , I\n1\ni , I\ni\n1, I1, I2) (resp. \u03c1(I\nj\ni , I2)\n= (Iji , I\nl\ni , I\ni\nl , Il, I\nl\n2, I2)) to paths if l = 1 (resp. l 6= 1);\n31 remove Sl from good trans;\n32 fi\n33 od\n34 od\nS\n2\n...\n... ...\n...\nI\n2\n...\nS\n1I1\nS\n22\nS\n19\nS\n18\nS\n13\nS\n5\nI\n22\nI\n19\nI\n18\nI\n13\nI\n5\ncase 1\ni = 18 case 6\ncase 3\ncase 2transit\nFigure 2. An illustration of different cases.\nConsequently, Disjoint paths when k=2 achieves its aims. Furthermore,\nall paths found by Disjoint paths when k=2 have length at most 5 and the\ntime complexity of Disjoint paths when k=2 is O(n2).\nTheorem 4 When T is a set of n\u2212 1 distinct nodes in Sn,2 and when I is\na node not in T , the algorithm Disjoint paths when k=2 finds n\u2212 1 node-\ndisjoint paths from the nodes in T to the node I. Furthermore, all paths found\nhave length at most 5 and the time complexity of Disjoint paths when k=2\nis O(n2).\n11\nNote that there are situations where at least one of the paths found in\nTheorem 4 necessarily has length 5. One such situation is when n \u2265 4 and\nthe target nodes include the nodes (1, 3), (2, 1) and (2, 3); for it is easy to\nsee that any path from the node (1, 3) to the node (1, 2) (avoiding the nodes\n(2, 1) and (2, 3)) must have length at least 5. Consequently, when n \u2265 4,\nTheorem 4 is optimal in terms of the length of the longest path found. Of\ncourse, S3,2 is a cycle of length 6 and so there is a configuration consisting of\na source and two distinct targets where there is necessarily a path of length\nat least 3 joining the source and one of the targets.\n4 Building node-disjoint paths when k > 2\nWe now detail a recursive algorithm to construct node-disjoint paths from\nn\u2212 1 distinct target nodes in Sn,k, given by the set of nodes T , to a source\nnode (which is different from each target node). Recall that we may assume\nthat our source is Ik and, for k \u2265 3, when we partition over dimension k,\nnone of the resulting copies of Sn\u22121,k\u22121 (namely S1, S2, . . . , Sn) contains more\nthan n\u2212 2 target nodes.\nWe remind the reader of some structural properties of Sn,k and introduce\nsome notation. Consider any node x of any Si, where i \u2208 {1, 2, . . . , n}. The\nnode x has n \u2212 1 neighbours, with 1 external neighbour outside Si, in S\u03b9(x)\n(and so \u03b9(x) is the first component of x), and n \u2212 2 internal neighbours\nin Si. Any two neighbours y and y\n\u2032 of x within Si are such that \u03b9(x) 6=\n\u03b9(y) 6= \u03b9(y\u2032) 6= \u03b9(x). Denote the neighbour of x in S\u03b9(x) by x\u03b9(x) and call it\nx\u2019s neighbour of index \u03b9(x), and for any neighbour y of x inside Si, we say\nthat y is x\u2019s neighbour of index \u03b9(y) and refer to y as x\u03b9(y). Thus, x has a\nneighbour of every index from {1, 2, . . . , n} \\ {i}.\nOur algorithm Disjoint paths iterates through the subgraphs of {S1, S2,\n. . . , Sn}\\{Sk, S1} finding paths in Sn,k from each of the target nodes encoun-\ntered. Actually, not the full paths are found: only the portions of the paths\nuntil the paths enter Sk, via some (distinct) entry nodes (that are not target\nnodes). Next, paths are found in the same way as above to deal with any\ntarget nodes in S1 (if there are any). However, it is ensured that there is\nalways one path from a target node, which may lie outside S1, through the\nnodes of S1, on to I1, and then on to Ik. This accounts for one of our eventual\noutput paths (note that this path does not contain any nodes of Sk, apart\nfrom Ik). Thus, we are left with finding n \u2212 2 node-disjoint paths from the\n12\nentry nodes in Sk and the target nodes of Tk to Ik, which we do recursively.\nHere is our algorithm in more detail. Define transit = {Sj : Tj = \u2205, j 6=\nk}. Consider some Si, where 1 6= i 6= k and Ti 6= \u2205 (and so Si 6\u2208 transit).\nA lower bound on the size of transit is (n \u2212 2) \u2212 ((n \u2212 1) \u2212 |Tk| \u2212 |Ti|) =\n|Ti|+ |Tk| \u2212 1, and this lower bound is only reached when every Sj for which\nSj 6\u2208 transit and i 6= j 6= k contains exactly one target node. For every\ntarget node x \u2208 Ti, if \u03b9(x) = k and x\u03b9(x) 6\u2208 Tk then place x in the set Xi (so,\nXi contains every target node in Ti with first component k whose external\nneighbour is not a target node). We shall ultimately construct a path from\neach target node x in Xi to its neighbour in Sk, which we call x\u2019s entry node,\nand then on to Ik in Sk. Note that all entry nodes are distinct.\nDefine Y \u2032i = {x : x \u2208 Ti \\ Xi, \u03b9(x) 6= k, S\u03b9(x) \u2208 transit}; that is, Y\n\u2032\ni\nconsists of those target nodes of Ti \\Xi whose external neighbours lie in sets\nin transit. Note that it might be the case that for two distinct target nodes\nx and x\u2032 in Y \u2032i , \u03b9(x) = \u03b9(x\n\u2032). Choose a subset Yi \u2286 Y\n\u2032\ni that is maximal with\nrespect to the property that for any two distinct target nodes x and x\u2032 in\nYi, \u03b9(x) 6= \u03b9(x\n\u2032). If x \u2208 Yi then remove S\u03b9(x) from transit. As we shall see,\nany Sj originally in transit has its nodes used on at most one path from any\ntarget node in T \\Tk; moreover, any path we ultimately construct from some\ntarget node will use nodes from at most one Sj which originally appeared in\ntransit. We shall ultimately construct a path from each target node x of Yi\nto x\u03b9(x), then on through nodes in S\u03b9(x) to a node in Sk, and then on to Ik.\nWe find an appropriate path through S\u03b9(x) and in to Sk, via an entry node in\nSk, presently. Thus, we have |Ti| \u2212 |Xi| \u2212 |Yi| target nodes remaining to be\ndealt with in Si and we have that |transit| is at least |Ti| \u2212 |Yi|+ |Tk| \u2212 1.\nSuppose that |Ti|\u2212|Xi|\u2212|Yi| \u2264 |Ti|\u2212|Yi|+|Tk|\u22121, i.e., 0 \u2264 |Xi|+|Tk|\u22121,\ni.e., either Xi 6= \u2205 or Tk 6= \u2205. Each of the target nodes in Ti \\ (Xi \u222a Yi) can\nchoose an internal neighbour so that the indices of the neighbours chosen are\nall different and are such that each chosen neighbour\u2019s external neighbour lies\nin some Sj \u2208 transit (note that all neighbours chosen are necessarily distinct\nand can not be target nodes, as otherwise they would have been included in\nYi on the grounds that Yi is maximal). We shall ultimately construct a path\nfrom each target node in Ti \\ (Xi \u222a Yi) to its chosen internal neighbour, then\non to the chosen neighbour\u2019s external neighbour, then through the Sj within\nwhich this external neighbour resides, then on to an entry node in Sk, and\nfinally on to the node Ik. All Sj \u2019s to be used in these paths are removed from\ntransit.\nSuppose that Xi = \u2205 and Tk = \u2205, and so we have that |transit| =\n13\n|Ti \\ Yi| \u2212 1. For all but one of the target nodes of Ti \\ Yi, we can proceed as\nin the previous paragraph and choose (distinct) internal neighbours through\nwhich we will construct paths that will ultimately lead to an entry node in\nSk and on to Ik (we reiterate that none of these internal neighbours can be\ntarget nodes because of the maximality of Yi). As above, all Sj\u2019s to be used\non these paths are removed from transit. Thus, that leaves only 1 target\nnode x of Ti \\ Yi to deal with. Let y be the neighbour of x of index k. Note\nthat as Xi = \u2205 and Tk = \u2205, y is an internal neighbour of x and can not be\na target node. Moreover, by construction, y is not a chosen neighbour of\none of the other target nodes in Ti \\ Yi, above (as \u03b9(y) = k and all chosen\nneighbours of the other target nodes in Ti \\ Yi have index different from k).\nWe shall ultimately construct a path from x to y, then to y\u2019s neighbour in\nSk (the entry node), and then on to Ik.\nConsider now some Si\u2032 for which Ti\u2032 6= \u2205 and i\n\u2032 6\u2208 {1, k, i}. Whilst dealing\nwith Si, above, we reduced the number of elements in transit; however, each\ntime we removed some Sj from transit, above, we dealt with some target\nnode in Si. Thus, a lower bound on the size of transit now is (n\u22123)\u2212 ((n\u2212\n1)\u2212|Tk|\u2212 |Ti|\u2212 |Ti\u2032|) = |Tk|+ |Ti|+ |Ti\u2032|\u22122 \u2265 |Tk|+ |Ti\u2032|\u22121. Consequently,\nwhen we deal with Si\u2032 in exactly the same way that we dealt with Si, the\nnumeric arguments are identical and thus our path \u2018reservations\u2019 can be made\nfor all target nodes in Si\u2032 too. Similarly, we \u2018reserve\u2019 paths in this way for\nall target nodes outside Sk \u222a S1.\nNow consider S1. We wish to ensure that we ultimately construct a path:\nfrom some target in S1, if there is one, through S1 to I1, and then on to Ik;\nor, if T1 = \u2205, from some target outside S1 \u222a Sk, in to S1, then on to I1, and\nthen on to Ik. We will deal with all other target nodes in S1 as we have done\nabove. As we have seen, immediately prior to dealing with S1, we have that\n|transit| is at least |Tk| + |T1| \u2212 1 and there are |T1| target nodes in S1 to\ndeal with.\nSuppose that S1 contains at least 1 target node. We proceed as we did\nabove for other Si\u2019s and deal with the target nodes in T1. Having done so,\nwe have reserved paths from all target nodes in T1. Let D be the set of\ntarget nodes in T1 whose distance to I1 in S1 is shortest (note that D might\njust consist of 1 element, and might, in fact, be {I1}). Choose some x \u2208 D\nand consider a shortest path \u03c1 in S1 from x to I1; denote by y the node\non this path adjacent to x, if y exists (of course, if y exists then it is not a\ntarget node). If y does not exist then D = {I1}; so, replace the path just\nreserved for I1 with the path (I1, Ik). If y exists and y does not appear on\n14\nany other reserved path from a target node in T1 \\ {x} then replace the path\nreserved for x with the path \u03c1 extended with the edge (I1, Ik). Consequently,\nwe may suppose that y appears on some reserved path from a target node x\u2032\nin T1 \\ {x}. In particular, the node y must have been chosen as one of x\n\u2032\u2019s\ninternal neighbours because x\u2032 6\u2208 X1 \u222a Y1 and, at that point, S\u03b9(x\u2032) 6\u2208 transit.\nWe can now replace x\u2032\u2019s reserved path with the path obtained by moving\nfrom x\u2032 to y, then along \u03c1 to I1, and then to Ik. Note that this path is\nnode-disjoint from all of the reserved paths just constructed (which consist\nof at most 1 edge before they leave S1).\nAlternatively, suppose that S1 contains no target nodes. If S1 is no longer\nin transit then we have indeed reserved a path from some target node outside\nS1 through S1 to I1 and on to Ik. So, suppose that S1 still resides in transit.\nBy hypothesis, not all target nodes lie in Sk and so we can trivially ensure\nthat for one target node outside Sk, we construct a path from this target\nnode (possibly through one of its neighbours) in to S1 and on to Ik through\nI1 (note that if our initially chosen target node x is such that its internal\nneighbour y for which y\u03b9(y) = 1 is a target node then we simply choose y as\nthe target node whose corresponding path to Ik passes through S1).\nWe have now made our path reservations: n\u2212 2 of these reservations are\nfor paths to entry nodes in Sk; and 1 reservation is for a path, from some\ntarget node x1, through S1 and on to Ik directly. We can visualize these\nreservations in Fig. 3, where the black nodes are target nodes, the dark grey\nnode is the source node, and the light grey nodes are entry nodes.\nWe now have to make concrete these path reservations. This means find\npaths through Sj \u2019s and on to entry nodes in Sk. However, we must ensure that\nall entry nodes in Sk are distinct from each other and also from any target\nnodes in Sk (as otherwise our resulting paths will not be vertex-disjoint).\nWe iterate through the target nodes of T \\ (Tk \u222a{x1}) and make concrete\nour paths. Note that every such target node has an associated reserved path\nand that the number of target nodes and entry nodes ultimately chosen in Sk\nwill be n\u22122. Some of our paths are already concrete. For example, any node\nx in some Xi has entry node x\u03b9(x) in Sk. Consider some target node x that\nhas a reserved path through some Sj (where Sj was originally in transit).\nThe path from x to the node y \u2208 Sj where the path enters Sj (y is the\nexternal neighbour of x or the external neighbour of an internal neighbour\nof x) is well-defined. By Lemma 2, there are n \u2212 1 distinct nodes of Sj ,\neach at a distance of at most 3 from y, with the property that their external\nneighbours all lie in Sk. So, at least one of these external neighbours in Sk\n15\nhas not yet been chosen as an entry node and is not a target node. Thus, we\nmay choose such a node as the entry node corresponding to the target node\nx. Hence, we can find an entry node corresponding to every target node of\nT \\ (Tk \u222a {x1}) so that all of these entry nodes are distinct and also distinct\nfrom all target nodes in Sk.\nIkSk\n... ...\nSi\nSm\nSj\nI\n1\nS\n1\n...\n...\n...transit\ntransit\ntransit\ntransit\nFigure 3. The path reservations.\nFinally, having constructed our entry nodes, we recursively find n \u2212 2\nvertex-disjoint paths in Sk from the target nodes of Tk and the entry nodes,\nand then we use (some of) these paths to extend our partially constructed\npaths from the target nodes of T \\ (Tk \u222a {x1}) to their corresponding entry\nnodes to the source Ik. Hence, we have an algorithm to find node-disjoint\npaths in Sn,k from each of any set T of n\u22121 target nodes to any given source\nnode; that is, Disjoint paths achieves its aims.\n5 Path lengths and complexity\nHaving proved that our algorithm Disjoint paths finds a collection of node-\ndisjoint paths in Sn,k from n\u22121 target nodes to a source node, we now turn to\nthe lengths of the paths produced by the algorithm and the time complexity\nof the algorithm.\n16\n5.1 Path lengths\nWe derive below an upper bound on the length of any path constructed by\nDisjoint paths; in the first instance, this upper bound is in the form of a\nrecurrence relation. Let bk be an upper bound on the length of any path\nproduced by the algorithm Disjoint paths applied in Sn,k, irrespective of\nn (at the moment, we have not shown that such an upper bound exists;\nhowever, we show, using induction, that it does and derive an estimate of it).\nBy Theorem 4, b2 = 5. As our induction hypothesis, we assume that bk\u22121\nexists and is independent of n.\nClearly, any path produced by our algorithm Disjoint paths which lies\nentirely within Sk has length at most bk\u22121. By considering the construction\nof paths from target nodes in any Si to Ik, where i 6= k, the length of any\nsuch path is at most the maximum of {\u2206(Sn\u22121,k\u22121) + 3, bk\u22121 + 6}. Solving\nthis recurrence relation with bk = 5 results in an upper bound on the length\nof any path constructed by Disjoint paths of bk \u2264 6k \u2212 7.\n5.2 Time complexity\nAs regards the time complexity of our algorithm, we assume that our model\nof computation is such that when dealing with Sn,k, the integer n can be\nstored in one word of memory; thus, basic arithmetic operations involving n\ncan be undertaken in constant time. This means that, for example, we can\niterate through the neighbours of a given node in O(n) time (the node is\ngiven as a k-tuple of integers between 1 and n). Note that we do not have an\nexplicit representation for Sn,k, as its adjacency matrix, for example, as this\nwould require an exponential amount of memory (in k); we simply start with\nn, k, a list of our target nodes, and our source, and we construct vertices of\nSn,k as and when they are required.\nWe begin by considering the computation undertaken by Disjoint paths\napart from the recursive call. We can register the Si\u2019s in which target nodes\nreside and the number of target nodes in the Si\u2019s in O(kn) time. With\nreference to our remark in the first paragraph of the previous section, our\nassumptions as regards the number of target nodes in any Si and the par-\nticular source node and partition in any recursive call result from an O(kn)\ntime computation. The initialization of transit can be undertaken in O(kn)\ntime. We can clearly deal with reserving paths corresponding to target\nnodes in some Si in O(|Ti|k) time, and we can make these paths concrete\n17\nin O(|Ti|kn) time (note that the straightforward algorithm in [6] for finding\na shortest path joining two nodes in Sn,k is easily implementable with time\ncomplexity O(kn)). Thus, we obtain that the time taken by the algorithm\nDisjoint paths on Sn,k, apart form the recursive call, is O(kn\n2) time. Con-\nsequently, by solving a simple recurrence relation, the time complexity of the\nalgorithm Disjoint paths is O(k2n2).\n6 Conclusions\nIn this paper, we have derived a polynomial-time algorithm to find node-\ndisjoint paths from each of n \u2212 1 distinct target nodes in Sn,k to a source\nnode (different from any target node). The length of any path constructed is\nat most 6k\u2212 7. This should be compared with the diameter of Sn,k which is\nat most 2k\u22121 (see the Introduction for an exact formula for the diameter of\nSn,k, suffice it to say that when 1 \u2264 k \u2264 \u230a\nn\n2\n\u230b, the diameter is exactly 2k\u22121).\nThe most appealing aspect of our construction is that we have managed\nto obtain an upper bound on the length of any of our paths from the source\nnode to the target nodes in Sn,k that is independent of n; thus, n can be\nincreased arbitrarily and our upper bound remains the same. Also, our algo-\nrithm is efficient and in practice will be even faster as the scenarios whereby\nrecursive calls are made will be much fewer than in our worst-case analysis.\nFurthermore, our algorithm should be easily and efficiently implementable\non a distributed-memory machine where global knowledge of the source and\ntarget nodes is available but where the paths have to be constructed in a\ndistributed fashion by the individual processors (see, for example, the under-\nlying model in [20]). We say no more here concerning this claim but note that\nthe structure of our algorithm lends itself to the incremental construction of\npaths.\nHowever, our upper bound is roughly three times the diameter of Sn,k,\nwhereas for n-star graphs the analogous upper bound is at most the diameter\nplus 2 and for hypercubes the analogous upper bound is at most the diameter\nplus 1. Thus, we conjecture that our result is not optimal. (Note that our\nresult is optimal when k = 2.) It may be the case that a refined analysis of\nthe possible distributions of sources and targets might yield that a recurrence\nof bk \u2264 bk\u22121 + 2 (see the previous section) can be obtained (which is what\nwould be required in order to get a maximal path length comparable with\nthe scenarios in n-star graphs and hypercubes). As yet, we have been unable\n18\nto make progress in this direction ((n, k)-star graphs are conceptually much\nmore complex than n-star graphs and hypercubes).\nOf course, we can apply our algorithm to Sn,n\u22121, i.e., the n-star. What re-\nsults is an algorithm of time complexity O(n4) that finds node-disjoint paths,\neach of length at most 6n \u2212 13. As might be expected, the algorithm from\n[5], designed specifically for n-stars, is better in that it has time complexity\nO(n2) and results in node-disjoint paths each of length at most 3n+9\n2\n+ 2.\nSimilarly, we can apply our algorithm to produce a (u, v)-container, for dis-\ntinct nodes u and v of Sn,k. Again, as expected, the resulting container is\nmuch worse than that produced by the (polynomial-time) algorithm in [16]\n(specifically designed for the purpose) where one of wide-diameter at most\n2k + 1 is produced. Nevertheless, our algorithm gives a polynomial-time\nalternative for constructing node-disjoint paths in n-stars and containers in\nSn,k.\nReferences\n[1] S.B. Akers, D. Horel and B. Krishnamurthy, The star graph: an at-\ntractive alternative to the n-cube, Proc. of Internat. Conf. on Parallel\nProcessing (1987) 393\u2013400.\n[2] L.N. Bhuyan and D.P. Agrawal, Generalized hypercube and hyperbus\nstructures for a computer network, IEEE Transactions on Computers\nC-33 (1984) 323\u2013333.\n[3] B. Bollobas, Extremal Graph Theory, Dover (2004).\n[4] J.-H. Chang and J. Kim, Ring embedding in faulty (n, k)-star graphs,\nProc. of 8th Internat. Conf. on Parallel and Distributed Systems (IC-\nPADS\u201901) (2001) 99\u2013106.\n[5] C.C. Chen and J. Chen, Nearly optimal one-to-many parallel routing in\nstar networks, IEEE Transactions on Parallel and Distributed Systems\n8 (1997) 1196\u20131202.\n[6] W.-K. Chiang and R.-J. Chen, The (n, k)-star graph: a generalized star\ngraph, Information Processing Letters 56 (1995) 259\u2013264.\n19\n[7] W.-K. Chiang and R.-J. Chen, Topological properties of the (n, k)-star\ngraph, Internat. Journal of Foundations of Computer Science 9 (1998)\n235\u2013248.\n[8] S. Gao, B. Novick and K. Qiu, From Hall\u2019s matching theorem to optimal\nrouting on hypercubes, Journal of Combinatorial Theory Series B 74\n(1998) 291\u2013301.\n[9] Q.P. Gu and S. Peng, Efficient algorithms for disjoint paths in star\ngraphs, Proc. of 6th Transputer\/Occam International Conf. (1994) 53\u2013\n65.\n[10] Q.P. Gu and S. Peng, Node-to-set disjoint paths problem in star graphs,\nInformation Processing Letters 62 (1997) 201\u2013207.\n[11] D.F. Hsu and Y.D. Lyuu, A graph-theoretical study of transmission\ndelay and fault tolerance, Internat. Journal of Mini and Microcomputers\n16 (1994) 35\u201342.\n[12] H.-C. Hsu, Y.-L. Hsieh, J.J.M. Tan and L.-H. Hsu, Fault Hamiltonicity\nand fault Hamiltonian connectivity of the (n, k)-star graphs, Networks\n42 (2003) 189\u2013201.\n[13] H.-C. Hsu, C.-K. Lin, H.-M. Hung and L.-H. Hsu, The spanning con-\nnectivity of the (n, k)-star graphs, Internat. Journal of Foundations of\nComputer Science 17 (2006) 415\u2013434.\n[14] C.-N. Lai, G.-H. Chen and D.-R. Duh, Constructing one-to-many dis-\njoint paths in folded hypercubes, IEEE Transactions on Computers 51\n(2002) 33\u201345.\n[15] S.C. Liaw, G.J. Chang, F. Cao and D.F. Hsu, Fault-tolerant routing in\ncirculant networks and cycle prefix networks, Annals of Combinatorics\n2 (1998) 165\u2013172.\n[16] T.-C. Lin, D.-R. Duh and H.-C. Cheng, Wide diameters of (n, k)-star\nnetworks, Internat. Conf. on Computing, Communications and Control\nTechnologies (CCCT\u201904) (2004) 160\u2013165.\n[17] T.-C. Lin and D.-R. Duh, Constructing vertex-disjoint paths in (n, k)-\nstar graphs, Information Sciences 178 (2008) 788\u2013801.\n20\n[18] J.-H. Park, One-to-many disjoint path covers in a graph with faulty\nelements, Proc. of Computing and Combinatorics, 10th Ann. Internat.\nConf. (COCOON\u201904), Lecture Notes in Computer Science Vol. 3106 (ed.\nK.-Y. Chwa, J.I. Munro), Springer (2004) 392\u2013401.\n[19] M.O. Rabin, Efficient dispersal of information for security, load balanc-\ning, and fault tolerance, Journal of the ACM 36 (1989) 335\u2013348.\n[20] I.A. Stewart, Distributed algorithms for building Hamiltonian cycles in\nk-ary n-cubes and hypercubes with faulty links, Journal of Interconnec-\ntion Networks 8 (2007) 253\u2013284.\n[21] Y. Xiang, Y. Lin, Z. Gu, C. Zhang and B. Cong, One-to-many node-\ndisjoint paths problem in com-star interconnection networks, Proc. of\n13th IASTED Int. Conf. on Parallel and Distributed Computing and\nSystems (PDCS\u201901) (2001) 248\u2013253.\n21\n"}