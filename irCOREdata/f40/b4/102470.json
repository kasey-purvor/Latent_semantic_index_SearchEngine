{"doi":"10.1109\/32.713329","coreId":"102470","oai":"oai:epubs.surrey.ac.uk:1932","identifiers":["oai:epubs.surrey.ac.uk:1932","10.1109\/32.713329"],"title":"Verifying authentication protocols in CSP","authors":["Schneider, Steve A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"1998-09-01","abstract":"This paper presents a general approach for analysis and verification of authentication properties using the theory of\\ud\nCommunicating Sequential Processes (CSP). The paper aims to develop a specific theory appropriate to the analysis of\\ud\nauthentication protocols, built on top of the general CSP semantic framework. This approach aims to combine the ability to express such protocols in a natural and precise way with the ability to reason formally about the properties they exhibit. The theory is illustrated by an examination of the Needham-Schroeder Public-Key protocol. The protocol is first examined with respect to a single run and then more generally with respect to multiple concurrent runs","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1932<\/identifier><datestamp>\n      2017-10-31T14:03:42Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1932\/<\/dc:relation><dc:title>\n        Verifying authentication protocols in CSP<\/dc:title><dc:creator>\n        Schneider, Steve A.<\/dc:creator><dc:description>\n        This paper presents a general approach for analysis and verification of authentication properties using the theory of\\ud\nCommunicating Sequential Processes (CSP). The paper aims to develop a specific theory appropriate to the analysis of\\ud\nauthentication protocols, built on top of the general CSP semantic framework. This approach aims to combine the ability to express such protocols in a natural and precise way with the ability to reason formally about the properties they exhibit. The theory is illustrated by an examination of the Needham-Schroeder Public-Key protocol. The protocol is first examined with respect to a single run and then more generally with respect to multiple concurrent runs.<\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:date>\n        1998-09-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1932\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Schneider, Steve A.  (1998) Verifying authentication protocols in CSP   IEEE Transactions on Software Engineering, 24 (9).  pp. 741-758.      <\/dc:identifier><dc:relation>\n        10.1109\/32.713329<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1932\/","10.1109\/32.713329"],"year":1998,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998 741\nVerifying Authentication Protocols in CSP\nSteve Schneider, Member, IEEE Computer Society\nAbstract\u2014This paper presents a general approach for analysis and verification of authentication properties using the theory of\nCommunicating Sequential Processes (CSP). The paper aims to develop a specific theory appropriate to the analysis of\nauthentication protocols, built on top of the general CSP semantic framework. This approach aims to combine the ability to express\nsuch protocols in a natural and precise way with the ability to reason formally about the properties they exhibit. The theory is\nillustrated by an examination of the Needham-Schroeder Public-Key protocol. The protocol is first examined with respect to a single\nrun and then more generally with respect to multiple concurrent runs.\nIndex Terms\u2014Authentication, security protocols, formal methods, CSP, verification, Needham-Schroeder protocol.\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u0003\u0003\u0003F\u0003\u0003\u0003\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n1 INTRODUCTION\nUTHENTICATION comes in a variety of forms, and\nauthentication protocols are used in a number of ways\ndepending on the precise security properties that they are\nbelieved to provide. International standard ISO 7498-2 [8]\ndistinguishes two forms of authentication:\n\u2022\u0003 peer entity authentication, which is intended to pro-\nvide confidence in an entity\u2019s identity at the time of\nusage. This kind of authentication involves freshness,\nbut does not provide any guarantees about any data\ntransferred.\n\u2022\u0003 data origin authentication, which provides corrobora-\ntion of the source of a data unit.\nBoth of these forms of authentication are concerned with\nthe identification of an entity, in one case to associate it with\nthe current connection, and in the other case to associate it\nwith a message. Entities are often identified with posses-\nsion of a particular secret password or key by agents acting\non their behalf, with protocols aiming to establish the fact\nof such possession. The international standard ISO\/IEC\n9798-1 states that \u201can entity to be authenticated proves its\nidentity by showing its knowledge of a secret.\u201d Data origin\nauthentication is commonly provided by encipherment or\nby digital signature, but the essential property is that the\ndata could only have been generated by an entity in posses-\nsion of particular secret information.\nThe question arises for any particular authentication\nprotocol as to which kind of authentication the protocol\nwas designed for, and which kinds it actually provides. A\nframework for expressing different flavors of authentica-\ntion property would help to address this issue. An example\nof such a framework is the logic of authentication proposed\nin [2], which provides a language for expressing different\nsecurity requirements. For example, the requirement that A\nshould know she is communicating with B is easily distin-\nguished from the requirement that B should know that A\nknows she is communicating with B.\nProtocols are implemented in terms of messages, so the\ncorrectness of an authentication must consider the relation-\nship between the messages of the protocol and the entities\nwhose authentication is required. The aim of the Commu-\nnicating Sequential Processes (CSP) approach presented in\nthis paper is to describe precisely what a protocol is in-\ntended to achieve in terms of its messages, and to provide a\nframework for verifying claims about such properties. CSP\nprovides a language for formal description of protocols,\nand a semantic theory for reasoning about their properties.\nThis approach forces the separation of properties and pro-\ntocols, and allows discussion of what is meant by particular\nkinds of security property independently of the protocols\nthat are intended to achieve them. The formal analysis will\nthen be entirely within the CSP framework which allows\nthe possibility of verification of protocols with respect to\nthe CSP properties.\nThe theoretical foundations of the CSP framework pro-\nposed by this author are described in [22]. Since a CSP de-\nscription of a protocol has a precisely defined semantics it is\na precise mathematical question as to whether the protocol\nmeets the property or not. However, the practicalities of\nhow such a verification might be carried out are not ad-\ndressed. That is the purpose of this paper.\nThe approach taken here is firstly to express the protocol\nin CSP. The authentication property we consider requires\nthat the receipt of some message of the protocol guarantees\nthat some earlier message must have been transmitted by the\nrequired agent. If B executes a protocol run ostensibly with\nA, then the final message B receives should provide some\nguarantees concerning A\u2019s participation. We establish this by\ndefining a suitable rank function on messages which shows\nthat only messages above a particular rank can circulate in a\nrestricted system in which A is blocked, and that this also\nblocks B\u2019s protocol run\u2014the rank of B\u2019s final message is too\nlow and the proof establishes that it cannot appear.\nCSP is particularly suitable for describing protocols at a\nlevel close to the level we think of them. In other contexts\nthe rank argument essentially amounts to an unreachabil-\nity analysis or a proof that a particular word is not in a\n0098-5589\/98\/$10.00 \u00a9 1998 IEEE\n\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\u2020\n\u2022\u0003 S. Schneider is with the Department of Computer Science, Royal Holloway,\nUniversity of London, Egham, Surrey TW20 0EX, UK.\nE-mail: s.schneider@dcs.rhbnc.ac.uk.\nManuscript received 28 Feb. 1997; revised 18 Nov. 1997.\nRecommended for acceptance by C. Landwehr.\nFor information on obtaining reprints of this article, please send e-mail to:\ntse@computer.org, and reference IEEECS Log Number 104040.\nA\n742 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\nlanguage. The strength of this approach is that there is a\nformal link between the rank arguments and a natural de-\nscription of the protocol. Formalization of the protocol into\nCSP also exposes issues and forces design decisions that\nmay not have been explicit in the original abstract protocol\ndescription. The Formalization of the required authentica-\ntion property likewise forces consideration of what, pre-\ncisely, is meant by authentication. It is useful to know\nwhich precise (CSP) properties the protocol does indeed\nguarantee, and which it does not. Both peer entity authenti-\ncation and data origin authentication properties can be\nspecified within this approach.\nOne of the strengths of CSP is the ease with which spe-\ncialized theories can be constructed on top of the semantic\nmodels. This allows particular specification statements to\nbe defined in terms of the standard semantics, and new\nproof rules appropriate to these specifications to be pro-\nvided. This approach is taken here, where we specify and\nreason about authentication properties, and about agents\u2019\ninability to generate particular messages. Although stan-\ndard proof rules would support the verification (since they\nare sound and complete), it is preferable to develop a spe-\ncialized theory since it provides an appropriate level of ab-\nstraction for supporting the kind of reasoning we require.\nThe protocol to be analyzed in this paper is a slimmed\ndown and amended version of the Needham-Schroeder\npublic-key protocol [16], in which the public keys of A and\nB are already known to each other. The original form of this\nprotocol has been the subject of an attack in [10], where\nLowe suggests an amendment to the protocol intended to\nmake it secure. The full version also involves communica-\ntion between each party and a trusted server to obtain the\npublic keys. The cut down version of the original protocol\nmay be described as follows:\nA \u0096 B    :    pB(nA.A)\n  B \u0096 A    :    pA(nA.nB)\n                                    A \u0096 B    :    pB(nB)\nThis protocol may be informally understood as follows: A\ninvents a new message or nonce nA, appends her identity A,\nencrypts the result with B\u2019s public key, and sends it to B.\nUser B is able to decrypt the message and obtain the nonce\nnA. He sends it back to A, together with his own newly in-\nvented nonce nB, all encrypted with A\u2019s public key. A de-\ncrypts this response, and responds by sending B\u2019s nonce\nback. The intention is that at the end, A and B have each\nauthenticated their identity to the other.\nLowe\u2019s attack describes a scenario in which user A\u2019s le-\ngitimate initiation of the protocol with I is used to initiate a\nprotocol run with B where B acts as if the other partner is A:\n     A \u0096 I    :    pI(nA.A)\nI(A) \u0096 B    :    pB(nA.A)\nB \u0096 I(A)    :    pA(nA.nB)\n     I \u0096 A    :    pA(nA.nB)\n     A \u0096 I    :    pI(nB)\nI(A) \u0096 B    :    pB(nB)\nHere I(A) denotes agent I impersonating A, either generat-\ning a message that appears to B to have come from A, or\nintercepting a message addressed to A. The end result of\nthis interchange of messages is that A believes she has es-\ntablished a session with I, and B believes he has established\na session with A.\nLowe suggests an amendment to the protocol, requir-\ning that the second message contains the responder\u2019s\nidentity explicitly. The amended version, which will be\nused as the running example throughout this paper, is\ndescribed as follows:\nA \u0096 B    :    pB(nA.A)\n      B \u0096 A    :    pA(nA.nB.B)\n      A \u0096 B    :    pB(nB)\nThis amendment foils the attack above, but the question\narises as to whether it is open to other attacks.\nThe structure of this paper is as follows. Section 2 intro-\nduces the CSP notation and theory which underpins this\napproach. Section 3 describes the way CSP is used to model\nand analyse security protocols and authentication proper-\nties, and presents the general approach to verification. Sec-\ntion 4 illustrates the approach through a verification of the\namended Needham-Schroeder public-key protocol. Section\n5 discusses how the approach might also be applied to con-\nfidentiality properties. Section 6 provides a general discus-\nsion and comparison with other approaches.\n2 CSP NOTATION\nCSP is an abstract language designed specifically for the\ndescription of communication patterns of concurrent sys-\ntem components that interact through message passing. It is\nunderpinned by a theory which supports analysis of sys-\ntems described in CSP. It is, therefore, well suited to the\ndescription and analysis of network protocols: protocols\ncan be described within CSP, as can the relevant aspects of\nthe network. Their interactions can be investigated, and\ncertain aspects of their behavior can be verified through use\nof the theory. Section 2 introduces the notation and ideas\nused in this paper. In particular, only the traces model for\nCSP is used here. For a fuller introduction to the language\nthe reader is referred to [7], [21].\n2.1 Events\nSystems are modeled in terms of the events that they can\nperform. The set of all possible events (fixed at the begin-\nning of the analysis) is denoted S. Events may be atomic in\nstructure or may consist of a number of distinct compo-\nnents. For example, an event put.5 consists of two parts: a\nchannel name put, and a data value 5. An example of events\nused in this paper are those of the form c.i.j.m consisting of\na channel c, a source i, a destination j, and a message m. If\nM and N are sets of messages, then M.N will be the set of\nmessages {m.n | m \u00b6 M ` n \u00b6 N}. If m is a single message\nthen we elide the set brackets and define m.N to be {m}. N.\nThus for example the set of messages i.N.m = {i.n.m | n \u00b6 N}.\nA channel c is said to be of type M if any event c.m \u00b6 S has\nthat m \u00b6 M.\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 743\n2.2 Processes\nProcesses are the components of systems. They are the enti-\nties that are described using CSP, and they are described in\nterms of the possible events that they may engage in. The\nprocess Stop is the process that can engage in no events at\nall; it is equivalent to deadlock. The output c!v \u0096 P is able\ninitially to perform only c.v, the output of v on channel c,\nafter which it behaves as P. The input c?x : T \u0096 P(x) can\naccept any input x of type T along channel c, following\nwhich it behaves as P(x). Its first event will be any event of\nthe form c.t where t \u00b6 T. The process P \u0090 Q (pronounced \u2018P\nchoice Q\u2019) can behave either as P or as Q: Its possible com-\nmunications are those of P and those of Q. An indexed form\nof choice \u0090i\u00b6I Pi is able to behave as any of its arguments Pi.\nProcesses may also be composed in parallel. If D is a set\nof events then the process P u[D]u Q behaves as P and Q\nacting concurrently, with the requirement that they have to\nsynchronize on any event in the synchronization set D;\nevents not in D may be performed by either process inde-\npendently of the other. A special form of parallel operator\nin which the two components do not interact on any events\nis P ||| Q which is equivalent to P u[{}]u Q.\nProcesses may be recursively defined by means of equa-\ntional definitions. Process names must appear on the left-\nhand side of such definitions, and CSP expressions which\nmay include those names appear on the right-hand side.\nFor example, the definition\nLIGHT on off LIGHT= \u2192 \u2192\u0302\ndefines a process LIGHT whose only possible behavior is to\nperform on and off alternately.\nMutually recursive processes may also be defined, where\na (possibly infinite) collection of process names Xk appear\non the left-hand side of definitions, and CSP expressions\nFk(X) possibly involving any of those names appear on the\nright. For example, the set of definitions\nCOUNT up COUNT\nCOUNT up COUNT\ndown COUNT\nn n\nn\n0 1\n1 2\n= \u2192\n= \u2192\n\u2192\n+ +\n\u0302\n\u0302 ( )\nh\ndefine a collection of processes; COUNT0 can do any num-\nber of up and down events, but can never do more downs\nthan ups.\nProcess definitions may also contain conditions to sepa-\nrate different cases. The collection of COUNT definitions\ncould be given as\nCOUNT\nup COUNT m\nup COUNT\ndown COUNT\nm\nm\nm\nm\n=\n\u2192 =\n\u2192\n\u2192\n+\n+\n\u2212\n\u0302\n1\n1\n1\n0if\n( )\notherwiseh\nor could be given by COUNT F COUNTm m=\u0302 ( )), where\nF COUNT\nup COUNT m\nup COUNT\ndown COUNT\nm\nm\nm\nm\n( )\nif\n( )\notherwise\n=\n\u2192 =\n\u2192\n\u2192\n+\n+\n\u2212\n\u0302\n1\n1\n1\n0\nh\nFor readability, subscripted information may also appear\nbracketed on the same line as its corresponding process: for\nexample, COUNTm may also be written as COUNT(m).\nFor a full discussion of single and mutually recursive\nprocess definitions, see [3].\n2.3 Traces\nThe semantics of a process P is defined to be the set of finite\nsequences of events or traces (traces(P)) that it may possibly\nperform. This set will always be nonempty, and prefix closed:\nIf tr is a possible trace of P, then so too is any prefix of tr. Ex-\namples of traces are \u00c9\u00d9 (the empty trace, which is possible for\nany process) and \u00c9on, off, on\u00d9 which is a possible trace of\nLIGHT. Concatenation of traces is described using the nota-\ntion tr1 X tr2, which is the sequence of events listed in tr1 fol-\nlowed by those in tr2. Any trace is of the form \u00c9\u00d9 or \u00c9a\u00d9 X tr\u2032\nwhere a is an event and tr\u2032  is the remainder of the trace.\nA useful operator on traces is projection: if D is a set of\nevents then the trace tr |) D is defined to be the maximal sub-\nsequence of tr all of whose events are drawn from D. If D is a\nsingleton set d then we overload notation and write tr |) d for\ntr |) {d}. Message extraction tr \u0097 C for a set of channel names C\nprovides the maximal sequence of messages passed on chan-\nnels C. Finally, tr \u02d9 C provides the set of messages in tr\npassed along the channels in C. These may be described in-\nductively on sequences, and the last by a set comprehension:\nkl kl\nkl kl\nkl\n|\n( )| ( | ) if\n( |` ) otherwise\n( )\n( ) if .\n( ) otherwise\n{ |( )| }\n)\nX )\nX )\nX\nX\n)\nD\nd tr D d tr D d D\ntr D\nC\nd tr C\nm tr C c C d c m\ntr C\ntr C m tr C m\n=\n=\n\u2208%&\u2019\n\u0015 =\n\u0015 = \u0015 \u2203 \u2208 \u2022 =\u0015\n%&\u2019\n\u0018 = \u0015 \u2260\nIf tr is a sequence, then s(tr) is the set of events appearing\nin the sequence. If an element a appears in the sequence tr,\nthen we write a tr. The operator s extends to processes: s(P)\nis the set of events that appear in some trace of P.\n2.4 Analyzing Processes\nSpecifications are given as predicates on traces, and a proc-\ness P satisfies a specification S (with tr as free variable) if all\nof its traces satisfy S:\nP sat S \u02c6 \" tr \u00b6 traces(P) \u009f S\nSpecifications are written with tr as the free trace variable.\nFor example,\nLIGHT sat s(tr) \u00b5 {on, off}\n2.5 Proof Rules\nThe traces model for CSP is associated with a proof system\nfor describing specifications on processes in terms of speci-\nfications on their components. There is a proof rule for each\nCSP operator, whose semantics in each case follows from\nthe trace semantics. For example, the rule for the prefix op-\nerator is\nP sat S\na \u0096 P sat (tr = \u00c9\u00d9 \u00b4\n                  tr = \u00c9a\u00d9 X tr\u2019 ` S[tr\u2019\/tr])\n744 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\nThe predicate S[tr\u008a\/tr] is S with all free occurrences of tr\nsubstituted by tr\u008a.\nParticular application domains are often concerned only\nwith particular forms of specification. It is often possible to\ngive more specialized proof rules for such specifications.\nThis amounts to developing a specialized theory and proof\nsystem for the application area. The benefits are that the full\ngenerality of the proof rules are not required, and that there\nwill often be lemmas and theorems, built on top of the\ntraces model, which allow higher-level reasoning. This is\nthe approach taken in this paper, where a key property\nmaintains r  used for verification is defined in terms of\ntraces, and various proof rules are provided for deducing\nwhen particular process descriptions meet this property. We\nwill see the specialized rules in Figs. 3, 4, and 5.\n2.6 Process Equivalences\nThe traces model for CSP supports a number of algebraic\nequivalences on processes, whose soundness follows from\nthe trace semantics. These are often useful in manipulating\nprocess descriptions into a form which is easier to reason\nabout. There are many laws expressing useful identities. For\nthe purposes of this paper, we will be interested in the effect\nof restricting particular events of a parallel combination P\nu[R]u Stop. This process restricts all of P\u2019s occurrences of\nevents from R, so it has precisely those traces of P that do not\ncontain any event from R. The equations are given in Fig. 1.\nFig. 1. Equations for restricted parallel combinations.\nRule restrict.1 states that restricting a process on a\nset of events R that it cannot perform has no effect. Rule\nrestrict.2 states that restricting a process on a set of\nevents distributes over interleaving.\nRules restrict.3 and restrict.4 are concerned with\nthe effect of a restriction on inputs and outputs.\nThese equations are used throughout the paper when-\never a process of the form USERAu[R]u Stop is expanded.\nThey will not be referred to explicitly when used, in order\nto avoid cluttering proofs.\n3 THE GENERAL CSP MODEL\n3.1 The CSP Network Description\nThe approach taken is to provide a CSP description of a\ngeneralization of the Dolev-Yao model [5]. Here it is as-\nsumed that the communications medium is entirely under\nthe control of the enemy, which can block, readdress, dupli-\ncate, and fake messages. We will define a \u2018generates\u2019 rela-\ntion \u00a3 which describes when new messages may be derived\nfrom existing ones: S \u00a3 m means that knowledge of all the\nmessages in S is sufficient to produce m. This will be used\nto capture the enemy\u2019s ability to fake messages. In [22] the\nroles of the passive medium and of the active enemy were\ndescribed using distinct CSP processes which enabled the\ncapabilities of the enemy to be separately described. For the\npurposes of the approach to verification taken in this paper\nit is preferable to describe the combination of the enemy\nand the medium as a single CSP process ENEMY, since this\nmakes for an easier analysis.\nThere is a (finite) set USER consisting of the names of all\nthe agents which use the network. For each i \u00b6 USER we\nassociate a process USERi which describes how user i be-\nhaves. Each process USERi communicates with ENEMY by\nmeans of a channel trans.i on which it transmits messages,\nand a channel rec.i on which it receives messages. Thus, we\nhave s(USERi) \u00b5 trans.i < rec.i, where trans.i is shorthand\nfor trans.i.USER.MESSAGE and trans.j is shorthand for\ntrans.j.USER.MESSAGE.\nThe resulting network is then described as follows:\nNET USER trans rec ENEMYj USER j= \u2208(||| )|[ , ]|\nThis network is pictured in Fig. 2.\nFig. 2. CSP model of the network.\nIn the analysis of a protocol we might consider A and B\nas the two parties involved in the protocol, and the proc-\nesses USERA and USERB will describe the respective roles\nthat they play.\nIf there are actually no other users connected to the sys-\ntem, then we can have USERi = Stop for each i \u00a1 A B and we\nobtain\nNET USER USER trans rec ENEMYA B= ( ||| )|[ , ]|\nWe retain the names of other users in the set USER to retain\nthe potential of the ENEMY to masquerade as a genuine user.\nThe channels trans and rec are of type USER.USER. MES-\nSAGE. An event trans.i.j.m models an occurrence of node i\nsending a message m with destination j, and an event rec.j.i.m\nmodels an occurrence of node j receiving a message m with\nsource i. Thus, i is the source, j the destination, and m the\nmessage. The message space MESSAGE will generally be\ndefined by a context-free grammar, as in Section 3.1.3.\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 745\nRefusals have been abstracted away, in the sense that in-\nput can never be refused. This amounts to making the as-\nsumption that the enemy can deduce nothing from how or\nwhen the messages are accepted. This is a reasonable as-\nsumption, since there are protocols currently in use to per-\nform tasks such as masking network traffic. Hence, at this\nlevel of abstraction we can assume that messages are al-\nways accepted by the network. (If this is later felt to be un-\nrealistic, the definition can be altered accordingly, so that\nmessages may not be input after the number of messages in\nthe network reaches some threshold.) Attacks on protocols\n(apart from denial of service attacks) tend to exploit unex-\npected interactions between messages, and the traces model\nis adequate for capturing these.\n3.1.1 Description of ENEMY\nThe capabilities of the enemy can be captured within a de-\nscription that controls all trans.i and rec.i channels. Dolev\nand Yao first formalized this kind of attacker in [5]. It is able\nto accept any message output by any user, and it can also\nprovide to any user any input that it is able to generate. In\nparticular, this description gives the enemy the capability of\nredirecting, spoofing, replaying and blocking messages, as\nwell as delivering them normally.\nENEMY S\ntrans i j m ENEMY S m\nrec i j m ENEMY Sj j USER S m\n( )\n? ? ? ( { })\n. ! ! ( ), , |_\n=\n\u2192\n\u2192\u2208\n<\nh\nh\n           (1)\nThe argument S is the set of messages in the possession of\nthe enemy. It is augmented every time some input occurs,\nand the messages m that may be output to agents are those\nthat can be generated from S. This is written S \u00a3 m, where \u00a3\nwill be defined in Section 3.1.4. In the output branch of the\nchoice, an arbitrary user i is chosen, and a message is out-\nput to him along his rec.i channel.\nThe set of messages initially in the possession of the en-\nemy will be given as a set INIT, and so ENEMY = ENEMY\n(INIT).\nThe enemy also subsumes the actions of other subverted\nor dishonest users by including their initial knowledge\n(such as their private keys) in the set INIT.\n3.1.2 Protocol Participants\nThe agents implementing the protocols place restrictions on\nthe messages that may be passed on trans, which in turn\nrestrict the possibilities for messages being passed on rec.\nThe agents A and B that are the participants in the proto-\ncol are modeled as USERA and USERB, consisting of CSP\nimplementations of the two halves of the protocol. More\ngenerally, if there are other participants (such as trusted\nthird parties) then their activity will also be described as\nCSP processes. Obviously their description will depend\nentirely on the protocol being modeled.\nThe agents A and B which implement a run of the\namended Needham-Schroeder protocol may be modeled in\nCSP as the processes USERA and USERB below. For the\npurposes of illustrating the approach, we will first simplify\nthe analysis by considering only the case where A is the\ninitiator and B is the receiver. This model does not allow for\nattacks where both parties act as initiators, or as receivers.\nThis restriction will be relaxed in Section 4.2, where we con-\nsider the fully general case of each participant taking either\nrole, and potentially engaging in multiple concurrent runs\nof the protocol.\nUSER\ntrans A i p n A\nrec A i p n x i\ntrans A i p x Stop\nA i USER\ni A\nA A\ni\n=\n\u2192\n\u2192\n\u2192\n\u2208h\n. ! ! ( . )\n. . ? ( . . )\n. ! ! ( )\n         (2)\nUSER rec B j p y j\ntrans B j p y n B\nrec B j p n Stop\nB B\nj B\nB B\n= \u2192\n\u2192\n\u2192\n. ? ? ( . )\n. ! ! ( . . )\n. . . ( )\n            (3)\n3.1.3 Message Space\nThe message space we use for analysis of this protocol can\nbe considered as the language generated by the following\ncontext-free grammar:\n                              RAW ::= USER | TEXT\n            | NONCE | KEY\nMESSAGE ::= RAW | KEY(MESSAGE)\n                                             | MESSAGE.MESSAGE\nIn fact for this example using public-key cryptography, the\nspace KEY will split into public keys PUBLIC and secret\nkeys SECRET, one of each for each user in USER:\nKEY ::= PUBLIC | SECRET\nWe will adopt the following notational convention: u \u00b6\nUSER, r \u00b6 RAW, t \u00b6 TEXT, ni \u00b6 NONCE, pi \u00b6 PUBLIC, si \u00b6\nSECRET, and m \u00b6 MESSAGE.\n3.1.4 The \u2018Generates\u2019 Relation \u00a3\nWe have rules which encapsulate the properties of public\nkey cryptography, which describe the way messages may\nbe generated from existing ones. These rules define the\ngenerates relation \u00a3.\nA1  If m \u00b6 S then S \u00a3 m\nA2  If S \u00a3 m and S \u00b5 S\u008a then S\u008a \u00a3 m\nA3  If S \u00a3 mi for each mi \u00b6 S\u008a and S\u008a \u00a3 m then S \u00a3 m\nM1  If S \u00a3 m and S \u00a3 k then S \u00a3 k(m)\nM2  S \u00a3 m1 and S \u00a3 m2 if and only if S \u00a3 m1.m2\nWe are now in a position to prove that all messages passed\non rec must be generable from the initial set INIT together\nwith the messages input on trans:\nTHEOREM 3.1.\nENEMY    sat    (INIT < (tr \u02d9 trans)) \u00a3 tr \u02d9 rec\nPROOF. We can prove easily by a mutual recursion induc-\ntion that\nENEMY(S) sat S < (tr \u02d9 trans) \u00a3 tr \u02d9 rec\nThe result follows from the fact that ENEMY =\u0302\nENEMY(INIT). o\n746 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\n3.1.5 Equations\nWe might also have equations on the message space. Some\nnatural ones would be those describing the relationship\nbetween encryption and decryption:\nE1        pA sA(m)) = sA(pA(m)) = m\nThere would also be properties such as associativity of\ncatenation:\nE2        m1.(m2.m3) = (m1.m2).m3\nEquations could also capture possible properties of encryp-\ntion mechanisms. For example, commutativity of encryp-\ntion is sometimes a necessary property (such as that re-\nquired for Diffie-Hellman key exchange).\nE3        k1(k2(m)) = k2(k1(m))\nWe will assume for the rest of this paper that (E1) and\n(E2) are the only equations on the message space unless\nexplicitly stated otherwise. We will write m1 =E m2 if m1 and\nm2 are equivalent under E1 and E2.\nWe will also assume and that A1\u2014A3 and M1\u2014M2 de-\nfine the relation \u00a3.\n3.1.6 Modeling Issues\nThere are a number of issues concerning the way the protocol\nhas been modeled. The use of pattern matching on message\ninput corresponds to the assumption that any message that\nfails to match the pattern would be ignored, though we are\nmodelling this as blocking receipt rather than accepting and\nthrowing it away: the USERi processes simply do not accept\nany message which does not match the pattern. In practice,\nthis is unlikely to be achievable, especially in cases where an\nagent must decrypt a message before finding out if it is of a\nparticular form. However, it does not affect the ability of the\nenemy to attack protocols described in this way.\nTyping of messages is also implicit in pattern matching.\nThe type of the channel determines the range of possible\nmessages that might match the pattern. The permissible\ninput for the code fragment rec.A.i?pA(nA.x) \u0096 \u2044 described\nin line 2 of USERA depends on the type of x. A correct run\nof the protocol would have x as a nonce, but without the\nability to type messages the input could accept an arbitrary\nmessage for x. For the purposes of this paper, we will as-\nsume that inputs defined by pattern matching must also\nconform to the expected type. This amounts to assuming\nthat it is not possible for a message of one type to be mis-\ntaken for a message of another type.\nIn line 2 the pattern matching amounts to any message of\nthe form pA(nA.x.i) being accepted for any nonce x, provided i\nmatches the i chosen as the destination of the first message.\nFreshness of nonces nA and nB is captured in the fact that\nneither of them appears in INIT, and in the fact that the defi-\nnition of the generates relation \u00a3 does not have any clause\npertaining to generation of nonces. In other words, an agent\n(or the enemy) can generate a nonce only if it is already in his\npossession. The generation of a fresh nonce is modeled by\nmaking it known initially only to a single agent\u2014only that\nagent is able to produce it. Of course, this is for analysis pur-\nposes only; in practice, nonces will be produced by mecha-\nnisms such as random number generation.\nThe apparent source j of B\u2019s first message (line 3) must\nmatch the source given in the message itself, since that in-\nformation is the only information B has concerning the\noriginator of the protocol.\n3.2 Authentication\nA message-oriented approach to authentication is discussed\nin [22]. Authentication will be captured in terms of events\n(generally transmission and receipt of particular messages)\nwhose occurrence guarantees the prior occurrence of other\nmessages. An authentication protocol generally achieves its\naims by allowing a participant to infer from receipt of a\nmessage that the other party must have previously been\ninvolved in the protocol run. The key property is concerned\nwith precedence between events: any element of a set of\nevents T must have been preceded by occurrence of some\nelement from the set of events R. This is captured as a speci-\nfication as follows:\nDEFINITION 3.2.\nR T tr R tr Tprecedes = = \u21d2 =\u0302 | |) )kl kl\nA number of aspects of authentication can be captured in\nthis style: Data origin authentication allows B to confirm that\nthe response to his nonce challenge really was generated by\nA, who knows she is talking to B. This is captured by the\nspecification \u2018trans.A.B.pB(nB) precedes rec.B.A.pB(nB)\u2018. Re-\nceipt by B of the message pB(nB) guarantees that A trans-\nmitted it earlier to B. This property will be the one verified\nin Section 4 of this paper.\nThis property may also be considered as describing peer\nentity authentication, provided freshness could also be es-\ntablished, since it would provide a guarantee that at the time\nof the protocol run it was indeed A communicating with B.\nFreshness could be expressed by the requirement that\ntrans.A.B.pB(nB) must occur after the beginning of the proto-\ncol run, and hence that it is preceded by trans.A.B.pB(nA.A).\nThis latter property is easily verified by an examination of\nUSERA.\nA weaker version of peer entity authentication might\nhave B simply requiring confirmation of the identity of A.\nThis might be captured by the specification \u2018{trans.A.j.pj(nB)| j \u2208 USER} precedes rec.B.A.pB(nB)\u2019. On receipt of the re-\nsponse to the nonce challenge, B can confirm that A did\nindeed respond to the nonce challenge, but possibly to a\ndifferent agent. Again, freshness should also be established.\nData origin authentication for B\u2019s message is captured by\nthe specification\n     \"n : NONCE \u009f trans.B.A.pA(nA.n.B)\n                                     precedes rec.A.B.pA(nA.n.B)\nOn receipt of any response to her nonce challenge, A con-\nfirms that the response was generated by B and B knows\nthat he is talking to A.\nOne benefit of this approach is that it supports the expres-\nsion of different authentication requirements rather than at-\ntempting to provide a definitive version of \u201cauthentication.\u201d\nThe following lemma is an immediate consequence of\nthe definition. This is useful for relating the rank function\napproach to the authentication properties.\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 747\nLEMMA 3.3.\nP sat R precedes T \u02c6\n                 P u[R]u Stop sat tr |) T = kl\nThe CSP trace semantics also support a number of spe-\ncialized proof rules for establishing when particular proc-\nesses provide specific precedes properties. Those used in\nthis paper are given in Figs. 3 and 4.\nThe soundness of the rules follows from the trace se-\nmantics of the operators and the formal definition of R\nprecedes T. We may give informal justification of their\nsoundness by considering that occurrence of an event\nfrom T is intended to provide evidence that some event\nfrom R previously occurred. Hence a process fails to sat-\nisfy R precedes T only when it is possible for some event\nfrom T to occur before any event from R.\nRule auth.stop is therefore sound because Stop cannot\nperform any events at all, and so cannot perform some T\nbefore any R.\nRule auth.prefix.1 is sound because if the very first\nevent a performed by a \u0096 P is an event from R, then it is\nnot possible for an event from T to occur before an event\nfrom R. This is independent of the nature of the subsequent\nprocess P, which therefore has no restrictions placed on it\nby the rule\u2014the rule is applicable for any process P.\nRule auth.prefix.2 is most useful when the event a is\nnot in R, since otherwise auth.prefix.1 is applicable. In\nthis case it states that if the first event is not in T, then oc-\ncurrence of a is irrelevant to authentication of R by T, and\nsuch authentication is guaranteed for a \u0096 P whenever it is\nguaranteed for P.\nRule auth.choice states that if each branch of a choice\nguarantees the authentication property R precedes T, then\nso does the entire choice\u2014since whenever some event from\nT occurs, it must have been performed by one of the arms\nof the choice, and that choice must previously have per-\nformed some event from R.\nRule auth.parallel states that if a single component P\nof a parallel combination is able to guarantee that R pre-\ncedes T, and it is involved in all occurrences of events from\nT, then that is enough to ensure that the entire parallel\ncombination P u[A]u Q guarantees it: P will not allow any\nevent from T to occur before an event from R occurs. There\nare no restrictions on the rest of the system Q, so the rule\nholds for any process description Q.\nRule auth.interleaves states that if both components\nof an interleaved combination can guarantee R precedes T,\nthen the combination itself can. This follows from the fact\nthat if some event from T occurs, then it must have been\nperformed by one of the component processes, which must\nhave previously performed an event from R.\nFinally, the rule auth.recursion for mutually recursive\nprocesses states that if the property R precedes T is pre-\nserved by recursive calls then it holds for the recursively de-\nfined process. This rule is a special case of the general rule for\nrecursion; for further details, see the discussion in [3].\n3.3 General Proof Strategy\n3.3.1 Rank Functions\nIn order to prove that a network meets a particular authen-\ntication property expressed as R preceding T, it will be nec-\nessary to establish that no event in T can be generated any-\nwhere in the system if all occurrences of events in R are\nblocked. A rank function r : MESSAGES \u0096 Z on messages\nwill be used to establish this. The intention is that the value\nassociated with any message that can circulate in the net-\nwork should be strictly positive; and that the values associ-\nated with messages appearing as parts of events in T\nshould be 0 or less.\nIf r : MESSAGE \u0096 Z is a function defined on messages,\nthen we lift it to sets of messages S and sequences of mes-\nsages seq as follows:\nFig. 3. Proof rules for authentication: prefix and choice.\nFig. 4. Proof rules for authentication: parallel and recursion.\n748 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\n                             r(S) = min {r(s) | s \u00b6 S}\nr(seq) = min {r(m) | c.m in seq}\nThe rank of an event c.m is the rank of the message m.\nThe definition of r must respect the equations on the\nspace of messages in order to be well-defined. In the case of\nthis paper this means that it should respect E1 and E2.\nThe property required by each component is that it can-\nnot introduce any message whose rank is less than 1. In\nother words, if all it has ever received is messages of strictly\npositive rank, then so should it has ever transmitted. This\nproperty may be captured as a specification maintains r\non traces:\nDEFINITION 3.4.\nmaintains \u03c1\n\u03c1 \u03c1\n=\n\u0018 > \u21d2 >\n\u0302\n( ) ( | )tr rec tr trans0 0)\nObserve that this is parameterized by the rank func-\ntion r.\nIf USERi meets this specification then it cannot introduce\na message of rank 0 or less into the system (along channel\ntrans.i) if there was not one already present (which was re-\nceived along channel rec.i).\nThe following theorem is at the heart of the proof strat-\negy presented in this paper.\nTHEOREM 3.5. If\nR1:  \"m \u00b6 INIT \u009f r(m) \u009b 1\nR2:  \"S, m \u009f\n        ((\" s \u00b6 S \u009f r(s) \u009b 1) ` S \u00a3 m \u02d8 r(m) \u009b 1)\nR3:  \"t \u00b6 T \u009f r(t) \u008b 0\nR4:  (USERi |[R]| Stop sat maintans r) for each user i\nthen NET sat R precedes T\nThe proof of this theorem appears in Appendix A.\nThe requirements of the theorem combine to establish\nthat only messages of strictly positive rank can circulate in\nNET |[R] Stop, and hence that nothing in T can be gener-\nated if all events in R are blocked. This means that any oc-\ncurrence of an event in T indicates that an event in R must\nhave occurred previously.\nThe theorem describes a number of key properties re-\nquired of the rank function. Properties R1 and R2 together\nyield the result that the enemy cannot introduce messages\nwhich fail to meet preserve strictly positive rank: if the en-\nemy begins with such messages, and only ever sees mes-\nsages of strictly positive rank, then only such messages can\nbe generated. Property R4 provides the same guarantee for\nall of the users. Property R3 is used to deduce that no event\nfrom T can, therefore, be generated.\nObserve that the construction of a suitable rank function\nis dependent on R and T as well as the descriptions of the\nusers. In other words, it is dependent both on the protocol\nand on the particular property to be established.\n3.3.2 Proof Obligations\nTheorem 3.5 relies on the assumption that\n\"i \u009f s(USERi) >  (trans < rec) \u00b5 trans.i < rec.i\ni.e., that no user except USERi has any interaction with\nENEMY on the channels trans.i or rec.i. This assumption is\nbuilt into the way we are modeling the network.\nAs discussed earlier, authentication properties expressed\nin CSP are in the form \u2018R precedes T,\u2019 meaning that if some\nevent from T occurs then some event from R must previ-\nously have occurred. Generally T will be a set of possible\ninputs which might be received at a particular node, pro-\nviding evidence of the occurrence of one of a set of outputs\nR at a different node.\nThe proof strategy we adopt is to show that if all occur-\nrences of events R are prevented in NET, then the events in\nT is not possible. In other words, we aim to show that the\nevents in T cannot be generated by the resulting system\ndescription NET |[R]| Stop.\nTo apply Theorem 3.5 we must meet the list of require-\nments R1 to R4. Some of these correspond to assumptions\nwhich we must be confident can be made, and others are\nproof obligations.\nItem R1 is an assumption on the enemy, and confidence\nin it will depend on the nature of r, and on the messages\nthat have nonpositive rank.\nItem R2 must be checked, and may be established by an\ninduction over the definition of the generates relation \u00a3. It\ntherefore relies on the fact that the clauses defining \u00a3 com-\npletely determine which messages can be generated from\nalready known ones. Item R3 must be shown for the par-\nticular set T. Item R4 must be proven for the cases (R4a):\nUSERA |[R]| Stop and (R4b): USERB |[R]} Stop.\n3.3.3 Specialized CSP Proof Rules\nThere are also a number of rules which can be given con-\ncerning the relationship between various CSP operators and\nthe maintains r specification. These are given in Fig. 5.\nThey are all sound with respect to the CSP traces model.\nTogether with the equations of Fig. 1 they will be used in\nestablishing R4a and R4b in various cases.\nInformally, their soundness can be justified as follows.\nRule stop is sound because Stop is unable to violate main-\ntains r since to do so requires an output of a message of\nnonpositive rank, and Stop can perform no output. Rule\noutput states that if the first output provided by a process\nhas positive rank, then the process satisfies maintains\nprovided that the behavior after this first output does not\nviolate it.\nRule input is concerned with the behavior of a process\nsubsequent to an input. The requirement to maintain posi-\ntive rank is concerned that if messages coming in have\npositive rank, then the messages going out should also\nhave positive rank. For a particular incoming message,\nthere are therefore two cases to consider: if the input mes-\nsage f(x) has rank 0 or less, then the subsequent behavior is\nirrelevant since responsibility for maintaining positive rank\nis no longer required; and if the message f x) input has\npositive rank, then the subsequent process P(j, x) should\nmaintain positive rank. Hence the rule states that the input\nprocess rec.i?j?f(x) \u0096 P(j, x) satisfies maintains r whenever\nP(j, x) does so after an input of positive rank. The form of\nthe input f (x) describes the pattern matching implicit in the\ninput process: f describes the input patterns allowed.\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 749\nFinally, rule choice states that if each branch of a choice\nmaintains positive rank, then so does the entire choice.\n4 ANALYSIS OF THE AMENDED\nNEEDHAM-SCHROEDER PROTOCOL\nThe protocol to be analyzed is as described in Section 1:\n                                 A \u0096 B    :    pB(nA.A)\nB \u0096 A    :    pA(nA.nB.B)\n                                 A \u0096 B    :    pB(nB)\nThe property to be proved as an illustration of the ap-\nproach is that receipt by B from A of the message pB(nB)\nguarantees that A previously sent that message to B. This is\nexpressed as the CSP specification\ntrans.A.B.pB(nB) precedes rec.B.A.pB(nB)\nThis may be considered as an entity authentication prop-\nerty, establishing that B can be sure he is in communication\nwith A. It can also be considered as a data origin authenti-\ncation property, establishing for B that the source of the\nmessage pB(nB) must be A.\n4.1 Proof\nIn order to establish that a run of this protocol has\ntrans.A.B.pB(nB) guaranteed by rec.B.A.pB(nB) we use the CSP\ndescription\nUSER trans A i p n A\nrec A i p n x i\ntrans A i p x Stop\nA i USER i A\nA A\ni\n= \u2192\n\u2192\n\u2192\n\u2208h . ! ! ( . )\n. . ? ( . . )\n. ! ! ( )\n            \nUSER rec B A p y A\ntrans B A p y n B\nrec B A p n Stop\nB B\nA B\nB B\n= \u2192\n\u2192\n\u2192\n. . ? ( . )\n. ! ! ( . . )\n. . . ( )\nThe property of user B authenticating user A sending\npB(nB) requires that if B engages in the protocol as if A is the\ninitiator, then A is indeed the initiator.\nHence, we are interested only in those executions of B\nwhich begin with some message of the form rec.B.A.m,\nwhere the source of message m appears to be A. The de-\nscription required for the analysis is the description USERB\nunder the restriction that B takes the first message to have\nA as its source.\nThe rank function described in Fig. 6 is suitable for an\napplication of Theorem 3.5: it meets properties R1 \u00e6 \u00e6 \u00e6 \u00e6-R4. In\nparticular\nR4a     USERA|[trans.A.B.pB(nB)]| Stop\n                  sat maintains r\nR4b  Since trans.A.B.pB(nB) \u2022 s (USERB), it follows that\n         USERB |[trans.A.B.pB(nB)]|Stop = USERB, so we\n         have only to prove\nUserB sat maintains r\nEach of the properties must be examined in turn.\nFig. 6. Rank function for verification of Lowe\u2019s amended protocol.\nWell-definedness of r. Since r is defined on the struc-\nture of the messages, it is necessary to check that any equa-\ntions on the message space hold: any two forms of the same\nmessage must have the same rank.\nFig. 5. Proof rules for maintains r.\n750 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\nIt is immediate from the definition of r that equations E1\nand E2 both hold:\nr(pi(si(m))) = r(si(pi(m))) = r(m)\nand\nr(m1.(m2.m3)) = r((m1.m2).m3)\nR1. We assume that \"m \u00b6 INIT \u009f r(m) \u009b 1. This is a rea-\nsonable assumption, amounting to the claim that the enemy\ndoes not initially have access to sA, sB, or nB, or messages\nconstructed from these.\nR2. We obtain the following result from a consideration\nof each clause in turn of the definition of \u00a3: A1\u2013A3, M1\u2013M2.\nThe result follows from the fact that \u00a3 is defined to be the\nsmallest relation closed under all of the clauses.\n(\" s \u00b6 S \u009f r(s) \u009b 1) ` S \u00a3 m \u02d8 r(m) \u009b 1\nR3. Observe that r(pB(nB)) = 0.\nR4a (USERA). We want to establish that\nUSERA| [trans.A.B.pB(nB)]| Stop\n                                sat  maintains r\nFor a given x \u00b6 NONCE, either x \u00a1 nB or x = nB.\nIf x \u00a1 nB it follows that r(x) \u009b 1 and so r(pi(x)) \u009b 1 (for any\ni), and hence that\ntrans.A!i!pi(x) Stop\u0096 sat maintains r              (4)\nFor the second case it is immediate that Stop sat maintains\nr.\nHence, we have that\ntrans A i p x Stop x n\nStop x n\ni B\nB\n. ! ! ( ) if\nif\n\u2192 \u2260\n=\n\u0019\n\u001b\u001a\n\u001c\n\u001e\u001d\nsat maintains \u03c1\nThis provides the antecedent for Rule input to yield\nrec A i p n x i\ntrans A i p x Stop x n\nStop x n\nA A\ni B\nB\n. . ? ( . . )\n. ! ! ( ) if\nif\n\u2192\n\u2192 \u2260\n=\n\u0019\n\u001b\u001a\n\u001c\n\u001e\u001d\nsat maintains \u03c1\nAnd so from Rule output (since r(pi(nA.A)) \u009b 1) we have for\nany i that\ntrans A i p n A\nrec A i p n x i\ntrans A i p x Stop x n\nStop x n\ni A\nA A\ni B\nB\n. ! ! ( . )\n. . ? ( . . )\n. ! ! ( ) if\nif\n\u2192\n\u2192\n\u2192 \u2260\n=\n\u0019\n\u001b\u001a\n\u001c\n\u001e\u001d\nsat maintains \u03c1\n            (5)\nFinally we obtain from Rule choice that\nhi USER\ni A\nA A\ni B\nB\ntrans A i p n A\nrec A i p n x i\ntrans A i p x Stop x n\nStop x n\n\u2208\n\u2192\n\u2192\n\u2192 \u2260\n=\n\u0019\n\u001b\u001a\n\u001c\n\u001e\u001d\n. ! ! ( . )\n. . ? ( . . )\n. ! ! ( ) if\nif\nsat maintains \u03c1\nSince this process is equivalent to USERA\n|[trans.A.B.pB(nB)]| Stop by the rules of Fig. 1, the proof is\ncomplete.\nR4b (USERB). Rule stop and Rule input (with trivial\nantecedent) yield that\nrec.B.A.pB(nB) \u0096 Stop\nsat     maintains r                             (6)\nNow for any nonce y r(pB(y.A)) \u009b 1 implies that r(y) \u009b 1\nwhich in turn implies that r(pA(y.nB.B)) \u009b 1, we obtain from\nRule output that\nr(pB(y.A)) \u009b 1 \u02d8\n       trans.B!A!pA(y.nB.B) \u0096\n    rec.B.A.pB(nB) \u0096 Stop\n                         sat maintains r                               (7)\nThis provides the antecedent for Rule input to yield\nrec.B.A?pB(y.A) \u0096\n   trans.B!A!pA(y.nB.B) \u0096\n      rec.B.A.pB(nB) \u0096 Stop\n                          sat maintains r\nor in other words USERB sat maintains r, as required.\nThis completes the proof that the occurrence of\nrec.B.A.pB(nB) guarantees the prior occurrence of\ntrans.A.B.pB(nB): B\u2019s receipt of nB encrypted under his own\npublic key provides evidence that A transmitted the mes-\nsage trans.A.B.pB(nB).\nThe properties of r that were used in the proof, as side-\nconditions to the proof rules, were\n1)\u0003 r(pA(nA.x.i)) \u009b 1 ` x \u00a1 nB ` x \u00b6 NONCE \u02d8 r(pi(x)) \u009b 1\nfor any i (used to obtain line 4);\n2)\u0003 r(pi(nA.A)) \u009b 1 for all i (used to obtain line 5);\n3)\u0003 r(y) \u009b 1 ` y \u00b6 NONCE \u02d8 r(pA(y.nB.B)) \u009b 1 (used to\nobtain line 7);\n4)\u0003 \" m \u00b6 INIT \u009f r(m) \u009b 1 (required for R1);\n5)\u0003 r(pB(nB)) = 0 (required for R3)\nProperties (1) and (3) use the fact that x and y are as-\nsumed to be nonces (rather than arbitrary messages), as\ndiscussed below.\nObserve that the proof works even if r(sB) = 1. This\nmeans that A can be authenticated to B even if B\u2019s own se-\ncret key is compromised. This is reasonable, since the fact\nthat sB is known only to B is really required by A rather\nthan by B.\n4.1.1 An Aside on Typing\nThe proof above uses the fact that messages are typed: the\npattern matching built into the analysis of USERA\n|[trans.A.B.pB(nB)] | Stop assumes that all inputs that\nUSERA will accept on rec.A will be of the form\ni.pA(NONCE.NONCE.i). In other words, the description of\nUSERA assumes that the message i.pA(nA.x.i) will be rejected\nunless x is a nonce.\nIn fact, the minimal assumption required is simply that\nuser A is able to recognize a message of the form pA(nA.x.i)\nfor arbitrary messages x, and to extract the message x from\nthis. The approach is still applicable, but at the cost of\nadded complexity. The CSP descriptions of the processes\nwill be more general since they will permit more inputs,\nand so the rank function will have to be preserved under\nmore general conditions. For example, an untyped USERB\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 751\nwhich can accept any message y (rather than any nonce y)\ndoes not preserve the rank function of Fig. 6 since it can\naccept pB(nA.nC.A) which has rank 1 and then transmit\npA(nA.nC.nB.B) which has rank 0.\nIn fact, the protocol is still secure, but the rank function\nrequired to establish this is more complicated. In fact, two\nrank functions are needed, to cover the two cases where A\nhas chosen to send to B, and where A has chosen to send to\na user other than B (as explained in Section 5). Their con-\nstruction is left as an exercise for the interested reader.\nA verification of the general untyped case will establish\nthat there are no attacks which can exploit type confusion\nbetween messages. A verification restricted to typed mes-\nsages will be more straightforward (and sometimes possible\nwhen the general case is not), but should be accompanied\nby the caveat that an implementation should be able to rec-\nognize the types of the messages it is dealing with.\n4.2 Multiple Runs\nAll the analysis performed above has been on a system\nwhere there is but a single run of the protocol between A\nand B, and where A and B take the roles of initiator and\nresponder, respectively. While it is possible informally to\ngeneralize the verifications to systems with repeated runs\nof the protocol, it is also possible to describe in CSP the\nsituation where agents perform multiple runs of the proto-\ncol and hence provide a formal verification. Analysis of a\nsingle run allows attention to be focused on the two par-\nticipants of the run. In the case where we have multiple\nruns, it is appropriate to model the two parties as able to\nengage in other runs with any other parties, and to restrict\ntheir behavior only for the protocol run under analysis. This\nis the approach that we shall take.\nOne issue to be addressed concerns the requirement to\nuse a fresh nonce on every protocol run. This may be\nmodeled in CSP by using an infinite sequence of nonces\nwhere nA,k and nB,k are used on the kth run of A and B, re-\nspectively. The kth run of the protocol will be defined in\nterms of what occurs during that run, and when the k +\n1th run can commence.\nThis requires a proof rule for recursive definitions, which\nis given in Fig. 7. Recursive definitions are of the form Nl =\u0302\nFl(N), where each Fl is a function on CSP process expressions,\ncontaining instances of various Nl process names. The rule\nstates that if it can be shown that each Fl(X) satisfies mrp from\nthe inductive assumption that all of the Xl satisfy maintains\nr, then we may conclude that each Nl in the recursive defini-\ntion does in fact satisfy maintains r (The base case of the\ninduction is that Stop satisfies maintains r, and this is al-\nready given by Rule stop of Fig. 5.).\nThe users are defined in terms of a mutual recursion. In\nthis case we model each user as being prepared either to\ninitiate or to respond to a fresh run of the protocol at any\nstage, independently of the number of runs it is already\ninvolved in at that time.\nThe protocol will be investigated as to whether an arbi-\ntrary run provides authentication\u2014such a run will be the\nkth run for some k.\nThe individual process names Nl will be given as\nUSERA(l) and USERB(l) for the two families of mutually\nrecursive definitions defining users A and B, respectively.\nUserA( )\n. ! ! ( . )\n. . ? ( . . )\n. ! ! ( )\n||| ( )\n)\n. ! ? ( . . )\n. ! ! ( )\n||| ( )\n,\n,\nl\ntrans A i p n A\nrec A i p n x i\ntrans A i p x Stop\nUSER l\nrec. A j p y j\ntrans A j p y n A\nrec A j p n Stop\nUSER l\ni USER\ni A\nA A\ni\nA\nA\nj A l\nA A l\nA\n=\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\n\u2208h\nh\n1\n1\n? ? ( .\nThe description of USERB is entirely similar, with B re-\nplacing A throughout.\nUserB\ni USER\ni B\nB B l\ni\nB\nB\nj B l\nB B l\nB\nl\ntrans B i p n B\nrec B i p n x i\ntrans B i p x Stop\nUSER l\nrec. B j p y j\ntrans B j p y n B\nrec B j p n Stop\nUSER l\n( )\n. ! ! ( . )\n. . ? ( . . )\n. ! ! ( )\n||| ( )\n)\n. ! ? ( . . )\n. . . ( )\n||| ( )\n,\n,\n,\n=\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\n\u2208h\nh\n1\n1\n? ? ( .\nWe define USERA = USERA(0) and USERB = USERB(0).\nAs an example we will prove the equivalent of the first\nproperty: that rec.B.A.pB(nB,k) authenticates trans.A.B.pB(nB,k)\nfor any given k. In other words, if B\u2019s kth run of the protocol\nis initiated by A and is between A and B, then B\u2019s receipt of\nthe final message authenticates that A sent that message.\nThe description of USERB(k) will be restricted to reflect\nthe fact that the analysis is with respect to this run.\nUserB\nB\nA B l\nB B l\nB\nk\nrec. B A p y A\ntrans B A p y n B\nrec B A p n Stop\nUSER k\n( )\n. )\n. ! ! ( . . )\n. . . ( )\n||| ( )\n,\n,\n=\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\n? ( .\n1\nThe descriptions of the other USERB(l) and all the USERA(l)\nprocesses will remain unchanged.\nFig. 7. Further proof rules for maintains r.\n752 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\nAn appropriate rank function is given in Fig. 8. It is very\nsimilar to the rank function in Fig. 6.\nThis rank function meets R0\u2013R3. We have only to prove R4a\nfor USERA and R4b for USERB to establish that\nrec.B.A.pB(nB, k) authenticates trans.A.B.pB(nB, k) for k.\nR4a (USERA). We have that\nUserA B B k\ni USER\ni A\nA A l\nB k\ni\nA\nB B k\nl trans A B p n Stop\ntrans A i p n A\nrec A j p n x i\nStop\ni B\nx n\ntrans A i p x\nStop\nUSER l\ntrans A B p n\nStop\n( ) |[ . . . ( )]|\n. ! ! ( . )\n. ? ? ( . . )\nif and\n. ! ! ( )\notherwise\n|||\n( )\n|[ . . . ( )]|\n,\n,\n,\n,\n= =\n\u2192\n\u2192\n=\n=\n\u2192\n%\n&\nKK\n\u2019\nKKK\n+\u0019\n\u001b\n\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d\n\u0019\n\u001b\n\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\n\u2208h\n1\n                       \nh\nrec. A j p y j\ntrans A j p y n A\nrec A j p n Stop\nUSER l\ntrans A B p n\nStop\nA\nj A l\nA A l\nA\nB B k\n? ? ( . )\n. ? ? ( . . )\n. . . ( ) |||\n( )\n|[ . . . ( )]|\n,\n,\n,\n\u2192\n\u2192\n\u2192\n+\u0019\n\u001b\n\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d\n\u0019\n\u001b\n\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\u001d\n1\nIt is straightforward to prove that\nrec A i p n x i\nStop i B x n\ntrans A i p x Stop\nA A l\nB k\ni\n. ? ? ( . . )\nif and\n. ! ! ( ) otherwise\n,\n,\n\u2192\n= =\n\u2192\n\u0019\n\u001b\u001a\n\u001c\n\u001e\u001d\nsat maintains \u03c1\nsince r(pA(nA,l.x.i)) \u009b 1 \u02d8\n((i = B ` x = nB,k) \u00b4 r(pi(x)) \u009b 1).\nUnder the inductive assumption that USERA(l + 1)\n|[trans.A.B.pB(nB, k)]| Stop sat maintains r, Rule inter-\nleaves yields that\nrec A j p n x i\nStop i B x n\ntrans A i p x\nStop\nUSER l trans A B p n Stop\nA A l\nB k\ni\nA B B k\n. ? ? ( . . )\nif and\n. ! ! ( )\notherwise\n|||\n( )|[ . . . ( )]|\n,\n,\n,\n\u2192\n= =\n\u2192\n\u0019\n\u001b\n\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\n+ 1\nsat maintains \u03c1\nRules choice and output together with the fact that\nr(pi(nA,l.A)) \u009b 1 for any i, yield that the first branch of the\nchoice satisfies maintains r.\nSimilar reasoning yields that the second branch of the\nchoice also satisfies maintains r, and so we deduce that\nthe process body of the equation for USERA(l)\n|[trans.A.B.pB(nB,k)]| Stop satisfies maintains r. Hence, we\nconclude that\nUSER trans A B p n StopA B B k|[ . . . ( )]|,\nsat maintains \u03c1\nas required.\nR4b (USERB). Since trans.A.B.pB(nB, k)] \u2022 s(USERB) for\nany l, we need only to prove that USERB sat maintains\nr, which will be achieved by establishing it for each l.\nWe begin with the inductive hypothesis that USERB(l) sat\nmaintains r for each l.\nWe must consider the case where l = k separately from\nthe case where l \u00a1 k.\nCase l = k:\nUSER l\nrec B A p y A\ntrans B A p y n B\nrec B A p n Stop\nUSER k\nB\nB\nA B k\nB B k\nB\n( )\n. . ? ( . )\n. ! ! ( . . )\n. . . ( )\n||| ( )\n,\n,\n=\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d1\nAn application of Rule input (with trivial antecedent)\nand an application of Rule output with the observation\nthat r(pA(y.nB,k.B)) \u009b 1 yields that\ntrans B A p y n B\nrec B A p n Stop\nA B k\nB B k\n. ! ! ( . . )\n. . . ( )\n,\n,\n\u2192\n\u2192\nsat maintains \u03c1\nRule interleave with the inductive hypothesis on\nUSERB(k + 1) yields\nFig. 8. Rank function for verification of the kth run.\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 753\ntrans B A p y n B\nrec B A p n Stop\nUSER k\nA B k\nB B k\nB\n. ! ! ( . . )\n. . . ( )\n||| ( )\n,\n,\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d1\nsat maintains \u03c1\nand so finally\nrec B A p y A\ntrans B A p y n B\nrec B A p n Stop\nUSER k\nB\nA B k\nB B k\nB\n. . ? ( . )\n. ! ! ( . . )\n. . . ( )\n||| ( )\n,\n,\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d1\nsat maintains \u03c1\nHence, we conclude that\nUSERB(l)    sat    maintains r                (8)\nCase l \u00a1 k: In this case the recursive equation is\nUSERB\ni USER\ni B\nB B l\ni\nB\nB\nj B l\nB B l\nB\nl\ntrans B i p n B\nrec B i p n x i\ntrans B i p x Stop\nUSER l\nrec. B?j?p y j\ntrans B j p y n B\nrec B j p n Stop\nUSER l\n( )\n. ! ! ( . )\n. . ? ( . . )\n. ! ! ( )\n||| ( )\n( . )\n. ! ! ( . . )\n. . . ( )\n||| ( )\n,\n,\n,\n=\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d\n\u2192\n\u2192\n\u2192\n+\n\u0019\n\u001b\n\u001a\u001a\u001a\n\u001c\n\u001e\n\u001d\u001d\u001d\n\u2208h\nh\n1\n1\nAgain the proof is almost identical to that provided for\nUSERA(l) |[trans.A.B.pB(nB,k)] |Stop. The requirements on r\nrequired for Rules input and output to be applied are\nsimilar to those in Section 4.1:\n1)\u0003 r(pB(nB,l.x.i)) \u009b 1 \u02d8 r(pi(x)) \u009b 1;\n2)\u0003 r(pi(nB,l.B)) \u009b 1;\n3)\u0003 r(pB(y.j)) \u009b 1 \u02d8 r(pj(y.nB,l.B)) \u009b 1\nThe first two arise from the first branch of the choice,\nand the third arises from the second branch. They are all\neasily checked, bearing in mind that l \u00a1 k means that nB,l \u00a1\nnB,k and so r(nB,l.B) = 1. The required result follows from an\napplication of Rule choice and finally of Rule recursion.\nHence, we obtain for any l \u00a1 k that\nUSERB(l)     sat    maintains r\nSince USERB(k) sat maintains r has already been estab-\nlished, Rule recursion yields that\nUSERB    sat     maintains r\nas required.\nSince the proof is valid for arbitrary k we deduce that on\nany protocol run receipt of the nonce challenge confirms\nthat it was appropriately sent by the other party.\n5 CONFIDENTIALITY\nAuthentication protocols are often concerned with key dis-\ntribution, and so their authentication requirements may be\nbound up with other required properties of the protocol,\nsuch as the establishing of a good key, or the guarantee that\nat the end of the run the protocol\u2019s nonces are known only\nto the participants.\nAuthentication is distinct from confidentiality, and each\nmight be provided by a protocol when the other is not. For\nexample, an alternative way to provide authentication is to\nsign nonce challenges, but this approach does not also pro-\nvide confidentiality. In general, the guarantee that each\nparty is communicating with the other does not in itself\nensure confidentiality, which must, therefore, be provided\nseparately. However, in some situations, an attack on\nauthentication may also provide an attack on confidential-\nity. For example, in the case of the protocol discussed in this\npaper, the nonces nA and nB might be expected to be secret\nto A and B, yet Lowe\u2019s attack allows the intruder to obtain\nthem both because the absence of authentication allows a\nthird party to be involved in the protocol run.\nConfidentiality is also expressible in terms of CSP speci-\nfications, with only a slight adaptation to the model of the\nnetwork. In order to describe cleanly in terms of messages\nwhether or not the enemy can obtain a particular message,\nit is useful to add an additional channel knows to the enemy,\nwhich allows him to communicate anything he has de-\nduced. The enemy\u2019s activity on this channel is similar to\nthat on the rec channels. The definition of the enemy will be\nextended with the following branch of a choice:\nENEMY S\nknows m ENEMY Sm\n( )\n! ( )\n=\n\u2192\nK\nhhS`\nConfidentiality for a particular message m0 will simply\nrequire that m0 should never appear on knows, which is eas-\nily specified as\ntr |\\  knows.m0 = \u00c9\u00d9\nFrom the point of view of agent B, one of the confidentiality\nrequirements is that his own nonce nB remains secret. This\nis captured as the requirement that\nNET sat tr |\\  knows.nB = \u00c9\u00d9\nwhere USERA and USERB are as described in Section 4.1:\nUSERA is honest but could undergo a protocol run with\nanyone; and USERB has a protocol run with A, since this\nproperty is concerned with confidentiality from B\u2019s point of\nview.\nThe approach to establishing this will again use rank\nfunctions, and apply a theorem similar to Theorem 3.5\nadapted to address confidentiality. One simplification will\nbe that the network NET does not need to be constrained on\nany events, so the unrestricted descriptions of USERA and\nUSERB will be analyzed to ensure that they preserve the\nrank. Requirements R1 and R2 (with R = fi) still need to be\nchecked to ensure that the enemy cannot reduce the rank;\nfinally, the equivalent of R3 requires the rank of the confi-\ndential message nB itself to have rank 0. The construction of\na rank function that meets these properties is left to the in-\nterested reader.\n754 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\nThere is a second property which B requires of the proto-\ncol: that any nonce which is accepted as A\u2019s nonce challenge\nduring the protocol run is indeed known only to A. Unlike\nnB, this nonce is not known to B at the beginning of the run,\nand this makes the expression of the property more intricate.\nThis second property expressed in the form tr |\\  knows.n\n= \u00c9\u00d9 is too strong: any intruder could supply the first mes-\nsage pB(n.A) to B, and in this case n will not be secret. The\nproperty that is required is that if B completes a protocol\nrun, apparently with A, then the nonce that B has accepted\nis known only to A and B. This is a kind of conditional con-\nfidentiality, requiring for any n that if pB(n.A) is the first\nmessage of the protocol, and the protocol runs to comple-\ntion (as indicated by the occurrence of the final message\npB(nB)), then tr |\\  knows.n = \u00c9\u00d9. This may be expressed as the\nfollowing CSP specification:\n\" y: NONCE \u009f  rec.B.A.pB(y.A) in tr ` pB(nB) in\n               \u02d8 tr |\\  knows.y = \u00c9\u00d9.\nThis description of the property is appropriate for the\nCSP description of a single run. If multiple runs are to be\nconsidered, then it would have to be more carefully crafted\nto ensure that the message n corresponds to the same run as\nthe nB,k. One way of achieving this would be to alter the\nCSP description by labeling each message in the run with\nthe number of the run l (e.g., trans.B.A.m will become\ntrans.B.A.l.m); the label could not be tampered with by the\nenemy, it would be entirely under the control of the user\nand maintained purely to keep track of the runs for model-\nling purposes. The confidentiality property would then\nrequire that if y were the nonce received in the kth run, and\nthat run were to terminate, then y could not be known to\nthe enemy.\nThis property, and the previous one concerning knows.nB,\ndo not hold for the original Needham-Schroeder protocol.\nThere is no single rank function that can guarantee that\nNET meets this specification by assigning rank 0 to any\nnonce n which might appear on knows, for then nA would\nhave to have rank 0 (since the protocol can run to comple-\ntion with this nonce). Yet A is able to send nA to any agent,\nso USERA will not maintain positive r. However, a family\nof rank functions may still be used to address the different\npossibilities for execution: the various nonces that B can\nreceive, and the various agents that A might choose to\ncommunicate with.\nThe specification above is equivalent to the following:\n\" n : NONCE \u009f rec.B.A.pB(n.A) in tr \u02d8\n                tr |\\  pB(nB) = \u00c9\u00d9\n                       \u00b4 tr |\\  knows.n = \u00c9\u00d9\nEither the protocol does not complete, or the nonce ac-\ncepted by B should be secret.\nThe choices for USERB can be expressed more explicitly\nas follows:\nUSER USER y\nUSER y rec B A p y A\ntrans B A p y n B\nrec B A p n Stop\nB y NONCE B\nB B\nA B\nB B\n=\n= \u2192\n\u2192\n\u2192\n\u2208h ( )\n( ) . . . ( . )\n. ! ! ( . . )\n. . . ( )\nSimilarly, USERA can be expressed as a choice over all of\nthe users with whom she might undertake a protocol run:\nUSERA = hi\u00b6USER USERA(i), where USERA(i) is given by\nUSERA(i) = trans.A!i!pi(nA.A) \u0096\n                                                 rec.A.i?pA(nA.x.i) \u0096\n                                                     trans.A!i!pi(x) \u0096 Stop\nIn the traces model, all of the choices that are possible for\nthe network components can be distributed over the paral-\nlel composition.\nUSER USER ENEMY INIT\nUSER i\nUSER y\nENEMY INIT\nA B\ni USER A\ny NONCE B\ni USER y NONCE\nUSER i USER y\nENEMY INIT\nA B\n||| || ( )\n( )\n||| ( )\n|| ( )\n,\n( )|| ( )\n| ( )\n=\n\u0019\n\u001b\u001a\n\u001c\n\u001e\u001d\n=\n\u2208\n\u2208\n\u2208 \u2208\n\u0019\n\u001b\u001a\n\u001c\n\u001e\u001d\nh\nh\nh\nThis means that the various cases for USERA(i) and\nUSERB(y) can be separately verified against the specifica-\ntion, and if all cases meet the specification, then the fol-\nlowing general rule guarantees that the overall choice must\nalso meet it:\n\u2200 \u2022j V S\nV S\nj\nj j\nsat\nsath\nThe cases to consider divide into i = B and i \u00a1 B, and y =\nnA and y \u00a1 nA. In each of these cases, a rank function can be\nprovided which has either r(pB(nB)) = 0 or r(y) = 0, and\nwhich is preserved by both USERA(i) and USERB(y), guar-\nanteeing either that the protocol cannot complete or that the\nnonce y accepted by B cannot appear on knows.\nFor example, when i \u00a1 B, then an appropriate rank func-\ntion is\n\u03c1\n\u03c1\n\u03c1\n\u03c1\n\u03c1\n\u03c1 \u03c1\n\u03c1 \u03c1\n\u03c1\n\u03c1 \u03c1\n\u03c1\n\u03c1 \u03c1 \u03c1\n0\n0\n0\n0\n0\n0\n1 2 1 2\n1\n1\n0\n1\n1\n0\n1\n11\n1\n( )\n( )\n( )\nif\notherwise\n( )\n( )\nif or\notherwise\n( ) ( )\n( )( )) ( )\nif and\n. .\n( ) otherwise\n( )( )) ( )\nif and\n( . .\n( ) otherwise\n)\n( . ) min{ ( ), ( )}\nu\nt\nn\nn n\np\ns\ni A i B\nr r\np m m\nj A\nm n n B\nm\ns m m\nj A\nm p n n B\nm\nm m m m\nB\ni\ni\nj E A B\nj E A A B\n=\n=\n=\n=%&\u2019\n=\n=\n= =%&\u2019\n=\n=\n+\n=\n=\n%\n&K\n\u2019K\n=\n\u2212\n=\n=\n%\n&K\n\u2019K\n=\nIn this case \u03c1(pB(nB)) = 0: B\u2019s part of the protocol run will\nnot terminate.\n(Construction of the rank functions for the other cases is\nleft as an exercise for the interested reader.) Different cases\nrequire different rank functions, but they all establish the\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 755\nsame property for their particular case, so that property\nmust hold for the complete description NET. All the rank\nfunctions allow nonces other than nA and nB to have rank 1\n(so in the case of y \u00a1 nB it is necessary to show that the pro-\ntocol cannot complete, that is, that \u03c1(pB(nB)) = 0).\nHence, it appears that the rank function approach will\nextend to handle confidentiality properties, though the ex-\npression of such properties can be more delicate.\n6 DISCUSSION\nIn this paper, we have shown how the theory of CSP might\nbe specialized to provide a theory for reasoning about\nauthentication protocols. The process of verification re-\nquires the assumptions about encryption mechanisms and\nabout the capability of a hostile agent to be made explicit.\nThe theory includes a CSP model of the framework con-\ntaining the protocol; rules for establishing authentication of\nmessages within a single agent; and a general theorem for\ndeducing authentication between agents from their proper-\nties with respect to a rank function \u03c1 on messages, together\nwith rules for deriving the required properties. We have\nalso considered how the approach can be adapted to handle\nconfidentiality properties.\nWe find that construction of the rank function forces\nconsideration of the precise reasons why a protocol is ex-\npected to work. In this respect, it should reflect the under-\nstanding of the protocol designer and make this under-\nstanding precise and explicit. Failed attempts to construct a\nrank function may also provide insight as to why a protocol\ndoes not provide authentication.\nThe CSP language, in common with other process alge-\nbras such as CCS, provides a language suitable for the de-\nscription of protocols in a natural way. Abadi and Gordon\n[1] observe that this kind of approach combines a precise\nand solid foundation for reasoning about protocols together\nwith a clear relationship to implementations.\nAnother benefit of the process algebra approach is to\nidentify precisely the properties required of a protocol. This\nmay be left vague in the original formulation of the proto-\ncol, and performing the verification often gives information\nas to which properties actually hold, as well as pinning\ndown precisely the properties which are provided by the\nprotocol. The vital question as to whether the properties\nobtained are indeed those required are beyond the scope of\nthe formal analysis itself, and must really be assessed ac-\ncording to the intended use of the protocol. Security prop-\nerties may be captured as CSP specifications, or alterna-\ntively in terms of equivalences between processes, as is\ndone in [1], where a network built using the protocol is re-\nquired to be equivalent to a network which describes the\neffect of a correct operation of the protocol: equivalence\nmeans that the protocol must operate correctly: that no\ncontext written in the process algebra can distinguish be-\ntween the actual protocol and its specification.\n6.1 Comparison with Other Approaches\nThe CSP approach put forward by this author in [22] advo-\ncated the encapsulation of required properties in terms of\nthe interactions between the protocol agents and their us-\ners. The intention is to separate out the required properties\nfrom the way of implementing them. Since a property of a\nsystem should be described in terms of its possible interac-\ntions with its environment, the internal channels trans.i and\nrec.i should not appear in the property description. This\napproach requires extra events such as A.connect_to.B and\nB.authenticated.A to appear in the protocol description as\ncaptured in USERA and USERB. The descriptions might then\nbe as follows:\nUSERA = a.connect_to? i \u0096\n                   trans.A!i!pi(nA.A) \u0096\n                      rec.A.i?pA(nA.x.i) \u0096\n                         trans.A!i!pi(x) \u0096 Stop\nUSERB = rec.B.A?pB(y.A) \u0096\n                   trans.B!A!pA(y.nB.B) \u0096\n                      rec.B?i.pB(nB) \u0096\n                          B.authenticated.A \u0096 Stop\nOur top level requirement would be that\nNET \\ (trans < rec) sat\nA.connect_to.B precedes B.authenticated.A\nThe essential proof strategy will remain that proposed in\nthis paper, but the high-level description of the property\nwill be purely in terms of the interactions between the net-\nwork and its environment. The proof rules will remain un-\nchanged, though there will be an additional assumption\nrequired that messages of rank 0 or less are not introduced\nto protocol agents by the environment. This was guaran-\nteed when such agents had no channels apart from trans\nand rec.\nThe approach of including additional \u2018control\u2019 events\ninto a protocol description is appropriate both for abstract-\ning away the details of the protocol description, and also\nfor providing a clearer understanding of what the protocol\ndesigner is attempting to achieve. This separation of con-\ncerns allows authentication specifications to be formulated\nindependently of the details of any particular protocol. Ex-\nternal events are introduced in other CSP approaches to\nprotocol analysis [19], [11] and elsewhere [24]. In the case of\nthe analysis performed here, additional external events\nsuch as A.nonce_challenge_OK.B might be included to make\nfiner distinctions between different flavors of authentica-\ntion. This approach is simply a straightforward extension of\nthe approach we have taken in this paper, introducing spe-\ncial events to mark particular points in the run of the proto-\ncol which we have been pinpointing directly.\nAnother issue of interest is that Definition 3.2 is not con-\ncerned with matching up occurrences of events from T and\nR: once some event from R has occurred then this definition\nallows arbitrarily many events from T to occur without\nbreaking authentication. Lowe [12] discusses a stronger\nversion of authentication which requires each authenticat-\ning event to correspond to a different authenticated event\u2014\nhe terms this requirement \u201cinjectivenes.\u201d Such a property is\nimportant in, for example, the authorisation of financial\ntransactions. This property can be captured by strengthen-\ning the above definition as follows:\n756 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\nR T\ntr R tr T\ninjectively precedes =\n\u2265\n\u0302\n# ( | ) # | )\\ \\\nwhere # tr denotes the length of the trace tr. The property R\ninjectively precedes is strictly stronger than R pre-\ncedes T.\nThe techniques developed in this paper are concerned\nonly with noninjective authentication. Their extension to\ndeal with injectiveness is an area of ongoing research.\nThis approach contrasts with that taken in [4], [19] where\nspecifications are what Roscoe calls intensional, requiring\nthat the protocol works \u2018as expected\u2019 in some sense. Such\nproperties cannot be expressed as CSP specifications inde-\npendently of the protocol itself, and they really correspond\nto a recipe for providing the specification appropriate to the\nparticular protocol. For example, Gollmann identifies a\nnumber of authentication properties in [6]; the one closest\nto those we have considered here is G4, which states that\n\u201cthe origin of all messages in the protocol has to be authen-\nticated.\u201d Other examples are given in [20], which gives the\n\u2018canonical\u2019 intensional specification as one where the inter-\nleavings of events at different agents are in accordance with\nthe messages in the protocol; and a slightly weaker one in\n[4], which requires that whenever a participant completes\nits part of a protocol run then the other participant must\nhave engaged in the sequence of events described by the\nprotocol. These intensional properties can be formulated for\nany particular protocol, but not in CSP terms independently\nof any protocol.\nA different process algebraic approach is taken by Abadi\nand Gordon [1], where the pi-calculus [15] is extended (to\nthe spi-calculus) to model encryption. The resulting lan-\nguage allows protocols to be described in a straightforward\nway; the treatment of freshness of nonces and keys is more\nexplicitly provided by the process description language\nitself: encapsulation with the n operator provides a natural\nand pleasing model of nonce and key generation. Correct-\nness of a protocol is established by showing that it is testing\nequivalent to a specification process that describes explic-\nitly what the protocol is intended to achieve. In other\nwords, they are indistinguishable in any context. As a re-\nsult, the enemy does not have to be modeledexplicitly. The\ncapabilities of the enemy are precisely those that can be\ndescribed within the spi-calculus language: a context dis-\ntinguishing between protocol and its specification would\ndescribe an attack on the protocol, and conversely if no\ncontext distinguishes them, then the protocol implements\nthe specification in the context of any enemy which may be\ndescribed in the spi calculus. This contrasts with the ap-\nproach taken in this paper, where the specification is sepa-\nrated to some extent from the protocol, and which allows\nfiner distinctions to be drawn between different notions of\nauthentication. The explicit description of the enemy allows\nanalysis with regard to different enemy capabilities within\nthe same framework. More comparative examples are re-\nquired to explore the relative merits of each approach.\nThe approach of providing a rank function r as the core\nof a proof is complementary to the tool-based approaches\n[10], [14], [9], [19] which search for attacks. The results of\nthe latter kind of analysis provide useful information as to\nwhy a protocol is not correct, or alternatively give a bald\nstatement that no attack can be found. This is appropriate\nfor debugging, but does not provide understanding as to\nwhy a protocol is correct. It is a claim of this paper that the\nrank function provides the basis for such an understanding,\nand it might be profitable to explore the interplay between\nthe state exploration approaches and proofs. One problem\nconcerns the relationship between the finite nature of the\nstate space and the infinite possibilities for attacks (such as\narise from such aspects as the possibility of arbitrary depths\nof encryption and combining of messages), and Lowe [11]\nhas begun to consider a proof strategy based on the general\nform of a protocol run for establishing when the absence of\nan attack on a finite state space really does imply that no\nattack is possible on the infinite state space. It seems that\nthe rank function approach might also be useful in this\ncontext.\nPaulson [18] has investigated the application of the proof\ntool Isabelle\/HOL to proving security properties of proto-\ncols. He specifies security protocols in terms of traces of the\nsystem as a whole. The steps of a protocol are translated\ninto rules about how system traces may be augmented.\nPossible enemy activities also become rules. Once all of the\nrules have been identified, the aim is to prove that any sys-\ntem trace that can be generated using the rules must meet\nthe required property; this is established by induction. He\ndoes not use an explicit invariant, but he also aims to prove\nthat particular events can never occur in a trace, and this\nrequires certain lemmas establishing that particular classes\nof event cannot occur. This is also a feature of the approach\ntaken in [13], which applies language theory to establish\nthat particular terms cannot be generated using given pro-\nduction rules. Mechanical assistance for proofs is invalu-\nable, and Paulson has some useful results concerning reus-\nability of proof strategies. It appears that a number of pro-\ntocols have proofs of a similar shape, which allows efficient\nanalysis of new protocols. Recent work on providing me-\nchanical assistance to the CSP proofs using PVS [17] is en-\ncouraging, but at present1 fit is still necessary to provide the\ninvariant in order for the proof to proceed, so analysis of\nfresh protocols will not be as automatic as Paulson reports\nfor Isabelle\/HOL.\nOther approaches to direct proof of protocols, rather\nthan the indirect route by establishing absence of attacks,\ntend to be based on formal languages for describing secu-\nrity properties, together with rules which support reason-\ning about statements in the language. Protocols are mod-\neledas rules which allow the derivation of new statements\nfrom existing ones. The best known example of such a lan-\nguage is the BAN logic [2], though the need for \u2018idealiza-\ntion\u2019 of protocols into the logic means that the link between\na protocol and its logical treatment is informal. The formal\nlanguage described in [23] contains lower-level primitives\nwhich relate more directly to the steps taken by a protocol,\nand supports reasoning concerning the knowledge of the\nintruder at particular stages. This language is used in con-\njunction with the NRL protocol analyzer which is used to\n1. As of April 1998.\nSCHNEIDER:  VERIFYING AUTHENTICATION PROTOCOLS IN CSP 757\ncheck reachability of negated requirements, so it is closer to\nthe tool-based approaches. However, an approach to proof\nreflecting that presented in this paper seems feasible.\n6.2 Future Directions\nThis paper has presented an approach to analyzing and\nverifying authentication protocols, driven in part by con-\nsideration of the Needham-Schroeder protocol. The verifi-\ncation was done by hand, and the cryptographic mecha-\nnisms considered are straightforward: nonces, and public-\nkey encryption. There is an obvious need to investigate the\nCSP handling of other security mechanisms such as time-\nstamps, and to investigate more complicated protocols.\nSome form of mechanical assistance for proof has now\nbeen provided within PVS [17] by Bruno Dutertre at Royal\nHolloway. A CSP trace semantics has been provided for the\noperators used in this paper, the various proof rules have\nall been proven sound, and all of the theorems have been\nproven. Correctness of the protocols in this paper with re-\nspect to their various properties has been established. An\nimportant avenue to explore will be the extent to which\nconstruction of the rank function can be assisted. In effect, a\nproof can be provided with respect to particular constraints\non the rank function, and the proof is completed once a\nfunction can be provided which meets all those constraints.\nAPPENDIX\nTHEOREM 3.5. If\n[R1:] \" m \u00b6 INIT \u009f r(m) > 0\n[R2:] \" S, m \u009f ((\" s \u00b6 S \u009f r(m) > 0) ` S \u00a3 m \u02d8 r(m) > 0)\n[R3:] \" t \u00b6 T \u009f r(m) \u008b 0\n[R4:] \" i \u009f (USERi |[R]| Stop sat maintains r)\nthen NET sat precedes T\nProof. By Lemma 3.3 it is sufficient to establish that R1\u2013R4\nimply NET |[R]| Stop sat tr |\\  T = kl.\nAssume for a contradiction that R1\u2013R4 hold, and\nalso that \u00c0 (NET |[R]| Stop sat tr |\\T =]l). Then there\nis some trace tr \u00b6 traces(NET |[R] Stop) for which tr |\\\nT \u00a1 kl. Since R3 tells us that r(t) \u008b 0 for any t \u00b6 T we\nhave that there are some messages in tr with rank less\nthan 1. Let tr0 be the prefix of tr whose final message\nis the first message of tr of rank 0 or less. In other\nwords, tr0 is the trace up to the point where the first\nmessage of rank 0 or less appears. By prefix closure of\ntraces in processes, tr0 is a trace of NET |[R]| Stop.\nNow consider the last message of tr0. It is either of\nthe form rec.i.j.x or trans.i.j.x for some i, j, and x, where\nr(x) \u008b 0\nCase rec.i.j.x. We have that tr0 is a trace of ENEMY.\nHence by Theorem 3.1 we have that (INIT < (tr0 \u02d9\ntrans)) \u00a3 tr0 \u02d9 rec and so (INIT < (tr0 \u02d9 trans)) \u00a3 x. But\nby the definition of tr0 we have \" m \u00b6 tr0 \u02d9 trans \u009f\nr(m) \u009b 1, since all messages in tr0 apart from the last\nhave strictly positive rank, so R1 and R2 yield that\nr(x) \u009b 1, forcing a contradiction.\nCase trans.i.x. Let tri = tr0 |\\  {trans.i, rec.i}. This is the\nsubsequence of tr0 in which USERi |[R]} Stop partici-\npates, so tri is a trace of USERi |[R]| Stop. Hence, by\nR4 we have maintains \u03c1(tri). Expanding the defini-\ntion we find\n(\" m \u00b6 tri \u02d9 rec.i \u009f r(m) \u009b 1)\n       \u02d9 (\" m \u00b6 tri \u02d9 trans.i \u009f r(m) \u009b 1)\nThe definition of tr0 means that the antecedent of\nthis implication is true, from which it follows that r(x)\n\u009b 1, yielding a contradiction.\nIn either case we find a contradiction, which estab-\nlishes the theorem. o\nACKNOWLEDGMENTS\nThe author thanks Peter Ryan, Irfan Zakiuddin, Bruno Du-\ntertre, James Heather, Gavin Lowe, Jeremy Bryans, Andy\nGordon, and Catherine Meadows for their comments on\nearlier forms of this work, and Chris Mitchell for some en-\nlightening discussions on authentication. James Heather\nmade the observation that confidentiality could be treated\nas a special case of authentication with the empty set for R.\nThe author is also grateful to the anonymous referees for\ntheir careful reading of an earlier version of this paper and\ntheir suggestions for improvement. It is also a pleasure to\nthank Bruno Dutertre for his work on checking the proofs\nwith PVS and suggesting improvements, underlining the\nnecessity for mechanical assistance to make such proofs\nmanageable. Funding for this research was received from\nthe Defence Research Agency.\nREFERENCES\n[1]\u0003 M. Abadi and A.D. Gordon, \u201cA Calculus for Cryptographic Pro-\ntocols: The spi Calculus,\u201d technical report, Univ. of Cambridge,\n1996.\n[2]\u0003 M. Burrows, M. Abadi, and R. Needham, \u201cA Logic of Authentica-\ntion,\u201d Technical Report 39, SRC, Dec. 1989.\n[3]\u0003 J. Davies and S. Schneider, \u201cRecursion Induction for Real-Time\nProcesses,\u201d Formal Aspects of Computing, vol. 5, no. 6, 1993.\n[4]\u0003 W. Diffie, P.C. van Oorschot, and M.J. Wiener, \u201cAuthentication and\nKey Exchanges,\u201d Designs, Codes, and Cryptography, vol. 2, 1992.\n[5]\u0003 D. Dolev and A.C. Yao, \u201cOn the Security of Public Key Protocols,\u201d\nIEEE Trans. Information Theory, vol. 29, no. 2, 1983.\n[6]\u0003 D. Gollmann, \u201cWhat Do We Mean by Entity Authentication,\u201d\nIEEE Computer Society Symp. Research in Security and Privacy, 1996.\n[7]\u0003 C.A.R. Hoare, Comm. Sequential Processes. Prentice Hall, 1985.\n[8]\u0003 International Organisation for Standardisation, Information Proc-\nessing Systems\u2014Open Systems Interconnection\u2014Basic Reference\nModel\u2014Part 2: Security Architecture, ISO 7498-2. 1989.\n[9]\u0003 R. Kemmerer, C. Meadows,. and  J. Millen, \u201cThree Systems for\nCryptographic Protocol Analysis,\u201d J. Cryptology, vol. 7, no. 2, 1994.\n[10]\u0003 G. Lowe, \u201cAn Attack on the Needham-Schroeder Public-Key\nAuthentication Protocol,\u201d Information Processing Letters, no. 56,\n1995.\n[11]\u0003 G. Lowe, \u201cBreaking and Fixing the Needham-Schroeder Public-\nKey Protocol Using FDR,\u201d Tools and Algorithms for the Construction\nand Analysis of Systems, Lecture Notes in Computer Science 1055.\nSpringer-Verlag, 1996.\n[12]\u0003 G. Lowe, \u201cA Hierarchy of Authentication Specifications,\u201d Proc.\nComputer Security Foundations Workshop, no. 10, 1997.\n[13]\u0003 C. Meadows, \u201cApplying Formal Methods to the Analysis of a Key\nManagement Protocol,\u201d J. Computer Security, vol. 1, no. 1, 1992.\n[14]\u0003 J. Millen, \u201cThe Interrogator Model,\u201d IEEE Computer Society Symp.\nResearch in Security and Privacy, 1995.\n758 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING,  VOL.  24,  NO.  9,  SEPTEMBER  1998\n[15]\u0003 R. Milner, J. Parrow, and D. Walker, \u201cA Calculus of Mobile Proc-\nesses,\u201d Information and Computation, no. 100, 1992.\n[16]\u0003 R. Needham and M.L. Schroeder, \u201cUsing Encryption for Authen-\nticiation in Large Networks of Computers,\u201d Comm. ACM, vol. 21,\nno. 12, 1978.\n[17]\u0003 S. Owre, N. Shankar, and J. Rushby, \u201cThe PVS Specification Lan-\nguage,\u201d technical report, Computer Science Laboratory, SRI Int\u2019l,\n1993.\n[18]\u0003 L.C. Paulson, \u201cProving Properties of Security Protocols by Induc-\ntion,\u201d technical report, Univ. of Cambridge, UK, 1996.\n[19]\u0003 A.W. Roscoe, \u201cModelling and Verifying Key-Excfhange Protocols\nUsing CSP and FDR,\u201d Proc. Computer Security Foundations Work-\nshop, no. 8, 1995.\n[20]\u0003 A.W. Roscoe, \u201cIntensional Specifications of Security Protocols,\u201d\nComputer Security Foundations Workshop, no. 9, 1996.\n[21]\u0003 A.W. Roscoe, The Theory and Practice of Concurrency. Prentice Hall,\n1997.\n[22]\u0003 S.A. Schneider, \u201cSecurity Properties and CSP,\u201d IEEE Computer\nSociety Symp. Research in Security and Privacy, 1996.\n[23]\u0003 P. Syverson and C. Meadows, \u201cA Formal Language for Crypto-\ngraphic Protocol Requirements,\u201d Designs, Code,s and Cryptography,\nno. 7, 1996.\n[24]\u0003 T. Woo and S. Lam, \u201cA Semantic Model for Authentication Proto-\ncols,\u201d Proc. IEEE Computer Society Symp. Research in Security and\nPrivacy, 1993.\nSteve Schneider received his BA degree in\nmathematics and philosophy, and the MSc and\nDPhil degrees in computer science from the\nUniversity of Oxford on Timed CSP. He worked\nat the Oxford Programming Research Group as\na research assistant on the ESPRIT project\nSPEC from 1989\u20131991, and then as an SERC\npostdoctoral fellow and a junior research fellow\nat Balliol College, Oxford. Since 1994, he has\nbeen a lecturer in computer science at Royal\nHolloway, University of London. His research\ninterests include concurrency, real-time systems, formal methods, and\nsecurity. Schneider is a member of the IEEE Computer Society.\n"}