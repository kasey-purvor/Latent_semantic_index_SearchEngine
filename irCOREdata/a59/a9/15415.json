{"doi":"10.1016\/j.tcs.2010.05.041","coreId":"15415","oai":"oai:dro.dur.ac.uk.OAI2:7419","identifiers":["oai:dro.dur.ac.uk.OAI2:7419","10.1016\/j.tcs.2010.05.041"],"title":"Computing role assignments of chordal graphs. \\ud","authors":["Hof, P van 't","Paulusma, Daniel","Rooij, J.M.M. van"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2010-09-01","abstract":"In social network theory, a simple graph G is called k-role assignable if there is a surjective mapping that assigns a number from {1,\u2026,k}, called a role, to each vertex of G such that any two vertices with the same role have the same sets of roles assigned to their neighbors. The decision problem whether such a mapping exists is called the k-Role Assignment problem. This problem is known to be NP-complete for any fixed k\u22652. In this paper, we classify the computational complexity of the k-Role Assignment problem for the class of chordal graphs. We show that for this class the problem can be solved in linear time for k=2, but remains NP-complete for any k\u22653. This generalizes earlier results by Sheng and answers her open problem.\\ud\n\\u","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/15415.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/7419\/1\/7419.pdf","pdfHashValue":"932be2cda6266a60ea12c795970cd1a777e78cf5","publisher":"Elsevier","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:7419<\/identifier><datestamp>\n      2013-04-03T12:17:11Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Computing role assignments of chordal graphs. \\ud\n<\/dc:title><dc:creator>\n        Hof, P van 't<\/dc:creator><dc:creator>\n        Paulusma, Daniel<\/dc:creator><dc:creator>\n        Rooij, J.M.M. van<\/dc:creator><dc:description>\n        In social network theory, a simple graph G is called k-role assignable if there is a surjective mapping that assigns a number from {1,\u2026,k}, called a role, to each vertex of G such that any two vertices with the same role have the same sets of roles assigned to their neighbors. The decision problem whether such a mapping exists is called the k-Role Assignment problem. This problem is known to be NP-complete for any fixed k\u22652. In this paper, we classify the computational complexity of the k-Role Assignment problem for the class of chordal graphs. We show that for this class the problem can be solved in linear time for k=2, but remains NP-complete for any k\u22653. This generalizes earlier results by Sheng and answers her open problem.\\ud\n\\ud\n<\/dc:description><dc:subject>\n        Role assignment<\/dc:subject><dc:subject>\n         Graph homomorphism<\/dc:subject><dc:subject>\n         Chordal graph<\/dc:subject><dc:subject>\n         Computational complexity. <\/dc:subject><dc:publisher>\n        Elsevier<\/dc:publisher><dc:source>\n        Theoretical computer science, 2010, Vol.411(40-42), pp.3601-3613 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2010-09-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:7419<\/dc:identifier><dc:identifier>\n        issn:0304-3975<\/dc:identifier><dc:identifier>\n        doi:10.1016\/j.tcs.2010.05.041<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/7419\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1016\/j.tcs.2010.05.041<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/7419\/1\/7419.pdf<\/dc:identifier><dc:rights>\n        NOTICE: this is the author's version of a work that was accepted for publication in Theoretical computer science.<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0304-3975","issn:0304-3975"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2010,"topics":["Role assignment","Graph homomorphism","Chordal graph","Computational complexity."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n07 October 2010\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nHof, P van \u2019t and Paulusma, D. and Rooij, J.M.M. van (2010) \u2019Computing role assignments of chordal\ngraphs.\u2019, Theoretical computer science., 411 (40-42). pp. 3601-3613.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1016\/j.tcs.2010.05.041\nPublisher\u2019s copyright statement:\nNOTICE: this is the author\u2019s version of a work that was accepted for publication in Theoretical computer science.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nComputing role assignments of chordal graphs?\nPim van \u2019t Hof1,??, Dani\u00ebl Paulusma1,?? and Johan M. M. van Rooij2\n1School of Engineering and Computing Sciences, Durham University,\nScience Laboratories, South Road, Durham, DH1 3LE, England.\n{pim.vanthof,daniel.paulusma}@durham.ac.uk\n2Department of Information and Computing Sciences, Universiteit Utrecht,\nPO Box 80.089, 3508 TB Utrecht, The Netherlands.\njmmrooij@cs.uu.nl\nAbstract. In social network theory, a simple graph G is called k-role\nassignable if there is a surjective mapping that assigns a number from\n{1, . . . , k}, called a role, to each vertex of G such that any two vertices\nwith the same role have the same sets of roles assigned to their neighbors.\nThe decision problem whether such a mapping exists is called the k-Role\nAssignment problem. This problem is known to be NP-complete for any\nfixed k \u2265 2. In this paper, we classify the computational complexity of\nthe k-Role Assignment problem for the class of chordal graphs. We\nshow that for this class the problem can be solved in linear time for\nk = 2, but remains NP-complete for any k \u2265 3. This generalizes earlier\nresults by Sheng and answers her open problem.\n1 Introduction\nAll graphs considered in this paper are undirected, finite and simple, i.e., without\nloops or multiple edges, unless otherwise stated. Given two graphs, say G on\nvertices u1, . . . , un and R on vertices 1, . . . , k called roles, an R-role assignment\nof G is a vertex mapping r : VG \u2192 VR such that the neighborhood relation is\nmaintained, i.e., the roles of the neighbors of each vertex u in G are exactly the\nneighbors of role r(u) in R. Let NG(u) denote the set of neighbors of u in the\ngraph G and let r(S) = {r(u) | u \u2208 S} for any subset S \u2286 VG. The condition\nthat r is an R-role assignment of G can be formally expressed as\nfor all u \u2208 VG : r(NG(u)) = NR(r(u)).\nAn R-role assignment r of G is called a k-role assignment of G if |r(VG)| = |VR| =\nk. An equivalent definition states that r is a k-role assignment of G if r maps each\nvertex of G to a positive integer so that |r(VG)| = k and r(NG(u)) = r(NG(u\u2032))\nfor any two vertices u and u\u2032 with r(u) = r(u\u2032). See Figure 1 for an example.\nRole assignments are introduced by Everett and Borgatti [9], who call them\nrole colorings. They originate in the theory of social behavior. The role graph R\n? An extended abstract of this paper has been presented at FCT 2009.\n?? This author has been supported by EPSRC (EP\/D053633\/1).\n1 2 3\nR\n1 1\n1 1\n2\n2 23\n3 3\nG\nFig. 1. A role graph R and a graph G with an R-role assignment which is also a 3-role\nassignment of G (example based on the figure in [24]).\nmodels roles and their relationships, and for a given society we can ask if its indi-\nviduals can be assigned roles such that relationships are preserved: each person\nplaying a particular role has exactly the roles prescribed by the model among\nits neighbors. This way one investigates whether large networks of individuals\ncan be compressed into smaller ones that still give some description of the large\nnetwork. As persons of the same social role may be related to each other, the\nsmaller network can contain loops. In other words, given a simple instance graph\nG on n vertices does there exist a possibly non-simple role graph R on k < n\nvertices in such a way that G has an R-role assignment? From the computational\ncomplexity point of view it is interesting to know whether the existence of such\nan assignment can be decided quickly (in polynomial time). This leads to the\nfollowing two decision problems.\nR-Role Assignment\nInput: a simple graph G.\nQuestion: does G have an R-role assignment?\nk-Role Assignment\nInput: a simple graph G.\nQuestion: does G have a k-role assignment?\nKnown results and related work. A graph homomorphism from a graph G\nto a graph R is a vertex mapping r : VG \u2192 VR satisfying the property that\nthe edge r(u)r(v) belongs to ER whenever the edge uv belongs to EG. If for\nevery u \u2208 VG the restriction of r to the neighborhood of u, i.e., the mapping\nru : NG(u) \u2192 NR(r(u)), is bijective, we say that r is locally bijective [1, 19]. If\nfor every u \u2208 VG the mapping ru is injective, we say that r is locally injective [10,\n11]. If for every u \u2208 VG the mapping ru is surjective, r is an R-role assignment\nof G. In this context, r is also called a locally surjective homomorphism from G\nto R.\nLocally bijective homomorphisms, also called graph coverings, have appli-\ncations in distributed computing [2, 3, 7] and in constructing highly transitive\nregular graphs [5]. Locally injective homomorphisms, also called partial graph\ncoverings, have applications in models of telecommunication [11] and frequency\n2\nassignment [12]. Besides social network theory [9, 21, 23], locally surjective ho-\nmomorphisms also have applications in distributed computing [8].\nThe main computational question is whether for every graph R the problem\nof deciding if an input graph G has a homomorphism of given local constraint\nto the fixed graph R can be classified as either NP-complete or polynomial time\nsolvable. For locally bijective and injective homomorphisms there are many par-\ntial results, see e.g. [11, 19] for both NP-complete and polynomial time solvable\ncases, but even conjecturing a classification for these two locally constrained\nhomomorphisms is problematic. This is not the case for the locally surjective\nconstraint and its corresponding decision problem R-Role Assignment.\nRoberts and Sheng [23] have shown that the k-Role Assignment problem\nis already NP-complete for k = 2. Fiala and Paulusma [13] have shown that\nthe k-Role Assignment problem is also NP-complete for any fixed k \u2265 3 and\nclassify the computational complexity of the R-Role Assignment problem. Let\nR be a fixed role graph without multiple edges but possibly with loops. Then the\nR-Role Assignment problem is solvable in polynomial time if and only if one\nof the following three cases holds: either R has no edge, or one of its components\nconsists of a single vertex incident with a loop, or R is simple and bipartite\nand has at least one component isomorphic to an edge. In all other cases the\nR-Role Assignment problem is NP-complete, even for the class of bipartite\ngraphs [13]. If the instance graphs are trees, then the R-Role Assignment\nproblem becomes polynomial time solvable for any fixed role graph R [14].\nA graph is chordal if it does not contain an induced cycle of length at least 4.\nChordal graphs are also called triangulated graphs. This class contains various\nsubclasses such as trees, split graphs and indifference graphs (graphs whose ver-\ntices can be assigned some real values such that two vertices are adjacent if and\nonly if their assigned values are sufficiently close). Due to their nice properties,\nchordal graphs form an intensively studied graph class both within structural\ngraph theory and within algorithmic graph theory. Sheng [24] presented an el-\negant greedy algorithm that solves the 2-Role Assignment problem in linear\ntime on chordal graphs with at most one vertex of degree 1. She also character-\nized all indifference graphs that have a 2-role assignment.\nOur results and paper organization. In Section 2, we present a linear time\nalgorithm for the 2-Role Assignment problem on chordal graphs. This settles\nan open problem of Sheng [24]. Unlike the greedy algorithm of Sheng [24], which\nuses a perfect elimination scheme of a chordal graph with at most one vertex of\ndegree 1, our algorithm works for any chordal graph G by using a dynamic pro-\ngramming procedure on a clique tree decomposition of G. Section 3 contains our\nsecond result. Here we prove that, for any fixed k \u2265 3, the k-Role Assignment\nproblem is NP-complete for chordal graphs. Section 4 contains the conclusions\nand mentions some open problems.\n2 Computing a 2-role assignment in linear time\nIn this section, we prove the following result.\n3\nTheorem 1. The 2-Role Assignment problem can be solved in linear time\nfor the class of chordal graphs.\nWe will start by discussing the different 2-role assignments. Following the\nnotation of Sheng [24], the six different role graphs on two vertices are:\nR1 := ({1, 2}, \u2205)\nR2 := ({1, 2}, {22})\nR3 := ({1, 2}, {11, 22})\nR4 := ({1, 2}, {12})\nR5 := ({1, 2}, {12, 22})\nR6 := ({1, 2}, {11, 12, 22})\nThese six role graphs are depicted in Figure 2.\n1 2 1 2 1 2\n1 2 1 2 1 2\nR1 : R2 : R3 :\nR4 : R5 : R6 :\nFig. 2. The six different role graphs on two vertices.\nLet G be a chordal graph. If G contains at most one vertex, then G has no\n2-role assignment. Suppose |VG| \u2265 2. If G only contains isolated vertices, then G\nhas an R1-role assignment. If G contains at least one isolated vertex and at least\none component with at least two vertices, then G has an R2-role assignment.\nIf G is disconnected but does not have isolated vertices, then G has an R3-role\nassignment. Now assume that G is connected and has at least two vertices. If\nG is bipartite, then G has an R4-role assignment. If G is not bipartite, then G\nhas a 2-role assignment if and only if G has an R5-role assignment or an R6-role\nassignment.\nWe claim that we only have to check whether G has an R5-role assignment.\nThis is immediately clear if G has a vertex of degree 1, as such a vertex must\nbe mapped to a role of degree 1 and R6 does not have such a role. If G does not\nhave any degree 1 vertices, we use the following result by Sheng [24].\nTheorem 2 ([24]). Let G be a chordal graph with at most one vertex of degree\n1 and no isolated vertices. Then G has an R5-role assignment.\nWe will now present a linear time algorithm that decides whether a chordal\ngraph G has an R5-role assignment and if so outputs an R5-role assignment of G.\nFrom the above, it is clear that this suffices to prove Theorem 1. Our algorithm\nis to be viewed as being independent from the linear time algorithm of Sheng [24]\nfor computing an R5-role assignment of a chordal graph with at most one vertex\nof degree one and no isolated vertices. Before presenting our algorithm we first\nmake some basic observations on chordal graphs.\n4\n2.1 On chordal graphs\nLet G = (V,E) be a chordal graph. A clique in G is a subset K \u2286 V such that\nG[K] is a complete graph, where G[K] denotes the subgraph of G induced by\nK. A clique in G is maximal if it is not properly contained in any other clique\nin G. Let K denote the set of maximal cliques of G. The clique graph C(G) of\nG has as its vertex set K, and two vertices of C(G) are adjacent if and only if\nthe intersection of the corresponding maximal cliques is non-empty. Moreover,\nevery edge K1K2 of C(G) is given a weight equal to |K1 \u2229K2|. Chordal graphs\ncan be represented using so-called clique trees, and many different definitions\nand characterizations of clique trees have appeared in the literature (see for\nexample [6]). We use a characterization due to Bernstein and Goodman [4]: a\ntree T with vertex set K is a clique tree of G if and only if T is a maximum\nweight spanning tree of C(G). See Figure 3 for an example of a chordal graph\nG and a clique tree of G.\na b c d\ne\nf g h\ni\na b\ne f\nb c\ne f\ni\nf g\nd\ng h\nd\nFig. 3. A chordal graph G (left) and a clique tree T of G.\nWe refer to a set K \u2208 K as a bag of T . We define the notions root bag, parent\nbag, child bag and leaf bag of a clique tree similar to the notions root, parent,\nchild and leaf of a \u201cnormal\u201d tree. If the bag Kr \u2208 K is the root bag of a clique\ntree T of G, then we say that T is rooted at Kr. A descendant of a bag K is a\nbag K\u2217 such that K lies on the (unique) path from K\u2217 to the root bag Kr in\nT . Every bag K 6= Kr of a clique tree T has exactly one parent bag K \u2032 in T .\nWe say that a vertex v \u2208 K is given to the parent bag K \u2032 if v \u2208 K \u2229K \u2032, i.e., if v\nis both in the child bag K and in the parent bag K \u2032. We say that vertex v \u2208 K\nstays behind if v \u2208 K \\K \u2032, i.e., if v is in the child bag K but not in the parent\nbag K \u2032. The characterization of a clique tree given above immediately implies\nthe following observation.\nObservation 1 Let G be a connected chordal graph with at least two maximal\ncliques. Let T = (K, E) be a clique tree of G rooted at Kr. At least one vertex\nof any bag K 6= Kr of T is given to the parent bag of K and at least one vertex\nstays behind. Moreover, |K| \u2265 2 for all K \u2208 K.\nIt is well-known that a connected graph is chordal if and only if it has a\nclique tree [18]. We will make use of the following results.\n5\nTheorem 3 ([20]). Let G = (V,E) be a chordal graph. Then\n\u2211\nK\u2208K |K| =\nO(|V |+ |E|).\nTheorem 4 ([6, 15]). A clique tree of a connected chordal graph G = (V,E)\ncan be constructed in O(|V |+ |E|) time.\n2.2 An outline of our algorithm\nOur algorithm for solving the R5-Role Assignment problem on chordal graphs\ntakes as input a chordal graph G = (V,E), and either outputs an R5-role assign-\nment of G, or outputs NO if such a role assignment does not exist. If the graph\nG is disconnected, then the algorithm described below is executed on each of\nthe connected components of G. In that case, the algorithm outputs an R5-role\nassignment of G if and only if it found an R5-role assignment of every connected\ncomponent of G, and outputs NO otherwise. We assume from now on that the\ninput graph G is connected.\nThe algorithm starts by computing a clique tree T of G, and then executes\ntwo phases. . In Phase 1, the algorithm assigns a label to every vertex, and decides\nwhether or not G is R5-role assignable. If so, then the labels of the vertices are\nused in Phase 2 to determine which role must be assigned to each vertex in order\nto obtain an R5-role assignment of G.\nPhase 1. Decide whether or not G has an R5-role assignment\nIn Phase 1, the algorithm processes the bags of T in a \u201cbottom-up\u201d manner,\nstarting with the leaf bags of T , and processing a bag K only after all its child\nbags have been processed. When processing bag K, the algorithm computes\na label LK(v) for each vertex v \u2208 K; this label LK(v) will be referred to as\nthe K-label of v. Initially, each vertex v \u2208 K is assigned a label LK(v) = 0.\nThereafter, our algorithm updates the labels of the vertices of this bag in order\nto maintain information about the possible roles that these vertices can get in\na possible R5-role assignment of G, as well as information about the possible\nroles of their neighbors. To this end, it uses the labels defined in Table 1. This\nupdating process first generates a new label for v in K based on the labels that\nv has in the child bags of K; thereafter it updates all labels in K based on the\ndifferent labels that are now present in K.\nLabels of two vertices can be conflicting if they represent information on the\npossible roles of the vertices that cannot be combined to an R5-role assignment.\nFor example, no two vertices in a bag can both get label 1, because this would\nmean each of them must have role 1. Our algorithm first checks if there are any\nconflicting labels. If so, it outputs NO. Otherwise, it updates the labels in order\nto maintain Invariant 1 below. Here, a solution on G is an R5-role assignment\nof G. A partial solution on a subgraph H of G is a mapping r\u2032 : VH \u2192 {1, 2}\nsuch that no two adjacent vertices x, y of H have roles that are forbidden by R5\n(i.e., we do not have r\u2032(x) = r\u2032(y) = 1), and every vertex x in H not adjacent\nto a vertex in G \u2212H has neighbors with the roles required by R5 (at least one\nneighbor y with role r\u2032(y) = 2, and if r\u2032(x) = 2, also at least one neighbor z with\nrole r\u2032(z) = 1).\n6\nInvariant 1 Let V \u2032 be the set of vertices of G that do not belong to any descen-\ndant of a bag K \u2032. Then a partial solution on G[V \u2032 \u222a K \u2032] can be extended to a\nsolution on G if and only if it satisfies the constraints given by the labels LK(v)\nof the vertices v \u2208 (K \u2229K \u2032) for every child bag K of K \u2032.\nRecall that Kr is the root of the clique tree. Suppose that at some moment\nbag Kr is processed. We observe that V \u2032 \u222aK \u2032 = Kr in Invariant 1 if K \u2032 = Kr.\nHence, our algorithm ensures that a partial solution on G[V \u2032 \u222aK \u2032] = G[Kr] can\nbe extended to a solution on G if and only if it satisfies the constraints given by\nthe labels of the vertices on K \u2229Kr for every child bag K of Kr. Our algorithm\nwill now decide if such a partial solution on G[Kr] exists. If so, it finds one and\ngoes to Phase 2. If not, it outputs NO.\nPhase 2. Produce an R5-role assignment of G\nWhen Phase 2 starts, we know that an R5-role assignment exists for G. Now, the\nalgorithm will construct an R5-role assignment as follows. The partial solution\non G[Kr] found at the end of Phase 1 is propagated to a solution of G in a \u201ctop-\ndown\u201d manner, processing a bag K only after its parent bag has been processed.\nA bag K is processed as follows. Each vertex v \u2208 K that already has been\nassigned a role at an earlier step in Phase 2 keeps this role; Invariant 1 ensures\nthat such a role satisfies the constraints given by LK(v). Each vertex in K\nwithout a role gets a role. The algorithm does this in a greedy way by considering\nthese vertices one by one and assigning them a role that satisfies the constraints\nimposed by their labels. This leads to an R5-role assignment of G.\nWe now present Phase 1 and Phase 2 in detail. When doing this we show that\nInvariant 1 is maintained throughout Phase 1. As such we immediately prove\nthat our algorithm is correct.\n2.3 Phase 1 in detail\nTable 1 shows what labels a vertex v in a bag K can have. We observe that\nPhase 2 is only executed if G is indeed R5-role assignable. We implicitly assume\nthis in Table 1 and in the remainder of this section, whenever we write that some\nvertex gets some role in Phase 2.\nInitially, every vertex v in each bagK is assigned the label LK(v) = 0. During\nan execution of the algorithm, this label LK(v) will be updated: the arrows in\nFigure 4 represent all possible transitions between two labels. This figure will be\nclarified in detail later on. For now, we only note that no arrows point downwards\nin Figure 4. This corresponds to the fact that labels in a higher level contain\nmore information than labels in a lower level. For example, if a vertex v in bag\nK has a label 22 and one of its neighbors in K gets label 2, then we change\nthe label LK(v) into 2 before processing the parent bag of K. After all, label\n2 contains more information than label 22, as label 2 contains the information\nthat at least one neighbor of v will get role 2 in Phase 2.\n7\nLK(v) = 0 initial label of every vertex\nLK(v) = 1 v must get role 1 in Phase 2\nLK(v) = 2 v must get role 2 in Phase 2; it is ensured that v gets a neighbor\nwith role 1 and a neighbor with role 2\nLK(v) = 1\n\u2217 v belongs to a set J \u2286 K of at least two vertices that are all\nlabeled 1\u2217 because they are given to K from the same child\nbag in which a vertex with label 21 is left behind; exactly one\nvertex in J must get role 1 (and hence all others must get role 2)\nLK(v) = 21 v must get role 2 in Phase 2; it is ensured that v gets a neighbor\nwith role 2, but we must still make sure that v gets a neighbor with\nrole 1\nLK(v) = 22 v must get role 2 in Phase 2; it is ensured that v gets a neighbor\nwith role 1, but we must still make sure that v gets a neighbor with\nrole 2\nLK(v) = 1|2 v may get either role 1 or 2 in Phase 2; in the latter case it is ensured\nthat v gets a neighbor with role 1 and a neighbor with role 2\nLK(v) = 1|21 v may get either role 1 or 2 in Phase 2; in the latter case it is ensured\nthat v gets a neighbor with role 2, but we must still make sure that\nv gets a neighbor with role 1\nLK(v) = 1|22 v may get either role 1 or 2 in Phase 2; in the latter case it is ensured\nthat v gets a neighbor with role 1, but we must still make sure that\nv gets a neighbor with role 2\nTable 1. The different labels a vertex v can have.\nWe will now give a detailed description of the label assignments in Phase 1. At\neach step of this description, we will prove that these label assignments maintain\nInvariant 1.\nLetK be the bag that is currently being processed. As soon asK is processed,\nthe algorithm deals with the next bag until all bags have been processed. Recall\nthat the order in which this is done is such that a bag is processed only if all its\nchild bags have been processed.\nThe algorithm distinguishes between the following three phases. Phase 1a\ndeals with the case in which K 6= Kr and K is a leaf bag. Phase 1b deals with\nthe case in which K 6= Kr and K is not a leaf bag. Phase 1c deals with the case\nin which K = Kr. For Phase 1a and 1b, we recall that by Observation 1 at least\none vertex in K stays behind, and at least one vertex is given to its parent bag,\nwhich we denote by K \u2032.\nPhase 1a. Deal with leaf bags\nSuppose K 6= Kr is a leaf bag of T . Let v be a vertex that stays behind. The\nalgorithm distinguishes between the cases |K| = 2 and |K| \u2265 3.\nCase 1. |K| = 2.\nIn this case, v must have degree 1 in G. Let w be the other vertex of K. By\nObservation 1, we find that w is given to K \u2032.\n8\n01|21 1|22\n1\u2217 1|2 21 22\n1 2\nFig. 4. All possible labels and all possible transitions between them.\nSet LK(v) := 1 and LK(w) := 22.\nReason: Because v has degree 1 in G, v must get role 1. This means w must get\nrole 2, and we must ensure that at least one other neighbor of w gets role 2.\nHence, the given label assignments maintain Invariant 1.\nCase 2. |K| \u2265 3.\nSet LK(u) := 1|2 for every vertex u \u2208 K.\nReason: If in Phase 2 all vertices in K \u2229K \u2032 receive role 2, then we assign role\n1 to v and role 2 to all other vertices of K \\K \u2032. In the other case, when there\nexists a vertex x \u2208 K \u2229K \u2032 that receives role 1, we assign role 2 to v and every\nother vertex in K \\K \u2032. Hence, Invariant 1 is maintained.\nPhase 1b. Deal with non-leaf bags that are not the root bag\nSuppose K 6= Kr is not a leaf bag of T . Recall that we process K only after\neach of its child bags has been processed. Hence, LKc(v) 6= 0 for every vertex\nv \u2208 K that is given to K from a child bag Kc. Such a vertex v may belong to\ndifferent child bags, and consequently, it may have received different labels. We\nshow how to combine these multiple labels into a single label LK(v) in K such\nthat Invariant 1 is maintained. The algorithm distinguish between three cases.\nCase 1. K contains a vertex v that has label 1 in a child bag of K.\nOur algorithm distinguishes between the following cases.\nCase 1.1. Vertex v has received label 2, 21 or 22 in another child bag of K.\nOutput NO.\nReason: Invariant 1 forces v to have two different roles. This is not allowed.\nCase 1.2. There is a vertex w \u2208 K \\ {v} with label 1 in a child bag of K.\n9\nOutput NO.\nReason: Invariant 1 forces two adjacent vertices, namely v and w, both to have\nrole 1. This is not allowed.\nCase 1.3. There is a set J \u2286 K of vertices that received label 1\u2217 in a child bag\nof K to which v does not belong.\nOutput NO.\nReason: Invariant 1 forces two adjacent vertices, namely v and a vertex from J ,\nboth to have role 1. This is not allowed.\nCase 1.4. Cases 1.1\u2212 1.3 do not occur and |K| = 2.\nLet w be the other vertex of K. Note that either v or w stays behind in K due\nto Observation 1.\nCase 1.4.1. LKc(w) \u2208 {1\u2217, 1|2, 1|21, 21} in some child bag Kc of K.\nSet LK(v) := 1 and LK(w) := 2.\nReason: Invariant 1 forces v to get role 1, and consequently, w to get role 2. If\nLKc(w) = 1\n\u2217 in some child bagKc, then by label definition w has a neighbor with\nlabel 21 and this neighbor will get role 2 in Phase 2. If LKc(w) \u2208 {1|2, 1|21, 21},\nthen we also apply the label definitions.\nCase 1.4.2. LKc(w) \u2208 {1|22, 22} for every child bag Kc of K that contains w,\nand K\\K \u2032 = {v}.\nSet LK(v) := 1 and LK(w) := 22.\nReason: Invariant 1 forces v to have role 1, and consequently, w must get role\n2 and still requires a neighbor with role 2. Note that w may belong to no child\nbag of K.\nCase 1.4.3. LKc(w) \u2208 {1|22, 22} for every child bag Kc of K that contains w,\nand K\\K \u2032 = {w}.\nOutput NO.\nReason: Invariant 1 forces v to have role 1, and consequently w to have role 2,\nand then w gets no required neighbor with role 2. Note that w may belong to\nno child bag of K.\nCase 1.5. Cases 1.1\u2212 1.3 do not occur and |K| \u2265 3.\nSet LK(v) := 1 and LK(w) := 2 for every w \u2208 K\\{v}.\nReason: Vertex v must get role 1 by Invariant 1, and in this way each vertex in\nK \\ {v} will have a neighbor with role 1 (namely v) and a neighbor with role 2.\nWe conclude that Invariant 1 is maintained in every subcase described above.\nCase 2. K contains no vertex that received label 1 in a child bag, but K does\ncontain a vertex that received label 1\u2217 in a child bag.\n10\nFor some p \u2265 1, let K1, . . . ,Kp be the child bags of K that contain vertices with\nlabel 1\u2217. For i = 1, . . . , p, let V \u2217i be the set of vertices in Ki that have label\n1\u2217 in Ki, while not having label 2, 21 or 22 in any other child bag of K. So,\nexactly one vertex in each Ki must get role 1 and this vertex must be chosen\nfrom V \u2217i . Because such a vertex will be in K and two vertices with role 1 cannot\nbe adjacent, this vertex must be the same vertex for every V \u2217i . Hence, it must\nbe taken from the set V \u2217 =\n\u22c2p\ni=1 V\n\u2217\ni .\nThe algorithm distinguishes between the following cases.\nCase 2.1. |V \u2217| = 0.\nOutput NO.\nReason: See the above argumentation.\nCase 2.2. |V \u2217| = 1.\nLet V \u2217 = {v}.\nSet LK(v) := 1 and LK(w) := 2 for all w \u2208 K \\ {v}.\nReason: Why the algorithm sets LK(v) := 1 is explained above. The algorithm\nsets LK(u) := 2 for every w \u2208 K \\ {v} for the following three reasons. Firstly,\nnone of the vertices in K \\ {v} received label 1 in any of the child bags of K,\nsince we assumed that Case 1 does not occur. Secondly, the constraint imposed\nby the labels 1\u2217 in each Ki will be satisfied by v. Thirdly, every vertex in K \\{v}\nhas a neighbor that will get role 1 in Phase 2, namely v, and a neighbor that\nwill get role 2. The latter is true because |K| \u2265 3, which can be seen as follows.\nRecall that vertices only have label 1\u2217 if they are given to a parent bag in groups\nof size at least 2. This means K has size at least two. However, if |K| = 2 then\nK is properly contained in one of its child bags, contradicting Observation 1.\nHence |K| \u2265 3 holds indeed.\nCase 2.3. |V \u2217| \u2265 2 and V \u2217 \u2286 (K \u2229K \u2032).\nSet LK(v) := 1\u2217 for all v \u2208 V \u2217 and LK(w) := 2 for all w \u2208 K \\ V \u2217.\nReason: The same arguments as in Case 2.2 apply. The only difference is that\nthere are at least two vertices in V \u2217. Because these vertices are all given to K \u2032,\nthe algorithm later decides which one of them will get role 1.\nCase 2.4. |V \u2217| \u2265 2 and V \u2217 6\u2286 (K \u2229K \u2032).\nSet LK(v) := 1|2 for all v \u2208 V \u2217 and LK(w) := 2 for all w \u2208 K\\V \u2217.\nReason: The algorithm sets LK(v) := 1|2 for all v \u2208 V \u2217 for the following reason.\nIf a vertex v \u2208 V \u2217 \u2229K \u2032 receives role 1 in Phase 2, then all neighbors of v will\nreceive role 2. If all vertices in V \u2217\u2229K \u2032 receive role 2 (or if V \u2217\u2229K \u2032 = \u2205), then the\nalgorithm gives the required role 1 to one of the vertices in V \u2217\\K \u2032. The label of\nall other vertices in K is set to 2 because of the same three reasons as in Case\n2.2 and 2.3.\nWe conclude that Invariant 1 is maintained in every subcase described above.\n11\nCase 3. K contains no vertex that received label 1 or 1\u2217 in any of its child bags.\nWe first update the labels of each vertex v \u2208 K that is given to K from the child\nbags of K. If v is in only one child bag Kc of K, then set LK(v) := LKc(v).\nOtherwise, if v has labels in two or more different child bags of K, the algorithm\nacts as follows. It first combines two labels into a new label as prescribed by\nTable 2, then combines this new label with the next label (if it exists), and\ncontinues until a single label remains.\n2 21 22 1|2 1|21 1|22\n2 2 2 2 2 2 2\n21 2 21 2 2 21 2\n22 2 2 22 2 2 22\n1|2 2 2 2 1|2 1|2 1|2\n1|21 2 21 2 1|2 1|21 1|2\n1|22 2 2 22 1|2 1|2 1|22\nTable 2. Combining two labels from different child bags.\nWe explain Table 2 by discussing the following two cases. Suppose v \u2208 K has\nlabel 21 in child bag Kc and label 22 in child bag Kd. Label 21 means that v is\nensured to have a neighbor that will receive role 2 in Phase 2. Label 22 means\nthat v is ensured to have a neighbor that will receive role 1 in Phase 2. Hence,\nthe algorithms sets LK(v) := 2. Suppose v \u2208 K has label 21 in Kc and label\n1|22 in Kd. Then v cannot get role 1 in Phase 2. In that case the algorithm sets\nLK(v) := 2. Arguments like the above follow directly from the label definitions\nand can be used for all other combinations. This way Invariant 1 is maintained.\nAfter the algorithm has updated the label of each vertex that was given to\nK from a child bag, the following holds for each v \u2208 K. If v was given to K from\na child bag then LK(v) 6= 0; otherwise LK(v) = 0. We write\nLK := {LK(v) | v \u2208 K},\nand LK\\K\u2032 = {LK(v) | v \u2208 K\\K \u2032} and LK\u2229K\u2032 = {LK(v) | v \u2208 K \u2229K \u2032}, where\nwe recall that K \u2032 is the parent bag of K.\nThe algorithm distinguishes between the following cases.\nCase 3.1. {22} \u2286 LK \u2286 {0, 1|2, 1|21, 1|22, 2, 21, 22}.\nCase 3.1.1. |K| \u2265 3 or |LK \u2229 {2, 21, 22}| \u2265 2.\nChange every K-label 22 into 2 and go to Case 3.2.\nReason: If |K| \u2265 3, then K will contain at least two vertices with role 2. Hence,\nany vertex with label 22 in K will get its required neighbor with role 2. The\nsame is true if |K| = 2 and both vertices of K have a K-label in {2, 21, 22}.\n12\nCase 3.1.2. |K| = 2 and |LK \u2229 {2, 21, 22}| = 1.\nLetK = {v, w}. Because 22 \u2208 LK we may assume that LK(v) = 22 and LK(w) \/\u2208\n{2, 21, 22}, thus LK(w) \u2208 {0, 1|2, 1|21, 1|22}. Note that either v or w stays behind\nin K by Observation 1.\nCase 3.1.2.1. LK(w) \u2208 {0, 1|21} and K\\K \u2032 = {v}.\nSet LK(w) := 21.\nReason: Vertex v stays behind and needs a neighbor with role 2. This neighbor\ncan only be w.\nCase 3.1.2.2. LK(w) \u2208 {0, 1|21}, and K\\K \u2032 = {w}.\nSet LK(w) := 1.\nReason: First suppose LK(w) = 0. Then w is not in a child bag of K. Because\nw stays behind, this means that w has degree one. Hence w must receive role 1.\nNow suppose LK(w) = 1|21. Because w stays behind, and v will receive role 2,\nwe find that w will not get a neighbor with role 1, which it would need if it gets\nrole 2. Hence w must get role 1.\nCase 3.1.2.3. LK(w) \u2208 {1|2, 1|22}.\nSet LK(w) := 2.\nReason: First suppose K\\K \u2032 = {v}. In this case w can function as the neighbor\nwith role 2 that v needs. Because w then has a neighbor, namely v, that will\nreceive role 2, we can set LK(w) := 2, even in the case that w had label 1|22\nin K. Now suppose K\\K \u2032 = {w}. The algorithm lets w be the required role 2\nneighbor of v. If LK(w) = 1|22, then the algorithm sets LK(w) := 2 instead of\nLK(w) := 22, because v will be a role 2 neighbor of w.\nWe conclude that Invariant 1 is maintained in every subcase described above.\nCase 3.2. LK \u2229 {2, 21} 6= \u2205 and LK \u2286 {0, 1|2, 1|21, 1|22, 2, 21}.\nThe algorithm distinguishes between the following cases.\nCase 3.2.1. LK\\K\u2032 \u2229 {0, 1|2, 1|21, 1|22} 6= \u2205.\nChange every K-label in {0, 1|21, 1|22} into 1|2, and every K-label 21 into 2.\nReason: Let v \u2208 K\\K \u2032 have LK(v) \u2208 {0, 1|2, 1|21, 1|22}. If none of the vertices\nin K \u2229K \u2032 receives role 1 in Phase 2, then Phase 2 assigns role 1 to v; otherwise\nv gets role 2. The latter is fine, because K contains a vertex with K-label 2 or\n21 that will receive role 2.\nCase 3.2.2. {21} \u2286 LK\\K\u2032 \u2286 {21, 2} and |LK\u2229K\u2032 \u2229 {0, 1|2, 1|21, 1|22}| = 0.\nOutput NO.\nReason: There is a vertex in K\\K \u2032 with K-label 21, and this vertex will not get\nits required neighbor with role 1.\n13\nCase 3.2.3. {21} \u2286 LK\\K\u2032 \u2286 {21, 2} and |LK\u2229K\u2032 \u2229 {0, 1|2, 1|21, 1|22}| = 1\nLet v \u2208 LK\u2229K\u2032 be the (unique) vertex in K \u2229K \u2032 that has LK(v) \u2208 {0, 1|2, 1|21}.\nSet LK(v) := 1 and change the K-label of every vertex in K\\{v} into 2.\nReason: First suppose |K| = 2, say K = {v, w}. Observe that w \u2208 K\\K \u2032 due to\nObservation 1. Because 21 \u2208 LK , we then find that LK(w) = 21. The algorithm\nchanges this label into 2, because v is a neighbor of w that will get role 1 after\nupdating its K-label. Now suppose |K| \u2265 3. Because v will get role 1, every\nvertex in K\\{v} will get role 2. Because |K| \u2265 3, every vertex in K\\{v} is\nguaranteed to have a neighbor with role 2. Hence, the K-label of such a vertex\nis updated into 2.\nCase 3.2.4. {21} \u2286 LK\\K\u2032 \u2286 {21, 2} and |LK\u2229K\u2032 \u2229 {0, 1|2, 1|21, 1|22}| \u2265 2.\nLet J consist of all vertices in K \u2229 K \u2032 with K-label in {0, 1|2, 1|21, 1|22}, so\n|J | \u2265 2.\nChange the K-label of every vertex in J into 1\u2217, and the K-label of every vertex\nin K\\J into 2.\nReason: We use the same arguments as in Case 3.2.2.2 after observing that\n|K| \u2265 3 holds.\nCase 3.2.5. LK\\K\u2032 = {2}.\nChange every K-label 0 into 1|21, and every K-label 1|22 into 1|2.\nReason: Because all vertices in K\\K \u2032 have K-label 2, they do not need a vertex\nwith role 1 in K \u2229 K \u2032, and every vertex in K \u2229 K \u2032 is guaranteed to have a\nneighbor with role 2. Therefore, the algorithm does as above.\nWe conclude that Invariant 1 is maintained in each subcase of Case 3.2.\nCase 3.3. LK \u2286 {0, 1|2, 1|21, 1|22}.\nCase 3.3.1. |K| \u2265 3, or |K| = 2 with LK\\K\u2032 = {1|2}, or |K| = 2 with LK\\K\u2032 =\n{1|21} and LK\u2229K\u2032 \u2208 {1|2, 1|21}.\nChange every K-label into 1|2.\nReason: First suppose |K| \u2265 3. Then each vertex in K will get a neighbor with\nrole 2. If no vertex of K \u2229K \u2032 gets role 1, the algorithm gives role 1 to a vertex in\nK\\K \u2032. Otherwise every vertex in K\\K \u2032 gets role 2 and will then have a neighbor\nwith role 1. Hence, the algorithm correctly updates each K-label into 1|2.\nNow suppose |K| = 2 with LK\\K\u2032 = {1|2}. Let K = {v, w} with v \u2208 K \u2229K \u2032,\nand w \u2208 K \u2229K \u2032. Thus, LK(v) = 1|2. If w gets role 1 in Phase 2, then v will get\nrole 2. If w gets role 2, then it already has a neighbor in K \u2032 with some role, as\nK \u2032 \\K 6= \u2205 due to Observation 1. If w still needs a neighbor of a specific role,\nthen the algorithm sets v to that role; otherwise v is assigned an arbitrary role.\nHence, the algorithm correctly sets L(w) := 1|2.\nFinally suppose |K| = 2 with LK\\K\u2032 = {1|21} and LK\u2229K\u2032 \u2208 {1|2, 1|21}.\nLet K = {v, w} with v \u2208 K\\K \u2032 and w \u2208 K \u2229 K \u2032. Then LK(v) = 1|21 and\n14\nLK(w) \u2208 {1|2, 1|21}. If w gets role 2 then v gets role 1 as otherwise, when v gets\nrole 2, v would not have a required neighbor with role 1. Note that w already is\nguaranteed to have a neighbor with role 2. If w gets role 1 then v gets role 2.\nThen w will be the required role 1 neighbor of v.\nCase 3.3.2 |K| = 2 with LK\\K\u2032 = {1|21} and LK\u2229K\u2032 \u2208 {0, 1|22}.\nLet K = {v, w}. Assume v \u2208 K\\K \u2032, thus LK(v) = 1|21. By Observation 1 we\nfind that w \u2208 K \u2229K \u2032, thus LK(w) \u2208 {0, 1|22}.\nSet LK(v) := 1|2 and LK(w) := 1|22.\nReason: If w gets role 2 then v gets role 1 as otherwise, when v gets role 2, v\nwould not have a required neighbor with role 1. Then w is still required to get\na neighbor with role 2. If w gets role 1 then v gets role 2. Then w will be the\nrequired role 1 neighbor of v.\nCase 3.3.3. |K| = 2 with LK\\K\u2032 = {1|22}.\nLet K = {v, w}. Assume v \u2208 K\\K \u2032, thus LK(v) = 1|22. By Observation 1 we\nfind that w \u2208 K \u2229K \u2032. Note that LK(w) \u2208 {0, 1|2, 1|21, 1|22}.\nSet LK(v) := 1|2 and LK(w) := 2.\nReason: Vertex w cannot get role 1, because then v would get role 2 and miss\nits required neighbor with role 2. Since K \u2032 is maximal, there exists a vertex\nw\u2032 \u2208 K \u2032\\K. If w\u2032 gets role 1, the algorithm assigns role 2 to role v. If w\u2032 gets\nrole 2, the algorithm assigns role 1 to v. In this way w will have neighbors of\nboth roles.\nCase 3.3.4. |K| = 2 with LK\\K\u2032 = {0}.\nLet K = {v, w}. Assume v \u2208 K\\K \u2032, thus LK(v) = 0. This means that\nv is vertex of degree 1 in G. By Observation 1 we find that w \u2208 K \u2229 K \u2032.\nNote that LK(w) 6= 0, because then K would be a leaf bag. Hence LK(w) \u2208\n{1|2, 1|21, 1|22}.\nCase 3.3.4.1. LK(w) \u2208 {1|2, 1|21}.\nSet LK(v) := 1 and LK(w) := 2.\nReason: Because v has degree 1 in G, v must get role 1. This means that w must\nget role 2 and that w has a neighbor with role 1, namely v.\nCase 3.3.4.2. LK(w) = 1|22.\nSet LK(v) := 1 and LK(w) := 22.\nReason: Because v has degree 1 in G, v must get role 1. This means that w must\nget role 2 but still needs a neighbor with role 2.\nWe conclude that Invariant 1 is maintained in each subcase of Case 3.3.\nPhase 1c. Deal with the root bag\n15\nThe root bag Kr is the last bag of T to be processed in Phase 1. Because the\nroot bag is the only bag of T that does not have a parent bag, the case analysis\nfor Kr slightly differs from the case analysis for other bags of T , as we explain\nbelow. After processing Kr, the algorithm enters Phase 2 unless it has output\nNO.\nCase 1. Kr contains a vertex v that has label 1 in a child bag of Kr.\nThe algorithm acts as in Case 1 of Phase 1b except when it is in Case 1.4.2,\nwhere it does as follows instead.\nOutput NO.\nReason: Vertex w is not able to get a required role 2 neighbor.\nCase 2. Kr contains no vertex that received label 1 in a child bag, but Kr does\ncontain a vertex that received label 1\u2217 in a child bag.\nThe algorithm acts as in Case 2 of Phase 1b except when it is in Case 2.3 or 2.4,\nwhere it does as follows instead.\nSet LKr (v) := 1 for some v \u2208 V \u2217 and LKr (w) := 2 for all w \u2208 Kr\\{v}.\nReason: Kr does not have a parent bag. Hence, the algorithm must assign one\nof the vertices role 1.\nCase 3. Kr contains no vertex that received label 1 or 1\u2217 in one of its child\nbags.\nThe algorithm first updates the Kr-label of every vertex in Kr as in Case 3 of\nPhase 1b and then distinguishes between the following cases.\nCase 3.1. LKr \u2229 {1|2, 1|21, 1|22} 6= \u2205.\nBecause |Kr| \u2265 2, there exist two different vertices v, w in Kr. Assume LKr (v) \u2208\n{1|2, 1|21, 1|22}. Note that LKr (w) \u2208 {0, 1|2, 1|21, 1|22, 2, 21, 22}.\nCase 3.1.1. |Kr| \u2265 3, or |Kr| = 2 with LKr (w) \u2208 {1|2, 1|21, 2, 21}.\nSet LKr (v) := 1 and LKr (u) := 2 for all u \u2208 Kr\\{v}.\nReason: First suppose |Kr| \u2265 3. This means that |Kr\\{v}| \u2265 2. Hence, every\nvertex in Kr\\{v} has a neighbor with role 2, while v is the required role 1\nneighbor. Now suppose |Kr| = 2 with LKr (w) \u2208 {1|2, 1|21, 2, 21}. Then w needs\nno neighbor of role 2 anymore, and v will be its neighbor of role 1.\nCase 3.1.2. |Kr| = 2 with LKr (v) \u2208 {1|2, 1|21} and LKr (w) \u2208 {0, 1|22}.\nSet LKr (v) := 2 and LKr (w) := 1.\nReason: In this way, both v and w have the required roles in their neighborhoods.\nCase 3.1.3. |Kr| = 2 either with LKr (v) = 1|22 and LKr (w) = 0, or with\nLKr (v) = 1|21 and LKr (w) = 22.\nOutput NO.\n16\nReason: In the first case, w is in no child bag of Kr. If w gets role 2, then w either\nhas no neighbor with role 1 or no neighbor with role 2. If w gets role 1, then v\ngets role 2. However, then v has no neighbor with role 2. Hence, the algorithm\ncorrectly outputs NO. In the second case w will get role 2 and has no neighbor\nwith role 2, unless v gets role 2. However, in that case, v has no neighbor with\nrole 1. Hence, the algorithm correctly outputs NO.\nCase 3.1.4. |Kr| = 2 either with LKr (v) = 1|22 and LKr (w) \u2208 {1|22, 22}, or\nwith LKr (v) = 1|2 and LKr (w) = 22.\nSet LKr (v) := 2 and LKr (w) := 2.\nReason: In this way, vertex v and w each get role 2, and both have a neighbor\nwith role 1 from a descendant of Kr, and a neighbor with role 2, namely each\nother.\nCase 3.2. LKr \u2286 {0, 2, 21, 22}.\nCase 3.2.1. {21} \u2286 LKr \u2286 {2, 21, 22}, or |Kr| = 2 with {0} \u2286 LKr \u2286 {0, 22}.\nOutput NO.\nReason: Suppose {21} \u2286 LKr \u2286 {2, 21, 22}. Then the vertex that has Kr-label\n21 has no neighbor of role 1.\nSuppose |Kr| = 2 with {0} \u2286 LKr \u2286 {0, 22}. If LKr = {0}, then G is\na graph on two vertices. Consequently, G has no R5-role assignment. Suppose\nLKr = {0, 22}. Let Kr = {v, w} with LKr (v) = 0 and LKr (w) = 22. If v gets\nrole 2, then v has no neighbor with role 1. Hence v must get role 1. In that case,\nhowever, w has no neighbor with role 2. Thus, the algorithm correctly outputs\nNO.\nCase 3.2.2. LKr \u2286 {2, 22}.\nChange the Kr-label of every vertex in Kr into 2.\nReason: In this way all vertices inKr will get role 2, while having both a neighbor\nwith role 1 and a neighbor with role 2.\nCase 3.2.3. |Kr| \u2265 3 with {0} \u2286 LKr .\nLet v \u2208 Kr have LKr (v) = 0.\nSet LKr (v) := 1 and LKr (u) := 2 for all u \u2208 Kr\\{v}.\nReason: Because |Kr| \u2265 3, we find that at least two vertices in Kr get role 2.\nHence, all vertices in Kr get the required roles in their neighborhood.\nCase 3.2.4. |Kr| = 2 with {0} \u2286 LKr * {0, 22}.\nLet Kr = {v, w}, and let v be a vertex with Kr-label 0. Then LKr (w) \u2208 {2, 21},\nsince otherwise we would have LKr \u2286 {0, 22}.\nSet LKr (v) := 1 and LKr (w) := 2.\nReason: In this way both v and w get the required roles in their neighborhood.\n17\n2.4 Phase 2 in detail\nSince the algorithm entered Phase 2, an R5-role assignment of G exists. Note\nthat at the end of Phase 1 every vertex in Kr either has Kr-label 1 or Kr-label\n2. The algorithm will assign role 1 to the vertices in Kr with Kr-label 1 and\nrole 2 to the vertices in Kr with Kr-label 2. It will then construct an R5-role\nassignment of G by propagating this partial solution on G[Kr] in a \u201ctop-down\u201d\nmatter, processing a bag K only after its parent bag has been processed. Note\nthat in this way a vertex has its most updated label when the algorithm assigns\nit a role.\nLet K \u2032 be a child bag of Kr. Any vertex u \u2208 K \u2032 that has been assigned a role\nalready must be a vertex of Kr. Because the partial solution on G[Kr] has been\nchosen such that Invariant 1 is maintained, the role of such a vertex u satisfies\nthe constraints given by LK\u2032(u). Hence u keeps its role.\nThe algorithm considers all vertices of K \u2032 without a role one by one. Let v\nbe such a vertex. If LK\u2032(v) = 1 then v gets role 1. If LK\u2032(v) \u2208 {2, 21, 22} then v\ngets role 2. If LK\u2032(v) = 1\u2217, then v belongs to a set J of vertices that each have\nK \u2032-label 1\u2217. We assign role 1 to v unless another vertex from J already got role 1.\nOtherwise, LK\u2032(v) \u2208 {1|2, 1|21, 1|22} must hold. In that case we follow exactly\nthe same analysis as in the description of Phase 1 by checking if a neighbor\nw of v in Kr still needs a required neighbor of certain role. If so, we let v be\nthis neighbor of w. In this way the roles of the vertices of K \u2032 that are also in\nchild bags of K \u2032 satisfy the constraints given by their labels in these child bags.\nInvariant 1 then again ensures that we can extend our partial solution to every\nchild bag K of K \u2032, and we proceed accordingly until all vertices have obtained\na role. In this way we obtain an R5-role assignment of G.\n2.5 Running time analysis\nTheorem 5. The R5-Role Assignment problem can be solved in linear time\nfor the class of chordal graphs.\nProof. Let G = (V,E) be a connected chordal graph. The algorithm first com-\nputes a clique tree T = (K, E) of G, which can be done in O(|V |+ |E|) time by\nTheorem 4. The algorithm then acts in the way described in Sections 2.2, 2.3,\nand 2.4. We already proved correctness of the algorithm in those sections.\nIn Phase 1, the algorithm computes |K| labels per bag K. Then, by The-\norem 3, there are O(|V | + |E|) labels to compute in total. We first determine,\nfor each vertex v \u2208 K, the time required to compute the label LK(v), given the\nlabels of v in the child bags of K. Next we determine the time required for the\nremaining part of Phase 1.\nThe time required to construct a label LK(v) from a combination of la-\nbels from child bags of K to which v belongs is proportional to the number of\nsuch child bags. For the entire clique tree, this combining of labels then costs\nO(\u2211K\u2208K |K|) = O(|V |+ |E|) time by Theorem 3.\nThe time required to update the labels in a bagK as prescribed in Section 2.2\nis O(|K|) by first scanning K to decide what subcase applies and then updating\n18\nthe labels for K. Again by Theorem 3, this requires O(|V |+ |E|) for the entire\nclique tree. We conclude that Phase 1 runs in O(|V |+ |E|) time.\nDue to our greedy approach in Phase 2, this phase can also be executed in\nO(|V | + |E|) time. We conclude that the overall running time of our algorithm\nis O(|V |+ |E|). This completes the proof of Theorem 5. uunionsq\n2.6 A remark regarding R6-role assignments\nIn our linear time algorithm that solves the 2-Role Assignment problem on\nchordal graphs we do not have to check if the input graph has an R6-role assign-\nment (cf. Theorem 2). This is rather \u201cfortunate\u201d as the R6-Role Assignment\nproblem turns out to be NP-complete even when restricted to split graphs, a\nsubclass of chordal graphs. For showing this we need some extra terminology.\nA split graph is a graph G = (V,E) whose vertex set V can be partitioned into\ntwo disjoint sets I and C, such that I is an independent set in G and C is a clique\nin G. A hypergraph H is a pair (Q,S) consisting of a set Q = {q1, . . . , qm}, called\nthe vertices of H, and a set S = {S1, . . . , Sn} of nonempty subsets of Q, called\nthe hyperedges of H. With a hypergraph H = (Q,S) we associate its incidence\ngraph I, which is a bipartite graph with partition classes Q and S, where for any\nq \u2208 Q,S \u2208 S we have qS \u2208 EI if and only if q \u2208 S. A 2-coloring of a hypergraph\nH = (Q,S) is a partition (Q1, Q2) of Q such that Q1 \u2229 Sj 6= \u2205 and Q2 \u2229 Sj 6= \u2205\nfor 1 \u2264 j \u2264 n. A hypergraph H is called nontrivial if Q contains at least three\nvertices and Q is a member of S. The Hypergraph 2-Colorability problem\nasks whether a given hypergraph has a 2-coloring. This problem, also known as\nSet Splitting, is NP-complete (cf. [16]). Obviously, it remains NP-complete\nwhen restricted to nontrivial hypergraphs.\nProposition 1. The R6-Role Assignment problem is NP-complete for the\nclass of split graphs.\nProof. Let (Q,S) be a nontrivial hypergraph. In its incidence graph I we add\nan edge between every pair of vertices in Q. This results in a split graph G. We\nclaim that (Q,S) has a 2-coloring if and only if G has an R6-role assignment.\nSuppose (Q,S) has a 2-coloring (Q1, Q2). Since |Q| \u2265 3, we may without loss\nof generality assume that |Q2| \u2265 2. We give each q \u2208 Q1 role 1 and each q \u2208 Q2\nrole 2. We assign role 1 to each S \u2208 S. Because (Q1, Q2) is a 2-coloring, each\nvertex in S has a neighbor with role 1 and a neighbor with role 2 in G. Because\nQ is a clique in G and |Q2| \u2265 2, each vertex in Q2 has a neighbor with role 1 and\na neighbor with role 2. For the same reason, each vertex in Q1 has a neighbor\nwith role 2. Since (Q,S) is nontrivial, Q \u2208 S. This guarantees that also in case\n|Q1| = 1, each vertex in Q1 has a neighbor with role 1. We conclude that G has\nan R6-role assignment.\nSuppose G has an R6-role assignment. Then every vertex in S has a neighbor\nwith role 1 and a neighbor with role 2. By construction, these neighbors are in\nQ. This immediately gives a 2-coloring of (Q,S). uunionsq\n19\n3 Complexity of k-Role Assignment for k \u2265 3\nIt is known that the k-Role Assignment problem is NP-complete for any fixed\nk \u2265 2 [13]. We proved in Section 2 that 2-Role Assignment can be solved in\nlinear time when the input graph is chordal. In this section, we show that the\nk-Role Assignment problem for chordal graphs is NP-complete for every fixed\nk \u2265 3. We use a reduction from the Hypergraph 2-Colorability problem.\nOur NP-completeness proof is more involved than the one for the general case\nin [13], as the graph constructed there (also from an instance of Hypergraph\n2-Colorability) is not chordal.\nTheorem 6. For k \u2265 3, the k-Role Assignment problem is NP-complete for\nthe class of chordal graphs.\nProof. Let k \u2265 3. We use a reduction from Hypergraph 2-Colorability. Let\n(Q,S) be a nontrivial hypergraph with incidence graph I.\nWe modify I as follows. Firstly, we add an edge between any two vertices inQ,\nso Q becomes a clique. Secondly, for each S \u2208 S we take a path PS = pS1 \u00b7 \u00b7 \u00b7 pSk\u22122\nand connect it to S by the edge pSk\u22122S, so these new paths P\nS are pendant paths\nin the resulting graph. Thirdly, we add a copy Hq of a new graph H for each\nq \u2208 Q. Before we explain how to do this, we first define H. Start with a path\nu1u2 \u00b7 \u00b7 \u00b7u2k\u22124. Then take a complete graph on four vertices a, b, c, d, and a com-\nplete graph on four vertices w, x, y, z. Add the edges cu1, du1, u2k\u22124w, u2k\u22124x.\nWe then take three paths S = s1 \u00b7 \u00b7 \u00b7 sk\u22122, T = t1 \u00b7 \u00b7 \u00b7 tk\u22122 and T \u2032 = t\u20321 \u00b7 \u00b7 \u00b7 t\u2032k\u22122,\nand we add the edges sk\u22122w, ctk\u22122, dt\u2032k\u22122. This finishes the construction of H.\nWe connect a copy Hq to q via the edge quq1, where u\nq\n1 is the copy of the vertex\nu1. We call the resulting graph G; notice that this is a connected chordal graph.\nSee Figure 5 for an example.\ny z\nw x\ns2 u4\ns1\nt1 t\u20321\nt2 u1 t\u20322\nc d\na b\nH\npS1\npS2\nS\nq\nuq1\nS\nQ\nG\nHq\nFig. 5. The graph H (left side) and the graph G (right side) when k = 4.\nWe first show that if G has a k-role assignment r : VG \u2192 {1, . . . , k}, then r is\nan R\u2217-role assignment, where R\u2217 denotes the k-vertex path on vertices 1, . . . , k\n20\nsuch that there is an edge between vertex i and i + 1 for i = 1, . . . , k \u2212 1, and\na loop in vertex k \u2212 1 and in vertex k. To see this, consider a copy Hq of H in\nG; we show that we can assign roles to the vertices of Hq in only one way. For\nconvenience, we denote the vertices of Hq without the superscript q.\nLet A be an induced path in G on at most k vertices, starting in a vertex\nof degree 1. We claim that the k-role assignment r must assign exactly |VA|\ndifferent roles to the vertices of A, i.e., we have |r(VA)| = |VA|. This can be\nseen as follows. Suppose |r(VA)| = \u03b1 < |VA|. We may without loss of generality\nassume that, starting from the vertex of degree 1, r assigns roles 1, . . . , \u03b1 to the\nfirst \u03b1 vertices of A and role \u03b1 \u2212 1 to the next vertex of A. However, then all\nneighbors of every role in R are fixed. Then, because G is connected, none of\nthe vertices of G gets assigned role k \u2265 |VA| > \u03b1 by r. This means that r is not\na k-role assignment of G, which is a contradiction.\nFrom the above, we find that we may write r(ti) = i for i = 1, . . . , k\u2212 2 and\nr(c) = k\u2212 1. This implies that a vertex with role 1 only has vertices with role 2\nin its neighborhood and a vertex with role i for 2 \u2264 i \u2264 k \u2212 2 only has vertices\nwith role i \u2212 1 and role i + 1 as neighbors. Then a vertex with role k can only\nbe adjacent to vertices with role k \u2212 1 or role k. Hence c must have a neighbor\nwith role k.\nSuppose r(d) = k. Then r(t\u2032k\u22122) \u2208 {k \u2212 1, k} and this eventually leads to\nr(t\u20321) \u2265 2 without a neighbor of role r(t\u20321)\u2212 1 for t\u20321. This is not possible. Hence\nr(d) 6= k. This means that k \u2208 r({a, b, u1}). Since a, b, u1 are neighbors of d as\nwell and a vertex with role k can only have neighbors with role k \u2212 1 and k, we\nthen find that d has role k \u2212 1.\nThe above implies that a and b have their role in {k \u2212 2, k \u2212 1, k}. Suppose\nk = 3. If r(a) = 1, then r(b) = 2 implying that r is a 2-role assignment (as\nr(c) = r(d) = 2 and then r(NG(b)) = {1, 2} implying that r cannot use role 3\nbecause G is connected). Suppose r(a) = 2. Then a needs a neighbor with role\n1. Hence r(b) = 1, but then r is a 2-role assignment. Suppose r(a) = 3. Then\nr(b) 6= 2, as otherwise b needs a neighbor with role 1. Hence r(b) = 3. This means\nthat r is an R\u2217-role assignment. Suppose k \u2265 4. If r(a) = k \u2212 2, then a needs\na neighbor with role k \u2212 3. So, r(b) = k \u2212 3. However, this is not possible since\nvertex b with role k \u2212 3 is adjacent to vertex c with role k \u2212 1. If r(a) = k \u2212 1,\nthen r(b) = k \u2212 2. This is not possible either. Hence r(a) = k and for the same\nreasons r(b) = k. Then r is an R\u2217-role assignment.\nWe claim that (Q,S) has a 2-coloring if and only if G has a k-role assignment.\nSuppose (Q,S) has a 2-coloring (Q1, Q2). We show that G has an R\u2217-role\nassignment, which is a k-role assignment. We assign role i to each pSi for i =\n1, . . . , k \u2212 2 and role k \u2212 1 to each S \u2208 S. As (Q,S) is nontrivial, either Q1 or\nQ2, say Q2, has size at least two. Then we assign role k \u2212 1 to each q \u2208 Q1\nand role k \u2212 2 to neighbor uq1. We assign role k to each q \u2208 Q2 and k \u2212 1 to\nneighbor uq1. As |Q2| \u2265 2, every vertex in Q has a neighbor with role k. Hence,\nwe can finish off the role assignment by assigning roles to the remaining vertices\nof each copy Hq of H as follows. For convenience, we remove the superscript q.\nWe map each path S, T, T \u2032 to the path 1 \u00b7 \u00b7 \u00b7 k\u22122, where r(si) = r(ti) = r(t\u2032i) = i\n21\nfor i = 1, . . . , k \u2212 2. If u1 received role k \u2212 2 we assign ui role k \u2212 1 \u2212 i for\ni = 2, . . . , k\u22122 and we assign uk\u22122+i role i+1 for i = 1, . . . , k\u22122. Furthermore,\nwe assign role k\u22121 to c, d, w, and role k to a, b, x, y, z. If u1 received role k\u22121, it\nalready has a neighbor with role k (namely its neighbor in Q). Then we assign ui\nrole k\u2212 i for i = 2, . . . , k\u2212 1 and we assign uk\u22121+i role i+1 for i = 1, . . . , k\u2212 3.\nFurthermore, we assign role k \u2212 1 to c, d, w, x, and role k to a, b, y, z.\nTo prove the converse statement, suppose G has a k-role assignment r. As we\nhave shown above, by construction, G must have an R\u2217-role assignment. Then\neach pSi must have role i for i = 1, . . . , k\u2212 2. Then r(S) = k\u2212 1 for each S \u2208 S,\nand each S must have a neighbor in Q with role k\u2212 1 and a neighbor in Q with\nrole k. We define Q1 = {q \u2208 Q | r(q) = k \u2212 1} and Q2 = Q \\Q1. Then we find\nthat (Q1, Q2) is a 2-coloring of (Q,S). This completes the proof of Theorem 6.\nuunionsq\n4 Conclusions\nWe have settled an open problem of Sheng [24] by presenting a linear time algo-\nrithm that decides whether a chordal graph G = (V,E) has a 2-role assignment.\nWe showed that for any fixed k \u2265 3 the k-Role Assignment problem stays\nNP-complete even for the class of chordal graphs.\nRole assignments are also studied in topological graph theory. There, a graph\nG is called an emulator of a graph R if G has an R-role assignment. One of\nthe important questions is which graphs allow finite planar emulators; see for\nexample the recent paper of Rieck and Yamashita [22] for nice developments in\nthis area. An interesting question is the computational complexity of the k-Role\nAssignment problem for planar graphs. The answer to this question is already\nunknown for k = 2.\nAcknowledgements. The authors would like to thank Hans Bodlaender and the two\nanonymous referees for useful comments. The second author also thanks Ji\u0159\u00ed Fiala for\nfruitful discussions on the subject.\nReferences\n1. Abello, J., Fellows, M. R., and Stillwell, J. C. On the complexity and\ncombinatorics of covering finite complexes. Australian Journal of Combinatorics 4\n(1991) 103\u2013112.\n2. Angluin, D. Local and global properties in networks of processors. In 12th ACM\nSymposium on Theory of Computing (1980) 82\u201393.\n3. Angluin, D., and Gardiner, A. Finite common coverings of pairs of regular\ngraphs. Journal of Combinatorial Theory B 30 (1981) 184\u2013187.\n4. Bernstein, P. A., and Goodman, N. Power of natural semijoins. SIAM Journal\non Computing 10 (1981) 751\u2013771.\n5. Biggs, N. Constructing 5-arc transitive cubic graphs. Journal of London Mathe-\nmatical Society II 26 (1982) 193\u2013200.\n6. Blair, J. R. S, and Peyton, B. An introduction to chordal graphs and clique\ntrees. Graph Theory and Sparse Matrix Computation 56 (1993) 1\u201329.\n22\n7. Bodlaender, H. L. The classification of coverings of processor networks. Journal\nof Parallel Distributed Computing 6 (1989) 166\u2013182.\n8. Chalopin, J., M\u00e9tivier, Y., and Zielonka, W. Local computations in graphs:\nthe case of cellular edge local computations. Fundamenta Informaticae 74 (2006)\n85\u2013114.\n9. Everett, M. G., and Borgatti, S. Role colouring a graph. Mathematical Social\nSciences 21 (1991) 183\u2013188.\n10. Fiala, J., and Kratochv\u00edl, J. Complexity of partial covers of graphs. In 12th\nInternational Symposium on Algorithms and Computation (ISAAC 2001) Lecture\nNotes in Computer Science 2223 (2001) 537\u2013549.\n11. Fiala, J., and Kratochv\u00edl, J. Partial covers of graphs. Discussiones Mathe-\nmaticae Graph Theory 22 (2002) 89\u201399.\n12. Fiala, J., Kratochv\u00edl, J., and Kloks, T. Fixed-parameter complexity of\n\u03bb-labelings. Discrete Applied Mathematics 113 (2001) 59\u201372.\n13. Fiala, J., and Paulusma, D. A complete complexity classification of the role\nassignment problem. Theoretical Computer Science 349 (2005) 67\u201381.\n14. Fiala, J., and Paulusma, D. Comparing universal covers in polynomial time.\nTheory of Computing Systems 46 (2010) 620\u2013635.\n15. Galinier, P., Habib, M., and Paul, P. Chordal Graphs and Their Clique\nGraphs. In 21st International Workshop on AGraph-Theoretic Concepts in Com-\nputer Science (WG 1995) Lecture Notes in Computer Science 1017 (1995) 358\u2013371.\n16. Garey, M. R., and Johnson, D. S. Computers and Intractability. W. H.\nFreeman and Co., New York, 1979.\n17. Gavril, F. Algorithms for minimum coloring, maximum clique, minimum covering\nby cliques and maximum independent set of a chordal graph. SIAM Journal on\nComputing 1 (1972) 180\u2013187.\n18. Gavril, F. The intersection graphs of subtrees in trees are exactly the chordal\ngraphs. Journal of Combinatorial Theory, Series B 16 (1974) 47\u201356.\n19. Kratochv\u00edl, J., Proskurowski, A., and Telle, J. A. Covering regular\ngraphs. Journal of Combinatorial Theory B 71 (1997) 1\u201316.\n20. Okamoto, Y., Takeaki, U., and Uehara, R. Counting the number of inde-\npendent sets in chordal graphs. Journal of Discrete Algorithms 6 (2008) 229\u2013242.\n21. Peke\u010d, A., and Roberts, F. S. The role assignment model nearly fits most\nsocial networks. Mathematical Social Sciences 41 (2001) 275\u2013293.\n22. Rieck, Y., and Yamashita, Y. Finite planar emulators for K4,5 \u2212 4K2 and\nFellows\u2019 conjecture. European Journal of Combinatorics 31 (2010) 903\u2013907.\n23. Roberts, F. S., and Sheng, L. How hard is it to determine if a graph has a\n2-role assignment? Networks 37 (2001) 67\u201373.\n24. Sheng, L. 2-Role assignments on triangulated graphs. Theoretical Computer\nScience 304 (2003) 201\u2013214.\n23\n"}