{"doi":"10.1023\/A:1009602303629","coreId":"69318","oai":"oai:eprints.lancs.ac.uk:27236","identifiers":["oai:eprints.lancs.ac.uk:27236","10.1023\/A:1009602303629"],"title":"Research Directions in Distributed Systems.","authors":["McKee, P. F.","Marshall, I. W.","Henning, I. D."],"enrichments":{"references":[{"id":987813,"title":"A Note on Distributed Computing&quot;","authors":[],"date":"1994","doi":null,"raw":"Jim Waldo, Geoff Wyant, Ann Wollrath, Sam Kendall, &quot;A Note on Distributed Computing&quot; Sun Microsystems Laboratories Inc, TR-94-29, November 1994","cites":null},{"id":987649,"title":"The State of the Art in Distributed and Dependable Computing&quot;, A CaberNet Sponsored Report,","authors":[],"date":"1998","doi":null,"raw":"John Bates, &quot;The State of the Art in Distributed and Dependable Computing&quot;, A CaberNet Sponsored Report, October 1998.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"1999-04","abstract":"This paper considers the technical characteristics of current distributed systems technology as exemplified by CORBA. In the context of large-scale globally distributed applications, potential problems are highlighted, and areas for further research and development are suggested","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/69318.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/27236\/1\/27236.pdf","pdfHashValue":"7c5ba96b7c6f0e221dad7567607e4c6713dd90ed","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:27236<\/identifier><datestamp>\n      2018-01-24T02:50:37Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Research Directions in Distributed Systems.<\/dc:title><dc:creator>\n        McKee, P. F.<\/dc:creator><dc:creator>\n        Marshall, I. W.<\/dc:creator><dc:creator>\n        Henning, I. D.<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        This paper considers the technical characteristics of current distributed systems technology as exemplified by CORBA. In the context of large-scale globally distributed applications, potential problems are highlighted, and areas for further research and development are suggested.<\/dc:description><dc:date>\n        1999-04<\/dc:date><dc:type>\n        Journal Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/eprints.lancs.ac.uk\/27236\/1\/27236.pdf<\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1023\/A:1009602303629<\/dc:relation><dc:identifier>\n        McKee, P. F. and Marshall, I. W. and Henning, I. D. (1999) Research Directions in Distributed Systems. BT Technology Journal, 17 (2). pp. 137-144. ISSN 1573-1995<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/27236\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1023\/A:1009602303629","http:\/\/eprints.lancs.ac.uk\/27236\/"],"year":1999,"topics":["QA75 Electronic computers. Computer science"],"subject":["Journal Article","PeerReviewed"],"fullText":"Research Directions in Distributed Systems.\nPaul McKee, Ian Marshall, and Ian Henning\nSummary\nThis article considers the technical characteristics of current distributed systems\ntechnology as exemplified by CORBA. In the context of large-scale globally distributed\napplications, potential problems are highlighted, and areas for further research and\ndevelopment are suggested.\n1. Introduction\nDistributed computing systems have been proposed as a viable technology for the\nprovision of highly scaleable, high performance applications. A specific example of this\nis the World Wide Web. This operates over a heterogeneous combination of computing\nplatforms and communication networks. Interoperability is assured via standard\nprotocols, IP at the network layer and HTTP at the application layer. In a more general\nsense, the aim of producing a generic platform to support the needs of a large proportion\nof distributed application developers has been the goal Object Management Group\n(OMG) and realised in their Common Object Request Broker Architecture (CORBA)\nspecifications. Here the object oriented (OO) software engineering approach has been\ncombined with the remote procedure call (RPC) to produce a \u2018software bus\u2019. The\napproach attempts to provide a set of common services for application developers whilst\nhiding a great deal of the complexity which distribution brings. Services are accessed via\nAPI\u2019s described via a common interface definition language (IDL). A number of products\nare now maturing supported on a range of target platforms which offers good prospects\nfor heterogeneous interworking.\nThere is no doubt that CORBA represents an excellent attempt to solve a very difficult set\nof problems. However the increasing use of networks such as the Internet to support\nseamless applications between people, communities, and businesses serve to form a set of\nchanging requirements which suggest further developments may well be necessary.\nElectronic business for example is likely to be a key application area. Use in such an\nenvironment spanning diverse computing, organisational and business enterprises will\nfuel the demand for the sharing of information and resources. As with the WWW, such\napplications are expected to become Global in extent. For use in such environments,\nsome of the characteristics required of a supporting distributed platform are likely to be;\n\u2022 service guarantees covering performance, transactions, and security\n\u2022 support for mobility both of the client and server parts of the application code\n\u2022 management for performance, reliability and growth\n\u2022 an ability to support the location of objects and resources from a global \u2018pool\u2019\n\u2022 a series of distributed information stores to reduce network traffic\nThis list is by no means exhaustive, and it must be noted that new applications and\ntechnologies will no doubt appear and add to it.\nIn this paper we consider the suitability of existing technology to meet some of these\nevolving requirements in the context of large scale, globally distributed applications. Our\naim is to highlight some of the issues and so to stimulate debate and research. In\nparticular in section 2 we discuss the characteristics of existing distributed operating\nsystems using CORBA as the exemplar1. We consider some of key areas of\ncommunications styles, support for interworking, scalability, mobility, management, and\nsecurity. Our analysis suggests some significant limitations for large scale and multi-\nenterprise use, and these are highlighted. Potential solutions are identified and future\ndirections for research highlighted.\n2.  Systems issues\nDistributed computing systems are becoming increasingly important in the realisation of\ndistributed applications. There are number of commercial offerings in this area\nparticularly CORBA from the OMG [2], DCOM from Microsoft [3], and RMI from Sun\n[4].\nJAVA RMI offers the advantage of being tightly coupled to the Java language system, but\nas such is a closed system that locks users into a single language technology. New\nlanguages offering features not found in Java will emerge, and will be unable to\ninteroperate with existing systems. However, in recognition of the need for cross\nlanguage interoperation Java RMI can make use of the IIOP protocol to link with\nCORBA. Therefore it can be classed alongside CORBA in any comparison.\nDCOM is attractive because it works with all Microsoft products and MS are the\ndominant operating systems supplier. However the standard is not well documented,\nunstable and proprietary to one manufacturer, although bindings are available for modern\nlanguages.\nThe current state of the art is more fittingly represented by CORBA [1]. It is language\nindependent, produced by an international committee composed of representatives from\nindustry, often advised by academia, and is designed to support a range of high-level\nservices. The architecture involves communication through an object request broker\n(ORB) which provides a mechanism for transparently communicating client requests to\ntarget object implementations. However identifying CORBA as representative of the\nstate-of-the-art does not mean that this will become the dominant system in the\nmarketplace, Microsoft has much commercial leverage.\n                                                     \n1 Although reference is made to CORBA, many of the same comments are applicable to\nmost existing distributed operating systems.\nIn this section we focus on a number of key aspects of distributed systems (CORBA) with\nthe aim of identifying weaknesses, we then attempt to suggest some solutions.\n2.1 Communication styles\nOne of the overall goals of distributed object oriented computing is that from the\nprogrammers viewpoint there should be no essential distinction between objects that\nshare an address space, and objects that are on two machines with different architectures\nlocated on different continents. In a conventional distributed operating system an\nembedded communication infrastructure is provided to support inter-object interaction. In\nCORBA, as in most other distributed operating systems, the complexity of the\ncommunication infrastructure has been hidden from the application designer who\ntherefore has no control over the choice of mechanism. In practice most CORBA\nimplementations only provide a single mechanism with a limited range of interaction\nstyles. In order to communicate between objects (or programmes) at different locations\nthe programmer uses procedure calls to a set of interfaces declared in a common interface\ndefinition language.  This approach enables programmers to create distributed systems\nwithout needing to learn about networking, since procedure calls are a natural part of all\nprogrammes. The programmer writes exactly the same code for any type of call, and\nrelies upon the system to take care of delivery.\nCORBA is based on the use of remote procedure calls (RPC) [5]. RPC systems are\nintended to make cross address space function calls look like local function calls.\nApplying this within the object oriented programming model allows papering over not\njust the marshalling of parameters and the un-marshalling of results, but also the location\nand connection to the target objects. There is thus a single paradigm of object use and\ncommunication no matter what the location of the objects might be.  Whether a given\nobjects invocation is local or remote is purely a function of the implementation of the\nobjects being used, and could easily change from one invocation to another if no user\ndefined state is stored. This approach will prove effective in many situations. However,\nthere are many cases where the default communication mechanisms will lead to poor\nperformance.  In such cases it would be better to encourage programmers to acquire\nsufficient knowledge to make a more appropriate choice, and provide the tools to enforce\nthe choice as part of the distributed operating system.\nFigure 1 depicts a hypothetical situation where a rich mixture of communication styles\nwould be appropriate. In this simple example the performance of the underlying\ninfrastructure may well vary considerably, for example loss and latency cannot be\npredicted if the Internet is used between enterprises. For time critical applications this\nmay prove problematic. Latency may even be an issue over high performance networks in\nsome demanding cases. In a wider context both computer and telecommunications\nnetworks are migrating towards a multi-service paradigm where variable degrees of\nquality of service will be available. Such capabilities should be made available to the\napplication programmer to use as befits the situation. Moving up from the low-level\ninfrastructure the interaction styles between objects may also vary. Simple connection\noriented communication may be adequate in many circumstances but a connectionless\n\u2018fire and forget\u2019 service with delivery guarantees may also be useful.\nFigure 1 Examples of different communication styles; type 1: unicast across enterprise\nboundaries, type 2: multicast to communicate with multiple objects associated with a\nsession, and type 3: low delay, low latency messaging.\nIn general there are differences between distributed and centralised programmes as a local\nmember function call and a cross continent object invocation are clearly not the same.\nOne of the main differences concerns concurrency.  A centralised programme typically\nhas a single thread of control. When centralised programmes do support concurrent\nexecution the threads communicate using shared data supported by monitors or\nsemaphores to allow synchronisation or mutual exclusion. A distributed programme on\nthe other hand is always multi-threaded. Whether more than one thread is simultaneously\nactive depends on the original motivation for distribution. In a conventional client server\nmodel a single conceptual thread passes between servers and interactions almost always\nfollow a request-reply model.  This type of application is well suited to the conventional\ninteraction style supported by CORBA and other current distributed operating systems,\nand the use of the underlying communication mechanism can be very efficient (in a good\nCORBA implementation).  However, where distribution has been used to exploit\nparallelism in the task and spread the processing load over multiple processors, it will\nnormally be more effective to use a message based interaction style.  Messages enable\nprogrammers to invoke remote objects without waiting for the response (and wasting\nlocal processor cycles). If the distributed operating system does not support more than\nuser\n1 1\n1\n2\n3\nEnterprise A\nEnterprise B\nEnterprise C\nr\nCom\n} serve\nmunication\npaths\none interaction style programmers are forced to model those they require in terms of the\ndominant model, this is often error prone and obscures the programmers original intent.\nIt should be clear by now that a range of communication options may well prove\nessential. Typical examples of these might include one to one; one-many, broadcast;\nstreamed or message based; connection or connectionless; synch or asynch, delay\/jitter\nsensitive\/insensitive, reliable\/unreliable, secure, authenticated etc. From an application\nprogrammers viewpoint it would be an advantage to be able to more appropriately\nengineer methods of communication to match a variety of environmental conditions. In\nthis section we consider the CORBA communication infrastructure, and review some of\nthe alternative approaches that are emerging.\nPrior to the introduction of the messaging specification [6], CORBA provided three\ncommunication models:\n\u2022 Synchronous two-way: in this model a client request is forwarded to a target object\nand the client then waits for a response. While it is waiting the client thread that\ninvoked the request is blocked and cannot perform any other processing. This\nbehaviour results in unsatisfactory performance for constrained applications.\n\u2022 One way: A one-way invocation is composed of only request with no response. The\noriginal intention was to use one way calls over unreliable transport protocols such as\nthe user datagram protocol UDP. The addition of one-way invocations promises only\nbest effort semantics, thus the ORB need not report an error if the one way fails. This\ninteraction mode was not clearly defined by the OMG and there may be variations\nbetween different vendor implementations. However, most ORBs implement one-way\ncalls over TCP as required by the standard IIOP protocol specification, and is thus not\nnon-blocking. Moreover the mechanism is inherently unreliable, and a reliable one-\nway call is often needed at both transport and request level.\n\u2022 Deferred synchronous: A client sends a request to a target object and then continues\nits own processing. The client ORB does not block the calling thread until the\nresponse arrives, instead the client can either later poll to see if the target object has\nreturned a response, or it can perform a separate blocking call to wait for the response.\nThe deferred synchronous request model can only be used with the dynamic\ninvocation interface DII, which is both difficult to implement and slow.\nThus essentially CORBA only offers one communication method, which is a uni-cast\nmethod. Similar observations may be made of the DCOM communications structure that\nis based on the DCE RPC.\nOne way in which the performance of large scale distributed systems can be improved is\nthe removal of the assumption that all function calls must be dealt with in the same way\n[7]. In a large-scale network latency must be taken into account; obviously a local\nmember function call and one that crosses continents will be quite different.  To do this a\nplatform is required which provides a communications architecture capable of supporting\nmultiple communication styles between objects over multiple Transport Protocols. These\nstyles must include support for reliable asynchronous and multi-cast communication.\nThus the Developer would be enabled to define a task or network specific interaction\nstyle, and would not be restricted to the current \u2018one size fits\u2019 all method.\nThe one size fits all approach to communication currently used in CORBA is being\nchallenged by a number of initiatives from both industry and universities. For example\nWin Sock version 2 which includes support for multiple protocols on a plug-in or pile-on\nbasis, offers Transport Protocol independence allowing the user to choose the protocol by\nthe services they provide, and includes support for multi-point and multi-cast\ncommunication [8]. ILU from Xerox [9] also includes support for multiple protocols, and\ncan reasonably be expected to influence the approach of the IETF HTTP  NG working\ngroup in which Xerox are represented. In the CORBA world the Orbacus ORB [10]\nincludes support for different protocols. Approaches typified by Flexi-Net from ANSA\n[11] and the Regent framework from Imperial College [12] introduce even greater\nflexibility by allowing dynamic protocol stack assembly, even at run-time. This added\nflexibility allows the user to make optimum use of advanced network capabilities as they\nbecome available. It further allows options such as compression and encryption only\nwhen they are required, which can produce a consequent improvement in efficiency. The\navailability of these flexible protocol choices would in no way replace the standard RPC,\nthese would still be available for use in applications where performance was not\nparamount, but for performance critical applications the extra flexibility would be a great\nbenefit.\n2.2 Support for inter working\nFuture large-scale distributed systems will contain machines of every type, with the\nbroadest range of operating systems and network connections possible. The machines will\npossess different architectures, and will be programmed using different programming\nlanguages. Applications will consist of collaborations between objects supplied by\ndifferent parties, co-operating to achieve the desired end result.  A designer will specify\nthe objects that comprise a system.  Some of the objects may be specified by a third party,\nand may not be located and bound into the system until run-time.  In this scenario, the\ndesigner will need to specify his functional and non-functional expectations of the object\nin such a way that the specification can be used at run-time to check whether an\nappropriate object has been located.  The object provider must also specify the functional\nand non-functional properties of his object in such a way that they can be unambiguously\nchecked at run-time.\nEverything in CORBA is represented as a service that is accessed via an interface\nspecified in IDL, commonly referred to as an API.  Interworking in CORBA is based on\ninvoking standard APIs using a standard message Protocol GIOP [13]. In most cases this\nmaps onto a set of wire protocols via IIOP. Should the user wish to inter-work with a\nnon-CORBA system a translation bridge must be supplied that will translate message\nformats, location information, transmission protocol etc, and act in a bi-directional way to\ntranslate any response.  The example in table 1 illustrates some problems that can arise\nwith this approach.  An IDL specification describes the syntax of an object\u2019s interface,\nincluding parent classes, exceptions, attributes and operation signatures. Unfortunately,\nthe meaning of the interface is only defined for a particular context, and the context does\nnot form part of the interface specification.  In other words the interface does not specify\nthe objects behaviour (i.e. its functional and non-functional properties).  In practice, when\ndevelopers are co-located, and objects are being developed concurrently this may not\nseem a problem.  However, when the developers are separated by organisation, location\nor time, it can lead to great difficulties since a full specification of behaviour may not\nexist, and even if it does it may not be correct.  If selection of an object is to be performed\nautomatically at run-time the problem is even worse, since any specification must be\nmachine readable.  Clearly an API based exclusively on IDL will not guarantee\ninteroperability.  Since APIs are normally considered to be the programming interface\nonly and not the associated specification we could say that APIs do not guarantee\ninteroperability, they merely facilitate it by providing a template for programmers.  APIs\nare thus necessary but not sufficient.\nInterface Definition Subtract( float a, float b) return float r , string ERR\nInputs Returned value Comments\na =15 b=10 r = 5 As expected\na =15 b =10 r = -5 Subtract  subtracts a from b\na=15 b =10 Err = parameter out of\nrange\nEither neg returns not allowed\nOr max size of a or b exceeded\na =15 b =10 r = 5 but on 10th\ninvocation Err =\nserver out of memory\nFunction is allocating memory\nand not releasing it\na = 15 b =10 r = 5 but response only\nreturned after 3min\nwait\nProcess is running at very low\npriority\na =15 b = 10 r = 5 then next time\nr = -5\nVersion change in subtract\nTable 1. Potential problems with API's\nIf we refer to table 1 all of the identified problems may be alleviated by access to a\ncomplete, manual based, specification. However, we must determine that we are using the\ncorrect manual for the object instance we are currently operating on.  In automated\nscenarios a manual would in any case be unavailable since human readable manuals are\nnot normally machine readable. To avoid these problems every object in the system\nshould have its properties precisely defined in an appropriate language. To facilitate\nautomated usage the language should be strongly typed, with fully enumerated variables\n(i.e. like a protocol specification). The definition should include items like the objects\ndependencies on other objects, the resource requirements of the object, the permitted\nparameter ranges, the intended semantics of the parameters, the quality of service offered\netc. as required by the complexity of the object being described. This definition must be\ntightly associated with each instance of every object, as it will contain much information\nthat is instance specific.  One possible solution would be to use containers (like XML or\nOpendoc) and embed the definition into the top level container as object metadata.  Not\nonly would this tie the object to its specification (metadata), it would also provide a\nstandardised metadata query interface.\nGiven access to a precise strongly typed description of an object, it is relatively\nstraightforward to provide high-level programmatic interfaces to a wide range of network\nprotocols, without affecting the interoperabilty of the protocol. Because the protocols are\nsimple the correctness of their operation may be proved formally. Any system that\nprovides an endpoint for such a protocol can communicate with any other system\nimplementing the same protocol using the well defined vocabulary of messages defined\nby the protocol. Thus, a promising approach for the future could be to base the services of\na distributed processing environment on a rich set of protocols with proven operation and\nso increase the potential for successful inter-working. Rather than develop a confusing\narray of distributed services, which don\u2019t interwork well (as has happened in CORBA),\nfuture distributed operating systems should exploit protocol based development wherever\npossible.\nThere is already some progress in this general direction based on the CORBA meta-object\nfacility and protocols are being developed as a part of HTTP-NG [14], ILU from Xerox\n[15] and JINI from SUN [16].\n2.3 Scalability\nIn the context of a future large scale distributed system scalability may be simply stated as\nthe ability to add applications, users and computing nodes to the system whilst\nmaintaining the specified level of service. Obviously adding users will eventually require\nthe addition of extra machines as will the addition of extra applications, but the scalability\nrequirement means that the required performance can be regained by adding computing\npower. Architecturally the system must avoid any system function whose performance\ndegradation depends on the number of system users.\nEven though a central tenet of distribution is scalability, within CORBA retains a reliance\non centralised information stores for such things as the name service, the trading service\nand implementation repositories. It must be acknowledged that the implementation\nrepository has a somewhat mixed effect: it is advantageous that only the objects that are\nin use are live. Nevertheless in all three cases the centralisation of data represents a\npotential performance bottleneck and a single point of failure. There are architectures\ndescribed for the Federation of both trading and naming services that assume the\nexistence of some form of centralised intelligence in the system which requires the user to\nspecify the connection graph and search order.\nCentralisation is not the only scalability issue in CORBA. The communication protocol in\nCORBA is also inefficient [17] giving rise to a high message overhead on certain\noperations, such as trading using dynamic properties. Use of the security and transaction\nservices also expands the size of messages, particularly when a transaction or security\nrelationship spans a number of objects. The message grows at each step with the\ninclusion of transaction or security context information. The management of connections\nis undefined in the CORBA specification, each IIOP connection requires a TCP\nconnection, and if the TCP connection fails the IIOP session cannot be recovered. The use\nof increasing numbers of API's in CORBA also affects scalability, every time a new\nservice is added, additional API's [18] are introduced adding to an already heavy ORB\nimplementation.\nIn order to improve the scalability of future distributed systems we must remove the need\nfor any form of centralised information repositories and reduce the impact of adding\nadditional services that further complicate the operating system. It would be desirable if\nan element of information locality could be included in any search for a service, as this\nwould reduce communications overhead. It would also be desirable if information\nlocation were handled locally, and largely independently. One way of achieving this\nwould be the use of structured multicasts to announce and request object information. The\nuse of hop count limits or time to live limitations would maintain network usage at\nreasonable levels. This multicast approach is currently used in SUN's JINI platform in the\ndiscovery and join part of the specification. Softwired's IBUS [19] also uses multicast\ntechnology. Multicast is used extensively in existing group management systems such as\nHORUS and ENSEMBLE [20].\nA recent IETF submission involving Microsoft, Inktomi, RealNetworks and SUN for a\nWeb Proxy Auto-discovery protocol [21] proposes an escalating strategy of resource\ndiscovery, based on existing internet protocols, to find a nearby web proxy server. Using\nsimple, functional and efficient mechanisms resource discovery is used to obtain\ninformation for the automatic configuration of web clients. Combining local discovery\nmechanisms with a cache overlay to store information could effectively distribute the\ninformation discovery overhead. The caches can also share information between them\nusing cache digests as proposed by Rousskov [22], increasing the knowledge of the\nsystem.\nThere will be a requirement for any practical system to access and mix objects that are\npart of different existing systems in different locations. Therefore the concept of a\nuniversal set of globally unique names becomes important. This allows named objects in\ndifferent systems to be treated in a common way. The scalability of a global naming\nsystem will also be greatly improved following the work on URC's and URN's at the\nW3C [23].\n 2.4 Mobility\nOne of the requirements for any large scale distributed system will be an increased level\nof support for mobility both of users and terminal equipment. The future user may\nreasonably expect to log onto any terminal anywhere in the world and be able to access\ntheir normal range of applications. To ensure that they continue to receive an acceptable\nquality of service, processes may need to be relocated closer to the point of use.\nDevelopments in mobile access technologies and mobile terminals will mean that a wide\nvariation in access bandwidth and end terminal capabilities must be catered for together\nwith the interference and fading problems that may be encountered over wireless links.\nIn common with all distributed operating systems CORBA hides the network from the\ndeveloper, consequently it provides no support for such non-reliable networks and\nservices. Location transparency is not always a desirable property as there are many\ninstances when location based information would be very useful to mobile users, and\ninformation describing the location of events such as failures and load peaks would aid\nthe management of large scale distributed systems. Moving objects without breaking\nreferences is also problematic. If we consider servers formed by the collaboration of\nseveral different processes every object must register with an object adapter, which acts\nas an interface between the implementation and the ORB.  It is also responsible for\nmanaging object references, call handling, and registration of the objects with the\nimplementation repository. In order to move the server all objects registered with the\nobject adapter must move together, they must register with the new repository giving rise\nto potential consistency and scalability problems. A footprint is left in the old repository,\nwhich again impacts the potential scalability and causes poor performance.\nAdding support for mobility to a distributed operating system will require a number of\nfundamental changes to the conventional model as typified by CORBA. One of the design\ncornerstones of distributed systems is location transparency, but in order to efficiently\nsupport mobile users and code it is desirable to selectively choose to implement location\ntransparency or not. It will also be necessary to resolve the requirements from any request\nin terms of choosing between objects or an identical object if closer. This will of course\nrequire a more complete meta-data description of each object to aid in the resolution of\nthis choice. Another aid to the support of mobility in distributed systems would be the use\nof a stateless programming model for server objects again helping to resolve the\nfundamental \"same or identical\" object question.\nThis selective inclusion of functionality is, as previously mentioned, available in the\nlayered protocol stacks built for the REGENT system from Imperial College. The\nspecification for Winsock 2 also includes a number of layered constructs for specifying\nquality of service and it would be interesting to determine if the same approach would\nallow selective transparency.\n2.5 Management\nIn a future large-scale distributed platform that, as previously described, supports mobility\nthe location of objects and users will be dynamic. In this section we are principally\nconcerned with management of the objects running on the platform. The management of\napplications will be a concern of the application developer. We are therefore interested in\nthe issues surrounding the location, activation, use and movement of objects within the\nplatform. The system needs to evolve in response to changing requirements, and we also\nneed to be able to describe how objects should respond to their changing environment.\nThis may be achieved using policies. Policies describe possible behaviour options, and\nconstraints on use of the options, and are often expressed as obligations, authorisations\nand prohibitions.\nIn almost all commercial CORBA implementations there is little support for\nmanagement. Tool support is lacking and there are very few standard interface\nspecifications that allow management to be added on. Available management is\ncentralised and proprietary, it has a monolithic architecture and consequently will not\ninter-work across different vendor implementations. Problems are also encountered with\nthe exact specification of management rules in a CORBA system. One of the first\nchallenges any management system needs to tackle is that of the CORBA infrastructure\nitself because it will be a large object based system.  To achieve this it seems reasonable\nthat the rules and policies should be objects. However when we come to manage the\nrunning system the rules and policies will be attributes of the system objects and may\nneed to be handled purely as text strings. This fundamental dichotomy needs to be\nresolved.\nThe management of future large-scale distributed systems must be decentralised. The\nnetwork delays and congestion involved in communicating information to any centralised\nmanagement entity make this approach unattractive. A key challenge for any distributed\nmanagement scheme will be how to manage the scheme, as it will be a large distributed\napplication too. Many of the management functions will need to be devolved locally, and\nmay be autonomous. To achieve this local policies will be needed for all objects in the\nsystem, both hardware and software, to determine their action when faced with events.\nThis policy set may form part of the meta-data associated with every object. It would also\nbe desirable to devolve application management to the end user of that application\nwherever possible, thus spreading the management overhead, and allowing each user of\nthe system to have an essentially unique solution. This in many ways mirrors the current\nwork on active networks allowing users to inject code into the network to achieve a\ngreater degree of application customisation. The description of management policies is\nstill very much a topic of active research, as is the local implementation of policies. On\nany particular node in the system there will be policies relating to the nodes actions and\npolicies relating to the objects actions. The overall behaviour from such a composite\ncollection of local policies will need to be understood.\n2.6 Security\nUse of existing CORBA implementations between enterprises presents a range of\nproblems depending upon the particular Firewall implementation.  IIOP can use any port\nand these interactions are bi-directional which can be difficult with application layer\nfirewalls.  The object communication end point in the IOR contains information about the\nhost and port for the communication, and betrays the LAN based origins of CORBA.\nTunnelling over HTTP is possible but this potentially compromises the security of the\nfirewall. Servers are also highly vulnerable to ill-formed requests that cause stability\nproblems. Overall there is a lack of a credible solution that limits the applicability of\nCORBA in the commercial world.\nAnother impact of the existing IDL based approach to interface specification, is the lack\nof any additional information regarding the source, reliability and resource requirements\nof any object offering that interface. A more complete description of the object is\nrequired. To illustrate this we can use an example from Active Networks, where third\nparty code is intended to run on network nodes. If the resource requirements of the code\nare available as a specification, and these limits are breached, the object is clearly faulty\nand may be terminated. This enables code to be run without an onerous testing\nrequirement.  The additional resource usage data would also be useful in the support of\nmobility, as it would be useful to know if a node could support the demands of an object,\nbefore the object is moved to that node. Performance management would also be helped\nby such a facility.\n3. Conclusions\nIt can be seen from the examples discussed in this paper that current distributed operating\nsystems work well for small\/medium-scale distributed applications operating over\nreliable, and well dimensioned network and computing infrastructures. However\nweaknesses are exposed when consideration is given to very large-scale applications, and\nparticularly to their use over wide area networked systems exhibiting a diverse range of\ninter-system capabilities and performance characteristics. Although many of the examples\nin this paper have been developed with reference to CORBA, similar observations may be\nmade for the other candidate systems. Having discussed some of the weaknesses of\ncurrent systems we identify areas for research to allow the development of distributed\noperating systems that will be useful for some of the future large-scale applications.\nCharacteristics of such systems will include;\n\u2022 greater flexibility in the task specific choice of communication style\n\u2022 autonomous or local management with increased end user participation\n\u2022 greater support for mobility of users and code\n\u2022 objects will have an associated meta data description\nInter working will be based on provably correct simple protocols, files will be stored\nclose to the originator and cached everywhere else, and such a cache hierarchy will be\nused for information discovery. Over all such a system should be dynamic and responsive\nto events.\nIn order to be able to achieve this vision future research priorities in distributed systems\nmust include;\n\u2022 providing a range of protocols in dynamic stacks\n\u2022 support for different communication styles such as multicast\n\u2022 location of objects and resources using local mechanisms\n\u2022 local mechanisms for management and policy definition\n\u2022 a language capable of unambiguously describing both functional and non-functional\nattributes of the objects in the system.\nBuilding distributed systems is difficult, and existing products such as CORBA and\nDCOM offer significant benefits. But building global distributed systems is very hard.\nThere are significant problems with existing systems and we need fresh approaches which\nembody more flexibility and allow less \u2018isolation\u2019 from the capabilities of the underlying\nhardware and network.\nReferences\n1. John Bates, \"The State of the Art in Distributed and Dependable Computing\", A\nCaberNet Sponsored Report, October 1998.\n2. www.omg.org\n3. www.microsoft.com\/com\/dcom.asp\n4. www.java.sun.com\/products\/jdk\/1.2\/docs\/guide\/rmi\/spec\/rmi-title.doc.html\n5. www12.w3.org\/History\/1992\/nfs_dxcern_mirror\/rpc\/doc\/Introduction\/Abstract.html\n6. Douglas C. Schmidt and Steve Vinoski, Programming Asynchronous Method\nInvocations with CORBA Messaging, C++ Report, SIGS, Vol. 11, No 7 2, February,\n1999\n7.  Jim Waldo, Geoff Wyant, Ann Wollrath, Sam Kendall, \"A Note on Distributed\nComputing\" Sun Microsystems Laboratories Inc, TR-94-29, November 1994\n8.  www.sockets.com\/winsock2.htm\n9.  http:\/\/pubweb.parc.xerox.com\/hypertext\/ilu\/index.html\n10.  http:\/\/www.ooc.com\/ob\/\n11. http:\/\/www.jungle.bt.co.uk\/projects\/ansa\/\n12. http:\/\/outoften.doc.ic.ac.uk\/~np2\/regent\/regent.html\n13. http:\/\/www.mitre.org\/research\/domis\/reports\/UNO.htm\n14. http:\/\/www.w3.org\/Protocols\/HTTP-NG\/\n15. http:\/\/www.parc.xerox.com\/istl\/projects\/http-ng\/\n16. http:\/\/java.sun.com\/products\/jini\/specs\/index.html\n17. http:\/\/www.cs.wustl.edu\/~schmidt\/corba-research-performance.html\n18. http:\/\/www.objectwatch.com\/issue14.htm\n19. http:\/\/i-gate.softwired.ch\/products\/ibus\/\n20. http:\/\/simon.cs.cornell.edu\/Info\/Projects\/Ensemble\/index.html\n21. http:\/\/eggplant.rte.microsoft.com\/wpad\/\/\n22. http:\/\/squid.nlanr.net\/Cache\/CacheDigest\/\n23. http:\/\/www.w3.org\/Addressing\/Addressing.html\n"}