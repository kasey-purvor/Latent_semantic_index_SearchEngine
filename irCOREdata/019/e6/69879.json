{"doi":"10.1049\/cce:19960205","coreId":"69879","oai":"oai:eprints.lancs.ac.uk:20427","identifiers":["oai:eprints.lancs.ac.uk:20427","10.1049\/cce:19960205"],"title":"The software development process for intelligent robots.","authors":["Seward, D. W.","Garman, A."],"enrichments":{"references":[{"id":16336960,"title":"A spiral model of software deveiopment and enhancement\u2019,","authors":[],"date":null,"doi":"10.1109\/2.59","raw":"BOEHM,  B.  W.:  \u2018A  spiral  model  of  software  deveiopment  and enhancement\u2019,  IEEE Computer, 1988,20,  (9),  pp.43-58","cites":null},{"id":16336974,"title":"Derek Seward is with the Department of Engineering and Alastair Garman is with the Department of Computing,","authors":[],"date":"1996","doi":null,"raw":"IEE: 1996 Derek  Seward  is  with  the  Department of  Engineering and Alastair  Garman  is  with  the  Department  of  Computing, Lancaster University, Lancaster LA1 4YR, LJK COMPUTING & CONTROL ENGINEERING JOURNAL  APRIL 1996 Authorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.","cites":null},{"id":16336964,"title":"Knowledge acquisition for a robot excavator\u2019,","authors":[],"date":"1990","doi":null,"raw":"GREEX, F\u2019.,  SEWARD, D.  W.,  and BRADLEY,  D.  A.:  \u2018Knowledge acquisition  for a  robot excavator\u2019, 7th  Int. Symp. on  Robotics in Construction, Bristol, 1990,  pp.351-357","cites":null},{"id":16336972,"title":"Safe system architectures for large mobile robots\u2019, EPSRC,","authors":[],"date":null,"doi":null,"raw":"\u2018Safe  system  architectures  for  large  mobile  robots\u2019, EPSRC,  ref. GFUJ18064","cites":null},{"id":16336967,"title":"Structured analysis and system specification\u2019","authors":[],"date":"1978","doi":"10.1007\/978-3-642-59412-0_33","raw":"DeMARCO,  T.:  \u2018Structured  analysis  and  system  specification\u2019 (Yourdon Press, New York, 1978)","cites":null},{"id":16336970,"title":"Structured design\u2019 (Prentice-Hall,","authors":[],"date":"1979","doi":null,"raw":"YOURDON,  E.,  and  CONSTANTINE,  L.  L.:  \u2018Structured  design\u2019 (Prentice-Hall,  1979)","cites":null},{"id":16336958,"title":"W.: \u2018LUCIE-the autonomous robot excavator\u2019, Industrid Robot,","authors":[],"date":"1992","doi":null,"raw":"SEWARD,  D. W.:  \u2018LUCIE-the  autonomous  robot  excavator\u2019, Industrid Robot, 1992, 19,  (1)  (MCB University Press)","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"1996-04","abstract":"The key problems in producing software to control intelligent robots are identified, the principal one being the difficulty of producing a detailed requirements specification. A series of process steps is defined and described in relation to the development of an intelligent robot excavator. The importance of a rational decomposition of the system into modules is stressed, and one particular component of the robot excavator is discussed in some detail-the activities manager. It is shown how techniques such as a `production system' and a `blackboard' were implemented in Ada to produce a flexible and easily maintainable system. Two other components are described-the low level controller and the safety manager. A brief description of the hardware platforms used is included","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/69879.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/20427\/1\/20427.pdf","pdfHashValue":"6117b9ce550997da06b4d083f93dd9e0524c9f5e","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:20427<\/identifier><datestamp>\n      2018-01-24T02:34:41Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D54:5441<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        The software development process for intelligent robots.<\/dc:title><dc:creator>\n        Seward, D. W.<\/dc:creator><dc:creator>\n        Garman, A.<\/dc:creator><dc:subject>\n        TA Engineering (General). Civil engineering (General)<\/dc:subject><dc:description>\n        The key problems in producing software to control intelligent robots are identified, the principal one being the difficulty of producing a detailed requirements specification. A series of process steps is defined and described in relation to the development of an intelligent robot excavator. The importance of a rational decomposition of the system into modules is stressed, and one particular component of the robot excavator is discussed in some detail-the activities manager. It is shown how techniques such as a `production system' and a `blackboard' were implemented in Ada to produce a flexible and easily maintainable system. Two other components are described-the low level controller and the safety manager. A brief description of the hardware platforms used is included.<\/dc:description><dc:date>\n        1996-04<\/dc:date><dc:type>\n        Journal Article<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/eprints.lancs.ac.uk\/20427\/1\/20427.pdf<\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1049\/cce:19960205<\/dc:relation><dc:identifier>\n        Seward, D. W. and Garman, A. (1996) The software development process for intelligent robots. Computing and Control Engineering, 7 (2). pp. 86-92.<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/20427\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1049\/cce:19960205","http:\/\/eprints.lancs.ac.uk\/20427\/"],"year":1996,"topics":["TA Engineering (General). Civil engineering (General)"],"subject":["Journal Article","NonPeerReviewed"],"fullText":"TWARE \nware development \nfor an intelligent \nard and Alastair Garman \nThe key problems in producing \nsoftware to control intelligent robots \nare identified, the principal one being \nthe difficulty of producing a detailed \nrequirements specification. A series of \nprocess steps is defined and described \nin relation to the development of an \nintelligent robot excavator. The \nimportance of a rational decomposition \nof the system into modules is stressed, \nand one particular component of the \nrobot excavator is discussed in some \ndetail-the activities manager. It is \nshown how techniques such as a \n\u2018production system\u2019 and a \u2018blackboard\u2019 \nwere implemented in Ada to produce a \nflexible and easily maintainable \nsystem. Two other components are \ndescribed-the low-level controller and \nthe safety manger. A brief description \nof the hardware platforms used is \nincluded. \nhere is currently a great deal of research and \ndevelopment going on throughout the world \nin the area of intelligent robots, particularly \nfor use in hazardous environments such as \nnuclear decommissioning, toxic waste tips and subsea. In \norder to carry out useful tasks in unstructured environ- \nments, robots inevitably require a richer sensory system \nthan conventional industrial robots, and much increased \nintelligence to make sense of their more complex world. \nThey also need the intelligence to carry out work \nsequences that involve subtle and adaptive operations \nwithout constant reference to human operators. This \nmeans that the proportion of system costs occupied by \nsoftware will continue to increase for the foreseeable \nfuture, and probably dominate hardware costs. \nThere are specific problems in developing software for \nintelligent robots, and these problems must be faced and \novercome if such robots are to escape from the research \nlaboratories and become viable commercial products. \nThis article sets out to investigate the problems of \nsoftware development for intelligent robots by reference \nto a research project to develop a robot excavator. The \nlessons learned from this project are formulated into a \nseries of steps that constitute a suitable process model for \nsoftware development. \nBackground \nFor the last five years, staff and students at Lancaster \nUniversity have been involved in the development of an \nautonomous robot excavator, and the end result of this \nwork is LUCIE-the Lancaster University Computerised \nIntelligent Excavator.l An excavator provides a good \nopportunity for development, as it is basically a highly \nefficient and well developed four-degree-of-freedom \nmanipulator arm, but with the complete absence of \nautomation or intelligence. The aim of the project is to \nadd autonomy in order to produce a robot excavator with \nthe following characteristics: \nIt should concentrate on the task of treuzchipzg, and be \nable to produce a good quality and accurate smooth- \nbottomed trench. \n0 It should adapt to different soil types without human \nintervention. \nIt should cope with obstructions, such as boulders in \nthe trench. \nCOMPUTING & CONTROL ENGINEERING JOURNAL APRIL 1996 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.\nSOFTWARE \nThe project needed to be organised in such a way that: \nIt is capable of incremental development with different \ndesign teams completing a stage of the work through- \nout an academic year. \n0 It is highly modular to provide for the possibility of \nadding, as yet, undeveloped technologies, such as a \nnavigation system and a system for the detection of \nhidden service pipes. \nA working prototype has been produced and the above \naims achieved (see Fig. 1). A hardware platform was \nprovided by the JCB excavator company in the form of a \nJCB 801 tracked mini-excavator. Many lessons have been \nlearned, particularly in the field of software engineering, \nwhich are relevant to the generic class of intelligent \nrobots. \nThe nature of the problem \nThe conventional opinion in software engineering \nemphasises the need for a complete and unambiguous \ndefinition of the system requirements before moving to \nthe design stage (although it is now accepted that this is \nusually unrealistic, and some iteration between require- \nments and design is required). Herein lies the major \ndifficulty with this class of intelligent robot. In our case \nthe task of digging a trench is a subtle manual task that \nhas never been properly defined. Indeed it is clear from \nthe observation of skilled human drivers that their tactics \nare constantly being modified to maintain efficient \noperation as ground conditions vary. They make wide \nuse of many sensory feedback loops (e.g. listening to the \nsound of the engine) to optimise the path of the excavator \nbucket. Even if the human approach was fully \nunderstood, it would still leave a significant problem in \nknowing how closely an automated method should mimic \nit. What is needed is a development system that allows \ntactical experimentation. Furthermore, this experimenta- \ntion requires at least a prototype havdwave system (not \njust the software). Thus we require a \u2018whole system\u2019 \ndevelopment process. \nA modern excavator has a very high power-to-weight \nratio-about ten times that of a. conventional industria1 \nrobot. In fact an excavator arm can apply a force which \nis sufficient to turn itself over. This, combined with \nmobility, means that safety is an important issue. \nThe problems of system development can therefore be \nsummarised as follows: \n0 It is not possible to write the complete system \nrequirements in advance, and hence they must be \nfurther refined throughout the development process. \n0 The undefined nature of the task means that there is a \nneed to be able to tune the system during operation. \nThis points to the necessity for a \u2018training\u2019 facility, \nwhere tactics Carl be refined in the field without the \nneed for constant re-compiling of the software code. \nA working hardware prototype is required for the \nrefinement of the requirements. Consideration was \ngiven to software simulation, but this was discounted \nas the primary tool on the grounds that the simulation \nof soil with realisl ic non-homogenous properties is too \ndifficult. \nLarge systems will usually consist of many off-the- \nshelf components and so a top-level architecture which \nstresses high modularity is vital for the flexible \nintegration of subsystems. An example of such a \ncomponent is a satellite global positioning system \nwhich contains both hardware and software \ncomponents. The architecture of the system must cope \nwith software components implemented in different \ncomputer languages. \nIt must be possible to validate the safety of the \ncomplete system. \nFig. 1 LUCIE the \nrobot excavator \nbeing trained \nCOMPUTING & CONTROL ENGINEERING JOURNAL APRIL 1996 87 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.\nStages of development \nOf the established software development models, that \nwhich comes closest to providing a framework for \nthis development is the Boehm Spiral Model.? This \nencourages the reduction of development risks by \nincorporating prototypes, simulations and models. \nHowever, the suggested steps given below are based more \non a critical review of the experience gained on the project \nthan strict adherence to the model: \n1 Problem definition and scope \nThis is to define the principle objectives of the robotic \nsystem, and also to indicate estimates of available \nresources in terms of equipment, finance, manpower and \ntime. \n2 Knowledge acquisition \nThis stage may involve observation and interrogation \nof human operators so that the robot\u2019s operational \nprocess can be understood and the functionality and \ntarget performance of the system de f in~d .~  In the \nparticular case of the robot excavator this stage also \nincluded a theoretical study of \u2018soil cutting\u2019, and an \nanalysis of excavator kinematics and forces. \n3 Preliminary system requirements definition and \nfeasibility study \nA high-level description of what is required from the \nrobotic system is produced in written form. This is then \ncompared with available technical resources to see if it is \nfeasible. \n4 Global system decomposition \nThe overall system is broken down into manageable \nmodules which can be relatively independently \nFig. 2 Fifth-scale model of excavator arm \ndeveloped. A rational decomposition is one of the most \nvital steps in system development, and is dealt with in \nrnoie detail below. \n5 Detailed requirements spec@ations for  subsystems \nusipig a rapid prototype \nThe risks associated with developing each module \nshould be considered, and as a result of this, the most \nappropriate process model(s) adopted. If modules can be \ntightly specified at an early stage, then this should be \ncarried out using a specification technique such as \nDeMarco\u2019s Structured Data Flow Diagrams.\u201c \nA rapid prototype of both the hardware and software \nis required for further refinement of the requirements, for \nthose modules which cannot be adequately defined. For \nlarge robots it may be advantageous to also build a \nsoftware or hardware scale model. This is discussed in \nmore detail below. In general the rapid prototype will use \noff-the-shelf hardware components, which will probably \nbear little resemblance to a finished production system, \nand will be far from optimum in terms of cost, robustness, \ncompactness and performance. \n6 Design and implementation of  a development \nprototype followed by experimental tuning and \nproduction of a detailed requirements spec@cation \nThis stage will build on the experience gained from \nstage 5 and the aim is to build a robot which has the full \nfunctionality of the final system, but also has additional \ncapabilities for tuning and adjustments so that the \ndetailed requirements can be finalised. It would be \nexpected that many of the hardware and software \ncomponents would be re-usable in the production version. \n7 Design and implementation of the production version \nto meet the detailed requirements dejned in stage 6. \nThe final production version is likely to contain more \nhighly optimised but less adaptable software, but \nsupported by a professional user interface. \nWith simpler robots it should be possible to merge steps \n5 and 6. The success of the design of the high-level system \narchitecture at stage 5 can be measured by how similar \nit is to the final product at the end of stage 7. For one-off \nor low volume robots the development would cease at \nstage 6. Some specific points from the above steps will \nnow be considered in more detail. \nThe use of robot models \nThere are strong arguments for including models \nthroughout the development. These can take the form of \nmathematical models, graphical computer simulations or \nphysical scale models. \nMathematical models are required for the production of \neffective control algorithms, particularly when the robot \ninvolves complex kinematics or fast moving parts, which \nadd a dynamic component to the problem. This was not \nCOMPUTING Br CONTROL ENGINEERING JOURNAL APRIL 1996 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.\nan important issue with LUCIE as  the excavator arm is \nwell damped by the soil when actually digging, and when \nmoving in air does not need to be accurately positioned. \nGraphical computer simulations are useful for defining \nbasic geometry, evaluating working strategies and, as \npart of the safety analysis, to avoid collisions. Software \ntools of various complexity are now available for both the \nabove, but are beyond the scope of this article. \nHardware scale models are of particular advantage \nwhen developing large robots, and they should, where \npossible, be designed to be driven by'the same software \ninterface as the full-sized prototype. The key benefits are: \nControl software can be tested under laboratory \nconditions. \nIn the case of the excavator, trial holes can be easily \ndug and refilled without the need to hire a driver. \n0 There are clear safety advantages compared to testing \nnew control software on large and powerful robots. \n0 They provide a good demonstrator to motivate staff, \nprovide confidence and encourage further funding. \nThey can often be quicker and cheaper to develop than \nequivalent software simulations. \nFig. 2 shows a fifth-scale model of an excavator arm that \nwas used to test control software and develop digging \nstrategies in a sand box. This model had a similar electro- \nhydraulic system to the full-scale excavator and was \ncontrolled through an identical software interface. It is \nimportant that such models are easily scaleable. In this \ncase the same software was successfully used to drive \nboth the fifth-scale model and the full-sized excavator- \nit was only required to change the geometry and a few \ncontrol parameters. \nDecomposition of system components \nA logical top-down decomposition of system compo- \nnents is the key to achieving a flexible and easily \nSOFTWA \nmaintainable system. (An exception to this can occur \nwhen using off-the-shelf components which may dictate \nsome bottom-up considerations to allow for specific \ninterfacing restrictions.) An important software engin- \neering concept that can help in obtaining a coherent \ndecomposition is coupling.5 The degree of coupling is a \nmeasure of the amount and range of data-flow that occurs \nbetween system modules. For ease of long-term mainten- \nance coupling should be minimised. A useful aid for \nidentifying the high-level modules is to consider where \na human would intervene in the system assuming \nhardware or software faults at various stages in the \nsystem. These interventions normally occur at points \nwhere coupling is minimised. Fig. 3 illustrates the top- \nlevel decomposition for the LUCIE excavator together \nwith the obvious human interventions in the event of \nsystem failure. The safety manager occupies a unique \nposition in relation to the other modules and so is not \nshown connected at this stage. \nTwo of the modules in Fig. 3-the low-level arm \ncontroller and the activities manager-have been fully \nimplemented and the safety manager is currently under \ndevelopment. These will be discussed in the following \nsections. \nLow-level arm controller \nThe purpose of the low-level arm controller is to take \nmovement commands from the activities manager and \nsend the appropriate control signals to the electro- \nhydraulic valves. Experiments with the fifth-scale model \nin step 5 revealed the desirability of a dual control \nstrategy which is closely reflected in the human approach \nto digging: \n0 When moving in air (i.e. tipping the spoil and \npositioning the bucket 1 eeth) a positional controller is \nrequired. The commands from the activities manager \nthus instruct the bucket to move to specific x,y,z co- \nI conventional l I setting-out I 1 \n-> safety manager \nand movement controller hidden cable detector \nI I observer looks \nfor cables \nFig. 3 Top-level \ndecomposition with \npoints of human \nintervention \nCOMPUTING & CONTROL ENGINEERING JOURNAL APRIL 1996 89 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.\nTWARE \nordinates in space. Angle sensors were placed on the \narm joints to provide closed-loop control. \na When moving in soil a velocity controller is required. \nThe commands from the activities manager instruct \nthe tip of the bucket teeth to comply with a particular \nvelocity vector (i.e. speed and direction). This strategy \naccepts the fact that movement in the ground needs to \nbe highly adaptive as ground conditions change, and \nthat there is little likelihood of reaching a specific point \nvia a predetermined path. Error feedback is used by \nthe activities manager to modify the velocity command \nin order to optimise performance. Thus if the exca- \nvator cannot achieve the demanded velocity because \nthe ground is too hard, the activities manager will \ndirect the low-level controller to attempt a shallower \ndig where the ground is ex)ected to be softer. This \napproach has proved very effective in providing \npseudo-force feedback without the need of additional \nforce sensors. \nThe low-level arm controller is currently implemented \nin \u2018(2. \nDevelopment prototype of the \nactivities manager \nOf the above high-level modules, it is most difficult to \nprovide an early detailed requirements specification for \nthe activities manager. The activities manager is the \nmodule that directs the digging process and has \nknowledge of the tactics required for efficient operation. \nThe knowledge required by the developers was obtained \nby observing human operators, theoretical studies and \ntrial and error experimentation. This section describes \nhow the module was tackled at the development \nprototype stage (step 6). \nBecause the requirements for the activities manager \nare not completely defined it is necessary to prototype the \ncontrol software. The prototyping process helps to \nidentify and clarify the requirements specification of the \ncontrol software. \nTo help the prototyping of the activities manager a \ndesign platform concept was used. The design platform \nallows the developers to try out and modify ideas, as well \nas reacting swiftly to requirements changes in other \nsystem components. \nDesign platform concept \nThe aim of the design platform is to provide maximum \nflexibility without compromising on maintainability. \nMaintainability is essential not only because of the \npotentially fast and possibly radical prototyping process, \nbut also because of the unstable nature of developing the \nsystem using students. The purpose is to produce a \ndetailed and static specification of the activities manager \nmodule. This specification is then used to produce an \noptimised and well engineered software solution. \nIn order to construct a design platform, it is necessary \nto have at least a basic understanding of the robotic \nsystem and the high-level goals of the control software. \nMost useful intelligent robots will be finite state \nmachines. These are systems which are in one or other \nparticular state of activity depending on the stimuli \nreceived. These stimuli can be as  a result of signals from \nsensors, timers, switches or work instructions from a \nhigher level program. The stimuli trigger the switch from \none state to another. Fig. 4 shows a state transition \ndiagram for \u2018digging within reach\u2019. The words inside the \nboxes describe particular states and the words in italics \noutside the boxes indicate the stimuli that triggers the \ntransition from one state to another. \nThe digger can only be in one state at any one time and \nthe process is performed by moving from a completed \nstate to the next state. If implemented with care, the finite \nstate machine approach provides both flexibility and \nmaintainability. Flexibility comes from the ease of adding \nnew states to the finite state machine. The maintain- \nability comes from the inherent modular structure of the \nfinite state machine. Running one state at a time improves \nthe performance of the whole system. \nAn interesting question arises as to \u2018where is the \nintelligence in such a system?\u2019. Briefly, it lies in the \nalgorithms that control the particular states, the sequence \nof states and the rules that control the transition between \nthe states. This combination enables the system to adopt \nappropriate behaviour in an unstructured environment. \nThe next step is to identify key design features, \naround which to build the design platform. In the case \nof the activities manager these were: a real-time com- \nponent, a non-real-time component, a means of applying \nknowledge and a control structure to model the phases of \nthe digging process. These design features have to be \nmerged with flexibility and maintainability character- \nistics to produce a design platform. \nFeatures of the activities manager3 design platform \nThe use of a high-level programming language is \nimportant, and the language used to implement the \nactivities manager is Ada. This provides a modular \napproach, information hiding and meaningful data \nstructures, which are all necessary for a maintainable \nsystem. \nThe activities manager involves a real-time component \nwhich was one of the critical design issues. A trade off \nexists between on the one hand maintainability and \nflexibility, and on the other hand real-time performance. \nThe strict real-time option in Ada is called tasking, but \nthis was rejected primarily because its complexity makes \nit unsuitable for a flexible, rapid prototyping process. \nInstead, simplicity, efficiency and a fast processor were \nused to provide an \u2018as fast as possible\u2019 solution. This \nsolution does not compromise the high flexibility and \nmaintainability characteristics of the system. \nThe next problem was how to embed knowledge in the \nactivities manager. A well known technique is to use a \nCOMPUTING & CONTROL ENGINEERING JOURNAL APRIL 1996 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.\nSOFTWARE \nacdepth \n-4 positioning teeth b- \nb u c k e t p  \n4 height_OK \n4 location-OK \nreleased \nvibrating bucket \nFig. 4 State transition \ndiagram for \u2018digging \nwithin reach\u2018 \nproduction system. This consists of three components: \nA list of rules of the form: IF (condition true) THEN \n(perform action). Currently about 30 rules are used for \na single digging cycle. \n0 A working memory containing the current value of all \nsystem data. Much of this data emanates from the low- \nlevel arm controller and can be considered to be \ndisplayed on a blackboard for use by any of the \nprogramme modules. The use of a blackboard is a \nwell known technique for communicating between \nasynchronous processes which may be running on \ndifferent processors and perhaps written in different \ncomputer languages. A particular section of memory \ncan be allocated to hold the blackboard data. \n0 An inference engine which cycles through the rules, \nchecks the conditions and instigates actions. \nWith complex systems this can result in having to check \nhundreds of rules at each cycle, and this can be a penalty \nin real-time systems. The solution was to place a separate \nproduction system in each of the states. In order to \nmaintain performance, the production systems were kept \nsmall and efficient. If a production system became too big, \nthe state was split into two or more substates. Each state \nis implemented as an Ada procedure with a \u2018while\u2019 loop \nforming the basis of the inference engine. When a \ntransition state is reached the next desired state is \ntransmitted to the working memory. If the most \nimportant and most likely rules are given the opportunity \nto fire first, then each iteration of the production system \nrules is performance optimised. The addition, modifi- \ncation and deletion of the rule is simple and therefore \nprovides a flexible and maintainable knowledge base. \nThe production systems need data in order to work. \nThe data structures required must be flexible and \nmeaningful, in ordler to be maintainable. The data \nstructures provided by high-level languages such as Ada \nare ideal for this purpose, as they provide flexibility, \ninformation hiding, logical structuring and meaningful \nnaming. Two examples of abstract data types used are \nfirstly that which contains the current state information \nas displayed on the blackboard: \ntype StateTableType is \nrecord \nTiltAngle:integer:=O; \nBucketAngle:integer:=O; \nxError:inte,ger:=O; \nyError:inte,ger:=O; \nVirtualPosition:Location:= (O,O,O); \nRealPositio n:Location:=(O,O,O); \nend record \nSecondly the following data structure contains the \ncommands which are issued to the low level controller: \nCOMPUTING & CONTROL ENGINEERING JOURNAL APRIL 1996 91 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.\nTWARE \ntype CommandType is \nrecord \nVelocity:Vector:=(O,O); \nPosition:Location:=(O,O,O); \nBucketAngle:integer:=O; \nend record; \nAnother feature of the design platform was the removal \nof all constants from the source code. Constants are \ninflexible and were therefore replaced by variables which \ncan be changed, as required by the prototyping process, \nwithout having to recompile the source code. The \n\u2018variable constants\u2019 can be changed by using a user \ninterface, to edit external files. These configuration files \ncontain the values that the \u2018variable constants\u2019 should \nhave. They are read by the activities manager and placed \ninto internal data structures. This method provides a \ncertain amount of flexibility without having to recompile \nthe source code, which is a great advantage in a rapid \nprototyping process. \nThe design platform can also be used as a test harness \nby simulating the input and analysing the output. This is \nagain achieved by reading input in from external files \nand writing output out to external files. This enabled the \nactivities manager to be tested without the digger and \nalso before the digger was finished. \nThe safety manager \nThe concept of a safety manager is currently being \ninvestigated under the Safe-SAM project which is \nsupported by the DTIEPSRC safety-critical systems \nprogramme.\u201c Mainstream thinking in safety-related \nsystems is to develop a safety case based on making \nsystems as deterministic as possible. Rigorous testing, \nstatic and dynamic analysis andor formal methods can \nbe used in an attempt to verify that a system performs \nsafely to specification. For the robot excavator, which \nuses a knowledge base to produce adaptive control in \nan unstructured environment, such an approach is not \nrealistic and could not be justified on economic grounds. \nFor this reason the concept of a safety manager is being \ndeveloped. The safety manager\u2019s role is to be aware of \nobjects in the working environment, and to sanction only \nsafe behaviour. It will be resident on a separate processor \nand, in biological terms, play the role of a \u2018conscience\u2019 to \nthe system. Another analogy is a nuclear protection \nsystem, which is not concerned with the functional \nprocess of the plant, but has the power to intervene to \nprevent hazards arising. The safety manager is being \nimplemented in Pascal using a validated compiler. \nBrief comments on hardware \nAlthough not the prime purpose of this article, a few \ncomments on the hardware environment may be of \ninterest. The initial rapid prototype used a single \npowerful RTX2000 processor to run both the activities \nmanager and the low-level controller. Both programs \nwere written in the language FORTH for which this \nprocessor is optimised. Off -the-shelf eurocards communi- \ncating via an STE bus were used for the processor and \nsupporting sensor and electro-hydraulic valve interface \ncards. These were rack mounted on the roof of the \nexcavator, as shown in Fig. 1. Performance was \nsatisfactory but the system was bulky, relatively \nexpensive and lacked robustness in a high-vibration \nenvironment. \nFor the later development prototype a more \nconventional route is being followed with the use of \nmultiple 486 PCs in the ultra-compact PC104 format. So \nfar, one PC is being used for navigation and track control, \none for the activities manager and low-level controller \nand one for the safety manager. Communications \nbetween the cards is via CAN (controller area network) \nbus. It is the long-term aim to provide all on-board \nsensors with intelligent CAN bus interfaces which will \nsignificantly reduce wiring. \nSummary and conclusions \nSoftware development for intelligent robots is difficult \nbecause it is usually not possible to define the software \nrequirements in sufficient detail at the start of the project. \nPrototyping provides a means of refining requirements, \nbut this requires a hardware as well as a software \nprototype. Scale models are useful, particularly with \nlarge robots, and they should be scaleable and capable of \nbeing driven by the same software as the full-sized robot. \nThe development process for the generic class of \nintelligent robots can be described in a series of seven \nsteps, which may be reduced to six for simple or one-off \nsystems. \nThe design platform concept provides the flexibility \nfor those modules that need to be changed at the proto- \ntype stage. This should be written in a high-level \nlanguage such as Ada, so that it can be easily changed \nand maintained. The use of well known techniques such \nas finite state modelling, production systems and black- \nboard architectures can be combined to form an efficient \nand coherent intelligent knowledge-based controller. \nReferences \n1 SEWARD, D. W.: \u2018LUCIE-the autonomous robot excavator\u2019, \nIndustrid Robot, 1992, 19, (1) (MCB University Press) \n2 BOEHM, B. W.: \u2018A spiral model of software deveiopment and \nenhancement\u2019, IEEE Computer, 1988,20, (9), pp.43-58 \n3 GREEX, F\u2019., SEWARD, D. W., and BRADLEY, D. A.: \u2018Knowledge \nacquisition for a robot excavator\u2019, 7th Int. Symp. on Robotics in \nConstruction, Bristol, 1990, pp.351-357 \n4 DeMARCO, T.: \u2018Structured analysis and system specification\u2019 \n(Yourdon Press, New York, 1978) \n5 YOURDON, E., and CONSTANTINE, L. L.: \u2018Structured design\u2019 \n(Prentice-Hall, 1979) \n6 \u2018Safe system architectures for large mobile robots\u2019, EPSRC, ref. \nGFUJ18064 \n6 IEE: 1996 \nDerek Seward is with the Department of Engineering and \nAlastair Garman is with the Department of Computing, \nLancaster University, Lancaster LA1 4YR, LJK \nCOMPUTING & CONTROL ENGINEERING JOURNAL APRIL 1996 \nAuthorized licensed use limited to: Lancaster University Library. Downloaded on December 12, 2008 at 07:14 from IEEE Xplore.  Restrictions apply.\n"}