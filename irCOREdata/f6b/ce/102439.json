{"doi":"10.1109\/TIT.2004.826673","coreId":"102439","oai":"oai:epubs.surrey.ac.uk:1899","identifiers":["oai:epubs.surrey.ac.uk:1899","10.1109\/TIT.2004.826673"],"title":"Upper bounds on separating codes","authors":["Cohen, Gerard D.","Schaathun, H."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2004-06-01","abstract":"<p>We show how to compute the support weight distribution A\/sub i\/\/sup r\/ for r\/spl ges\/k-d\/sub 2\/\/sup \/spl perp\/\/+3, where d\/sub 2\/\/sup \/spl perp\/\/ is the second minimum support weight of a code, provided the weight enumerator of the dual code is known.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1899<\/identifier><datestamp>\n      2017-10-31T14:03:34Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:436F6D707574696E67<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1899\/<\/dc:relation><dc:title>\n        Upper bounds on separating codes<\/dc:title><dc:creator>\n        Cohen, Gerard D.<\/dc:creator><dc:creator>\n        Schaathun, H.<\/dc:creator><dc:description>\n        <p>We show how to compute the support weight distribution A\/sub i\/\/sup r\/ for r\/spl ges\/k-d\/sub 2\/\/sup \/spl perp\/\/+3, where d\/sub 2\/\/sup \/spl perp\/\/ is the second minimum support weight of a code, provided the weight enumerator of the dual code is known.<\/p><\/dc:description><dc:date>\n        2004-06-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1899\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Cohen, Gerard D. and Schaathun, H.  (2004) Upper bounds on separating codes   IEEE Transactions on Information Theory, 50 (5).       <\/dc:identifier><dc:relation>\n        10.1109\/TIT.2004.826673<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1899\/","10.1109\/TIT.2004.826673"],"year":2004,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"1Upper bounds on separating codes\nG\u00e9rard D. Cohen, Senior Member, IEEE\nHans Georg Schaathun, Member, IEEE\nAbstract\u2014 The combinatorial concept of separating systems\nhas numerous applications, such as automata theory, digital\nfingerprinting, group testing, and hashing. In this paper, we\nderive upper bounds on the size of codes with various separating\nproperties.\nIndex Terms\u2014 separating systems, superimposed codes, hash-\ning, error-correcting codes\nAn (n,M, d)q code is a set of M words of length n over\nan alphabet of q elements, at minimum distance d apart. If the\ncode forms a linear vector space of dimension k = logq M\nover GF(q), then we call it an [n, k, d]q code. A (t, u)-\nseparating code, also known as a (t, u)-separating system or\n(t, u)-SS, is defined as follows.\nDefinition 1: A pair (T,U) of disjoint sets of words is\ncalled a (t, u)-configuration if #T = t and #U = u. Such\na configuration is separated if there is a position i, such that\nevery word of T is different from any word of U on position\ni.\nA code is (t, u)-separating if every (t, u)-configuration is\nseparated.\nThe separating weight \u03b8(T,U) of a (t, u)-configuration\nis the number of positions i which separate it. The (t, u)-\nseparating weight \u03b8t,u of a code C is the minimum of \u03b8(T,U)\nfor all (t, u)-configurations (T,U). Note that \u03b81,1 = d. In this\npaper we present improvements on the upper bounds on (t, u)-\nseparating codes.\nI. MOTIVATION\nThe theory of separating systems has been applied in\ndifferent areas of science and technology such as automata\nsynthesis, technical diagnosis, constructions of hash functions,\nand authenticating ownership claims. Separating codes is a\ncombinatorial concept and has been studied as such in a set-\ntheoretic framework, e.g. [16].\nThe recent interest in separating codes comes mainly from\ndigital fingerprinting [6]. A vendor distributes digital copies of\na copyrighted work, and she wants to prevent the users from\nmaking illegal copies. A digital watermark is a perceptually in-\nvisible pattern embedded in a digital file. Watermarking can be\nused to give every sold copy a unique ID, a digital fingerprint,\nidentifying the buyer. If an illegal copy subsequently appears,\nthe user guilty of copying may be identified and prosecuted.\nAn interesting combinatorial problem arises in the venture\nto protect against coalitions of pirates. If several users collude,\nFirst author is with Dept. Informatique et Reseaux, ENST, Paris, France.\nEmail: \u3008cohen@infres.enst.fr\u3009.\nSecond author is with Dept. Informatics, University of Bergen, Norway.\nEmail: \u3008georg@ii.uib.no\u3009.\nThe research was partially supported by the Aurora Programme of the\nNorwegian Research Council and the Minist\u00e8re des Affaires Etrang\u00e8res of\nFrance. The second author has also been funded by the Norwegian Research\nCouncil under Grant 146874\/420.\nThe work was presented in part at the International Conference on Telecom-\nmunications in French Polynesia February 2003.\nthey may compare their copies, and every differing symbol\nmust be part of the fingerprint. Thus having identified part of\nthe fingerprint, the pirates may also change it and produce\nillegal copies with invalid fingerprint. The fingerprints the\npirates are able to forge form the so-called feasible set, defined\nas\nF (T ) := {(v1, . . . , vn) \u2208 Qn |\n\u2200i, 1 \u2264 i \u2264 n,\u2203(a1, . . . , an) \u2208 T, ai = vi},\nwhere T is the set of fingerprints held by the pirates, Q is the\nalphabet, and n is the length of a fingerprint.\nIf the set (code) of valid fingerprints still makes it possible\nto trace at least one guilty pirate out of a coalition of size t or\nless, we say that the code has the t-identifiable parent property\n(t-IPP). If the pirates are able to forge the fingerprint of an\ninnocent user, we say that this user is framed. Codes which\nprevent framing are called frameproof codes, and this concept\ncoincides with (t, 1)-separation. Other kinds of separating\ncodes have also been used to construct IPP codes [4], [3].\nIt can also be seen that if the code is (t, t)-separating, then no\ntwo disjoint pirate coallitions of size at most t can produce\nthe same false fingerprint; and therefore (t, t)-SS are known as\nt-secure frameproof codes in the fingerprinting literature [24].\nIn [23] it was proved that the best known asymptotical\n(2, 2)-separating codes are also 2-IPP with \u000f-error. In [22]\na new scheme against three pirates is constructed based on\nseparating codes.\nThe case of (2, 2)-separation was introduced by Sagalovich\nin the context of automata: two such systems transiting si-\nmultaneously from state a to a\u2032 and from b to b\u2032 respectively\nshould be forbidden to pass through a common intermediate\nstate. A state of the system in this case is an n-bit binary\nstring, and the moving from one state to another is obtained\nby flipping bits one by one. Only shortest paths from the old\nto the new state are allowed, so moving from a to a\u2032 will\nonly involve flipping bits where a and a\u2032 differ. The set of\nvalid states \u0393 forms a (2, 2)-separating system, if for any\nfour distinct states, a, a\u2032, b, and b\u2032 from \u0393, the transitions\na \u2192 a\u2032 and b \u2192 b\u2032 cannot pass through any common state.\nSagalovich\u2019s contribution on this topic is substantial and has\nbeen surveyed in [21].\nII. MINIMUM ALPHABET SIZE FOR LINEAR SS\nIf a linear code is to be (t, u)-separating, then the alphabet\nmust have a certain minimum size. Here we give lower bounds\non q. The result for binary codes is probably well-known, but\nthe non-binary result appears to be unknown in the literature.\nProposition 1: Let a and b be two linearly independent\ncodewords, and write T = {a}\u222a{b+\u03b1a | \u03b1 \u2208 GF(q)}. Then\n(0, T ) is a (q + 1, 1)-configuration which is not separated.\nProof: We shall prove that in every position i, at least\none codeword in T has a 0. If ai = 0, this holds, so assume\nai 6= 0. Then b\u2212 a\u22121i bia has 0 in position i, as required.\nCorrollary 1: If C is q-ary, linear (t, t\u2032)-separating, then\nmax{t, t\u2032} \u2264 q.\nThis bound is tight in the binary case, since (2, 2)-separating,\nbinary, linear codes are known to exist (e.g. [21]).\n2Theorem 1: If C is a non-binary, linear (t, t\u2032)-separating,\nthen t+ t\u2032 \u2264 q + 1.\nProof: We have already proved that max{t, t\u2032} \u2264 q. It\nonly remains to prove that we can construct a non-separated\n(t, q + 2 \u2212 t)-configuration for all t such that 2 \u2264 t \u2264 q. By\nsymmetry, it is sufficient to show this when t \u2264 q + 2 \u2212 t,\nin particular when t < q. Let \u03b10, \u03b11, . . . , \u03b1q\u22121 be all the\nfield elements, where \u03b10 = 0 and \u03b11 = 1. Let a and b be\ntwo independent codewords. A non-separated (t, q + 2 \u2212 t)-\nconfiguration is given by\n({\u03b10a, . . . , \u03b1t\u22121a}, {\u03b1ta,a+ \u03b11b, . . . ,a+ \u03b1q+1\u2212tb}).\nFirst note that \u03b1ta matches 0 on every position not in \u03c7(a),\nand a+ b matches a on every position not in \u03c7(b). In every\nposition in \u03c7(a) \u2229 \u03c7(b), we get t different field values in the\nfirst set, and q+1\u2212 t different field values from the a+\u03b1ib.\nSince there are only q elements in the field, they cannot be\nseparated.\nIII. ON (t, 1)-SEPARATING CODES\nIt was proved by Blackburn [5] that any (t, 1)-separating\ncode has M \u2264 t \u00b7 qdn\/te. We generalise this result for codes\nwith a guaranteed (t, 1)-separating weight \u03b8t,1 = \u03c4n. Such\ncodes have been studied in [13], [17] motivated by broadcast\nencryption.\nPartition {1, 2, ..n} into t almost equal parts P1, . . . , Pt of\nsize bn\/tc or dn\/te. Say a codeword c is isolated on Pi if\nno other codeword projects onto a n\/t-tuple on Pi located at\ndistance less than (n\/t)\u03c4 from c.\nLemma 1: If C has (t, 1)-separating weight n\u03c4 or greater,\nthen every codeword c \u2208 C is isolated on at least one Pi.\nProof: Suppose for a contradiction that there is a\ncodeword c0 which is isolated on no Pi. Let ci be a codeword\nat distance less than (n\/t)\u03c4 from it when projected onto Pi,\nfor i = 1, . . . , t. Now c0 is separated from {c1, . . . , ct}\non less than (n\/t)\u03c4 coordinates per block, or less than n\u03c4\ncoordinate positions total. This contradicts the assumption on\nthe separating weight \u03c4 .\nDenote by Ii the subset of codewords isolated on Pi. We\nhave just proved that C \u2282 \u22c3 Ii. Furthermore, every nonempty\nIi is a code of minimum distance at least b(n\/t)\u03c4c and thus\nsize at most qd(1\u2212\u03c4)n\/te by the Singleton bound ([19]). This\nproves:\nTheorem 2: If C has (t, 1)-separating weight n\u03c4 or greater,\nthen #C \u2264 tqd(1\u2212\u03c4)n\/te.\nFor constant t, this asymptotically gives R \u2264 (1 \u2212 \u03c4)\/t\nwhen n increases, where R := (logq #C)\/n is the code rate.\nIf we let \u03c4 tend to zero, we get an upper bound on (t, 1)-SS,\nwhich was found independently in [10] and [5]. The proofs are\nessentially the same as the one presented here. Asymptotically\nwhen n increases, the best possible rate of a (t, 1)-SS is at\nmost 1\/t.\nIV. UPPER BOUNDS BY PROJECTION\nIn this section, we give a general presentation of the well-\nknown recursive projection arguments for upper bounds. The\ntechnique have been used for decades, but the results have\ncontinuously been refined in various ways, see e.g. [21]. Here\nwe make yet a step forward in tightening the bounds, both\nfor separating codes and for the related superimposed and\ncompletely separating codes.\nA. The binary case\nSeparating codes are related to two stronger concepts.\nCompletely separating codes ((t, t\u2032)-CSS) are used in automata\ntheory and fault-tolerant systems alongside the separating\ncodes. Superimposed codes ((t, t\u2032)-SI) where introduced in\n[14], and have been studied in several papers, e.g. [11], [12].\nWe will consider the binary case only. Consider any t+ t\u2032\ncodewords and view them as rows of a matrix. If the code\nis separating, there must be at least one separating column,\nwhich is either x0 = (0 . . . 01 . . . 1) with t zeroes and t\u2032 ones,\nor x1 = (1 . . . 10 . . . 0) with t ones and t\u2032 zeroes.\nIf the code is (t, t\u2032)-superimposed, we demand at least\none column of type x0, and if the code is (t, t\u2032)-completely\nseparating, we demand both x1 and x0. Thus separating codes\nis clearly the weakest concept, while completely separating\nsystems is the strongest. If t = t\u2032, superimposed codes and\ncompletely separating codes are equivalent, since the property\nhas to hold for any ordering of the words.\nLet RCSS(t, t\u2032), RSI(t, t\u2032), and RSS(t, t\u2032) be the best pos-\nsible asymptotic rates of (t, t\u2032)-CSS, (t, t\u2032)-SI, and (t, t\u2032)-SS,\nrespectively. Clearly we have\nRSS(t, t\u2032) \u2265 RSI(t, t\u2032) \u2265 RCSS(t, t\u2032) \u2265 1\n2\nRSS(t, t\u2032).\nWe denote by R\u00afx(t, t\u2032) any upper bound on Rx(t, t\u2032). Let R\u00af(\u03b4)\nbe any upper bound on the asymptotic rate of error-correcting\ncodes with normalised minimum distance \u03b4 = d\/n.\nProposition 2: Any binary (t, u)-separating (\u03b80,0,M, \u03b81,1)\ncode \u0393 with separating weights \u03b8a,b, for 1 \u2264 a \u2264 t and\n1 \u2264 b \u2264 u, gives rise to, for any positive v < min{t, u}, a\ncompletely (t\u2212v, u\u2212v)-separating (\u03b8v,v,M\u22122v, 2\u03b8v+1,v+1)\ncode \u0393\u2032 with complete-separating weights \u03b8\u2032a,b = \u03b8a+v,b+v for\n1 \u2264 a \u2264 t\u2212 v and 1 \u2264 b \u2264 u\u2212 v.\nProof: Consider two v-tuples V and V \u2032 of words from \u0393,\nsuch that they have separating weight \u03b8v,v . Assume by transla-\ntion that (V, V \u2032) has \u03b8v,v columns of the form (0 . . . 01 . . . 1).\nLet \u0393\u2032 be the code obtained from \u0393 by deleting every column\nwhere (V, V \u2032) is not separated and the 2v words from V\nand V \u2032. Clearly \u0393\u2032 has the length and size claimed by the\nproposition. It remains to prove the statement on separating\nweights.\nLet (T,U) be a (t\u2032, u\u2032)-configuration from \u0393 where t\u2032 \u2264\nt\u2212 v and u\u2032 \u2264 u\u2212 v. Then both (V \u222a T, V \u2032 \u222a U) and (V \u2032 \u222a\nT, V \u222a U) must have separating weight at least \u03b8t\u2032+v,u\u2032+v ,\nwhich implies that (T,U) is completely separated with weight\nat least \u03b8t\u2032+v,u\u2032+v . This holds even when restricting only to\nthe positions where (V, V \u2032) is separated.\nThe following proposition is proved in the same way.\nProposition 3: Any completely (t, u)-separating\n(n,M, 2\u03b81,1) code with completely separating weights\n\u03b8a,b, for 1 \u2264 a \u2264 t and 1 \u2264 b \u2264 u, gives rise to, for any\npositive v < min{t, u}, a completely (t\u2212 v, u\u2212 v)-separating\n3(t, t\u2032) CSS SIC SS\n(2, 1) \u2014 0.32192 0.51\n(3, 1) \u2014 0.19932 0.33331\n(3, 2) 0.06627 0.074493 0.1202\n(4, 2) 0.04301 0.045523 0.07994\n(4, 3) 0.01533 0.018283 0.02951\n(t, t) CSS SS\n(1, 1) 1.0000 1.0000\n(2, 2) 0.16102 0.28354\n(3, 3) 0.03534 0.066275\n(4, 4) 0.008368 0.01630\n(5, 5) 0.002042 0.004037\n1 Theorem 2\n2 [12]\n3 [15]\n4 Well known, see [21].\n5 A slightly stronger bound is alleged in [8].\nTABLE I\nUPPER BOUNDS ON COMPLETELY SEPARATING CODES (CSS),\nSUPERIMPOSED CODES (SIC), AND SEPARATING CODES (SS) OVER A\nBINARY ALPHABET.\n(\u03b8v,v,M \u2212 2v, 2\u03b8v+1,v+1) code with complete-separating\nweights \u03b8\u2032a,b = \u03b8a+v,u+v for 1 \u2264 a \u2264 t\u2212v and 1 \u2264 b \u2264 u\u2212v.\nTheorem 3: We have for t, u \u2265 2 that\nRCSS(t, u) \u2264 R\u00af\n(\n2RCSS(t, u)\nR\u00afCSS(t\u2212 1, u\u2212 1)\n)\n,\nRSS(t, u) \u2264 R\u00af\n(\nRSS(t, u)\nR\u00afCSS(t\u2212 1, u\u2212 1)\n)\n.\nProof: Let C be a (t, u)-CSS with rate R = RCSS(t, u),\nand let C \u2032 be the (t \u2212 1, u \u2212 1)-CSS which exists by Propo-\nsition 3. Denote by R\u2032 the rate of C \u2032. We have that\n\u03b4 = 2\n\u03b81,1\n\u03b80,0\n= 2\nlogM\n\u03b80,0\n\u03b81,1\nlogM\n= 2R\/R\u2032.\nNow, obviously R \u2264 R\u00af(\u03b4), which is decreasing in \u03b4t, and this\ngives the result. The bound on RSS is similar, except that the\nminimum distance of C is d = \u03b81,1 instead of 2\u03b81,1.\nThis theorem provides a recursive bound on separating\ncodes. The general idea is not new, at least the derived bound\non (2, 2)-SS has been known for ages, see [21]. Even so, the\nresults we obtain here for (t, t)-CSS are stronger than those\nrecently presented in [12] (except for t = 2).\nWe use the linear programming bound for R\u00af(\u03b4), as given in\nthe following theorem in its q-ary version. See [2] for the non-\nbinary form and [20] for the original (binary) version. Also\nnote improvements in [1], [18].\nTheorem 4 (Linear Programming Bound): For any\n(n,M, d) q-ary code, we have\nR(\u03b4) \u2264 Hq(((q \u2212 1)\u2212 (q \u2212 2)\u03b4 \u2212 2\n\u221a\n(q \u2212 1)\u03b4(1\u2212 \u03b4))\/q),\nwhere\nHq(x) = \u2212(1\u2212 x) logq(1\u2212 x)\u2212 x logq x+ x logq(q \u2212 1).\nIn Table I, we summarise the rate we get for small t and\nt\u2032, and q = 2. Most of the rates are obtained by using\nthe theorems of this section recursively. The first bounds in\nthe iterations are copied from other works. Observe that we\nimprove the bounds also on (t, t)-superimposed codes for\nt \u2265 3.\nExample 1: Let C1 be an asymptotic class of (\u03b80, 2k, \u03b81)\n(3, 3)-SS. Then there is an asymptotic class C2 of (\u03b81, 2k, \u03b82)\n(2, 2)-CSS. We have that R2 = k\/\u03b81 \u2264 0.161, and\nR1 = k\/\u03b80 = R2\u03b41 \u2264 0.161\u03b41,\nwhich is equivalent to\n\u03b41 \u2265 R1\/0.161.\nWe can use any upper bound R\u00af(\u03b4) on R1, and get\nR1 \u2264 R\u00af(\u03b41) \u2264 R\u00af(R1\/0.161).\nUsing the Theorem 4, we get R1 \u2264 0.0663.\nB. The ternary case\nIn the non-binary case, complete separation is not clearly\ndefined. When q > 3, we are not able to prove a recursive\nbound stronger than\nRSSq (t, u) \u2264 R\u00af\n(\nRSSq (t, u)\nR\u00afSSq (t\u2212 1, u\u2212 1)\n)\n,\nwhich is considerably weaker than the binary result. The\nreason for this is found in the proofs of Propositions 2 and 3:\nsince there are four alphabet symbols (or more), it is possible\nto have one column which separates both (V \u222aT, V \u2032\u222aU) and\n(V \u2032 \u222a T, V \u222a U).\nIn the ternary case, though, we get a strong analogue\nof the binary results by defining ternary pseudo-completely\nseparating weights. Let (T,U) be a (t, u)-configuration. A\nseparating column i is of Type 0 if xi 6= 1 for all x \u2208 T\nand yi 6= 0 for all y \u2208 U . It is of Type 1 if xi 6= 0 for all\nx \u2208 T and yi 6= 1 for all y \u2208 U . Note that one column can\nbe both of Type 0 and of Type 1 if and only if q > 3.\nThe pseudo-completely separating weight of a ternary code\nC is the largest number \u03b8t,u such that any (t, u)-configuration\nhas at least \u03b8t,u separating columns of Type 0 and at least \u03b8t,u\nseparating columns of Type 1.\nThe following two lemmata can be proved using the proof\nof Proposition 2.\nLemma 2: Any ternary (t, u)-separating (\u03b80,0,M, \u03b81,1)\ncode \u0393 with separating weights \u03b8a,b, for 1 \u2264 a \u2264 t and 1 \u2264\nb \u2264 u, gives rise to, for any positive v < min{t, u}, a pseudo-\ncompletely (t\u2212v, u\u2212v)-separating (\u03b8v,v,M\u22122v, 2\u03b8v+1,v+1)\ncode \u0393\u2032 with pseudo-completely separating weights \u03b8\u2032a,b =\n\u03b8a+v,u+v .\nLemma 3: Any ternary pseudo-completely (t, u)-separating\n(\u03b80,0,M, 2\u03b81,1) code \u0393 with pseudo-completely separating\nweights \u03b8a,b, for 1 \u2264 a \u2264 t and 1 \u2264 b \u2264 u, gives rise to, for\nany positive v < min{t, u}, a pseudo-completely (t\u2212v, u\u2212v)-\nseparating (\u03b8v,v,M \u2212 2v, 2\u03b8v+1,v+1) code \u0393\u2032 with pseudo-\ncompletely separating weights \u03b8\u2032a,b = \u03b8a+v,u+v .\nAnalogously to Theorem 3, we get the following theorem.\nTable II follows by combining Theorem 5 with the linear\nprogramming bound.\n4(t, t) PCSS SS\n(1, 1) 1 1\n(2, 2) 0.2197 0.3537\n(3, 3) 0.06204 0.1138\n(4, 4) 0.01913 0.03675\n(5, 5) 0.006120 0.01202\n(t, t\u2032) PCSS SS\n(3, 2) 0.1268 0.2197\n(4, 3) 0.03751 0.07056\n(5, 4) 0.01180 0.02290\n(4, 2) 0.08978 0.1605\n(5, 3) 0.02713 0.05167\n(5, 2) 0.06966 0.1268\nTABLE II\nUPPER BOUNDS ON TERNARY SEPARATING CODES, COMPUTED BY USING\nTHE BOUND R \u2264 1\/t FOR (t, 1)-SS AND -PCSS (THEOREM 2) AND\nRECURSIVE APPLICATION OF THEOREM 5.\nt+ u Rate\n3 0.3537\n4 0.1683\n5 0.09050\n6 0.05206\nTABLE III\nUPPER BOUNDS ON TERNARY LINEAR SEPARATING CODES, COMPUTED BY\nRECURSIVE APPLICATION OF COROLLARY 2.\nTheorem 5: We have for t, u \u2265 2 that\nRPCSS3 (t, u) \u2264 R\u00af\n(\n2RPCSS3 (t, u)\nR\u00afPCSS3 (t\u2212 1, u\u2212 1)\n)\n,\nRSS3 (t, u) \u2264 R\u00af\n(\nRSS3 (t, u)\nR\u00afPCSS3 (t\u2212 1, u\u2212 1)\n)\n.\nC. The linear case\nLet RLSSq (t, u) be the highest possible rate for an asymptotic\nfamily of linear, q-ary (t, u)-separating code.\nProposition 4: Any linear separating [\u03b80,0, k, \u03b81,1] code C\nwith separating weights \u03b8a,b, where 1 \u2264 a \u2264 t and 1 \u2264 b \u2264\nu, gives rise to a linear separating [\u03b80,1, k \u2212 1, \u03b81,2] code C \u2032\nwith separating weights \u03b8\u2032a,b = \u03b8a,b+1, where 1 \u2264 a \u2264 t and\n1 \u2264 b \u2264 u\u2212 1.\nProof: Let c \u2208 C be a codeword of weight \u03b81,1. Let C \u2032\nbe the code obtained by shortening C on every position where\nc is zero. It remains to prove that \u03b8a,b(C \u2032) \u2265 \u03b8a,b+1(C) for\nall a and b. It is sufficient that any (a, b)-configuration (A,B)\nof C \u2032 with 0 \u2208 A has separating weight at least \u03b8a,b+1(C).\nConsider the corresponding (a, b+1)-configuration (A,B\u2032) =\n(A,B\u222a{c}) in C. Observe that (A,B\u2032) can only be separated\nwhere c is non-zero, i.e. on positions existing in C \u2032. Hence\n\u03b8(A,B) = \u03b8(A,B\u2032) \u2265 \u03b8a,b+1(C) as required.\nCorrollary 2: For any t \u2265 1 and u \u2265 2, we have\nRLSSq (t, u) \u2264 R\u00af\n(\nRLSSq (t, u)\nR\u00afLSSq (t, u\u2212 1)\n)\n.\nNote that this bound depends only on the sum t+u. We have\ncomputed numerical values for q = 3 in Table III. Applying\nthe corollary for q = 2 gives the same bounds as the ones\nobtained from intersecting codes in [9].\nV. CONCLUSION\nWe have refined the upper bounds on (t, u)-separating\ncodes. This has also led to improvements on the upper bounds\nfor (t, t)-superimposed codes (completely separating codes).\nREFERENCES\n[1] M. Aaltonen, \u201cA new upper bound on nonbinary block codes,\u201d Discrete\nMath., vol. 83, no. 2-3, pp. 139\u2013160, 1990.\n[2] M. J. Aaltonen, \u201cLinear programming bounds for tree codes,\u201d IEEE\nTrans. Inform. Theory, vol. 25, no. 1, pp. 85\u201390, 1979.\n[3] A. Barg, G. R. Blakley, and G. A. Kabatiansky, \u201cDigital fingerprinting\ncodes: Problem statements, constructions, identification of traitors,\u201d\nIEEE Trans. Inform. Theory, vol. 49, no. 4, pp. 852\u2013865, Apr. 2003.\n[4] A. Barg, G. Cohen, S. Encheva, G. Kabatiansky, and G. Z\u00e9mor, \u201cA\nhypergraph approach to the identifying parent property,\u201d SIAM J. Disc.\nMath., vol. 14, no. 3, pp. 423\u2013431, 2001.\n[5] S. R. Blackburn, \u201cFrameproof codes,\u201d SIAM J. Discrete Math., vol. 16,\nno. 3, pp. 499\u2013510, 2003.\n[6] D. Boneh and J. Shaw, \u201cCollusion-secure fingerprinting for digital data,\u201d\nIEEE Trans. Inform. Theory, vol. 44, no. 5, pp. 1897\u20131905, 1998,\npresented in part at CRYPTO\u201995.\n[7] B. Chor, A. Fiat, and M. Naor, \u201cTracing traitors,\u201d in Advances in\nCryptology - CRYPTO \u201994, ser. Springer Lecture Notes in Computer\nScience, vol. 839. Springer-Verlag, 1994, pp. 257\u2013270.\n[8] F. Chung, R. Graham, and T. Leighton, \u201cGuessing secrets,\u201d Electron. J.\nCombin., vol. 8, 2001.\n[9] G. D. Cohen, S. B. Encheva, S. Litsyn, and H. G. Schaathun, \u201cInter-\nsecting codes and separating codes,\u201d Discrete Applied Mathematics, vol.\n128, no. 1, pp. 75\u201383, 2003.\n[10] G. D. Cohen and H. G. Schaathun, \u201cNew upper bounds on separating\ncodes,\u201d in 2003 International Conference on Telecommunications, Feb.\n2003.\n[11] A. G. D\u2032yachkov and V. V. Rykov, \u201cA survey of superimposed code\ntheory,\u201d Problems Control Inform. Theory\/Problemy Upravlen. Teor.\nInform., vol. 12, no. 4, pp. 229\u2013242, 1983, english translation from\nRussian.\n[12] A. G. D\u2032yachkov, P. Vilenkin, A. Macula, and D. Torney, \u201cFamilies of\nfinite sets in which no intersection of ` sets is covered by the union of\ns others,\u201d J. Combin. Theory, vol. 99, pp. 195\u2013208, 2002.\n[13] J. Garay, J. Staddon, and A. Wool, \u201cLong-lived broadcast encryption,\u201d\nin Crypto 2000, ser. Springer Lecture Notes in Computer Science, vol.\n1880, 2000, pp. 333\u2013352.\n[14] W. Kautz and R. Singleton, \u201cNonrandom binary superimposed codes,\u201d\nIEEE Trans. Inform. Theory, vol. 10, no. 4, pp. 363\u2013377, Oct. 1964.\n[Online]. Available: http:\/\/ieeexplore.ieee.org\/iel5\/18\/22624\/01053689.\npdf\n[15] H. K. Kim, V. Lebedev, and D. Y. Oh, \u201cSome new results on (w, r)\nsuperimposed codes,\u201d 2003, preprint.\n[16] J. K\u00f6rner and G. Simonyi, \u201cSeparating partition systems and locally\ndifferent sequences,\u201d SIAM J. Discrete Math., vol. 1, pp. 355\u2013359, 1988.\n[17] R. Kumar, S. Rajagopalan, and A. Sahai, \u201cCoding constructions\nfor blacklisting problems without computational assumptions,\u201d in\nCrypto\u201999, ser. Springer Lecture Notes in Computer Science, vol. 1666,\n1999, pp. 609\u2013623.\n[18] T. Laihonen and S. Litsyn, \u201cOn upper bounds for minimum distance\nand covering radius of non-binary codes,\u201d Designs, Codes, and Cryp-\ntography, vol. 14, no. 1, pp. 71\u201380, 1998.\n[19] F. J. MacWilliams and N. J. A. Sloane, The Theory of Error-Correcting\nCodes. North-Holland, Amsterdam, 1977.\n[20] R. J. McEliece, E. R. Rodemich, H. Rumsey, Jr., and L. R. Welch,\n\u201cNew upper bounds on the rate of a code via the Delsarte-MacWilliams\ninequalities,\u201d IEEE Trans. Inform. Theory, vol. IT-23, no. 2, pp. 157\u2013\n166, 1977.\n[21] Y. L. Sagalovich, \u201cSeparating systems,\u201d Problems of Information Trans-\nmission, vol. 30, no. 2, pp. 105\u2013123, 1994.\n[22] H. G. Schaathun, \u201cFighting three pirates with scattering codes,\u201d 2003,\nsubmitted to ISIT\u201904 in Chicago.\n[23] \u2014\u2014, \u201cFighting two pirates,\u201d in Applied Algebra, Algebraic Algorithms\nand Error-Correcting Codes, ser. Springer Lecture Notes in Computer\nScience, vol. 2643. Springer-Verlag, May 2003, pp. 71\u201378.\n[24] J. N. Staddon, D. R. Stinson, and R. Wei, \u201cCombinatorial properties of\nframeproof and traceability codes,\u201d IEEE Trans. Inform. Theory, vol. 47,\nno. 3, pp. 1042\u20131049, 2001.\n"}