{"doi":"10.1145\/1278972.1278995","coreId":"70171","oai":"oai:eprints.lancs.ac.uk:12992","identifiers":["oai:eprints.lancs.ac.uk:12992","10.1145\/1278972.1278995"],"title":"Adding Preemption to TinyOS","authors":["Duffy, Cormac","Roedig, Utz","Herbert, John","Sreenan, Cormac J."],"enrichments":{"references":[{"id":16309456,"title":"A systematic framework for evolving TinyOS,\u201d","authors":[],"date":"2006","doi":null,"raw":"E. Trumpler and R. Han., \u201cA systematic framework for evolving TinyOS,\u201d in IEEE Workshop on Embedded Networked Sensors, pp. 61\u201365, May 2006.","cites":null},{"id":16309458,"title":"Abstractions for safe concurrent programming in networked embedded systems,\u201d","authors":[],"date":"2006","doi":"10.1145\/1182807.1182825","raw":"W. P. McCartney and N. Sridhar, \u201cAbstractions for safe concurrent programming in networked embedded systems,\u201d in Proceedings of the 4th international conference on Embedded networked sensor system, pp. 167 \u2013 180, October 2006.","cites":null},{"id":16309460,"title":"Cyclops: In situ image sensing and interpretation in wireless sensor networks,\u201d","authors":[],"date":"2005","doi":"10.1145\/1098918.1098939","raw":"M. Rahimi, R. Baer, O. I. Iroezi, J. C. Garcia, J. Warrior, D. Estrin, and M. Srivastava., \u201cCyclops: In situ image sensing and interpretation in wireless sensor networks,\u201d in In proc. 3rd international conference on Embedded Networked Sensor Systems,, pp. 192\u2013204, November 2005.","cites":null},{"id":16309454,"title":"Evolving realtime systems using hierarchical scheduling and concurrency analysis,\u201d","authors":[],"date":"2003","doi":"10.1109\/real.2003.1253251","raw":"J. Regehr, A. Reid, K. Webb, M. Parker, and J. Lepreau, \u201cEvolving realtime systems using hierarchical scheduling and concurrency analysis,\u201d in 24th IEEE Internation Real-Time Systems Symposium, pp. 25\u201336, December 2003.","cites":null},{"id":16309452,"title":"Improving the Energy Ef\ufb01ciency of the MANTIS Kernel,\u201d","authors":[],"date":"2007","doi":"10.1007\/978-3-540-69830-2_17","raw":"C. Duffy, U. Roedig, J. Herbert, and C. J. Sreenan, \u201cImproving the Energy Ef\ufb01ciency of the MANTIS Kernel,\u201d in Proceedings of the 4th IEEE European Workshop on Wireless Sensor Networks (EWSN2007), Delft, Netherlands, Jan. 2007.","cites":null},{"id":16309450,"title":"MANTIS: System support for multimodal networks of insitu sensors,\u201d","authors":[],"date":"2003","doi":"10.1145\/941350.941358","raw":"H. Abrach, S. Bhatti, J. Carlson, H. Dai, J. Rose, A. Sheth, B. Shucker, and R. Han, \u201cMANTIS: System support for multimodal networks of insitu sensors,\u201d in 2nd ACM International Workshop on Wireless Sensor Networks and Applications, pp. 50\u201359, September 2003.","cites":null},{"id":16309448,"title":"System architecture directions for networked sensors,\u201d","authors":[],"date":"2000","doi":"10.1145\/356989.356998","raw":"J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and K. Pister, \u201cSystem architecture directions for networked sensors,\u201d in ACM SIGOPS Operating Systems Review, vol. 34, pp. 93\u2013104, December 2000.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-06","abstract":"Event-driven operating systems such as TinyOS are the preferred choice for wireless sensor networks. Alternative designs such as MANTIS following a classical multi-threaded approach are also available. Event-based systems are generally more energy efficient than multi-threaded systems. However, multi-threaded systems are more capable than event-based systems of supporting time critical tasks as task preemption is supported. Timeliness can be traded for energy efficiency by choosing the appropriate operating system. In our recent work we have shown that the multi-threaded system MANTIS can be modified to be as energy efficient as TinyOS. As a result, the modified MANTIS can be used to fit both sensor network design goals of energy efficiency and timeliness. This solution is not considered optimal as most existing sensor network applications and software libraries are developed for TinyOS. Therefore, we present a TinyOS modification that adds preemption while retaining the existing TinyOS structure and features","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/70171.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/12992\/1\/emnets07duffy.pdf","pdfHashValue":"a345bdea6efdf5ae0dad2b914695fe1e786d93e8","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:12992<\/identifier><datestamp>\n      2018-01-24T02:10:28Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D626F6F6B5F73656374696F6E<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Adding Preemption to TinyOS<\/dc:title><dc:creator>\n        Duffy, Cormac<\/dc:creator><dc:creator>\n        Roedig, Utz<\/dc:creator><dc:creator>\n        Herbert, John<\/dc:creator><dc:creator>\n        Sreenan, Cormac J.<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        Event-driven operating systems such as TinyOS are the preferred choice for wireless sensor networks. Alternative designs such as MANTIS following a classical multi-threaded approach are also available. Event-based systems are generally more energy efficient than multi-threaded systems. However, multi-threaded systems are more capable than event-based systems of supporting time critical tasks as task preemption is supported. Timeliness can be traded for energy efficiency by choosing the appropriate operating system. In our recent work we have shown that the multi-threaded system MANTIS can be modified to be as energy efficient as TinyOS. As a result, the modified MANTIS can be used to fit both sensor network design goals of energy efficiency and timeliness. This solution is not considered optimal as most existing sensor network applications and software libraries are developed for TinyOS. Therefore, we present a TinyOS modification that adds preemption while retaining the existing TinyOS structure and features.<\/dc:description><dc:date>\n        2007-06<\/dc:date><dc:type>\n        Contribution in Book\/Report\/Proceedings<\/dc:type><dc:type>\n        NonPeerReviewed<\/dc:type><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/eprints.lancs.ac.uk\/12992\/1\/emnets07duffy.pdf<\/dc:identifier><dc:relation>\n        http:\/\/dx.doi.org\/10.1145\/1278972.1278995<\/dc:relation><dc:identifier>\n        Duffy, Cormac and Roedig, Utz and Herbert, John and Sreenan, Cormac J. (2007) Adding Preemption to TinyOS. In: EmNets '07 Proceedings of the 4th workshop on Embedded networked sensors. , pp. 88-92. ISBN 978-1-59593-694-3<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/12992\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1145\/1278972.1278995","http:\/\/eprints.lancs.ac.uk\/12992\/"],"year":2007,"topics":["QA75 Electronic computers. Computer science"],"subject":["Contribution in Book\/Report\/Proceedings","NonPeerReviewed"],"fullText":"1Adding Preemption to TinyOS\nCormac Duffy1, Utz Roedig2, John Herbert1, Cormac J. Sreenan1\n1Computer Science Department, University College Cork, Ireland\n2InfoLab21, Lancaster University, Lancaster\nAbstract\u2014Event-driven operating systems such as TinyOS are\nthe preferred choice for wireless sensor networks. Alternative\ndesigns such as MANTIS following a classical multi-threaded\napproach are also available. Event-based systems are generally\nmore energy efficient than multi-threaded systems. However,\nmulti-threaded systems are more capable than event-based sys-\ntems of supporting time critical tasks as task preemption is\nsupported. Timeliness can be traded for energy efficiency by\nchoosing the appropriate operating system. In our recent work\nwe have shown that the multi-threaded system MANTIS can be\nmodified to be as energy efficient as TinyOS. As a result, the\nmodified MANTIS can be used to fit both sensor network design\ngoals of energy efficiency and timeliness. This solution is not\nconsidered optimal as most existing sensor network applications\nand software libraries are developed for TinyOS. Therefore,\nwe present a TinyOS modification that adds preemption while\nretaining the existing TinyOS structure and features.\nI. INTRODUCTION\nSensor nodes must be designed to be energy efficient in\norder to allow long periods of unattended network operation.\nHowever, energy efficiency is not the only design goal in a\nsensor network. For example, timely processing and reporting\nof sensing information is often required as well. This might\nbe needed to guarantee a maximum delivery time of sensing\ninformation from a sensor, through a multi-hop network, to\na base-station. To be able to give such assurances, network\ncomponents with a deterministic behavior will be required.\nThe operating system running on sensor nodes is one such\ncomponent.\nEvent-based operating systems are considered to be the best\nchoice for building energy efficient sensor networks as they\nrequire little memory and processing resources. Hence, the\nevent-based TinyOS [1] is currently the preferred operating\nsystem for sensor networks. Event-based operating systems\nare not very useful in situations where tasks have processing\ndeadlines. As tasks are processed sequentially, prioritizing\nimportant tasks to meet processing deadlines is not possible.\nMulti-threaded operating systems are more suitable if such\nrequirements must be fulfilled. Thread preemption and context\nswitching enables such systems to prioritize tasks and meet\ndeadlines. The MANTIS [2] operating system is a multi-\nthreaded operating system designed specifically for wireless\nsensor networks. MANTIS has a relatively high processing\noverhead for thread management. This processing overhead is\ndirectly related to reduced energy efficiency because of the\nrelative increase in CPU activity.\nThis creates the dilemma that both design goals - energy\nefficiency and timeliness - can only currently be optimized\nindependently. One is forced to choose which goal is of higher\nimportance in the considered application scenario. Therefore,\nit would be good if the dilemma could be resolved by either\nmaking MANTIS more energy efficient or TinyOS more\nresponsive.\nOur previous work [3] concentrated on the first option: A\nMANTIS kernel modification to increase power efficiency.\nAs the results show, MANTIS can be modified to be as\npower-efficient as TinyOS without impacting vital kernel func-\ntionality. Thus, the modified MANTIS can be used to solve\nboth important sensor network design goals. The result of\nthis previous work also shows that the common belief that\n\u201cmulti-threaded operating systems are not suitable for resource\nconstrained sensor networks\u201d is not necessarily true.\nThe modified MANTIS provides a solution for our previ-\nously outlined dilemma but has other considerable limitations.\nThe sensor network community selected TinyOS as the defacto\nstandard with most existing applications, libraries and device\ndrivers available for TinyOS. Therefore, to avoid re-coding\nexisting software and allow re-usage of existing TinyOS in-\nfrastructures it is worth exploring the second option: A TinyOS\nmodification to increase system responsiveness. This paper\npresents a modification that adds preemption to TinyOS which\nresults in a responsive system that retains its existing structure\nand features.\nThe next Section of the paper presents related work. Sec-\ntion III describes briefly TinyOS and explains its limitations\nin terms of responsiveness. Section IV explains in detail our\nTinyOS modifications to add preemption. Section V presents\nan evaluation of the modified system. It is shown how ex-\nisting applications can take advantage of the new preemptive\nscheduler. Section VI concludes the paper.\nII. RELATED WORK\nIn [4], the TinyOS operating system is executed within a\nmulti-threaded AVRX kernel as part of a concurrency analysis\nstudy. Thus, any TinyOS task could be preempted by another\nAVRX thread. This solution has some drawbacks. The solution\nis bound to AVR based microprocessors. Furthermore, the\nAVRX kernel provides many threading features not necessarily\nneeded for event-based programming. The system has memory\nrequirements of both, TinyOS and the AVRX kernel.\nA similar approach with comparable limitations can be seen\nin [5]. Here, the TinyOS operating system is executed as a\nthread within the multi-threaded MANTIS operating system.\nThe resulting TinyMOS system has a large memory footprint\n(see Section V). Many context switches (for example, intro-\nduced by time-slicing) create a significant processing overhead\n2(see [3]). In addition, TinyOS and MANTIS programming\nsemantics are mixed which makes TinyMOS usage difficult.\nA different approach is described in [6]. Here, a multi-\nthreading library for TinyOS called TinyThread is presented.\nThe TinyThread library provides TinyOS programmers with\na thread programming abstraction but does not enable task\npreemption. A thread scheduler in the form of a TinyOS task\nis periodically placed in the task queue. Threads are then\nscheduled and run to completion or until they block. This\napproach allows users to multiplex standard TinyOS tasks and\nthreads, but does not facilitate preemption and cannot provide\nany degree of performance control. Furthermore, threads are\nprogrammed in a different fashion to normal TinyOS code\nwhich does not allow a seamless integration of TinyThreads\nwith existing TinyOS applications.\nThe approach presented in this paper differs from the\ndescribed existing works in major aspects. Thread preemption\nis added natively to TinyOS. Context switching is only used\nto facilitate task preemption and not to introduce a thread\nprogramming abstraction. Standard TinyOS programming con-\nventions are used such that preemption features are seamlessly\nintegrated.\nIII. THE TINYOS ARCHITECTURE\nThis section first describes the basic TinyOS functionality\naffected by our modifications. Thereafter, the limitations of\nTinyOS motivating our modifications are discussed.\nA. Basic Functionality\nThe TinyOS system and specialized applications are written\nin a component based programming language called nesC. The\ncomponents are self contained modules of code that interact\nwith each other through strict interfaces. A component inter-\nface is characterised by a number of event handling functions.\nEvent-based applications are implemented as series of event-\nhandlers and tasks. TinyOS tasks are deferred function calls\nthat are placed in a simple FIFO task-queue for execution.\nTinyOS tasks are taken sequentially from the queue and are\nrun to completion. Once running, a TinyOS task can not\nbe interrupted (preempted) by another TinyOS task. Event-\nhandlers are triggered in response to a hardware interrupt\nand are able to preempt the execution of a currently running\nTinyOS task. Event-handlers perform the minimum amount of\nprocessing to serve the event. Further processing is performed\nwithin a TinyOS task that is normally created within the event\nhandler. After all TinyOS tasks in the task queue are executed,\nthe TinyOS system enters a sleep state to conserve energy. The\nsleep state is terminated when an interrupt occurs.\nB. TinyOS Limitations\nA new TinyOS task is normally posted to the scheduler\nfrom within an interrupt and usually processes data that\nwas obtained during the interrupt routine. For example, the\ninterrupt could signal sensor activity or the arrival of a network\npacket; the corresponding task will then process the sensor\nreading or handle the incoming data packet. A new task\nIdle Idle\ntime\nTask\nProcessing\nInterrupt\nProcessing\nT2\nE1 E2 E4E3\nT4T1 T3\nA)\nIdle IdleTask\nProcessing\nInterrupt\nProcessing\nT2\nE1 E2 E4E3\nT4T1 T3\nB)\nIdle IdleTask\nProcessing\nInterrupt\nProcessing\nT2\nE1 E2 E4E3\nT4T1\nT3 C)\nIdle IdleTask\nProcessing\nInterrupt\nProcessing\nT2\nE1 E2 E4E3\nT4T1A T3\nD)\nT1B\nFig. 1. TinyOS task processing options\nis inserted at the end of the FIFO task queue and it is\nexecuted as soon as all other tasks in the queue have been\nprocessed. Fig 1 A shows an example of four events creating\nfour different tasks during interrupt handling to process the\ndata. The problem is that some tasks might be of higher\nimportance than others and it is desirable to schedule them\nbefore all others. For example, it might be desirable to handle\na network packet before processing new sensor information in\norder to assure packet forwarding deadlines. This limitation of\nthe FIFO task scheduling in TinyOS 1.0 was recognized and\nthus the new version TinyOS 2.x offers the option to alter the\ntask scheduler which allows us to prioritize specific tasks. For\nexample, as shown in Fig 1 B, task T3 can be queued before\nT2 to prioritize processing of the third event. Our TinyOS\nmodification presented in the next section will make use of\nthis feature introduced in TinyOS 2.x.\nThe possibility of re-ordering tasks improves the event-\nhandling capabilities of the operating system. However, a\nsevere limitation of the system still exists. If a task is currently\nexecuting, a new task created during an interrupt will be\nexecuted after the current task finishes processing. The time\nat which this new task will be scheduled cannot be controlled\nin TinyOS 2.x as it is impossible to preempt the currently\nrunning task. In the example Fig 1 B, task T3 is prioritized\nbut still has to wait for T1 to finish before it is executed. Some\ntasks can have a long processing duration which will defer the\nexecution of an important task for an unacceptably long period\nof time1.\nCurrently, this limitation can be addressed in two different\nways. One option is to move task processing functionality in\nthe interrupt processing routine (see Fig 1 C). The currently\nrunning task is preempted and high priority processing is\nperformed in the interrupt context. This solution is not optimal\nas interrupts are disabled in TinyOS while executing an\n1The complexity of a sensing operation depends on the phenomenon\nmonitored, the sensor device used and the data pre-processing required. If,\nfor example, an ATMEGA128 CPU with a processing speed of 4Mhz is\nconsidered (a currently popular choice for sensor nodes) in conjunction with\na camera, image processing might take some time before a decision is made.\nDepending on camera resolution and image processing performed, a sensing\ntask can easily take more than 100ms [7].\n3interrupt. For example, if in Fig 1 C E4 would occur earlier\nduring processing of T3 in the context of E3 the handling of\nE4 would be deferred to the end of T3. If E4 has a higher\npriority than E3, control over execution times will be lost at\nthis point. Another option is to split longer tasks into smaller\nsubtasks. For example, in Fig 1 D task T1 is split in two\nsmaller tasks T1A and T1B. T1A is posted before task T1B and\ntherefore task T3 can be scheduled before T1B. This solution\nis not always optimal, as not all tasks can be split-up easily\ninto several sub-tasks [7]. In addition, the programmer has to\nensure that task-splitting is organized such that all processes\ncan meet their deadlines, which is quite difficult to achieve in\na practical scenario.\nIV. THE TINYOS MODIFICATIONS\nTo mitigate the TinyOS limitations described in the previous\nsection priority scheduling and task preemption is added to the\nTinyOS 2.x operating system.\nA. Priority Scheduling\nTinyOS 2.x facilitates component-based schedulers that can\nbe included in the operating system if required. The first step in\nour TinyOS modification is the development of a new priority\nbased scheduler component to replace the provided standard\nTinyOS 2.x FIFO scheduler. Depending on the performance\nrequirements of the user application, this new Priority Level\nScheduler (PL scheduler) can be wired into the application to\nfacilitate greater control over which tasks are processed first.\nThe PL scheduler provides five different priority levels:\n\u2022 (P1) High Priority Preemptive\n\u2022 (P2) High Priority Non-Preemptive\n\u2022 (P3) Basic Priority (Used for standard TinyOS tasks)\n\u2022 (P4) Low Priority Non-Preemptive\n\u2022 (P5) Low Priority Preemptive\nIn each level, tasks are scheduled in a FIFO manner. The\nbasic priority level must always be supported as all standard\nTinyOS tasks are queued here by default. The adjacent priority\nlevels provide a non preemptive higher and lower priority\nqueue. Thus, tasks in either of these queues will be scheduled\naccording to their priority but will not preempt any actively\nrunning task resulting in a behavior as shown in the example\nFig 1 B. The high priority preemptive task and the low priority\npreemptive task queues can be used to schedule preemptive\ntasks. A high priority preemptive task will preempt any run-\nning task from the lower priority task levels and any task from\nthese levels can preempt a running low priority preemptive\ntask. Implementation details of the preemption mechanism are\ndescribed later.\nIn practice not all levels of priority are necessary and as\nsuch allocating a task queue for five different priority levels\ncan create a bloated scheduler. The component architecture of\nTinyOS facilitates counting up the number of tasks at compile\ntime. The PL scheduler can determine exactly how many\nqueues are required and the code elimination features of the\nnesC compiler remove redundant interfaces for task priorities\nnot used. If more than five priority levels are required, the\nPL scheduler can be extended to provide these. However, we\nIdle Idle\ntime\nTask\nProcessing\nContext 2\nInterrupt\nProcessing\nT2\nE1 E2 E4E3\nT4T1\nT3\nA)\nTask\nProcessing\nContext 1\npreempt()\nIdle Idle\nTask\nProcessing\nContext 2\nInterrupt\nProcessing\nT2\nE2 E4E3\nT4T3\nB)\nTask\nProcessing\nContext 1\nIdle Idle\nTask\nProcessing\nContext 2\nInterrupt\nProcessing\nE1 E3\nT1 T3\nC)\nTask\nProcessing\nContext 1\ngrace period t for T3\nFig. 2. Modified TinyOS task processing options\nbelieve that five levels are sufficient to support common sensor\nnetwork scenarios.\nB. Preemption\nTask preemption is facilitated by the PL scheduler for\nsituations in which a cooperative task schedule will not meet\nthe application\u2019s temporal requirements.\n1) Conceptual Idea: Task preemption requires costly con-\ntext switches that have to be supported by the operating\nsystem. These context switches must be implemented care-\nfully to avoid a significant increase in system overhead and\nenergy consumption. Our previous research [3] on optimizing\npreemptive scheduling for the multi-threaded MANTIS system\nhighlighted that it is of paramount importance to reduce the\nnumber of context switches. With this design requirement in\nmind the PL scheduler avoids preemption where possible using\ntwo different principles.\nAs a first principle, a context switch is only performed if\nit is necessary to match processing deadlines. An example of\nthis behavior is illustrated in Fig 2. Task T1 is executing with\nbasic priority P3 and a task T3 with priority P1 (high priority\npreemptive) is scheduled at the end of the interrupt routine\nE3. A context switch is now necessary to process the high\npriority task T3. Thereafter, the context is switched back and\nthe original task T1 executes to completion (see Fig 2 A).\nIf the same high priority task T3 is scheduled in a scenario\nwhere the system is idle (see example Fig 2 B), no context\nswitch is performed and the task executes immediately. In this\ncase the high priority task T3 will be executed in the standard\ncontext. In other words, a context switch is not associated with\nthe priority level of a task, it is associated with the need for\npreemption. This mechanism reduces the number of context\nswitches compared to existing preemption techniques in multi-\nthreaded systems where the execution of a higher prioritized\nthread is normally bound to a context switch (for example,\n[5]).\n4Algorithm 1 Priority Task Structure\n1: Module SomeComponentC{\n2: uses interface PriorityTask<HighPreempt>;\n3: }\n4: Implementation{\n5: event void someEvent(){\n6: call PriorityTask.postTask()\n7: }\n8:\n9: event PriorityTask.runTask(){\n10: \/\/task code\n11: }\n12: }\n13: Configuration SomeComponent{\n14: }\n15: implementation{\n16: components new PriorityTask() as PremptingTask;\n17: components SomeComponentC, .....\n18: SomeComponetC.PriorityTask->PremptingTask;....\n19: }\nAs a second principle to reduce context switches, a grace\nperiod t for preemption is used. It is assumed that many high\npriority tasks need to be executed within a specific time frame\nbut not necessarily immediately. A timer is used to mark the\nlatest possible point in time when the task must be executed to\nmatch deadlines. If currently running lower prioritized tasks\ncomplete before the grace period t, all tasks can be executed\nwithout preemption. Such a scheduling situation is depicted in\nFig 2 C. Task T1 is executing with basic priority P3 and a task\nT3 with priority P1 (high priority preemptive) is scheduled at\nthe end of the interrupt routine E3. Task T3 has a grace period\nof t and thus, preemption is not necessary to schedule the high\npriority task in time.\nThe PL scheduler requires memory for three separate stacks\nto store the processing state of the three preemptive task\npriority levels (P1, P3, P5). As there are only three preemptive\npriorities only three stacks need to be allocated. The number\nof required stacks is dependent on the number of preemptive\npriority levels and not on the number of tasks used. Due to the\nfixed number of stacks used, a calculation of required stack\nsizes is simplified. In practice, the bulk of all tasks will be run\nin the same stack as regular TinyOS tasks are defaulted to the\nbasic priority level P3.\n2) Implementation Specifics: A component specifies a pri-\nority task by wiring a priority task interface to the PL scheduler\ncomponent and by implementing the interface event runTask().\nThis procedure conforms to the TinyOS Enhancement Pro-\nposal (TEP) 106 on tasks and schedulers.\nAn example of an implemented priority task can be seen\nin Alg. 1. For a component to use a priority task it must\nimplement the PriorityTask interface and specify the task\npriority as one of the interface parameters (Alg. 1, line 2). The\ninterface provides a postTask command which is the same as\nthe basic task syntax post [task name] (Alg. 1, line 6) and\nthe runTask event handler which stores the task functionality\n(Alg. 1, line 9). The event handler is invoked by the scheduler\nwhen the task is scheduled to be processed.\nEach task must then be wired up to one of the five param-\neterized taskPriority interfaces provided by the PL Scheduler\n(Alg. 2, link 2-6). The wiring process is somewhat simplified\nby the generic PriorityTask component (Alg. 1, line 16), which\nAlgorithm 2 Priority Scheduler Structure\n1: Module PLScheduler{\n2: provides interface TaskPriority<HighPreempt>[id];\n3: provides interface TaskPriority<HighNonPreempt>[id];\n4: provides interface TaskBasic[id];\n5: provides interface TaskPriority<LowNonPreempt>[id];\n6: provides interface TaskPriority<LowPreempt>[id];\n7: }\nuses the interface parameter information to determine the\ntask priority and uniquely wire each task to the appropriate\nscheduler interface.\nThe PL scheduler, is an extension of the TinyOS 2.x FIFO\nscheduler. Depending on the number of task priorities of\nthe operating system, up to five different task queues are\ninitialized. A bit field is initialized to keep track of which\ntask priorities are either preempted or actively processing. On\nreceiving a posted task the scheduler first ensures that the task\nhas not already been posted (TinyOS TEP 106 requirement).\nSecond, the scheduler checks if the task will be delayed by a\nlower priority task actively running. If preemption is required,\nthe scheduler will perform a context switch or set a grace\nperiod timer to delay the context switch. The grace period\ntime t is a fixed global value for all tasks in the current\nimplementation.\nThe context switch requires that the current registers are\nsaved to the current stack and the stack pointer register is then\ndirected to the next stack context containing the preempted\nqueue scheduler. The preempted queue scheduler executes all\ntasks sequentially starting from the highest priority task down\nas far as the priority of the preempted task. The scheduler can\ntherefore process multiple high priority tasks waiting on the\npreempted task to finish requiring only 2 context switches to\nexecute a set of high priority tasks. When there are no more\ntasks enqueued waiting on the preempted task, the context is\nswitched back to the preempted task context and the preempted\ntask can finish executing.\nThe stack size of the required stacks is currently specified\nand allocated at compile time. To obtain a good estimate of\nthe required stack size, a tool as proposed in [6] can be used.\nUnlike preemptive multi-threaded systems such as [5], [6]\nthread blocking procedures are not necessary. The PL sched-\nuler schedules and executes all tasks according to the event-\nbased architecture.\nC. Race Conditions\nThe PL scheduler adheres to all the finalized TinyOS 2.x\nTEP specifications on TinyOS tasks and schedulers with one\nexception: tasks are not guaranteed to execute in a sequential\nmanner. Only tasks within the same priority are guaranteed\nto execute sequentially. A higher priority task can preempt\na lower priority task and modify shared memory creating a\nrace condition. Currently, the TinyOS nesC compiler is not\ndesigned to detect such race conditions. Thus, the programmer\nmust be aware of these additional programming complications\nintroduced in using a preemptive scheduler.\nIn TinyOS, the defacto method to prevent race conditions\nis to enclose the race condition sensitive code in an atomic\n5statement. The atomic statement prevents race conditions by\ndisabling hardware interrupts, which are the only events that\ncan cause race conditions in the TinyOS concurrency model.\nHowever, in the modified TinyOS, race conditions can also\noccur when a task preemption occurs. To ensure that the\natomicity of atomic sections is preserved, the PL Scheduler\nchecks that the active task is not executing atomic code before\npreempting.\nV. EVALUATION OF THE MODIFIED TINYOS\nThe usability of the TinyOS modifications to extend exist-\ning application code to provide preemption is evaluated. In\naddition, the modified TinyOS is compared with the existing\nsolutions TinyMOS [5] described in the related work section.\nA. Usability Evaluation\nTmote Sky nodes with a cc2420 zigbee radio transceiver\nare used for the evaluation. To test the TinyOS modification\na slightly modified version of the well known TinyOS 2.x\nRadioCountToLeds application is used. The application period-\nically broadcasts a 3 bit message to other nodes every tblink =\n250ms and displays any received messages by toggling the\nLEDs. The RadioCountToLeds application uses the standard\nTinyOS communications stack to send and receive messages.\nAfter receiving a message, the cc2420 radio stack posts a task\nreceiveDone_task() to signal to higher level components that\na message has been received. In addition, a timer is used to\npost a computationally expensive task every tcomp = 1000ms.\nThis task requires 100ms to finish on the Tmote Sky node.\nThis computational expensive task is not part of the standard\nRadioCountToLeds application and is used to visualize the\nadvantage of preemption features.\nStandard TinyOS: In the standard TinyOS system, the\ncomputational expensive task blocks the task posted by the\ncc2420 radio stack that finally processes incoming messages.\nTherefore LEDs are toggled with a delay of 100ms if the\ncomputational expensive task was just scheduled. Delayed\ntoggling of LEDs is obviously not a serious problem but this\ndemonstrates problems in TinyOS driven sensor networks if\nthey are to be used in time critical application scenarios.\nModified TinyOS: In the modified TinyOS system a low\npriority P5 is assigned to the computationally expensive task.\nThis is done by re-wiring this task to the correct priority\nlevel of the PL scheduler. The rest of the application re-\nmains unaltered. Now the computationally expensive task is\npreempted by the cc2420 task posted after receiving a radio\nmessage as standard TinyOS tasks run in priority level P3. The\nLEDs now toggle state as in the original RadioCountToLeds\napplication; the computationally expensive task is executing\nin the background. Only a minimal application modification\nis necessary to achieve the desired application behavior.\nB. Comparative Evaluation\nThe previously described RadioCountToLeds application\nversion was implemented using the TinyMOS concept. In\nthe TinyMOS variation the computationally expensive task is\nimplemented as a MANTIS thread running at a lower priority\nthan the thread carrying the TinyOS system. Thus, the resulting\napplication has the same behavior as the system using the\nmodified TinyOS with PL scheduler.\nHowever, both solutions differ in important aspects. First,\nthe computational expensive task has to be implemented using\nMANTIS semantics. A programmer has to be familiar with\nboth TinyOS and MANTIS syntax to develop the application.\nA seamless integration of preemption features in TinyOS is\nnot achieved. Second, the TinyMOS solution has a signifi-\ncantly higher processing overhead as more context switches\nthan in the presented PL scheduler solution are required.\nThis additional overhead translates to an increase in energy\nconsumption as less idle-time is available for sleep periods.\nHowever, as shown in [3] this processing overhead can be\nreduced to acceptable levels. Third, the TinyMOS solution\nhas a larger memory footprint. Adding the TinyMOS solution\nto the modified RadioCountToLeds application increases the\ncode size by 10926 byte, the RAM size by 267 byte. Adding\nthe PL scheduler solution to the modified RadioCountToLeds\napplication, increases the code size by 864 byte and the RAM\nsize by 30 byte. Space necessary for stacks is not included\nhere for either solution. The, presented TinyOS modification\nhas a significantly smaller memory requirement than TinyMOS\n(92% less code size increase, 89% less RAM size increase).\nVI. CONCLUSION\nAs it is shown in the paper, it is possible to add pre-\nemption to the TinyOS system without introducing overheads\nused in multi-threaded systems. The established event driven\nprocessing concepts can be retained while adding preemption\nthrough context switching. Established TinyOS programming\nconventions can be used which ensures that existing applica-\ntion code can be re-used. Preemption features can be integrated\nseamlessly in existing TinyOS infrastructures.\nREFERENCES\n[1] J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and K. Pister,\n\u201cSystem architecture directions for networked sensors,\u201d in ACM SIGOPS\nOperating Systems Review, vol. 34, pp. 93\u2013104, December 2000.\n[2] H. Abrach, S. Bhatti, J. Carlson, H. Dai, J. Rose, A. Sheth, B. Shucker,\nand R. Han, \u201cMANTIS: System support for multimodal networks of in-\nsitu sensors,\u201d in 2nd ACM International Workshop on Wireless Sensor\nNetworks and Applications, pp. 50\u201359, September 2003.\n[3] C. Duffy, U. Roedig, J. Herbert, and C. J. Sreenan, \u201cImproving the Energy\nEfficiency of the MANTIS Kernel,\u201d in Proceedings of the 4th IEEE\nEuropean Workshop on Wireless Sensor Networks (EWSN2007), Delft,\nNetherlands, Jan. 2007.\n[4] J. Regehr, A. Reid, K. Webb, M. Parker, and J. Lepreau, \u201cEvolving real-\ntime systems using hierarchical scheduling and concurrency analysis,\u201d\nin 24th IEEE Internation Real-Time Systems Symposium, pp. 25\u201336,\nDecember 2003.\n[5] E. Trumpler and R. Han., \u201cA systematic framework for evolving TinyOS,\u201d\nin IEEE Workshop on Embedded Networked Sensors, pp. 61\u201365, May\n2006.\n[6] W. P. McCartney and N. Sridhar, \u201cAbstractions for safe concurrent\nprogramming in networked embedded systems,\u201d in Proceedings of the 4th\ninternational conference on Embedded networked sensor system, pp. 167\n\u2013 180, October 2006.\n[7] M. Rahimi, R. Baer, O. I. Iroezi, J. C. Garcia, J. Warrior, D. Estrin,\nand M. Srivastava., \u201cCyclops: In situ image sensing and interpretation in\nwireless sensor networks,\u201d in In proc. 3rd international conference on\nEmbedded Networked Sensor Systems,, pp. 192\u2013204, November 2005.\n"}