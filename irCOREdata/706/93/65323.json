{"doi":"10.1109\/ICECCS.2007.27","coreId":"65323","oai":"oai:dro.dur.ac.uk.OAI2:6222","identifiers":["oai:dro.dur.ac.uk.OAI2:6222","10.1109\/ICECCS.2007.27"],"title":"Linking Object-Z with Spec#.","authors":["Qin, S.","He, G."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-07-01","abstract":"Formal specifications have been a focus of software engineering research for many years and have been applied in a wide variety of settings. Their use in software engineering not only promotes high-level verification via theorem proving or model checking, but also inspires the \"correct-by- construction\" approach to software development via formal refinement. Although this correct-by-construction method proves to work well for small software systems, it is still a Utopia in the development of large and complex software systems. This paper moves one step forward in this direction by designing and implementing a sound linkage between the high level specification language Object-Z and the object-oriented specification language Spec#. Such a linkage would allow system requirements to be specified in a high-level formal language but validated and used in program language level. This linking process can be readily integrated with an automated program refinement procedure to achieve correctness-by-construction. In case no such procedures are applicable, the obtained contract- based specification can guide programmers to manually generate program code, which can then be verified against the obtained specification using any available program verifiers","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65323.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6222\/1\/6222.pdf","pdfHashValue":"3b95ef5b3ee6a92fc9e318aa45999b1fb3bd59da","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6222<\/identifier><datestamp>\n      2010-11-08T10:50:06Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Linking Object-Z with Spec#.<\/dc:title><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        He, G.<\/dc:creator><dc:description>\n        Formal specifications have been a focus of software engineering research for many years and have been applied in a wide variety of settings. Their use in software engineering not only promotes high-level verification via theorem proving or model checking, but also inspires the \"correct-by- construction\" approach to software development via formal refinement. Although this correct-by-construction method proves to work well for small software systems, it is still a Utopia in the development of large and complex software systems. This paper moves one step forward in this direction by designing and implementing a sound linkage between the high level specification language Object-Z and the object-oriented specification language Spec#. Such a linkage would allow system requirements to be specified in a high-level formal language but validated and used in program language level. This linking process can be readily integrated with an automated program refinement procedure to achieve correctness-by-construction. In case no such procedures are applicable, the obtained contract- based specification can guide programmers to manually generate program code, which can then be verified against the obtained specification using any available program verifiers. <\/dc:description><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        (2007). 12th IEEE International Conference on Engineering of Complex Computer Systems, 11-14 Jul 2007, Auckland, New Zealand ; proceedings. Los Alamitos, CA: IEEE, pp. 185-196<\/dc:source><dc:date>\n        2007-07-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6222<\/dc:identifier><dc:identifier>\n        doi:10.1109\/ICECCS.2007.27<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6222\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/ICECCS.2007.27<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6222\/1\/6222.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2007 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2007,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n08 November 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nQin, S. and He, G. (2007) \u2019Linking Object-Z with Spec.\u2019, in 12th IEEE International Conference on\nEngineering of Complex Computer Systems, 11-14 Jul 2007, Auckland, New Zealand ; proceedings. Los\nAlamitos, CA: IEEE, pp. 185-196.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/ICECCS.2007.27\nPublisher\u2019s copyright statement:\n2007 IEEE. Personal use of this material is permitted. However, permission to reprint\/republish this material for\nadvertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists,\nor to reuse any copyrighted component of this work in other works must be obtained from the IEEE.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nLinking Object-Z with Spec#\nShengchao Qin and Guanhua He\nDepartment of Computer Science, Durham University\n{shengchao.qin, guanhua.he}@durham.ac.uk\nAbstract\nFormal specifications have been a focus of software en-\ngineering research for many years and have been applied in\na wide variety of settings. Their use in software engineering\nnot only promotes high-level verification via theorem prov-\ning or model checking, but also inspires the \u201ccorrect-by-\nconstruction\u201d approach to software development via formal\nrefinement. Although this correct-by-construction method\nproves to work well for small software systems, it is still a\nutopia in the development of large and complex software\nsystems. This paper moves one step forward in this direc-\ntion by designing and implementing a sound linkage be-\ntween the high level specification language Object-Z and\nthe object-oriented specification language Spec#. Such a\nlinkage would allow system requirements to be specified\nin a high-level formal language but validated and used\nin program language level. This linking process can be\nreadily integrated with an automated program refinement\nprocedure to achieve correctness-by-construction. In case\nno such procedures are applicable, the obtained contract-\nbased specification can guide programmers to manually\ngenerate program code, which can then be verified against\nthe obtained specification using any available program ver-\nifiers.\nKeywords Formal specification, Object-Z, Spec#, verifi-\ncation, pre\/post conditions.\n1 Introduction\nSoftware correctness has become one major concern in\nsoftware development [22]. Formal methods are expected to\nplay a significant role in ensuring this. On one side, formal\nmethods are adopted to help with existing software prod-\nucts. For instance, formal analysis\/verification techniques\nare used to prove\/check that existing programs meet certain\ndesired properties (or to find counterexamples otherwise).\nOn the other hand, formal methods are also expected to ful-\nfill the so-called correct-by-construction approach to soft-\nware development [29, 1]. This utopia suggests us to make\nuse of a high level formal specification language to specify\nsystem requirement and then construct an executable pro-\ngram via a correctness-provable refinement procedure. Al-\nthough this approach proves to work well for small exam-\nples, it seems still a long way to go before we can make use\nof it to help automate the development of complex software\nsystems.\nA realistic solution would be to adopt the correct-by-\nconstruction approach in part in the current software de-\nvelopment process. If the entire system can be developed\nsolely via the correct-by-construction approach, then it is\ndone. If certain stages (or certain components) can be de-\nrived via the correct-by-construction approach (while others\ncannot), developers only have to deal with the remaining\nstages (or components). Afterwards we can employ appro-\npriate formal verification tools to ensure the correctness of\nthe remaining part and thus that of the whole system. Con-\nceived by this general idea, we propose in this paper a de-\nvelopment frameworkwhich supports the automatic transla-\ntion from high level specifications to program-level specifi-\ncations. In the subsequent implementation stage, the frame-\nwork would offer a choice for the developers, which, for\nexample, can be a pure correct-by-construction approach\n(refinement), or an approach based on manual coding, or a\ncombination of these two. For programmer-generated code,\nappropriate verification tools are then employed to check\nthat the implementation does fulfill the specification.\nTo set the scene, let us make the framework more con-\ncrete by fixing the high-level and the low-level specification\nlanguages. A well-known rigorous high level language is\nthe model-based language Z [34]. To allow object-oriented\ndesign to be introduced as early as possible, we would\nchoose Object-Z [33] as our high level specification lan-\nguage. We then choose the Spec# as the low-level speci-\nfication language. As an extension to the new but popular\n.Net C# language, Spec# aims at a more cost-effective way\nto develop and maintain high-quality software [4]. To the\nbest of our knowledge, there is no link between Object-Z\nand Spec# available yet. Moreover, given the large amount\nof research effort involved in the Spec# project, we believe\nsoon there will be very good tool support for specifications\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nwritten in Spec#. At the current stage, the Boogie static\nprogram verifier [3] can be used to check the consistency\nbetween the implemented program and its specification.\nThe main contribution of this paper is an automatedmap-\nping from high-level Object-Z specifications to program-\nlevel Spec# specifications which forms the first stage of\nthe above-advocated formal development framework. In\nthe subsequent implementation stage, our framework allows\nany new or existing formal refinement algorithm to be opted\nin. In case that such correct-by-construction algorithms are\nnot available and manual implementation has to be adopted,\nthe framework would allow the developers to invoke appro-\npriate verification tools (e.g. Boogie) to formally verify the\nmanually generated code.\nThe remainder of the paper is organised as follows. Sec 2\nbriefly introduces both the Object-Z and Spec# specification\nlanguages. Sec 3 presents the structural mapping algorithm\nfrom Object-Z to Spec#. Sec 4 is devoted to the tool devel-\nopment. Related work is presented in Sec 5. Conclusion\nand future work follow afterwards.\n2 A Brief Overview of Object-Z and Spec#\nIn this section, we give a preliminary introduction to\nboth the high level specification language Object-Z and the\nprogram-level specification language Spec#.\n2.1 The Object-Z Language\nObject-Z [33] is an object-oriented extension of the\nmodel-based specification language Z. An object-oriented\nspecification describes a system as a collection of interact-\ning objects, each of which has a pre-described structure\nand behaviour [14]. The object-oriented approach to cre-\nating a system is currently the popular approach as it is ar-\nguable truer to the real world and therefore easier to un-\nderstand than procedural and functional programming lan-\nguages. This extension to Z eases the integration of speci-\nfication with other common software engineering methods\nsuch as UML, as exemplified in e.g. [23, 27]. The modu-\nlarity that Object-Z introduces does improve the clarity of a\nspecification.\nThe key feature of Object-Z, as always with the object-\noriented approach, is its focus on classes. They are rep-\nresented by use of class schemas, an example of which is\nshown in Figure 1 (taken from [13]). The example includes\nmany of the basic Object-Z features. The first line of the\nclass schema forms a visibility list: a list of all the opera-\ntion specifications and variables that are visible to outside of\nthe class. If no visibility list is present then all variables and\noperations are visible by default. Axiomatic definitions are\nused when a variable to be known throughout a specifica-\ntion, i.e. a global variable, is to be declared along with some\nconstraints on the variable in the form of predicates, an ex-\nample of which is the definition of the variable limit. A\npredicate can consist of any first-order logic or standard set\ntheory expression. Therefore, the= symbol indicates equal-\nity rather than assignment. A state schema uses its declara-\ntions to introduce variables and its predicates to introduce\nobject invariants, as shown in the anonymous schema in-\ntroducing variable balance. If the predicates that make up\nthe initial schema, INIT, and all the object invariants hold\nthen the model is said to be in its initial configuration. The\nremaining schemas within the class schema in the example\nare all operational schemas. Operational schemas consist of\ndeclarations to introduce required variables, e.g. amount?\nin the withdraw operation, and predicates defining a method\ncontract, e.g. the two predicates given in withdraw opera-\ntion. If the method contract results in a change in a primary\nvariable\u2019s value then that variable must be included in the\noperational schema\u2019s delta list, and the primary variable\u2019s\nname within the predicate must end with the \u2032(primed) sym-\nbol, e.g. balance\u2032. Other naming conventions within oper-\national schemas are that a variable name ending in the ?\nsymbol, e.g. amount?, indicates an input variable, while a\nvariable name ending in the ! symbol, e.g. funds!, indicates\nan output variable. The expression used to define the with-\ndrawConfirm operation is a composite operation. This is an\noperation defined in terms of a combination of other oper-\nations that can be combined in several different ways. For\ndetails of the different combination methods and further de-\ntails of more advanced features of Object-Z specifications,\nsuch as inheritance, object containment and polymorphism,\nsee [33, 13].\n2.2 The Spec# Language\nSpec# [4] is an extension of Microsoft\u2019s .NET frame-\nwork programming language C#, and the development en-\nvironment currently offering support for the Spec# pro-\ngramming system is Microsoft Visual Studio. Spec# is a\nprogramming system incorporating specification concepts,\nrather than a formal specification language. Features the\nSpec# system has introduced into C# include object invari-\nants [2], non-null types [16], and method contracts. Object\ninvariants are \u201cspecifications that constrain the value space\nof the implementation\u2019s data\u201d [4], i.e. conditions that must\nalways hold on all objects of that class, and are declared\nwith the invariant keyword. In some cases it is possible that\na series of statements in a methodwill break an invariant. To\nbe able to handle such a situation, Spec# has introduced the\nblock statement identified by the expose keyword. Within\nan expose statement invariants can be broken, as long as all\ninvariants hold again by the end of the statement. The con-\ncept of non-null types allows programmers to discriminate\nbetween expressions that may evaluate to null and those that\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nCreditCard\n\u0002 (limit, balance; INIT,withdraw, deposit,withdrawAvail,withdrawConfirm)\nlimit : N\nlimit \u2208 {1000, 2000, 5000}\nbalance : Z\nbalance + limit \u2265 0\nINIT\nbalance = 0\nwithdraw\n\u0394(balance)\namount? : N\namount? \u2264 balance + limit\nbalance\u2032 = balance\u2212 amount?\nwithdrawAvail\n\u0394(balance)\namount! : N\namount! = balance + limit\nbalance\u2032 = \u2212limit\ndeposit\n\u0394(balance)\namount? : N\nbalance\u2032 = balance + amount?\nfundsAvail\nfunds! : N\nfunds! = balance + limit\nwithdrawConfirm =\u0302 withdraw o9 fundsAvail\nFigure 1. The CreditCard Class in Object-Z\nare sure not to [4].\nMethod contracts consist of a series of conditions known\nas pre-conditions, post-conditions and frame conditions.\nPre-conditions, preceded by the requires keyword, define\nthe state in which the system must be to be able to call\nthe method, while post-conditions, preceded by the ensures\nkeyword, describe the state in which the method is allowed\nto return. Frame conditions restrict which pieces of the pro-\ngram state a method implementation is allowed to modify\nand are preceded by the modifies keyword. A full intro-\nduction of features of the Spec# programming system and\nresulting complexities are detailed in [4].\nIn addition to extending the C# programming language,\nSpec# also introduces the Boogie verification tool. Boogie\noperates by verifying the object code rather than the source\ncode, thereby allowing code written in languages other than\nSpec# to be verified. It can perform both static verifica-\ntion and run-time checks. Static verification is where Boo-\ngie uses automated theorem proving to verify a source pro-\ngram. For example, Boogie can verify methods according\nto specified post-conditions and can ascertain whether the\npost-conditions are required or not, i.e. if the verification\nis successful then the run-time checks are excessive since\nthey would never fail. The run-time checks are performed\non any pre- or post-conditions, which are turned into inline\ncode that is identifiable as method contract, to ensure that\nthey hold.\n3 The Mapping from Object-Z to Spec#\nThis section is devoted to the mapping process from\nObject-Z to Spec#. We will present the formal mapping via\na few definitions and then state the soundness properties.\nTo present the design of the mapping, we shall focus on a\ncore subset of Object-Z specification language. The abstract\nsyntax of this core subset is given in Figure 2. The actual\nconcrete syntax that we have implemented subsumes this\nabstract syntax.\nNote that an Object-Z specification is formed by a se-\nquence of class declarations. A class declaration includes a\nvisibility list, an (optional) superclass, some (optional) ax-\niomatic (local) definitions, a state schema, an initial schema,\nand some state operations. An example of a class declara-\ntion is given earlier in Figure 1.\nOne significant incompatibility between Object-Z and\nSpec# is that Object-Z supports multiple inheritance while\nSpec# does not. To simplify the design, we constrain the\nsubset of Object-Z to adopt only single inheritance. This\nsimplification was also adopted by [18, 28].\nThe translation from Object-Z to Spec# is conducted in a\nstructural manner, i.e., every class declaration in an Object-\nZ specification is mapped to a class definition in the corre-\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nOZSpecification ::= CDecl\u2217\nCDecl ::=\u0002 VisibList; InheritC; Local\u2217; State; INIT; Op\u2217\nVisibList ::= VisibAttr; VisibOp\nVisibAttr ::= AttrName\u2217\nVisibOp ::= OpName\u2217\nInheritC ::= Inherits CName\nLocal ::= VarDecl\u2217 [\u2022 Predicate]\nState ::= VarDecl\u2217 [\u0394 VarDecl\u2217] [\u2022 Predicate]\nVarDecl ::= v : T\nOp ::= OpName :: OpExp | v.OpName\n| [v.]OpName o9 [v.]OpName\n| [v.]OpName \u2227 [v.]OpName\n| [v.]OpName [] [v.]OpName\n| [v.]OpName \u2016 [v.]OpName\nOpExp ::= \u0394(AttrName\u2217),VarDecl\u2217 \u2022 Predicate\nFigure 2. The Syntax of Object-Z\nsponding Spec# program. We present this structural map-\nping L in the following definitions:\nDefinition 1 (The Structural Mapping L: Spec) For a\ngiven Object-Z specification\nozs =\u0302 OZC1; . . . ; OZCn\nthe mapping algorithmL generates in Spec# a specification\nsss = L(ozs) = SSC1; . . . ; SSCn\nwhere each Object-Z class declaration OZCi is mapped to\na Spec# class SSCi, i.e., L(OZCi) = SSCi, for i = 1, .., n.\n(See Definition 2.) \u0002\nDefinition 2 (The Structural Mapping L: Class) For a\ngiven Object-Z class\nOZC =\u0302\u0002vl; inherits \u0302OZC; ldef; state; init; opmj=1\nwhere predicate(ldef) = pred1, and predicate(state) =\npred2, predicate(init) = pred3, 1 the mapping algorithm\nL generates the corresponding Spec# class declaration\nSSC = L(OZC) using the following rules:\n1. SSC has L(\u0302OZC) as its immediate superclass.\n2. All variables declared in ldef and state become in-\nstance variables newly declared in SSC. Constants de-\nclared in ldef become constants newly declared in SSC.\n3. SSC has pred1 \u2227 pred2 as its object invariant. That is,\nthe clause\ninvariant pred1 \u2227 pred2;\nappears in SSC (following the instance variables).\n1The function predicate(...) is to extract the predicate out of a local\naxiomatic definition, a state schema or an initial schema.\n4. A default constructor method (contract) is generated\nwith pred3 as its postcondition. 2\n5. For j = 1, ..,m, the operation opj is mapped to an in-\nstance method methj = L(OZC.opj) of the class SSC.\n(See Definition 3.)\n6. If the visibility list vl is empty, all instance variables\nand operations are made public. Otherwise, only those\nmentioned in vl are made public while others are made\nprivate. \u0002\nDefinition 3 (The Structural Mapping L: Operations)\nEach operation op from an Object-Z class OZC is mapped\nto a method meth = L(OZC.op) (with an empty method\nbody) in the corresponding Spec# class L(OZC) according\nto the following rules:\n1. Case (basic) op =\u0302 mn :: \u0394(r), u?:S, v!:T \u2022 Pred.\nSuppose sa denotes the set of secondary variables de-\nclared in class OZC. The method L(OZC.op) gener-\nated by the mapping algorithm will be\nvoid mn (S u, out T v) requires pre; ensures post;\nmodifies r \u222a sa {}3\nNote that the conditions pre and post are generated\nfrom Pred in a way similar to what Diller used in [11]:\npre =\u0302 \u2203 a\u2032, v! \u00b7 Pred[u\/u?][this.a\/a]\npost =\u0302 Pred[old(this.a)\/a][this.a\/a\u2032][v\/v!]\nWhere a denote all state variables that may be changed\nby op, which include the primary variables r and\nall secondary variables declared in the current class.\nNote also that, due to different notations required in\nthe source and target languages, we rename every a to\nold(this.a) and then every a\u2032 to this.a for the postcon-\ndition. 4 We also eliminate the ? (resp. !) associated\nwith all input (resp. output) variables as Spec# does\nnot use it.\n2. Case (o9) op =\u0302 op1 o9 op2. Suppose\nL(OZC.op1) =\u0302 void mn1(T1 u, out T2 v)\nrequires pre1; ensures post1; modifies r1 {}\nL(OZC.op2) =\u0302 void mn2(T2 v, out T3 w)\nrequires pre2; ensures post2; modifies r2 {}\n2Note that object invariant is not added into the postcondition explicitly\nbut is enforced implicitly in Spec#.\n3This provides one possible solution. An alternative solution we used\nin our prototype implementation is to map one of the output variables, say\nthe first one (if there are more than one), to the result which will be returned\nby the method.\n4Here we attach \u2018this\u2019 to every instance variable to simplify the presen-\ntation in a later case. This is optional in our implementation.\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nThe method generated for op is as follows:\nL(OZC.op) =\u0302 void mn(T1 u, out T3 w)\nrequires pre; ensures post; modifies r\n{T2 v; mn1(u, out v); mn2(v, out w); }\nwhere pre =\u0302 pre1 \u2227 \u2203 v \u00b7 (post1 \u21d2 pre2), and post =\u0302\n\u2203 v\u00b7((post1\u2227no\u03c7(r2\u2212r1))\u25e6(post2\u2227no\u03c7(r1\u2212r2))), and\nr =\u0302 r1 \u222a r2. The predicate no\u03c7(V) indicates that all\nvariables in V remain unchanged. It is defined as fol-\nlows:\nno\u03c7({}) =\u0302 true\nno\u03c7({v}\u222aV) =\u0302 (v=old(v)) \u2227 no\u03c7(V)\nThis auxiliary predicate is vital here for the generation\nof the correct postcondition for the composite opera-\ntion, as the modifies frame for the composite operation\ncan be larger than that of its constituent operations.\nGiven two predicates P1(old(v), v) and P2(old(v), v),\nthe sequential composition of them is defined as fol-\nlows (as in [21]):\nP1 \u25e6 P2 =\u0302 \u2203 v0 \u00b7 P1(old(v), v0) \u2227 P2(v0, v)\n3. Case (\u2227) op =\u0302 op1 \u2227 op2. Suppose\nL(OZC.op1) =\u0302 void mn1(Ti1 u1, out To1 v1)\nrequires pre1; ensures post1; modifies r1 {}\nL(OZC.op2) =\u0302 void mn2(Ti2 u2, out To2 v2)\nrequires pre2; ensures post2; modifies r2 {}\nFor simplicity, let us assume the parameter lists are\ndisjoint, i.e., {u1, v1} \u2229 {u2, v2} = \u2205. Let {Ti u} de-\nnote {Ti1 u1} \u222a {Ti2 u2}, and {To v} denote {To1 v1} \u222a\n{To2 v2}. The method generated for op is as follows:\nL(OZC.op) =\u0302 void mn(Ti u, out To v)\nrequires pre; ensures post; modifies r {}\nwhere r =\u0302 r1 \u222a r2, pre =\u0302 pre1 \u2227 pre2, and post =\u0302\npost1 \u2227 post2.\n4. Case ([]) op =\u0302 op1[]op2. Suppose\nL(OZC.op1) =\u0302 void mn1(Ti u, out To v)\nrequires pre1; ensures post1; modifies r1 {}\nL(OZC.op2) =\u0302 void mn2(Ti u, out To v)\nrequires pre2; ensures post2; modifies r2 {}\nNote that it is required that both constituent methods\nhave the same set of parameters. The method gener-\nated for op is as follows:\nL(OZC.op) =\u0302 void mn(Ti u, out To v)\nrequires pre; ensures post; modifies r {}\nwhere r =\u0302 r1 \u222a r2, pre =\u0302 pre1 \u2228 pre2, and post =\u0302\nold(pre1)\u2227 post1 \u2228 old(pre2)\u2227 post2. The postcondi-\ntion states that if a particular branch is chosen for ac-\ntual execution, then the corresponding postcondition\nshould be guaranteed in the post-state.\n5. Case (\u2016) op =\u0302 op1 \u2016 op2. Suppose\nL(OZC.op1) =\u0302\nvoid mn1(T1 u1, S1 w1, out S2 w2, out T3 v1)\nrequires pre1; ensures post1; modifies r1 {}\nL(OZC.op2) =\u0302\nvoid mn2(T2 u2, S2 w2, out S1 w1, out T4 v2)\nrequires pre2; ensures post2; modifies r2 {}\nAccording to the semantic definition of parallel com-\nposition in Object-Z, the parallel composition will\nidentify some input variables from either operation\nto be equated with some output variables (with same\nbasenames) in another operation. In the above, the in-\nput variables w1 out of L(op1) will be equated with\nthe output variables w1 in L(op2) and be hidden from\nthe final result. Similar for the variables w2. Thus, the\nmethod generated for op is as follows:\nL(OZC.op) =\u0302\nvoid mn(T1 u1, T2 u2, out T3 v1, out T4 v2)\nrequires pre; ensures post; modifies r {}\nwhere pre =\u0302 \u2203w1,w2 \u00b7 pre1 \u2227 pre2, post =\u0302 \u2203w1,w2 \u00b7\npost1 \u2227 post2, and r =\u0302 r1 \u222a r2.\n6. Case (Aggregation) op =\u0302 x.op1. Suppose x :: \u2193X,\nand\nL(X.op1) =\u0302 void mn(T1 u, out T2 v)\nrequires pre1; ensures post1; modifies r1 {}\nThe method generated for op is as follows:\nL(OZC.op) =\u0302 void mn(T1 u, out T2 v)\nrequires pre; ensures post; modifies r\n{v.op1(u, out v); }\nwhere pre =\u0302 pre1[x\/this], and post =\u0302 post1[x\/this]. If\nthis \u2208 r1 then r = {x} else r = \u2205. 5\nRemark: Object-Z does not impose behavioural sub-\ntyping in inheritance hierarchies; instead, it allows\neven arbitrary redefinition of operations in subclasses.\nThe above mapping rule for aggregation works under\nthe assumption that behavioural subtyping has been\n5The generation of frame conditions can be very tricky. In Spec#, an\nownership based method is proposed to deal with frame conditions when\naggregate objects are involved [2] . For simplicity, here we do not take into\naccount the permission to modify fields of aggregate objects.\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nimposed in the inheritance hierarchies in the Object-\nZ specifications.6 This is a proof obligation imposed\non the specifier. For those specifications where behav-\nioural subtyping does not hold, the above rule will not\nwork. However, it is possible to develop a more gen-\neral way to handle this issue (thanks to Graeme Smith)\nbut we will not elaborate it in this paper.\n7. Case (Composition with Aggregation) In case that\na composition is made of aggregate operations, i.e.,\nop =\u0302 x.op1 \u2295 y.op2, where x and y are state variables\nof OZC, and \u2295 is from {o9, [],\u2227, \u2016}. This can be han-\ndled in a way similar to case 2-5 above. The pre\/post\nconditions for the resulting method can be generated\nin the same way as in case 2-5, except that we need\nto rename \u2018this\u2019 in pre\/post of op1 to \u2018x\u2019, and \u2018this\u2019 in\npre\/post of op2 to \u2018y\u2019. We generate the modifies clause\nin a way similar to case 6. \u0002\nNote that the mapping algorithm has not filled in the\nmethod bodies in this stage. They are left to the next de-\nvelopment stage either by formal refinement or by manual\ncoding. It is worth mentioning that in the case (o9) and the\naggregation case, the code for the composite method can be\ngenerated automatically by invoking the constituent meth-\nods, though in the aggregation case, the actual method to\nbe called will be determined dynamically due to polymor-\nphism. In other cases, we have to generate the code for the\ncomposite method directly.\nWe now state the soundness properties of our mapping\nprocess L. We will make use of a refinement relation anal-\nogous to that defined in [19].\nInformally speaking, the Spec# specification generated\nby the mapping process is better than (or at least as good\nas) its source Object-Z specification. To formally state this,\nwe will need to go to the meta level (semantic level). How-\never, in order to focus better on the soundness and keep this\npart short, we will not present the formal semantics for the\nsource\/target languages here. Instead, we assume they are\nalready available for use. Intuitively, the semantics of a\nspecification is the set of programs (i.e. implementations)\nthat satisfy the specification.\nWe will make use of the following definitions in the\nsoundness theorem.\nDefinition 4 We say a Spec# method meth (with contract\n(pre, post)) refines (or implements) an Object-Z operation\nop, denoted as op \u000fcom meth, if every implementation of the\nmethod contract is also an implementation of the operation.\nThat is,\n\u2200 com \u00b7 \u0011 {pre} com {post} \u21d2 \u03c1 com \u2208 [[op[]\n6Suppose class Y inherits class X, and operation op is defined in\nX but redefined in Y . Behavioural subtyping requires the following:\npre(X.op)\u21d2 pre(Y.op), and post(Y.op)\u21d2 post(X.op).\nNote that for simplicity, we assume the (in and out) parame-\nters in meth and the variables declared in op have the same\nset of base names. The mapping \u03c1 is to map every input\nvariable u to u?, and every output variable v to v!. \u0002\nDefinition 5 We say a Spec# class SSC refines (or imple-\nments) an Object-Z class OZC, denoted as OZC \u000fclass SSC,\nif (1) the superclass of SSC refines the superclass of OZC;\n(2) the instance variables defined in SSC are identical to\nthose variables defined in OZC; (3) for every operation op\nin OZC, there is a method meth in SSC such that op \u000fcom\nmeth. \u0002\nDefinition 6 Given an Object-Z specification ozs =\u0302\nOZC1; . . . ; OZCn, and a Spec# specification sss =\nL(ozs) = SSC1; . . . ; SSCn, we say sss refines (or imple-\nments) ozs, denoted as ozs \u000f sss, if OZCi \u000fclass SSCi, for\ni = 1, .., n. \u0002\nThe following theorem states the soundness of the map-\nping algorithm.\nTheorem 1 (Soundness) The mapping algorithm L (de-\nfined in Definition 1,2,3) is sound. That is, for a given\nObject-Z specification ozs and its corresponding Spec#\nspecification sss = L(ozs), we have ozs \u000f sss. \u0002\n4 The Tool Development\nIn this section we discuss the development of the proto-\ntype tool.\n4.1 Overview of the Implementation\nThe graphical representation for Object-Z is good for vi-\nsualisation but does not seem to be a favorable input format\nfor the tool to implement. So we decide to go for a plain-text\nbased representation. Instead of using XML-based repre-\nsentation (e.g. as did in [18]), we take the LATEX representa-\ntion for Object-Z as the input syntax for our system. Thanks\nto the LATEX package for Object-Z [24], we can easily ob-\ntain the graphical representation from the LATEX format.\nWe have chosen the functional language Haskell [31] to\nbe our implementation language as Haskell is a very good\nlanguage for fast prototyping and it has a parser combina-\ntor library, called Parsec [25] which can be used to build\nthe parser very quickly. The implemented tool is composed\nof three components, namely, a parser, a mapper, and a\nprinter, which are built as three Haskell functions, parsing,\nmapping, and printing, respectively. The function parsing\nparses the input Object-Z LATEX file to an Object-Z syntax\ntree, the function mapping transforms the Object-Z syntax\ntree into a Spec# syntax tree, while the function printing is\na pretty printer which converts the Spec# syntax tree to a\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nFigure 3. Oz2Spec#: Linking Object-Z with Spec#\nSpec# program. In a nutshell, the system can be viewed as\na composition of the above three functions:\nOZ2SSp = printing \u25e6 mapping \u25e6 parsing\nWe have also built a graphical user interface (GUI) in\nMicrosoft .Net Framework. A snapshot of the GUI is shown\nin Figure 3.\nIn our system, the parser component parses an Object-\nZ source file into a list of Object-Z class declaration trees,\nwhich are then converted to a list of Spec# class declaration\ntrees by the mapper component. Finally, they are pretty-\nprinted into one source file which is the Spec# program. We\nwill elaborate a bit more on the mapping function.\n4.2 Mapping\nThe mapping function from Object-Z to Spec# forms the\ncore part of our implementation. It takes as a list of Object-\nZ syntax trees and generates as output a list of Spec# syntax\ntrees. As we described in section 3, the mapping function is\nconducted in a structural manner, i.e., it maps an Object-Z\nclass declaration to a corresponding Spec# class declaration\nwhere all the constituents from the source and the target\nhave the similar correspondence.\nThe mapper component mainly consists of the following\nfunctions:\n\u2022 A function predicate is used to extract predicates out of\nlocal definitions, the state schema, or the INIT schema.\nWhile a function variable is to extract variables out of\nlocal definitions and the state schema. The visibility\nproperty ( public or private) for instance variables in\nSpec# classes is decided in accordance with the visi-\nbility list given in the source Object-Z specification.\n\u2022 A function mapConstructor maps the INIT schema to\na Constructor method. It also transfers all the predi-\ncates in INIT to the post-condition for the constructor\nmethod.\n\u2022 A function mapMethods maps Object-Z operations to\nSpec# methods using the algorithm given in section 3.\nOur system maintains the information about class depen-\ndencies (mainly for inheritance and aggregation) as such in-\nformation is required during the mapping. For instance, if\na class B has an instance variable v of type A, where A is\nanother class declared in the specification, then class B de-\npends on class A. In such a scenario an operation of class B\nmay be defined in terms of an operation of class A via the\nvariable v:\nA\nop1\n\u00b7 \u00b7 \u00b7\nB\nv : A\nop2 =\u0302 v.op1\nThe class dependency information is stored in a class ta-\nble in our implementation. During mapping, when an op-\neration refers to another operation in another class, we can\nsearch through the class table to find that class from which\nwe can obtain the required method contracts in order to gen-\nerate the contract for the method in the depending class. As\nmentioned earlier, one way to support polymorphism (e.g.\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nin the above class B, v might be defined as v : \u2193A) is to\nimpose a proof obligation on the specifier such that behav-\nioural subtyping holds in inheritance hierarchies.\nPart of the Spec# specification generated from the Cred-\nitCard example in Figure 1 are shown in Figure 4. Another\nexample is given in the appendix.\npublic class CreditCard\n{\npublic int limit;\npublic int balance;\ninvariant ...;\ninvariant balance + limit >= 0;\npublic CreditCard()\nensures balance == 0;\n{}\npublic void withdraw(int amount)\nrequires amount >= 0;\nrequires amount <= balance + limit;\nensures balance == old(balance) - amount;\nmodifies balance;\n{}\nprivate int fundsAvail()\nensures result == balance + limit;\n{}\npublic int withdrawConfirm(int amount)\nrequires amount >= 0;\nrequires amount <= balance + limit;\nensures balance == old(balance)-amount;\nensures result == old(balance)-amount+limit;\nmodifies balance;\n{}\n...\n}\nFigure 4. Part of the Spec# Code generated\nfor the CreditCard Example\n5 Related Work\nAs an object-oriented extension to the state-based spec-\nification language Z [34], Object-Z [14, 33, 13] has been\na well-studied high level formal specification language. It\nhas also been used in many applications, e.g., the modelling\nof Java concurrency [15], agent modelling [20]. There\nare also limited tool support available for Object-Z, e.g.\n[35]. Object-Z has also been extended to support mod-\nelling of different complex systems, e.g., integrating with\nCSP [32, 17], relating with Pi-calculus [36], blending with\nTimed CSP [26], coupling with Timed Automata [12].\nCompared to Object-Z, Spec# [4] is a rather new speci-\nfication language. It extends also new but already very pop-\nular .Net programming language C# with various specifica-\ntion mechanisms, includingmethod contracts, object invari-\nants [2], assertions, non-null types [16] etc. The Boogie tool\n[3] is proposed to statically verify specifications written in\nSpec#. Apart from static verification, Spec# also has good\nsupport for runtime assertion checking. JML [6] is a similar\nprogram specification language which is based on Java.\nA closely related work is the Object-Z to JML parser by\nGiles [18], where an implementation for a mapping from\nObject-Z to JML is reported. Similar to ours, their mapping\nalso ignores multiple inheritance in Object-Z. While they\nrequire Object-Z input files to be given in XML format and\ngenerate JML programs, we take as input the latex format\nof Object-Z specifications which can be easily compiled to\ngraphical representation. In [18], the design of the mapping\nis presented informally, while in this paper, we give a formal\ndefinition of the mapping algorithm, correctness of which is\nprovable. One feature of Object-Z is that it allows multiple\noutput variables in its operations. This becomes a problem\nin the translation from Object-Z to JML [18], in which they\nhave to use wrapper classes or translate the multiple output\nvariables into a single vector output. However, it is not a\nproblem in our translation from Object-Z to Spec#, thanks\nto the feature that C# (hence Spec#) supports output para-\nmeters which can be used to represent multiple outputs.\nThe work in [28] investigated the linking between CSP-\nOZ and UML\/Java. Their aim is to generate part of the CSP-\nOZ specifications from an initially developed UML model,\nand then transform the CSP-OZ specification to Java, with\nCSP-OZ playing an intermediate role and serving to veri-\nfying correctness of the UML model. Although they have\npresented their approach via a large case study, no gen-\neral transformation algorithm is reported. Cavalcanti and\nSampaio [7] reported another approach to combining CSP-\nOZ with Java, where CSP-OZ specifications are translated\ninto CTJ, an extension of Java with CSP-like processes and\nchannels, using a number of refinement rules.\n6 Conclusion and Future Work\nTo support the correct-by-construction approach in com-\nplex software development, we advocate the use of a for-\nmal framework in which a high-level formal language (e.g.\nObject-Z) is used for requirement specifications, and a\nlower level language (e.g. Spec#) is employed for pro-\ngram specifications; in the implementation stage formal re-\nfinement procedures can be integrated to transform the ob-\ntained (more concrete) program specifications to actual pro-\ngram code. If such provably-correct refinement procedure\nis not applicable or can only be applied in part, the manu-\nally coded part can then be verified by an integrated prover.\nWe have designed in this paper a formal mapping from the\nhigh level language Object-Z to the program-level language\nSpec#, and built a prototype tool to implement the mapping.\nOur future work is to complete the above-mentioned\ndevelopment framework. On one hand, we shall explore\nformal refinement calculi that can be used for the refine-\nment from the concrete program specifications (where only\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\nmethod contracts are available) to the actual implementa-\ntions (where method bodies are filled up). We should try to\nmake use of existing refinement tools if possible, or build\nour own one. On the other hand, we shall look into appro-\npriate program verifiers which can be used to verify the final\nprogram code especially when the method bodies are manu-\nally programmed. A good candidate is the Boogie static ver-\nifier [3] by Microsoft research team. Boogie generates from\na Spec# specification verification conditions (VCs) which\nare discharged by an underlying theorem prover. At the\nmoment, Boogie calls the Simplify theorem prover [10] but\nhopefully they will integrate Boogie with their own prover\nin the near future. Depending on the properties that may be\ninvolved in the system to develop, more advanced provers\nmay be integrated into our framework, e.g. the termination\nprover [5, 9], the shape and size verifiers [8, 30], etc. On the\nother hand, it would be very interesting to investigate how\nto extend our mapping algorithm so that it works for a more\npowerful specification language like TCOZ [26], which can\nbe a challenging future work as well.\nAcknowledgement\nThe work is supported in part by the EPSRC funded\nproject EP\/E021948\/1. We would like to thank the anony-\nmous reviewers for their valuable comments. We thankGra-\nham Odds for a Java-based prototype implementation in his\nfinal year project which raised many interesting issues and\nmotivated us to investigate them more deeply. We are also\ngrateful to Graeme Smith and Jun Sun for helpful discus-\nsion on Object-Z.\nReferences\n[1] R. J. Back, A. Akademi, and J. Von Wright. Refinement\nCalculus: A Systematic Introduction. Springer-Verlag New\nYork, Inc., Secaucus, NJ, USA, 1998.\n[2] M. Barnet, R. DeLine, M. Fahndrich, K.R.M. Leino, and\nW. Schulte. Verification of object-oriented programs with\ninvariants. Journal of Object Technology. Special issue:\nECOOP 2003 workshop on Formal Techniques for Java-like\nPrograms, 3(6), June 2004.\n[3] M. Barnett, B. E. Chang, R. DeLine, B. Jacobs, and K. R. M.\nLeino. Boogie: A Modular Reusable Verifier for Object-\nOriented Programs. In International Symposium on Formal\nMethods for Components and Objects (FMCO), 2005.\n[4] M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# pro-\ngramming system: An overview. In Workshop on Construc-\ntion and Analysis of Safe, Secure, and Interoperable Smart\nDevices, 2004.\n[5] J. Berdine, A. Chawdhary, B. Cook, D. Distefano, and\nP. O\u2019Hearn. Variance analyses from invariance analyses. In\nACM Symposium on Principles of Programming Languages\n(POPL), Nice, France, January 2007.\n[6] L. Burdy, Y. Cheon, D. R. Cok, M. Ernst, J. Kiniry, G. T.\nLeavens, K. R. M. Leino, and E. Poll. An Overview of JML\nTools and Applications. International Journal on Software\nTools for Technology Transfer, 7(3):212\u2013232, June 2005.\n[7] A. Cavalcanti and A. Sampaio. From CSP-OZ to Java with\nProcesses. In Workshop on Formal Methods for Parallel\nProgramming, held in conjunction with International Paral-\nlel and Distributed Processing Symposium. IEEE CS Press,\n2002.\n[8] W.N. Chin, S.C. Khoo, S.C. Qin, C. Popeea, and H.H.\nNguyen. Verifying Safety Policies with Size Properties and\nAlias Controls. St. Louis, Missouri, May 2005.\n[9] B. Cook, A. Podelski, and A. Rybalchenko. Proving thread\ntermination. In ACM SIGPLAN Conf. on Programming Lan-\nguage Design and Implementation (PLDI), San Diego, June\n2007.\n[10] D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: a the-\norem prover for program checking. Journal of the ACM,\n52(3):365\u2013473, 2005.\n[11] A. Diller. Z and Hoare Logics. In Z User Workshop, 1991.\n[12] J. S. Dong, P. Hao, S. C. Qin, J. Sun, and W. Yi. Timed\nPatterns: TCOZ to Timed Automata. In Formal Methods\nand Software Engineering (ICFEM04), Seattle, WA, USA.\n[13] R. Duke and G. Rose. Formal Object Oriented Specifica-\ntion Using Object-Z. Cornerstones of Computing. Macmil-\nlan, March 2000.\n[14] R. Duke, G. Rose, and G. Smith. Object-Z: a Specification\nLanguage Advocated for the Description of Standards. Com-\nputer Standards and Interfaces, 17:511\u2013533, 1995.\n[15] R. Duke, L. Wildman, and B. Long. Modelling Java Concur-\nrency with Object-Z. In International Conference on Soft-\nware Engineering and Formal Methods (SEFM 2003). IEEE\nComputer Society Press, 2003.\n[16] M. Fa\u00a8hndrich and K. R. M. Leino. Declaring and checking\nnon-null types in an object-oriented language. In ACM SIG-\nPLAN Conference on Object-Oriented Programming Sys-\ntems, Languages and Applications (OOPSLA 2003, pages\n302\u2013312, Anaheim, CA, USA, 2003.\n[17] C. Fischer. CSP-OZ - a combination of CSP and Object-\nZ. In Formal Methods for Open Object-Based Distributed\nSystems. Chapman & Hall, 1997.\n[18] N. Giles. An Object-Z to JML Parser, 2002. MSc thesis,\nImperial College.\n[19] J. He, Z. Liu, X. Li, and S. Qin. A relational model for\nobject-oriented designs. In Second Asian Symposium on Pro-\ngramming Languages and Systems (APLAS\u201904), pages 415\u2013\n436, 2004.\n[20] V. Hilaire, O. Simonin, A. Koukam, and J. Ferber. A For-\nmal Approach to Design and Reuse Agent and Multiagent\nModels. In Agent Oriented Software Engineering (AOSE 04),\nLecture Notes in Computer Science, 2004.\n[21] C. A. R. Hoare and J. He. Unifying Theories of Program-\nming. Prentice-Hall, 1998.\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\n[22] C.A.R. Hoare and J. Misra. Verified software: Theories,\ntools, experiments: Vision of a grand challenge project. In\nThe VSTTE conference \u2013 Verified Software: Theories, Tools,\nExperiments, ETH Zurich, October 2005.\n[23] S.-K. Kim and D. Carrington. Formalizing the uml class di-\nagram using object-z. In Second International Conference\non The Unified Modeling Language: Beyond the Standard\n(UML\u201999), volume 1723 of Lecture Notes in Computer Sci-\nence, pages 83\u201398, 1999.\n[24] P. King. Printing Z and Object-Z LATEX documents. May\n1990.\n[25] D. Leijen. Parsec, a fast combinator parser. November 2001.\n[26] B. Mahony and J. S. Dong. Timed Communicating Object\nZ. IEEE Transactions on Software Engineering, 26(2):150\u2013\n177, February 2000.\n[27] H. Miao, L. Liu, and L. Li. Formalizing UML models with\nObject-Z. In Formal Methods and Software Engineering,\nvolume 2495 of Lecture Notes in Computer Science, pages\n523\u2013534, 2002.\n[28] M. Mo\u00a8ller, E.-R. Olderog, H. Rasch, and H. Wehrheim.\nLinking CSP-OZ with UML and Java: A Case Study. In\n4th International Conference on Integrated Formal Methods,\n(IFM 2004), Canterbury, UK, pages 267\u2013286, April 2004.\n[29] C.C. Morgan. Programming from Specifications. Prentice\nHall International, second edition, 1994.\n[30] H.H. Nguyen, C. David, S.C. Qin, and W.N. Chin. Auto-\nmated Verification of Shape And Size Properties via Separa-\ntion Logic. Nice, France, January 2007.\n[31] S. Peyton-Jones and et al. Glasgow Haskell Compiler.\nhttp:\/\/www.haskell.org\/ghc.\n[32] G. Smith. A Semantic Integration of Object-Z and CSP for\nthe Specification of Concurrent Systems. In Formal Methods\nEurope (FME\u201997), volume 1313 of Lecture Notes in Com-\nputer Science. Springer-Verlag, 1997.\n[33] G. Smith. The Object-Z Specification Language. Advances\nin Formal Methods. Kluwer Academic Publishers, 2000.\n[34] M. Spivey. The Z Notation: A Reference Manual. Inter-\nnational Series in Computer Science. Prentice Hall, second\nedition, 1992.\n[35] J. Sun, J.S. Dong, J. Liu, and H. Wang. Object-Z Web En-\nvironment and Projections to UML. In International World\nWide Web Conference (WWW-10). ACM Press, 2001.\n[36] K. Taguchi, J.S. Dong, and G. Ciobanu. Relating Pi-calculus\nto Object-Z. In IEEE International Conference on Engineer-\ning Complex Computer Systems (ICECCS\u201904). IEEE Press,\n2004.\nSortedSequence\n\u0002 (items, length, insert, remove)\nmax : N\nitems : seqZ\n\u0394\nlength : N\nlength \u2264 max\n\u2200 x, y : N \u2022 0 \u2264 x \u2264 y \u2264 length\u22121\n\u21d2 items(x) \u2264 items(y)\nINIT\nitems = \u3008\u3009\nlength = 0\ninsert\n\u0394(items)\nn? : Z\nlength < max\nn? in items\u2032\n\u2200 x, y : N \u2022 0 \u2264 x \u2264 y \u2264 length\u2032\u22121\n\u21d2 items\u2032(x) \u2264 items\u2032(y)\n\u00b7 \u00b7 \u00b7\npublic class SortedSequence {\nprivate int max;\npublic int[] items;\npublic int length;\ninvariant max > 0;\ninvariant length >=0 && length <= max;\ninvariant forall {int x; forall {int y;\n(0<=x && x<=y && y<=length-1)\n==> (items[x]<=items[y])}};\npublic SortedSequence()\nensures items == null;\nensures length == 0;\n{}\npublic void insert(int n)\nrequires length < max;\nensures n in items;\nensures forall {int x; forall {int y;\n(0<=x && x<=y && y<=length-1)\n==> (items[x]<=items[y])}};\nmodifies items, length;\n{}\n...\n}\n12th IEEE International Conference on Engineering Complex Computer Systems (ICECCS 2007)\n0-7695-2895-3\/07 $25.00  \u00a9 2007\n"}