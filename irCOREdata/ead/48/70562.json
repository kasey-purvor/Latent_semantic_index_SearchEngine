{"doi":"10.1023\/A:1019116530113","coreId":"70562","oai":"oai:eprints.lancs.ac.uk:11632","identifiers":["oai:eprints.lancs.ac.uk:11632","10.1023\/A:1019116530113"],"title":"L2imbo:a distributed systems platform for mobile computing","authors":["Davies, Nigel","Friday, Adrian","Blair, Gordon S.","Wade, Stephen"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"1998-08","abstract":"Mobile computing environments increasingly consist of a range of supporting technologies offering a diverse set of capabilities to applications and end-systems. Such environments are characterised by sudden and dramatic changes in the quality-of-service (QoS) available to applications and users. Recent work has shown that distributed systems platforms can assist applications to take advantage of these changes in QoS and, more specifically, facilitate applications to adapt to their environment. However, the current state-of-the-art in these platforms reflects their fixed network origins through their choice of synchronous connection-oriented communications paradigms. In this paper we argue that these paradigms are not well suited to operation in the emerging mobile environments. Furthermore, we offer an alternative programming paradigm based on tuple spaces which, we believe, offers a number of benefits within a mobile context. The paper presents the design, implementation and evaluation of a new platform based on this paradigm","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/70562.pdf","fullTextIdentifier":"http:\/\/eprints.lancs.ac.uk\/11632\/1\/davies%2Dl2imbo%2Dmonet98.pdf","pdfHashValue":"46c5e2597e341de29336bc34e9526da312545b9b","publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:eprints.lancs.ac.uk:11632<\/identifier><datestamp>\n      2018-01-24T00:04:20Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413735<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        L2imbo:a distributed systems platform for mobile computing<\/dc:title><dc:creator>\n        Davies, Nigel<\/dc:creator><dc:creator>\n        Friday, Adrian<\/dc:creator><dc:creator>\n        Blair, Gordon S.<\/dc:creator><dc:creator>\n        Wade, Stephen<\/dc:creator><dc:subject>\n        QA75 Electronic computers. Computer science<\/dc:subject><dc:description>\n        Mobile computing environments increasingly consist of a range of supporting technologies offering a diverse set of capabilities to applications and end-systems. Such environments are characterised by sudden and dramatic changes in the quality-of-service (QoS) available to applications and users. Recent work has shown that distributed systems platforms can assist applications to take advantage of these changes in QoS and, more specifically, facilitate applications to adapt to their environment. However, the current state-of-the-art in these platforms reflects their fixed network origins through their choice of synchronous connection-oriented communications paradigms. In this paper we argue that these paradigms are not well suited to operation in the emerging mobile environments. Furthermore, we offer an alternative programming paradigm based on tuple spaces which, we believe, offers a number of benefits within a mobile context. The paper presents the design, implementation and evaluation of a new platform based on this paradigm.<\/dc:description><dc:date>\n        1998-08<\/dc:date><dc:type>\n        Journal Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:relation>\n        http:\/\/dx.doi.org\/10.1023\/A:1019116530113<\/dc:relation><dc:identifier>\n        Davies, Nigel and Friday, Adrian and Blair, Gordon S. and Wade, Stephen (1998) L2imbo:a distributed systems platform for mobile computing. Mobile Networks and Applications, 3 (2). pp. 143-156. ISSN 1383-469X<\/dc:identifier><dc:relation>\n        http:\/\/eprints.lancs.ac.uk\/11632\/<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/dx.doi.org\/10.1023\/A:1019116530113","http:\/\/eprints.lancs.ac.uk\/11632\/"],"year":1998,"topics":["QA75 Electronic computers. Computer science"],"subject":["Journal Article","PeerReviewed"],"fullText":"Mobile Networks and Applications 3 (1998) 143\u2013156 143\nL2imbo: A distributed systems platform for mobile computing\nNigel Davies, Adrian Friday, Stephen P. Wade and Gordon S. Blair\nDistributed Multimedia Research Group, Department of Computing, Lancaster University, Bailrigg, Lancaster LA1 4YR, UK\nMobile computing environments increasingly consist of a range of supporting technologies offering a diverse set of capabilities\nto applications and end-systems. Such environments are characterised by sudden and dramatic changes in the quality-of-service (QoS)\navailable to applications and users. Recent work has shown that distributed systems platforms can assist applications to take advantage of\nthese changes in QoS and, more speci\ufb01cally, facilitate applications to adapt to their environment. However, the current state-of-the-art in\nthese platforms re\ufb02ects their \ufb01xed network origins through their choice of synchronous connection-oriented communications paradigms.\nIn this paper we argue that these paradigms are not well suited to operation in the emerging mobile environments. Furthermore, we offer\nan alternative programming paradigm based on tuple spaces which, we believe, offers a number of bene\ufb01ts within a mobile context.\nThe paper presents the design, implementation and evaluation of a new platform based on this paradigm.\n1. Introduction\nMobile computing environments are characterised by\nsigni\ufb01cant and rapid changes in their supporting infrastruc-\nture and, in particular, in the quality-of-service (QoS) avail-\nable from their underlying communications channels. Pre-\nvious research [11,24] has demonstrated that in order to\noperate effectively in mobile environments applications are\nrequired to adapt in response to these changes. Such appli-\ncations are termed adaptive applications.\nAdaptive applications require distributed systems sup-\nport, and a number of platforms have recently been de-\nveloped which address this requirement. Examples include\nMobile DCE [34], the MOST platform [9] and the Rover\nToolkit [23]. These mobile platforms attempt to provide ap-\nplication programmers with traditional computational mod-\nels and communications semantics consistent with those\nnormally found in platforms designed for \ufb01xed networks.\nIn particular, the three major mobile distributed systems\nplatforms all implement RPC semantics with (to a greater\nor lesser extent) additional interfaces allowing applications\nto monitor and adapt to changes in QoS. Clearly, procedure\ncall semantics are dif\ufb01cult to provide during periods when\nmobile hosts are experiencing very low levels of commu-\nnications QoS or during periods of disconnected operation.\nTo address this problem the platforms all include support\nfor buffering remote procedure calls during periods of dis-\nconnection ready for transmission when the network QoS\nimproves and facilities for re-binding clients to new (pos-\nsibly proxy) services during network partitions.\nIn this paper we argue that the procedure call paradigm\nhas a number of shortcomings when used in the context of\nmobile environments and suggest an alternative paradigm\nbased on tuples and tuple spaces [16]. The tuple space\nparadigm has been widely used in the parallel computing\ncommunity but there has, to our knowledge, been no work\non applying the paradigm in mobile environments. The use\nof tuple spaces for mobile computing was considered by\nSchilit in his thesis [32] but they were dismissed as being\n\u201c... not designed to manage hosts over slow links, and ...\nnot concerned with the problems of fault tolerance in a par-\ntially connected network\u201d. We would argue that while this\nis clearly true of the original tuple space platform, Linda\n[16] (which was designed for shared memory multiproces-\nsors), the same criticism could be levelled against any dis-\ntributed systems platform which had been developed before\nthe impact of mobile computing had been considered (e.g.,\nDCE). In contrast, we believe that the inherent temporaland\nspatial de-coupling offered by the tuple space paradigm is\nmore suited to the partial connection experienced by mobile\nhosts than existing synchronous communication paradigms.\nIn the remainder of this paper, we consider the design of\na tuple space based platform called L2imbo. The platform,\nAPI and a distributed implementation of the prototype are\nconsidered.\nSection 2 presents an analysis of the characteristics of\nmobile environments and highlights the role of distrib-\nuted systems platformsin supportingapplicationadaptation.\nSection 3 considers the three foremost mobile distributed\nsystems platforms and argues that the synchronous com-\nmunications model which underpins these platforms is not\nwell suited to use in a mobile environment. Section 4 then\npresents the design of our new platform, L2imbo, which\nis based on an asynchronous programming paradigm and\nincludes integrated support for QoS. A distributed imple-\nmentation of the L2imbo paradigm is described in section 5.\nA performance comparison of the platform prototype with\nrespect to more well known distributed systems platforms\nis presented in section 6. Finally, section 7 contains our\nconcluding remarks.\n2. Supporting mobile computing\nCurrently, mobile hosts are able to make use of a wide\nvariety of communications technologies to attain connec-\ntivity. These technologies include wide, metropolitan and\n\u00d3 Baltzer Science Publishers BV144 N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing\nlocal area wireless networks together with more traditional\n\ufb01xed network technologies. Increasingly, network tech-\nnologies are becoming integrated to offer seamless connec-\ntivity to mobile hosts through a system of network over-\nlays [25]. Each of these supporting technologies offer end-\nsystems a unique signature of characteristics (QoS), the\nmost commonly considered, and easily visualised of which,\nis bandwidth. In simple terms, a typical \ufb01xed network (such\nas Ethernet) will offer several orders of magnitude greater\nbandwidth than the average mobile channel (e.g., GSM).\nIn addition, networks may be characterised in innumer-\nable other ways including access time, bit error rates, error\ncontrol strategies, orientation (connection orientation versus\npacket mode) and, of increasing importance, functionality.\nThis last category re\ufb02ects the fact that many networking\ntechnologies now offer a range of services to end-systems.\nFor example, the TETRA system offers con\ufb01gurable vari-\nable bit rate channels with multiple levels of forward er-\nror protection which may be selected by the client. Many\nof these abilities are shared by cordless systems based on\nDECT, wired systems such as ISDN and future wireless\ncellular developments including the emerging GSM High\nSpeed Circuit Switched Data (HSCSD) and General Packet\nRadio Services (GPRS). In addition, a number of reserva-\ntion based protocols are available for \ufb01xed networks which\nalter the networks perceived QoS [8,12].\nGiven the implications for applications and end-users of\nthe characteristics and potential services offered by such\na range of networking technologies, there is an increas-\ning requirement for QoS information and control through-\nout end-system software [10,25,29]. This requirement for\ninformation provision is in contrast to current distributed\nsystems platforms which justify their existence primarily\nthrough the provision of distribution transparencies. For\ninstance, the provision of location and access transparen-\ncies greatly simplify the development of distributed appli-\ncations. Such an approach has proved highly successful for\nfacilitating interworking in heterogeneous distributed envi-\nronments and works adequately while the characteristics of\nthe underlying system are relatively static and assumptions\nconcerning levels of service can be made by applications\nand end-users. However, as stated in the previous section,\nchange is a fundamental characteristic of mobile environ-\nments. Employing the same approach in environments such\nas these, i.e., hiding the environmental changes with layers\nof transparency, prohibits adaptation, the requirement for\nwhich has been presented in [10,25,29].\nExisting research has postulated that API level QoS ab-\nstractions based on communications bindings [14,22] are\nsuf\ufb01cient to enable platforms and applications to be made\naware of, and control, their supporting environment. In-\ndeed, systems based on the concept of bindings have shown\nthat such abstractions provide a natural and easily visualised\nmethod of managing network QoS in mobile applications\n[15]. However, tying system QoS management to inter-\nhost communication is not ideal. In particular, there are\na number of QoS parameters which may govern system\nbehaviour that are not linked to communication. An ex-\nample of one of the most signi\ufb01cant of these parameters\nis power or, more speci\ufb01cally, the charge in the system\u2019s\nbatteries and power consumption of various system com-\nponents (including network interfaces, on-board hardware,\nthe display, PC card devices and the hard disk). While the\npower consumption associated with using the network inter-\nface (or network interfaces) is clearly linked with commu-\nnication, the remaining components\u2019 consumption is likely\nto be largely independent of any ongoing communications.\nThe close liaison between communications and QoS im-\nplies that, at the API level, communications must be estab-\nlished before QoS information can be obtained (note that\nthis does not necessarily imply that engineering level bind-\nings must also be created). This approach makes writing\ndistributed applications dif\ufb01cult since in order to determine\nthe QoS available to a range of services the application\nmust \ufb01rst establish bindings to each service in order to\ngain an appropriate handle for obtaining QoS information.\nIn our opinion, future distributed systems platforms will\nbe required to provide more general mechanisms to facil-\nitate adaptation. In more detail, such platforms must col-\nlate and manage QoS information from a wide range of\nsources (both communications and end-system based) for\npresentation to higher layers, enabling feedback and control\nthroughout the architecture. Examples of such QoS infor-\nmation include power availability, physical location, device\nproximity and communications capabilities and costs.\n3. Current mobile distributed systems platforms\nTo date there have been three signi\ufb01cant research ef-\nforts aimed at producing general purpose distributed sys-\ntems platforms for mobile environments. In the following\nsections we brie\ufb02y review each of the resulting systems and\nthen discuss their commonalities and shortcomings.\n3.1. Mobile DCE\nThe Mobile DCE initiative at the University of Tech-\nnology, Dresden aims to augment a standard DCE platform\nwith new features for operation in a mobile environment.\nThe overall system architecture is based on the concept\nof domains. These are logical groupings of machines with\nshared resources managed by a domain manager. Mobile\nclients move between domainsand hence have access to dif-\nferent resources. Manager processes on each client interact\nwith the domain managers and utilise a matrix specifying\nresource characteristics in order to ensure service provision\nas the client changes domains. In more detail, as clients\ncross domain boundaries their managers decide (for each\nservice) whether to continue remote access to a service in\nthe original domain, to re-bind to a new service in the\ndestination domain or, during periods of disconnection, to\nemulate the service and replay messages when connectivity\nis restored.N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing 145\nMobile DCE has been implemented under the Win-\ndows\/NT operating system and a number of applications\nhave been developed including mobile e-mail. The use of\nthe industry standard DCE\/Microsoft RPC protocol allows\nthe platform to be integrated with existing distributed ap-\nplications.\n3.2. The MOST platform\nLancaster University\u2019s MOST platform provides support\nfor adaptive mobile applications within an Open Distributed\nProcessing (ODP) [20] based framework. The platform\naugments an existing ODP compatible platform called AN-\nSAware [1] with new services, protocols and API calls. In\nparticular, the platform incorporates a new protocol called\nQEX [15] which is able to adapt to changes in the QoS of\nits underlying communications infrastructure and pass this\ninformation on to interested client applications.\nThe QEX protocol is layered above a low-level service\ncalled S-UDP which provides dial-up UDP connections\nover GSM. S-UDP and QEX both allow messages to be\ntagged with deadlines and messages from the mobile host\nto the \ufb01xed network are sent in earliest-deadline-\ufb01rst order.\nThe system uses the message deadlines to determine when\nto establish and break connections. Furthermore, messages\ncan be buffered during periods of disconnection until either\nthey are sent or their deadlines expire (in which case an\nexception is raised at the client).\nThe MOST platform has been implemented on Sun\nworkstations and notebook PCs running a variety of\n\ufb02avours of UNIX and using a range of communications\ntechnologies including GSM. The platform has been used\nto support a wide range of mobile applications including\ne-mail, a collaborative geographic information system and\na job dispatch application for \ufb01eld engineers.\n3.3. Rover\nThe Rover toolkit from M.I.T. is designed to support the\ndevelopment of mobile applications. This support is based\non the twin notions of relocatable data objects and queued\nremote procedure calls (QRPCs). In essence, the platform\nallows the creation of data objects with well de\ufb01ned inter-\nfaces which can be migrated at run-time between the mo-\nbile client and servers on the \ufb01xed network. This allows\ndecisions regarding application con\ufb01gurationand the client-\nserver computation trade-off to be made (and re-evaluated)\nat run-time as the network QoS and resource availability\nchange.\nCommunication between objects is carried out using the\ntoolkit\u2019s QRPC protocol. In addition to being able to re-\nbind to objects which have migrated, QRPC also provides\nsupport for periods of disconnection by buffering messages\ndestined for remote sites until network connectivity is re-\nstored.\nA number of applications have been ported to the\nRover toolkit including a web browser and an e-mail ap-\nplication. However, unlike both MOST and Mobile DCE,\nRover is not based on an existing standard and applica-\ntions must be re-engineered to operate in a mobile environ-\nment.\n3.4. Discussion\nAll of the above platforms offer mobile clients connec-\ntion-oriented RPC-based communications with associated\nQoS support. The implementations of the communications\nservices all relax the synchronous nature of RPC interac-\ntions by allowing messages to be buffered (Mobile DCE),\ndelayed (MOST) or queued (Rover). However, the pro-\ngramming model presented to application writers is still\nessentially synchronous in nature. Indeed, all of the plat-\nforms attempt to maintain RPC semantics in the face of\nvariations in network connectivity. Furthermore, all of the\nmodels are connection-oriented: clients select services to\nbe used, bind to their interfaces and then invoke operations\non these interfaces. As the network QoS and service avail-\nability change the platforms use a range of techniques in an\nattempt to maintain the illusion of connection-orientedcom-\nmunications. For example, in Mobile DCE the RPC pro-\ntocol transparently re-binds clients to local proxy services\nduring periods of disconnection. In all of the platforms\nhooks have been provided to enable application program-\nmers to determine the QoS of the underlying network and\nhence construct applications which adapt to changes in this\nQoS.\nOur experiences with developing and working with plat-\nforms of this type have led us to question the suitability\nof the synchronous paradigms on which they are based for\nuse in a mobile environment. In particular, as network QoS\ndegrades, providing a model of synchronous, connection-\noriented communications becomes increasingly dif\ufb01cult. In\naddition, the emphasis placed on communications in these\nplatforms has thus far prevented a general model of QoS\nmonitoring and adaptation emerging (as discussed in sec-\ntion 2). More speci\ufb01cally, while explicitly modelling bind-\nings (as in the MOST platform) provides a convenient in-\nterface for monitoring communications QoS, it does not\nprovide a general mechanism for informing applications of\nchanges in other QoS parameters (e.g., power availabil-\nity). These changes must be propagated to clients using\nan alternative mechanism, e.g., operating system signals or\nenvironment variables as in [33]. However, as previously\nhighlighted, the lack of a cohesive strategy for dealing with\nall forms of QoS information complicates the development\nof applications.\nThe remainder of this paper describes the design, imple-\nmentation and evaluation of a new platform called L2imbo\nwhich attempts to address the issues raised in this section.\nMore speci\ufb01cally, the platform features an asynchronous,\nconnectionless programming paradigm and a uniform ar-\nchitecture for QoS control and monitoring.146 N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing\n4. The L2imbo architecture\n4.1. The tuple space paradigm\nThe tuple space paradigm has been extensively re-\nsearched by the parallel programming community for over\na decade. Tuples are typed data structures and each tuple\nconsists of a collection of typed data \ufb01elds. Each \ufb01eld is\neither termed an actual, if it contains a value, or a formal,i f\nit does not. Collections of (possibly identical) tuples exist\nin shared data objects called tuple spaces. Tuples can be\ndynamically deposited in and removed from a tuple space,\nthough they can not be altered while resident in it. Changes\ncan, however, be made to a tuple by withdrawing it from\nthe tuple space, amending and then reinserting it [17]. Tu-\nple spaces are shared between collections of processes, all\nof which have access to the tuples contained within.\nIn classic distributed environments processes commu-\nnicate across virtual channels described by bindings and\nformed from pairs of endpoints, cf. Chorus ports and UNIX\nBSD 4.3 sockets. The tuple space paradigm is funda-\nmentally different because processes communicate exclu-\nsively through tuple space; this has been termed gener-\native communication [16]. As processes no longer inter-\nact directly with one another, the implicit need for bind-\nings is removed and inter-process communication can actu-\nally progress anonymously. It is, however, also possible to\nachieve directed communications whereby tuples are pro-\nduced for an identi\ufb01ed consumer process by encapsulating\ndestination information in the tuples themselves. Several\nschemes have been proposed to achieve this, including an\napproach based on Amoeba-like ports [31]. Because tu-\nple spaces contain persistent tuple objects, as opposed to\nmessages, inter-process communication is supported across\ntime as well as space [3].\nThe tuple space paradigm was conceived by researchers\nat Yale [16] and embodied in a coordination language called\nLinda. Linda is not a standalone computational language,\ninstead Linda operatorsare embedded in host computational\nlanguages (e.g., C or Pascal). The original Linda model\nde\ufb01nes four basic operators:\n\u000f out inserts a tuple, composed of an arbitrary mix of\nactual and formal \ufb01elds, into a tuple space. This tuple\nbecomes visible to all processes with access to that tuple\nspace.\n\u000f in extracts a tuple from a tuple space, with its argument\nacting as the template against which to match. Actuals\nmatch tuple \ufb01elds if they are of equal type and value;\nformals match if their \ufb01eld types are equal. If all corre-\nsponding \ufb01elds of a tuple match the template the tuple\nis withdrawn and any actuals it contains are assigned\nto formals in the template. Tuples are matched non-\ndeterministically and in operations block until a suit-\nable tuple can be found.\n\u000f rd is syntactically and semantically equivalent to in\nexcept that a matched tuple is not withdrawn from the\ntuple space and hence remains visible to other processes.\n\u000f eval is similar to out, except it creates active rather\nthan passive tuples. The tuple is active because separate\nprocesses are spawned to evaluate each of its \ufb01elds. The\ntuple subsequently evolves into a passive tuple resident\nin the tuple space.\nAlthough not proposed in the original Linda model,\nmany implementations support two further operators, inp\nand rdp [26]. These are non-blocking versions of in and\nrd which evaluate to boolean values indicating their suc-\ncess and, if the operation succeeds, assigns actuals to for-\nmals as before.\n4.2. Platform overview\nOur new platform, L2imbo, is based on the Linda model\nbut includes a number of signi\ufb01cant extensions which ad-\ndress the speci\ufb01c requirements necessary for operation in\nmobile environments. In particular, our system incorporates\nthe following key extensions:\n\u000f multiple tuple spaces which may be specialised to meet\napplication level requirements, e.g., for consistency, se-\ncurity or performance;\n\u000f an explicit tuple type hierarchywith support for dynamic\nsub-typing;\n\u000f tuples with QoS attributes including delivery deadlines;\n\u000f a number of system agents that provide services for QoS\nmonitoring, the creation of new tuple spaces and the\npropagation of tuples between tuple spaces.\nIn the following sections we explain each of these ex-\ntensions in detail.\n4.2.1. Multiple tuple spaces\nThe original Linda model was designed to support par-\nallel programming on shared-memory multi-processor sys-\ntems and features a single, global tuple space. Many re-\ncent models have proposed the introduction of multiple tu-\nple spaces to address issues of performance, partitioning\nand scalability [5,19,27]. In particular, supporting multi-\nple tuple spaces removes the need to conduct all operations\nthrough a single global tuple space on all machines: im-\nportant for performance in a distributed environment and\ncritical in an environment where communications links are\ncostly and unreliable.\nWe provide a class of system agent which can create\nnew tuple spaces which can be con\ufb01gured to meet appli-\ncation speci\ufb01c requirements [19]. For example, in addition\nto general purpose tuple spaces we allow the creation of\ntuple spaces with support for security (user authentication),\npersistence and tuple logging (for accountability in safety\ncritical systems). Crucially, it is also possible to create a\nrange of QoS-aware tuple spaces (as discussed below).\nIn order to create a new tuple space clients commu-\nnicate with the appropriate system agents via a universal\ntuple space (UTS) using the sequence of operations shownN. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing 147\nFigure 1. Tuple space creation.\nin \ufb01gure 1. Clients specify the characteristics of the de-\nsired tuple space and place a create tuple space re-\nquest into a common tuple space. The appropriate sys-\ntem agent accesses this tuple, creates a tuple space with\nthe required characteristics and then places a tuple of type\ntuple space into the common tuple space. The \ufb01elds\nin this tuple denote the actual characteristics of the new\ntuple space (which may be different to those requested in\nbest-effort systems) and a handle through which clients can\naccess the new space.\nClients can make use of the new tuple space by means\nof a use primitive which provides access to a previously\ncreated tuple space. This primitive communicates with a\nmembership agent through the universal tuple space and\nreturns a handle if the tuple space exists and certain other\ncriteria are met. The precise criteria vary from tuple space\nto tuple space and can include checks on authentication\nand access control functions or relevant QoS management\nfunctions. At a later time, handles can be discarded by an\nagent using a discard primitive. An appropriate tuple is\nthen placed in the universal tuple space so that the mem-\nbership agent can take appropriate steps. Tuple spaces are\ndestroyed by placing a tuple of type terminate into the\ntuple space. These tuples are picked up by system agents\nwithin the tuple spaces themselves and invoke a system\nfunction to gracefully shut-down the tuple space.\nNote that this model can be applied recursively. It is\npossible to access a tuple space through the universal tu-\nple space and then \ufb01nd that this tuple space has system\nagents supporting the creation and subsequent access to tu-\nple spaces. This recursive structure provides a means of\ncreating private worlds offering \ufb01ner grain access control.\n4.2.2. Tuple type hierarchy\nIn our model all tuples are associated with a given type.\nTyped tuples can be organised to form a hierarchy by estab-\nlishing sub-typing relationships between them. The bene\ufb01ts\nof sub-typing in a distributed environment have been com-\nprehensively investigated within the ODP community as\npart of their work on interface trading [21]. In this model\nsub-typing enables added \ufb02exibility when matching service\noffers to client requests. We hope to accrue similar bene\ufb01ts\nby supporting sub-typing in L2imbo.\nThis scheme has a number of advantages over the no-\ntional typing found in many tuple space implementations.\nIn addition to the usual bene\ufb01ts associated with type signa-\ntures, it allows for the use of sub-typing when attempting\nto match tuples to in requests. In more detail, in requests\nfor a tuple of a given type can be matched with existing tu-\nples of an equal or sub-type. The conversion between types\nand sub-types (simply a matter of omitting \ufb01elds when re-\nturning the matching tuple) can be handled by the tuple\nspace. Interestingly, sub-type relationships in our model\nare themselves simply tuples of a prede\ufb01ned system type\nwhich are placed in the tuple space like any other tuple. As\nsuch, tuples and thus type relationships may be established\nby any authorised user of the tuple space.\nAs an optimisation in L2imbo, a tuple of one type is\nonly regarded as a sub-type of another tuple if the common\n\ufb01elds are present in the same order in the initial \ufb01elds of\nthe type. This optimisation greatly reduces the complexity\nof the tuple matching process.\n4.2.3. QoS attributes\nExisting mobile distributed systems platforms such as\nMOST allow deadlines to be associated with messages.\nThis enables messages to be re-ordered by the system to\nmake optimum use of the available network connectivity or\nbuffered during periods of disconnection. In L2imbo this is\nachieved by associating deadlines with tuples. In the case\nof a tuple which is the subject of an out operation the\ndeadline refers to the time the tuple is allowed to reside in\nthe tuple space before being deleted. In the case of tuples\nwhich are used as arguments to in or rd operations the\ndeadline refers to the time for which the requests can block\nbefore timing out. Once again, this timing information can\nbe used by the system to re-order messages.\nNote that by supporting time-outs on tuple space oper-\nations we are able to avoid having to provide special sup-\nport for inp and rdp, the non-blocking forms of in and\nrd found in other tuple space implementations [26]. Non-\nblocking operations cause particular problems for imple-\nmenters of distributed tuple spaces. Essentially, one must\nbe able to satisfy the assertion that when the non-blocking\noperation is actioned, no matching tuple is available any-\nwhere in the tuple space, without having to lock the entire\ntuple space [4]. In distributed implementations this require-\nment forces many tuple space operations to progress in lock\nstep, allowing every component site to have all the avail-\nable tuples simultaneously. In our model, a timed operation\nis subject to the weaker assertion that no tuple could be ob-\ntained within the speci\ufb01ed time.\n4.2.4. System agents\nAll interaction between the system and applications is\nvia tuple spaces. In addition to the tuple space creation\nagents discussed in section 4.2.1, tuple spaces may be aug-\nmented more generally by further agents which implement\nsystem and application functions. In more detail, agents\nreside above tuple spaces and interact with the tuple space,\ncarrying out a particular computation. If required, agents\ncan be written in a language supporting the creation of\nmobile code (e.g., Java or TCL) and migrated as neces-\nsary. Note that mobility of agents is naturally supported\nby the tuple space model; agents simply stop interacting\nwith the tuple space, re-locate and then re-start their in-\nteraction. As an enhancement, agents are also generally\nstateless; all state is assumed to be in the tuple space. As\ntuples are persistent and globally available, it is then trivial\nto support replication of agents. In other words, there is no148 N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing\nFigure 2. Tuple space agent interaction.\nneed for a consistency algorithm; this is directly provided\nby tuple spaces. Agents are classi\ufb01ed as system agents, al-\nready provided in the environment, and application agents,\nintroduced into the environment by the programmer. This\ndistinction is however not particularly rigid. The appli-\ncation programmer is free to introduce additional system\nagents into the environment. This overall architecture is\nshown in \ufb01gure 2.\nIn the remainder of this section we consider the function\nof three of the most signi\ufb01cant system agents de\ufb01ned in\nL2imbo: Bridging agents, QoS monitoring agents and type\nmanagement agents.\nBridging agents\nBridging agents provide the means of linking arbitrary\ntuple spaces and controlling the propagation of tuples be-\ntween these spaces. In their simplest form bridging agents\nare processes which carry out repeated rd operations on\none tuple space and then out the corresponding tuples\ninto a second tuple space (with appropriate mechanisms\nto avoid the problems caused by the non-deterministic na-\nture of the rd operation). However, bridging agents can\nalso provide more intelligent tuple propagation based on\na number of factors including tuple types and QoS pa-\nrameters. For example, bridging agents can be con\ufb01g-\nured to only propagate tuples or requests (generated as\na result of in, out or rd operations) subject to a set\nof constraints. Bridging agents can also be used to pro-\nvide gateways between specialised tuple spaces. For ex-\nample, a bridging agent could be con\ufb01gured to carry out\nformat conversions between homogeneous and heteroge-\nneous tuple spaces or to act as a \ufb01rewall to prevent\nthe propagation of unauthenticated tuples to secure tuple\nspaces.\nIt is important to stress that tuple spaces usually span\nmultiple hosts; bridging agents provide a mechanism for\npropagation of tuples between tuple spaces and are not\nusually required for the propagation of tuples between sep-\narate hosts: this functionality is provided by the protocol\ndiscussed in section 5.3.\nFigure 3. The L2imbo monitoring architecture.\nQoS monitoring agents\nEvery site in L2imbo has an associated local manage-\nment tuple space together with a number of QoS monitor-\ning agents. These monitoring agents monitor key aspects of\nthe system and inject tuples representing the current state\nof that part of the system into the management tuple space.\nSome typical forms of QoS monitoring agent are outlined\nbelow:\n\u000f Connectivity monitors: Watch over the characteristics of\nthe underlying communications infrastructure and make\navailable information such as the current throughput be-\ntween hosts.\n\u000f Power monitors: Review the availability and consump-\ntion of power on a particular host. In particular, applica-\ntions can obtain power information on host peripherals\nand may utilise hardware power saving functionality as\nappropriate.\n\u000f Cost monitors: Determine the cost associated with the\ncurrent communications links between hosts.\nThe precise con\ufb01guration of QoS monitoring agents can\nvary from site to site. As above, the architecture is open\nin that new QoS monitoring agents can readily be added\nto the con\ufb01guration. Monitors can observe events at var-\nious points in the system including: the rate of injection\nof tuples into a given tuple space, the rate of access to tu-\nples in tuple space (through in or rd operations), the total\nthroughput currently achieved from that node, the cost of\nthe current channel, the level of connectivity of that node,\nthe power availability and rate of consumption at that node,\nthe processor load and the current physical location of that\nnode. In this way, the architecture deals uniformly with a\nrange of QoS parameters relating to both communications\nand the general environment. In addition, the architecture\ncan provide information relating to a particular tuple space\nor to the node in general. This overall architecture is de-\npicted in \ufb01gure 3.\nThis architecture also has the advantage that information\npertaining to a node can be made globally available (cf.\nsignals and environmentvariables which are only accessible\nby local applications). This is achieved by placing QoS\ninformation tuples in a tuple space, which other sites can\naccess. This allows, for example, agents on different nodes\nto \ufb01nd out about the location of a particular site, its current\nprocessor load, the throughput it is currently experiencing,\netc. Note however that sites can make QoS informationN. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing 149\nprivate simply by selecting a particular membership agent\nthat prevents access from other sites.\nType management agents\nAs mentioned earlier, the optional typing which may be\napplied to a tuple can enable sub-typing hierarchies to be\nestablished between them. The type management agent on\neach site is responsible for determining inter-tuple type re-\nlationships based on system tuples of the type add type\nwhich are snooped from a given tuple space. The agent pro-\nvides facilities to the tuple space protocols to assist them\nin discovering when suitable sub-types can be found based\non supplied matching criteria. In addition, the type man-\nagement agent is the authority through which the sub-type\nrelationship tuples generated by local applications are rati-\n\ufb01ed for validity.\n4.2.5. Support for adaptation\nThe L2imbo architecture supports a variety of mecha-\nnisms for adaptation. Such mechanisms are typically em-\nployed on detecting a signi\ufb01cant change as a result of QoS\nmonitoring.\nOne of the main techniques for achieving adaptation is\nthat of \ufb01ltering agents. Filtering agentsare a special form of\nbridging agent in the architecture. As stated in the preced-\ning section, a bridging agent is one that links arbitrary tuple\nspaces and controls the propagation of tuples between these\nspaces. Filtering agents are essentially bridging agents that\nperform transformations on the tuples to map between dif-\nferent levels of QoS and are based on the work of [30,35]\non \ufb01ltering agents for multimedia computing. They rely\non typing information to identify the subset of tuples to be\n\ufb01ltered.\nFiltering agents can, for example, be used to translate\nbetween different media formats. More commonly though\nthey are used to reduce the overall bandwidth requirements\nfrom the source to the target tuple spaces. For example,\na \ufb01ltering agent can act between two tuple spaces dealing\nwith MPEG video and only propagate I-frames to the target\ntuple space. The \ufb01ltering agent could also perform more\naggressive bandwidth reduction, for example by performing\ncolour reduction on the I-frames (as proposed in [36]).\nThe importance of \ufb01ltering agents is that it is possible\nto construct a number of parallel tuple spaces offering the\nsame service, e.g., the propagation of video frames, but at\nradically different levels of QoS. An agent can therefore\nselect between the different levels depending on their level\nof connectivity. On detecting a drop in available bandwidth\n(or indeed an increase), they can switch to a different tuple\nspace. This overall approach is illustrated in \ufb01gure 4.\nFigure 4. The use of \ufb01ltering agents.\nThe architecture also supports a number of other forms\nof adaptation. For example, on detecting QoS violations, a\nsending agent can choose to adapt the rate at which tuples\nare injected into the tuple space. This is however a rather\ncrude mechanism in an environment supporting multiple\nreceivers with potentially different levels of connectivity.\nMore interestingly, a receiver can selectively in or rd cer-\ntain types of tuple and ignore others on detecting a drop in\ntheir connectivity. For example, they can select I-frames\nonly and ignore P- and B-frames (achieving a similar ef-\nfect as above). Similarly, they can select base encodings\nin hierarchical encoding schemes. With the appropriate al-\nlocation of priorities on these tuple types the underlying\nplatform can discard the lower priority tuples on detecting\ncongestion, implying that they need not be transmitted over\na lower bandwidth link.\n5. Prototype implementation\n5.1. Overview\nWe have developed a distributed systems platform based\non the L2imbo programming model presented in section 4.\nThe platform consists of a small stub library which is linked\nwith each application process and a single daemon process,\nan instance of which executes on each participating host.\nApplication requests (i.e., in, out and rd operations)\nare marshalled by the stub library and passed to the dae-\nmon process. The daemon process collaborates with other\ninstances of itself on remote hosts to provide tuple space\nrepositories and matching functions. Hence the tuple space\nis implemented in a distributed fashion and the daemon\nprocesses are required to maintain consistency between\ncopies of the tuple space on different hosts. This enables\nversions of the tuple space to remain accessible during pe-\nriods of disconnection. The issue of consistency between\ncopies of the tuple space is examined in detail in section 5.3.\nFigure 5 shows the overall platform architecture.\nInstances of the daemon process communicate using a\nprotocol called the Distributed Tuple Space (DTS) protocol.\nThe daemon process and the DTS protocol are described in\nmore detail in the following sections.\nFigure 5. Overview of the L2imbo platform.150 N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing\nFigure 6. Structure of the L2imbo daemon process.\n5.2. The L2imbo daemon process\nAs previously stated, all tuple space interactions are co-\nordinated by an instance of the L2imbo daemon running on\neach host. The structure of the L2imbo daemon process can\nbe presented as a number of layers as shown in \ufb01gure 6.\nThe lowest layer of the daemon is the network interface\nlayer. Each network supported by the L2imbo distributed\nsystems platform has a correspondinginterface module. All\ninterface modules present a generic interface behind which\ndetails such as connection management and signalling are\nhidden. Packets ready for transmission are delivered to\nan appropriate network interface module by the network\nscheduler. The network scheduler accepts protocol mes-\nsages from higherlayers and, based on associated QoS para-\nmeters, determines the order in which they are transmitted.\nThe QoS structure currently contains only two \ufb01elds, prior-\nity and deadline. Within each priority, messages are sched-\nuled in earliest deadline \ufb01rst (EDF) order. Messages with\nthe highest priority (smallest number) are scheduled before\nthose of successive priorities (even if a lower priority has an\nearlier deadline). The priority can thus be considered to be\na measure of the urgency that the associated deadline is met\nby the scheduler. This concept is based on previous work\nby Nieh on thread scheduling for continuous media [28].\nThe bottom two layers (consisting of the network sched-\nuler and network interfaces) are collectively known as the\nnetwork abstraction layer. The network abstraction layer\nhas been designed to provide a set of generic transport ser-\nvices that are independent of both tuple spaces and network\ntechnology.\nThe protocol layer is responsible for the implementa-\ntion of application requests (i.e., in, out and rd). This\nlayer is described in detail in section 5.3. Finally, the stub\nlayer is responsible for communicating between the L2imbo\ndaemon and client applications on the same host. By cen-\ntralising all of the applications accesses to the tuple spaces\nthrough a single process on each host, the platform gains\nan overall picture of the demands on the available network\n(or networks) and is able to balance the load and manage\ncongestion more effectively. However, there is of course\na performance penalty associated with this approach since\neach message involves an additional context switch and lo-\ncal communications overhead. This issue is explored in\nmore detail in section 6.\n5.3. The Distributed Tuple Space protocol\nA single Distributed Tuple Space protocol module on\neach host is responsible for providingthe tuple space reposi-\ntory and associated matchingfunctionsfor every tuple space\nused by client applications (in the \ufb01rst instance this is just\nthe universal tuple space). The module uses the protocol\nto maintain the distributed local caches of tuples and re-\nquests (anti-tuples) and to ensure that they reach eventual\nconsistency.\nIt is essential that such a distributed implementation does\nnot apply locking strategies for operationswhich remove tu-\nples and avoids algorithms which lead to acknowledgement\nimplosion, both of which critically affect performance. For-\ntunately there are a number of features of the tuple space\nparadigm which greatly simplify the implementation task.\nFirstly, the model does not specify how long it takes for\ntuples to propagate to and from the tuple space: as long\nas tuples are matched non-deterministically and tuples can\nnever be in\u2019d more than once (tuples are thus unique) the\nmodel holds. Similarly, tuple operations are not causally\nordered and total ordering does not have to be maintained.\nFurthermore, providing the uniqueness of tuples is main-\ntained, it is not necessary to enforce strict consistency be-\ntween the caches associated with distinct instances of the\nL2imbo daemon.\nOur protocol is based on IP multicast and borrows appli-\ncation level framing concepts from SRM the scalable mul-\nticast transport which underpins wb [13] and Jet\ufb01le [18].\nEssentially, each distributed tuple space is modelled as a\nmulticast group (see \ufb01gure 7). This ensures that applica-\ntion level partitioning (by creating new application speci\ufb01c\ntuple spaces for a given domain) is re\ufb02ected at both the\nplatform and the communications level and hence helps\nL2imbo applications to scale.\nEach tuple and anti-tuple is given a unique identi\ufb01er\nwhich comprises a daemon identi\ufb01er and a monotonically\nincreasing integer. All messages in the protocol are multi-\ncast and it is assumed that the messages will be snooped\nby all available hosts in the multicast group. The format\nof the nine protocol messages are shown in \ufb01gure 8. Indi-\nvidual protocol messages may be concatenated into single\nmulticasts for increased performance.\nThe user operations in, rd and out map onto the\nmessages as shown in table 1. The out operation propa-\ngates a tuple to all group members which then cache this\nlocally until explicitly removed by a DELETE message.\nThe speed of the in operation governs the overall perfor-\nmance of the tuple space and causes the most problems in\ndistributed implementations. The key to the performance\nof our prototype lies in the notion of tuple ownership. Im-\nportantly, ownership can be transferred to any of the par-N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing 151\nFigure 7. The decentralised architecture.\nTable 1\nUser operations.\nUser op. Action\nout if (any matching local RD requests)\nsatisfy requests\nif (pending matching local IN request)\nsatisfy request\ntx (OUT [tuple id, our id, type, tuple])\ntx (DELETE[tuple id, in request id])\nelse\nif (pending foreign IN request which\nmatches)\ntx (OUT [tuple id, in requester id,\ntype, tuple])\nelse\ntx (OUT [tuple id, our id, type,\ntuple])\nin if (a matching tuple is queued)\nif (we are the owner)\ntx (DELETE [tuple id, in request id])\nelse\nqueue the IN request\ntx (CHOWN REQ [tuple id, client id])\nelse\nqueue the IN request\ntx (IN [our id, type, spec])\nrd if (a matching tuple is queued)\ntx (ACCESS[tuple id])\nelse\nqueue the RD request\ntx (RD[tuple, spec])\nFigure 8. Distributed Tuple Space protocol messages.\nticipants of the tuple space and does not solely rest with\nthe creator of the tuple. Before a tuple can be removed\n(by an in operation) the ownership of the tuple must be\ntransferred to the performer of the in operation (achieved\nby nomination by the current owner of the tuple or by using\nan explicit CHOWN REQ message). Any user of the tuple\nspace is free to in (remove) any tuples that they currently\nown without consulting any other user.\nOptimisations can be achieved through careful assign-\nment of the tuple ownership. For instance, consider the ex-\nample where someone generates a tuple for which it knows\nthere is a pending IN request. The generator of the tuple\nsends an OUT message nominating the originator of the\npending IN as the owner. Upon snooping the OUT message\nand, assuming the IN request has remained unsatis\ufb01ed in\nthe meantime, the tuple can be immediately removed and a152 N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing\nTable 2\nTuple space messaging protocol.\nMessage Action\nOUT if (we already know about this tuple)\nupdate ownership information\nelse\nqueue tuple\nwhile (any matching local RD request is queued)\nsatisfy requests\nif (any RDs were satisfied)\ntx (ACCESS[tuple id])\nelse\nif (a matching local IN request is queued)\nif (we are the nominated owner)\ntx (DELETE [tuple id, in request id])\nelse\ntx (CHOWN REQ [tuple id, our id])\nIN if (a matching tuple is queued)\nif (we are the owner)\ntx (OUT [tuple id, in requester id, type, tuple])\nelse\ntx (OUT [tuple id, owner id, type, tuple])\nelse\nqueue IN request\nRD if (a matching tuple is queued)\ntx (OUT [tuple id, owner id, type, tuple])\nCHOWN REQ if (we know about this tuple)\nif (its been deleted)\ntx (DELETE [tuple id, in request id])\nelse\nif (we still own tuple)\ntx (CHOWN ACK [tuple id, client id])\nelse\ntx (CHOWN ACK [tuple id, owner id)])\nelse\ntx (REPAIR REQ [tuple id])\nCHOWN ACK if (we know about this tuple)\nupdate tuple ownership\nif (we are the new owner and we have a pending local IN)\nservice request\ntx (DELETE [tuple id, in request id])\nDELETE if (we know about the tuple)\ndelete tuple from store (and IN request it satisfies)\nACCESS if (we know about the tuple)\nif (we have deleted the tuple)\ntx (DELETE [tuple id, in request id])\nelse\ntx (REPAIR REQ [tuple id])\nREPAIR REQ if (we have this tuple)\ntx (REPAIR ACK [tuple id, owner id, type, tuple])\nREPAIR ACK if (we don\u2019t have this tuple)\nqueue tuple\nDELETE message generated. Moreover, based on observed\ninteractions, a tuple which is generated in response (which\nis likely to be consumed by the originator of the last tuple)\ncould nominate the originator as the owner. This mecha-\nnism allows RPC-like semantics to be modelled ef\ufb01ciently\n(if necessary).\nThe tuple identi\ufb01er associated with every tuple enables\nmembers of the tuple space to detect tuples that are missing\nfrom their local cache. If a member detects a missing tuple,\nthey issue a REPAIR REQ message asking for a copy of the\ntuple. Members who have a copy of the tuple can multicast\naR E P A I RACK containing the missing tuple. The protocolN. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing 153\nuses a backoff proportional to the distance from the sender\nof the request to ensure that the closest cache which can\nsatisfy the request responds \ufb01rst. If an acknowledgement\nis snooped, the timer governing the transmission of the ac-\nknowledgement is cancelled. Table 2 illustrates how the\nprotocol messages are handled. Note that ACCESS and\nDELETE messages (generated by rd\u2019s and in\u2019s) do not\nneed to be generated immediately since they are only used\nby other parties to either detect missing tuples or prevent\nthe use of stale tuples. The more quickly these messages\nare transmitted the faster the views of the tuple space held\nby each node will converge but in any case the semantics\nwill remain unchanged. This enables us to reduce trans-\nmission overhead by batching ACCESS\u2019s and DELETE\u2019s\nwith other protocol messages.\nHosts are free to connect and disconnect from the multi-\ncast group (and\/or network) at will. We assume that mobile\nhosts will connect through some form of mobility support\ngateway (such as that proposed for mobile IP and IPv6) and\nthat the gateway will operate a cache proxy on behalf of\ndisconnected clients. Since mobile hosts may be the nom-\ninated owners of tuples, we assume that a disconnected\nhost may optimistically continue to access (rd) copies of\nthe tuples which they have cached and do not own. How-\never, the mobile is not allowed to remove (in) a tuple that\nhas been OUT\u2019d to the network, since the proxy may have\nyielded ownership while the mobile was disconnected (al-\nthough, tuples generated during disconnection may be used\nsince the rest of the network will be unaware of these until\nreconnection). When a host reconnects to the network, it\nonly need inform the group of new tuples it has generated.\nThe proxy will in turn inform the client of any cached tu-\nples which have been deleted. Tuples missed during the\ndisconnection can be obtained through the multicast of IN\nand RD messages in the usual manner.\n5.4. Implementation status\nWe have built an implementation of the L2imbo distrib-\nuted systems platform which runs on Linux 2.0 (MULTI-\nCAST), SunOS 4.1.4 (MULTICAST-4.1.4) and Solaris 2.5.\nAll these operating systems offer RFC 1112 compliant IPv4\nmulticast support, which is a prerequisite for running the\nDTS protocol. The platform currently consists of less than\n14000 lines of C code with an executable size of approxi-\nmately 48 Kbytes (Linux).\nThe platform implements the design as speci\ufb01ed in sec-\ntion 5. In addition, we have implemented three key perfor-\nmance optimisations: piggybacking of DELETE and AC-\nCESS messages, IN message suppression in the face of\ncongestion and static linking of single applications with\nthe L2imbo daemon. These optimisations are considered in\nmore detail below.\n5.4.1. Piggybacking of DELETE and ACCESS messages\nSince it is acceptable to delay the DELETE and AC-\nCESS messages generated by in and rd operations, proto-\ncol overhead can be saved by piggybacking these messages\non other protocol messages. In the current implementa-\ntion a single DELETE or ACCESS message can be pig-\ngybacked on any other message (including other DELETE\nor ACCESS messages) by setting a \ufb02ag in the message\nheader and prepending the payload before that of the origi-\nnal message. This optimisation reduces the overhead due to\nprotocol headers and, more signi\ufb01cantly, spreads the time\nspent in the select and recvfrom\/sendto system\ncalls.\n5.4.2. IN message suppression\nIn the protocol speci\ufb01cation presented earlier both IN\nand OUT messages are propagated. On a lightly loaded\nnetwork this is advantageous because it enables the creator\nof a tuple to nominate as an owner a process which has a\ncurrentlypendingIN request. However, in the face of bursts\nof message exchanges between processes it is advantageous\nto suppress the propagation of IN messages since the nomi-\nnated owner can be determined based on prior interactions.\nIn the current prototype the propagation of IN messages is\ncontrolled automatically by monitoring the interarrival time\nof protocol messages from a given host.\n5.4.3. Static linking of single applications with the L2imbo\ndaemon\nThe \ufb01nal optimisation we have made in the implemen-\ntation relates to the case when a single application on\na host is utilising the L2imbo platform. In this special\ncase, it is possible to link the application into the platform\nwith some minor modi\ufb01cations. The single process ver-\nsion (combined platform and application) will out perform\nthe separate process version due to the reduction in context\nswitching and interprocess communication overhead. Al-\nthough this optimisation has limited applicability in most\ncases, we are planning to experiment with a mechanism\nby which applications can inject trusted stub code into the\nplatform to behave as a proxy for the application for certain\ntuple interactions. The stub code could then be executed\nwithout necessitating expensive interactions with the appli-\ncation. This approach has been demonstrated in systems\nsuch as Sumo [7] which allow trusted client code to be run\nin response to QoS upcalls from the platform. Note that\nsuch code must be trusted or suitable precautions must be\ntaken to enable this mechanism to be safely generalised (for\ninstance, a safe operating environment could be provided\nsuch as safe-TCL or Java).\n6. Analysis\nAs stated earlier, the tuple space paradigm was origi-\nnally designed to operate in shared memory multiprocessor\narchitectures where the inherent time and space decoupling\nenables transparent service rebinding and load balancing\nbetween processors. We believe that the time and space\ndecoupling present in the model also has relevance in the154 N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing\nmobile computing domain and provides an effective and\nconsistent way of dealing with the migration, failure and\ndisconnection of mobile hosts. However, a consistent con-\ncern raised regarding the tuple space paradigm is the dif\ufb01-\nculty of developing an ef\ufb01cient distributed implementation.\nIn this section we consider the performance of L2imbo in\na \ufb01xed network environment in order to address these con-\ncerns (the performance of L2imbo over a wide range of\nwireless communications technologies including TETRA,\nGSM and WaveLAN is the subject of our current research).\nThe performance of tuple space implementations is usu-\nally governed by two factors, i.e., the speed with which\ntuples and anti-tuples can be matched and the speed with\nwhich tuples can be removed from the tuple space. As a\nconsequence, RPC style interaction is a worst-case scenario\nfor any tuple space implementation because the communi-\ncation is directed (and hence matching must take place on\neach interaction) and the relevant tuples must be removed\nby each party in the communication. Furthermore, RPC\nstyle test programs do not typically include in their perfor-\nmance \ufb01gures the time the client takes to locate and bind\nto the test service.\nNew applications designed for L2imbo are unlikely to\nrely heavily on RPC style communications. However, since\nmany existing applications do use RPC style programming\nmodels we consider it important that the L2imbo platform\nis able to approximate RPC semantics with reasonable ef\ufb01-\nciency. In the next section we compare L2imbo to a number\nof well known RPC based platforms.\n6.1. Test con\ufb01guration\nThe test suite consists of three separate pairs of client\nand server processes which carry out timed RPC interac-\ntions using raw UDP sockets, the ANSAware distributed\nsystems platform (version 4.1) [2] and the L2imbo proto-\ntype, respectively. In the case of L2imbo, the RPC inter-\naction is modelled by a server process which executes an\nin operation for a tuple of type request. When the in op-\neration has been satis\ufb01ed the server out\u2019s a tuple of type\nreply and continues with the next in operation. The client\nsimply outputs a succession of request tuples, waiting for\na reply between each one.\nThe test suite was compiled on two host\/OS environ-\nments, i.e., PCs running Linux 2.0 and Sun Sparcstations\nrunning SunOS 4.1 both with IP multicast support compiled\nin. Both pairs of machines are networked with 10 Mbps\nEthernet and are located on the same, though separate, sub-\nnets. The versions of the sockets and L2imbo test software\nwere identical on both hardware platforms. However, while\nthe ANSAware platform used on the Suns is a standard re-\nlease, the ANSAware platform used in the Linux environ-\nment is our own port based on the SunOS distribution and\ncontains a number of low-level performance enhancements\n[15].\nTo isolate the additional overhead we incur for splitting\nthe L2imbo platform into separate processes, we have run\ntests for both the optimised (linked into a single executable)\nand unoptimised (separate process) forms of the client and\nserver.\n6.2. Test results and analysis\nThe client and server processes were timed over 1000\nRPCs (or equivalent). Each RPC consists of a call with the\nspeci\ufb01ed payload size and a null reply. Each test was run\nten times and averaged to obtain the results presented in\ntables 3 and 4. All timing \ufb01gures can be viewed dually as\nthe time taken in seconds to complete each test or the time\nin milliseconds for a single interaction.\nThe \ufb01gures in table 3 clearly demonstrate that in the\nmajority of cases L2imbo clients and servers outperform\ntheir ANSAware counterparts. The only exception to this\nis when L2imbo clients and servers are running as sepa-\nrate processes and the packet sizes are small (i.e., less than\n2 K). In these cases the overhead of the additional context\nswitching and local communication required in L2imbo has\na signi\ufb01cant impact on the \ufb01gures. Reducing to a mini-\nmum the overheads associated with exchanging messages\nbetween the stubs and the daemon process is clearly an im-\nportant factor in improving the performance of L2imbo. In\nall cases the integrated L2imbo client\/server pairs outper-\nforms ANSAware.\nTable 4 presents the test results for the Sun versions of\nthe test suite and uses the reference version of the AN-\nSAware platform. The \ufb01gures clearly show that in the op-\ntimised form L2imbo outperforms ANSAware in all cases.\nHowever, the context switch and additional local messag-\ning exacts a heavy toll, further reinforcing the need for\nimproved application and daemon interprocess communi-\ncation.\nTable 3\nComparison of relative performance on Linux.\nPayload (bytes) Sockets ANSAware 4.1 Limbo DTS Limbo DTS\n(UDP) (REX) (linked) (separate\nprocesses)\n256 0.98 2.73 1.90 3.13\n512 1.30 3.06 2.30 3.54\n1024 1.96 3.72 3.09 4.35\n2048 3.02 5.81 4.46 5.92\n4096 4.95 20.12 6.93 9.26\n8192 8.67 40.09 11.48 14.83\nTable 4\nComparison of relative performance on SunOS (vanilla ANSAware).\nPayload Sockets ANSAware 4.1 Limbo DTS Limbo DTS\n(bytes) (UDP) (REX) (linked) (separate\nprocesses)\n256 2.98 7.10 6.53 12.58\n512 3.45 10.48 7.20 13.47\n1024 3.93 11.17 8.64 15.10\n2048 5.85 13.14 11.97 20.28\n4096 9.46 21.14 18.06 28.26\n8192 15.83 34.83 29.93 44.82N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing 155\nThe \ufb01gures taken on Linux additionally suggest that\nL2imbo performs comparably to other established RPC\nbased platforms such as COOL, a CORBA based platform\ndeveloped by Chorus Syst` emes [6]. The COOL bench-\nmark report quotes 3.8 ms for a basic request exchange\nof 1000 bytes in each direction on a similar speci\ufb01cation\nLinux platform. The linked version of L2imbo takes 4.4 ms\nto perform this same test (averaged over 1000 interactions).\nFurthermore, for interactions of 100 bytes in each direction,\nCOOL is quoted as taking 2.6 ms, whereas the optimised\nform of L2imbo takes just 1.9 ms (we attribute this as being\ndue to L2imbo\u2019s use of UDP whereas COOL uses TCP as\nthe RPC transport mechanism).\n7. Concluding remarks\nCurrent distributed systems platforms designed for mo-\nbile environments are based on synchronous, connection-\noriented communications with associated QoS monitoring\nand management. In this paper we have argued that such\nplatforms are not well suited to use in emerging heteroge-\nneous mobile environments. We have described L2imbo,\na new platform based on an alternative programming par-\nadigm, i.e., tuple spaces. Given the time and space de-\ncoupling inherent in the tuple space model we believe the\nparadigm provides an interesting approach that addresses\nmany of the shortcomings of existing mobile support plat-\nforms. In particular, the platform offers an asynchronous\nprogramming model and an architecture for reporting and\npropagating QoS information relating to all aspects of the\nsystem.\nWe have described in detail the design and implementa-\ntion of the L2imbo platform and have presented the results\nof our initial performance analysis. This shows that L2imbo\nis able to performcomparablyto RPC based platformswhen\nsupporting bursts of intensive directed communications, the\ntraditional worst-case scenario for a tuple space platform.\nWe are now developinga number of applications to exer-\ncise the L2imbo platform. More speci\ufb01cally, we are devel-\noping a suite of applications to support collaborative work\nby members of the emergency services. This suite of ap-\nplications will include a GIS based application which will\nenable users to collaboratively view and annotate geograph-\nical data as well as a number of applications which process\ncontinuous media. The network bearer for this work will\ninitially be WaveLAN but the applications will be ported to\nTETRA and GSM in the long term. Through this process\nwe hope to gain experience not only of using L2imbo for\nlarge-scale application development but also of operating\nL2imbo over a network with substantially different charac-\nteristics to our current environment.\nAcknowledgements\nThe work described in this paper was carried out under\nthe auspices of the \u201cSupporting Reactive Services in a Mo-\nbile Computing Environment\u201d project (EPSRC Grant No.\nGR\/K11864). The authors would like to thank the anon-\nymous referees whose comments have helped shape this\npaper.\nReferences\n[1] APM Ltd., ANSA: An engineers introduction to the architecture,\nTechnical Document release TR.03.02, Architecture Projects Man-\nagement Ltd., Cambridge, UK (November 1989).\n[2] APM Ltd., An introduction to ANSAware 4.0, Architecture Projects\nManagement Ltd., Cambridge, UK (February 1992).\n[3] R. Bjornson, N. Carriero, D. Gelernter, T. Mattson, D. Kamin-\nsky and A. Sherman, Experience with Linda, Technical Report\nYALEU\/DCS\/TR-866, Department of Computer Science, Yale Uni-\nversity, New Haven, CT (August 1991).\n[4] P. Butcher, A. Wood and M. Atkins, Global synchronisation in Linda,\nConcurrency: Practice and Experience 6(6) (1994) 505\u2013516.\n[5] N. Carriero, D. Gelernter and L. Zuck, Bauhaus Linda, in: Selected\nPapers from ECOOP \u201994, Bologna, Italy (July 1994) pp. 66\u201376.\n[6] Chorus Syst` emes, CHORUS\/COOL-ORB Programmer\u2019s Guide,\nTechnical Report CS\/TR-96-2.1, Chorus Syst` emes (1996).\n[7] G. Coulson, G.S. Blair, P. Robin and D. Shepherd, Extending the\nchorus micro-kernel to support continuous media applications, in:\nProc. NOSSDAV \u201993, Lancaster House, Lancaster, UK (November\n1993) pp. 49\u201360.\n[8] A. Danthine, Y. Baguette, G. Leduc and L. L\u00b4 eonard, The OSI 95\nconnection-mode transport service \u2013 The enhanced QoS, in: Proc.\n4th IFIP Conference on High Performance Networking,L i e g e ,B e l -\ngium (December 14\u201318, 1992) pp. 232\u2013252.\n[9] N. Davies, G.S. Blair, K. Cheverst and A. Friday, Supporting adap-\ntive services in a heterogeneous mobile environment, in: Proc.\nMCSA \u201994, Santa Cruz, CA (December 8\u20139, 1994) pp. 153\u2013157.\n[10] N. Davies, G.S. Blair, K. Cheverst and A. Friday, Experiences of\nusing RM-ODP to build advanced mobile applications, Distributed\nSystems Engineering Journal 2(3) (1995) 142\u2013151.\n[11] N. Davies, S. Pink and G.S. Blair, Services to support distributed\napplications in a mobile environment, in: Proc. SDNE \u201994, Prague,\nCzech Republic (June 1994) pp. 84\u201389.\n[12] L. Delgrossi, R.G. Herrtwich, C. Vogt and L.C. Wolf, Reservation\nprotocols for internetworks: A comparison of ST-II and RSVP, in:\nProc. NOSSDAV \u201993, Lancaster House, Lancaster, UK (November\n1993) pp. 199\u2013207.\n[13] S. Floyd, V. Jacobson, S. McCanne, C. Liu and L. Zhang, A reliable\nmulticast framework for light-weight sessions and application level\nframing, in: Proc. ACM SIGCOMM \u201995, Cambridge, MA (August\n1995) pp. 342\u2013356.\n[14] A. Friday and N. Davies, Distributed systems support for mobile\napplications, in: Proc. IEE Symposium on Mobile Computing and\nits Applications, Savoy Place, London (November 24, 1995) 6\/1\u20136\/3.\n[15] A.J. Friday, G.S. Blair, K.W.J. Cheverst and N. Davies, Extensions\nto ANSAware for Advanced Mobile Applications, in: Proc. ICDP\n\u201996, Dresden, Germany (February 27\u2013March 1, 1996).\n[16] D. Gelernter, Generative communication in Linda, ACM Transac-\ntions on Programming Languages and Systems 7(1) (1985) 80\u2013112.\n[17] D. Gelernter, N. Carriero, S. Chandran and S. Chang, Parallel pro-\ngramming in Linda, in: Proc. International Conference on Parallel\nProcessing (August 1985) pp. 255\u2013263.\n[18] B. Gr\u00a8 onvall, I. Marsh and S. Pink, A multicast-based distributed\n\ufb01le system for the internet, in: Proc. 7th ACM SIGOPS European\nWorkshop, Connemara, Ireland (September 2\u20134, 1996).\n[19] S. Hupfer, Melinda: Linda with multiple tuple spaces, Technical Re-\nport YALEU\/DCS\/RR-766, Department of Computer Science, Yale\nUniversity, New Haven, CT (February 1990).156 N. Davies et al. \/ L2imbo: A distributed systems platform for mobile computing\n[20] ISO draft recommendation X.901: Basic reference model of open\ndistributed processing, Part 1: Overview and guide to use, Draft\nReport (1992).\n[21] ISO\/IEC 13235-1\/ITU recommendation X.950, Open distributed\nprocessing \u2013 trading function: Speci\ufb01cation (March 1997).\n[22] ISO international standard ITU-T recommendation X.903: Open dis-\ntributed processing reference model, Part 3: Architecture, Standard\nRecommendation ISO\/IEC 10746-3, ISO WG7 Committee (January\n1995).\n[23] A.D. Joseph, A.F. deLespinasse, J.A. Tauber, D.K. Gifford and\nM.F. Kaashoek, Rover: A toolkit for mobile information access,\nin: Proc. SOSP \u201995, Copper Mountain Resort, CO (December 3\u20136,\n1995) pp. 156\u2013171.\n[24] R.H. Katz, Adaptation and mobility in wireless information systems,\nIEEE Personal Communications 1(1) (1994) 6\u201317.\n[25] R. Katz, E. Brewer, E. Amir, H. Balakrishnan, A. Fox, S. Gribble,\nT. Hodes, D. Jiang, G. Nguyen, V. Padmanabhan and M. Stemm, The\nbay area research wireless access network (BARWAN), in: Proc.\nIEEE COMPCON Spring \u201996, Santa Clara, CA (February 25\u201328,\n1996).\n[26] J.S. Leichter, Shared tuple memories, shared memories, buses and\nLANs \u2013 Linda implementations across the spectrum of connectivity,\nPh.D. thesis, Department of Computer Science, Yale University, New\nHaven, CT (July 1989).\n[27] N.H. Minsky and J. Leichter, Law-governed Linda as a coordination\nmodel, in: Selected Papers from the Workshop on Models and Lan-\nguages for Coordination of Parallelism and Distribution, Bologna,\nItaly (June 1994) pp. 125\u2013146.\n[28] J. Nieh and M. Lam, Integrated processor scheduling for multimedia,\nin: Proc. NOSSDAV \u201995, Durham, NH (April 19\u201321, 1995).\n[29] B.D. Noble, M. Price and M. Satyanarayanan, A programming inter-\nface for application-aware adaptation in mobile computing, in: Proc.\nMLIC \u201995, Ann Arbor, MI (April 10\u201311, 1995) pp. 57\u201366.\n[30] J. Pasquale, G. Polyzos, E. Anderson and V. Kompella, Filter propa-\ngation in dissemination trees: Trading off bandwidth and processing\nin continuous media networks, in: Proc. NOSSDAV \u201993, Lancaster\nHouse, Lancaster, UK (November 1993) pp. 269\u2013278.\n[31] J. Pinakis, Providing directed communication in Linda, in: Proc.\n15th Australian Computer Science Conference, Hobart, Tasmania\n(January 1992).\n[32] W.N. Schilit, A system architecture for context-aware mobile com-\nputing, Ph.D. thesis, Department of Computer Science, Columbia\nUniversity, New York, NY (1995).\n[33] B. Schilit, N. Adams and R. Want, Context-aware computing appli-\ncations, in: Proc. MCSA \u201994, Santa Cruz, CA (December 8\u20139, 1994)\npp. 85\u201390.\n[34] A. Schill and S. K\u00a8 ummel, Design and implementation of a support\nplatform for distributed mobile computing, Distributed Systems En-\ngineering Journal 2(3) (1995) 128\u2013141.\n[35] N. Yeadon, Quality of service \ufb01lters for multimedia communications,\nPh.D. thesis, Lancaster University, Lancaster, UK (May 1996).\n[36] N. Yeadon, F. Garcia, D. Hutchison and D. Shepherd, Filters: QoS\nsupport mechanisms for multipeer communications, IEEE Journal on\nSelected Areas in Communications 14(7) (1996) 1245\u20131262.\nNigel Davies graduated from Lancaster University\nin 1989 and later that year joined the Comput-\ning Department as a research associate investigat-\ning storage and management aspects of multime-\ndia systems. As a result of his work in this area\nhe was awarded a Ph.D. in 1994. After a spell\nas a visiting researcher at the Swedish Institute\nof Computer Science (SICS), where he worked on\nmobile \ufb01les systems, he returned to Lancaster, \ufb01rst\nas site-manager for the MOST mobile computing\nproject and subsequently as a lecturer in the Computing Department. His\ncurrent research interests include mobile computing, distributed systems\nplatforms and systems support for multimedia communications. He is a\nmember of ACM.\nE-mail: nigel@comp.lancs.ac.uk\nAdrian Friday graduated from the University of\nLondon in 1991. The following year he moved\nto Lancaster and participated in the MOST project\ninvolving Lancaster University and E.A. Technol-\nogy. In 1996 he was awarded a Ph.D. for his\nwork on \u201cInfrastructure Support for Adaptive Mo-\nbile Applications\u201d and is currently a research as-\nsistant in the Computing Department.\nE-mail: adrian@comp.lancs.ac.uk\nStephen Wade has been a research student in\nthe Computing Department since graduating from\nLancaster University in 1995. He is an active par-\nticipant in the \u201cSupporting Reactive Services in\na Mobile Computing Environment\u201d project and is\nworking towards his Ph.D. on \u201cUsing an Asyn-\nchronous Paradigm for Mobile Distributed Com-\nputing\u201d.\nE-mail: spw@comp.lancs.ac.uk\nGordon Blair is currently a Professor in the Com-\nputing Department at Lancaster University. He\ncompleted his Ph.D. in computing at Strathclyde\nUniversity in 1983. Since then, he was a SERC\nResearch Fellow at Lancaster University before\ntaking up a lecturership in 1986. He has been\nresponsible for a number of research projects at\nLancaster in the areas of distributed systems and\nmultimedia support and has published over a hun-\ndred papers in his \ufb01eld. His current research inter-\nests include distributed multimedia computing, operating system support\nfor continuous media, the impact of mobility on distributed systems and\nthe use of formal methods in distributed systems development. He is a\nmember of ACM.\nE-mail: gordon@comp.lancs.ac.uk"}