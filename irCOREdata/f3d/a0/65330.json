{"doi":"10.1007\/978-3-540-31862-0_15","coreId":"65330","oai":"oai:dro.dur.ac.uk.OAI2:6228","identifiers":["oai:dro.dur.ac.uk.OAI2:6228","10.1007\/978-3-540-31862-0_15"],"title":"An automatic mapping from Statecharts to Verilog.","authors":["Viet-Anh, T. V.","Qin, S.","Chin, W.-N."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Liu, Z.","Araki, K."],"datePublished":"2004-09-24","abstract":"Statecharts is a visual formalism suitable for high-level system specification, while Verilog is a hardware description language that can be used for both behavioural and structural specification of (hardware) systems. This paper implements a semantics-preserving mapping from Graphical Statecharts to Verilog programs, which, to the best of our knowledge, is the first algorithm to bridge the gap between Statecharts and Verilog, and can be embedded into the hardware\/software co-specification process [19] as a front-end","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65330.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6228\/1\/6228.pdf","pdfHashValue":"931d0f1bcb8d29f9e60621da72f672ef1ce9bb67","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6228<\/identifier><datestamp>\n      2015-03-31T12:00:03Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        An automatic mapping from Statecharts to Verilog.<\/dc:title><dc:creator>\n        Viet-Anh, T. V.<\/dc:creator><dc:creator>\n        Qin, S.<\/dc:creator><dc:creator>\n        Chin, W.-N.<\/dc:creator><dc:description>\n        Statecharts is a visual formalism suitable for high-level system specification, while Verilog is a hardware description language that can be used for both behavioural and structural specification of (hardware) systems. This paper implements a semantics-preserving mapping from Graphical Statecharts to Verilog programs, which, to the best of our knowledge, is the first algorithm to bridge the gap between Statecharts and Verilog, and can be embedded into the hardware\/software co-specification process [19] as a front-end.<\/dc:description><dc:publisher>\n        Springer <\/dc:publisher><dc:source>\n        Liu, Z. & Araki, K. (Eds.). (2004). Theoretical computing : 1st International Colloquium, ICTAC 2004, 20-24 September 2004, Guiyang, China ; revised selected papers. Berlin: Springer , pp. 187-203, Lecture notes in computer science(3407)<\/dc:source><dc:contributor>\n        Liu, Z.<\/dc:contributor><dc:contributor>\n        Araki, K.<\/dc:contributor><dc:date>\n        2004-09-24<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6228<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/978-3-540-31862-0_15<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6228\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/978-3-540-31862-0_15<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6228\/1\/6228.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/978-3-540-31862-0_15<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2004,"topics":[],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nViet-Anh, T. V. and Qin, S. and Chin, W.-N. (2004) \u2019An automatic mapping from Statecharts to Verilog.\u2019, in\nTheoretical computing : 1st International Colloquium, ICTAC 2004, 20-24 September 2004, Guiyang, China ;\nrevised selected papers. Berlin: Springer , pp. 187-203. Lecture notes in computer science. (3407).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/b107116\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nViet-Anh, T. V. and Qin, S. and Chin, W.-N. (2004) 'An automatic mapping from Statecharts \nto Verilog.', in Theoretical computing : 1st International Colloquium, ICTAC 2004, 20-24 \nSeptember 2004, Guiyang, China ; revised selected papers. Berlin: Springer , pp. 187-203. \nLecture notes in computer science. (3407). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/b107116 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nAutomatic Mapping from Statecharts to Verilog\nViet-Anh Vu Tran1, Shengchao Qin2,3 and Wei Ngan Chin2,3\n1 Vietsoftware Company, Hanoi, Vietnam\ntran.vu.viet.anh@vietsoftware.com\n2 Singapore-MIT Alliance\n3 National University of Singapore\n{qinsc,chinwn}@comp.nus.edu.sg\nAbstract. Statecharts is a visual formalism suitable for high-level system spec-\nification, while Verilog is a hardware description language that can be used for\nboth behavioural and structural specification of (hardware) systems. This paper\nimplements a semantics-preserving mapping from Graphical Statecharts to Ver-\nilog programs, which, to the best of our knowledge, is the first algorithm to bridge\nthe gap between Statecharts and Verilog, and can be embedded into the hard-\nware\/software co-specification process [19] as a front-end.\n1 Introduction\nStatecharts [6, 7] is a visual formalism catering for high-level behaviourial specification\nof embedded systems. Its hierarchical structure, orthogonal and broadcast communica-\ntion features make the system specification compact and intuitive to understand. It is\na very good candidate for executable specification in system design [8]. Moreover, the\nsemantics of Statecharts has been extensively investigated [9, 12, 14, 15, 13] in recent\nyears. Some works also attempt to provide tools for formal verification of Statecharts\nspecifications [4], [14], [20].\nVerilog [22], [17] is a widely used language for hardware description in industry [2],\n[5], [11], [10] and also in research. Verilog is used to model the structure and behaviour\nof digital systems ranging from simple hardware building block to complete systems.\nVerilog semantics is based on the scheduling of events and the propagation of changes.\nOne early attempt to investigate the semantics of Verilog is the work of Gordon [5]\nwhich explains how top-level modules can be simulated.\nA Verilog program (or specification, as it is more frequently referred to) is a de-\nscription of a device or process rather similar to a computer program written in C or\nPascal. However, Verilog also includes constructs specifically chosen to describe hard-\nware. One major difference from a language like C is that Verilog allows processes to\nrun in parallel. This is obviously very desirable if one is to exploit the inherently paral-\nlel behaviour of hardware. In this work, we will make use of abstract Verilog [10], [18],\nthat is described in the next chapter.\nOn the other hand, Verilog is a hardware description language that has been widely\nused by hardware designers. Its rich features make it a good candidate for low\u2013level\nsystem specifications. The formal semantics of Verilog was first given by Gordon [5] in\nterms of simulation cycles. It has been thoroughly investigated afterwards [25], [24].\nAs the advantages of Statecharts and Verilog in embedded system design process\nare complementary to each other, a natural question that can be raised is, can we make\nuse of both of them in system design? That is, can we use Statecharts as the high level\nspecification, while use Verilog as the low level description? This question has mo-\ntivated our work and this paper shall provide a positive answer by bridging the gap\nbetween Statecharts and Verilog. The compilation from Statecharts to Verilog can be\nembedded into the hardware\/software co-specification process [19]. A mapping algo-\nrithm will be given in the following sections, where the soundness has been given in\nQin and Chin [18].\nThe rest of this paper is organized as follows. Sec 2 gives a brief introduction to\nStatecharts and Verilog. Sec 3 presented the formal definition of the mapping function,\nfollowed by its implementation in Sec 4. Sec 5 illustrates our mapping results using two\nexamples, while Sec 6 concludes the paper.\n2 Preliminaries\n2.1 Formal syntax of statecharts\nStatecharts is a specification language derived from finite-state machines. The lan-\nguage is rather rich in features including state hierarchy and concurrency. Transitions\ncan perform nontrivial computations unlike finite-state machines where they contain at\nmost input\/output pairs. In this section we will describe Statecharts presented by David\nHarel [6], [7], [9].\nStatechart diagrams capture the behaviour of entities capable of dynamic behaviour\nby specifying their responses to the event occurrences. Typically, it is used for describ-\ning the behaviour of classes, but statecharts may also describe the behaviour of other\nmodel entities such as use cases, actors, subsystems, operations, or methods.\nWe use a simple textual representation of Statecharts, while our system can auto-\nmatically translate a graphical representation to the textual representation. The state-\ncharts language we adopt has some features that are not present in UML statecharts.\nFor example, broadcast communication is supported in our language but not in UML\nstatecharts.\nAs already mentioned in previous section, Statecharts is extensible by hierarchy,\northogonality or broadcast communication. In this paper, we use the formal syntax of\nstatechart from [7] and [18]. The syntax of Statecharts formula is defined as follows\n(quoting from [18]):\nS : a set of names used to denote Statecharts. This is expected to be large enough to\nprevent name conflicts.\n\u03a0e : a set of all abstract events (signals). We also introduce another set \u03a0 e to denote\nthe set of negated counterparts of events in \u03a0e , i.e. \u03a0 e =df {e | e \u2208 \u03a0e}, where e\ndenotes the negated counterpart of event e, and we assume e = e.\n\u03a0a : a set of all assignment actions of the form v = exp.\n\u03c3 : V ar \u2192 V al is the valuation function for variables, where V ar is the set of all\nvariables, V al is the set of all possible values for variables. A snapshot for variables v\nis \u03c3(v).\nT : a set of transitions, which is a subset of S \u00d7 2\u03a0e\u222a\u03a0 e \u00d7 2\u03a0e\u222a\u03a0a \u00d7 Be \u00d7 S,\nwhere Be is the set of boolean expressions.\nA term-based syntax of statecharts was introduced in [18] and [14], [15]. We re-\nintroduce it here for the benefit of the reader. The set SC is a set of Statecharts terms\nthat is constructed by the following inductively defined functions.\nBasic : S \u2192 SC\nBasic(s) =df |[s]|\nOr : S \u00d7 [SC] \u00d7 T \u2192 SC\nOr(s, [p1, ..., pl, ..., pn], pl, T ) =df |[s : [p1, ..., pl, ..., pn], pl, T ]|\nAnd : S \u00d7 2SC \u2192 SC\nAnd(s, {p1, ..., pn}) =df |[s : {p1, ..., pn}]|\nNote that:\n\u2013 Basic(s) : denotes a basic statechart named s.\n\u2013 Or(s, [p1, ..., pl, ..., pn], pl, T ) : represents an Or-statechart with a set of sub-states\n{p1, ..., pn}, where p1 is the default sub-state, pl is the current active sub\u2013state, T is\ncomposed of all possible transitions among immediate sub-states of s.\n\u2013 And(s, {p1, ..., pn}) is an And-statechart named s, which contains a set of orthogonal\n(concurrent) sub-states {p1, ..., pn} .\nIn this paper we use sub-state interchangeable as children of Or-state. Correspond-\ningly, we use children and region of And-state interchangeably. For statecharts that we\nadopted in this work, we shall assume that each And-state will have at least two regions.\nFurthermore, each region shall be an Or-state.\nWe shall take the textual representation of statecharts as input data for our core\nmapping program. Our front-end algorithm will translate graphic charts to textual rep-\nresentation automatically. As an example, we give below a simple graphical Statechart\nand its corresponding textual representation.\nP0\r\nP1\r\nP2\r\nP1a\r P1b\r\nP2a\r\nP2b\r P2c\r\nt2: b (true)\r\nt3: c (true)\r\nt1: a (true)\r\nP0 = |[ S1: P1, P2 ]|\nP1 = |[ S2: [ P1a, P1b ], P1a, t1 ]|\nP2 = |[ S3: [ P2a, P2b, P2c ], P2a, t2, t3 ]|\nP1a = |[ S4 ]|\nP1b = |[ S5 ]||\nP2a = |[ S6 ]|\nP2b = |[ S7 ]|\nP2c = |[ S8 ]|\nt1 = < P1a, a , , true, P1b >\nt2 = < P2a, b , , true, P2a >\nt3 = < P2b, c , , true, P2c >\nFig. 1. A simple example of a Statechart and its textual representation.\n2.2 Verilog\nVerilog is a hardware description language that has been widely used in industry. Al-\nthough the Verilog IEEE standard [22] was released around ten years ago, the formal\nsemantics based on simulation cycles [5] has not been well-investigated until recently,\ne.g. [11], [10]. In our work, we shall use a behaviourial subset of Verilog introduced in\n[10] and [18]. This more abstract version of Verilog can be used to express designs at\nvarious levels of hardware behaviour. Such an abstract design can be gradually refined\ninto an equivalent counterpart in the Verilog HDL which can provide a closer match\nto the underlying architecture of the hardware. This process may be repeated until the\ndesign is at a sufficiently lower level such that the hardware device can be synthesised\nfrom it. There are two main features in abstract Verilog that are not present in Verilog\nHDL, namely guarded choice extension and recursion. The translation from general\nguarded choices to parallel composition in normal Verilog is achievable, although non-\ntrivial. The conversion of recursion to iteration is harder but there exists standard con-\nversion techniques to realise some subsets of them. Furthermore, for bounded recursion,\nit is possible to inline the abstract Verilog code so as to remove recursion.\nA Verilog program can be a parallel or a sequential process, but only parallel process\nmay contain sequence processes, not vice-versa. Here are some categories of syntactic\nelements:\n1. Parallel process\nP ::= S | P \u2016 P\nwhere, S is a sequential process.\n2. Sequential process can be formally described as following\nS ::= PC (primitive command) | S;S (sequential composition)\n| s \u0001 b \u0003 S (condition) | b \u2217 S (iteration)\n| (b&g S) [] ... [] (b&g S) (guarded choice) | fix X \u2022 S (recursion)\nwhere, b is boolean condition, and\nPC ::= skip | sink | \u22a5 | \u2192 \u03b7 (output event) | v = ex (assignment)\ng ::=\u2192 \u03b7 | @(x = v) (assignment guard))\n| #1 (time delay) | eg (event control)\neg ::= \u03b7 | eg & eg | eg & \u00aceg\n\u03b7 ::= \u2191 v (value rising) | \u2193 v (value falling) | e (a set of abstract events)\nRecall that a Verilog program can only be a parallel process at the top level, a se-\nquential process cannot contain a parallel process. However, most real systems contain\nmany parallel processes possibly organised hierarchically. To solve this restriction, we\nshall use algebraic laws [10] to expand a parallel process into a sequential one.\nHere are some simple code examples:\n\u2013 (e & (\u2192 f) sink) [] (g & (\u2192 h) sink)\n\u2013 \u00b5X \u2022 (e (f X) )\n\u2013 (a & (\u2192 e) sink) \u2016 (b & (\u2192 f) sink)\n3 Semantic-Preserving Mapping\nOur algorithm that takes as input graphical statecharts and generates as output Verilog\ncode is based on the theoretical result presented in [18]. This mapping algorithm works\nin a top-down manner starting from the root of the statechart and then moving to its\nchildren. Each time, we consider the input statechart (each part of Statecharts) as a\nsingleton statechart and continue until no further applicable.\nWe present the mapping function L as originally proposed in [18] which produces\nresult based on the type of the source statechart:\nDefinition of mapping function L:\nL : SC \u2192 Verilog\nmaps any statechart description into a corresponding Verilog process. It keeps un-\nchanged the set of variables employed by the source description, i.e.,\n\u2200sc \u2208 SC \u2022 vars(L(sc)) = vars(sc)\nand it is inductively defined as follows.\n\u2013 For a statechart sc = |[s]| constructed by Basic, L maps its input into an idle\nprogram sink which can do nothing but let time advance, i.e.,\nL(sc) =df sink\n\u2013 For a statechart sc = |[s : {p1, ..., pn}]| constructed by And, L maps its input into\na parallel construct in Verilog.\nL(sc) =df \u20161\u2264i\u2264n L(pi)\n\u2013 For a statechart sc = |[s : [p1, ..., pn], pl, T ]| constructed by Or, we define L\nby exhaustively figuring out the first possible transitions of sc if any, otherwise it\nreturns sink.\nL(sc) =df\n{\nsink if T \u2217(sc) = \u2205\nP otherwise\nwhere\nP =df []0\u2264k\u2264or-depth(sc) []{b\u03c4k & g\ni\n\u03c4k\n& (&0\u2264j\u2264k hj) & g\n0\n\u03c4k\nL(resc(\u03c4k, sc)) |\n\u03c4k \u2208 T (activek(sc)) \u2227 src(\u03c4k) = activek+1(sc) \u2227\nhj = &{\u00acgi\u03c4 | \u03c4 \u2208 T (active\nj\u22121(sc)) \u2227 src(\u03c4) = activej(sc)}}\nand\nactive0(sc) =df sc\nactive1(sc) =df active(sc)\nactivei+1(sc) =df active(active\ni(sc))\nFor each statechart, we always assume each of its variables has bounded range,\nand the set of possible events is finite, which implies that the set of its configurations\nis finite. Therefore, the set of configurations (under transition relation) forms a well\u2013\nfounded quasi order, which indicates the mapping function L is terminating.\nFollowing are some formal notations used in the above definition. Firstly, the func-\ntion or-depth : SC \u2192 N to calculate the \u201cor\u2013depth\u201d of a statechart, which is defined as\nfollows:\n- for a statechart sc = |[s]| constructed by Basic, or-depth(sc) =df 0;\n- for a statechart sc = |[s : [p1, ..., pn], pl, T ]| constructed by Or, or-depth(sc) =df\nor-depth(pl) + 1;\n- for a statechart sc = |[s : {p1, ..., pn}]| constructed by And, or-depth(sc) =df\n1.\nThe or-depth of an Or-chart just records the depth of the path transitively along its\nactive Or-sub-states. We stop going further once an And-state is encountered. The or-\ndepth of an And-chart is simply 1.\nSecondly, the source and target state functions, src(\u03c4) and tgt(\u03c4), respectively repre-\nsent the source and target state of a transition \u03c4 . Given a transition \u03c4 = &1\u2264k\u2264m\u03c4ik \u2208\nT , where \u03c4ik \u2208 T \u2217(pik), for 1 \u2264 k \u2264 m, and i1, ..., in is a permutation of 1, ..., n, we\ndefine its source and target state as follow:\nsrc(\u03c4) =df (q1, ..., qn), where qik = src(\u03c4ik ), for 1 \u2264 k \u2264 m, and qik =\nactive(pik), for m < k \u2264 n;\ntgt(\u03c4) =df (r1, ..., rn), where rik = tgt(\u03c4ik ), for 1 \u2264 k \u2264 m, and rik =\nactive(pik), for m < k \u2264 n.\nNote that T \u2217(p) contains all possible transitions inside p along its transitive ac-\ntive sub-state chain, i.e., T \u2217(p) =df {\u03c4 | \u03c4 \u2208 T \u2227 src(\u03c4) = pl} \u222a T \u2217(pl). And\nactive(sc) denotes a current active sub-state of sc. With an Or-statechart sc = |[s :\n[p1, ..., pn], pl, T ]|, we have active(sc) = pl. With an And-statechart sc = |[s :\n{p1, ..., pn}]|, we have the active state as a vector of the active states of these con-\nstituents, i.e., active(sc) =df (active(p1), ..., active(pn)).\nThirdly, we need to know the resulting statechart after a transition is taken. When a\ntransition \u03c4 occurs, any involved statechart can have changes in its (transitive) active\nsub-states. We use a function:\nresc : T \u00d7 SC \u2192 SC\nto return the modified statechart after performing a transition in a statechart. It is defined\ninductively with regard to the type of the statechart.\n- for a Basic-statechart sc, and any transition \u03c4 , resc(\u03c4, sc) =df sc;\n- for an Or-statechart sc = |[s : [p1, ..., pn], pl, T ]|, and a transition \u03c4 ,\nresc(\u03c4, sc) =df\n\uf8f1\uf8f2\n\uf8f3\nsc[l 7\u2192a2d(tgt(\u03c4))], if \u03c4 \u2208 T \u2227 src(\u03c4) = pl;\nsc[l 7\u2192resc(\u03c4,pl)], if \u03c4 \u2208 T\n\u2217(pl);\nsc, otherwise.\n- for an And-statechart sc = |[s : {p1, ..., pn}]|, and a transition \u03c4 ,\nresc(\u03c4, sc) =df\n{\nsc\u03c4 , if \u03c4 = &1\u2264k\u2264m\u03c4ik \u2208 T (sc);\nsc, otherwise.\nwhere sc\u03c4 = sc[q1\/p1, ..., qn\/pn] is the statechart obtained from sc via re-\nplacing pi by qi, for 1 \u2264 i \u2264 n, qik = resc(\u03c4ik , pik), for 1 \u2264 k \u2264 m, and\nqik = pik , for m < k \u2264 n.\nThe function a2d(sc) is used to change the active sub-state of sc into its default\nsub-state, and the same change is applied to its new active sub-state. This function is\ndefined as:\n- a2d(|[s]|) =df |[s]|\n- a2d(|[s : [p1, ..., pn], pl, T ]|) =df |[s : [p1, ..., pn], a2d(p1), T ]|\n- a2d(|[s : {p1, ..., pn}]|) =df |[s : {a2d(p1), ..., a2d(pn)}]|\nThe substitution sc[l 7\u2192pm] for an Or-statechart sc = |[s : [p1, ..., pn], pl, T ]| is defined\nby sc[l 7\u2192pm] =df |[s : [p1, ..., pn], pm, T ]|\n4 Implementation\nOur implementation consists of two parts: a statechart editor (called Statechart E, is\na stencil of MS Visio) and a mapping program from statechart into abstract Verilog\n(called AMSV-Automatic Mapping of Statechart into Verilog).\nStatechart\r\ndrawing\r\n(Statechart_E)\r\nMapping\r\n(AMSV)\r\ntexture\r\nrepresentation\r\nCode\r\ngeneration\r\n(AMSV)\r\nabstract\r\nVerilog\r\nFig. 2. Structure of the implementation.\nFig. 2 shows the stages of using our system. Users first draw their statecharts, using\nStatechart E, which also automatically generates the corresponding textual representa-\ntions. AMSV will then generate abstract Verilog code from textual representation of\nthese statecharts. In next two sections, we will discuss about Statechart E, AMSV, and\nsome other techniques used in the system.\n4.1 Statechart editor\nStatechart E is built with three main purposes:\n\u2013 First, of course is for editing Statechart diagrams. The editor should be convenient\nto use and easy to draw.\n\u2013 Second, it should also be easy to export textual representation of statechart. This is\nused by the mapping algorithm which converts statechart to abstract Verilog.\n\u2013 Last, it should be easy to save the statecharts to other graphical formats (like bmp,\njpg, ps, eps, etc) This is important for portability and for documentation.\nFrom these requirements, we built Statechart E as an add-on\/embedded stencil in\nMicrosoft Visio. We make use of MS. Visio because Visio is a very powerful graphical\neditor tool for drawing diagrams. Visio also supports many graphical formats for export-\ning our diagrams. Moreover, using Visio, we can not only draw statechart components\nbut also other shapes from suitable drawing types or stencils.\nFeatures of Statechart E:\n\u2013 A menu named Statechart is added to the menu bar of Visio. This menu contains\ntwo functions, namely: Generate statechart and Add new statechart page. The first\nfunction is used to export the current statechart to a textual file. This file is used as\ninput for the mapping program which to transform to abstract Verilog. The second\nfunction is used to add a new page for current statechart diagram. To enable this\nmenu and its functions, users must allow a macro to be accepted when opening the\nstencil.\n\u2013 A set of masters is added to the stencil and this is used for constructing statecharts.\nIt consists of a state master, a default master (common for all kind of states), 8 tran-\nsition masters (to help build complex statecharts), and vertical\/horizontal separators\nfor And-state.\n\u2013 Each master is accompanied by a program written in Visual Basic for Application\n(VBA) to check data, events and perform actions of each master. Some masters\nare linked to a window to allow input of needed data. This program also partially\nchecks the supplied data such as duplicate name, etc.\n\u2013 We also allow users to build hierarchical statecharts. Users can easily extend a given\nstatechart by adding a new page (using the second function in menu Statechart)\nand continue to extend the current statechart in a hierarchical manner in the new\npage. Note that the generate function will read all components in all pages of the\nstatechart.\n4.2 AMSV - Core mapping program\nThe second part, called AMSV (Automatic Mapping of Statechart into Verilog), is es-\nsentially a Java program.\nDFS algorithm As presented in section 3, the mapping algorithm has to deal with\neach state; Basic, And, and Or states. It can construct the corresponding Verilog\ncode after the mapping algorithm has been applied to all states of the source statechart.\nNevertheless, how do we traverse all states of the input statechart? In the AMSV, we\nmake use of depth\u2013first\u2013search (DFS) algorithm [3] to reach all states of the statechart.\nHowever, DFS works on each tree of nodes. To apply DFS we have to reconstruct\nthe source statechart into a tree of states. Fig. 3 shows an example of hierarchy tree (b)\nfor a simple statechart (a). Here, dashed arrows denote the children of an And-state (like\narrow from P0 to P1, P2), while the doted arrows point to the active sub-states of Or-\nstate (like arrow from P1 to P3 or P2 to P6). The solid arrows represent the transitions.\nP0\r\nP1\r\nP3\r\nP4\r\nP2\r\nP6\r\nP7\r\nt3: e3\r\nP5\r\nt\r 2\r:\r\n \n\r e\r2\rt\r1\n\r:\r \re\n\r1\r\nt\r4\r:\n\r \re\n\r4\r\nP8\r\nP9\rt5: e5\r\na)\nP0\r\nP1\r\nP3\r\nP4\r\nP2\r\nP6\r\nP7\rP5\r\nP8\r P9\r\nP0\r\nP1\r\nP3\r\nP4\r\nP2\r\nP6\r\nP7\rP5\r\nP8\r P9\r\nb) c)\nFig. 3. Hierarchy tree. a) Statechart example, b) hierarchy tree, and c) DFS route.\nAfter reconstructing each statechart into a hierarchy tree, we apply a recursive func-\ntion which maps each statechart to abstract Verilog. At each time, we only consider one\nstate, called the current state. Through this recursive function, we apply the mapping\nalgorithm to all states of the source statechart to obtain Verilog process code. These\ncodes are kept in a hash table for latter use. After that, we gather the output code (from\nsub-states or from target states of all transitions to the current state) to generate final\nabstract Verilog process.\nFor example, in the Fig. 3, first we start from the root state (like P0). After that, we\ninvoke the function itself if it is possible to go to current state\u2019s children (P1, P2) or\ntarget states of transitions (P3 to P4, P5). A systematic way of finding the next state is\ndescribed below. Fig. 3 c shows the route taken by our DFS traversal:\n\u2013 each state is the target of transition: If there exists any transition from the current\nstate, go to the target state of the transition. Like transitions from P3 to P4 or P5.\nThe information of the transition will be memorized to generate output code. If\nthere are more than one transitions from current state, process it one by one. The\norder between these transitions is not important.\n\u2013 each state is a child of the And-state: If the current state is And-state, go to all\nchildren. Like from P0 to P1 or P2. Information of children in that And-state will\nbe memorized during code generation, as acquired by the Verilog language.\n\u2013 state is sub-state of Or-state: Just go to active state and continue as before. For\nexample, P3 and P6 are the active states of P1 and P2.\nRecursion During the traversal to the states of a given statechart, it is possible for a\ntransition to re-occur. This may be due to non-termination. To solve this problem we\nuse a boolean array to remember all states which the program has already encountered.\nIf a program reaches a marked state, it just uses that information to generate a loop, and\nthen go back to previous state. This is meant to terminate a recursive transition.\nParallel expansion Recall from early discussion in Sec 2, we shall take into account\nthe parallel expansion of And-state. Whenever an And-state is reached, all information\n(guards, conditions, etc) of the children of a current state are used for expansion. The\nonly exception is when the current state is the root. In this case we generate Verilog\ncode from all its children and gather it using the parallel operation (\u2016). This situation\nwas discussed in [23].\n5 Examples\nIn this section, we illustrate the mapping algorithm via the following examples: a CD\nplayer and a washing machine.\n5.1 CD-player\nSpecification Fig. 4 shows the graphical statechart of a CD-player. It contains two or-\nthogonal regions: Play control (PlayCtr) and Track information (TrackCtr), which\nare used to control the playing mode and record the track information respectively. The\nfirst region contains Stop, Play, Pause sub-states to control the playing mode,\nwhile the second one contains only a sub-state, Track. Three buttons, Next, Prev,\nand select a track, are associated with the Track state. The variable ct (that is,\ncurrent track) is used to keep record of the current position of the CD being played. We\nassume ct is initially 0 whenever the CD-player is switched on.\nIn this model, Stop and Track are respectively two default sub-states of two\northogonal regions. So when the CD-Player is switched on, both of them are entered\nsimultaneously. Upon the arrival of event Play pressed (that is, the Play button is\npressed), transition t1 is taken and state PlayingCtr is entered, where the default\nsub-state Playing becomes active. Transitions t4 and t3 are used to alter between\nstate Playing and Paused. Transition t2 connects state PlayingCtr with state\nStop. When the control is in state PlayingCtr (either Playing or Paused), and\nt2 is enabled, it will yield the Stop state (that is, the CD-player will stop).\nIn the orthogonal state TrackCtr, upon the arrival of events Next pressed or\nPrev pressed, the variable ct (current track) will be changed according to the event.\nConditions (ct > 1) and (ct < Max(track)) are used to check the range of the ct. The\ntransition t7 is taken if users select any track in the range.\nCD-Player-ON\r\nPlayCtr\r TrackCtr\r\nStop\r\nt\r1\r:\r \rP\n\rl\ra\ry\r_\n\rp\rr\re\rs\n\rs\re\rd\n\r\n \n\r\/\r \rc\rt\r=\n\r1\r\n(\rt\rr\ru\re\n\r)\r\nt\r2\r:\r \n\rS\rt\ro\rp\r_\n\r\np\rr\re\rs\rs\re\rd\r\n \n\r\/\r \n\rc\rt\r=\r1\r\n(\rt\rr\ru\re\r)\r\nPlayingCtr\r\nPlaying\r\nPaused\r\nt\r3\r:\r \rP\n\rl\ra\ry\r_\n\rp\rr\re\n\rs\rs\n\re\n\rd\r (\rt\rr\ru\re\r)\r\nt\r 4\r :\r  \n\r P\r a\r u\r s\r e\n\r _\n\r p\r r\r e\n\r s\r s\r e\r d\r\n(\r t\r r\r u\r e\n\r )\r\nTrack\r\nt5: Next_pressed \/ ct=ct+1\r\n(ct<max(track))\r\nt\r 7\r :\r  \n\r T\r r\ra\n\r c\r k\r _\n\r s\r e\n\r l\r e\r c\r t\r  \n\r\n\/\r  \n\r c\r t\r =\n\rt\r r\r s\r l\r\n(\r 0\r <\n\r c\r t\r <\n\r m\n\r a\r x\r (\r t\r r\r a\r c\rk\r )\r +\n\r 1\r )\rt6: Prev_pressed \/\rct=ct-1 (ct>1)\r\nFig. 4. CD player with track information (ct).\nFor simplicity, we only added track information in this specification of a CD-player.\nA real CD-player may contain other functionalities, like timer, forward, rewind, etc. We\ncan add these setting as parallel regions in a similar way.\nAfter drawing the statechart specification in Statechart E, the following textual rep-\nresentation is automatically generated:\nCD-Player-ON = |[ S1: { PlayCtr, TrackCtr } ]|\nPlayCtr = |[ S2: [ Stop, PlayingCtr ], Stop, { t1, t2 } ]|\nTrackCtr = |[ S3: [ Track ], Track, { t5, t7, t6 } ]|\nStop = |[ S4 ]|\nPlayingCtr = |[ S5: [ Playing, Paused ], Playing, { t3, t4 } ]|\nPlaying = |[ S6 ]|\nPaused = |[ S7 ]|\nTrack = |[ S8 ]|\nt1 = < Stop, { Play_pressed }, { ct=1 }, true, PlayingCtr >\nt2 = < PlayingCtr, { Stop_pressed }, { ct=1 }, true, Stop >\nt3 = < Paused, { Play_pressed }, { }, true, Playing >\nt4 = < Playing, { Pause_pressed }, { }, true, Paused >\nt5 = < Track, { Next_pressed }, { ct=ct+1 }, ct<max(track),\nTrack >\nt7 = < Track, { Track_select }, { ct=trsl }, 0<ct<max(track)+1,\nTrack >\nt6 = < Track, { Prev_pressed }, { ct=ct-1 }, ct>1, Track >\nThe first 8 lines are information of states. The rest are transitions.\nResult The textual representation given in last section is taken as the input of our\nalgorithm AMSV, the output we obtain is the following code in abstract Verilog:\nResult:\nL_PlayCtr || L_TrackCtr\nWhere:\nL_PlayCtr = fix X0. ( L_Stop )\nL_TrackCtr = fix X2. (\n( ( ( Next_pressed & @( ct=ct+1 ) & ( ct<max(track) ) X2 )\n[] ( Track_select & @( ct=trsl ) & ( 0<ct<max(track)+1 ) X2 ) )\n[] ( Prev_pressed & @( ct=ct-1 ) & ( ct>1 ) X2 ) ) )\nL_Stop = ( ( Play_pressed & @( ct=1 ) )\n( ( Stop_pressed & @( ct=1 ) X0 ) [] fix X1. ( L_Playing ) ) )\nL_Playing = ( ( Pause_pressed & not Stop_pressed )\n( ( ( Play_pressed & not Stop_pressed ) X1 )\n[] ( Stop_pressed & @( ct=1 ) X0 ) ) )\nnote that we use fix (rather than \u00b5) to denote the recursion. L state is the correspond-\ning result from state.\nHere we can see that the L PlayCtrl and L TrackCtr are processes which are running\nin parallel, where the recursive identifiers X0, X1, X2 represent three loop points.\n5.2 Washing machine\nSpecification In this subsection, we discuss a washing machine with five setting func-\ntions;Timer, Hot water, Rinse level,Water level, andPre-wash. Fig. 5\nshows the user interface of the washing machine. Fig. 6 gives the statechart specifica-\ntion of the washing machine corresponding to the interface, while Fig. 7 zooms into\nthe sub-state Washing-Ctr. Statechart in Fig. 6 contains six parallel regions corre-\nsponding to five setting functions and the washing progress (Wash-Ctr). Each setting\nregion contains a sub-statechart to change the value of its function. For example, in the\nTimer-Ctr region, the variable tm denotes the time that the washing machine has to\nwait before it starts to wash. It can be changed by Inc or Dec buttons. Other variables\nhw (hot water), rl (rinse level), wl (water level) and pw (pre-wash) are similar, and can\nbe changed via pressing corresponding buttons. The default values of these variables\nare shown in Fig. 5 with black circles (hw = 0, rl = 0, wl = 0, and pw = 0) and\ndefault timer is 0.\nStart\r\nPre-\r\nwash\r\nWater\r\nlevel\r\nYes\r\nNo\r Normal\r\nHalf\r\nFull\r\nRinse\r\nLight\r\nMedium\r\nExtra\r\nHot\r\nwater\r\nCold\r\nWarm\r\nHot\r\nInc\r\nDec\r\n  0 h\r\nFig. 5. Interface of the washing machine.\nWashing-machine-ON\r\nWash-Ctr\r\nIdle\r\nWashing-Ctr\r\nt1: Start \/ washing=true\r\n(true)\r\nTimer-Ctr\r\nTimer\r\nt\r5\r:\r \rt\ri\rm\re\rr\r-\ri\rn\rc\rr\re\ra\rs\re\r\n \r\/\r \rt\rm\r=\rt\rm\r+\r1\r\n(\rt\rm\r<\r1\r0\r\n \r&\r \rw\ra\rs\rh\ri\rn\rg\r=\rf\ra\rl\rs\re\r)\r\nt6: timer-decrease \/ tm=tm-1\r\n(tm>1 & washing=false)\r\nWater-Ctr\r\nNormal\r Half\r\nFull\r\nt10: Water-\r\npressed \/ wl=1\r\n(true)\r\nt\r1\r1\n\r:\r \rW\n\ra\rt\re\n\rr\r-\n\rp\rr\n\re\rs\n\rs\re\n\rd\r \r \/\n\r\nw\n\rl\r=\r2\n\r \r(\rt\rr\n\ru\re\n\r)\r\nt\r1\r2\r:\r \n\rW\n\ra\rt\re\rr\r-\n\rp\rr\re\rs\rs\re\rd\r \n\r\/\r\nw\n\r l\r=\n\r0\r \n\r(\rt\rr\ru\re\r)\r\nLight\r Medium\r\nExtra\r\nt7: Rinse-pressed \/\r\nrl=1 (true)\r\nt\r8\r:\n\r \rR\n\ri\rn\rs\n\re\r-\n\rp\rr\re\n\rs\rs\n\re\rd\n\r\n \n\r\n\/\r\nr\rl\r=\n\r2\r  \r(\r\nt\r r\ru\n\re\r)\r\nt\r9\r:\r \n\rR\ri\rn\rs\re\r-\n\rp\rr\re\rs\rs\re\rd\r\n \n\r\/\r\nr\rl\r=\n\r0\r \n\r(\rt\rr\ru\re\r)\r\nPrewash-Ctr\r\nPre-w-no\r Pre-w-yes\r\nt13: Pre-wash \/ pw=1\r\n(washing=false)\r\nt14: Pre-wash \/ pw=0\r\n(washing=false)\r\nHotwater-Ctr\r\nCold\r\nWarm\r\nHot\r\nt\r2\r:\r \n\rH\ro\rt\r-\n\rw\ra\rt\re\rr\r \n\r\/\r\nh\rw\r=\n\r1\r\n \n\r(\rt\rr\ru\re\r)\r\nt\r3\r:\r \rH\n\ro\rt\r-\rw\n\ra\rt\re\rr\n\r \r\/\r\nh\rw\r=\n\r2\r \r(\rt\rr\ru\n\re\r)\r\nt\r4\r:\r \rH\n\ro\rt\r-\rw\n\ra\n\rt\re\rr\r \r\/\r\nh\rw\n\r=\n\r0\r \r(\rt\rr\ru\re\n\r)\r\nRinse-Ctr\r\nFig. 6. Main statechart of a washing machine.\nThe Washing-Ctr is an Or-state as given in Fig. 7. The state Check-wait is\nactivated once state Washing-Ctr is entered. If tm is greater than 0, the machine\nkeeps waiting for tm time before the control moves to Pre-wash state. The transition\nt18 calculates the value of the variable washtime based on the pre-wash setting. For\nexample, if pw is 0 then washtime = 1. The variablewashtime is used to keep record\nof the time that the clothes have been washed so far. It is explained as follows:\n\u2013 washtime = 0: if pw = 1, need pre-wash.\n\u2013 washtime = 1: if pw = 0, no need pre-wash, need powder, no spin.\n\u2013 washtime = 2 or 3: wash without powder, spin.\n\u2013 washtime > 3: finish.\nUpon finishing, the machine beeps to inform the user.\nThe textual representation generated from Statechart E is printed in [23].\nStart-washing\r\nWait\rt15:  \/ timer-cal\r(tm>0)\r\nt\r1\r6\r:\r \n\r\n \n\r\n\/\r \rc\rh\re\n\rc\rk\r-\rp\rr\n\re\r-\rw\n\ra\rs\rh\r\n(\rt\rm\r=\r0\n\r)\rPre-wash\r\nWashing\r\nwater-in\r\ncold-w\r warm-w\r hot-w\r\nt\r2\r2\r :\n\r \r \r\/\r \rc\rh\n\re\rc\rk\n\r-\rw\r l\r\n(\rh\rw\r=\n\r0\r )\r\nt\r2\r4\r:\r \n\r\n \n\r\n\/\r\n \n\r\nc\rh\re\rc\rk\r-\n\rw\rl\r(\rh\rw\r=\r2\r)\rt23:  \/ check-wl\r(hw=1)\r\nwashing\r\nt\r2\r5\r :\r \n\r \n\r\/\r \n\rs\rt\ra\rr\r t\r-\n\rw\ra\rs\rh\r\n(\r t\rr\ru\re\r )\r t\r2\r7\r:\r \r \r\/\n\r \rs\rt\ra\rr\n\rt\r-\rw\ra\n\rs\rh\r\n(\rt\rr\ru\re\r)\n\r\nt26:  \/ start-wash\r\n(true)\r\nwater-out\r\nt28:  \/ washtime=washtime+1 (true)\r\nPowder-in\r\nt18:  \/ washtime=1-pw (true)\r\nSpin\r\nt29:  \/ start-spin (washtime>1)\r\nWash-end\r\nt31:  \/ Beep-finish\r\n(washtime=4)\r\nCheck-wait\r\nt17:  \/ check-pre-wash\r\n(tm=0)\r\nt19: fill-water\r\n(washtime!=1)\r\nt\r2\r0\r :\r \r\n \n\r\n\/\r\n \n\rg\re\r t\r-\rp\ro\rw\rd\re\rr\r-\ri\rn\r(\rw\ra\rs\rh\ri\rn\rg\rt\r i\rm\re\r=\r1\r)\r\nt\r3\r0\r:\r \r \r\/\n\r  \rr\re\rw\ra\r\ns\rh\r\n(\rw\ra\rs\rh\rt\n\ri\rm\r e\r<\r\n4\r)\r\nt\r2\r1\r:\r \rf\r i\rl\rl\r-\rw\n\ra\rt\re\rr\r \r(\rt\rr\ru\re\n\r)\r\nFig. 7. Statechart of Washing-Ctr in the washing machine.\nResult We then run the AMSV algorithm to generate the Verilog program for the\nwashing machine. We only give some part of the target code here.\nFirst of all, let us regard Washing-Ctr as a basic state (before we zoom into it). We\nhave the following Verilog program:\nResult:\nL_Wash-Ctr || L_Timer-Ctr || L_Water-Ctr || L_Prewash-Ctr ||\nL_Hotwater-Ctr || L_Rinse-Ctr\nWhere:\nL_Wash-Ctr = L_Idle\nL_Idle = ( Start & @( washing=true ) sink )\nL_Timer-Ctr =\nfix X0. ( ( ( timer-increase & @( tm=tm+1 ) &\n( tm<10 & washing=false ) X0 )\n[] ( timer-decrease & @( tm=tm-1 ) &\n( tm>1 & washing=false ) X0 ) ) )\nL_Water-Ctr = fix X1. ( L_Normal )\nL_Normal = ( ( Water-pressed & @( wl=1 ) ) L_Half )\nL_Half = ( ( Water-pressed & @( wl=2 ) )\n( Water-pressed & @( wl=0 ) X1 ) )\nL_Light = ( ( Rinse-pressed & @( rl=1 ) ) L_Medium )\nL_Medium = ( ( Rinse-pressed & @( rl=2 ) )\n( Rinse-pressed & @( rl=0 ) X4 ) )\nL_Prewash-Ctr = fix X2. ( L_Pre-w-no )\nL_Pre-w-no = ( ( Pre-wash & @( pw=1 ) & ( washing=false ) )\n( Pre-wash & @( pw=0 ) & ( washing=false ) X2 ) )\nL_Hotwater-Ctr = fix X3. ( L_Cold )\nL_Cold = ( ( Hot-water & @( hw=1 ) ) L_Warm )\nL_Warm = ( ( Hot-water & @( hw=2 ) ) ( Hot-water & @( hw=0 ) X3 ) )\nL_Rinse-Ctr = fix X4. ( L_Light )\nThe sink process in L Idle is used to denote the Washing-Ctrl process, as we\nregard it as a basic state. On the other hand, if we consider Washing-Ctr as a stand-\nalone statechart, the corresponding code for it is as follows:\nResult:\nL_Check-wait =\n( ( ( & @( timer-cal ) & ( tm>0 ) ) L_Wait )\n[] ( ( & @( check-pre-wash ) & ( tm=0 ) ) L_Pre-wash ) )\nL_Start-washing =\n( ( ( fill-water & ( washtime!=1 ) ) L_water-in\n( & @( rewash ) & ( washtime<4 ) X0 ) )\n[] ( ( & @( get-powder-in ) & ( washingtime=1 ) ) L_Powder-in\n( & @( rewash ) & ( washtime<4 ) X0 ) ) )\nL_Wait = ( ( & @( check-pre-wash ) & ( tm=0 ) ) L_Pre-wash )\nL_Pre-wash = ( ( & @( washtime=1-pw ) )\nfix X0. ( ( ( & @( rewash ) & ( washtime<4 ) X0 )\n[] L_Start-washing ) ) )\nL_water-in =\n( ( ( ( & @( check-wl ) & ( hw=0 ) ) L_cold-w\n( & @( rewash ) & ( washtime<4 ) X0 ) )\n[] ( ( & @( check-wl ) & ( hw=2 ) ) L_hot-w\n( & @( rewash ) & ( washtime<4 ) X0 ) ) )\n[] ( ( & @( check-wl ) & ( hw=1 ) ) L_warm-w\n( & @( rewash ) & ( washtime<4 ) X0 ) ) )\nL_cold-w = ( ( & @( start-wash ) ) L_washing\n( & @( rewash ) & ( washtime<4 ) X0 ) )\nL_warm-w = ( ( & @( start-wash ) ) L_washing\n( & @( rewash ) & ( washtime<4 ) X0 ) )\nL_hot-w = ( ( & @( start-wash ) ) L_washing\n( & @( rewash ) & ( washtime<4 ) X0 ) )\nL_washing = ( ( & @( washtime=washtime+1 ) ) L_water-out\n( & @( rewash ) & ( washtime<4 ) X0 ) )\nL_water-out = ( ( & @( start-spin ) & ( washtime>1 ) ) L_Spin\n( & @( rewash ) & ( washtime<4 ) X0 ) )\nL_Powder-in = ( ( fill-water ) L_water-in\n( & @( rewash ) & ( washtime<4 ) X0 ) )\nL_Spin = ( & @( Beep-finish ) & ( washtime=4 ) sink\n( & @( rewash ) & ( washtime<4 ) X0 ) )\nIn the final code, the sink process in L Idle is replaced by the processL Check-wait.\n6 Conclusion\nIn this paper we proposed an automatic mapping algorithm to translate high-level Stat-\necharts into low-level Verilog specifications. Our algorithm has been proved sound ear-\nlier [18].\nThe system that we have built in Java provides a graphical interface for users to\ndraw their statecharts in MS Visio. Our mapping algorithm thus translates the graph-\nical representation into a textual representation, and then generates the corresponding\nVerilog programs.\nSome of related works on connecting Statecharts with other formalisms are pre-\nsented in [1, 4, 16, 21, 20]. Beauvais et.al. [1] and Seshia et.al. [21] translate STATEM-\nATE Statecharts to synchronous languages Signal and Esterel respectively, aiming to\nuse supporting tools provided in the target formalisms for formal verification purposes.\nHowever, all these translations are based on the informal semantics [9] lacking correct-\nness proofs. The authors of [4, 16] transform variants of Statecharts into hierarchical\ntimed automata and use tools (UPPAAL, SPIN) to model check Statecharts properties.\nMore recently, a translation from Statecharts to B\/AMN is reported in [20]. However,\nno correctness issue has been addressed. In comparison, the translation from Statecharts\nto Verilog in this paper aims at code generation for system design. The mapping func-\ntion that we implement in this paper is constructed based on formal semantics for both\nthe source and target formalisms and has been proven to be semantics-preserving [18].\nOur compilation from Statecharts into Verilog can be used as a front-end of hard-\nware design or hardware\/software co-design. After translating the input statechart spec-\nification into abstract Verilog code, we can proceed to obtain lower level descriptions,\nas a prelude to hardware implementation, or we can pass the Verilog specification to a\nhardware\/software partitioning system [19].\nIn order to provide the concrete Verilog programs to users, future works include\nguarded choices elimination and the replacement of the other structures of abstract Ver-\nilog, so that the AMSV can generate also concrete Verilog program. This should make\nour tool especially useful for hardware designer.\nReferences\n1. J.-R. Beauvais, et. al. A Translation of Statecharts to Signal\/DC+. Technical report, IRISA,\n1997.\n2. J. P. Bowen, J.-F. He, and Q.-W. Xu. An Animatable Operational Semantics of the VERILOG\nHardware Description Language. In Proc. ICFEM2000: 3rd IEEE International Conference\non Formal Engineering Methods, IEEE Computer Society Press, York, UK, September 2000.\n3. T. H. Cormena, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to Algorithms. MIT\nPress; 2nd edition, September 2001.\n4. A. David, M. Oliver Mo\u00a8ller, and Wang Y. Formal Verification of UML Statecharts with Real-\ntime Extensions. In Proc. of Fundamental Approaches to Software Engineering, number\n2306 in Springer LNCS, 2002.\n5. M. J. C. Gordon. The Semantic Challenge of Verilog HDL. In Proc. Tenth Annual IEEE\nSymposium on Logic in Computer Science, IEEE Computer Society Press, pages 136\u2013145,\nJune 1995.\n6. D. Harel. Statecharts: A Visual Formalism for Complex Systems. Science of Computer\nProgramming, 8, 1987.\n7. D. Harel. On Visual Formalisms. Communications of the ACM, 31(5), 1988.\n8. D. Harel and E. Gery. Executable Object Modeling with Statecharts. Computer, 30(7), 1997.\n9. D. Harel and A. Naamad. The STATEMATE Semantics of Statecharts. ACM Transactions\non Software Engineering and Methodology, 5(4), October 1996.\n10. J.-F. He. An Algebraic Approach to the VERILOG Programming. In Proc. of 10th An-\nniversary Colloquium of the United Nations University \/ International Institute for Software\nTechnology (UNU\/IIST). Springer, 2002.\n11. J.-F. He and H. Zhu. Formalising Verilog. In Proc. IEEE International Conference on\nElectronics, Circuits and Systems, IEEE Computer Society Press, Lebanon, December 2000.\n12. J.J.M. Hooman, S. Ramesh, and W.P. de Roever. A Compositional Axiomatization of State-\ncharts. Theoretical Computer Science, 101, 1992.\n13. Q. Long, Z.Y. Qiu, and S.C. Qin. The Equivalence of Statecharts. In International Confer-\nence on Formal Engineering Methods, number 2885 in Springer LNCS, Singapore, Novem-\nber 2003.\n14. G. Lu\u00a8ttgen, M. von der Beeck, and R. Cleaveland. A Compositional Approach to Statecharts\nSemantics. Technical Report 200012, NASA\/CR2000210086, ICASE Report, March 2000.\n15. A. Maggiolo-Schettini, A. Peron, and S. Tini. Equivalences of Statecharts. In 7th Interna-\ntional Conference on Concurrency Theory (CONCUR\u201996), number 1119 in Springer LNCS,\nPisa, Italy, August 1996.\n16. E. Mikk, Y. Lakhnech, M. Siegel, and G. Holzmann. Implementing Statecharts in\nPromela\/SPIN. In the 2nd IEEE Workshop on Industrial-Strength Formal Specification Tech-\nniques. IEEE Computer Society, 1999.\n17. Open Verilog International (OVI). Verilog Hardware Description Language Reference Man-\nual.\n18. S.C. Qin and W.N. Chin. Mapping Statecharts to Verilog for Hardware\/Software Co-\nSpecification. In K. Araki, S. Gnesi, and D. Mandrioli, editors, Formal Methods: Inter-\nnational Symposium of Formal Methods Europe, volume 2805, pages 282\u2013299. Springer,\n2003.\n19. S.C. Qin, J.F. He, Z.Y. Qiu, and N.X. Zhang. Hardware\/Software Partitioning in Verilog. In\nInternational Conference on Formal Engineering Methods, number 2495 in Springer LNCS,\nShanghai, China, October 2002.\n20. E. Sekerinski and R. Zurob. Translating Statecharts to B. In B. Butler, L. Petre, , and\nK. Sere, editors, Proc. of the 3rd International Conference on Integrated Formal Methods,\nnumber 2335 in Springer LNCS, Turku, Finland, 2002.\n21. S. Seshia, R. Shyamasundar, A. Bhattacharjee, and S. Dhodapkar. A Translation of State-\ncharts to Esterel. In J. Wing, J. Woodcock, and J. Davies, editors, FM99: World Congress on\nFormal Methods, number 1709 in Springer LNCS, 1999.\n22. IEEE Standard. IEEE Standard Hardware Description Language based on the Verilogr\nHardware Description Language. 1995.\n23. V.-A. V. Tran. Automatic Mapping from Statecharts to Verilog. Master\u2019s Thesis, School of\nComputing, The National University of Singapore, 2004.\n24. H. Zhu, J. P. Bowen, and J.-F. He. Deriving Operational Semantics from Denotational Se-\nmantics for Verilog. Technical report, Technical Report SBU-CISM-01-16, South Bank Uni-\nversity, London, UK, June 2001.\n25. H. Zhu, J. P. Bowen, and J.-F. He. From Operational Semantics to Denotational Semantics for\nVerilog. In Proc. CHARME 2001: 11th Advanced Research Working Conference on Correct\nHardware Design and Verification Methods, number 2144 in Springer LNCS, Livingston,\nScotland, September 2001.\n"}