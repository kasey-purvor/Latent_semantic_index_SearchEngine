{"doi":"10.1109\/ECRTS.2008.14","coreId":"192232","oai":"oai:lra.le.ac.uk:2381\/4191","identifiers":["oai:lra.le.ac.uk:2381\/4191","10.1109\/ECRTS.2008.14"],"title":"Exploring the Impact of Task Preemption on Dependability in Time-Triggered Embedded Systems: a Pilot Study.","authors":["Short, Michael J.","Pont, Michael J.","Fang, Jianzhong"],"enrichments":{"references":[{"id":44641172,"title":"A \u2018Hardware-in-the Loop\u2019 testbed representing the operation of a cruise-control system in a passenger car. In:","authors":[],"date":"2005","doi":null,"raw":"Ayavoo, D., Pont, M. J., Fang, J., Short, M., and Parker, S. A \u2018Hardware-in-the Loop\u2019 testbed representing the operation of a cruise-control system in a passenger car. In: Proceedings of the Second UK Embedded Forum (Birmingham, UK, October 2005), pp. 60-90, 2005. Published by University of Newcastle upon Tyne [ISBN: 0-7017-0191-9].","cites":null},{"id":44641167,"title":"A Method for Characterising a Microprocessor\u2019s Vulnerability to SEU.","authors":[],"date":"1988","doi":"10.1109\/23.25521","raw":"Elder J.H. A Method for Characterising a Microprocessor\u2019s Vulnerability to SEU. IEEE Trans. on Nuclear Science, Vol. 35, No. 6, December 1988.","cites":null},{"id":44641176,"title":"A relative performance monitor for process controllers.","authors":[],"date":"2003","doi":"10.1002\/acs.772","raw":"Li, Q., Whiteley, J.R., and Rhinehart, R.R. A relative performance monitor for process controllers. Int. Journal of Adaptive Control and Signal Processing, Vol. 17, pp. 685-708, 2003.","cites":null},{"id":44641179,"title":"An embedded software primer.","authors":[],"date":"1999","doi":null,"raw":"Simon, D.E. An embedded software primer. AddisonWesley, 1999. ISBN: 0-201-61569X.","cites":null},{"id":44641143,"title":"An engineering process for the verification of real-time systems.","authors":[],"date":"2007","doi":"10.1007\/s00165-006-0021-4","raw":"Burns, A. and Lin, T.M. An engineering process for the verification of real-time systems. Formal Aspects of Computing, Vol. 19, pp. 111-136, 2007.","cites":null},{"id":44641163,"title":"An Evaluation of the Error Detection Mechanisms in MARS Using Software-Implemented Fault Injection. In:","authors":[],"date":"1996","doi":"10.1007\/3-540-61772-8_31","raw":"Fuchs, E. An Evaluation of the Error Detection Mechanisms in MARS Using Software-Implemented Fault Injection. In: Proc. of the European Dependable Computing Conference, Springer-Verlag, Lecture Notes in Computer Science, Volume 1150, pp. 73-90, 1996.","cites":null},{"id":44641149,"title":"Applying new scheduling theory to static priority pre-emptive scheduling.","authors":[],"date":"1993","doi":"10.1049\/sej.1993.0034","raw":"Audsley, N., Burns, A., Richardson, M., Tindell, K., and Wellings, A. Applying new scheduling theory to static priority pre-emptive scheduling. Software Engineering Journal 8(5), pp. 284-292 September 1993.","cites":null},{"id":44641139,"title":"Computer Controlled Systems: Theory And Design.","authors":[],"date":"1997","doi":"10.1524\/auto.1985.33.112.432","raw":"Astrom, K. and Wittenmark, B. Computer Controlled Systems: Theory And Design. Prentice Hall, 1997. ISBN: 0133148998.","cites":null},{"id":44641166,"title":"Control-Flow Checking Via Regular Expressions. In:","authors":[],"date":"2001","doi":"10.1109\/ats.2001.990300","raw":"Benso, A., di Carlo, S., di Natale, G., Prinetto, P. and Tagliaferri, L. Control-Flow Checking Via Regular Expressions. In: Proc. IEEE Asian Test Symposium, pp. 299-303, 2001.","cites":null},{"id":44641138,"title":"Digital computer control systems.","authors":[],"date":"1991","doi":"10.1007\/978-1-349-21490-7","raw":"Virk, G.S. Digital computer control systems. McGrawHill, 1991. ISBN: 0070675120.","cites":null},{"id":44641175,"title":"Electronic Throttle Control \u2013 A Dependability Case Study.","authors":[],"date":"1999","doi":null,"raw":"Mauser, H. and Thurner, E. Electronic Throttle Control \u2013 A Dependability Case Study. Journal of Universal Computer Science, Vol. 5, No. 10, pp. 730 \u2013 741, 1999.","cites":null},{"id":44641150,"title":"Energy-aware strategies in real-time systems for autonomous robots. In:","authors":[],"date":"2004","doi":"10.1007\/978-3-540-30182-0_85","raw":"Buttazzo, G., Marinoni, M., and Guidi, G. Energy-aware strategies in real-time systems for autonomous robots. In: Proc. of the 19th International Symposium on Computer and Information Sciences (ISCIS 2004), Turkey, 2004.","cites":null},{"id":44641152,"title":"Engineering and analysis of fixed-priority schedulers.","authors":[],"date":"1993","doi":"10.1109\/32.241774","raw":"Katcher, D. I., Arakawa, H., and Strosnider, J. K. Engineering and analysis of fixed-priority schedulers. IEEE Trans. on Software Engineering, Vol. 19, No. 9, pp. 920-934, 1993.","cites":null},{"id":44641160,"title":"Establishing timing requirements for control loops in real-time systems.","authors":[],"date":"2003","doi":"10.1016\/s0141-9331(03)00015-2","raw":"Bate, I., McDermid, M. and Nightingale, P. Establishing timing requirements for control loops in real-time systems. Microprocessors and Microsystems, Vol. 27, pp. 159-169, 2003.","cites":null},{"id":44641164,"title":"Experimental Dependability Evaluation of the Artk68-FT Real-time Kernel. In:","authors":[],"date":"2004","doi":null,"raw":"Aidemark, J., Folkesson, P. and Karlsson, J. Experimental Dependability Evaluation of the Artk68-FT Real-time Kernel. In: Proc. of the International Conference on Real-Time and Embedded Computer Systems and Applications, G\u00f6teborg, Sweden, August 2004.","cites":null},{"id":44641162,"title":"Exploring the links between software architecture and PID parameters in embedded control systems. In:","authors":[],"date":null,"doi":null,"raw":"Fang, J. and Pont, M.J. Exploring the links between software architecture and PID parameters in embedded control systems. In: Proceedings of the 6th UKACC Control Conference, Glasgow, Scotland, 30 August to 1 September, 2006.","cites":null},{"id":44641168,"title":"Fault Injection for Dependability Validation\u2014A Methodology and Some Applications.","authors":[],"date":"1990","doi":"10.1109\/32.44380","raw":"Arlat, J., Aguera, M., Amat, L., Crouzet, Y., Fabre, J.-C., Laprie, J.-C., Martins, E. and Powell, D. Fault Injection for Dependability Validation\u2014A Methodology and Some Applications. IEEE Trans. Software Eng., vol. 16, no. 2, pp. 166-182, Feb. 1990.","cites":null},{"id":44641156,"title":"Fixed Priority Scheduling versus Pre-Run-Time Scheduling.","authors":[],"date":"2000","doi":null,"raw":"Xu, J. and Parnas, D.L. Fixed Priority Scheduling versus Pre-Run-Time Scheduling. Real-Time Systems, Vol. 18, pp. 7-23, 2000.","cites":null},{"id":44641182,"title":"Handbook - Reliability Prediction of Electronic Equipment. Department of Defence,","authors":[],"date":"1990","doi":null,"raw":"MIL-HDBK-217F. Military Handbook - Reliability Prediction of Electronic Equipment. Department of Defence, Washington DC, 1990.","cites":null},{"id":44641173,"title":"Hardware in the loop simulation of embedded automotive control systems. In:","authors":[],"date":"2005","doi":"10.1109\/itsc.2005.1520052","raw":"Short, M. J. and Pont, M. J. Hardware in the loop simulation of embedded automotive control systems. In: Proceedings of the 8th IEEE International Conference on Intelligent Transportation Systems (IEEE ITSC 2005) held in Vienna, Austria, pp. 226-231, 2005.","cites":null},{"id":44641169,"title":"Implementation and evaluation of failsafe computercontrolled systems.","authors":[],"date":"2002","doi":"10.1016\/s0360-8352(02)00031-1","raw":"Ting, Y., Shan, F.M., Lu, W.B. and Chen, C.H. Implementation and evaluation of failsafe computercontrolled systems. Computers & Industrial Engineering, Vol. 42, pp. 401-415, 2002.","cites":null},{"id":44641148,"title":"Introduction to real-time software design.","authors":[],"date":"1981","doi":"10.1007\/978-1-4612-4610-7_1","raw":"Allworth, S. Introduction to real-time software design. Springer-Verlag, 1981.","cites":null},{"id":44641158,"title":"Maximizing the Stability Radius of a Set of Systems Under Real-Time Scheduling Constraints.","authors":[],"date":"2005","doi":"10.1109\/tac.2005.858639","raw":"Palopoli, L., Pinello, C., Bicchi, A. and SangiovanniVincentelli, A. Maximizing the Stability Radius of a Set of Systems Under Real-Time Scheduling Constraints. IEEE Transactions on Automatic Control, Vol. 50, No. 11, pp. 1790-1795, 2005.","cites":null},{"id":44641137,"title":"Modern control technology: components and systems.","authors":[],"date":"2000","doi":null,"raw":"Kilian, C.T. Modern control technology: components and systems. Delmar Thomson Learning, 2000. ISBN: 076682358X.","cites":null},{"id":44641144,"title":"On Inspection and Verification of Software with Timing Requirements.","authors":[],"date":"2003","doi":"10.1109\/tse.2003.1223645","raw":"Xu, J. On Inspection and Verification of Software with Timing Requirements. IEEE Transactions on Software Engineering, Vol. 29, No. 8, pp. 705-720, 2003.","cites":null},{"id":44641154,"title":"Patterns for time-triggered embedded systems: Building reliable applications with the 8051 family of microcontrollers.","authors":[],"date":"2001","doi":null,"raw":"Pont, M. J. Patterns for time-triggered embedded systems: Building reliable applications with the 8051 family of microcontrollers. ACM Press \/ Addison-Wesley, 2001. ISBN: 0-201-331381.","cites":null},{"id":44641178,"title":"Priority Inheritance Protocol: An approach to real-time synchronization.","authors":[],"date":"1990","doi":"10.1109\/12.57058","raw":"Sha, L., Rajkumar, R., and Lehoczky, J. P. Priority Inheritance Protocol: An approach to real-time synchronization. IEEE Trans. On Computers 39: 1175-1185, 1990.","cites":null},{"id":44641147,"title":"Reducing jitter in embedded systems employing a time-triggered software architecture and dynamic voltage scaling.","authors":[],"date":"2006","doi":"10.1109\/tc.2006.29","raw":"Phatrapornnant, T. and Pont, M. J. Reducing jitter in embedded systems employing a time-triggered software architecture and dynamic voltage scaling. IEEE Transactions on Computers, 55 (2): 113-124, 2006.","cites":null},{"id":44641170,"title":"Reliability in engineering design.","authors":[],"date":"1977","doi":"10.1016\/0026-2714(80)90524-7","raw":"Kapur, K.C. and Lamberson, L.R. Reliability in engineering design. New York: Wiley & Sons, 1977.","cites":null},{"id":44641140,"title":"Safety Critical Computer Systems.","authors":[],"date":"1996","doi":null,"raw":"Storey, N. Safety Critical Computer Systems. Addison Wesley Publishing, 1996.","cites":null},{"id":44641142,"title":"Scheduling algorithms for multiprogramming in a hard real-time environment.","authors":[],"date":"1973","doi":"10.1016\/b978-155860702-6\/50016-8","raw":"Liu and, C. L. and Layland, J. W. Scheduling algorithms for multiprogramming in a hard real-time environment. Journal of the ACM 20(1), 1973.","cites":null},{"id":44641141,"title":"Scheduling and Timing Analysis for Safety Critical Real-Time Systems. PhD Dissertation,","authors":[],"date":"1998","doi":null,"raw":"Bate, I.J. Scheduling and Timing Analysis for Safety Critical Real-Time Systems. PhD Dissertation, University of York, U.K., November 1998.","cites":null},{"id":44641181,"title":"Single Event Effects in Avionics.","authors":[],"date":"1996","doi":"10.1109\/23.490893","raw":"Normand, E. Single Event Effects in Avionics. IEEE Trans. on Nuclear Science, Vol. 43, No. 2, 1996.","cites":null},{"id":44641146,"title":"Software architecture for hard real-time applications: Cyclic executives vs. fixed priority executives.","authors":[],"date":"1992","doi":"10.1007\/bf00365463","raw":"Locke, C. D. Software architecture for hard real-time applications: Cyclic executives vs. fixed priority executives. Real-Time Systems, 4(1): 37-52, 1992.","cites":null},{"id":44641180,"title":"Software-based self-testing of microprocessors.","authors":[],"date":"2006","doi":"10.1016\/j.sysarc.2005.05.004","raw":"Sosnowski, J. Software-based self-testing of microprocessors. Journal of Systems Architecture, Vol. 52, pp. 257-271, 2006.","cites":null},{"id":44641174,"title":"Sudden acceleration \u2013 the myth of driver error.","authors":[],"date":null,"doi":null,"raw":"Castelli, J., Nash, C., Ditlow, C. and Pecht, M. Sudden acceleration \u2013 the myth of driver error. University of Maryland, CALCE EPSC Press, ISBN 0-9707174-5-8.","cites":null},{"id":44641145,"title":"The cyclic executive model and Ada.","authors":[],"date":"1989","doi":"10.1109\/real.1988.51108","raw":"Baker, T. P. and Shaw, A. The cyclic executive model and Ada. Real-Time Systems, Vol. 1, No. 1, pp. 7-25, 1989.","cites":null},{"id":44641177,"title":"The design of a pre-emptive scheduler for the C167 Microcontroller.","authors":[],"date":"2006","doi":null,"raw":"Fang, J. The design of a pre-emptive scheduler for the C167 Microcontroller. Technical Report ESL 06\/01, University of Leicester, 2006.","cites":null},{"id":44641171,"title":"The Impact of Workload On The Dependability Of Microprocessors Used In Control Applications. MSC Thesis,","authors":[],"date":"1996","doi":null,"raw":"Krishnan, R.V. The Impact of Workload On The Dependability Of Microprocessors Used In Control Applications. MSC Thesis, University of Illinois at UrbanaChampaign, USA, 1996.","cites":null},{"id":44641165,"title":"Transient detection in COTS processors using software approach.","authors":[],"date":"2006","doi":"10.1016\/j.microrel.2004.10.013","raw":"Rajabzadeh, A. and Miremadi, S.G. Transient detection in COTS processors using software approach. Microelectronics Reliability, Vol. 46, pp. 124-133, 2006.","cites":null}],"documentType":{"type":1}},"contributors":[],"datePublished":"2008-07","abstract":"In this paper, we explore the impact of task\\ud\npreemption on the dependability of a single-processor embedded control system. Our particular focus in this exploratory study is on static\u2013priority, time-triggered\\ud\nscheduler architectures. The study is empirical in nature and we employ a hardware-in-the-loop (HIL) testbed, representing a cruise control system for a passenger vehicle, in conjunction with fault-injection\\ud\nto perform the dependability comparisons. The results we have obtained suggest that the presence of preemption may have a negative influence on dependability; however further work is needed in this area before more general conclusions may be drawn","downloadUrl":"http:\/\/ieeexplore.ieee.org\/.","fullTextIdentifier":"https:\/\/lra.le.ac.uk\/bitstream\/2381\/4191\/1\/MJS%20-%20ECRTS%20-%202008.pdf","pdfHashValue":"b13aaad9b32cdeeaa4fe09a2651f69a703be7a37","publisher":"Institute of Electrical and Electronics Engineers (IEEE).","rawRecordXml":"<record><header><identifier>\n        \n            \n                oai:lra.le.ac.uk:2381\/4191<\/identifier><datestamp>\n                2016-03-22T09:43:13Z<\/datestamp><setSpec>\n                com_2381_171<\/setSpec><setSpec>\n                com_2381_9549<\/setSpec><setSpec>\n                col_2381_172<\/setSpec>\n            <\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:doc=\"http:\/\/www.lyncode.com\/xoai\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n            \nExploring the Impact of Task Preemption on Dependability in Time-Triggered Embedded Systems: a Pilot Study.<\/dc:title><dc:creator>\nShort, Michael J.<\/dc:creator><dc:creator>\nPont, Michael J.<\/dc:creator><dc:creator>\nFang, Jianzhong<\/dc:creator><dc:description>\nIn this paper, we explore the impact of task\\ud\npreemption on the dependability of a single-processor embedded control system. Our particular focus in this exploratory study is on static\u2013priority, time-triggered\\ud\nscheduler architectures. The study is empirical in nature and we employ a hardware-in-the-loop (HIL) testbed, representing a cruise control system for a passenger vehicle, in conjunction with fault-injection\\ud\nto perform the dependability comparisons. The results we have obtained suggest that the presence of preemption may have a negative influence on dependability; however further work is needed in this area before more general conclusions may be drawn.<\/dc:description><dc:date>\n2009-01-29T11:46:06Z<\/dc:date><dc:date>\n2009-01-29T11:46:06Z<\/dc:date><dc:date>\n2008-07<\/dc:date><dc:type>\nConference paper<\/dc:type><dc:identifier>\nReal-Time Systems - Euromicro Conference on,  ECRTS, 2008, Art. No. 4573105, pp. 83-91.<\/dc:identifier><dc:identifier>\nhttp:\/\/ieeexplore.ieee.org\/xpl\/articleDetails.jsp?arnumber=4573105<\/dc:identifier><dc:identifier>\nhttp:\/\/hdl.handle.net\/2381\/4191<\/dc:identifier><dc:identifier>\n10.1109\/ECRTS.2008.14<\/dc:identifier><dc:language>\nen<\/dc:language><dc:rights>\nThis is the author's final draft of the paper published as Real-Time Systems - Euromicro Conference on,  ECRTS, 2008, Art. No. 4573105, pp. 83-91. Copyright \u00a9 2008 IEEE. The final version is available from http:\/\/ieeexplore.ieee.org\/. Doi: 10.1109\/ECRTS.2008.14. This material is posted here with permission of the IEEE. Such permission of the IEEE does not in any way imply IEEE endorsement of any of the University of Leicester\u2019s products or services. Internal or personal use of this material is permitted. However, permission to reprint\/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution must be obtained from the IEEE by writing to pubs-permissions@ieee.org. By choosing to view this document, you agree to all provisions of the copyright laws protecting it.<\/dc:rights><dc:publisher>\nInstitute of Electrical and Electronics Engineers (IEEE).<\/dc:publisher>\n<\/oai_dc:dc>\n<\/metadata>\n        <\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2008,"topics":[],"subject":["Conference paper"],"fullText":"Paper Preprint \u2013 To Appear In: \nProceedings of the 20th Euromicro RTS Conf. 2008 \nExploring the Impact of Task Preemption on Dependability in  \nTime-Triggered Embedded Systems: a Pilot Study \n \n \nMichael Short, Michael J. Pont and Jianzhong Fang \nEmbedded Systems Laboratory, University of Leicester, Leicester, UK. \n{mjs61, mjp9}@leicester.ac.uk, fang_jz@yahoo.com \n \n \nAbstract \n \nIn this paper, we explore the impact of task \npreemption on the dependability of a single-processor \nembedded control system.  Our particular focus in this \nexploratory study is on static\u2013priority, time-triggered \nscheduler architectures.  The study is empirical in \nnature and we employ a hardware-in-the-loop (HIL) \ntestbed, representing a cruise control system for a \npassenger vehicle, in conjunction with fault-injection \nto perform the dependability comparisons.  The results \nwe have obtained suggest that the presence of \npreemption may have a negative influence on \ndependability; however further work is needed in this \narea before more general conclusions may be drawn.  \n \n1. Introduction \n \nModern control systems are almost invariably \nimplemented using some form of digital computer \nsystem [1].  The dominance of digital systems in this \nfield is a consequence of the low cost, increased \nflexibility, greater ease of use, and increased \nperformance of digital control algorithms when \ncompared with equivalent analogue implementations \n[2] [3].  As such systems are increasingly employed in \napplications where their correct functioning is vital, \nparticular attention must be focused on the \ndependability of such systems. \nDependability in this sense covers many attributes, \nfor example reliability, security, timeliness and \nschedulability [4] [5].  In this paper, we are specifically \nconcerned with the operational dependability (i.e. the \nlevel of software fault tolerance and reliability) of \ncontrol systems implemented using a single resource-\nconstrained embedded processor, as employed in the \nfield.  As such, we assume that appropriate analysis \nhas been undertaken during system verification to \nensure the functional correctness and schedulability of \nthe design (e.g. [5] [6] [7]).   \nThe particular focus is on systems in which time-\ntriggered (TT) schedulers are employed to control the \nrelease of periodic tasks, which are in turn employed to \nimplement the control algorithm.  Often, to keep the \nsoftware environment as simple as possible, instead of \nemploying a full \u201creal-time operating system\u201d to \ndispatch the tasks, some form of scheduler is \nemployed.  In this paper, we are concerned with \nschedulers whose task priority are assigned during the \nsystem design phase and remain static during \noperation; these \u2018fixed priority\u2019 schedulers are \ngenerally recognized as being the most suitable for \ndesigns when dependability is a key design goal [5] \n[8]. \nThe simplest form of practical TT scheduler is a \n\u201ccyclic executive\u201d (e.g. [9] [10]): this has a \u201ctime-\ntriggered co-operative\u201d (or \u201ctime-triggered non-\npreemptive\u201d) architecture.  Such time-triggered co-\noperative (TTC) architectures have been found to be a \ngood match for a wide range of low-cost, resource-\nconstrained applications.  TTC architectures also \ndemonstrate very low levels of task jitter [10], and \u2013 \nprovided that an appropriate implementation is used \u2013 \ncan maintain their low-jitter characteristics even when \ntechniques such as dynamic voltage scaling (DVS) are \nemployed to reduce system power consumption [11]. \nAlthough it has many useful characteristics, a simple \nTTC solution is not always appropriate.  As Allworth \nhas noted: \u201c[The] main drawback with this [co-\noperative] approach is that while the current process is \nrunning, the system is not responsive to changes in the \nenvironment.  Therefore, system processes must be \nextremely brief if the real-time response [of the] \nsystem is not to be impaired\u201d [12].  We can formally \nexpress this concern by noting that if a system is being \ndesigned which must execute one or more tasks of \nexecution time e and also respond within an interval t \nto external events then, in situations where t < e, a pure \nco-operative scheduler will not generally be suitable. \nTime-triggered preemptive (TTP) scheduling has \nbeen proposed as an appropriate alternative for use in \nsuch circumstances [5] [6] [13].  Of the various options \navailable, the rate monotonic algorithm has been \nshown by Liu and Layland to be optimal: that is - if it \nis possible to schedule a task set using a fixed-priority \nalgorithm and meet all of its timing constraints \u2013 then a \nrate-monotonic algorithm can achieve this [6].  More \nspecifically, it can be shown that every task can meet \nits deadline if the total CPU utilization is <= 69% and \nthe following assumptions are met: (1) all tasks are \nperiodic and independent of each other, (2) the \ndeadline of every task is equal to its period and (3) the \nworst-case execution time of all tasks is known, and \n(4) context switching time can be ignored ([5] [6] [10] \n[14]).  Where such assumptions can be shown to be \nrealistic, RM can be an attractive option.  In many \ncases, such assumptions cannot be assumed to hold; a \nmore complete analysis (which includes CPU \noverheads for example) is discussed by Katcher et al. \n[15].  \nWith the increased processing power and \narchitectural design of many commercial low-cost \nmicrocontrollers, the main drawback of the purely co-\noperative approach is somewhat alleviated; complex \ntasks can be coded to have relatively short execution \ntimes, and many time-consuming operations (such as \nsending multiple characters over a slow serial link) can \nbe offloaded to dedicated on-chip hardware.  In \nsituations where task execution times may still be \nprohibitively long, techniques have been proposed to \neffectively manage these situations and automate the \ncreation of a suitable schedule (e.g. [8] [16] [17]).  In \nlight of this, system designers may have a wider range \nof scheduling algorithms to select from in current \ndesigns. \nNumerous papers have considered the impact of \nscheduling on the performance and stability of digital \ncontrol systems, from theoretical, empirical and \nsimulation-based perspectives (e.g. [18] [19] [20]).  In \nthis paper, in addition to assuming that the task set for \na given implementation is both correct and \nschedulable, we also make the following assumptions: \n(1) A controller C(s) has been designed for a plant P(s) \nsuch that a required performance and stability margin \nhas been achieved; (2) The continuous controller C(s) \nhas been discretised into a suitable digital controller \nC(z); (3) The sampling rate T of the controller C(z) has \nbeen selected such that under worst-case jitter \nconditions the lower bound on the sampling rate given \nby the Nyquist stability criterion is not broken [2] [3] \n[19]. \nAlthough several studies have sought to investigate \nthe dependability of systems designed around both \nTTP and TTC architectures (e.g. see Fuchs [21] and \nAidemark et al. [22] for an example of each), we have \nnot succeeded in finding previous studies in which a \ndirect comparison (utilizing identical hardware, task \nspecifications and fault-tolerance mechanisms) has \nbeen made of these two approaches.   \nIt is known that \u2013 since preemptive schedulers \nrequire task context switching - they will generally \nhave both larger CPU overheads and RAM\/ROM \nrequirements than \u201cequivalent\u201d co-operative \nschedulers (e.g. see [9] [10] [15] [16]).  As a \nconsequence, it has also been argued that the timing \nproperties of software code in non-preemptive designs \nare both easier to inspect and verify than preemptive \ncode [5] [8] [17]. \nPrevious research has demonstrated that both the \nmanifestation rate of transient errors and the \neffectiveness of transient fault detection mechanisms \nin an embedded system are related (in part) to the \nfunctionality and resource requirements of its software \n[23] [24] [25] [26].  It thus follows that as schedulers \nare largely implemented in software1, different designs \nmay therefore directly influence the fault-tolerance \nproperties of the resulting system. \nIn addition, the increases in both CPU and inter-task \ncommunication overheads in a TTP design (over a \nTTC design) will typically result in an increase in CPU \nutilization when a given system specification is \nimplemented.  Previous research has investigated a \nlink between CPU utilization and microcontroller \nfailure rate when a microprocessor is employed to \nperform cyclic control actions [27] [28] [29]; it has \nbeen suggested that an increased utilization leads to an \nincreased failure rate due to effects such as electro-\nmigration and increased power consumption. \nIn this paper, we explore these issues.  More \nspecifically, our empirical study considers the use of \n\u201cstandard\u201d TTC and TTP schedulers in the \nimplementation of a Cruise Control System (CCS) for \n                                                          \n1   This may not be the case for all system-on-chip designs (where, \nfor example, the operating system kernel is implemented in \nhardware).  Such designs raise a different set of questions about \nreliability: these issues are not considered in this paper.   \na passenger car, and explores the differences in \nresource requirements and dependability of the \nresulting designs with \u2018all other things being equal\u2019.  \nThe studies are carried out using a suitable hardware-\nin-the-loop (HIL) testbed, which has facilities for \ninjecting transient faults. \n \n2. Experimental methodology \n \n2.1 Test facility \n \nAs noted in the introduction, the study described in \nthis paper involved the use of a HIL simulator; the \nprinciple of HIL simulation is shown in Figure 1.  The \nsimulator is currently set up to represent the dynamics \nof a passenger vehicle in real-time, iterated at a rate of \n1 kHz.  The nature of the testbed itself, and the \ndynamic models used to represent the vehicle have \nbeen described elsewhere [30] [31]; we provide only a \nbrief summary here. \n \n \n \nFigure 1. HIL simulation principle \n \nAlthough the dynamic model of the vehicle is non-\nlinear, it can be approximated in the operating range of \nthe CCS by the following transfer function: \n \n115\n02.0\n)(\n)(\n+= ssF\nsv\n \n(1) \n \n\u2026 where v(s) is the velocity of the vehicle in meters \nper second, and F is the accelerating force (which is \ndependant on the accelerator setting, engine RPM and \nwheel slip conditions). \nThe main requirement of the CCS, which is \nimplemented by the embedded system under test, is to \nprovide the vehicle driver with an option of \nmaintaining the vehicle at a desired speed without \nfurther intervention, by automatically controlling the \nvehicle throttle setting.  It performs this function by \nmeasuring the current vehicle speed from a sensor and \nperforming a PID calculation to determine the throttle \nsetting.  The classical form of the PID algorithm \nemployed in this study is as follows: \n \ndt\ntdeTKdtte\nT\nKteKtu dc\nt\ni\nc\nc\n)()()()(\n0\n++= \u222b  \n(2) \n \n\u2026 where u(t) is the commanded throttle setting, e(t) \nis the error between reference (desired) speed and \nactual (measured) speed, and Kc, Ki and Kd are the \nsystem gains, chosen to give the desired closed loop \nperformance [1] [2] [3].  Additionally, the module is \nrequired to indicate the current speed of the vehicle \nand the status of the control system to the driver, via a \nserial interface to an LCD.  It also must interface to a \nnumber of switches to receive commands from the \ndriver (\u201cCCS enable\u201d, \u201cCCS disable\u201d,  \u201cSpeed up\u201d, \netc).   \nThe microprocessor employed in this study to \nimplement each version of the CCS was the 16-bit \nInfineon C167 with a 20 MHz clock speed [34].  Such \na device is representative of the type of embedded \nsystem currently found in many passenger vehicles.  \nDigital signals from this device are interfaced into the \nsimulation PC via standard parallel port interfaces; \nanalog (sensor) signals are synthesized by the PC using \nlow-cost AD7394 DAC chips from Analog Devices. \nOverall, the CCS testbed summarized here was \nchosen as a representative system as it can be \nconsidered to be a critical application [32], and \nprevious studies have shown that transient effects and \nprocessor faults (amongst other things) can be a major \ncontributory cause to potential dangerous system \nfailures [33]. \n \n2.2 Fault injection \n \nIn order to evaluate the dependability of each system \nunder test, a reliable, non-intrusive and high \nperformance fault injection protocol was created.  The \nprotocol itself operates via the PC serial port and on-\nchip UART of the microcontroller under test, and is \nbased on the well-understood \u2018bit-flip\u2019 or \u2018upset\u2019 \nmodel.  Such an approach has been shown to be \nrepresentative of a wide range of transient faults in \nembedded systems [26].   \nThe protocol operates as follows.  Three control \nbytes are sent by the PC, invoking a high priority \ninterrupt in the microcontroller.  Fault injection is \nachieved by the use of pointer indirection to achieve \nthe bit flips; bit flips in the C167 internal RAM \n(IRAM) areas can corrupt the system stack, registers, \nspecial function registers (SFRs) and program counter.  \nBit flips in the external RAM (XRAM) areas can \ncorrupt the user stack and also the task data areas.  To \nensure a fair comparison between the two systems, for \neach fault injected in this study a random bit to flip \nwas selected in a random memory address location \nfrom a 4.5 KB area of IRAM or a 4.5 KB area of \nXRAM; thus implementing a wide variety of data, \ncontrol flow and CPU \/ peripheral configuration errors. \n \n2.3 Overall methodology \n \nIn each of the experiments performed in this paper, \nthe vehicle cruise control was initially enabled at 50 \nMPH (80.5 KPH).  The \u2018driver\u2019 then commanded \nperiodic speed changes from 50 MPH to 40 MPH \n(64.4 KPH), and vice versa, every 10 seconds.  One \nsecond prior to this commanded speed change, a fault \nwas injected into the system under test by the \nsimulation PC.  After the injection of each fault, the \nresulting system behavior was automatically classified \nusing a simple model-based performance monitor to \ngauge the operation of the system in real-time2.  The \nperformance monitor compares the real system \nbehavior with the desired system behavior, as shown in \nFigure 2, to detect deviations from the specification \nthat are indicative of a system failure (e.g. sluggish \/ \noscillatory performance, out of range or \u2018stuck at\u2019 \nerrors).  The performance monitor is an adapted \nversion of the design presented by Li et al. [35].  After \neach resulting fault has been classified, the results are \nlogged into a text file by the PC for later analysis. \n \n \nFigure 2. Performance monitor \n \nThis test strategy was employed to allow for a \nmaximum possible coverage of critical code (sampling, \ncontrol, actuation, response to driver commands) \nfollowing the injection of the fault.  It must be noted \nthat there was no explicit synchronization when \ninjecting faults; they could occur at any point in the \nembedded system\u2019s execution, and could not be \n                                                          \n2  To eliminate any \u2018probe effects\u2019, the performance monitor was \nimplemented entirely on the PC. \n\u2018blocked\u2019 in any way.  In each of the tests described in \nthis paper, the experimentation was allowed to run \nautonomously until 100,000 faults had been injected \ninto the system under test, the resulting failure modes \nclassified by the monitor, and logged into the text file.  \nThe overall testing strategy that was employed is \nshown schematically in Figure 3. \n \n \n \nFigure 3. Overall experimental methodology \n \n3. Scheduler and task designs \n \n3.1 TTC system \n \nTo implement the system, the first scheduler used in \nthis study was a form of cyclic executive.  The specific \nimplementation used was based on that described \npreviously by Pont [16], with very minor changes \nmade to match the C167 processor employed in this \nstudy.   \nPlease note that - because of the co-operative nature \nof this scheduler - no locking mechanisms were \nrequired, and inter-task communication was by means \nof \u201cglobal\u201d variables. \n \n3.2 TTP system \n \nThe time-triggered preemptive (TTP) scheduler used \nin this study was a fully preemptive design, which was \nused to implement a rate-monotonic (RM) schedule of \nthe task set described in the following section.  The \nfast context switching mechanism of the C167 was \nemployed in the implementation; full details of the \nscheduler design are documented by Fang [36]. \nPlease note that \u2013 as discussed in the introduction - a \n\u201cpure\u201d RM schedule assumes that all tasks are \nindependent: this was not the case in our system \n(indeed, it is very rarely the case in any practical \ndesign) and our scheduler implementation could \ntherefore only provide an approximation of the RM \ntheory.  To avoid conflicts, locking mechanisms were \nimplemented (to protect shared hardware resources).  \nThese locking mechanisms approximated the \u201cPriority \nCeiling Protocol\u201d [37].  In \u201cPCP\u201d, a ceiling priority is \ndefined as the maximum priority of those tasks that \ntake part in a priority comparison.  When using PCP, \nthe intention is to ensure that the task which is \ncurrently using the resource completes as quickly as \npossible. \nIn addition to the locking mechanism, the RM \nscheduler also requires a mechanism for transmitting \ndata between tasks (the possibility of task preemption \nmeans that we cannot simply use global variables for \nthis purpose, as we can with the co-operative design).  \nVarious mechanisms can be used for inter-task data \ntransfers in such designs: for example, we could use \nthe lock mechanism and global variables.  A more \npopular technique is a message queue (e.g. see Simon \n[38]): such an approach was employed in this study. \n \n3.3 Task software \n \nSix periodic software tasks were created to \nimplement the control system.  A sensor task (T1) \nsampled the vehicle speed (as a voltage) through an \nanalog-to-digital (ADC) port, re-scaled the voltage to \nthe required speed range and performed range and \nrange-rate sanity checks.  The control task (T2) \nperformed the PID calculation; a digitized version of \n(2): \n \n )( 1\n0\n\u2212\n=\n\u2212++= \u2211 jjdj\nm\nmijPj eeKeKeKu  \n(3) \n \n\u2026 where uj is the commanded throttle setting at \nsample j, and ej is the error at sample j.  The three \nsystem gains were chosen (manually) to give the \ndesired closed loop performance; a critically damped \n95% settling-time of approximately 6 seconds.  The \nactuation task (T3) performed a further sanity check on \nthe resulting throttle command and translated this \noutput to a parallel port of the C167, to control a \nthrottle servo actuator.  These three tasks were \nscheduled to execute sequentially with a period of \n20 ms, giving an overall sampling rate of 50 Hz. \nA status-update task (T4) was executed once every \n100 ms.  This task monitored and \u201cde-bounced\u201d the \n\u201ccruise enable\u201d and \u201cresume\u201d switches.  It also \nmonitored switches on both the accelerator and brake \npedals: if either of the pedal switches was depressed, \nthe cruise control was disengaged.  In addition, a \ndisplay update task (T5) was also executed every \n100 ms and sent a string of display characters to the \nLCD (serial protocol).  Note that in the co-operative \nscheduler, we broke the LCD update task evenly up \ninto smaller segments (as discussed in Pont [16]). \nThe final system task was the safety task (T6), also \nexecuted every 100 ms.  This task serviced the \nwatchdog timer, and also verified the system \nconfiguration (such as timer reload value, I\/O \nconfiguration and interrupt settings). \nThese tasks and their periods T and duration D \n(expressed in ms) are summarized in Table I.   \n \nTable I. Task set summary \n \nName Task ID T (ms) D (ms) \nSensor T1 20 0.5 \nControl T2 20 1.2 \nActuator T3 20 0.5 \nStatus T4 100 9 \nLCD \u2013 P T5 100 25 \nLCD \u2013 C T5 20 5 \nSafety T6 100 0.1 \n \nPrior to experimentation both software \nimplementations were verified using bounded model \nchecking3 techniques to ensure that run-time failures \nwere not due to simple coding errors. \n \n3.4 Timer tick interval \n \nIn a system based on periodic scheduler \u201cticks\u201d \n(timer interrupts), the tick interval must be set \naccording to the application requirements.  If the tick \ninterval is too long, the system will be unable to \nrespond at an appropriate rate and will not \u2013 for \nexample \u2013 be able to meet data-sampling requirements.  \nIf the tick interval is too short, the scheduling load will \nbe unnecessarily high: this may increase both jitter \nlevels and system power consumption. \nFrom an analysis of the schedule, for the co-\noperative system we chose a timer interrupt rate of \n10 ms, as this is the largest common divisor of the \ntasks that is also greater than the longest task duration.  \n                                                          \n3  Please see http:\/\/www-2.cs.cmu.edu\/~modelcheck\/cbmc for \nfurther details of the model checker that was employed. \nFrom Katcher et al. [15], we calculated timer bounds \nfor the tick rate TTIC of the preemptive system to be \nbetween 1.14 ms < TTIC < 18.25 ms.  The actual value \ntaken was thus the integer mid point of 10 ms, identical \nto the co-operative system. \n \n3.5 Transient protection mechanism \n \nIn order to increase realism of the study, a number \nof identical hardware and software based mechanisms \nwere utilized (in both TTC and TTP implementations) \nin order to detect and correct transient errors.  These \nmechanisms included the use of a 200 ms watchdog \ntimer, duplex implementation of critical data with \ncomparison, sanity checks of control signals, and a \ntask overrun detection mechanism.  The on-chip \nexception traps of the C167 processor were also \nemployed, allowing detection of:  stack overflow; \nstack underflow; illegal operands; illegal word access; \nprotected instruction faults; and, illegal bus access. \nThe unused areas of FLASH memory and RAM in \neach design were filled with illegal operands to \nprovide an addition means of detecting control-flow \nerrors.  On activation of any of these traps, a full \nsystem reset was forced.  Finally, on system boot-\nup\/reset, the system performed the following software-\nbased self-tests [39]: \n \n1. Internal RAM\/register\/stack validation. \n2. External RAM validation. \n3. ROM checksum. \n4. Peripheral test (e.g. ports, timer). \n \nThis approach to fault-tolerance is illustrated in \nFigure 4. \n \n4. Results and discussion \n \nIn this section we discuss the results that were \nobtained in the study; we begin with a comparison of \nthe required memory resources and CPU utilization of \neach implementation. \n \n4.1 CPU and memory requirements \n \nAs mentioned in the introduction, TTP schedulers \nare expected to have larger CPU overheads and \nmemory requirements than equivalent TTC designs.  \nTable 2 shows the requirements for each of the designs \nemployed in this study.  The CPU utilization U and \nscheduler overhead W were both experimentally \ndetermined (by directly measuring both the idle time of \nthe microcontroller and the time spend executing \nscheduler code) over several thousand hyper periods of \nthe task set, during (normal) fault-free operation.  \nTable II also shows the percentage increase between \nthe TTC and TTP designs. \n \n \n \nFigure 4. Transient protection mechanisms \n \nTable II. System resource comparison \n \nSystem U (%) W (\u03bcs)  RAM (B) ROM (B) \nTTC 45.36 39.5 650 4,774 \nTTP 51.44 262.2 4,882 5,030 \n% Increase 13.4 563.8 651.1 5.4 \n \n4.2 Fault injection results \n \nAs mentioned, in this study we were concerned \nwith operational dependability of the systems under \ntest.  After the injection of each fault, the resulting \nfailure behavior was therefore categorized as one of \nthe following: \n \n1. Effect-less: the fault was either not activated, or was \ntolerated by the employed fault mechanisms; it did not \ncause a measurable deviation of performance from the \nsystem specification. \n \n2. Failure: the fault was neither detected nor corrected \nand resulted in a permanent deviation of performance \nfrom the system specification. \n \nBased on this classification, the probability of \nfailure PF following a transient fault was estimated.  \nThe results we obtained for each system are \nsummarized in Table III. \n \nTable III. Fault injection comparison \n \nSystem \nFaults  \nInjected \nEffect  \nLess Failures PF \nTTC 100,000 99942 58 5.8 x 10-4 \nTTP 100,000 99755 245 2.45 x 10-3 \n \n4.3 Discussion \n \nBased on the results shown in the previous two \nsections, it can be seen that for the two systems, \nexhibiting identical functionality, several noticeable \ndifferences can be observed.  Firstly, as expected all \nmeasures of system resources were larger for the TTP \nsystem.  The most significant differences being the \nincrease in RAM requirements (651.1 %) and \nscheduler overheads (563.8 %), followed by an \nincreased CPU utilization (13.4 %).  The smallest \nincrease was in the system ROM requirements, with a \n5.4 % increase in size. \nSecondly, as the fault injection results demonstrate, \ndespite both systems exhibiting relatively good \ntransient error recovery properties a significant \ndifference in the failure behavior of the two systems \nwas observed.  A 322.4 % increase in the number of \nrecorded dangerous failures was observed in the TTP \nsystem over the TTC.  Thus as can be seen from the \ntable, there is a measurably greater risk that the TTP \nsystem will exhibit dangerous failure behavior \nfollowing a transient disturbance.  Given that the main \ndifference between the two system implementations \nwas the choice of scheduler, we hypothesize that the \nincreased complexity, overheads and resource usage in \nthe TTP system had a direct influence on its transient \nerror failure rate. \nBased on these results, it is possible to calculate an \nexpected mean-time-to-dangerous-failure (MTTDF) \nfor each system implementation.  Taking the \nprobability of a transient bit flip to be approximately \n10-9 \/ bit \/ hour for a ground based mobile installation \n[40], the probability of a transient error \u03bbT occurring in \nthe 9KB area of memory that was considered in this \nstudy is therefore approximately 7.4 x 10-5. \nPrevious works suggest a linear relationship \nbetween CPU failure rate \u03bbCPU and utilization; this \nrelationship can be expressed as follows [27] [28] [29]: \n \n \nUMINCPU U \u0394\u22c5+= \u03bb\u03bb  \n(4) \n \n\u2026 where \u0394U is the change in failure rate due to \npower consumption between 0 and 100% CPU \nutilization.  Thus the failure rates per 10-6 hours for the \nC167 CMOS technology microcontroller with 111 \npins, a 128K Flash EEPROM and 256K SRAM can be \ncalculated as shown in Table IV [41]. \n \nTable IV. Component failure rates \n \nComponent Failure Rate \nCPU (\u03bbMin) 0.69393 \nCPU (\u0394U) 0.00067 \nEEPROM (\u03bbE) 0.16490 \nRAM (\u03bbR) 0.24320 \n \nConsidering that the failure of the CPU or memory \ndevices will result in an unpredictable failure that will \ncause a significant deviation of system performance \nfrom the specification, the dangerous failure rate \u03bbSYS \nfor each system may then be calculated as follows: \n ( )fTRECPUSYS P\u22c5+++= \u03bb\u03bb\u03bb\u03bb\u03bb  \n(5) \n \nApplying (4) and (5) to the results we have \nobtained, the failure rates for the TTP and TTC \nsystems can then be calculated as shown: \n \n6\n6\n10317.1\n10175.1\n\u2212\n\u2212\n\u00d7=\n\u00d7=\nTTP\nTTC\n\u03bb\n\u03bb\n \n(6) \n \nFrom this, it can be seen that in this study, with \u2018all \nother things being equal\u2019, the TTC implementation of \nthe CCS was significantly more dependable than the \nTTP design.  This is further illustrated when \ncomparing the MTTDF of each system: the MTTDF of \nthe TTC system is 97.14 years, and the MTTDF of the \nTTP system is 86.67 years.  Although both of these \nvalues may be deemed acceptable for a CCS system, it \nis clear from these results that the use of task \npreemption in this experimental study has had a \nmeasurable impact on the dependability of the \nresulting system implementation, with a 12.1 % \nincrease in the expected MTTDF in the TTC design. \n \n \n5.0 Conclusions \n \nIn this paper, we have explored the impact of \npreemption on the operational dependability of a \nsingle-processor embedded control system, \nimplemented using a static time-triggered scheduler.  \nThe study was empirical in nature and we employed a \nhardware-in-the-loop (HIL) testbed, combined with \nfault-injection experimentation, to perform the \ncomparisons.  The results obtained in this initial study \nsuggest that preemption may have a measurable effect \non dependability and fault-tolerance in embedded \nsystems; however at this early stage it cannot be said \nthat these results will generalize further. \nFurther work is required to investigate if the results \nfound here will generalize to other processor \nplatforms, scheduler implementations and application \nareas. Additionally it is unclear if more advanced fault \ndetection schemes than those employed in this paper \nwill minimize the differences we have described.  One \nother point to note is that this paper has not directly \nconsidered the effects of corruptions in the program \nROM in the systems under test; this may well have an \nadditional influence on the obtained results. \nFurther work in this area will consider these \neffects, and will also consider additional case studies \nin which the effects of preemption rate may also be \ninvestigated. It is also planned to investigate \npreemption effects on dependability in dynamic \nschedulers (primarily EDF), and also its effects in \nmulti-processor, distributed embedded systems. It is \nhoped that such studies may shed further light on the \nimportant issues raised in this paper. \n \n6.0 Acknowledgements \n \nThe project described in this paper was supported \nby the Leverhulme Trust (Grant F\/00212\/D). \n \n7. References \n \n[1] Kilian, C.T. Modern control technology: components and \nsystems. Delmar Thomson Learning, 2000. ISBN: \n076682358X. \n \n[2] Virk, G.S. Digital computer control systems. McGraw-\nHill, 1991. ISBN: 0070675120. \n \n[3] Astrom, K. and Wittenmark, B. Computer Controlled \nSystems: Theory And Design. Prentice Hall, 1997. ISBN: \n0133148998. \n \n[4] Storey, N. Safety Critical Computer Systems. Addison \nWesley Publishing, 1996. \n \n[5] Bate, I.J. Scheduling and Timing Analysis for Safety \nCritical Real-Time Systems. PhD Dissertation, University of \nYork, U.K., November 1998. \n \n[6] Liu and, C. L. and Layland, J. W. Scheduling algorithms \nfor multiprogramming in a hard real-time environment. \nJournal of the ACM 20(1), 1973.  \n \n[7] Burns, A. and Lin, T.M. An engineering process for the \nverification of real-time systems. Formal Aspects of \nComputing, Vol. 19, pp. 111-136, 2007. \n \n[8] Xu, J. On Inspection and Verification of Software with \nTiming Requirements. IEEE Transactions on Software \nEngineering, Vol. 29, No. 8, pp. 705-720, 2003. \n \n[9] Baker, T. P. and Shaw, A. The cyclic executive model \nand Ada. Real-Time Systems, Vol. 1, No. 1, pp. 7-25, 1989. \n \n[10] Locke, C. D. Software architecture for hard real-time \napplications: Cyclic executives vs. fixed priority executives. \nReal-Time Systems, 4(1): 37-52, 1992. \n \n[11] Phatrapornnant, T. and Pont, M. J. Reducing jitter in \nembedded systems employing a time-triggered software \narchitecture and dynamic voltage scaling. IEEE Transactions \non Computers, 55 (2): 113-124, 2006. \n \n[12] Allworth, S. Introduction to real-time software design. \nSpringer-Verlag, 1981. \n \n[13] Audsley, N., Burns, A., Richardson, M., Tindell, K., and \nWellings, A. Applying new scheduling theory to static \npriority pre-emptive scheduling. Software Engineering \nJournal 8(5), pp. 284-292 September 1993. \n \n[14] Buttazzo, G., Marinoni, M., and Guidi, G. Energy-aware \nstrategies in real-time systems for autonomous robots. In: \nProc. of the 19th International Symposium on Computer and \nInformation Sciences (ISCIS 2004), Turkey, 2004.  \n \n[15] Katcher, D. I., Arakawa, H., and Strosnider, J. K. \nEngineering and analysis of fixed-priority schedulers. IEEE \nTrans. on Software Engineering, Vol. 19, No. 9, pp. 920-934, \n1993. \n \n[16] Pont, M. J. Patterns for time-triggered embedded \nsystems: Building reliable applications with the 8051 family \nof microcontrollers. ACM Press \/ Addison-Wesley, 2001. \nISBN: 0-201-331381.  \n \n[17] Xu, J. and Parnas, D.L. Fixed Priority Scheduling versus \nPre-Run-Time Scheduling. Real-Time Systems, Vol. 18, pp. \n7-23, 2000. \n \n[18] Palopoli, L., Pinello, C., Bicchi, A. and Sangiovanni-\nVincentelli, A. Maximizing the Stability Radius of a Set of \nSystems Under Real-Time Scheduling Constraints. IEEE \nTransactions on Automatic Control, Vol. 50, No. 11, pp. \n1790-1795, 2005. \n \n[19] Bate, I., McDermid, M. and Nightingale, P. Establishing \ntiming requirements for control loops in real-time systems. \nMicroprocessors and Microsystems, Vol. 27, pp. 159-169, \n2003. \n \n[20] Fang, J. and Pont, M.J. Exploring the links between \nsoftware architecture and PID parameters in embedded \ncontrol systems. In: Proceedings of the 6th UKACC Control \nConference, Glasgow, Scotland, 30 August to 1 September, \n2006. \n \n[21] Fuchs, E. An Evaluation of the Error Detection \nMechanisms in MARS Using Software-Implemented Fault \nInjection. In: Proc. of the European Dependable Computing \nConference, Springer-Verlag, Lecture Notes in Computer \nScience, Volume 1150, pp. 73-90, 1996. \n \n[22] Aidemark, J., Folkesson, P. and Karlsson, J. \nExperimental Dependability Evaluation of the Artk68-FT \nReal-time Kernel. In: Proc. of the International Conference \non Real-Time and Embedded Computer Systems and \nApplications, G\u00f6teborg, Sweden, August 2004. \n \n[23] Rajabzadeh, A. and Miremadi, S.G. Transient detection \nin COTS processors using software approach. \nMicroelectronics Reliability, Vol. 46, pp. 124-133, 2006. \n \n[24] Benso, A., di Carlo, S., di Natale, G., Prinetto, P.  and \nTagliaferri, L. Control-Flow Checking Via Regular \nExpressions. In: Proc. IEEE Asian Test Symposium, pp. 299-\n303, 2001. \n \n[25] Elder J.H. A Method for Characterising a \nMicroprocessor\u2019s Vulnerability to SEU. IEEE Trans. on \nNuclear Science, Vol. 35, No. 6, December 1988. \n \n[26] Arlat, J., Aguera, M., Amat, L., Crouzet, Y., Fabre, J.-\nC., Laprie, J.-C., Martins, E. and Powell, D. Fault Injection \nfor Dependability Validation\u2014A Methodology and Some \nApplications. IEEE Trans. Software Eng., vol. 16, no. 2, pp. \n166-182, Feb. 1990. \n \n[27] Ting, Y., Shan, F.M., Lu, W.B. and Chen, C.H. \nImplementation and evaluation of failsafe computer-\ncontrolled systems. Computers & Industrial Engineering, \nVol. 42, pp. 401-415, 2002. \n \n[28] Kapur, K.C. and Lamberson, L.R. Reliability in \nengineering design. New York: Wiley & Sons, 1977. \n \n[29] Krishnan, R.V. The Impact of Workload On The \nDependability Of Microprocessors Used In Control \nApplications. MSC Thesis, University of Illinois at Urbana-\nChampaign, USA, 1996. \n \n[30] Ayavoo, D., Pont, M. J., Fang, J., Short, M., and Parker, \nS. A \u2018Hardware-in-the Loop\u2019 testbed representing the \noperation of a cruise-control system in a passenger car. In: \nProceedings of the Second UK Embedded Forum \n(Birmingham, UK, October 2005), pp. 60-90, 2005. \nPublished by University of Newcastle upon Tyne [ISBN: 0-\n7017-0191-9].  \n \n[31] Short, M. J. and Pont, M. J. Hardware in the loop \nsimulation of embedded automotive control systems. In: \nProceedings of the 8th IEEE International Conference on \nIntelligent Transportation Systems (IEEE ITSC 2005) held in \nVienna, Austria, pp. 226-231, 2005. \n \n[32] Castelli, J., Nash, C., Ditlow, C. and Pecht, M. Sudden \nacceleration \u2013 the myth of driver error. University of \nMaryland, CALCE EPSC Press, ISBN 0-9707174-5-8. \n \n[33] Mauser, H. and Thurner, E. Electronic Throttle Control \n\u2013 A Dependability Case Study. Journal of Universal \nComputer Science, Vol. 5, No. 10, pp. 730 \u2013 741, 1999. \n \n[34] Infineon Technology AG. C167CS Derivatives: 16-bit \nsingle-chip microcontroller. User's Manual, V2.0, 2000.  \n \n[35] Li, Q., Whiteley, J.R., and Rhinehart, R.R. A relative \nperformance monitor for process controllers. Int. Journal of \nAdaptive Control and Signal Processing, Vol. 17, pp. 685-\n708, 2003. \n \n[36] Fang, J. The design of a pre-emptive scheduler for the \nC167 Microcontroller. Technical Report ESL 06\/01, \nUniversity of Leicester, 2006. \n \n[37] Sha, L., Rajkumar, R., and Lehoczky, J. P. Priority \nInheritance Protocol: An approach to real-time \nsynchronization. IEEE Trans. On Computers 39: 1175-1185, \n1990.  \n \n[38] Simon, D.E. An embedded software primer. Addison-\nWesley, 1999. ISBN: 0-201-61569X.  \n \n[39] Sosnowski, J. Software-based self-testing of \nmicroprocessors. Journal of Systems Architecture, Vol. 52, \npp. 257-271, 2006. \n \n[40] Normand, E. Single Event Effects in Avionics. IEEE \nTrans. on Nuclear Science, Vol. 43, No. 2, 1996. \n \n[41] MIL-HDBK-217F. Military Handbook - Reliability \nPrediction of Electronic Equipment. Department of Defence, \nWashington DC, 1990.  \n"}