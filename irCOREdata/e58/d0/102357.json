{"doi":"10.1109\/ICC.2005.1494502","coreId":"102357","oai":"oai:epubs.surrey.ac.uk:1816","identifiers":["oai:epubs.surrey.ac.uk:1816","10.1109\/ICC.2005.1494502"],"title":"Multi-Layers Balanced LKH","authors":["Ng, Wee Hock Desmond","Sun, Zhili"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2005-01-01","abstract":"<p>Secure multicast communication is important for applications such as pay-per-view distribution. LKH has been proposed to distribute a shared secret key in a way that scales efficiently for groups with many members. However, the efficiency of LKH depends critically on whether the key tree remains balanced. For applications such as video streaming or online teaching, several multicast sessions might be related in one way or another. in this paper, we consider the balance of the key tree and treat related multicast sessions as a whole. Our approach shows significant improvement over traditional method and trades off additional rekeying costs for similar computation power at members'. side compared to existing related approach. Two optimisations are also proposed to further enhance the efficiency of our algorithm.<\/p","downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":null,"rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:1816<\/identifier><datestamp>\n      2017-10-31T14:03:15Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:656C656374726F6E6963656E67696E656572696E67:63637372<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/1816\/<\/dc:relation><dc:title>\n        Multi-Layers Balanced LKH<\/dc:title><dc:creator>\n        Ng, Wee Hock Desmond<\/dc:creator><dc:creator>\n        Sun, Zhili<\/dc:creator><dc:description>\n        <p>Secure multicast communication is important for applications such as pay-per-view distribution. LKH has been proposed to distribute a shared secret key in a way that scales efficiently for groups with many members. However, the efficiency of LKH depends critically on whether the key tree remains balanced. For applications such as video streaming or online teaching, several multicast sessions might be related in one way or another. in this paper, we consider the balance of the key tree and treat related multicast sessions as a whole. Our approach shows significant improvement over traditional method and trades off additional rekeying costs for similar computation power at members'. side compared to existing related approach. Two optimisations are also proposed to further enhance the efficiency of our algorithm.<\/p><\/dc:description><dc:date>\n        2005-01-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/1816\/1\/fulltext.pdf<\/dc:identifier><dc:identifier>\n          Ng, Wee Hock Desmond and Sun, Zhili  (2005) Multi-Layers Balanced LKH   IEEE International Conference on Communications, 2.  pp. 1015-1019.      <\/dc:identifier><dc:relation>\n        10.1109\/ICC.2005.1494502<\/dc:relation><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/1816\/","10.1109\/ICC.2005.1494502"],"year":2005,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"Multi-Layers Balanced LKH \nWee Hock Desmond Ng, Zhili Sun \nCentre for Communication Systems Research \nUniversity of Surrey \nGuildford, Surrey, GU2 7XH, United Kingdom \n{W.Ng | Z.Sun} @surrey.ac.uk \n \n \nAbstract\u2014Secure multicast communication is important for \napplications such as pay-per-view distribution. LKH has been \nproposed to distribute a shared secret key in a way that scales \nefficiently for groups with many members. However, the \nefficiency of LKH depends critically on whether the key tree \nremains balanced. For applications such as video streaming or \nonline teaching, several multicast sessions might be related in one \nway or another. In this paper, we consider the balance of the key \ntree and treat related multicast sessions as a whole. Our \napproach shows significant improvement over traditional method \nand trades off additional rekeying costs for similar computation \npower at members\u2019 side compared to existing related approach. \nTwo optimisations are also proposed to further enhance the \nefficiency of our algorithm.  \nKeywords- secure multicast, group key management, secure \ngroup communication \nI.  INTRODUCTION \nIP multicast [1] enables efficient group communication by \nallowing the sender to transmit a single copy of data, with \nnetwork elements such as routers and switches making copies \nas necessary for the receivers. This solves the scalability issues \nat the sender side and allows better utilisation of network \nresources such as bandwidth and buffer space.  \nIn order for IP multicast to scale to virtually any group size, \nit relies on a single group address to identify the set of \nrecipients rather than explicitly listing them. However, this \nanonymous receiver model prevents the content providers from \ncharging the members. The only way to provide controlled \naccess to data is to encrypt the multicast data and distribute the \nencryption key to the members. If the membership is dynamic, \nthis shared encryption key has to be updated and redistributed \nto all authorised members securely every time there is a change \nin the group membership in order to provide forward and \nbackward secrecy. Forward secrecy means a departing member \ncannot obtain information about future group communication, \nand backward secrecy means that a joining member cannot \nobtain information about past group communication. Changing \nof keys, also known as rekeying, is necessary even when there \nis no change in membership to prevent the key from being \ncompromised after long period of usage. A number of scalable \napproaches [2, 3, 4, 5, 6, 7] have been proposed, and one in \nparticular, logical key hierarchy (LKH) [2, 3] is analysed in \nthis paper. The trusted entity, which is responsible for \ndistributing the key to the members, is known as group \ncontroller (GC). \nIn LKH, there are two types of keys: Traffic Encryption \nKey (TEK) and Key Encryption Key (KEK). In short, TEK is \nthe group key, which is used to encrypt the multicast data while \nKEK is used to provide scalable rekeying. The efficiency of \nLKH depends critically on whether the key tree remains \nbalanced. A key tree is considered balanced if the distance \nfrom the root to any two leaf node differs by not more than one \n[8, 9]. If the key tree becomes unbalanced, the distance from \nthe root to a leaf node can become as high as N, where N is the \nnumber of members. In other words, some group members \nmight require up to N decryptions if any of its siblings departs \nfrom the multicast group.  \nWithin LKH, two types of groups, data group (DG) and \nservice group (SG), have been defined in [10, 11]. A DG is a \nset of members who receives the same single data stream. The \ninformation distributed in each DG is encrypted with the TEK. \nA SG is a set of members who entitles the same privileges and \nreceives the exactly same set of data stream. This is because in \nexisting group applications such as video streaming and online \nteaching, some members might subscribe to several similar \nDGs at the same time. Figure 1 illustrates a multicast video \nencoded in cumulative layers for heterogeneous receivers. Each \nreceiver subscribes to a subset of layers in such a way that the \ntotal capacity of the subscribed layers does not exceed the \nreceiver\u2019s capacity. In this illustration, BL, EL1 and EL2 are \nthe DGs and SGBL are members in DGBL excluding those in \nDGEL1 and DGEL2. For SGEL1, it consists of the members in \nDGEL1 excluding those in DGEL2 and SGEL2 are members in \nDGEL2. \nIf the above multicast sessions are considered using \ntraditional method, each DG will be considered separately, \nwhich leads to inefficiency in term of key storage at both GC \nand members side [10, 11].  In addition, the rekeying costs are \nhigher [11, 12]. The term rekeying cost refers to the total \nnumber of keys to be unicast or multicast out to the members \nwhen the GC spawns a rekey. \n \nEL1EL2 BL\nBL - Base Layer\nEL - Enhancement Layer\n \n \nFigure 1. Multicast video encoded in cumulative layers \n10150-7803-8938-7\/05\/$20.00 (C) 2005 IEEE\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 13,2010 at 14:37:39 UTC from IEEE Xplore.  Restrictions apply. \nIn this paper, we consider all related multicast sessions as a \nwhole to minimise key storage and rekeying costs needed by \nthe GC and members. In addition, we also take the balance of \nkey tree into consideration to allow similar key storage among \nmembers and preserve the rekeying scalability of LKH; this \nmeans each member needs at most log k N decryptions when \nany of its siblings departs rather than N decryptions (worst \ncase) in an unbalanced LKH. The rest of this paper is organised \nas follows. In section II, we provide the background material of \nLKH and explain how an unbalanced key tree affects the GC \nand members in term of key storage and rekeying costs. \nRelated works are examined in this section too. In section III, \nwe discuss how our Multi-Layers Balanced LKH (MLB-LKH) \nconstructs the key tree for the related multicast sessions. The \nsimulation results of our proposed algorithm with traditional \nand existing approaches are presented in section IV, followed \nby the conclusion in section V. \nII. RELATED WORK \nIn LKH, the GC maintains a tree of keys, where the internal \nnodes of the tree hold the KEKs and the leaf nodes correspond \nto the group members. Each leaf node holds an individual key \nassociated with that one member. Each member receives and \nmaintains a copy of the individual key associated with its leaf \nnode and the KEKs corresponding to each ancestor node in the \npath from its parent node to the root. All group members share \nthe key held by the root of the tree, also known as TEK, as \nshown in Figure 2. \nFor a balanced key tree with outdegree, k, each member \nstores log k N + 1 keys while the GC stores all (kN - 1)\/(k - 1) \nkeys. For example, in Figure 2, member U1 knows K1, K2, K5 \nand member U7 knows K1, K4 and K11. In this example, K1 is \nthe TEK, which is used to encrypt the multicast data, K2 to K4 \nare the KEKs for rekeying purposes and K5 to K13 are the \nindividual keys associated with the group members on the leaf \nnodes. \nWhen a member is removed from the group, the GC must \nchange all the keys in the path from this member\u2019s leaf node to \nthe root to achieve forward secrecy.  All the other members \nthat remain in the group must update their keys accordingly, \nnamely change the keys in the intersection between the path \nfrom their leaf nodes to the root and the path from the removed \nmember\u2019s leaf node to the root.  In particular, this means that \nevery remaining member will learn the new TEK. When the \nkey tree is balanced, the rekeying cost is k log k N \u2013 1 keys. For \nexample, suppose member U9 in Figure 2 is departing, all the \nkeys he stores (K1, K4), except for his individual key, must be \nchanged. The GC first encrypts the new K4, K4\u2019, with K11 and \nK12 for member U7 and U8 respectively. Finally, it encrypts \nK1\u2019 with the respective TEKs for all the group members. \nIf backward secrecy is required, then a join operation is \nsimilar to a remove operation in which the keys that the joining \nmember receives must be different from the keys previously \nused in the group. The rekeying cost is 2 log k N keys when the \nkey tree is balanced. Suppose member U9 is joining the group, \nthe GC first encrypts K4\u2019 for member U7 and U8. Then it \nencrypts K1\u2019 with K1 for member U1 and U8. Finally, it \nencrypts K4\u2019 and K1\u2019 with K13 for member U9.  \nThe efficiency of LKH depends critically on whether the \nkey tree remains balanced. A key tree is considered balanced if \nthe distance from the root to any two leaf node differs by not \nmore than one. For a balanced key tree with N leaf nodes, the \nheight from the root to any leaf node is log k N. However if the \nkey tree becomes unbalanced, the distance from the root to a \nleaf node can become as high as N. Figure 3 shows an \nunbalanced key tree. First of all, we can see that key storage \namong members varies from 3 to 5 rather than 4 in a balanced \nLKH. Secondly, U1 or U2 needs 4 decryptions if any of its \nsiblings departs rather than log 2 7 decryptions in a balanced \nLKH and lastly, the rekeying cost for an unbalanced LKH is 7 \nkeys rather than 2 log 2 7 keys in a balanced LKH when U1 or \nU2 departs since K1, K2, K4 and K8 need to be changed. In \nthis example, the difference between balanced and unbalanced \nLKH varies slightly as the group size is small. In cases where \nthe group consists over several thousands or millions of \nmembers such as pay-per-view, this effect can be very obvious.   \nCentralised multi-group key management scheme has been \nproposed in [10, 11] which considers related multicast sessions \nas a whole. There are three steps in the scheme. First, a subtree, \nknown as SG-subtree, is constructed for each SG with the leaf \nnodes being the users of that particular SG. Next, a subtree, \nknown as DG-subtree, is constructed for each DG. Finally, the \nleaf nodes of DG-subtrees and roots of SG-subtrees are \nconnected to generate the key tree. Our approach differs from \ntheirs as we are able to trade-off additional rekeying costs in \norder to obtain a balanced key tree. This is because we try to \npreserve the scalability of LKH by spreading the computation \npower equally among the members. Furthermore, if we \nproperly place the members in the key tree, these additional \nrekeying costs can be considered as quite insignificant.  \nK1\nK2 K4\nK5 K6 K7 K8 K10 K12 K13\nTEK :\nKEK :\nIndividual\nKey  :\nU1 U2 U3 U4 U5 U6 U7 U8 U9\nK3\nK11K9\n \n \nFigure 2. Logical key tree \n \nK1\nK2 K3\nK4 K5 K6 K7\nK8 K9 K10 K11\nK12 K13\nU1 U2\nU3 U4 U5\nU6 U7\n \n \nFigure 3. Unbalanced key tree \n1016\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 13,2010 at 14:37:39 UTC from IEEE Xplore.  Restrictions apply. \nIII. MULTI-LAYERS BALANCED LKH (MLB-LKH) \nIn this section, we discuss how we can minimise the key \nstorage and rekeying costs for several related multicast sessions \nwithin LKH. Since the efficiency of LKH depends on the \nbalance of the key tree, we trade-off additional rekeying \nmessages for a balanced key tree. Figure 4 shows how the \nvideo encoded in cumulative layers in Figure 1 can be mapped \nonto our MLB-LKH. Each member not only receives the KEKs \non its path to root but the TEKs that are used to encrypt the \nrespective layers as well. It can be seen that the GC needs to \nmulticast the TEK of EL1 twice. \nThe placement of the members in MLB-LKH is important \nsince proper placement can minimise the number of rekeying \nmessages needed by the members. As shown in Figure 4, all \nSGs form at least one key tree of its own and related SGs are \nplaced side by side. As the multicast sessions might be \ndynamic, the GC must place the joining members according to \ntheir SGs. The worst case rekeying cost is 2 log k N + m if a \njoining member subscribes to the DG on the highest layer, \nwhere m is the highest layer in DG. Similarly for a depart \nevent, the worst case rekeying cost is k log k N + m if the \ndeparting member departs from the DG on the highest layer. \nSwitching between SGs is normal when a member requires \nadditional service or does not require that service anymore. The \nonly way is to treat that member as a departing member in the \nold SG and a joining member in its desired SG. For example, a \nmember might wish to subscribe for a higher quality multicast \nvideo due to the ample amount of bandwidth. The worst case \nrekeying cost happens when the two SGs have no interception \nother than the root as shown in Figure 5(a). The rekeying cost \nis (k + 2)(log k N \u2013 1) \u2013 1. Suppose there is an interception \nalong the path as shown in Figure 5(b), the best rekeying cost is \n(k + 2)(log k N \u2013 l \u2013 l) \u2013 1. \nSome multicast applications such as military \ncommunications not only require the group key to be changed \nimmediately after each membership changes, it may even be \nnecessary to stop data flow while such groups are being \nrekeyed [13]. Therefore, in order to reduce the latency needed \nby members who subscribe more layers than others, one \nmethod is to perform pseudo random function (PRF) on TEK \nin the highest affected layer to generate TEK in the lower layer. \nAssume the highest affected SG is m, the members in SGm \nneed to perform m PRF, F m (TEKm) = TEK0, to obtain all the \nnecessary TEKs for the multicast sessions as shown in Figure \n6. As for the required KEKs, it can take its time to decrypt the \nnecessary rekeying messages while receiving the multicast data \nat the same time. For example in Figure 4, one member in \nSGEL1 is departing; both TEKBL and TEKEL1 need to be \nchanged. The members in SGEL1 just need to receive the new \nTEKEL1, TEKEL1\u2019, and perform PRF on it to get TEKBL\u2019.  \nIV. SIMULATIONS AND PERFORMANCE COMPARISON \nFor simulation purpose, we adopted the scenario where the \nmulticast video is encoded with 4 cumulative layers. We use a \nbinary key tree with members ranging from 0 to 8096 and the \nmembers are dividing into 2\/16, 6\/16, 7\/16 and 1\/16 for each \nlayer respectively. \n \nFigure 4. Mapping of video encoding in cumulative layers on MLB-LKH \n \nA B\nlevel 0\nlevel l\n.\n.\n.\nA B\n(a) (b)  \nFigure 5. (a) Worst case and (b) Best Case of switching between SGs \n \n \nFigure 6. Generation of TEK using one-way chain \n \nFigure 7 shows the key storage for the GC and group \nmembers. The GC\u2019s storage in LKH grows at the faster rate \ncompared to MLB-LKH. This is because in LKH, each \nmulticast session is considered separately and this causes a lot \nof unnecessary keys to be stored by the GC. Although there are \nseveral work on minimisation of key at the GC side, which can \nminimise these effects [14, 15], the members still require a \nsignificant amount of storage if each multicast session is \nconsidered separately; the more services the members \nsubscribe to, the more redundant keys the members need to \nstore. As for MLB-LKH, the difference in key storage between \nthe members is at most m. From Figure 7(b), we can see that in \nLKH, the members in the highest layer store thrice the number \nof keys than the members in MLB-LKH. \nFor both approaches, once the number of members exceeds \n1000, the members\u2019 storage grows at a much slower rate. This \nis because the total number of members that can be \naccommodated double each time for every increment in height. \nHowever, the number of members in the key tree has \nsignificant effects on the GC side since it needs to store the \nindividual key of all group members as well as KEKs. \nIn Figure 8 and 9, we look at the effects of individual join \nand depart event in LKH and MLB-LKH. When the affected \nmember is in layer 2 or higher, the rekeying cost for LKH is at \nleast twice compared to MLB-LKH. Similarly as before, the \nhigher the affected layer, the higher the rekeying costs. For \nboth algorithms, the rekeying cost for joining member is higher \n1017\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 13,2010 at 14:37:39 UTC from IEEE Xplore.  Restrictions apply. \n0 2000 4000 6000 8000 10000\n0\n0.5\n1\n1.5\n2\n2.5\n3\n3.5 x 10\n4 GC Storage (4 Layers)\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nk\ne\ny\ns\n s\nto\nre\nd\nLKH\nMLB\u2212LKH\n0 2000 4000 6000 8000 10000\n0\n10\n20\n30\n40\n50\n60\nMembers Storage (4 Layers)\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nk\ne\ny\ns\n s\nto\nre\nd\nLKH(1)\nLKH(2)\nLKH(3)\nLKH(4)\nMLB\u2212LKH(1)\nMLB\u2212LKH(2)\nMLB\u2212LKH(3)\nMLB\u2212LKH(4)\n \nFigure 7. (a) GC storage and (b) members storage for LKH and MLB-LKH \n \n0 2000 4000 6000 8000 10000\n0\n20\n40\n60\n80\n100\n120\nLKH Joining Costs\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\nLayer 0\nLayer 1\nLayer 2\nLayer 3\n0 2000 4000 6000 8000 10000\n0\n20\n40\n60\n80\n100\nLKH Departing Costs\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\nLayer 0\nLayer 1\nLayer 2\nLayer 3\n \nFigure 8. LKH rekeying costs - (a) joining and (b) departing \n \n0 2000 4000 6000 8000 10000\n0\n5\n10\n15\n20\n25\n30\n35\nMLB\u2212LKH Joining Costs\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\nLayer 0\nLayer 1\nLayer 2\nLayer 3\n0 2000 4000 6000 8000 10000\n0\n5\n10\n15\n20\n25\n30\nMLB\u2212LKH Departing Costs\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\nLayer 0\nLayer 1\nLayer 2\nLayer 3\n \nFigure 9. MLB-LKH rekeying costs - (a) joining and (b) departing \n \ncompared to departing member because we started with a \ncompletely balanced LKH for all layers. In this example, the \nrekeying cost for joining and departing member in each layer \nfor LKH and MLB-LKH is 2 log 2 N0 + 2 and 2 log 2 N0 \u2013 1 \nrespectively, where N0 is the number of members in the key \ntree. \nAs it is common for members to subscribe additional \nservices or unsubscribe unwanted services, Figure 10 and 11 \ninvestigate all possibilities of switching for both algorithms. \nUsually, the rekeying cost for LKH is better compared to \nMLB-LKH when the group member switches by one layer \nregardless of whether that member is joining or departing. This \nis because only one key tree in LKH needs to be rekeyed for \nsuch changes whereas two SGs in MLB-LKH are affected. As  \n0 2000 4000 6000 8000 10000\n0\n10\n20\n30\n40\n50\n60\n70\n80\nLKH Switching (Low to High)\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\n0 to 1\n0 to 2\n0 to 3\n1 to 2\n1 to 3\n2 to 3\n0 2000 4000 6000 8000 10000\n0\n10\n20\n30\n40\n50\n60\n70\nLKH Switching (High to Low)\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\n1 to 0\n2 to 1\n2 to 0\n3 to 0\n3 to 1\n3 to 2\n \nFigure 10. LKH switching - (a) Low to high and (b) High to low \n \n0 2000 4000 6000 8000 10000\n0\n10\n20\n30\n40\n50\n60\nMLB\u2212LKH Switching (Low to High)\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\n0 to 1\n0 to 2\n0 to 3\n1 to 2\n1 to 3\n2 to 3\n0 2000 4000 6000 8000 10000\n0\n10\n20\n30\n40\n50\n60\nMLB\u2212LKH Switching (High to Low)\nNumber of Members\nN\nu\nm\nb\ne\nr \no\nf \nre\nk\ne\ny\nin\ng\n m\ne\nss\na\ng\ne\ns\n1 to 0\n2 to 1\n2 to 0\n3 to 0\n3 to 1\n3 to 2\n \nFigure 11. MLB-LKH switching - (a) Low to high and (b) High to low  \n \nfor other switching possibilities, MLB-LKH tends to \noutperform LKH when two or more key trees in LKH are \naffected. \nThere is another optimisation that can be used to reduce the \nrekeying costs and latency when a member, Ux\u2192y, switches \nfrom SGx to SGy, where keys in SGx are a proper subset of \nkeys in SGy. Rather than treating Ux\u2192y as a departing member \nin SGx and a joining member in SGy as before, the GC can \nmulticast the new TEK of SGy, TEK\u2019SGy, encrypted with the \ncurrent TEK of SGy, TEKSGy, to the existing members in SGy \nand unicast TEK\u2019SGy to Ux\u2192y encrypted with its individual key. \nThis is because all the other TEKs and KEKs are unaffected. \nHowever, this optimisation requires the GC to keep records of \nthe members who perform such switching. The actual \nswitching of Ux\u2192y takes place when there is a join, depart or \nother form of switching events. A point to be noted is that \nTEK\u2019SGy does not need to be able to generate the TEK below it \nusing PRF because all the other keys still remain the same. \nAlthough centralised multi-group key management scheme \nconsiders related multicast sessions as a whole, our approach \ndiffers from theirs by trading off rekeying costs for similar key \nstorage and number of decryptions among members. Suppose \nthere are a lot of related multicast layers and if the higher layer \nis very heavily populated compared to the lower layer, the \nnumber of decryptions that are needed can be quite significant \nfor centralised multi-group key management scheme. Reducing \nthe number of decryptions might reduce the waiting latency as \ndata flow might stop until all the remaining members get the \nkeys.  \n1018\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 13,2010 at 14:37:39 UTC from IEEE Xplore.  Restrictions apply. \nFor the simulation, we adopted the scenario where the \nvideo is encoded with 5 cumulative layers. Binary key tree \nwith three different group sizes are used. The splitting of the \nmembers are 0.05%, 0.1%, 0.1%, 0.3% and 0.45% for each \nlayer respectively.  \nFrom Figure 12, we can see the difference between the \nlowest and highest layer for centralised multi-group key \nmanagement is around 10 keys. This means that every member \nthat is joining or departing the highest layer will need 10 \nadditional decryptions compared to the member that is joining \nor departing in the lowest layer. Furthermore, the rekeying cost \nwill be higher as explained in section II. As for MLB-LKH, the \ndifference between the lowest and highest layer is just the \nnumber of layers in the multicast session.  \nV. CONCLUSION \nIn this paper, we have discussed how LKH is used to secure \nmulticast communication. First, we described how LKH can be \nused to secure a multicast session for a group of members. \nFrom there, we extended this idea to secure several related \nmulticast sessions. In addition, we have also taken the balance \nof LKH into consideration. \nIf related multicast sessions are considered as a whole, the \ntotal number of keys needed in the key tree and the rekeying \ncosts are greatly reduced. For our simulation using video \nencoded with 4 cumulative layers, the key storage at the GC \nand members\u2019 side is reduced by at least half. As for the \nindividual join and depart rekeying costs, the higher the \naffected layer, the higher the rekeying costs. In the case of \nMLB-LKH, the difference in rekeying costs for a join or depart \nevent is at most m. However, we observe that when a member \nswitches by one layer, regardless of whether that member is \njoining or departing the group, the rekeying cost is generally \nlower for LKH due to the fact that only that layer key tree \nneeds to be rekeyed whereas two SGs in MLB-LKH are \naffected. For other switching possibilities, MLB-LKH tends to \nbe better than LKH. However, MLB-LKH requires proper \nplacement of members in the key tree in order to minimise the \nrekeying costs. Most importantly, the members must be \ngrouped according to their SGs. When compared to centralised \nmulti-group key management scheme, we trade-off rekeying \ncosts for a balanced key. This not only allows the member to \nhave similar key storage but similar number of decryptions \nwhenever there is change in group membership.  \nTwo optimisation techniques are proposed to further \nenhance our algorithm. Since it might be necessary for some \nmulticast applications to stop data flow during rekeying, one \nmethod to reduce latency is to perform PRF on the TEK in \nhighest affected layer to get the TEK in the lower layer. As for \nKEKs, the members can take its time to decrypt the rekeying \nmessages while receiving the multicast data. Another \noptimisation is when a member switches between layers, where \nkeys in the old layer are a proper subset of the keys in the new \nlayer. The GC just needs to generate another TEK for the new \nlayer and send it to the existing members in that layer and the \njoining member. \n1 2 3 4 5\n10\n15\n20\n25\n30\nLayers\nN\nu\nm\nb\ne\nr \no\nf \nk\ne\ny\ns\nCentralised Multi\u2212Group Key Management Scheme\n10000 members\n100000 members\n1000000 members\n1 2 3 4 5\n14\n16\n18\n20\n22\n24\n26\n28\n30\nLayers\nN\nu\nm\nb\ne\nr \no\nf \nk\ne\ny\ns\nMLB\u2212LKH\n10000 members\n100000 members\n1000000 members\n \nFigure 12. Number of key held by members at different layers: (a) Centralised \nmulti-group key management scheme and (b) MLB-LKH \nREFERENCES \n \n[1] S. .E. Deering, \u201cHost Extensions for IP Multicasting\u201d, RFC 1112, IETF, \nAug 1989. \n[2] D.M. Wallner and E.J. Harder and R.C. Agee, \u201cKey management for \nmulticast issues and architectures\u201d, RFC 2627, Jun. 1999. \n[3] C. Wong, M. Gouda and S. Lam, \u201cSecure group communication using \nkey graphs\u201d, IEEE\/ACM Trans. Networking, Vol. 8. pp. 12-23, Feb. \n2000. \n[4] S. Mittra, \u201cIolus: A framework for scalable secure multicasting\u201d, In \nProc. ACM SIGCOMM, Vol. 27, pp. 277-288, Sept. 1997. \n[5] D. . Balenson, D. McGrew and A. Sherman, \u201cKey Management for large \ndynamic groups: One-way function trees and amortised initialisation\u201d, \nInternet Draft, draft-irtf-smug-groupkeymgmt-oft-00.txt. Aug. 2000. \n[6] M. Valdvogel, G. Caronni, D. Sun, N. Weiler and B. Plattner, \u201cThe \nversakey frameworks: versatile group key management\u201d, IEEE JSAC \n(Special Issue on Middleware), Vol. 17, No. 9, pp. 1614-1631, Sept \n1999. \n[7] I.Chang, R. Engel, D. Kandlur, D. Pendarakis, D. Saha, \u201cKey \nmanagement for secure Internet multicast using boolean function \nminimization techniques. IEEE INFOCOM, Mar. 1999 \n[8] M.J. Moyer, J.R. Rao, P. Rohatgi, \u201cMaintaining balanced key trees for \nsecure multicast\u201d, Internet Draft, draft-irtf-smug-key-tree-balance-00.txt, \nJun. 1999. \n[9] J. Pegueroles, F. Rico-Novella, \u201cBalanced Batch LKH: New proposal, \nimplementation and performance evalution\u201d, IEEE Symposium on \nComputers and Communications (ISCC), Jun. 2003. \n[10] Y. Sun, K.J. Ray Liu, \u201cMulti-layer management for secure multimedia \nmulticast communications\u201d, IEEE Iternational Conference on \nMultimedia and Expo (ICME), Vol. 2, pp. 205-208, Jul. 2003. \n[11] Y. Sun, K.J. Ray Liu, \u201cScalable hierarchical access control in secure \ngroup communications\u201d, IEEE INFOCOM, Hong Kong, Mar. 2004. \n[12] M. P. Howarth, S. Iyengar, Z. Sun, H. Cruickshank, \u201cDynamics of key \nmanagement in secure satellite multicast\u201d, IEEE JSAC, Feb 2004. \n[13] B. DeCleene, L. Dondeti, S. Griffin, T. Hardjono, D. Kiwior, J. Kurose, \nD. Towsley, S. Vasudevan, C. Zhang, \u201cSecure group communication for \nwireless networks\u201d, In Proc. MILCOM, Oct. 2001. \n[14] Y. Tseng, \u201cA scalable key management scheme with minimizing key \nstorage for secure group communications\u201d, International Journal of \nNetwork Management, Nov. 2003. \n[15] J. Pegueroles, J. Hernandez-Serrano, F. Rico-Novella, M. Soriano, \n\u201cAdapting GDOI for balanced batch-LKH\u201d, Internet Draft, draft-irtf-\ngsec-gdoi-batch-lkh-00.txt, Jun. 2003. \n \n1019\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 13,2010 at 14:37:39 UTC from IEEE Xplore.  Restrictions apply. \n"}