{"doi":"10.1016\/S0020-0190(98)00196-3","coreId":"65478","oai":"oai:dro.dur.ac.uk.OAI2:5733","identifiers":["oai:dro.dur.ac.uk.OAI2:5733","10.1016\/S0020-0190(98)00196-3"],"title":"On the power of built-in relations in certain classes of program schemes.","authors":["Chauhan,  S. R.","Stewart,  I. A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"1999-01-01","abstract":"We completely classify the relative expressibilities of the program schemes of NPS augmented with the built-in relations: linear order; addition; multiplication; and BIT.  We employ pebble games allied with some number theory","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65478.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/5733\/1\/5733.pdf","pdfHashValue":"6667936361d2fd24efd48d182b272977faf60f16","publisher":"Elsevier","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:5733<\/identifier><datestamp>\n      2011-11-09T15:51:58Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        On the power of built-in relations in certain classes of program schemes.<\/dc:title><dc:creator>\n        Chauhan,  S. R.<\/dc:creator><dc:creator>\n        Stewart,  I. A.<\/dc:creator><dc:description>\n        We completely classify the relative expressibilities of the program schemes of NPS augmented with the built-in relations: linear order; addition; multiplication; and BIT.  We employ pebble games allied with some number theory.<\/dc:description><dc:subject>\n        Computational complexity<\/dc:subject><dc:subject>\n         Descriptive complexity<\/dc:subject><dc:subject>\n         Finite model theory<\/dc:subject><dc:subject>\n         Program schemes.<\/dc:subject><dc:publisher>\n        Elsevier<\/dc:publisher><dc:source>\n        Information processing letters, 1999, Vol.69(2), pp.77-82 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        1999-01-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:5733<\/dc:identifier><dc:identifier>\n        issn:0020-0190<\/dc:identifier><dc:identifier>\n        doi:10.1016\/S0020-0190(98)00196-3<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/5733\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1016\/S0020-0190(98)00196-3<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/5733\/1\/5733.pdf<\/dc:identifier><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:0020-0190","0020-0190"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":1999,"topics":["Computational complexity","Descriptive complexity","Finite model theory","Program schemes."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n01 July 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nChauhan, S. R. and Stewart, I. A. (1999) \u2019On the power of built-in relations in certain classes of program\nschemes.\u2019, Information processing letters., 69 (2). pp. 77-82.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1016\/S0020-0190(98)00196-3\nPublisher\u2019s copyright statement:\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n01 July 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status of attached file: \nAccepted for publication \n \nCitation for published item: \nChauhan, S. R. and Stewart, I. A. (1999) 'On the power of built-in relations in certain classes \nof program schemes.', Information processing letters., 69 (2). pp. 77-82. \n \nFurther information on publisher\u2019s website: \nhttp:\/\/dx.doi.org\/10.1016\/S0020-0190(98)00196-3 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nOn the power of built-in relations in\ncertain classes of program schemes\nS.R. Chauhan a,1 and I.A. Stewart b,2\naDepartment of Computer Science, University of Wales Swansea,\nSwansea SA2 8PP, U.K.\nbDepartment of Mathematics and Computer Science, Leicester University,\nLeicester LE1 7RH, U.K.\nKey words: Computational complexity. Descriptive complexity. Finite model\ntheory. Program Schemes.\n1 Introduction\nOne of the fundamental results of finite model theory is Immerman\u2019s char-\nacterization [10,11] of the complexity class NL (non-deterministic logspace)\nas the class of problems definable in transitive closure logic augmented with\na built-in successor relation, (\u00b1TC)\u2217[FOs]. Essentially, by \u201cbuilt-in successor\nrelation\u201d we mean that any sentence of the logic has access to a successor\nrelation on the universe of the (finite) structure in which it is interpreted (and\nwhere this successor relation does not necessarily come as part of the struc-\nture). So that our sentences should define problems, i.e., sets of structures\nclosed under isomorphism, we only ever consider the invariant sentences; that\nis, those sentences with the property that every (appropriate) structure ei-\nther satisfies the sentence no matter which successor relation is chosen or it\ndoesn\u2019t satisfy the sentence no matter which successor relation is chosen. Un-\nfortunately, the property of being an invariant sentence is not decidable, even\nfor first-order logic with a built-in successor relation [7], and so one should not\nreally say that one has a truly \u201clogical\u201d characterization of NL. The general\nquestion of whether complexity classes such as NL and P (polynomial-time)\n1 Supported by EPSRC Ph.D. Studentship 93317145.\n2 Partially supported by British-German ARC Project 604 and EPSRC Grant\nGR\/H 81108. Much of the work in this paper was done whilst the author was\nat the University of Wales Swansea.\nPreprint\nactually possess \u201clogical\u201d characterizations is the subject of much research in\nfinite model theory (see, for example, [5] and [13]).\nImmerman proved yet more: he actually produced a normal form for the sen-\ntences of (\u00b1TC)\u2217[FOs]. As observed in [14], this normal form result can be\nre-interpreted as a result about the expressive power of a very simple class\nof program schemes in the presence of a built-in successor relation. A pro-\ngram scheme of NPS takes a finite structure as input and is essentially a\nnon-deterministic while-program with a constant number of variables, these\nvariables taking values from the universe of the input structure, and where\nthe tests in any while-instruction are quantifier-free first-order formulae (these\nare \u201cpoor tests\u201d, in the parlance of [12]; as opposed to \u201crich tests\u201d which are\nfirst-order formulae). If we allow the program schemes of NPS to additionally\nhave access to a built-in successor relation then we denote the resulting class\nof program schemes by NPS(succ). Re-interpreting Immerman\u2019s result yields\na characterization of NL as the class of problems accepted by the program\nschemes of NPS(succ) (a similar result, though in a different context, was\nderived earlier in [8]).\nThe question arises as to whether this very simple class of program schemes\nNPS can be augmented with other different built-in relations so as to yield\na characterization of NL; and it is this question that provides the initial mo-\ntivation for this paper (other studies arising from similar motivations can be\nfound in, for example, [6] and [15]). Our choice of other built-in relations to\nconsider is influenced by what has been studied already in other contexts in\nfinite model theory. In particular, in [1] it is proven that first-order logic aug-\nmented with the built-in relations\u2264, a linear order, and BIT , a binary relation\nsuch that BIT (i, j) holds iff \u201cthe ith bit of the binary representation of the\nnatural number j is 1\u201d, characterizes the complexity class AC0. As remarked\nin, for example, [2], this logic is equivalent to the extension of first-order logic\nwith the built-in binary relation \u2264 and the built-in ternary relations +, an\naddition, and \u00d7, a multiplication. Hence, the four built-in relations we shall\nconsider are succ, \u2264, + and \u00d7. In fact, we completely classify the relative\nexpressibilities of the program schemes of NPS augmented with these built-in\nrelations, as is depicted in Fig. 1 (a bold line joining two classes indicates that\nthe upper class is more expressive than the lower class, and a dashed line that\nthe classes are incomparable).\nWhilst, admittedly, the scenario described above is rather esoteric, it turns\nout that as well as the above classification, we can actually obtain analogous\nclassifications for both bounded-variable infinitary logic, L\u03c9\u221e\u03c9, and its existen-\ntial fragment, \u2203L\u03c9\u221e\u03c9. The logic L\u03c9\u221e\u03c9 features widely in finite model theory: for\ninstance, transitive closure logic, least fixed point logic and partial fixed point\nlogic are all fragments of L\u03c9\u221e\u03c9 (see, for example, [5]). The classification for\nextensions of \u2203L\u03c9\u221e\u03c9 is exactly that in Fig. 1 with \u201cNPS\u201d replaced by \u201c\u2203L\u03c9\u221e\u03c9\u201d,\n2\nand \u201cNL =\u201d omitted. The classification for L\u03c9\u221e\u03c9 is as follows.\nNL = NPS(succ) = NPS(+,\u00d7)\nNPS(+) NPS(\u00d7,\u2264)\nNPS(\u2264) NPS(\u00d7)\nNPS\nFigure 1. How the classes of program schemes relate.\nTheorem 1 L\u03c9\u221e\u03c9 \u2282 L\u03c9\u221e\u03c9(\u00d7) \u2282 L\u03c9\u221e\u03c9(succ) = L\u03c9\u221e\u03c9(+) = L\u03c9\u221e\u03c9(\u2264).\nOur classifications follow from Proposition 5 where our basic methodology is\nto exhibit problems in certain program-scheme classes which are not defin-\nable in certain infinitary-logic classes, and to use the simple observation that\na program-scheme class is a fragment of the analogous infinitary-logic class.\nIn order to prove our inexpressibility results for L\u03c9\u221e\u03c9, we use well established\npebble games. Let us remark that if we allow first-order tests in the program\nschemes of NPS, i.e.,\u201c rich tests\u201d, then we obtain a result identical to Theo-\nrem 1 except with \u201cNPS\u201d replacing \u201cL\u03c9\u221e\u03c9\u201d.\n2 Program schemes and logics\nThe reader is referred to [5] for details of any finite model theoretic concepts\nand notions not covered here. Any program scheme is defined to be over some\nfixed signature, with a signature \u03c4 being a finite tuple \u3008R1, . . . , Rr, C1, . . . , Cc\u3009,\nwhere each Ri is a relation symbol, of some fixed positive arity di, and where\neach Cj is a constant symbol (function symbols are not allowed in our signa-\ntures). A program scheme \u03c1 \u2208 NPS(\u03c4) is a finite sequence of instructions of\none of the following types):\n\u2022 atoms consist of: the variables {xi : i = 1, 2, . . .}; the constant symbols of\n\u03c4 ; and the constant symbols 0 and max (which we ensure do not occur in\nany signature)\n\u2022 assignment instructions are of the form:\n\u00b7 var := atom, where var denotes some variable and atom some atom\n\u00b7 guess(var), where var denotes some variable\n3\n\u2022 test instructions are of the form WHILE t DO i1, i2, . . . , ik OD, for some\nk \u2265 0 and instructions i1, i2, . . . , ik, where t is a boolean combination of\nboolean tests , or their negations, of the form:\n\u00b7 y1 = y2, where y1 and y2 are atoms\n\u00b7 R(y1, y2, . . . , yd), where R is a d-ary relation symbol of \u03c4 and y1, y2, . . . , yd\nare atoms\n\u2022 input\/output instructions are of the form input(x1, x2, . . . , xm) and output\n(x1, x2, . . . , xm), where x1, x2, . . . , xm are the input\/output variables.\nThe first (resp. last) instruction of any program scheme is the input (resp.\noutput) instruction, and any program scheme has exactly one input and one\noutput instruction. Also, the input\/output variables are exactly those variables\ninvolved in any program scheme. Without loss of generality, we may assume\nthat there is available an IF . . . THEN . . . (ELSE . . .) FI instruction (see [14]).\nA program scheme over the signature \u03c4 = \u3008R1, . . . , Rr, C1, . . . , Cc\u3009 takes as\ninput a finite structure S over \u03c4 , or \u03c4 -structure, where S = \u3008{0, 1, . . . , n \u2212\n1}, RS1 , . . . , RSr , CS1 , . . . , CSc \u3009, with |S| = {0, 1, . . . , n\u22121} the universe of S, and\nwith each RSi \u2286 |S|di and each CSj \u2208 |S|: we also write |S| to denote the size\nn of S (this causes no confusion; and nor does our choice of leaving out super-\nscripts denoting the structure in which a relation symbol, etc., is interpreted).\nWe denote the class of all structures over some signature \u03c4 by STRUCT(\u03c4).\nThe interpretation of some program scheme \u03c1 over \u03c4 in a \u03c4 -structure S of\nsize n should be obvious except that we require: that the initial values (from\n|S|) of the input\/output variables are given; that the constant symbols 0 and\nmax are interpreted arbitrarily but differently in S (we assume all structures\nhave size at least 2); and that any instruction guess(xi) nondeterministically\nassigns some value of |S| to the variable xi. We say that \u03c1 accepts S, and\nwrite S |= \u03c1 if, and only if, with the input\/output variables initially all set\nat 0, there exists a computation of \u03c1 on input S such that \u03c1 halts with the\ninput\/output variables all set at max.\nAs things stand, acceptance of a structure by a program scheme depends upon\nthe interpretation of 0 and max, and as such is clearly unacceptable. We could\nremedy this situation by insisting that every structure S always comes with\nits own constants 0 and max; but this would force us to consider natural ob-\njects like graphs unnaturally, i.e., by supplying two additional distinguished\nvertices. We remedy this discrepancy by only ever considering certain pro-\ngram schemes. Henceforth, we only consider program schemes \u03c1 for which the\nfollowing is true: for every \u03c4 -structure S (where \u03c4 is the underlying signature\nof \u03c1) and for every 0, 0\u2032,max,max\u2032 \u2208 |S| for which 0 \n= max and 0\u2032 \n= max\u2032,\n(S, 0,max) |= \u03c1 iff (S, 0\u2032,max\u2032) |= \u03c1. That is, we only ever consider program\nschemes with 2 built-in constants . Consequently, the set of structures accepted\nby a program scheme \u03c1 constitute a problem; that is, a set of finite structures,\nover some fixed signature, which is closed under isomorphism. We write NPS\n4\nto denote the class of program schemes {\u03c1 \u2208 NPS(\u03c4) : \u03c4 some signature} (with\nthe above proviso on each \u03c1), and also write NPS to denote those problems\naccepted by some program scheme of NPS (the same goes for other classes of\nprogram schemes defined later).\nJust as we augmented program schemes with two built-in constants, so we\ncan augment them with built-in relations. For example, to say that a pro-\ngram scheme has a built-in successor relation is to say that a program scheme\nhas available: a binary relation succ that is always interpreted as a successor\nrelation on the universe of an input structure, i.e., as a relation of the form\n{(u0, u1), (u1, u2), . . . , (un\u22122, un\u22121)}, where the input structure has size n; and\nalso two constant symbols 0 and max that are always interpreted as the least\nand greatest elements of the successor relation, i.e., as u0 and un\u22121, respec-\ntively. Just as before, we only ever consider those program schemes with a\nbuilt-in successor relation which define problems, i..e, those program schemes\n\u03c1, over the signature \u03c4 , such that for every \u03c4 -structure S and for every pair of\nsuccessor relations succ and succ\u2032 (with associated \u201cleast\u201d and \u201cgreatest con-\nstants\u201d), (S, succ, 0,max) |= \u03c1 iff (S, succ\u2032, 0\u2032,max\u2032) |= \u03c1. We denote the class\nof problems accepted by program schemes with a built-in successor relation\nas NPS(succ).\nA built-in linear-order \u2264 is defined as was a built-in successor, and we write\n\u2264 (u, v) as u \u2264 v; a built-in addition is defined by allowing a program scheme\naccess to a ternary relation + that is always interpreted as an \u201caddition\u201d on\nthe universe of some input structure, and we write +(u, v, w) as u + v = w;\nand a built-in multiplication is defined by allowing a program scheme access\nto a ternary relation \u00d7 that is always interpreted as a \u201cmultiplication\u201d on the\nuniverse of some input structure, and we write \u00d7(u, v, w) as u \u00d7 v = w. The\nbuilt-in constants 0 and max are the least and greatest elements of the linear\norder \u2264, addition + and multiplication \u00d7, respectively.\nWe use pebble games to prove our separation results. Let \u03c4 be some signature.\nThe k-pebble infinitary game on the \u03c4 -structures S and T is played by two\nplayers, Spoiler and Duplicator, as follows. The board consists of the two struc-\ntures S and T , and there are k pairs of pebbles {p1, q1}, {p2, q2}, . . . , {pk, qk}.\nA move of the game consists of Spoiler picking up some pebble pi (resp. qi),\nwhich may or may not have previously been played, and placing it on some\nelement of |S| (resp. |T |): then Duplicator picks up pebble qi (resp. pi) and\nplaces it on some element of |T | (resp. |S|). Spoiler wins after a move has been\nmade if the substructure of S induced by the elements upon which pebbles are\ncurrently placed (and any constants) is not isomorphic to the substructure of\nT induced by the elements upon which pebbles are currently placed, where the\nisomorphism is that given by mapping the element of |S| upon which pebble pi\nis currently placed (if indeed it has been so placed) to that of |T | upon which\npebble qi is currently placed and mapping a constant of S to the correspond-\n5\ning constant of T (also, if this mapping is not well-defined then Spoiler wins).\nThe game may be infinite. We say that Duplicator has a winning strategy in\nthe k-pebble infinitary game on S and T if no matter how Spoiler moves,\nDuplicator can prolong the game indefinitely (we prefer to leave the notion of\na \u201cwinning strategy\u201d intuitive rather than define it rigorously).\nThe k-pebble infinitary game classifies definability in the logic Lk\u221e\u03c9, which\nis defined as follows: Lk\u221e\u03c9 is the fragment of the logic L\u221e\u03c9 with at most k\nvariables, where the logic L\u221e\u03c9 is first-order logic where infinite conjunctions\nand disjunctions may be formed. Bounded-variable infinitary logic is defined\nas L\u03c9\u221e\u03c9 = \u222akLk\u221e\u03c9. The existential fragment, \u2203L\u03c9\u221e\u03c9, of L\u03c9\u221e\u03c9 consists of all\nthose formulae not involving the universal quantifier \u2200. It is easy to see that\nNPS \u2286 \u2203L\u03c9\u221e\u03c9 (and also in the presence of built-in relations).\nTheorem 2 [3,9] Let \u03c4 be some signature and let S and T be \u03c4 -structures.\nThe Duplicator has a winning strategy in the k-pebble infinitary game on S\nand T iff S and T agree on all sentences of Lk\u221e\u03c9. Moreover, the Duplicator\nhas a winning strategy in the restricted k-pebble infinitary game on S and T\nwhere Spoiler only ever plays in S iff S and T agree on all sentences of \u2203Lk\u221e\u03c9.\nWe close this section with some historical remarks. Program schemes were ex-\ntensively studied in the seventies, without much regard being paid to resources,\nbefore a closer complexity analysis was undertaken in, mainly, the eighties (see\n[12] and the references therein). In the late eighties, program schemes were de-\nveloped to work on finite structures [14], mindful of advances in descriptive\ncomplexity theory. We feel that the links between program schemes, logics for\nprograms, dynamic logic, etc., and the logics studies in finite model theory,\nparticularly those involving generalized quantifiers, have not been considered\nin the past as fully as they might have been, and that this is an interesting\nprospective area of research.\n3 The basic results\nLet the signature \u03c4 = \u3008U,E,C,D\u3009, where U is a unary relation symbol, E\nis a binary relation symbol and C and D are constant symbols. Define the\nproblem BP as consisting of all those \u03c4 -structures such that there is a path in\nthe digraph described by E from vertex C to vertex D of length at most \u03bd,\nwhere \u03bd = |{u : U(u) holds}|.\nTheorem 3 BP \u2208 NPS (\u2264) \\ L\u03c9\u221e\u03c9(\u00d7).\nPROOF. The following program scheme \u03c1 \u2208 NPS(\u2264) accepts BP:\n6\ninput(x,y,u,v)\nIF C \n= D THEN\nguess(u)\nWHILE \u00acU(u) DO guess(u) OD\nguess(x)\nWHILE \u00acE(C,x) DO guess(x) OD\nWHILE x \n= D DO\nguess(v)\nWHILE \u00acU(v) \u2228 v \u2264 u DO guess(v) OD\nguess(y)\nWHILE \u00acE(x,y) DO guess(y) OD\nu := v\nx := y\nOD\nFI\nx, y, u, v := max\noutput(x,y,u,v)\nSuppose that BP is definable by a sentence \u03c8 \u2208 Lk\u221e\u03c9(\u00d7), for some k.\nLemma 4 For every k, there exists an n such that there are at least k distinct\nprimes greater than n\/2 and less than n.\nPROOF. From Tchebychev\u2019s Theorem [4, p.55], if \u03a0(x) denotes the number\nof primes not exceeding x then:\n0.92\nx\nln x\n\u2264 \u03a0(x) \u2264 1.22 x\nln x\n,\nfor all sufficiently large x, and so \u03a0(2x)\u2212 \u03a0(x) \u2192\u221e as x \u2192\u221e. \u0002\nLet n be such that {p1, p2, . . . , p2k+2} is a set of distinct primes, each of which\nis greater than n\/2 and less than n: given k, such an n exists by Lemma 4.\nDefine the \u03c4 -structure S = \u3008{0, 1, . . . , n\u2212 1}, US, ES, CS, DS\u3009 as follows:\nUS = {p1, p2, . . . , pk+1}, ES = {(i, i + 1) : i = 0, 1, . . . , k + 1}\nCS = 0, DS = k + 1.\nLet T be defined exactly as was S except that pk+1 \n\u2208 UT . Note that S \u2208 BP\nbut T \n\u2208 BP. Let the relation symbol \u00d7 and the constant symbols 0 and\nmax be interpreted as the natural multiplication on |S| = |T |, 0 \u2208 |S| = |T |\nand n \u2212 1 \u2208 |S| = |T |, respectively. By hypothesis, (S,\u00d7, 0,max) |= \u03c8 and\n(T,\u00d7, 0,max) \n|= \u03c8.\n7\nConsider the following winning strategy for Duplicator in the k-pebble Ehren-\nfeucht-Fra\u00a8\u0131sse\u00b4 game on (S,\u00d7, 0,max) and (T,\u00d7, 0,max). Write V S = {pk+2,\npk+3, . . . , p2k+2}, V T = {pk+1, pk+2, . . . , p2k+2}, W S = |S| \\ (US \u222a V S) and\nW T = |T | \\ (UT \u222a V T ).\n\u2022 If Spoiler plays on an unpebbled element in US (resp. UT , V S, V T ) then\nDuplicator plays on an unpebbled element in UT (resp. US, V T , V S).\n\u2022 If Spoiler plays on a pebbled element in US (resp. UT , V S, V T ) then Du-\nplicator plays on the corresponding pebbled element in UT (resp. US, V T ,\nV S).\n\u2022 If Spoiler plays in W S (resp. W T ) then Duplicator plays on the element of\nthe same name in W T (resp. W S).\nTheorem 2 yields a contradiction. \u0002\nProposition 5 (i) NPS (succ) = NPS (+,\u00d7)(= NL) and \u2203L\u03c9\u221e\u03c9(succ) =\n\u2203L\u03c9\u221e\u03c9(+,\u00d7).\n(ii) NPS (\u2264) \u2286 NPS (+) and \u2203L\u03c9\u221e\u03c9(\u2264) \u2286 \u2203L\u03c9\u221e\u03c9(+).\n(iii) There are problems in NPS (succ) which are not in \u2203L\u03c9\u221e\u03c9(\u2264).\n(iv) There are problems in NPS (+) which are not in \u2203L\u03c9\u221e\u03c9(\u2264).\n(v) There are problems in NPS (\u00d7) which are not in \u2203L\u03c9\u221e\u03c9(+).\n(vi) There are problems in NPS (+) which are not in \u2203L\u03c9\u221e\u03c9(\u2264,\u00d7).\nPROOF. (Sketch)\n(i) and (ii) Simple exercises.\n(iii) and (iv) The problem ODD consisting of all those structures of odd\nsize over the empty signature \u03c4\u0003 is in NPS(succ) and NPS(+). A simple\nEhrenfeucht-Fra\u00a8\u0131sse\u00b4 game on two sufficiently large \u03c4\u0003-structures Sn and Sn+1,\nthe first of odd size n and the second of even size n + 1, yields that ODD \n\u2208\n\u2203L\u03c9\u221e\u03c9(\u2264) (take the natural linear orders in Sn and Sn+1, and let Duplica-\ntor\u2019s winning strategy be given by the function f : |Sn| \u2192 |Sn+1| defined as\nf : i \u0010\u2192 i, for all i \u2208 {0, 1, . . . , n\u2212 2}, and f(n\u2212 1) = n).\n(v) The problem PERF1 consisting of all those structures over the signa-\nture \u03c4\u0003 whose size is 1 plus a perfect square is in NPS(\u00d7). Let p be a suf-\nficiently large even number. A simple Ehrenfeucht-Fra\u00a8\u0131sse\u00b4 game on two \u03c4\u0003-\nstructures Sp2+1 and S2p2+1 of sizes p\n2+1 and 2p2+1, respectively, yields that\nPERF1 \n\u2208 \u2203L\u03c9\u221e\u03c9(+) (take the natural additions in Sp2+1 and S2p2+1, and let\nDuplicator\u2019s winning strategy be given by the function f : |Sp2+1| \u2192 |S2p2+1|\ndefined as f : i \u0010\u2192 2i).\n(vi) The problem ODD is in NPS(+). A simple Ehrenfeucht-Fra\u00a8\u0131sse\u00b4 game\non two \u03c4\u0003-structures S3 and S4 of sizes 3 and 4, respectively, yields that any\nproblem in \u2203L\u03c9\u221e\u03c9(\u00d7) which contains S3 must contain S4 (take the natural\nmultiplications in S3 and S4 and the natural linear orders in S3 and S4, and\nlet Duplicator\u2019s winning strategy be given by the function f : |S3| \u2192 |S4|\n8\ndefined as f(0) = 0, f(1) = 1 and f(2) = 3.) \u0002\nReferences\n[1] D.A.M. Barrington, N. Immerman and H. Straubing, On uniformity within\nNC1, J. Comput. System Sci. 41 (1990) 274\u2013306.\n[2] D.M. Barrington and N. Immerman, Time, hardware and uniformity, Proc. 9th\nIEEE Ann. Conf. on Structure in Complexity Theory , IEEE Press (1994) 176\u2013\n185.\n[3] J. Barwise, On Moschovakis closure ordinals, J. Symbolic Logic 42 (1977) 292\u2013\n296.\n[4] H. Davenport, Multiplicative Number Theory , Springer (1980).\n[5] H.D. Ebbinghaus and J. Flum, Finite Model Theory , Springer-Verlag (1995).\n[6] K. Etessami and N. Immerman, Reachability and the power of local ordering,\nTheoret. Comp. Sci. 148 (1995) 227\u2013260.\n[7] Y. Gurevich, Logic and the challenge of computer science, in: Current Trends in\nTheoretical Computer Science (ed. E. Bo\u00a8rger), Computer Science Press (1988)\n1\u201357.\n[8] D. Harel and D. Peleg, On static logics, dynamic logics, and complexity classes,\nInf. Control 60 (1984) 86-102.\n[9] N. Immerman, Upper and lower bounds for first-order expressibility, J. Comput.\nSystem Sci. 25 (1982) 76\u201398.\n[10] N. Immerman, Languages which capture complexity classes, SIAM J. Comput.\n16 (1987) 760\u2013778.\n[11] N. Immerman, Nondeterministic space is closed under complementation, SIAM\nJ. Comput. 17 (1988) 935\u2013938.\n[12] D. Kozen and J. Tiuryn, Logics of programs, in: Handbook of Theoretical\nComputer Science Vol. B (ed. J. van Leeuwen), Elsevier (1990) 789\u2013840.\n[13] M. Otto, Bounded variable logics and counting, Lecture Notes in Logic Vol. 9,\nSpringer-Verlag (1997).\n[14] I.A. Stewart, Logical and schematic characterization of complexity classes, Acta\nInformat. 30 (1993) 61\u201387.\n[15] H. Straubing, Finite Automata, Formal Logic and Circuit Complexity ,\nBirkha\u00a8user (1994).\n9\n"}