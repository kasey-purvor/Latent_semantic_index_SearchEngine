{"doi":"10.1109\/IPDPS.2010.5470369","coreId":"65284","oai":"oai:dro.dur.ac.uk.OAI2:6293","identifiers":["oai:dro.dur.ac.uk.OAI2:6293","10.1109\/IPDPS.2010.5470369"],"title":"A general algorithm for detecting faults under the comparison diagnosis model.","authors":["Stewart, I. A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2010-04-01","abstract":"We develop a widely applicable algorithm to solve the fault diagnosis problem in certain distributed-memory multiprocessor systems in which there are a limited number of faulty processors. In particular, we prove that if the underlying graph G = (V,E) forming the interconnection network has connectivity no less than its diagnosability \u03b4 and can be partitioned into enough connected components of large enough size then given a syndrome of test results under the comparison diagnosis model resulting from some set of faulty nodes of size at most \u03b4, we can find the actual set of faulty nodes with time complexity O(\u0394N), where \u0394 is the maximal degree of any node of the graph and N is the number of nodes","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65284.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6293\/1\/6293.pdf","pdfHashValue":"956a105a5b0b6ee42348a72b41287e10074d72d1","publisher":"IEEE","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6293<\/identifier><datestamp>\n      2010-11-08T12:03:29Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        A general algorithm for detecting faults under the comparison diagnosis model.<\/dc:title><dc:creator>\n        Stewart, I. A.<\/dc:creator><dc:description>\n        We develop a widely applicable algorithm to solve the fault diagnosis problem in certain distributed-memory multiprocessor systems in which there are a limited number of faulty processors. In particular, we prove that if the underlying graph G = (V,E) forming the interconnection network has connectivity no less than its diagnosability \u03b4 and can be partitioned into enough connected components of large enough size then given a syndrome of test results under the comparison diagnosis model resulting from some set of faulty nodes of size at most \u03b4, we can find the actual set of faulty nodes with time complexity O(\u0394N), where \u0394 is the maximal degree of any node of the graph and N is the number of nodes.<\/dc:description><dc:subject>\n        Interconnection networks<\/dc:subject><dc:subject>\n         Fault diagnosis<\/dc:subject><dc:subject>\n         Comparison diagnosis model.<\/dc:subject><dc:publisher>\n        IEEE<\/dc:publisher><dc:source>\n        (2010). 2010 IEEE International Symposium on Parallel and Distributed Processing IPDPS, 19-23 April 2010, Atlanta GA, ; proceedings. . : IEEE, pp. 1-9<\/dc:source><dc:date>\n        2010-04-01<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6293<\/dc:identifier><dc:identifier>\n        doi:10.1109\/IPDPS.2010.5470369 <\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6293\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1109\/IPDPS.2010.5470369 <\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6293\/1\/6293.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2010 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other users, including reprinting\/ republishing this (c) 20xx IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other users, including reprinting\/ republishing this material for advertising or promotional purposes, creating new collective works for resale or redistribution to servers or lists, or reuse of any copyrighted components of this work in other works.material for advertising or promotional purposes, creating new collective works for resale or redistribution to servers or lists, or reuse of any copyrighted components of this work in other works.\\ud\n<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2010,"topics":["Interconnection networks","Fault diagnosis","Comparison diagnosis model."],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n29 June 2010\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nStewart, I. A. (2010) \u2019A general algorithm for detecting faults under the comparison diagnosis model.\u2019, in 2010\nIEEE International Symposium on Parallel and Distributed Processing IPDPS, 19-23 April 2010, Atlanta GA,\n; proceedings. , pp. 1-9.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1109\/IPDPS.2010.5470369\nPublisher\u2019s copyright statement:\n2010 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other users,\nincluding reprinting\/ republishing this (c) 20xx IEEE. Personal use of this material is permitted. Permission from IEEE\nmust be obtained for all other users, including reprinting\/ republishing this material for advertising or promotional\npurposes, creating new collective works for resale or redistribution to servers or lists, or reuse of any copyrighted\ncomponents of this work in other works.material for advertising or promotional purposes, creating new collective works\nfor resale or redistribution to servers or lists, or reuse of any copyrighted components of this work in other works.\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nA general algorithm for detecting faults\nunder the comparison diagnosis model\nIain A. Stewart\nSchool of Engineering and Computing Sciences, Durham University,\nScience Labs, South Road, Durham DH1 3LE, U.K.\nAbstract\nWe develop a widely applicable algorithm to solve the fault diagnosis problem in\ncertain distributed-memory multiprocessor systems in which there are a limited number\nof faulty processors. In particular, we prove that if the underlying graph G = (V,E)\nforming the interconnection network has connectivity no less than its diagnosability \u03b4\nand can be partitioned into enough connected components of large enough size then\ngiven a syndrome of test results under the comparison diagnosis model resulting from\nsome set of faulty nodes of size at most \u03b4, we can find the actual set of faulty nodes\nwith time complexity O(\u2206N), where \u2206 is the maximal degree of any node of the graph\nand N is the number of nodes.\n1 Introduction\nThere has been a considerable amount of research undertaken as to designing interconnec-\ntion networks with application to parallel computing. There can be no specific family of\ninterconnection networks that is better than all of the others, for the quality of a family of\ninterconnection networks depends upon the properties that happen to be of most relevance\nto a particular application. What is more, a whole range of properties of interconnection\nnetworks have proven to be of relevance to a whole range of applications. These properties\ninclude having low degree and high connectivity, being node- or edge-symmetric, having sim-\nple and efficient routing and broadcast algorithms, and possessing embedded Hamiltonian\ncycles or paths and cycles of a whole variety of lengths.\nNot only should interconnection networks possess desirable properties such as those above\nbut they should be able to tolerate a (limited) number of node or edge failures (more precisely,\nthe machines whose processors are joined according to the interconnection network should\nbe able to tolerate processor or link failures). This expectation has provoked much research\non not just the sustainability of specific properties in the presence of faults but also the\ndetection of the actual faults. It is with this latter research direction that we are concerned\nin this paper.\nImagine the situation. A distributed multiprocessor system is known to possess some\nfaulty nodes but it is not known as to which nodes are faulty. The problem is to detect the\n1\nfaulty nodes; that is, to diagnose the set of faulty nodes. Crucial to this diagnosis is the\nobservation that we can use the nodes of the system to do this; that is, we can undertake a\nself-diagnosis. As to how this is done depends upon the model adopted. A popular model\nis the comparison diagnosis model (also called the MM model), advocated by Malek and\nMaeng [18, 19]. In this model, a node can send a message to any two of its neighbours who\nthen send replies back to the node. On receipt of these two replies, the node compares them\nand proclaims that at least one of the two neighbours is faulty if the replies are different or\nthat both neighbours are fault-free if the replies are identical. However, if the node itself is\nfaulty then no reliance can be placed on this proclamation. The goal is to use these tests\nmade by various nodes in order to deduce exactly which are the faulty nodes.\nObviously there are limits as to what can be done under this model. For example, if\nall nodes are faulty then there is no way that this can be detected (from any collection of\ntests undertaken). For a specific interconnection network, there is a bound on the number of\nfaulty nodes that can necessarily be detected within this model. Work has been undertaken\non determining these bounds, or the diagnosabilities , for different interconnection networks.\nFor example, in [23] it was proven that when n \u2265 5, the n-dimensional hypercube has\ndiagnosability n; so, if there are at most n faulty nodes then these nodes can be found\ngiven the set of all possible test results. Also, in [14] it was proven that when n \u2265 4, the\nn-dimensional crossed cube has diagnosability n. In addition, in [28] it was proven that\nwhen n \u2265 4, the n-dimensional star graph has diagnosability n\u2212 1. However, an important,\ngeneric result (subsuming the above results) was obtained in [6] where it was proven that if\nan interconnection network is regular of degree n, has connectivity n and has at least 2n+3\nnodes then it has diagnosability n.\nRelated to determining the diagnosability of a system is the fault diagnosis problem; that\nis, the problem of actually determining the faulty nodes, given a set of test results (assuming\nthat one knows the diagnosability of the network and in the knowledge that the number of\nfaults is bounded above by the diagnosability). In [20] an algorithm was given to determine\nthe set of faulty nodes (in the circumstances described in the previous sentence) with time\ncomplexity O(N5), where N is the number of nodes in the network. The time complexity was\nrecently improved in [26] to O(d\u22063N), where d (resp. \u2206) is the minimum (resp. maximum)\ndegree of any node in the network. In the particular case of an n-dimensional hypercube,\nit was shown in [27] that the fault diagnosis problem can be solved with time complexity\nO(n22n).\nHowever, a very recent paper of Chiang and Tan [8] developed a theory of node diagnos-\nability. Here, nodes are individually diagnosed as to whether they are faulty or healthy. It\nturns out that under certain circumstances the health of a node can be deduced by examin-\ning a local neighbourhood of the node. In particular, it was shown in [8] that if every node\nis the root of an \u2018extended star structure\u2019 then a lower bound on its node diagnosability\ncan be obtained and also that this extended star structure can be utilised to solve the fault\ndiagnosis problem with time complexity O(\u2206N). The general technique was illustrated on\nhypercubes and stars. (We shall discuss the content of the important papers [6,8,27] in more\ndetail presently.)\nIn this paper, we establish a generic result that is applicable to a wide range of families of\ninterconnection networks prevalent in parallel computing. In particular, we prove that under\ncertain conditions (relating to the connectivity of the network and its intrinsic structure),\n2\nwhich hold within numerous interconnection networks, we can obtain algorithms for the fault\ndiagnosis problem. The time complexity of all our algorithms is O(\u2206N), where N is the\nnumber of nodes in the network and \u2206 is the maximal degree of any node. Our algorithms\nare either the fastest such algorithm known for the particular interconnection network or\nmatch the time complexity of the fastest known algorithm. The conditions under which we\ncan apply our techniques are significantly less demanding than the conditions under which\nChiang and Tan can apply their approach and, unlike Chiang and Tan, we do not require\nthe whole of the syndrome table to be computed; that is, we dispense with the computation\nof redundant data. We illustrate the efficacy of our approach by applying it to hypercubes,\ncrossed cubes, twisted cubes, folded hypercubes, enhanced hypercubes, augmented cubes,\nshuffle cubes, twisted N -cubes, k-ary n-cubes, augmented k-ary n-cubes, (n, k)-stars, stars,\npancake graphs and arrangement graphs.\nWe present the comparison diagnosis model in more detail in the next section before we\ndiscuss the papers [8] and [27] in Section 3. In Section 4, we present our generic algorithm\nbefore we apply it in a wide range of interconnection networks in Section 5. We compare our\nalgorithms with those resulting from applying the techniques of Chiang and Tan in Section 6\nand also present directions for further research.\n2 The comparison diagnosis model\nIn this section, we detail the basic definitions and the essential notions and results relating to\nthe comparison diagnosis model. In actuality, we perform fault diagnosis for a distributed-\nmemory multiprocessor whose processors are connected via an interconnection network and\naccording to some topology. However, throughout we adopt a graph-theoretic terminology\nand abstract our multiprocessor as an undirected graph G consisting of nodes V and edges\nE (as opposed to processors and links).\nThe comparison diagnosis model is as follows. Given a graph G = (V,E) within which\nthere may be faulty nodes, every node u of V tests every pair v and w of its neighbours\nby sending a test message to both neighbours and receiving replies. We assume that: all\nfaults are permanent; and a faulty node always produces an incorrect response to any test\nmessage, so that two faulty nodes do not produce identical responses to any test messages.\nSuppose that u is a healthy node (that is, it is not faulty). If the replies from v and w are\nidentical then the test result su(v, w) is set at 0 (signalling that both v and w are healthy),\notherwise su(v, w) is set at 1 (signalling that at least one of v and w is faulty). However,\nif u is a faulty node then the test result su(v, w) can be arbitrarily 0 or 1 with no reliance\nplaced upon this result. The set of all test results for every node and its pairs of neighbours\nis called a syndrome. The general fault diagnosis problem is: given a graph G = (V,E) and\na syndrome, can we use the data therein to obtain exactly the set of faulty nodes and, if so,\nto find these faulty nodes?\nNote that the same syndrome could arise from different sets of faulty nodes; that is,\nthere might be more than one set of faulty nodes consistent with the syndrome. A graph\nG = (V,E) is said to be \u03b4-diagnosible if given a syndrome s resulting from a set of at most \u03b4\nfaulty nodes, there is exactly one set of faulty nodes consistent with s. The maximum number\n\u03b4 for which a graph G = (V,E) is \u03b4-diagnosable is the diagnosability of G. Sengupta and\n3\nDahbura [20] were the first to provide structural conditions upon G for it to be \u03b4-diagnosible.\nOne remark we have is that the diagnosability of any graph G = (V,E) is bounded above by\nthe minimal degree of any vertex of V . So see this, suppose that u is some vertex of minimal\ndegree in G and consider the following two sets of faulty nodes: the first fault set consists of\nall u\u2019s neighbours; and the second of all u\u2019s neighbours as well as u. It is not difficult to see\nthat there is a syndrome that both of these sets of faults are consistent with.\nHenceforth, the fault diagnosis problem for a graph G = (V,E) is defined as follows:\ngiven a syndrome for a set of faults F \u2286 V of size at most the diagnosability of G, we require\nan algorithm that outputs exactly the set of faults F .\n3 Related work\nIn this section we overview work related to solving the fault diagnosis problem. Of direct\nrelevance to our research is the work of Yang [27] and Chiang and Tan [8].\nThe roots of our approach to determining the faulty nodes of a graph lie in [27] where\nan algorithm specific to hypercubes was developed. It is worthwhile reviewing this algo-\nrithm in order to introduce our techniques and also to point out some deficiencies of the\nalgorithm (which we shall remedy). In [27], Yang utilized various cycle decompositions of\nthe n-dimensional hypercube Qn. If one fixes some components of the bit-strings of length\nn describing the nodes of Qn then one obtains a subgraph isomorphic to Qm, for some\nm < n, and it has long been known that Qm is Hamiltonian. Furthermore, the set of 2\nn\u2212m\n(Hamiltonian) cycles resulting from varying the values of the chosen fixed components are\n\u2018well connected\u2019 to one another in that the cycles are connected in the \u2018shape\u2019 of the hyper-\ncube Qn\u2212m, via additional matchings; that is, by a set of node-disjoint edges where every\nnode of the two cycles involved is incident with exactly one edge. (In Fig. 1 we illustrate\n4 cycles, with \u2018dotted\u2019 edges, joined using matchings in the shape of a cycle of length 4.)\nThus, Qn is the union of a collection of node-disjoint cycles, interconnected in the shape\nof a hypercube. Yang observed that if the cycles are \u2018long enough\u2019 and \u2018plentiful enough\u2019\n(that is, the number of components in the bit-strings of length n chosen to be fixed is not\ntoo large and not too small) then there must be enough cycles which can be deduced to\nconsist entirely of healthy nodes and which can then be used to determine exactly where\nthe faulty nodes lie within the rest of the hypercube. For example, let s be some syndrome.\nIf some cycle is such that sx(y, z) = 0 for every triple (y, x, z) of consecutive nodes on the\ncycle and the cycle has length greater than n (that is, the diagnosability of Qn [23] and so\nan upper bound on the number of faulty nodes) then necessarily all nodes on this cycle must\nbe healthy. Also, if this cycle is \u2018connected\u2019 to another cycle, by an additional matching,\nthen the healthy cycle can be used to find the faulty nodes in the potentially faulty cycle,\nwith this process subsequently iterated. What results is an algorithm for finding the faulty\nnodes in an n-dimensional hypercube that has time complexity O(n22n).\nHowever, as we show momentarily, the focus in [27] on decompositions into cycles is\nunnecessary and also adds an additional complexity-theoretic burden on the algorithm (this\nburden was not considered in [27]). As regards this latter point, note that in order to apply\nYang\u2019s algorithm one needs to be able to actually construct Hamiltonian cycles in hypercubes.\nWhilst it is stated in [27] that such cycles can \u2018easily be constructed recursively\u2019, there is\n4\nFig. 1. Four cycles connected in the shape of a cycle.\nmore to it than this. The construction of cyclic Gray codes (for that is what an Hamiltonian\ncycle in a hypercube is) has been a longstanding topic of interest in computer science and\ndiscrete mathematics (see, for example, [4] for an account of the status of the problem some\n30 years ago). There now exist numerous efficient algorithms for the generation of cyclic Gray\ncodes (though note that the standard recursive algorithm is somewhat unsatisfactory in that\nit uses exponential space). Nevertheless, the actual computation of the Hamiltonian cycles\nis ignored in [27]. On the other hand, if the construction of the Hamiltonian cycles is to be\ndone by a distributed algorithm implemented on the parallel machine whose interconnection\nnetwork is the (faulty) hypercube then this becomes more problematic, for now it is not\nso straightforward to construct these cycles efficiently (that is, in time polynomial in the\ndimension of the hypercube) and when some of the processors may be faulty. The reader is\nreferred to [21] and the references therein for the consideration of distributed algorithms to\nconstruct Hamiltonian cycles in faulty hypercubes. Of course, given that with our method\nwe no longer need to rely on (Hamiltonian) cycle decompositions such as those utilized by\nYang, this whole problem disappears with our approach and we obtain a widely-applicable\nalgorithm (that is not restricted to just hypercubes). An additional drawback of Yang\u2019s\nalgorithm is that when applied to Qn its time complexity of O(n\n22n) does not compare\nfavourably with the algorithm due to Chiang and Tan [8], discussed in the next paragraph,\nwhich has time complexity O(n2n).\nIn [8], Chiang and Tan adopt a different approach to solving the fault diagnosis problem.\nThey develop an algorithm that is applied at each and every node in order to ascertain\nwhether that particular node is healthy or faulty. Their ingenious algorithm only requires\nthat syndrome tests involving nodes in a particular neighbourhood around the actual node\nx be studied, where this neighbourhood is an extended star , rooted at x, as illustrated in\nFig. 2 (in this figure, only tests undertaken by the black nodes and involving only the nodes\nand edges of the extended star need be considered in order to deduce whether x is healthy\nor faulty). They show that if a graph is such that every node is the root of an extended star\nwhere there are n branches in this extended star then not only is the diagnosability of the\ngraph at least n but there is an algorithm that solves the fault diagnosis problem that has\ntime complexity O(\u2206N), where N is the size of the input graph and \u2206 is the maximal degree\nof any node. Consequently, their algorithm is quite widely applicable. However, they make a\ncrucial assumption that an extended star can be efficiently computed at any node and do not\ninclude the time or intellectual effort required to actually compute these extended stars in\n5\ntheir complexity analysis. They go on to illustrate methods for finding these extended stars\nin hypercubes and star graphs. In actuality, the additional time required to find extended\nstars in hypercubes and star graphs does not add to the time complexity (as it is subsumed\nby the \u2018big-O\u2019 notation) but, nevertheless, it will still be consumed in any computation.\nAlso, it is not always clear as to how one constructs extended stars (or even whether they\nexist) in many other graphs prevalent as interconnection networks.\nx\n...\n...\n...\nFig. 2. An extended star rooted at x.\nAs regards diagnosability, it is worth comparing the results in [6] and [8]. The main result\nfrom [6] is that if a graph is regular of degree n, has connectivity n and has at least 2n + 3\nnodes then it has diagnosability n, whereas the main result (on diagnosability) from [8] is\nthat a graph has diagnosability at least n if every node x is the root of an extended star with\nn branches. In fact, Chiang and Tan\u2019s result is a corollary of Chang, Lai, Tan and Hsu\u2019s\nfor graphs that have connectivity n, are regular of degree n and for which for every node x\nthere exists a node y such that the distance between x and y is at least 5 (as, by Menger\u2019s\nTheorem, there exist n node-disjoint paths joining any two nodes x and y with each of these\npaths of length at least 5). Both results are powerful and widely-applicable; indeed, all the\ngraphs discussed in Section 5 satisfy the common hypothesis.\n4 A general algorithm\nLet G = (V,E) be a connected graph of diagnosability \u03b4 \u2265 1 and let F \u2286 V be a set of\nfaulty nodes of size at most \u03b4. Let s be a syndrome under the set of faulty nodes F . In\nwhat follows, if we write sx(y, z) = 0 or sx(y, z) = 1 then it is implicit that (x, y) and (x, z)\nare in E. In this section, we describe a general algorithmic procedure that solves the fault\ndiagnosis problem for a wide variety of graphs G (that is, given a syndrome s, can be used\nto determine the faulty nodes of F so long as |F | is no greater than the diagnosability of G).\nWe go on to apply this procedure to a number of graph families prevalent as interconnection\nnetworks for parallel processing.\n4.1 Looking for healthy components\nWe shall show how to modify Yang\u2019s approach so as to obtain a simpler, faster and more\ngenerally applicable algorithm to solve the fault diagnosis problem. We detail here our core\nalgorithm.\n6\nWe fix an ordering of the nodes of V . Also, fix u0 \u2208 V and let s be some syndrome. We\nbegin by initializing U0 = {u0} and U1 as\n{u0} \u222a {v : (u0, v) \u2208 E and there exists w \u2208 V \\ {v} such\nthat (u0, w) \u2208 E and su0(v, w) = 0}.\nFor every v \u2208 U1 \\ {u0}, we set t(v) = u0. We define Ui, for i \u2265 2, iteratively as\nUi\u22121 \u222a {v : v 6\u2208 Ui\u22121 and (u, v) \u2208 E for some\nu \u2208 Ui\u22121 \\ Ui\u22122 with su(v, t(u)) = 0}.\nFor every v \u2208 Ui \\ Ui\u22121, where i \u2265 2, we define t(v) to be the least (w.r.t. our fixed\nordering) node u \u2208 Ui\u22121 \\ Ui\u22122 for which su(v, t(u)) = 0. We say that the nodes of the set\nCi = {t(v) : v \u2208 Ui \\Ui\u22121} contribute to the construction of Ui, for i \u2265 1. Note that no node\ncontributes to the construction of both Ui and Ui\u2032 , where i 6= i\n\u2032.\nLet r be the least r such that Ur = Ur+1. The function t : Ur \\ {u0} \u2192 Ur describes\na tree T with root u0 via: if t(v) = u then u is the parent of v in T . W.r.t. the tree T ,\nthe internal nodes are exactly those nodes which contribute to some Ui; in fact, the internal\nnodes at depth i in T (where the root has depth 0) constitute the set Ci+1. Note that if T\ndoes not consist of the single node u0 then the root node u0 has degree at least 2.\nClearly we have that if u0 is healthy then all nodes of U1 are healthy. In fact, a simple\ninduction yields that if u0 is healthy then all nodes of Ui are healthy, for every i \u2265 1.\nAlternatively, if some node u of some Ci is faulty (that is, some internal node of T ) then:\nits parent t(u) (if it exists) is faulty, as st(u)(u, v) = 0, for some node v (with v = t(t(u)),\nif t(u) is not the root, and v equal to some child of u0, otherwise); and all of its children v\nthat are themselves internal nodes are faulty, as sv(w, t(v) = u) = 0, for all children w of v.\nConsequently, if any internal node of T is faulty then so are all internal nodes of T .\nThe above observations can be allied to the fact that we have an upper bound on the\nnumber of faulty nodes in F . In particular, as we construct the Ui\u2019s, if ever the size of the\nset C1 \u222a C2 \u222a . . . \u222a Ci becomes greater than \u03b4 then we know for sure that every node of T\nwill be healthy.\nThe following algorithm Set Builder(u0), whose input is: a graph G = (V,E), of diag-\nnosability \u03b4; a node u0 \u2208 V ; and a syndrome s, implements the above discussion.\nSet Builder(u0)\nset U0 := {u0}, all healthy := false, finished := false and i := 1\nwhile finished = false do\nbuild Ui\nif Ui = Ui\u22121 then\nfinished := true and i := i - 1\nelse\nif |C1 \u222a C2 \u222a . . . \u222a Ci| > d then\nall healthy := true\ni := i + 1\nreturn (all healthy, Ui)\n7\nLet r be the value of the variable i on termination (and so Ur\u22121 \u2282 Ur = Ur+1, if r \u2265 1, and T\nis the tree associated with Ur). The truth of the variable all healthy on termination signals\nthat we have proven that all nodes in Ur are healthy. Of course, if all healthy is false then\nthe nodes of Ur might all be healthy but we cannot as yet say for sure.\nSuppose that all nodes of Ur are, in fact, healthy, and that r \u2265 1 (if r = 0 then Ur = {u0}).\nLet N be the set of nodes adjacent to some node of Ur in G. If x \u2208 N then it is adjacent to\nsome node y \u2208 Ur which in turn is adjacent to z = t(y) \u2208 Ur, if y 6= u0, or some child z of u0\nin T , if y = u0. In both cases, sy(x, z) = 1 as otherwise x would have been placed in some\nUi and hence Ur. As y and z are healthy, we must have that x is faulty. Hence, all nodes\nof N are faulty. Also, either N forms an articulation set for G (that is, the removal of the\nnodes of N and their incident edges from G results in a disconnected graph) or V = Ur \u222aN .\nWe shall use this observation subsequently.\n4.2 Time complexity\nConsider the (sequential) time complexity of Set Builder(u0). Building U1 takes O(\u2206\n2) time,\nwhere \u2206 is the maximal degree of any node in G (we assume an adjacency list representation\nof G). Building Ui, for i \u2265 2, takes O(\u2206pi\u22121) time, where pi\u22121 = |Ui\u22121 \\ Ui\u22122|. The first\ntest in the body of the while-loop of Set Builder takes constant time as does the second\ntest, as counting the number of nodes in Ci can be built into the construction of Ui at no\nextra cost (note that we only need to count up to \u03b4 and that \u03b4 \u2264 \u2206). Hence, if there are r\niterations of the while-loop then Set Builder(u0) has time complexity O(\u2206|Ur|). Note also\nthat every time a node is added to Ui, either the node contributing to this addition is already\nadjacent to at least 2 nodes of Ui or it becomes adjacent to at least 2 nodes of Ui. Thus, if\nSet Builder(u0) terminates with all healthy set at false then r is at most \u03b4 + 1.\nThe discussion above immediately yields the following result which we shall apply in a\nvariety of graphs in the next section.\nTheorem 1 Let G = (V,E) be a connected graph of diagnosability \u03b4 \u2265 1 and connectivity\n\u03ba \u2265 \u03b4, and where the maximal degree of any node in V is \u2206. Suppose that the algorithm\nSet Builder(u0), for some u0 \u2208 V , takes as input a description of the graph G and a\nsyndrome for some faulty set of nodes F \u2286 V of size at most \u03b4, and outputs the set of nodes\nUr, where |Ur| > 1 and all nodes of Ur are healthy. The set N of nodes adjacent to a node\nof Ur is the set of faults F and the time taken by Set Builder(u0) is O(\u2206|Ur|).\nNote that in order to apply the above theorem to solve the fault diagnosis problem in graphs\nwhose connectivity is at least their diagnosability, all we need to do is to ensure that the\nnumber of internal nodes of the output tree T (whose node set is Ur) is greater than the\ndiagosability.\n5 Applications\nIn this section, we apply the general algorithm of the previous section to some specific families\nof graphs that have been studied as interconnection networks. We refer the reader to the\nspecific references given for definitions of these graphs.\n8\n5.1 Hypercubes and their variants\nLet Qn be an n-dimensional hypercube, where n \u2265 7. It is known that the diagnosability of\nQn is n [23]. Let F be a set of at most n faulty nodes in Qn. Let m be the minimal integer\nsuch that m > log2(n). Fixing the first n \u2212 m components of the nodes of a hypercube\nat some tuple in v \u2208 {0, 1}n\u2212m results in a copy of Qm, denoted Qm(v), within Qn (we\noften denote the nodes of some \u2018dimensional\u2019 graph in bold type). Since 2m > n, Qm(v)\nhas more than n nodes. Also, as n \u2265 7, there are 2n\u2212m > n node-disjoint copies of Qm\nwithin Qn. Consequently, at least one of these copies contains no faulty nodes; call this copy\nQm(w). If we start the algorithm Set Builder at the node u0 = (w, 0, 0, . . . , 0) of Qn then\nthe resulting set of nodes Ur consists entirely of healthy nodes (as it must contain all 2\nm\nnodes of Qm(w)). The set of nodes N adjacent to Ur consists entirely of faulty nodes and\nis either an articulation set of Qn or it consists of all faulty nodes in Qn. However, as any\narticulation set of Qn contains at least n nodes [24], we must have that N contains exactly\nthe faulty nodes in Qn.\nThe above presupposes that we can find the subgraph Qm(w) of Qn within which there\nare no faulty nodes. In our search for this subgraph Qm(w), we need to ensure that we do\nnot waste too much time exploring other subgraphs that may not be suitable. Given an\narbitrary graph G, we denote by Set Builder(u0, H) the algorithm Set Builder applied to\nG at the node u0 of the subgraph H of G but where the adjacency relation is restricted to\nthe subgraph H ; that is, Set Builder(u0, H) starts from u0 and only adds nodes of H to the\nsets it builds. This gives rise to the following algorithm.\nFaults in Hypercubes\nv := 0n\u2212m and u := (v, 0m)\n(all healthy, U) := Set Builder(u, Qm(v))\nwhile all healthy = false do\nv := nextn\u2212m(v) and u := (v, 0\nm)\n(all healthy, U) := Set Builder(u, Qm(v))\n(all healthy, U) := Set Builder(u)\nN := set of neighbours of U\noutput N\nThe function nextn\u2212m(v) delivers the next node after the node v of Qn\u2212m according to some\nfixed listing of all nodes. Note that there is no need for there to be edges between consecutive\nnodes; any listing of the nodes of Qn\u2212m will do. In fact, all we need is a list of n + 1 nodes\nstarting from 0n\u2212m as executing Set Builder starting from at least one of the n+1 resulting\nnodes will result in the provision of a set of healthy nodes as required.\nAs for the complexity of our algorithm Faults in Hypercubes, an execution of the al-\ngorithm Set Builder(u, Qm(v)) takes O(n2\nm) = O(n2) time. Thus, the time complexity of\nFaults in Hypercubes is dominated by the final execution of Set Builder and this execution\ntakes O(n2n) time.\nTheorem 2 Let F be a set of at most n faulty nodes in an n-dimensional hypercube. There\nis an algorithm running in O(n2n) time that takes as input a syndrome for F and returns\nthe actual set F of faulty nodes.\n9\nNote that the key property of hypercubes that results in Theorem 2 is that the nodes\nof Qn can be partitioned into 2 sets, depending upon the first component of the bit-string\nof length n naming a node, so that the induced subgraphs on these two sets of nodes are\nboth isomorphic to Qn\u22121. This results in an ability to partition Qn into disjoint sets of\nnodes (the subgraphs Qm(v), above) so that a list of representative nodes in each set can\nbe easily generated (the nodes (v, 0m), above). Hypercubes are not alone in having such\ndecompositions.\n\u2022 For n \u2265 1, the 2n nodes of a crossed cube CQn can be partitioned into 2 sets, by fixing\nthe first component in the bit-strings of length n naming the nodes at 0 and at 1, so\nthat each set of nodes induces a copy of CQn\u22121 [12]. Also, CQn is regular of degree n\nand has connectivity n [16]; thus, by [6], CQn has diagnosability n, when n \u2265 4.\n\u2022 For n \u2265 2, the 2n nodes of a twisted cube TQn can be partitioned into 2 sets, by fixing\nthe first two components in the bit-strings of length n naming the nodes at either (0, 0)\nor (1, 0) and at either (0, 1) or (1, 1), so that each of these subsets induces a copy of\nTQn\u22121 [15]. Also, TQn is regular of degree n and has connectivity n [7]; thus, by [6],\nTQn has diagnosability n, when n \u2265 4.\n\u2022 For n \u2265 1, the folded hypercube FQn and the enhanced hypercube Qn,m contain the\nhypercube Qn as a spanning subgraph, and are both regular of degree n+ 1 and have\nconnectivity n + 1 [3, 22]; thus, by [6], both FQn and Qn,m have diagnosability n + 1,\nwhen n \u2265 4.\n\u2022 For n \u2265 1, the 2n nodes of an augmented cube AQn can be partitioned into 2 sets, by\nfixing the first component in the bit-strings of length n naming the nodes at 0 and at\n1, so that each of these subsets induces a copy of AQn\u22121 [10]. Also, AQn is regular of\ndegree 2n \u2212 1 and has connectivity 2n \u2212 1 [10]; thus, by [6], AQn has diagnosability\n2n\u2212 1, when n \u2265 5.\n\u2022 For n = 4k+2, with k \u2265 0, the 2n nodes of a shuffle-cube SQn can be partitioned into\n16 sets, by fixing the first four components at some tuple from {0, 1}4, so that each of\nthese subsets induces a copy of SQn\u22124 [17]. Also, SQn is regular of degree n and has\nconnectivity n [17]; thus, by [6], SQn has diagnosability n, when n \u2265 4.\n\u2022 For n \u2265 2, the 2n nodes of a twisted N -cube TQ\u2032n can be partitioned into 2 sets, by\nfixing the first component in the bit-strings of length n naming the nodes at 0 and\nat 1, so that one of these sets induces a copy of Qn\u22121 and other induces a copy of\nTQ\u2032n\u22121 [13]. Also, TQ\n\u2032\nn is regular of degree n and has connectivity n [13]; thus, by [6],\nTQ\u2032n has diagnosability n, when n \u2265 4.\nConsequently, be proceeding as we did for the hypercube, we immediately obtain the follow-\ning result.\nTheorem 3 Let G be CQn, TQn, FQn, Qn,m, AQn, SQn or TQ\n\u2032\nn and let F be a set of at\nmost \u03b4 faulty nodes, where \u03b4 is the diagnosability of G. There is an algorithm running in\nO(n2n) time that takes as input a syndrome for F and returns the actual set F of faulty\nnodes.\n10\n5.2 Other interconnection networks\nLet k \u2265 3 and n \u2265 2, and let Qkn be a k-ary n-cube. However, suppose further that\n(k, n) 6\u2208 {(3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (5, 2)}. By [6], the diagnosability of Qkn is 2n. Let\nF be a set of at most 2n faulty nodes in Qkn. Let m be the minimal integer such that\nkm > 2n; that is, such that m > logk(2n). Fixing the first n \u2212 m components of a k-ary\nn-cube at some tuple in v \u2208 {0, 1, . . . , k \u2212 1}n\u2212m results in a copy of Qkm, denoted Q\nk\nm(v),\nwithin Qkn. Since k\nm > 2n, Qkm(v) has more than 2n nodes. Also, because of our restrictions\non k and n, there are kn\u2212m > 2n node-disjoint copies of Qkm within Q\nk\nn. Consequently, at\nleast one of these copies contains no faulty nodes; call this copy Qkm(w). If we start the\nalgorithm Set Builder at the node u0 = (w, 0, 0, . . . , 0) of Q\nk\nn then the resulting set of nodes\nUr consists entirely of healthy nodes (as it must contain all k\nm nodes of Qkm(w)). The set of\nnodes N adjacent to Ur consists entirely of faulty nodes and is either an articulation set of\nQkn or it consists of all faulty nodes in Q\nk\nn. However, as any articulation set of Q\nk\nn contains\nat least 2n nodes [5], we must have that N contains exactly the faulty nodes in Qkn. We can\nclearly construct an algorithm just as we did for hypercubes and obtain the following result.\nTheorem 4 Let F be a set of at most 2n faulty nodes in a k-ary n-cube. There is an\nalgorithm running in O(nkn) time that takes a syndrome for F and returns the actual set F\nof faulty nodes.\nA graph called the augmented k-ary n-cube AQn,k was recently defined in [25] and is an\nextension of the k-ary n-cube in a manner analogous to the extension of an n-dimensional\nhypercube to an n-dimensional augmented cube. It was proven in [25] that AQn,k is regular\nof degree 4n\u2212 2 and has connectivity 4n\u2212 2. Thus, by [6], so long as (n, k) 6= (2, 3), AQn,k\nhas diagnosability 4n \u2212 2. As AQn,k contains a k-ary n-cube as a spanning subgraph, an\nimmediate corollary of the above discussion is that there is an algorithm running in O(nkn)\ntime that takes a syndrome for a set F of at most 4n\u2212 2 faulty nodes in AQn,k and returns\nthe actual set F of faulty nodes.\nLet n \u2265 2 and 2 \u2264 k \u2264 n\u2212 1, and let Sn,k be the (n, k)-star graph. The (n, k)-star graph\nis regular of degree n \u2212 1 and has connectivity n \u2212 1 [9]. The (n, k)-star graph has n!\n(n\u2212k)!\nnodes, and so if (k, n) 6= (2, 3) then Sn,k has diagnosability n\u22121 [6]. Let F be a set of at most\nn\u2212 1 faulty nodes in Sn,k. By fixing the kth component of the bit-strings naming the nodes\nof Sn,k, we obtain that Sn,k is partitioned into n copies of Sn\u22121,k\u22121, each of which contains\nmore than n \u2212 1 nodes (as k 6= 1). Thus, at least one of these copies must consist entirely\nof healthy nodes. Hence, we can apply Set Builder to obtain our set of faulty nodes, just\nas we have done above.\nTheorem 5 Let F be a set of at most n \u2212 1 faulty nodes in an (n, k)-star Sn,k, where\n2 \u2264 k \u2264 n \u2212 1. There is an algorithm running in O( n!n\n(n\u2212k)!\n) time that takes a syndrome for\nF and returns the actual set F of faulty nodes.\nOf course, Sn,n\u22121 is isomorphic to the star graph Sn [1] and so Theorem 5 applies to star\ngraphs too. Note that if k = 1 then Sn,1 is a clique on n nodes.\nLet n \u2265 2 and let Pn be the n-dimensional pancake graph. The n-dimensional pancake\ngraph is regular of degree n\u2212 1 and has connectivity n\u2212 1 [2]. The n-dimensional pancake\n11\ngraph has n! nodes, and so if n \u2265 4 then Pn has diagnosability n\u2212 1 [6]. Let F be a set of\nat most n \u2212 1 faulty nodes in Pn. By fixing the kth component of the bit-strings naming\nthe nodes of Sn,k, we obtain that Sn,k is partitioned into n copies of Sn\u22121,k\u22121, each of which\ncontains more than n \u2212 1 nodes (as k 6= 1). Thus, at least one of these copies must consist\nentirely of healthy nodes. Hence, we can apply Set Builder to obtain our set of faulty nodes,\njust as we have done above.\nTheorem 6 Let F be a set of at most n\u22121 faulty nodes in a pancake graph Pn, where n \u2265 4.\nThere is an algorithm running in O(n!n) time that takes a syndrome for F and returns the\nactual set F of faulty nodes.\nLet n \u2265 4 and 2 \u2264 k \u2264 n, and let An,k be the arrangement graph [11]. The arrangement\ngraph An,k is regular of degree k(n\u2212k) and has connectivity k(n\u2212k) [11]. The arrangement\ngraph An,k has\nn!\n(n\u2212k)!\nnodes and so has diagnosability k(n\u2212 k) [6]. Let F be a set of at most\nk(n\u2212k) faulty nodes in An,k. By fixing some component of the bit-strings naming the nodes\nof Pn, we obtain that Pn is partitioned into n copies of Pn\u22121, each of which contains more\nthan n\u2212 1 nodes. Thus, at least one of these copies must consist entirely of healthy nodes.\nHence, we can apply Set Builder to obtain our set of faulty nodes, just as we have done\nabove.\nTheorem 7 Let F be a set of at most n \u2212 1 faulty nodes in an arrangement graph An,k,\nwhere n \u2265 4 and 2 \u2264 k \u2264 n. There is an algorithm running in O(n!k(n\u2212k)\n(n\u2212k)!\n) time that takes a\nsyndrome for F and returns the actual set F of faulty nodes.\n6 Conclusions and further research\nAs we have just demonstrated, we have developed a widely applicable technique that results\nin an algorithm to solve the fault diagnosis problem in a range of graphs used as inter-\nconnection networks in parallel computing. The time complexities of our algorithms match\nthose of the algorithms due to Chiang and Tan. However, the conditions required for us to\napply our algorithms are much less severe than the conditions required by Chiang and Tan.\nApart from a relationship between the connectivity and the diagnosability of the graph in\nquestion, all that we need is that the input graph can be partitioned into enough sizeable\nconnected subgraphs, whereas Chiang and Tan require not only that every node is the root\nof an extended star but also that this extended star can be actually computed, for every node\nof the graph. Indeed, as can be seen from [8], quite a bit of work still has to be done in the\ncase of hypercubes and stars for Chiang and Tan\u2019s technique to be applied whereas, as we\nhave demonstrated in this section, our technique can be easily applied to a range of graphs.\nNote that once we have satisfied ourselves that our condition holds for some graph, we are\ndone; for unlike Chiang and Tan, we do not need to rely on any additional computational\naspects of our condition in the subsequent computation of the faulty set of nodes. Note also\nthat if the set of faulty nodes is not an articulation set then a by-product of our algorithm\nis that we obtain a tree spanning the set of healthy nodes of the graph which could possibly\nbe utilised in some other context.\n12\nHowever, there are more improved aspects of our algorithms when compared with those\nof Chiang and Tan. We have hitherto assumed that all fault diagnosis algorithms are simply\ngiven the syndrome as input; that is, that the syndrome has already been obtained (presum-\nably by every node testing pairs of its neighbours in the distributed-memory multiprocessor\nwithin which it lies). The cost of actually obtaining the syndrome has been ignored. It\ncould well be that performing the actual tests is expensive and that we wish to minimize\nthe number of tests performed. Any expense might be exacerbated depending upon the\nmessage-passing model adopted; for it might be that any node can only send one message\nat any time and thus that at least d time units are required in order for a node to send a\nmessage to each of its neighbours (with different nodes having to synchronize their messages\nto avoid conflicts). Alternatively, actually consulting the syndrome table could well be ex-\npensive, and so we may wish to minimize the number of test results needing to be read from\nthe table.\nWe note that regardless of whether we wish to minimize the number of tests performed\nor the number of syndrome table look-ups, our algorithm Set Builder(u0) does not need\nto build or consult the whole of the syndrome table (in order to calculate Ur). We assume\nfor simplicity that we are trying to minimize the number of syndrome table look-ups. The\nnumber of test results due to the node u0 that need to be consulted is at most\n\u2206(\u2206\u22121)\n2\n. We\nconsult at most \u2206 \u2212 1 test results due to any node of U1 \\ {u0}; we consult at most \u2206 \u2212 1\ntest results due to any node of U2 \\U1; and so on. Hence, the number of test results from the\nsyndrome table needing to be consulted is (\u2206\u2212 1)(\u2206\n2\n+ |Ur| \u2212 1), which is far less than the\nnumber of test results in the complete syndrome table. On the other hand, Chiang and Tan\u2019s\nalgorithms need to consult all of the test results in the syndrome table. Indeed, if the whole\nof the syndrome table cannot be stored in memory then it is non-trivial to implement Chiang\nand Tan\u2019s algorithms so that the same test results do not need to be repeatedly consulted.\nThe upshot is that our algorithms will consult markedly fewer test results from the syndrome\ntable than the algorithms of Chiang and Tan as we minimise unnecessary consultations.\nAs a direction for further research, we suggest the following. The whole essence of\nfinding the faults in a distributed multiprocessor system is that this should be undertaken\nthrough self-diagnosis; that is, the nodes of the system should collect the data from which\nthe actual faulty nodes can be discovered. Hitherto, this discovery has been performed via\na centralised sequential algorithm. For \u2018dimensional\u2019 networks such as hypercubes, crossed\ncubes, k-ary n-cubes, and so on, the resulting algorithm takes time exponential in the actual\ndimension. It would, of course, be preferable to have a time complexity that is polynomial in\nthe actual dimension; however, in a centralized context this does not make sense given that\nthere is generally an exponential (in the dimension) number of processors in the network.\nSurprisingly, given the focus on self-diagnosis, no attention has been paid to the system\nitself undertaking the computation enabling the discovery of the faulty nodes; that is, no\nattention has been paid to the distributed complexity of such a task. One might think that\nan immediate obstacle to the system itself finding the faulty nodes is that some of these nodes\nare themselves faulty. However, the diagnosis of faults in the context of models such as the\ncomparison diagnosis model is that it is the nodes (that is, the main processors) where faults\narise and not the relatively less complex communication links within the interconnection\nnetwork nor the system which governs inter-node communication. That is, it is entirely\nrealistic to assume that the communication network is intact and fault-free, and that the\n13\ncommunication system can perform (simple) computations in order to diagnose the faulty\nnodes. Indeed, when collecting the data to build a syndrome it is implicitly assumed that\nany processor can send a message to any of its neighbours and that the interconnection\nnetwork is fault-free. It would be of practical interest to study the distributed complexity of\nsolving the fault diagnosis problem in this setting and it is something we intend to pursue\nin future. Preliminary results show that a distributed implementation of our algorithm in\nhypercubes has a significantly improved time complexity when compared to a distributed\nimplementation of Chiang and Tan\u2019s algorithm.\nReferences\n[1] S.B. Akers, D. Harel and B. Krishnamurthy, The star graph: an attractive alternative\nto the n-cube, in: Proc. of Int. Conf. on Parallel Processing (1987) 393\u2013400.\n[2] S.B. Akers and B. Krishnamurthy, A group-theoretic model for symmetric interconnec-\ntion networks, IEEE Transactions on Computers 38 (1989) 555\u2013566.\n[3] A. Al-Amaway and S. Latifi, Properties and performance of folded hypercubes, IEEE\nTransactions on Parallel and Distributed Systems 2 (1991) 31\u201342.\n[4] J.R. Bitner, G. Ehrlich and E.M. Reingold, Efficient generation of the binary reflected\nGray code and its applications, Communications of the ACM 19 (1976) 517\u2013521.\n[5] B. Bose, B. Broeg, Y. Kwon and Y. Ashir, Lee distance and topological properties of\nk-ary n-cubes, IEEE Transactions on Computers 44 (1995) 1021\u20131030.\n[6] C.-P. Chang, P.-L. Lai, J.J.-M. Tan and L.-H. Hsu, Diagnosability of t-connected net-\nworks and product networks under the comparison diagnosis model, IEEE Transactions\non Computers 53 (2004) 1582\u20131590.\n[7] C.-P. Chang, J.-N. Wang and L.-H. Hsu, Topological properties of twisted cube, Infor-\nmation Sciences 113 (1999) 147\u2013167.\n[8] C.-F. Chiang and J.J.-M. Tan, Using node diagnosability to determine t-diagnosability\nunder the comparison diagnosis model, IEEE Transactions on Computers 58 (2009)\n251\u2013259.\n[9] W.-K. Chiang and R.-J. Chen, Topological properties of the (n, k)-star graph, Interna-\ntional Journal of Foundations of Computer Science 9 (1998) 235\u2013248.\n[10] S.A. Choudum and V. Sunitha, Augmented cubes, Networks 40 (2002) 71\u201384.\n[11] K. Day and A. Tripathi, Arrangement graphs: a class of generalized star graphs, Infor-\nmation Processing Letters 42 (1992) 235\u2013241.\n[12] K. Efe, P.K. Blackwell, W. Slough and T. Shiau, Topological properties of the crossed\ncube architecture, Parallel Computing 20 (1994) 1763\u20131775.\n14\n[13] A.-H. Esfahanian, L.M. Ni and B.E. Sagan, The twisted N -cube with application to\nmultiprocessing, IEEE Transactions on Computers 40 (1991) 88\u201393.\n[14] J. Fan, Diagnosability of crossed cubes under the comparison diagnosis model, IEEE\nTransactions on Parallel and Distributed Systems 13 (2002) 1099\u20131104.\n[15] P.A.J. Hilbers, M.R.J. Koopman and J.L.A. van de Snepscheut, The twisted cube,\nProc. of Parallel Architectures and Languages Europe (J.W. de Bakker, A.J. Nijman,\nP.C. Treleaven, eds.), Lecture Notes in Computer Science Vol. 258, Springer-Verlag\n(1987) 152\u2013159.\n[16] P.D. Kulasinghe, Connectivity of the crossed cube, Information Processing Letters 61\n(1997) 221\u2013226.\n[17] T.-K. Li, J.J.M. Tan, L.-H. Hsu and T.-Y. Sung, The shuffle-cubes and their general-\nization, Information Processing Letters 77 (2001) 35\u201341.\n[18] J. Maeng and M. Malek, A comparsion connection assignment for self-diagnosis of multi-\nprocessor systems, Proc. 11th Int. Symp. on Fault-Tolerant Computing (1981) 173\u2013175.\n[19] M. Malek, A comparsion connection assignment for diagnosis of multiprocessor systems,\nProc. 7th Ann. Symp. on Computer Architecture, ACM Press (1980) 31\u201335.\n[20] A. Sengupta and A.T. Dahbura, On self-diagnosable multiprocessor systems: diagnosis\nby the comparison approach, IEEE Transactions on Computers 41 (1992) 1386\u20131396.\n[21] I.A. Stewart, Distributed algorithms for building Hamiltonian cycles in k-ary n-cubes\nand hypercubes with faulty links, Journal of Interconnection Networks 8 (2007) 253\u2013\n284.\n[22] N. Tzeng and S. Wei, Enhanced hypercubes, IEEE Transactions on Computers 40\n(1991) 284\u2013294.\n[23] D. Wang. Diagnosability of hypercubes and enhanced hypercubes under the comparison\ndiagnosis model, IEEE Transactions on Computers 48 (1999) 1369\u20131374.\n[24] A.Y. Wu, Embedding of tree networks into hypercubes, Journal of Parallel and Dis-\ntributed Computing 2 (1985) 238\u2013249.\n[25] Y. Xiang and I.A. Stewart, Augmented k-ary n-cubes, Information Sciences, to appear.\n[26] X. Yang and Y.Y. Tang, Efficient fault identification of diagnosable systems under the\ncomparison model, IEEE Transactions on Computers 56 (2007) 1612\u20131618.\n[27] X. Yang, A linear time fault diagnosis algorithm for hypercube multiprocessors under\nthe MM\u2217 comparison model, Proc. of 12th Asian Test Symposium, IEEE Press (2003)\n50\u201357.\n[28] J. Zheng, S. Latifi, E. Regentova, K. Luo and X. Wu, Diagnosability of star graphs under\nthe comparison diagnosis model, Information Processing Letters 93 (2005) 29\u201336.\n15\n"}