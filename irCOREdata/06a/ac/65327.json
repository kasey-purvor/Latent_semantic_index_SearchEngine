{"doi":"10.1007\/978-3-540-45236-2_17","coreId":"65327","oai":"oai:dro.dur.ac.uk.OAI2:6215","identifiers":["oai:dro.dur.ac.uk.OAI2:6215","10.1007\/978-3-540-45236-2_17"],"title":"Mapping statecharts to Verilog for hardware\/software co-specification.","authors":["Qin, S.","Chin, W. N."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":["Araki, K.","Gnesi, S.","Mandrioli, D."],"datePublished":"2003-09-25","abstract":"Hardware-Software co-specification is a critical phase in co-design. Our co-specification process starts with a high level graphical description in Statecharts and ends with an equivalent parallel composition of hardware and software descriptions in Verilog. In this paper, we investigate the  statecharts formalism by providing it a formal syntax and a compositional operational semantics. After that, we design a semantics-preserving mapping function to transform a \\ud\nStatecharts description into Verilog specification. We can combine this mapping  with our previous formal partitioning process so as to form a more complete and  automated co-specification process","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/65327.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/6215\/1\/6215.pdf","pdfHashValue":"d99a993ecf6b5d23ed35d6ed0590124b1464045d","publisher":"Springer","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:6215<\/identifier><datestamp>\n      2015-03-31T11:50:42Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Mapping statecharts to Verilog for hardware\/software co-specification.<\/dc:title><dc:creator>\n        Qin, S. <\/dc:creator><dc:creator>\n        Chin, W. N. <\/dc:creator><dc:description>\n        Hardware-Software co-specification is a critical phase in co-design. Our co-specification process starts with a high level graphical description in Statecharts and ends with an equivalent parallel composition of hardware and software descriptions in Verilog. In this paper, we investigate the  statecharts formalism by providing it a formal syntax and a compositional operational semantics. After that, we design a semantics-preserving mapping function to transform a \\ud\nStatecharts description into Verilog specification. We can combine this mapping  with our previous formal partitioning process so as to form a more complete and  automated co-specification process. <\/dc:description><dc:subject>\n        Statecharts<\/dc:subject><dc:subject>\n         Verilog<\/dc:subject><dc:subject>\n         Operational semantics<\/dc:subject><dc:subject>\n         Homomorphism.<\/dc:subject><dc:publisher>\n        Springer<\/dc:publisher><dc:source>\n        Araki, K. & Gnesi, S. & Mandrioli, D. (Eds.). (2003). FME 2003 : formal methods : International Symposium of Formal Methods Europe,  8-14 September 2003, Pisa, Italy: proceedings. Berlin: Springer, pp. 282-299, Lecture notes in computer science(2805)<\/dc:source><dc:contributor>\n        Araki, K.<\/dc:contributor><dc:contributor>\n        Gnesi, S.<\/dc:contributor><dc:contributor>\n        Mandrioli, D.<\/dc:contributor><dc:date>\n        2003-09-25<\/dc:date><dc:type>\n        Book chapter<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:6215<\/dc:identifier><dc:identifier>\n        issn:0302-9743<\/dc:identifier><dc:identifier>\n        issn: 1611-3349<\/dc:identifier><dc:identifier>\n        doi:10.1007\/978-3-540-45236-2_17<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6215\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1007\/978-3-540-45236-2_17<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/6215\/1\/6215.pdf<\/dc:identifier><dc:rights>\n        The final publication is available at Springer via http:\/\/dx.doi.org\/10.1007\/978-3-540-45236-2_17<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["0302-9743"," 1611-3349","issn: 1611-3349","issn:0302-9743"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2003,"topics":["Statecharts","Verilog","Operational semantics","Homomorphism."],"subject":["Book chapter","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n10 December 2009\nVersion of attached file:\nAccepted Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nQin, S. and Chin, W. N. (2003) \u2019Mapping statecharts to Verilog for hardware\/software co-specification.\u2019, in\nFME 2003 : formal methods : International Symposium of Formal Methods Europe, 8-14 September 2003,\nPisa, Italy: proceedings. Berlin: Springer , pp. 282-299. Lecture notes in computer science. (2805).\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1007\/b13229\nPublisher\u2019s copyright statement:\nThe original publication is available at www.springerlink.com\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\n  \nDurham Research Online \n \nDeposited in DRO: \n10 December 2009 \n \nPeer-review status: \nPeer-reviewed \n \nPublication status: \nAccepted for publication version \n \nCitation for published item: \nQin, S. and Chin, W. N. (2003) 'Mapping statecharts to Verilog for hardware\/software co-\nspecification.', in FME 2003 : formal methods : International Symposium of Formal Methods \nEurope, Pisa, Italy, September 8-14, 2003 : proceedings. Berlin: Springer , pp. 282-299. \nLecture notes in computer science. (2805). \n \nFurther information on publishers website: \nhttp:\/\/dx.doi.org\/10.1007\/b13229 \n \nPublishers copyright statement: \nThe original publication is available at www.springerlink.com \n \n \n \n \n \n \n \n \n \n \n \nUse policy \n \nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior \npermission or charge, for personal research or study, educational, or not-for-profit purposes provided that : \n \n\uf0a7 a full bibliographic reference is made to the original source \n\uf0a7 a link is made to the metadata record in DRO \n\uf0a7 the full-text is not changed in any way \n \nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders. \n \nPlease consult the full DRO policy for further details. \n \nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom \nTel : +44 (0)191 334 2975 | Fax : +44 (0)191 334 2971 \nhttp:\/\/dro.dur.ac.uk \nMapping Statecharts to Verilog for Hardware\/Software\nCo-Specification\nShengchao Qin and Wei-Ngan Chin\nSingapore-MIT Alliance, National University of Singapore\nSchool of Computing, National University of Singapore\nqinsc,chinwn @comp.nus.edu.sg\nAbstract. Hardware-Software co-specification is a critical phase in co-design.\nOur co-specification process starts with a high level graphical description in Stat-\necharts and ends with an equivalent parallel composition of hardware and soft-\nware descriptions in Verilog. In this paper, we investigate the Statecharts formal-\nism by providing it a formal syntax and a compositional operational semantics.\nAfter that, we design a semantics-preserving mapping function to transform a\nStatecharts description into Verilog specification. We can combine this mapping\nwith our previous formal partitioning process so as to form a more complete and\nautomated co-specification process.\nKeywords: Statecharts, Verilog, operational semantics, homomorphism\n1 Introduction\nThe design of a complex control system is ideally decomposed into a progression of\nrelated phases. It starts with an investigation of properties and behaviours of the pro-\ncess evolving within its environment, and an analysis of the requirement for its safety\nperformance. From these is derived a specification of the electronic or program-centred\ncomponents of the system. The process then may go through a series of design phases,\nending in a program expressed in a high level language. After translation into a machine\ncode of a chosen computer, it can be executed at a high speed by electronic circuity. In\norder to achieve time performance required by the customer, additional application-\nspecific hardware devices may be needed to embed the computer into the system which\nit controls.\nClassical circuit design methods resemble the low level machine language program-\nming methods. These methods may be adequate for small circuit design, but not ade-\nquate for circuits that perform complicated algorithms. Industry interests in the for-\nmal verification of embedded systems are gaining ground since an error in a widely\nused hardware device can have adverse effect on profits of the enterprise concerned. A\nmethod with great potential is to develop a useful collection of proven equations and\nother theorems, to calculate, manipulate and transform a specification formulae to the\nproduct.\nHardware\/software co-design is a design technique which delivers computer sys-\ntems comprising hardware and software components. A critical phase of the co-design\nprocess is the hardware\/software co-specification, which starts from a high level sys-\ntem specification and ends with a pair of sub-specifications representing resp. hardware\nand software. Our previous work ([17]) proposes a formal partitioning algorithm which\nsplits a Verilog source program into hardware and software specifications. The parti-\ntioning correctness is verified using algebraic laws developed for the Verilog hardware\ndescription language. This algebraic approach has also been demonstrated in our earlier\nwork [15, 16]. One of advantages of this approach is that it ensures the correctness of\nthe partitioning process. Moreover, it optimises the underlying target architecture, and\nfacilitates the reuse of hardware devices.\nIn this paper, we bridge the gap between the high level specification in Statecharts\nand the Verilog source program by defining a mapping function between the two for-\nmalisms. Through this work, the overall co-specification process can be automated, as\nillustrated in Fig.1. Two key contributions of the present paper are:\n\u2013 we propose a formal operational semantics for a subset of Statecharts with data\nstates, which adopts an asynchronous model and supports true concurrency;\n\u2013 we define a formal mapping function which transforms a Statechart specification\ninto a Verilog program. We show that the target program after mapping preserves\nthe semantics of the source specification.\nS t a t e c h a r t s   S p e c i f i c a t i o n \nM a p p i n g \nV E R I L O G  R a w  S p e c i f i c a t i o n \nA l g e b r a i c  T r a n s f o r m a t i o n \nR e f i n e d  V E R I L O G  S p e c i f i c a t i o n \nH a r d w a r e - S o f t w a r e  P a r t i t i o n i n g \nS o f t w a r e  S p e c i f i c a t i o n H a r d w a r e  S p e c i f i c a t i o n \nH a r d w a r e - S o f t w a r e  C o - S y n t h e s i s \nP e r f o r m a n c e   E s t i m a t i o n  &    S i m u l a t i o n \nF o r m a l \nP a r t i t i o n i n g \nR u l e s \nFig. 1. HW-SW Co-Specification\nThe mapping process can be integrated with our previous formal partitioning al-\ngorithm so as to form an automated hardware-software co-specification process for\nhardware-software co-design, as summarised in Fig.1. The remainder of this paper is or-\nganised as follows. Section 2 first gives a formal (text-based) syntax for Statecharts with\ndata states and proposes a compositional operational semantics for it afterwards. Sec-\ntion 3 introduces a subset of Verilog for behaviourial specification. We build a mapping\nfunction from Statecharts into Verilog and prove that it is a homomorphism between\nthe two formalisms in Section 4. Related works together with a simple discussion and\nconclusion follow afterwards.\n2 Operational Semantics for Statecharts\nThe graphical language of Statecharts as proposed by David Harel ([4]) is suitable for\nthe specification and modeling of reactive systems. While the (graphical) syntax of the\nlanguage has been formulated quite early, the definition of its formal semantics proved\nto be more difficult than originally expected. As discussed in [14], these difficulties\nmay be explained as resulting from several requirements that seem to be desirable in a\nspecification language for reactive systems, but yet conflict with one another in some\ninterpretations. This may be why there exist more than twenty variants of Statecharts\n([21]), each of which can be regarded as a subset of the originally expected language.\nThe version discussed in [6] for STATEMATE is rather large and powerful; however,\ntheir operational semantics is neither formal nor compositional. The work presented\nin [11] provides a compositional semantics for Statecharts, but does not contain data\nstates. Hooman et.al ([9]) proposes a denotational semantics based on histories of com-\nputation. Following this line, [20] attempts to link the denotational semantics of State-\ncharts with temporal logic, so as to support formal verification. All these works adopt\na synchronous model of time, which is simpler to understand and formalise, but less\npowerful than the asynchronous model.\nOur version of Statecharts involves data items. The model we adopt is the asyn-\nchronous model, which is more powerful for specifying and modeling complex systems.\nOur formal operational semantics comprises the following features.\n\u2013 It is compositional, which implies that inter-level transitions and state references\nhave been dropped. The history mechanism has also been ignored.\n\u2013 It adopts an asynchronous time model, in which a macro-step (comprising a se-\nquence of micro-steps) occurs instantaneously. This model supports perfect syn-\nchrony hypothesis and also supports state refinement in top-down design.\n\u2013 It reflects the causality of events.\n\u2013 To be more intuitive, our semantics obeys local consistency, rather than global\nconsistency. That is, the absence of an event may lead to itself directly or indirectly\nin the same macro-step.\n\u2013 Instantaneous states are allowed, but each state cannot be entered twice or more at\nthe same instant of time. 1\n1 For simplicity, this checking is omitted in our semantics. We can include it by keeping records\nof the states that are passed so far in the current macro-step and prevent a former state from\nbeing re-entered in each macro-step.\n\u2013 It covers the data-state issues of Statecharts, allowing assignments in state transi-\ntions.\n\u2013 It supports true concurrency.\nIn this paper, timeout events are not included and this aspect is left as future work.\nIn what follows we give a formal syntax for Statecharts, and afterwards investigate\nits operational semantics thoroughly.\n2.1 A Formal Syntax of Statecharts\nQuoting from [5], state charts = finite-state diagrams + depth + orthogonality + broad-\ncast communication. This equation indicates the typical features of the Statecharts for-\nmalism:\n\u2013 It is an extension of conventional finite state machines (Mealy machine).\n\u2013 It provides natural notion of depth. A state can either be a basic one, or of a hierar-\nchical structure, inside which some other states are treated as its substates.\n\u2013 It supports the modeling of concurrency. A state may contain several states as its\nconcurrent components. This feature also helps to avoid state explosion.\n\u2013 It provides the broadcast communication mechanism. Unlike CSP or CCS, its out-\nput events are asynchronous, and can be broadcast to any receiver without waiting.\nHowever, its input events are synchronous, and are blocked until the arrival of the\ncorresponding output events. Such a communication mechanism is similar to Ver-\nilog.\nIn order to formalise the syntax of Statecharts, we introduce the following notations.\n: a set of names used to denote Statecharts which is large enough to prevent name\nconflicts.\n: the set of all abstract events (signals). We also introduce another set to\ndenote the set of negated counterparts of events in , i.e. ,\nwhere denotes the negated counterpart of event , and we assume .\n: the set of all assignment actions of the form exp.\nVar Val is the valuation function for variables, where Var is the set of all\nvariables, Val is the set of all possible values for variables. A snapshot for variables is\n.\n: the set of transitions, which is a subset of ,\nwhere is the set of boolean expressions.\nSimilar to [12, 11], we give a term-based syntax for Statecharts. The set SC of\nStatecharts terms is constructed by the following inductively defined functions.\nBasic SC\nBasic\nOr SC SC SC\nOr\nAnd SC SC\nAnd\nSome informal explanations follow:\n\u2013 Basic denotes a basic statechart named .\n\u2013 Or represents an Or-statechart with a set of substates\n, where is the default substate, is the active substate, is com-\nposed of all possible transitions among immediate substates of .\n\u2013 And is an And-statechart named , which contains a set of orthog-\nonal (concurrent) substates .\n2.2 Operational Transition Rules\nThe configuration of computation is defined by a triple , where\n\u2013 is the syntax of the statechart of interest.\n\u2013 gives the snapshot of data items.\n\u2013 denotes the current environment of active events.\nThe behaviour of a statechart is composed of a sequence of macro-steps, each of\nwhich comprises a sequence of micro-steps. A statechart may react to any stimulus\nfrom the environment at the beginning of each macro-step by performing some enabled\ntransitions and generating some events. This may fire other state transitions and lead\nto a chain of micro-steps without advancing time. During this chain of micro-steps, the\nstatechart does not respond to any potential external stimulus. When no more internal\ntransitions are enabled, the clock tick transition will occur by emptying the set of active\nevents and advancing time by one unit.\nWe explore a set of transition rules comprising state transitions and time advance\ntransitions.\nAt any circumstance, what a basic statechart can do is to advance time by a clock\ntick.\n1.\nIf a transition between two immediate substates of an Or-statechart is enabled and the\ntransition condition is true in current circumstance, it can be performed.\n2. En\ntgt trig a\nwhere\nsrc and tgt denote, respectively, the source and target state of transition .\na represents all events generated by transition , whereas a denotes\na single assignment action generated by . No loss of general results since a\nsequence of instantaneous assignment statements can be transformed into a single one.\nThis changes the data state from to .\nEn comprises all transitions among substates of being enabled by events in\n. It can be generated by the following definition.\nEn iff\nsrc trig trig\nwhere trig and trig represent respectively the positive events and the negated\nevents from .\nThe function changes the active substate of into its default substate, and\nthe same change is applied to its new active substate.\nThe substitution for an Or-statechart is defined\nby\nDiscussion: in rule 2, those events that are used to trigger are consumed by and\nwill no longer exist. This mechanism looks intuitive and reasonable and can help to\nprevent incorrect looping. Consider an example given in Fig. 2 (a). When the first event\nfrom the environment comes, the transition is performed and the active substate\nis migrated from to . This will not move back to until next event occurs,\nas under normal expectation. Earlier work ([14]) suggests a different treatment, where\nactive events are kept active during all micro-steps in a macro-step, where they may be\nreused many times.\n1p 2p\/{}e\n\/{}e\np\neba \/},{3o fcb \/},{4o\nge \/\n5o3p\n4p\n5p\n6p\n7p\n)(a )(b\n1q 2q\n1o\n2o\nq\nFig. 2. Example Statecharts (a) and (b)\nThe transitions in Statecharts are considered hierarchically. If no transitions among\nimmediate substates of an Or-statechart are enabled, an enabled (inner) transition for the\nactive substate may be performed instead. This consideration is carried out inductively\nas highlighted in rule 3.\n3.\nEn\ntrig a\nIf no transition is enabled for an OR-statechart, time advances, as shown below.\n4. En\nThe premise indicates that no transitions in can be triggered by . The set of transi-\ntions that are enabled at multiple levels is defined as follows.\nEn for any basic state\nEn En En\nEn En\nFor a parallel statechart, variables are shared by all orthogonal components. How-\never, each variable can only be modified by one component. We use WVar to denote\nthe set of variables that can be modified by a statechart .\nIt is natural and intuitive to accept that several transitions allocated in orthogonal\ncomponents may be fired simultaneously. This implies that they can be performed in a\ntruly concurrent way. However, we have to write the transition rule for parallel state-\ncharts carefully. Let us look at the statechart in Fig. 2 (b). Suppose the external stimulus\nis , which will fire both and at the same moment. Under rule 2, per-\nforming either of them will prevent another from happening since the common event is\nconsumed by the performed transition. This contradicts the above intuitive explanation.\nWe propose a more reasonable way in which simultaneously enabled transitions are\nallowed to occur concurrently within And-charts. In the following rule, we suppose\nis a permutation of .\n5.\nall are constructed byBasic orOr\nfor all\nEn for all\nWVar WVar for all where\ntrig a\nIn this rule, the overall transition that the And-chart performs involves several simul-\ntaneously enabled transitions which are performed respectively by\ncomponents . Other components ( ) are not involved in\nthis transition.\nA time advance transition will take place if all orthogonal components agree to do\nso.\n6. En\n3 Verilog and Its Operational Semantics\nHardware description languages (HDLs) are widely used to express designs at various\nlevels of abstraction in modern hardware design. A HDL typically contains a high level\nsubset for behaviour description, with the usual programming constructs such as assign-\nments, conditionals, guarded choices and iterations. It also has appropriate extensions\nfor real-time, concurrency and data structures for modeling hardware. VHDL and Ver-\nilog ([10]) are two contemporary HDLs that have been widely used for years. Although\nthe formal semantics of VHDL has been studied quite thoroughly, that of Verilog has\nbeen ignored until recently ([3, 7, 8, 22, 23]). However, it is reported that Verilog has\nbeen more widely used in industry (especially in US)([3]).\nWhat we shall use is a simple version of Verilog with some notational extension (as\ndiscussed in [7]) which contains the following categories of syntactic elements.\n1. A Verilog program can be a sequential process or a parallel program made up of a set\nof sequential processes.\n2. A sequential process in Verilog can be any of the following forms.\n(primitive command) (sequential composition)\n(conditional) (iteration)\n(guarded choice) (recursion)\nwhere is a boolean condition, and\nskip sink (output event) (assignment)\n(assignment guard)\n(time delay) (event control)\n(value rising) (value falling) (a set of abstract events)\nAlthough Verilog has been standardised ([10]) and widely used in industry, its pre-\ncise semantics is still lacking. Some recent work ([7, 8, 22, 23]) attempted to address\nits formal semantics issues from different points of views. The most recent work ([7])\ndiscussed these distinct views, especially the algebraic and operational semantics for\nVerilog, and explored the underlying links between them.\nThe subset of Verilog we adopt is quite similar to that proposed by He ([7]). How-\never, there are some different treatments between our version and He\u2019s version. We\ninclude explicitly the possible context environment of active events in our configura-\ntion, and change the operational rules for the parallel constructs. This facilitates our\nsemantic mapping from Statecharts into Verilog, and does not change the observable\nbehaviour of a program.\nIn our operational semantics of Verilog, transitions are of the form . The\nconfiguration describes the state of an executing mechanism of Verilog programs\ntogether with the environment of active events before an action , whereas describes\nthat immediately after. They are identified as triples , where\n\u2013 is a program text, representing the rest of the program that remains to be exe-\ncuted.\n\u2013 Var Val records the data state.\n\u2013 is the current set of active events.\nA label denotes a transition from state to . It can be a clock tick event ,\nor a compositional event possibly with three conjunctive parts: representing\nthe enabling condition, the set of events consumed, and the set of events generated,\nrespectively.\nNow we present a critical subset of transition rules which are relevant to our trans-\nformation from Statecharts into Verilog.\nThe primitive sink can do nothing but advance time by a clock tick.\nsink sink\nThe guarded choice construct\ncan take a guarded transition if that guard is enabled.\nfor some\nwhere indicates that the input guard is enabled by . This is defined as:\nAlso, extracts all \u201cpositive\u201d events from the input guard (to be consumed when\nenabling the guard), i.e.,\nand records the set of events generated by the output guard . Given an output\nguard , the generated events are\nif\nif\notherwise\nIf no guard is enabled, the clock tick can be performed.\nwhere is the same as if no time delay guards ( ) appear in . Otherwise, it is\nthe guarded choice obtained from by eliminating all time delay guards.\nA parallel construct of guarded choices is of the form where\nThis can be transformed into a guarded choice construct by algebraic laws ([7]). Here,\nwe give the transition rules for the parallel construct directly. It can perform a (composi-\ntional) guarded transition if some threads agree, where denotes a permutation\nof .\nwhere , and\nIf no threads can take a guarded transition, then the clock tick event can take place,\nas follows:\nNote that is the same as if no time delay guards ( ) appear in . Otherwise, it\nis the guarded choice obtained from by eliminating all time delay guards.\nA sink thread does not block the behaviour of its partners.\nsink sink\n4 Mapping Statecharts into Verilog\nIn this section, we build a link between Statecharts and Verilog, by which a Statecharts\ndescription can be mapped to its corresponding Verilog program. We show such a map-\nping preserves the semantics and can be conducted in a compositional manner.\n4.1 Mapping Function\nBefore constructing the mapping function called , we address some subtle issues and\nintroduce some notations. There exist two features which complicate the definition of\non an Or-chart, one is the hierarchical feature of Statecharts and the priority of tran-\nsitions, whereas the other lies in that an And-chart can be a sub-chart of an Or-chart.\nThis feature differentiates Statecharts from conventional programming languages. The\nformer indicates that transitions in an outer level (rule 2) has higher priority than those\nin an inner level (rule 3). The possible transitions are considered hierarchically, starting\nfrom the current active state, and progressing into inner active substates where appli-\ncable. By enumerating these transitions in accordance with the hierarchy, we can cope\nwith the different priorities for transitions occurring in distinct levels.\nTo deal with the above features, we prepare the following formal notations. We first\ngive a function or-depth SC to calculate the \u201cor-depth\u201d of a statechart, which is\ndefined as follows:\n\u2013 for a statechart constructed by Basic, or-depth ;\n\u2013 for a statechart constructed by Or,\nor-depth or-depth ;\n\u2013 for a statechart constructed by And, or-depth .\nThe or-depth of an Or-chart just records the deepness of the path transitively along\nits active Or-substates. We stop going further once an And-state is encountered. The\nor-depth of an And-chart is simply 1.\nSecondly, we extend some notations from Or-charts to And-charts. As already\nknown, for an Or-chart , active denotes its current\nactive substate; for any transition , src and tgt respectively represent its\nsource and target state. Given a parallel statechart , where all\nare Or-charts, we define its current active state as a vector of the active states of these\nconstituents, i.e., active active active . We use to denote\nall possible (perhaps compositional) transitions of the And-chart . Given a transition\n, where , for , and is\na permutation of , we define its source state and target state respectively as\nfollows:2\nsrc , where src , for , and\nactive , for ;\ntgt , where tgt , for , and\nactive , for .\nThirdly, we need to know the resulting statechart after a transition is taken. When\na transition occurs, any involved statechart can have changes in its (transitive) active\nsubstates. We use a function\nresc SC SC\nto return the modified statechart after performing a transition in a statechart. It is defined\ninductively with regard to the type of the statechart.\n\u2013 for a Basic-chart , and any transition , resc ;\n\u2013 for an Or-chart , and a transition ,\nresc\ntgt if src\nresc if\notherwise\n\u2013 for an And-chart , and a transition ,\nresc ifotherwise\nwhere is the statechart obtained from via replacing\nby , for , resc , for , and , for\n.\n2 For an Or-chart , contains all possible transitions inside\nalong its transitive active substate chain, i.e., src .\nWith the help of , we define the aforementioned possible transition set for an\nAnd-chart formally as\n, where . The transition set for\nthe general And-chart with components can be defined similarly.\nThe definition of is split into three cases in accordance with the type of the source\nstatechart.\nDefinition 1 (Mapping function ). The function\nSC Verilog\nmaps any statechart description into a corresponding Verilog process. It keeps un-\nchanged the set of variables employed by the source description, i.e.,\nSC vars vars\nand it is inductively defined as follows.\n\u2013 For a statechart constructed by Basic, maps it into an idle program sink\nwhich can do nothing but let time advance, i.e.,\nsink\n\u2013 For a statechart constructed by And, maps it into a\nparallel construct in Verilog.\n\u2013 For a statechart constructed by Or, we define by\nexhaustively figuring out the first possible transitions of if any, otherwise it sinks.\nsink if\notherwise\nwhere\nor-depth resc\nactive src active\nactive src active\nand\nactive active active\nactive active active\nThe input guard comprises the overall trigger events of , which has the\nform , where are events from trig , whereas are events out of\ntrig .\nDue to the priority mechanism of Statecharts, an enabled transition in an inner\nlevel can occur only when no transitions from any outer level - are\nenabled. The part is used to denote this condition.\nThe output guard is the overall action performed by , which has the form\n, where comprises all abstract events out of a , and the\nassignment action is from a .\nFor each statechart, we always assume each of its variables has bounded range,\nand the set of possible events is finite, which implies that the set of its configurations\nis finite. Therefore, the set of configurations (under transition relation) forms a well-\nfounded quasi order, which indicates the mapping function is terminating.\nThe following example deals with the transformation of statecharts in Fig. 2.\nExample 1. The statechart (a) in Fig. 2 can be described as :\nwhere\nAfter applying the mapping function onto it, the statechart (a) becomes the fol-\nlowing process\nwhich does nothing but just waits to be fired by an event from the environment.\nThe statechart (b) can be described as :\nwhere\nIt is mapped into the following parallel construct\nsink sink sink\nwhere the two parallel processes are mapped from and , respectively.\np \n1 p \n10 p \n11 p \n12 p \n1 \/ += y y f 10 <y \n0 \/ =y e \n3 p \n2 p \n4 p \n6 p \n5 p 7 p \n8 p \n9 p \n1 \/ - x x d =0 >x \nc b \/ \/{} a \n2 t 3 t \n1 t \n4 t 5 t \n6 t 7 t \nFig. 3. A More Complicated Statechart\nExample 2. The statechart in Fig. 3 is more complicated than those in Fig. 2. It is de-\nscribed by:\nwhere\nAfter applying onto it, we obtain the following recursive process.\nwhere\nLet us illustrate a more practical example: a simple remote controller for an air-conditioner.\no n \nF a n T e m p e r a t u r e T i m e r T e m p D i s p l a y \nT i m e r D i s p l a y \na u t o \nh i g h \nl o w \nb f a n \nb f a n \nb f a n t e m p \ne I n c r  &   v < 2 8   \/  v = v + 1 \ne D e c r  &   v > 1 6   \/  v = v - 1 \nt c o n t \nt o f f \nt o n \nb t i m e r  \/  t i m e r o n \nb t i m e r \nb t i m e r  \/ \nt i m e r o f f \nh I n c r  &   t < 8   \/  t = t + 1 \nh D e c r  &   t > 1   \/  t = t - 1 \nt e m p D \nv > d v    \/  d v = v \nv < d v    \/  d v = v \nt i D i s O f f \nt i D i s O n \nt i m e r o n t i m e r o f f \nt < d t   \/  d t = t \nt > d t   \/ \nd t = t \nh I n c r  &   t < 8   \/ \nt = t + 1 \nh D e c r  &   t > 1   \/  t = t - 1 \nFig. 4. An Air-Conditioner Remote Controller: the on state\nExample 3. Part of the specification for an air-conditioner remote controller is pre-\nsented in Fig. 4. It is composed of five orthogonal components namely Fan, Temper-\nature, Timer, TempDisplay, and TimerDisplay. They will be respectively mapped to\nVerilog programs pFan, pTemperature, pTimer, pTempDisplay, and pTimerDisplay.\nAfter applying the mapping function to the statechart in Fig.4, we obtain the\nfollowing target program pon:\npon pFan pTemperature pTimer pTempDisplay pTimerDisplay\nThe five component programs are respectively\npFan bfan bfan bfan\npTemperature eIncreDecr\npTimer btimer timeron\nwhere\nhIncr\nhDecr\nbtimer\nhIncr\nhDecr\nbtimer timeroff\npTempDisplay\npTimerDisplay timeron\ntimeroff\n4.2 Correctness\nThe following theorem shows that the mapping function from Statecharts into Verilog\nis a homomorphism between the two formalisms.\nTheorem 1 (Homomorphism). Given any statechart and any of its possible transi-\ntions which leads to statechart , there exists a Verilog transition for which\narrives at , such that ; on the other hand, for any Verilog transition\nof leading to , there exists a Statecharts transition from to , such that\n, as illustrated in Fig. 5.\nC ' C \nP ' P \nt \nL L \nl \nFig. 5. Mapping function\nProof By case analysis on the type of .\n1. is constructed by Basic.\nWhat can do is to perform the clock tick and remains as after the transition.\nOn the other hand, from Definition 1 we know sink, which does nothing\nbut performs the clock tick and remains as sink after that.\n2. is constructed by Or.\nIn case that , it can be proved similar to the first case. Now suppose\n, can (1) perform a transition active for some\nin case that all transitions of outer levels (if any) are not available, which changes\nthe active substate of active from its source state to its target state and results\nin resc ; (2) otherwise, it can take a clock tick and remain its state. From\nDefinition 1 of , we know that has the form . If (1) occurs, is\nfired, from the semantics of Verilog, such a program can perform the corresponding\ntransition and become , otherwise it can perform the clock tick transition. From\nthe definition of , it is straightforward that resc .\nThe second part can be proved similarly from the definition of .\n3. is constructed by And.\nFrom Definition 1, we know\nGiven any possible transition , we assume , where\n, without loss of generality. If can be performed at the current en-\nvironment, from rule 5, we know that , for , are ready to take place\nand orthogonal components other than do not have available transitions.\nThis implies all processes can take the transition corresponding\nto respectively in the current environment, whereas others can not. From\nthe operational semantics of parallel construct of Verilog, a parallel transition cor-\nresponding to can take place and after the transition the program becomes\nwhere\nresc for\notherwise.\nIt exactly accords with resc . The case for a clock tick transition is trivial.\nThe second part is also straightforward, since any transition of the result parallel\nconstruct in Verilog either involves several threads or a single thread. From\nthe definition of , we can conclude, in either case, there exists a corresponding\nStatecharts transition for , which yields and holds.\nThe following theorem shows the soundness of the mapping function.\nTheorem 2 (Soundness). The mapping function in Definition 1 transforms any Stat-\necharts specification into a Verilog program with the same observable behaviour as the\noriginal chart.\nProof In addition to the results from Theorem 1, we need to show that, given a\nstatechart and its image in Verilog, any possible pair of their corresponding\nsteps (a statechart transition and a Verilog transition), starting from the same context\nenvironment(the same and in the corresponding configurations), consume the same\nset of events, generate the same set of events, and bring the updates of data state into\naccord. These follow directly from the construction of the mapping function .\n5 Discussion and Related Work\nIn our co-specification process, we conduct the partitioning task after a Verilog be-\nhaviour specification has been generated from the higher level system description in\nStatecharts. We use this approach because the semantics of Verilog has been well inves-\ntigated and a collection of algebraic laws ([7]) can be used as the fundamental support\nof the partitioning algorithm. In contrast, most work on Statecharts\u2019 semantics focuses\non its operational rules since it has proved to be quite difficult to present a simple de-\nnotational model from which algebraic laws of Statecharts can be derived. Due to this\ndifficulty, the partitioning problem is currently not addressed at the Statecharts level.\nAlthough it may seem unnatural to obtain a software specification in Verilog after par-\ntitioning, it is still reasonable in the sense that the behaviour subset of Verilog is very\nsimilar to C programming language and can be readily transformed into C code.\nDue to the involvedness of formal semantics for Statecharts, there have been so\nmany related works that we can hardly discuss all here. Some of them are presented in\n[6, 9, 11, 12, 14, 21]. Many of these works adopt the simpler synchronous model. The\nwork in [6] takes into account a very large subset of Statecharts, but the semantics\nis neither compositional nor formal. In contrast, our operational semantics is formal,\ncompositional and supports asynchronous model.\nAlthough it is reported that Verilog has been widely used in industry (especially\nin United States) for years, its precise semantics has been ignored until recently. The\nresults [8, 22, 23, 7] are all based on Gordon\u2019s interpretation on simulation cycles [3].\nA simple operational semantics is given in [8]. Zhu, Bowen and He [22, 23] investigate\nthe consistency between Verilog\u2019s operational and denotational semantics, while He [7]\nexplores a program algebra for Verilog and its connection with both operational and\ndenotational semantics.\nSome of related works on connecting Statecharts with other formalisms are pre-\nsented in [1, 2, 13, 19, 20, 18]. Beauvais et.al. [1] and Seshia et.al. [19] translate STATE-\nMATE Statecharts to synchronous languages Signal and Esterel respectively, aiming to\nuse supporting tools provided in the target formalisms for formal verification purposes.\nHowever, all these translations are based on the informal semantics [6] lacking correct-\nness proofs. The authors of [2, 13] transform variants of Statecharts into hierarchical\ntimed automata and use tools (UPPAAL, SPIN) to model check Statecharts properties.\nAlso, [20] based on the denotational semantics [9] aims to connect a subset of Stat-\necharts with temporal logic FNLOG for theoretically proving Statecharts\u2019 properties.\nMore recently, a translation from Statecharts to B\/AMN is reported in [18]. However,\nno correctness issue has been addressed. In comparison, the translation from Statecharts\nto Verilog in this paper aims at code generation for system design. Our mapping func-\ntion is constructed based on formal semantics for both the source and target formalisms\nand has been proven to be semantics-preserving.\n6 Conclusion\nThis paper proposes a mapping function which transforms a high level specification in\nvisual formalism Statecharts into a behaviour description in Verilog HDL. We explore a\ncompositional operational semantics to Statecharts which contains many powerful fea-\ntures that Statecharts owns, but proved to be difficult to be combined into a uniform for-\nmalism. Based on this semantics and an operational semantics for Verilog, we show our\nmapping function provides as a semantic link between the two formalisms. Moreover,\nwe combine this transformation process with our previous formal partitioning approach\nyielding a hardware\/software co-specification process that can be automated. However,\nthe translation from Statecharts to Verilog can also be used in pure hardware design.\nAfter translating into a behaviourial description in Verilog, existed Verilog synthesizer\ncan be used to obtain low level descriptions, like netlists, for direct implementation in\nhardware (ASICs or FPGAs).\nAs an immediate future work, the obtained guarded choice specification should be\ntransformed into simplified behaviourial description in Verilog using algebraic laws\n[7]. An implementation for this mapping from graphical descriptions in Statecharts to\nVerilog specifications is also being considered.\nAcknowledgement\nWe would like to thank Jifeng He for inspiration, thank Khoo Siau Cheng, P.S. Thiagarajan, Wang\nYi and Zhu Huibiao for useful discussions. We are also grateful to anonymous referees for many\nhelpful comments.\nReferences\n1. J.-R. Beauvais, et. al., \u201cA Translation of Statecharts to Signal\/DC+\u201d, Technical Report, IRISA,\n1997.\n2. Alexandre David, M. Oliver Mo\u00a8ller and Wang Yi, \u201cFormal Verification of UML Statecharts\nwith Real-Time Extensions\u201d, in the Proc. of Fundamental Approaches to Software Engineer-\ning (FASE 2002), LNCS 2306, pp. 218\u2013232, Springer-Verlag, 2002.\n3. M. Gordon, \u201cThe Semantic Challenge of Verilog HDL\u201d, In the Proc. of Tenth Annual IEEE\nSymposium on Logic in Computer Science, IEEE Computer Society Press, pp. 136\u2013145, 1995.\n4. D. Harel, \u201cStatecharts: a Visual Formalism for Complex Systems\u201d, Science of Computer Pro-\ngramming, vol.8, no.3, pp. 231\u2013274, 1987.\n5. D. Harel, \u201cOn Visual Formalisms\u201d, Communications of the ACM, Vol. 31, No. 5, pp. 541\u2013530,\n1988.\n6. D. Harel and A. Naamad, \u201cThe STATEMATE Semantics of Statecharts\u201d, ACM Transactions\non Software Engineering and Methodology, Vol. 5, No. 4, pp. 293\u2013333, October, 1996.\n7. J. He, \u201cAn Algebraic Approach to the VERILOG Programming\u201d, in the Proc. of 10th An-\nniversary Colloquium of the United Nations University \/ International Institute for Software\nTechnology (UNU\/IIST), Springer-Verlag, 2002.\n8. J. He and Q. Xu, \u201cAn Operational Semantics of a Simulator Algorithm\u201d, in the Proc. of the\n2000 International Conference on Parallel and Distributed Processing Techniques and Appli-\ncations (PDPTA\u20192000), Las Vegas, Nevada, USA, June 26-29, 2000.\n9. J.J.M. Hooman, S. Ramesh, and W.P. de Roever, \u201cA Compositional Axiomatization of State-\ncharts\u201d, Theoretical Computer Science 101, pp. 289\u2013335, 1992.\n10. IEEE Computer Society, IEEE Standard Hardware Description Language Based on the Ver-\nilog Hardware Description Language (IEEE std 1364-1995), 1995.\n11. G. Luttgen, M. von der Beeck, and R. Cleaveland, \u201cA Compositional Approach to Statecharts\nSemantics\u201d, NASA\/CR-2000-210086, ICASE Report No.2000-12, March, 2000.\n12. A. Maggiolo-Schettini, A. Peron, and S. Tini, \u201cEquivalences of Statecharts\u201d, in 7th Inter-\nnational Conference on Concurrency Theory (CONCUR\u201996), Pisa, Italy, Aug. 1996, LNCS\n1119, pp.687\u2013702, Springer-Verlag.\n13. E. Mikk, Y. Lakhnech, M. Siegel and G. Holzmann, \u201cImplementing Statecharts in\nPromela\/SPIN\u201d, in the Proc. of the 2nd IEEE Workshop on Industrial-Strength Formal Speci-\nfication Techniques, IEEE Computer Society, 1999.\n14. A. Pnueli and M. Shalev, \u201cWhat is in a Step: On the Semantics of Statecharts\u201d, in the Proc.\nof the Symposium on Theoretical Aspects of Computer Software, LNCS 526, pp. 244\u2013264,\nSpringer-Verlag, Berlin.\n15. S. Qin and J. He, \u201cAn Algebraic Approach to Hardware\/software Partitioning\u201d, in the Proc\nof the 7th IEEE International Conference on Electronics, Circuits and Systems (ICECS\u20192k),\nIEEE Computer Society Press, pp 273\u2013276, Lebanon, Dec., 2000.\n16. S. Qin and J. He, \u201cPartitioning Program into Hardware and Software\u201d, in the Proc of APSEC\n2001, IEEE Computer Society Press, pp. 309\u2013316, Macau, Dec., 2001.\n17. S. Qin, J. He, Z. Qiu, and N. Zhang, \u201cHardware\/Software Partitioning in Verilog\u201d, in the 4th\nInternational Conference for Formal Engineering Methods (ICFEM2002), LNCS 2495, pp.\n168\u2013179, Springer-Verlag.\n18. E. Sekerinski and R. Zurob, \u201cTranslating Statecharts to B\u201d, in B. Butler, L. Petre, and K.\nSere, eds.,Proc. of the 3rd International Conference on Integrated Formal Methods, Turku,\nFinland, LNCS 2335, pp. 128\u2013144, Springer-Verlag, 2002.\n19. S. Seshia, R. Shyamasundar, A. Bhattacharjee and S. Dhodapkar, \u201cA Translation of State-\ncharts to Esterel\u201d, In J. Wing, J. Woodcock, and J. Davies, eds., FM99: World Congress on\nFormal Methods, LNCS 1709, pp. 983\u20131007, 1999.\n20. A. Sowmya and S. Ramesh, \u201cExtending Statecharts with Temporal Logic\u201d, IEEE Transac-\ntions on Software Engineering, Vol. 24, No. 3, March, 1998.\n21. M. von der Beeck, \u201cA Comparison of Statecharts Variants\u201d, in Formal Techniques in Real-\nTime and Fault-Tolerant Systems, L. de Roever and J. Vytopil, Eds. LNCS 863, pp. 128\u2013148,\nSpringer-Verlag, New York.\n22. Zhu H., J. Bowen and He J., \u201cFrom Operational Semantics to Denotational Semantics for\nVerilog\u201d, in the Proc. of CHARME 2001, LNCS 2144, pp. 449\u2013464.\n23. H. Zhu, J. Bowen and J. He, \u201cSoundness, Completeness and Non-redundancy of Operational\nSemantics for Verilog Based on Denotational Semantics\u201d, in the 4th International Conference\nfor Formal Engineering Methods (ICFEM2002), LNCS 2495, pp. 600\u2013612, Springer-Verlag.\n"}