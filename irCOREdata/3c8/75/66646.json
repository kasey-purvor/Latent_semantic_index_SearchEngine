{"doi":"10.1137\/S0097539700376676","coreId":"66646","oai":"oai:dro.dur.ac.uk.OAI2:628","identifiers":["oai:dro.dur.ac.uk.OAI2:628","10.1137\/S0097539700376676"],"title":"Classifying the complexity of constraints using finite algebras.","authors":["Bulatov,  A.","Jeavons,  P.","Krokhin,  A."],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2005-04","abstract":"Many natural combinatorial problems can be expressed as constraint satisfaction problems. This class of problems is known to be NP-complete in general, but certain restrictions on the form of the constraints can ensure tractability. Here we show that any set of relations used to specify the allowed forms of constraints can be associated with a finite universal algebra and we explore how the computational complexity of the corresponding constraint satisfaction problem is connected to the properties of this algebra. Hence, we completely translate the problem of classifying the complexity of restricted constraint satisfaction problems into the language of universal algebra.We introduce a notion of \"tractable algebra,\" and investigate how the tractability of an algebra relates to the tractability of the smaller algebras which may be derived from it, including its subalgebras and homomorphic images. This allows us to reduce significantly the types of algebras which need to be classified. Using our results we also show that if the decision problem associated with a given collection of constraint types can be solved efficiently, then so can the corresponding search problem. We then classify all finite strictly simple surjective algebras with respect to tractability, obtaining a dichotomy theorem which generalizes Schaefer's dichotomy for the generalized satisfiability problem. Finally, we suggest a possible general algebraic criterion for distinguishing the tractable and intractable cases of the constraint satisfaction problem","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/66646.pdf","fullTextIdentifier":"http:\/\/dro.dur.ac.uk\/628\/1\/628.pdf","pdfHashValue":"72b7ed9677d32a34b1d6240cb5aab663b47e227c","publisher":"Society for Industrial and Applied Mathematics","rawRecordXml":"<record><header><identifier>\n  \n    \n      oai:dro.dur.ac.uk.OAI2:628<\/identifier><datestamp>\n      2011-06-15T15:54:27Z<\/datestamp><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:title>\n    \n      \n        Classifying the complexity of constraints using finite algebras.<\/dc:title><dc:creator>\n        Bulatov,  A.<\/dc:creator><dc:creator>\n        Jeavons,  P.<\/dc:creator><dc:creator>\n        Krokhin,  A.<\/dc:creator><dc:description>\n        Many natural combinatorial problems can be expressed as constraint satisfaction problems. This class of problems is known to be NP-complete in general, but certain restrictions on the form of the constraints can ensure tractability. Here we show that any set of relations used to specify the allowed forms of constraints can be associated with a finite universal algebra and we explore how the computational complexity of the corresponding constraint satisfaction problem is connected to the properties of this algebra. Hence, we completely translate the problem of classifying the complexity of restricted constraint satisfaction problems into the language of universal algebra.We introduce a notion of \"tractable algebra,\" and investigate how the tractability of an algebra relates to the tractability of the smaller algebras which may be derived from it, including its subalgebras and homomorphic images. This allows us to reduce significantly the types of algebras which need to be classified. Using our results we also show that if the decision problem associated with a given collection of constraint types can be solved efficiently, then so can the corresponding search problem. We then classify all finite strictly simple surjective algebras with respect to tractability, obtaining a dichotomy theorem which generalizes Schaefer's dichotomy for the generalized satisfiability problem. Finally, we suggest a possible general algebraic criterion for distinguishing the tractable and intractable cases of the constraint satisfaction problem.<\/dc:description><dc:subject>\n        Constraint satisfaction problem<\/dc:subject><dc:subject>\n         Universal algebra<\/dc:subject><dc:subject>\n         Dichotomy theorem.<\/dc:subject><dc:publisher>\n        Society for Industrial and Applied Mathematics<\/dc:publisher><dc:source>\n        SIAM journal on computing, 2005, Vol.34(3), pp.720-742 [Peer Reviewed Journal]<\/dc:source><dc:date>\n        2005-04<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:identifier>\n        dro:628<\/dc:identifier><dc:identifier>\n        issn:0097-5397<\/dc:identifier><dc:identifier>\n        issn: 1095-7111<\/dc:identifier><dc:identifier>\n        doi:10.1137\/S0097539700376676<\/dc:identifier><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/628\/<\/dc:identifier><dc:identifier>\n        http:\/\/dx.doi.org\/10.1137\/S0097539700376676<\/dc:identifier><dc:format>\n        application\/pdf<\/dc:format><dc:identifier>\n        http:\/\/dro.dur.ac.uk\/628\/1\/628.pdf<\/dc:identifier><dc:rights>\n        \u00a9 2005 Society for Industrial and Applied Mathematics<\/dc:rights><dc:accessRights>\n        info:en-repo\/semantics\/openAccess<\/dc:accessRights><\/oai_dc:dc><\/metadata><\/record>","journals":[{"title":null,"identifiers":["issn:0097-5397","0097-5397","issn: 1095-7111"," 1095-7111"]}],"language":{"code":"en","id":9,"name":"English"},"relations":[],"year":2005,"topics":["Constraint satisfaction problem","Universal algebra","Dichotomy theorem."],"subject":["Article","PeerReviewed"],"fullText":"Durham Research Online\nDeposited in DRO:\n07 October 2008\nVersion of attached file:\nPublished Version\nPeer-review status of attached file:\nPeer-reviewed\nCitation for published item:\nBulatov, A. and Jeavons, P. and Krokhin, A. (2005) \u2019Classifying the complexity of constraints using finite\nalgebras.\u2019, SIAM journal on computing., 34 (3). pp. 720-742.\nFurther information on publisher\u2019s website:\nhttp:\/\/dx.doi.org\/10.1137\/S0097539700376676\nPublisher\u2019s copyright statement:\n2005 Society for Industrial and Applied Mathematics\nAdditional information:\nUse policy\nThe full-text may be used and\/or reproduced, and given to third parties in any format or medium, without prior permission or charge, for\npersonal research or study, educational, or not-for-profit purposes provided that:\n\u2022 a full bibliographic reference is made to the original source\n\u2022 a link is made to the metadata record in DRO\n\u2022 the full-text is not changed in any way\nThe full-text must not be sold in any format or medium without the formal permission of the copyright holders.\nPlease consult the full DRO policy for further details.\nDurham University Library, Stockton Road, Durham DH1 3LY, United Kingdom\nTel : +44 (0)191 334 3042 \u2014 Fax : +44 (0)191 334 2971\nhttp:\/\/dro.dur.ac.uk\nSIAM J. COMPUT. c\u00a9 2005 Society for Industrial and Applied Mathematics\nVol. 34, No. 3, pp. 720\u2013742\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS\nUSING FINITE ALGEBRAS\u2217\nANDREI BULATOV\u2020 , PETER JEAVONS\u2021 , AND ANDREI KROKHIN\u00a7\nAbstract. Many natural combinatorial problems can be expressed as constraint satisfaction\nproblems. This class of problems is known to be NP-complete in general, but certain restrictions\non the form of the constraints can ensure tractability. Here we show that any set of relations used\nto specify the allowed forms of constraints can be associated with a finite universal algebra and we\nexplore how the computational complexity of the corresponding constraint satisfaction problem is\nconnected to the properties of this algebra. Hence, we completely translate the problem of classifying\nthe complexity of restricted constraint satisfaction problems into the language of universal algebra.\nWe introduce a notion of \u201ctractable algebra,\u201d and investigate how the tractability of an algebra\nrelates to the tractability of the smaller algebras which may be derived from it, including its subal-\ngebras and homomorphic images. This allows us to reduce significantly the types of algebras which\nneed to be classified. Using our results we also show that if the decision problem associated with a\ngiven collection of constraint types can be solved efficiently, then so can the corresponding search\nproblem. We then classify all finite strictly simple surjective algebras with respect to tractability, ob-\ntaining a dichotomy theorem which generalizes Schaefer\u2019s dichotomy for the generalized satisfiability\nproblem. Finally, we suggest a possible general algebraic criterion for distinguishing the tractable\nand intractable cases of the constraint satisfaction problem.\nKey words. constraint satisfaction problem, universal algebra, dichotomy theorem\nAMS subject classifications. 08A70, 68Q25, 68T99\nDOI. 10.1137\/S0097539700376676\n1. Introduction. In a constraint satisfaction problem the aim is to find an as-\nsignment of values to a given set of variables, subject to constraints on the values\nwhich can be assigned simultaneously to certain specified subsets of the variables\n[39, 43]. One common example of such a problem is the standard propositional sat-\nisfiability problem [21], where the variables must be assigned Boolean values and the\nconstraints are specified by clauses.\nThe mathematical framework used to describe constraint satisfaction problems\nhas strong links with many other areas of computer science and mathematics. For\nexample, links with relational database theory [22, 23, 34], with some notions of logic\nand group theory [1, 18, 20], and with universal algebra [31] have been investigated.\nThere is an early survey of these results in [46].\nThroughout the paper we assume that P \u0002= NP, and we call a problem tractable\nonly if it belongs to P. The constraint satisfaction problem is known to be NP-hard\nin general [39, 43]. However, certain restrictions on the form of the constraints have\nbeen shown to ensure tractability [8, 10, 30, 32, 33, 56].\nOne fundamental open research problem in this area is to characterize exactly the\nforms of constraint relations that give rise to tractable problem classes. This prob-\nlem is important from a theoretical perspective, as it helps to clarify the boundary\n\u2217Received by the editors August 15, 2000; accepted for publication (in revised form) October 19,\n2004; published electronically April 19, 2005. This work was supported by the UK EPSRC, under\ngrants GR\/M12926 and GR\/R29598.\nhttp:\/\/www.siam.org\/journals\/sicomp\/34-3\/37667.html\n\u2020School of Computing Science, Simon Fraser University, Canada (abulatov@cs.sfu.ca).\n\u2021Computing Laboratory, University of Oxford, Oxford, UK (Peter.Jeavons@comlab.ox.ac.uk).\n\u00a7Department of Computer Science, University of Durham, Durham, UK (Andrei.Krokhin@\ndurham.ac.uk).\n720\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 721\nbetween tractability and intractability in a wide range of combinatorial search prob-\nlems. It is also important from a practical perspective, as it allows the development\nof constraint programming languages that exploit the existence of diverse families of\ntractable constraints to provide more efficient solution techniques [38, 50].\nThe problem of characterizing the tractable cases was completely solved for the\nimportant special case of Boolean constraint satisfaction problems by Schaefer in\n1978 [52]. Schaefer established that for Boolean constraint satisfaction problems\n(which he called \u201cgeneralized satisfiability problems\u201d), there are exactly six differ-\nent families of tractable constraints, and any problem involving constraints not con-\ntained in one of these six families is NP-complete. This important result is known as\nSchaefer\u2019s dichotomy theorem. Similar dichotomy results have also been obtained for\nother combinatorial problems over a Boolean domain that are related to the Boolean\nconstraint satisfaction problem [11].\nSchaefer [52] raised the question of how the analysis of complexity could be ex-\ntended to larger sets of possible values (that is, sets with more than two elements).\nSome progress has been made with this question recently, and a number of tractable\nfamilies of constraints have been identified, over both finite and infinite sets. In partic-\nular, Feder and Vardi [20] used techniques from logic programming and group theory\nto identify three broad families of tractable constraints, which include all of Schae-\nfer\u2019s six classes. A series of papers by Jeavons and coauthors has shown that any\nindividual tractable constraint class over a finite domain can be characterized using\nalgebraic properties of relations [28, 29, 30, 32]. This approach was used by Bulatov\nto obtain a complete classification for the complexity of constraints on a three-element\nset [3]. Finally, we note that for temporal and spatial reasoning problems involving\nconstraints over infinite sets of values, several tractable constraint classes have been\nidentified [17, 44, 51], and a dichotomy theorem has been obtained for qualitative tem-\nporal reasoning problems over intervals expressed using Allen\u2019s interval algebra [35].\nIt has also been shown recently that the complexity of certain forms of constraint over\ninfinite sets of values can be analyzed using algebraic properties [2].\nHowever, there is still no complete classification for the complexity of constraints\nover finite sets with more than three elements, and no dichotomy has so far been\nestablished for arbitrary finite sets.\nIn our opinion, the main difficulty in addressing this question is the lack of a\npowerful and convenient language in which the properties of constraint satisfaction\nproblems responsible for complexity can be expressed. Schaefer\u2019s dichotomy theorem\nis stated in terms of the syntactic properties of propositional forms, which is certainly\nnot an appropriate language for non-Boolean constraints. A number of different at-\ntempts have been made to find such an appropriate language [13, 14, 20, 28, 30]; we\nbelieve that the most fruitful of these is the one that uses the algebraic properties of\nconstraints [28, 30].\nThe first step in the algebraic approach exploits the well-known idea that, given an\ninitial set of constraint relations, there will often be further relations that can be added\nto the set without changing the complexity of the associated problem class. In fact,\nit has been shown that it is possible to add all the relations that can be derived from\nthe initial relations using certain simple rules. The larger sets of relations obtained\nusing these rules are known as relational clones [16, 48]. Hence the first step in the\nanalysis is to note that it is sufficient to analyze the complexity only for those sets of\nrelations which are relational clones.\nThe next step in the algebraic approach is to note that relational clones can be\ncharacterized by their polymorphisms, which are algebraic operations on the same\n722 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nStructural properties of a finite universal algebra\n\u0003\nProperties of polymorphisms\n\u0003\nProperties of the corresponding relational clone\n\u0003\nComplexity of a restricted constraint satisfaction problem\nFig. 1.1. Translating questions about the complexity of different forms of constraints into\nquestions about the properties of algebras.\nunderlying set [27, 30]. As well as providing a convenient and concise method for\ndescribing large families of relations, the polymorphisms also reflect certain aspects\nof the structure of the relations that can be used for designing efficient algorithms.\nThis link between relational clones and polymorphisms has already played a key role\nin identifying many tractable constraint classes and developing appropriate efficient\nsolution algorithms for them [3, 4, 6, 7, 12, 28].\nHowever, as we shall see later on in this paper, working directly with the polymor-\nphisms of a set of relations is sometimes not the most convenient and powerful way\nto investigate the complexity of the corresponding constraint satisfaction problems.\nIn this paper we take the algebraic approach one step further by linking constraint\nsatisfaction problems with finite universal algebras (see Figure 1.1). We show that the\nlanguage of finite algebras provides a number of very powerful new tools for analyzing\nthe complexity of constraint problems. In particular, using this language allows us\nto suggest a simple criterion for distinguishing tractable and intractable cases. This\ncriterion makes extensive use of notions related to universal algebras, and is difficult\nto formulate concisely without using this language. Another advantage of this new\ntranslation is that it allows us to make use of the deep structural results developed\nfor classifying the structure of finite algebras [25, 42, 53].\nAs the first fruit of using this machinery we exhibit a new dichotomy theorem for\na class of algebras which properly includes all the two-element algebras, and hence\nprovide a true generalization of Schaefer\u2019s dichotomy theorem.\nThe paper is organized as follows. In section 2 we define the class of constraint\nsatisfaction problems we are considering, where the constraints are chosen from a\nspecified set of relations. Then we define the way in which these sets of relations can\nbe classified according to the complexity of the corresponding constraint satisfaction\nproblems. We show how this question can be translated into an equivalent question\nabout relational clones, and hence further translated into a question about classifying\nsets of operations. In section 3 we make the new step from sets of operations to finite\nalgebras, which is the real focus of this paper. Using this final translation we introduce\nthe notion of a tractable algebra. We are then able to restate Schaefer\u2019s dichotomy\ntheorem in a much shorter and possibly clearer form, as a classification of two-element\nalgebras with respect to tractability. In section 4 we prove that, in this context, it\nsuffices to consider certain restricted classes of algebras. As a by-product we show\nthat, if the decision problem for a set of constraint types can be solved efficiently, then\nso can the corresponding search problem. In section 5 we study how the tractability of\na finite algebra relates to the tractability of its smaller derived algebras. In section 6\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 723\nwe use the results obtained to classify all strictly simple surjective algebras. Finally,\nin section 7, we use the new algebraic terminology to state a conjecture about the\ngeneral structure of tractable algebras, and provide examples to illustrate and support\nthis conjecture.\n2. Definitions and earlier results.\n2.1. Constraint satisfaction problems. The central notion in the study of\nconstraints and constraint satisfaction problems is the notion of a relation.\nDefinition 2.1. For any set A, and any natural number n, the set of all n-tuples\nof elements of A is denoted by An. Any subset of An is called an n-ary relation over\nA. The set of all finitary relations over A is denoted by RA. A constraint language\nover A is a subset of RA.\nThe \u201cconstraint satisfaction problem\u201d was introduced by Montanari [43] in 1974\nand has been widely studied [15, 20, 36, 39, 40, 41]. In this paper we study a parame-\nterized version of the standard constraint satisfaction problem, in which the parameter\nis a constraint language specifying the possible forms of the constraints.\nDefinition 2.2. For any set A and any constraint language \u0393 over A, the\nconstraint satisfaction problem CSP(\u0393) is the combinatorial decision problem with\nInstance: A triple (V,A, C), where\n\u2022 V is a set of variables;\n\u2022 C is a set of constraints, {C1, . . . , Cq}.\nEach constraint Ci \u2208 C is a pair \u3008si, \u03c1i\u3009, where\n\u2013 si is a tuple of variables of length mi, called the constraint scope;\n\u2013 \u03c1i \u2208 \u0393 is an mi-ary relation over A, called the constraint relation.\nQuestion: Does there exist a solution, that is, a function \u03d5, from V to A,\nsuch that, for each constraint \u3008si, \u03c1i\u3009 \u2208 C, with si = (xi1 , . . . , xim), the tuple\n(\u03d5(xi1), . . . , \u03d5(xim)) belongs to \u03c1i?\nIn this paper we shall consider only cases where the set A, specifying the possible\nvalues for the variables, is finite. In such cases the size of a problem instance can be\ntaken to be the length of a string containing all constraint scopes and all tuples of all\nconstraint relations from the instance.\nExample 2.3. An instance of the standard propositional 3-Satisfiability prob-\nlem [21, 45] is specified by giving a formula in propositional logic consisting of a con-\njunction of clauses, each of which contains at most three literals, and asking whether\nthere are values for the variables that make the formula true.\nSuppose that \u03a6 = F1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Fn is such a formula, where the Fi are clauses. The\nsatisfiability question for \u03a6 can be expressed as the constraint satisfaction problem\ninstance (V, {0, 1}, C), where V is the set of all variables appearing in the clauses Fi,\nthe values 0 and 1 represent the logical values False and True, and C is the set\nof constraints {\u3008s1, \u03c11\u3009, . . . , \u3008sn, \u03c1n\u3009}, where each constraint \u3008sk, \u03c1k\u3009 is constructed as\nfollows:\n\u2022 sk = (xk1 , xk2 , xk3), where xk1 , xk2 , xk3 are the variables appearing in clause Fk;\n\u2022 \u03c1k = {0, 1}3 \\ {(a1, a2, a3)}, where ai = 1 if xki is negated in Fk and ai = 0\notherwise (i.e., \u03c1k contains exactly those 3-tuples that make Fk true).\nThe solutions of this instance are exactly the assignments which make the formula \u03a6\ntrue.\nIf we define \u03933-Sat to be the constraint language over {0, 1} consisting of all rela-\ntions expressible by 3-clauses, then any instance of 3-Satisfiability can be expressed\nas an instance of CSP(\u03933-Sat) in this way, and vice versa.\n724 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nExample 2.4. An instance of Graph Unreachability consists of a graph G =\n(V,E) and a pair of vertices, v, w \u2208 V . The question is whether there is no path in G\nfrom v to w.\nThis can be expressed as the constraint satisfaction problem instance defined by\n(V, {0, 1}, C), where\nC = {\u3008e, {={0,1}}\u3009 | e \u2208 E} \u222a {\u3008(v), {(0)}\u3009, \u3008(w), {(1)}\u3009},\nwhere ={0,1} denotes the equality relation over the set {0, 1}.\nIf we define \u0393gu to be the constraint language over {0, 1} containing just the\nrelations ={0,1}, {(0)} and {(1)}, then any instance of Graph Unreachability can\nbe expressed as an instance of CSP(\u0393gu) in this way.\nExample 2.5. An instance ofGraph q-Colorability consists of a graphG. The\nquestion is whether the vertices of G can be labelled with q colors so that adjacent\nvertices are assigned different colors [21, 45].\nThis problem corresponds to the problem CSP({\u0002=A}), where A is a q-element\nset (of colors) and \u0002=A is the disequality relation over A, defined by\n\u0002=A = {(a, b) \u2208 A2 | a \u0002= b}.\nExample 2.6. Given a fixed graph H, an instance of H-Colorability consists\nof a graph G. The question is whether there is a mapping from the vertices of G to\nthe vertices of H, such that adjacent vertices in G are mapped to adjacent vertices in\nH [24]. (In the special case when H is the complete graph on q vertices, Kq, the H-\nColorability problem reduces to the Graph q-Colorability problem described\nin Example 2.5.)\nThis problem corresponds to the problem CSP({EH}), where EH is the edge\nrelation of H, that is, the binary relation consisting of all adjacent pairs of vertices\nfrom H.\nMany other examples of standard combinatorial problems expressed as constraint\nsatisfaction problems can be found in [31]. For alternative formulations of the con-\nstraint satisfaction problem, such as the problem of deciding whether there is a ho-\nmomorphism from one relational structure to another, see [20, 31, 34].\n2.2. Tractable constraint languages. Throughout this paper we shall say\nthat a problem is tractable if there exists a deterministic polynomial-time algorithm\nsolving all instances of that problem. We can use Definition 2.2 to classify constraint\nlanguages according to the complexity of the corresponding constraint satisfaction\nproblem.\nIn order to be able to classify infinite, as well as finite, constraint languages, we\ndefine the notion of a tractable constraint language in a way that depends on finite\nsubsets only.\nDefinition 2.7. For any set A, a finite constraint language \u0393 \u2286 RA is said to\nbe tractable if CSP(\u0393) is tractable.\nAn infinite constraint language \u0393 \u2286 RA is said to be tractable if every finite\nsubset of \u0393 is tractable.\nA constraint language \u0393 \u2286 RA is said to be NP-complete if CSP(\u0394) is NP-\ncomplete for some finite \u0394 \u2286 \u0393.\nExample 2.8. It is well known (see [21, 45]) that the Graph q-Colorability\nproblem described in Example 2.5 is tractable when q \u2264 2 and is NP-complete\notherwise. Hence, it follows from Example 2.5 that the finite constraint language\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 725\ncontaining just the single relation \u0002=A is tractable when |A| \u2264 2 and is NP-complete\notherwise.\nExample 2.9. The complexity of the H-Colorability problem for undirected\ngraphs H was completely characterized in [24], where it was shown that if an undi-\nrected graph H is bipartite or has a loop, then the corresponding H-Colorability\nproblem is tractable; otherwise it is NP-complete.\nUsing this result, it follows from Example 2.6 that a constraint language \u0393 = {E},\nconsisting of a single symmetric binary relation E, is tractable if E is the edge relation\nof a bipartite graph, or a graph with a loop. Otherwise \u0393 is NP-complete.\nA finite or infinite constraint language \u0393 with the property that CSP(\u0393) is\ntractable will be called globally tractable. Clearly any constraint language that is\nglobally tractable is tractable in the sense of Definition 2.7, but it is not immediately\nclear whether or not the converse holds for all infinite languages. This is because for\na certain infinite constraint language \u0393, it may be the case that for each finite subset\n\u0394 \u2286 \u0393 there exists a polynomial-time algorithm Alg(\u0394) solving CSP(\u0394), and yet\nthere is no uniform polynomial-time algorithm solving CSP(\u0393). However, we know\nof no examples where this is the case and we conjecture that any tractable constraint\nlanguage is also globally tractable.\nExample 2.10. Let A be a finite field, and let \u0393Lin be the constraint language\nconsisting of all relations over A which consist of all solutions to some system of linear\nequations over A. Any relation from \u0393Lin, and therefore any instance of CSP(\u0393Lin),\ncan be represented by a system of linear equations over A. Indeed, if \u03c1 \u2208 \u0393Lin, then\nit is the solution space of the system of linear equations obtained by the following\nprocedure:\nStep 1 Pick an arbitrary element a0 = (a01, . . . , a0n) \u2208 \u03c1, and set\n\u03c10 = {b\u2212 a0 | b \u2208 \u03c1}.\nStep 2 For every member (a1, . . . , an) of \u03c10, form the equation\na1x1 + \u00b7 \u00b7 \u00b7+ anxn = 0, and find a basis, \u03c1\u22a5, of the solution space of\nthe resulting system of equations.\nStep 3 For each (b1, . . . , bn) \u2208 \u03c1\u22a5, output the equation\nb1x1 + \u00b7 \u00b7 \u00b7+ bnxn = b0, where b0 = b1a01 + \u00b7 \u00b7 \u00b7+ bna0n.\nSince any instance ofCSP(\u0393Lin) may be solved in polynomial time (e.g., by Gaussian\nelimination), it follows that \u0393Lin is a (globally) tractable constraint language.\nA constraint language over the set A = {0, 1} is known as a Boolean constraint\nlanguage. The complexity of CSP(\u0393) has been investigated [52] for all Boolean con-\nstraint languages \u0393, and the following complete classification has been obtained.\nTheorem 2.11 (see Schaefer [52]). A Boolean constraint language, \u0393, is (glob-\nally) tractable if (at least) one of the following six conditions holds:\n1. Every relation in \u0393 contains a tuple in which all entries are 0;\n2. Every relation in \u0393 contains a tuple in which all entries are 1;\n3. Every relation in \u0393 is definable by a formula in conjunctive normal form in\nwhich each conjunct has at most one negated variable;\n4. Every relation in \u0393 is definable by a formula in conjunctive normal form in\nwhich each conjunct has at most one unnegated variable;\n5. Every relation in \u0393 is definable by a formula in conjunctive normal form in\nwhich each conjunct contains at most two literals;\n6. Every relation in \u0393 is the set of solutions of a system of linear equations over\nthe finite field GF(2).\nOtherwise it is NP-complete.\n726 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nIn particular, Theorem 2.11 establishes that any Boolean constraint language can\nbe classified as either tractable or NP-complete, and hence this result is known as\nSchaefer\u2019s dichotomy theorem.\nA similar dichotomy theorem has been obtained for constraint languages over any\nset with three elements [3], using some of the algebraic methods described below. The\nclassification problem for languages over larger finite sets is still open [20], and is the\ncentral topic of this paper.\nProblem 2.12 (\u201ctractable relations problem\u201d). Characterize all tractable con-\nstraint languages over finite sets.\nExample 2.13. One of the first non-Boolean tractable constraint languages to\nbe characterized was the set \u0393ZOA of \u201c0\/1\/all\u201d relations described in [10]. The set\n\u0393ZOA contains all relations over some fixed set A of the following forms:\n(i) all unary relations;\n(ii) all binary relations of the form A1 \u00d7A2 for subsets A1, A2 of A;\n(iii) all binary relations of the form {(a, \u03c0(a)) | a \u2208 A1} for some subset A1 of A\nand some permutation \u03c0 of A;\n(iv) All binary relations of the form {(a, b) \u2208 A1 \u00d7A2 | a = a1 \u2228 b = a2} for some\nsubsets A1, A2 of A and some elements a1 \u2208 A1, a2 \u2208 A2.\nIt was shown in [10] that CSP(\u0393ZOA) is tractable, and that for any binary relation\n\u03c1 over A which is not in \u0393ZOA, CSP(\u0393ZOA \u222a {\u03c1}) is NP-complete.\n2.3. From arbitrary constraint languages to relational clones. To de-\nscribe the tractable Boolean constraint languages, Schaefer used syntactic properties\nof propositional formulas representing Boolean relations. In the non-Boolean case this\nmethod can no longer be used. We therefore need an adequate language in which it\nis possible to express the properties of constraint languages which are responsible for\nthe complexity of the corresponding constraint satisfaction problems.\nA useful first step in tackling this problem is to consider what additional rela-\ntions can be added to a constraint language without changing the complexity of the\ncorresponding problem class. This technique has been widely used in the analysis of\nBoolean constraint satisfaction problems [11, 52], and in the analysis of temporal and\nspatial constraints [17, 44, 51]; it was introduced for the study of constraints over\narbitrary finite sets in [27].\nTo use this technique we first define a method for deriving new relations from\ngiven ones. The method we use involves defining the new relations using certain\nkinds of logical formulas involving the given relations. To define such formulas we\nuse the standard correspondence between relations and predicates: a relation consists\nof all tuples of values for which the corresponding predicate holds. (We will use the\nsame symbol for a predicate and its corresponding relation, since the meaning will\nalways be clear from the context.)\nDefinition 2.14 (see [48]). A constraint language \u0393 \u2286 RA is called a relational\nclone if it contains every relation (predicate) expressible by a first-order formula in-\nvolving\n(i) relations (predicates) from \u0393 \u222a {=A} (where =A is the equality relation on\nthe set A);\n(ii) conjunction; and\n(iii) existential quantification.\nFirst-order formulas involving only conjunction and existential quantification are\noften called primitive positive (pp) formulas.\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 727\nFor any constraint language \u0393, there is a unique smallest relational clone contain-\ning \u0393, which is denoted \u3008\u0393\u3009 and is called the relational clone generated by \u0393. The set\n\u3008\u0393\u3009 consists of all relations definable by pp-formulas over the relations in \u0393 together\nwith the equality relation.\nExample 2.15. Consider the Boolean constraint language \u0393 = {R1, R2}, where\nR1 = {(0, 1), (1, 0), (1, 1)} and R2 = {(0, 0), (0, 1), (1, 0)}.\nIt is straightforward to check that every binary Boolean relation can be ex-\npressed by a pp-formula involving R1 and R2. For example, the relation R3 =\n{(0, 0), (1, 0), (1, 1)} can be expressed by the formula R3 = \u2203yR1(x, y) \u2227 R2(y, z).\nHence the relational clone generated by \u0393, \u3008\u0393\u3009, includes all 16 binary Boolean rela-\ntions.\nIn fact it can be shown that \u3008\u0393\u3009 consists of precisely those Boolean relations (of\nany arity) that can be expressed as a conjunction of unary or binary Boolean relations\n[49, 53].\nThere are a number of different but equivalent definitions of relational clones\n[16, 48], and a different definition was used in [27] to establish the following theorem.\nWe give a proof here that uses Definition 2.14.\nTheorem 2.16 (see [27]). For any set of relations \u0393 and any finite set \u0394 \u2286 \u3008\u0393\u3009,\nthere is a polynomial time reduction from CSP(\u0394) to CSP(\u0393).\nProof. Let \u0394 = {\u00051, . . . , \u0005k} be a finite set of relations over the finite set A, where\neach \u0005i is expressible by a pp-formula involving relations from \u0393 and the equality\nrelation, =A. Note that we may fix these representations.\nAny instance (V ;A; C) \u2208 CSP(\u0394) can be transformed as follows. For every\nconstraint \u3008s, \u03c1\u3009 \u2208 C, where s = (v1, . . . , vl) and \u03c1 is representable by the pp-formula\n\u03c1(v1, . . . , vl) = \u2203u1, . . . , um (\u03c11(w11, . . . , w1l1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c1n(wn1 , . . . , wnln)),\nwhere w11, . . . , w\n1\nl1\n, . . . , wn1 , . . . , w\nn\nln\n\u2208 {v1, . . . , vl, u1, . . . , um},\n(i) add the auxiliary variables u1, . . . , um to V (renaming if necessary so that\nnone of them occurs before);\n(ii) add the constraints \u3008(w11, . . . , w1l1), \u03c11\u3009, . . . , \u3008(wn1 , . . . , wnln), \u03c1n\u3009 to C;\n(iii) remove \u3008s, \u03c1\u3009 from C.\nIt can easily be checked that the problem instance obtained by this procedure is\nequivalent to (V ;A; C) and belongs to CSP(\u0393 \u222a {=A}). Moreover, since all the rep-\nresentations of relations from \u0394 are fixed, this transformation can be carried out in\nlinear time in the size of the instance. Finally, all constraints of the form \u3008(v1, v2),=A\u3009\ncan be eliminated by replacing all occurrences of the variable v1 with v2. This trans-\nformation can also be carried out in polynomial time.\nCorollary 2.17. A set of relations \u0393 is tractable if and only if the relational\nclone \u3008\u0393\u3009 is tractable.\nSimilarly, \u0393 is NP-complete if and only if \u3008\u0393\u3009 is NP-complete.\nThis result reduces the problem of characterizing tractable constraint languages\nto the problem of characterizing tractable relational clones.\nExample 2.18. Reconsider the tractable constraint language of 0\/1\/all relations,\n\u0393ZOA, defined in Example 2.13.\nNote that for any fixed finite set A, the set of 0\/1\/all relations over A contains\nonly unary and binary relations and is therefore finite. However, it follows from\nCorollary 2.17 that the relational clone \u3008\u0393ZOA\u3009 is also tractable. This is an infinite\nset of relations containing relations of every possible arity.\n728 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nIn fact, the set \u3008\u0393ZOA\u3009 corresponds precisely to the implicational relations de-\nfined in [33]. Moreover, the set of 0\/1\/all relations, \u0393ZOA, is precisely the set of\nunary and binary relations in the relational clone \u3008\u0393ZOA\u3009.\n2.4. From relational clones to sets of operations. We have shown in the\nprevious section that to analyze the complexity of arbitrary constraint languages it\nis sufficient to consider only relational clones. This considerably reduces the variety\nof languages to be studied. However, it immediately raises the question of how to\nrepresent and describe relational clones. For many relational clones the only known\ngenerating sets are rather sophisticated, and in some cases no generating sets are\nknown [48].\nVery conveniently, it turns out that there is a well-known alternative way to\nrepresent and describe any relational clone, using operations. In our definitions we\nfollow [42] and [53].\nDefinition 2.19. For any set A, and any natural number n, a mapping f :\nAn \u2192 A is called an n-ary operation on A. The set of all finitary operations on A is\ndenoted by OA.\nWe first describe a fundamental algebraic relationship between operations and\nrelations. Note that any operation on a set A can be extended in a standard way\nto an operation on tuples of elements from A, as follows. For any (m-ary) operation\nf and any collection of tuples a1, . . . , am \u2208 An, where ai = (a1i, . . . , ani), define\nf(a1, . . . , am) to be (f(a11, . . . , a1m), . . . , f(an1, . . . , anm)).\nDefinition 2.20 (see [16, 48, 53]). An m-ary operation f \u2208 OA preserves an\nn-ary relation \u03c1 \u2208 RA (or f is a polymorphism of \u03c1, or \u03c1 is invariant under f) if\nf(a1, . . . , am) \u2208 \u03c1 for all choices of a1, . . . , am \u2208 \u03c1.\nFor any given sets \u0393 \u2286 RA and F \u2286 OA, let\nPol(\u0393) = {f \u2208 OA | f preserves each relation from \u0393},\nInv(F ) = {\u03c1 \u2208 RA | \u03c1 is invariant under each operation from F}.\nWe remark that the operators Pol and Inv form a Galois correspondence between RA\nand OA (see Proposition 1.1.14 of [48]). Introductions to this correspondence can be\nfound in [16, 47], and a comprehensive study in [48]. We note, in particular, that\nInv(F ) = Inv(Pol(Inv(F ))), for any set of operations F . Sets of the form Inv(F ) are\nprecisely the relational clones, as the next result indicates.\nProposition 2.21 (see [48]). For any set A, and any F \u2286 OA, the set Inv(F )\nis a relational clone. Conversely, any relational clone can be represented in the form\nInv(F ) for some set F \u2286 OA. In particular, for any \u0393 \u2286 RA, \u3008\u0393\u3009 = Inv(Pol(\u0393)).\nUsing Proposition 2.21 together with Corollary 2.17, we can now translate our\noriginal problem of characterizing tractable sets of relations (Problem 2.12) into an\nequivalent problem for sets of operations. First, we define what it means for a set of\noperations to be tractable or NP-complete.\nDefinition 2.22. A set F \u2286 OA is said to be tractable if Inv(F ) is tractable. A\nset F \u2286 OA is said to be NP-complete if Inv(F ) is NP-complete.\nUsing this definition, we obtain the following translation of Problem 2.12.\nProblem 2.23 (\u201ctractable operations problem\u201d). Characterize all tractable sets\nof operations on finite sets.\nIn many cases the description of a set of operations provides a compact, concise\nway to describe the associated relational clone, as the next example indicates.\nExample 2.24. Recall the constraint language \u0393ZOA of 0\/1\/all relations which\nwas defined in Example 2.13 and extended to \u3008\u0393ZOA\u3009 in Example 2.18.\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 729\nIt was shown in [30] that \u3008\u0393ZOA\u3009 is precisely the constraint language consisting\nof all relations which are invariant under the ternary \u201cdual discriminator\u201d operation\nd, defined as follows:\nd(x, y, z) =\n{\ny if y = z,\nx otherwise.\nHence this infinite tractable constraint language, which is rather complicated to de-\nscribe in detail, may be represented very simply as the set of relations invariant under\nthe tractable set of operations {d}.\nIn many cases, it has been shown that the presence of a single operation satisfying\ncertain simple conditions is sufficient to ensure the tractability of a set of operations.\nExample 2.25. A binary operation f(x, y) satisfying the following three condi-\ntions is said to be a semilattice operation:1\n(i) f(x, f(y, z)) = f(f(x, y), z) (associativity),\n(ii) f(x, y) = f(y, x) (commutativity),\n(iii) f(x, x) = x (idempotency).\nTheorem 16 of [29] says that for any finite set A, any set of operations F \u2286 OA\ncontaining a semilattice operation is tractable.\nIn contrast, we will now consider the properties of operations that are associated\nwith NP-complete constraint languages.\nDefinition 2.26. An operation f : An \u2192 A is called essentially unary if there\nexists a (nonconstant) unary operation g : A \u2192 A and an index i \u2208 {1, 2, . . . , n}\nsuch that f(a1, a2, . . . , an) = g(ai) for all choices of a1, a2, . . . , an. If g is the identity\noperation, then f is called a projection.\nAny operation which is not essentially unary (including all constant operations)\nwill be called essentially nonunary.\nProposition 2.27 (see Jeavons [27]). For any finite set A and any \u0393 \u2286 RA, if\nPol(\u0393) contains essentially unary operations only, then CSP(\u0393) is NP-complete.\nExample 2.28. Consider the relation N over the set {0, 1}, defined by\nN = {0, 1}3 \\ {(0, 0, 0), (1, 1, 1)}.\nIt can be shown that Pol({N}) contains essentially unary operations only [49], and\nhence CSP({N}) is NP-complete, by Proposition 2.27.\nWe remark that the problem CSP({N}) was first shown to be NP-complete by\nSchaefer [52]; it corresponds to a restricted form of the Not-All-Equal Satisfia-\nbility problem [21, 45].\nBoolean operations, that is, operations on A = {0, 1}, have been very well stud-\nied [49, 53]. In particular, it is known that if a Boolean constraint language is not\ncontained in one of Schaefer\u2019s six tractable classes, then all of its polymorphisms are\nessentially unary operations [53]. Hence we may reformulate Schaefer\u2019s dichotomy\ntheorem to obtain the following complete classification for Boolean operations.\nCorollary 2.29 (Schaefer\u2019s dichotomy for operations). A set of Boolean op-\nerations is tractable if it contains an essentially nonunary operation. Otherwise it is\nNP-complete.\n1Note that in some earlier papers [27, 30, 46] the term ACI operation is used.\n730 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\n3. Algebras. We have shown in section 2 that the problem of analyzing the\ncomplexity of a constraint language can be translated into the problem of analyzing\nthe complexity of the set of operations which preserve all of the relations in that\nlanguage. In the Boolean case, this is sufficient to obtain a complete classification of\ncomplexity, but over larger sets we need to develop more powerful analytical tools, as\nthe next example indicates.\nExample 3.1. Consider the binary operation \u25e6 on the set {0, 1, 2} defined by the\nfollowing Cayley table:\n\u25e6 0 1 2\n0 0 1 1\n1 1 1 0\n2 2 2 2\nThis operation does not fall into any known tractable class, nor is it essentially unary.\nHence we cannot determine the complexity of this operation using the tools of the\nprevious section (but see Example 5.5 below).\nIn this section we shall open the way to the use of a further set of powerful ana-\nlytical tools by making the final translation step, from sets of operations to algebras.\nDefinition 3.2. An algebra is an ordered pair A = (A,F ) such that A is a\nnonempty set and F is a family of finitary operations on A. The set A is called the\nuniverse of A, and the operations from F are called basic. An algebra with a finite\nuniverse is referred to as a finite algebra.\nTo make the translation from sets of operations to algebras we simply note that\nany set of operations F on a fixed set A can be associated with the algebra (A,F ).\nHence, we will define what it means for an algebra to be tractable by considering the\ntractability of the basic operations.\nDefinition 3.3. An algebra A = (A,F ) is said to be tractable if F is tractable.\nAn algebra A = (A,F ) is said to be NP-complete if F is NP-complete.\nUsing Definition 3.3 we can now translate our original tractable relations problem\n(Problem 2.12) into the following equivalent problem for algebras.\nProblem 3.4 (\u201ctractable algebras problem\u201d). Characterize all tractable alge-\nbras.\nUsing Definition 3.3, we can reformulate Schaefer\u2019s dichotomy theorem [52] in yet\nanother way, this time as a classification of the complexity of algebras defined on a\ntwo-element set.\nCorollary 3.5 (Schaefer\u2019s dichotomy for algebras). An algebra with a two-\nelement universe is NP-complete if all of its basic operations are essentially unary.\nOtherwise it is tractable.\nThe first advantage of using algebras instead of sets of operations is that we can\nmake use of some standard constructions on algebras to obtain new results about\nthe complexity of constraint languages. Another advantage is that finite algebras\nhave been extensively studied, and a considerable body of structural theory has been\ndeveloped [25, 42, 53]. We explore these ideas further in the remainder of the paper.\nIn our study it will be useful to describe an equivalence relation linking algebras\nthat correspond to the same constraint language. As we noted earlier, the mappings\nPol and Inv have the property that Inv(Pol(Inv(F ))) = Inv(F ), and so we can extend a\nset of operations F to the set Pol(Inv(F )) without changing the associated invariant\nrelations. The set Pol(Inv(F )) consists of all operations that can be obtained from the\noperations in F , together with the set of all projection operations, by forming arbitrary\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 731\ncompositions of operations [16, 48]. (If f is an n-ary operation on A, and g1, g2, . . . , gn\nare k-ary operations on A, then the composition of f and g1, g2, . . . , gn is the k-ary\noperation h on A defined by h(a1, a2, . . . , ak) = f(g1(a1, . . . , ak), . . . , gn(a1, . . . , ak)).)\nThe set of operations obtained in this way is usually referred to in universal algebra\nas the set of term operations over F [16], so we will make the following definition.\nDefinition 3.6. For any algebra A = (A,F ), an operation f on A will be called\na term operation of A if f \u2208 Pol(Inv(F )).\nThe set of all term operations of A will be denoted Term(A).\nTwo algebras with the same universe are called term equivalent if they have\nthe same set of term operations. Note that, for any algebra A = (A,F ), we have\nInv(F ) = Inv(Term(A)), so two algebras are term equivalent if and only if they have\nthe same set of associated invariant relations. It follows that we need to characterize\ntractable algebras only up to term equivalence.\nExample 3.7. A group is an algebra with three basic operations: a binary multipli-\ncation operation, a unary converse operation, and a constant unit operation (see [37]).\nA coset of a group is a relation which is invariant under the ternary term operation\nt(x, y, z) = xy\u22121z. It is stated in Theorem 33 of [20] that any constraint language con-\nsisting of cosets of a finite group is tractable. Hence any finite group is tractable, and\nmoreover, any finite algebra with the ternary term operation t is also tractable.\n4. Special classes of algebras. In this section we will show that, when study-\ning the tractability of finite algebras, we can restrict our attention to certain special\nclasses of algebras.\nDefinition 4.1. We call an algebra surjective if all of its term operations are\nsurjective.2\nIt is easy to verify that a finite algebra is surjective if and only if its unary term\noperations are all surjective and hence form a group of permutations.\nIt was shown in [27] that any unary polymorphism can be applied to a set of\nrelations without changing the complexity of that set.\nProposition 4.2 (see [27]). For any set of relations \u0393, and any unary operation\nf \u2208 Pol(\u0393), let f(\u0393) be the set of relations {f(\u03c1) | \u03c1 \u2208 \u0393}, where f(\u03c1) = {f(a) | a \u2208 \u03c1}.\nThe set \u0393 is tractable if and only if f(\u0393) is tractable, and \u0393 is NP-complete if and\nonly if f(\u0393) is NP-complete.\nAny algebra A = (A,F ) which is not surjective will have a unary term operation\nf which is not surjective, and hence has range U , where U is a proper subset of A. By\napplying this operation to all of the relations in Inv(F ), as described in Proposition 4.2,\nwe can obtain a set of relations over U without changing the tractability. The algebra\ncorresponding to this new set of relations can be shown to be a term induced algebra\nof A, which is defined as follows.\nDefinition 4.3 (see [55]). Let A = (A,F ) be an algebra, and let U be a nonempty\nsubset of A. The term induced algebra A|U is defined as (U,Term(A)|U ), where\nTerm(A)|U = {g|U : g \u2208 Term(A) and g preserves U}.\nBy choosing a unary term operation f with a range U of minimal cardinality,\nwe can ensure that the term induced algebra A|U is surjective. Hence we have the\nfollowing theorem.\nTheorem 4.4. For any finite algebra A, there exists a set U such that\n(i) the algebra A|U is surjective, and\n2Note that in [54] an algebra is said to be surjective if all of its basic operations are surjective.\nHowever, such algebras can have nonsurjective term operations, so our definition is more restrictive.\n732 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\n(ii) the algebra A is tractable if and only if A|U is tractable, and is NP-complete\nif and only if A|U is NP-complete.\nTheorem 4.4 shows that we can restrict our attention to surjective algebras. The\nnext theorem shows that for many purposes we need consider only those surjective\nalgebras with the additional property of being idempotent.\nDefinition 4.5. An operation f on A is called idempotent if it satisfies f(x, . . . , x) =\nx for all x \u2208 A.\nThe full idempotent reduct of an algebra A = (A,F ) is the algebra (A,Termid(A)),\nwhere Termid(A) consists of all idempotent operations from Term(A).\nNote that an operation f on a set A is idempotent if and only if it preserves\nall the relations in the set \u0393con = {{(a)} | a \u2208 A}, consisting of all unary one-\nelement relations on A. Hence, Inv(Termid(A)) is the relational clone generated by\nInv(F ) \u222a \u0393con.\nTo establish the next theorem we need an auxiliary lemma from [53].\nLemma 4.6. Let A = ({a1, a2, . . . , ak}, F ) be a finite algebra whose unary term\noperations form a permutation group G. Then the relation \u03c1G, defined by\n\u03c1G = {(g(a1), . . . , g(ak)) | g \u2208 G},\nbelongs to Inv(F ).\nProof. Proposition 1.3 of [53] states that relations of the form \u03c1G are preserved\nby all operations of the algebra A and hence belong to Inv(F ).\nTheorem 4.7. A finite surjective algebra A is tractable if and only if its full\nidempotent reduct A0 is tractable. Moreover, A is NP-complete if and only if A0 is\nNP-complete.\nProof. Let A = (A,F ) be a finite surjective algebra, and let A0 be the full\nidempotent reduct of A.\nAs observed above, Inv(Term(A0)) is the relational clone generated by the set\nInv(F )\u222a\u0393con, where \u0393con = {{(a)} | a \u2208 A}. By Corollary 2.17, it follows that A0\nis tractable if and only if Inv(F ) \u222a \u0393con is tractable, and A0 is NP-complete if and\nonly if Inv(F ) \u222a \u0393con is NP-complete. In the remainder of the proof we will show\nthat CSP(Inv(F ) \u222a \u0393con) is polynomial-time equivalent to CSP(Inv(F )).\nClearly, every instance of CSP(Inv(F )) may be considered as an instance of\nCSP(Inv(F ) \u222a \u0393con), so there is a constant-time reduction from CSP(Inv(F )) to\nCSP(Inv(F ) \u222a \u0393con).\nFor the converse result, let P = (V,A, C) be an instance of CSP(Inv(F ) \u222a \u0393con)\nand let P \u2032 be the problem instance (V \u2032, A, C\u2032), where V \u2032 = V \u222a {va | a \u2208 A} (each of\nthe variables va is a new variable not in V ). To obtain the constraints C\u2032, take the\noriginal constraints C of P, and replace each unary constraint of the form \u3008v, {(a)}\u3009\nin C with the constraint \u3008(v, va),=A\u3009, where =A is the binary equality relation on A.\nFinally, add the constraint \u3008(va1 , . . . , vak), \u0005G\u3009, where a1, a2, . . . , ak are the elements\nof A (in some order) and \u0005G is the relation defined in Lemma 4.6. Note that P \u2032 is an\ninstance of CSP(Inv(F )) and that this construction can be carried out in polynomial\ntime.\nWe claim that if the problem P \u2032 has a solution \u03c8, then it has a solution \u03c6 such\nthat \u03c6(va) = a for all a \u2208 A. To establish this claim, note that, by the definition of\n\u03c1G, there is g \u2208 G such that \u03c8(va) = g(a) for all a \u2208 A. Since G is a group, the\ninverse operation g\u22121 \u2208 G, which means that it is a term operation of A. This implies\nthat every relation in Inv(F ) is invariant under g\u22121, so \u03c6 = g\u22121\u03c8 is also a solution to\nP \u2032, and has the property that g\u22121\u03c8(va) = a for all a \u2208 A.\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 733\nAny solution \u03c6 satisfying this condition clearly satisfies all the constraints in C, so\nthe restriction of \u03c6 to V is a solution to P. Conversely, if \u03c8 is any solution to P, then\nits extension \u03c8\u2032 to V \u2032 such that \u03c8\u2032(va) = a, for all a \u2208 A, is a solution to P \u2032. Hence\nthis construction establishes a polynomial-time reduction from CSP(Inv(F )\u222a \u0393con)\nto CSP(Inv(F )).\nTheorem 4.7 can be restated in terms of constraint languages, as follows.\nCorollary 4.8. Let \u0393 be a constraint language over a finite set A, and let\n\u0393con = {{(a)} | a \u2208 A} be the set of all unary one-element relations on A.\nIf all unary polymorphisms of \u0393 are permutations, then \u0393 is tractable if and\nonly if \u0393 \u222a \u0393con is tractable, and \u0393 is NP-complete if and only if \u0393 \u222a \u0393con is\nNP-complete.\nCorollary 4.8 has an interesting consequence connecting decision problems and\nsearch problems. In this paper we have formulated the constraint satisfaction problem\nas a decision problem (Definition 2.2), in which the question is to decide whether\nor not a solution exists. However, the corresponding search problem, in which the\nquestion is to find a solution, often arises in practice. We will now show that the\ntractable cases of these two forms of the problem coincide. (Note that the tractable\ncases of the search problem are those which belong to the complexity class FP.)\nCorollary 4.9. A decision problem CSP(\u0393) is tractable if and only if the\ncorresponding search problem can be solved in polynomial time.\nProof. Obviously, tractability of the search problem implies tractability of the\ncorresponding decision problem.\nFor the converse, let \u0393 be a tractable set of relations over a finite set A. By\nchoosing a unary polymorphism f of \u0393, whose image set U is minimal, we can obtain\na corresponding set of relations \u0393\u2032 = f(\u0393) over U , such that every unary polymorphism\nof \u0393\u2032 is a permutation. By Proposition 4.2, \u0393\u2032 is also tractable.\nNow consider any instance P = (V,A, C) of CSP(\u0393). By the choice of \u0393, we can\ndecide in polynomial time in the size of P whether this instance has a solution. Assume\nthat it has. Then the instance P \u2032 = (V,U, C\u2032), obtained by replacing each constraint\nrelation \u03c1 with the corresponding relation f(\u03c1), also has a solution. Furthermore,\nevery solution of P \u2032 is also a solution to P.\nSince P \u2032 has a solution, it follows that for each v \u2208 V there must be some a \u2208 A\nfor which we can add the constraint \u3008(v), {(a)}\u3009 and still have a solvable instance.\nHence, by considering each variable in turn, and each possible value a \u2208 A for that\nvariable, we can add such a constraint to each variable in turn, and hence obtain\na solution to P \u2032. Checking for solvability for each possible value at each variable\nrequires us to solve an instance of the decision problem CSP(\u0393\u2032 \u222a \u0393con) at most\n|V | \u00b7 |U | times, and hence can be completed in polynomial time in the size of P \u2032, by\nCorollary 4.8.\n5. Constructions on algebras. The results in this section link the complexity\nof a finite algebra with the complexity of its subalgebras and homomorphic images\n[9, 16, 42]. In many cases, we can use these results to reduce the problem of analyzing\nthe complexity of an algebra to a similar problem involving an algebra with a smaller\nuniverse.\nDefinition 5.1. Let A = (A,F ) be an algebra and B a subset of A such that,\nfor any f \u2208 F and for any b1, . . . , bn \u2208 B, where n is the arity of f , we have\nf(b1, . . . , bn) \u2208 B. Then the algebra B = (B,F |B) is called a subalgebra of A, where\nF |B consists of the restrictions of all operations in F to B. If B \u0002= A, then B is said\nto be a proper subalgebra.\n734 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nTheorem 5.2. Let A be a finite algebra.\n(i) If A is tractable, then so is every subalgebra of A.\n(ii) If A has an NP-complete subalgebra, then A is NP-complete.\nProof. Let B = (B,F |B) be a subalgebra of A = (A,F ). It is easy to check\nthat Inv(F |B) \u2286 Inv(F ). Hence, CSP(Inv(F |B)) can be reduced to CSP(Inv(F )) in\nconstant time.\nNow (i) and (ii) follow immediately from the existence of this reduction.\nDefinition 5.3. Let A1 = (A1, F1) and A2 = (A2, F2) be such that F1 = {f1i |\ni \u2208 I} and F2 = {f2i | i \u2208 I}, where both f1i and f2i are ni-ary, for all i \u2208 I.\nA map \u03d5 : A1 \u2192 A2 is called a homomorphism from A1 to A2 if\n\u03d5f1i (a1, . . . , ani) = f\n2\ni (\u03d5(a1), . . . , \u03d5(ani))\nholds for all i \u2208 I and all a1, . . . , ani \u2208 A1.\nIf the map \u03d5 is surjective, then A2 is said to be a homomorphic image of A1.\nTheorem 5.4. Let A be a finite algebra.\n(i) If A is tractable, then so is every homomorphic image of A.\n(ii) If A has an NP-complete homomorphic image, then A is NP-complete.\nProof. Let B = (B,FB) be a homomorphic image of A = (A,FA) and let \u03d5 be\nthe corresponding homomorphism. We will show that, for any finite \u0393 \u2286 Inv(FB),\nCSP(\u0393) is linear-time reducible to CSP(\u0393\u2032) for some finite \u0393\u2032 \u2286 Inv(FA).\nFor \u03c1 \u2208 Inv(FB), set \u03d5\u22121(\u03c1) = {a | \u03d5(a) \u2208 \u03c1} where \u03d5 acts componentwise. It\nis clear that \u03d5\u22121(\u03c1) is a relation of the same arity as \u03c1. It can straightforwardly be\nchecked that \u03d5\u22121(\u03c1) \u2208 Inv(FA). Let \u0393\u2032 = {\u03d5\u22121(\u03c1) | \u03c1 \u2208 \u0393}. Then \u0393\u2032 is a finite subset\nof Inv(FA).\nTake an instance P = (V,B, C) of CSP(\u0393) and construct an instance P \u2032 =\n(V,A, C\u2032) of CSP(\u0393\u2032) where C\u2032 = {\u3008s, \u03d5\u22121(\u03c1)\u3009 | \u3008s, \u03c1\u3009 \u2208 C}.\nIf \u03c8 is a solution of P \u2032, then \u03d5\u03c8 is a solution of P. Conversely, if \u03be is a solution of\nP, then any function \u03c8 : V \u2192 A such that \u03d5\u03c8(v) = \u03be(v) for any v \u2208 V is a solution\nof P \u2032.\nWe now give two examples to illustrate the use of Theorems 5.2 and 5.4. The\nexamples show that both of these results can be useful (independently) to establish the\ncomplexity of certain algebras by reducing the question to an algebra over a smaller\nset.\nExample 5.5. Reconsider Example 3.1. LetA be the idempotent algebra ({0, 1, 2}, \u25e6),\nwhere \u25e6 is the binary operation defined by the following Cayley table:3\n\u25e6 0 1 2\n0 0 1 1\n1 1 1 0\n2 2 2 2\nBy using Theorem 5.4, we will show that A is NP-complete even though all of its\nproper subalgebras are tractable.\nNotice that, as the equalities 0 \u25e6 2 = 1, 1 \u25e6 2 = 0, 0 \u25e6 1 = 1 \u25e6 0 = 1 show,\nA has only one proper subalgebra having more than one element, the algebra B =\n({0, 1}, \u25e6|{0,1}). It is easy to check that \u25e6|{0,1} is a semilattice operation on {0, 1}.\nHence, by Definition 3.3 and Theorem 16 of [29] (see Example 2.25), the algebra B is\ntractable.\n3Note that we write x \u25e6 y instead of \u25e6(x, y).\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 735\nOn the other hand, consider the algebra C = (C, \u2217), where C = {a, b} and for all\nx, y \u2208 {a, b}, x \u2217 y = x. It is easy to check that the mapping \u03d5 : {0, 1, 2} \u2192 C such\nthat \u03d5(0) = \u03d5(1) = a, \u03d5(2) = b, is a homomorphism from A onto C. By Corollary 3.5,\nC is NP-complete. Hence, by Theorem 5.4, A is NP-complete.\nExample 5.6. Consider the idempotent algebra A = ({0, 1, 2}, \u25e6), where \u25e6 is the\nbinary operation defined by the following Cayley table:\n\u25e6 0 1 2\n0 0 1 1\n1 0 1 1\n2 1 1 2\nBy using Theorem 5.2, we will show that A is NP-complete even though all of its\nsmaller homomorphic images are tractable.\nSince one-element algebras are certainly tractable, we need to consider only two-\nelement homomorphic images B ofA. Let B = ({a, b}, \u2217), where \u2217 is a binary operation\non {a, b}, and assume that \u03d5 is a homomorphism from A onto B. Then we have\n\u03d5(x \u25e6 y) = \u03d5(x) \u2217 \u03d5(y) for all x, y \u2208 {0, 1, 2}.\nCase 1. \u03d5(0) = \u03d5(1) = a, \u03d5(2) = b. In this case we have\na \u2217 a = \u03d5(0) \u2217 \u03d5(0) = \u03d5(0 \u25e6 0) = \u03d5(0) = a,\na \u2217 b = \u03d5(0) \u2217 \u03d5(2) = \u03d5(0 \u25e6 2) = \u03d5(1) = a,\nb \u2217 a = \u03d5(2) \u2217 \u03d5(0) = \u03d5(2 \u25e6 0) = \u03d5(1) = a,\nb \u2217 b = \u03d5(2) \u2217 \u03d5(2) = \u03d5(2 \u25e6 2) = \u03d5(2) = b.\nIt is easy to check that \u2217 is a semilattice operation on {a, b}. Hence, by Definition 3.3\nand Theorem 16 of [29] (see Example 2.25), the algebra B is tractable.\nCase 2. \u03d5(0) \u0002= \u03d5(1).\nIt follows that \u03d5(2) \u2208 {\u03d5(0), \u03d5(1)}. If \u03d5(2) = \u03d5(0), then\n\u03d5(0) = \u03d5(0 \u25e6 0) = \u03d5(0) \u2217 \u03d5(0) = \u03d5(0) \u2217 \u03d5(2) = \u03d5(0 \u25e6 2) = \u03d5(1).\nAlternatively, if \u03d5(2) = \u03d5(1), then\n\u03d5(0) = \u03d5(1 \u25e6 0) = \u03d5(1) \u2217 \u03d5(0) = \u03d5(2) \u2217 \u03d5(0) = \u03d5(2 \u25e6 0) = \u03d5(1).\nHence this second case is impossible, and we have shown that all smaller homo-\nmorphic images of A are tractable.\nOn the other hand, the algebra A has a subalgebra A\u2032 = ({0, 1}, \u25e6) such that\nx \u25e6 y = y for all x, y \u2208 {0, 1}. By Corollary 3.5, A\u2032 is NP-complete. Hence, by\nTheorem 5.2, A is NP-complete.\n6. Strictly simple surjective algebras. The results of the previous section\nhave established that a tractable algebra must have the property that all of its sub-\nalgebras and homomorphic images are tractable. Hence, a natural first question is\nwhether we can classify the complexity of all algebras which do not have any smaller\n(nontrivial) subalgebras or homomorphic images. Classifying all such algebras can be\nviewed as a possible \u201cbase case for induction\u201d in the pursuit of a general classification.\nDefinition 6.1. A finite algebra is called simple if all of its smaller homomorphic\nimages are one-element; and strictly simple4 if it is simple and all of its proper\nsubalgebras are one-element.\n4In some papers appearing before 1990 such algebras are called plain.\n736 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nBy Theorem 4.4, it is sufficient to consider only surjective algebras. In this section\nwe obtain a complete classification for all strictly simple surjective algebras.5 We\nshow that any algebra of this type is either tractable or NP-complete, and we give a\ncomplete characterization of the tractable cases. Such algebras include all surjective\ntwo-element algebras, as well as many algebras over larger universes, so this dichotomy\nresult includes and generalizes Schaefer\u2019s dichotomy for algebras with a two-element\nuniverse (see Corollary 3.5 above).\nTo obtain the result, we make use of the complete description of finite strictly\nsimple surjective algebras obtained by Szendrei [54]. To formulate Szendrei\u2019s result,\nwe first need to introduce some further standard algebraic concepts and notation (for\na general introduction to these algebraic concepts, see, for example, [37]).\nLet G be a permutation group acting on a set A. By R(G) we denote the set\nof operations on A preserving each relation of the form {(a, g(a)) | a \u2208 A}, for some\ng \u2208 G. By Rid(G) we denote the set of idempotent operations in R(G).\nA permutation group G acting on a set A is called regular if, for any a, b \u2208 A,\nthere exists g \u2208 G such that g(a) = b, and if each nonidentity member of G has no\nfixed point. G is called primitive if the algebra (A,G) is simple.\nLet A = (A,+) be a finite Abelian group, and let K be a finite field. The finite\ndimensional vector space on A over K will be denoted KA = (A; +,K), the group of\ntranslations {x+ a | a \u2208 A} will be denoted T (A), and the endomorphism ring of KA\nwill be denoted End KA. Note that one can consider A as a module over End KA.\nThis module will be denoted by (End KA)A.\nFinally, let F0k denote the set of all operations preserving the relation\nX0k = {(a1, . . . , ak) \u2208 Ak | ai = 0 for at least one i, 1 \u2264 i \u2264 k},\nwhere 0 is some fixed element of A, and let F0\u03c9 =\n\u22c2\u221e\nk=2 F0k .\nTheorem 6.2 (see [54]). Let A be a finite strictly simple surjective algebra.\n\u2022 If A has no one-element subalgebras, then A is term equivalent to one of the\nfollowing algebras:\n(a) (A,R(G)) for a regular permutation group G acting on A;\n(b) (A,Termid((End KA)A) \u222a T (A)) for some vector space KA = (A; +,K)\nover a finite field K;\n(c) (A,G) for a primitive permutation group G on A.\n\u2022 If A has one-element subalgebras, then A is idempotent and term equivalent\nto one of the following algebras:\n(a\u25e6) (A,Rid(G)) for a permutation group G on A such that every nonidentity\nmember of G has at most one fixed point;\n(b\u25e6) (A,Termid((End KA)A)) for some vector space KA over a finite field K;\n(d) (A,Rid(G) \u2229 F0k ) for some k ( 2 \u2264 k \u2264 \u03c9), some element 0 \u2208 A and\nsome permutation group G acting on A such that 0 is the unique fixed\npoint of every nonidentity member of G;\n(e) (A,F ) where |A| = 2 and F contains a semilattice operation;\n(f) a two-element algebra with an empty set of basic operations.\nIn the following theorem we determine all tractable finite strictly simple surjective\nalgebras by analyzing each of the cases listed in Theorem 6.2.\n5Note that the full idempotent reduct of a strictly simple surjective algebra is not always strictly\nsimple. Hence we obtain a slightly stronger result by classifying all strictly simple surjective algebras,\nrather than just the strictly simple idempotent algebras.\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 737\nTheorem 6.3. A finite strictly simple surjective algebra is NP-complete if all of\nits term operations are essentially unary. Otherwise it is tractable.\nProof. If A is an algebra of type (c) or (f), then all of its term operations are\nessentially unary. Hence Pol(Inv(Term(A))) contains essentially unary operations only,\nso A is NP-complete, by Proposition 2.27.\nIf A = (A,F ) is an algebra of type (a) or (a\u25e6), then we claim that the dual\ndiscriminator operation d(x, y, z) defined in Example 2.24 is a term operation of A.\nTo establish this claim, it is easy to verify that d preserves every relation of the form\n{(a, g(a)) | a \u2208 A} where g is a permutation on A. Since d is an idempotent operation,\nit belongs to both R(G) and Rid(G). Hence, in cases (a) and (a\u25e6), every relation in\nInv(F ) is invariant under d. It follows from Theorem 5.7 of [30] that CSP(Inv(F )) is\ntractable (see Example 2.24). Hence, in this case A is tractable.\nIf A is an algebra of type (b) or (b\u25e6), then the affine operation f(x, y, z) = x\u2212y+z\nis a term operation of A. Tractability of A then follows from Theorem 33 of [20] (see\nExample 3.7).\nNow let A = (A,F ) be an algebra of type (d) corresponding to some k with\n2 \u2264 k \u2264 \u03c9. Consider the operation f(x, y) defined as follows:\nf(x, y) =\n{\nx if x = y,\n0 otherwise.\nFirst, we show that f preserves any relation of the form g\u25e6 = {(a, g(a)) | a \u2208 A} where\ng \u2208 G. Let a = (a1, a2), b = (b1, b2) \u2208 g\u25e6. If a1 = b1, then a2 = g(a1) = g(b1) = b2,\nand, by definition of f , we have that the pair f(a, b) is equal to (a1, g(a1)) and hence\nbelongs to g\u25e6. If a1 \u0002= b1, then, since g is a permutation, a2 \u0002= b2 and the pair\nf(a, b) equals (0, 0), which also belongs to g\u25e6 because 0 is a fixed point of g. Hence\nf \u2208 Rid(G).\nNext, we show that f \u2208 F0k . Let a = (a1, . . . , ak), b = (b1, . . . , bk) \u2208 X0k ; that is,\neach of a, b contains 0. If, say, ai = 0, then f(ai, bi) = 0, so the tuple f(a, b) contains 0\nand hence belongs to X0k .\nWe have shown that f \u2208 Rid(G) \u2229 F0k , and hence f is a term operation of A. It\nis easy to check that f is a semilattice operation. By Theorem 16 of [29], this implies\nthat CSP(Inv(F )) is tractable (see Example 2.25). Hence, in this case A is tractable.\nFinally, if A is an algebra of type (e), then tractability again follows from Theo-\nrem 16 of [29].\n7. Toward a general classification. Theorem 6.3 gives a straightforward cri-\nterion to determine whether a finite strictly simple surjective algebra is tractable or\nNP-complete. In this section we examine what can be said about more general finite\nalgebras.\nTheorems 5.2 and 5.4 establish two separate necessary conditions for any finite\nalgebra to be tractable. We can combine these conditions by using the standard\nalgebraic notion of a factor [9].\nDefinition 7.1. A homomorphic image of a subalgebra of an algebra A is called\na factor of A. A factor whose universe contains only a single element is called a\ntrivial factor.\nCorollary 7.2. If A is a tractable finite algebra, then so is every factor of A.\nTheorems 5.2 and 5.4 also establish two separate sufficient conditions for any\nfinite algebra to be NP-complete. Using the notion of a factor, we can combine\nthese results, together with Proposition 2.27, to obtain a single sufficient condition\nfor NP-completeness.\n738 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nCorollary 7.3. A finite algebra A is NP-complete if it has a factor B all of\nwhose term operations are essentially unary.\nHowever, the condition described in Corollary 7.3 is not a necessary condition for\nan arbitrary algebra A to be NP-complete, as the next example shows.\nExample 7.4. Consider the algebra A = ({0, 1, 2, 3}, {d, f, p}), where d is a binary\noperation and f, p are unary operations, defined by the following tables:6\nd 0 1 2 3\n0 0 3 0 3\n1 2 1 2 1\n2 2 1 2 1\n3 0 3 0 3\nx f(x) p(x)\n0 1 1\n1 0 0\n2 3 2\n3 2 3\nSince f(0) = 1, any subalgebra of A containing 0 also contains 1. Furthermore,\nsince f(1) = 0, any subalgebra containing 1 also contains 0. Similarly, any subalgebra\ncontaining one of 2, 3 also contains the other. Finally, since d(0, 1) = 3 and d(2, 3) = 1,\nit follows that the only subalgebra of A is A itself.\nNow let \u03c6 be a homomorphism of A. If \u03c6(0) = \u03c6(1), then\n\u03c6(2) = \u03c6(d(1, 0)) = d(\u03c6(1), \u03c6(0)) = d(\u03c6(0), \u03c6(0)) = \u03c6(0), and\n\u03c6(3) = \u03c6(d(0, 1)) = d(\u03c6(0), \u03c6(1)) = d(\u03c6(0), \u03c6(0)) = \u03c6(0),\nso \u03c6 maps all the elements of A to a single element. Furthermore, if \u03c6(0) = \u03c6(2), then\n\u03c6(0) = \u03c6(2) = \u03c6(p(2)) = p(\u03c6(2)) = p(\u03c6(0)) = \u03c6(p(0)) = \u03c6(1),\nand we get the previous case. In all other cases a similar proof shows that if \u03c6 is not\ninjective, then it maps all the elements of A to a single element.\nHence we have shown that the only nontrivial factor of A is A itself, and clearly\nnot all the operations of A are essentially unary.\nHowever, we will now show that A is NP-complete. (Note that this does not\ncontradict Theorem 6.3 because A is not surjective.) To establish this, consider the\nternary relation \u03c1, consisting of 36 tuples, defined as follows (where tuples are written\nas columns):\n\u03c1 =\n\u239b\n\u239d0 0 0 3 3 3 0 0 0 3 3 3 1 1 1 2 2 2 1 1 1 2 2 2 1 1 1 2 2 2 0 0 0 3 3 30 3 3 0 0 3 1 1 2 1 2 2 0 0 3 0 3 3 1 2 2 1 1 2 0 0 3 0 3 3 1 1 2 1 2 2\n1 1 2 1 2 2 0 3 3 0 0 3 0 3 0 3 0 3 0 0 3 0 3 3 1 2 2 1 1 2 1 2 1 2 1 2\n\u239e\n\u23a0 .\nIt is straightforward to verify that this relation is invariant under the operations d, f ,\nand p. However, if we set h(x) = d(f(x), p(x)), then h(\u03c1) = N , where N is the relation\ndefined in Example 2.28, and hence {h(\u03c1)} is NP-complete. By Proposition 4.2, it\nfollows that {\u03c1} is NP-complete, and hence A is NP-complete.\nOn the other hand, it was shown in Theorem 6.3 that the condition described in\nCorollary 7.3 is both necessary and sufficient for a finite strictly simple surjective alge-\nbra to be NP-complete (assuming that P \u0002= NP). Furthermore, all previously known\nforms of NP-complete constraint satisfaction problems (see [46, 52]) can be shown\nto be NP-complete using Corollary 7.3. Hence, we conjecture that the condition de-\nscribed in Corollary 7.3 is both necessary and sufficient for NP-completeness for any\n6This algebra is, in fact, the matrix square [42] of ({0, 1};\u2212), where \u2212 denotes the negation.\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 739\nfinite surjective algebra. We state this conjecture for the special case of idempotent\nalgebras, where the only essentially unary operations are projections.\nConjecture 7.5 (\u201ctractable algebras conjecture\u201d). A finite idempotent algebra\nA is NP-complete if it has a nontrivial factor B all of whose operations are projec-\ntions. Otherwise it is tractable.\nAs shown in sections 2\u20134, the problem of determining the complexity of an ar-\nbitrary constraint language can be reduced to an equivalent problem for a certain\nidempotent algebra associated with the language. Therefore, this conjecture, if true,\nwould solve all the various forms of the \u201ctractability problem\u201d mentioned above, in-\ncluding the original problem for arbitrary constraint languages, Problem 2.12.\nThe next examples show that Conjecture 7.5 is confirmed in a number of special\ncases, by existing dichotomy results. Moreover, we will show that in each case the\nexisting dichotomy result can be obtained as a simple consequence of Conjecture 7.5.\nExample 7.6. A dichotomy theorem for two-element algebras was given in Corol-\nlary 3.5. In this example we will show that this result is equivalent to Conjecture 7.5\nrestricted to two-element algebras.\nLet A be a two-element algebra.\nIf A is idempotent, then Corollary 3.5 implies that either A is tractable, or else it\nis NP-complete and all of its operations are projections. Hence Corollary 3.5 implies\nthat Conjecture 7.5 holds for any two-element algebra.\nConversely, we will now establish that Conjecture 7.5 implies Corollary 3.5. If\nA is not surjective, then it has a nonsurjective unary term operation, which must\nbe constant, and hence A is tractable, by Theorem 4.4. On the other hand, if A\nis surjective, then by Theorem 4.7 we can consider its full idempotent reduct, A0.\nAssuming Conjecture 7.5 holds for any two-element algebra, we have that either A0 is\ntractable or else it is NP-complete and every operation of A0 is a projection. If every\noperation of A0 is a projection, then we claim that every operation of A must be\nessentially unary. To establish this claim, let f be any term operation of A. Since A\nis surjective, the unary term operation g(x) = f(x, x, . . . , x) must be a permutation.\nNow let h be the composition of the inverse permutation g\u22121 and f . It is easy to\ncheck that h is an idempotent term operation of A and hence is an operation of A0. If\nh is a projection, then f must depend on only one of its arguments, which establishes\nthe claim. Hence, we have shown that either A is tractable, or else every operation\nof A is essentially unary, which establishes that Conjecture 7.5 implies Corollary\n3.5.\nExample 7.7. A dichotomy theorem for constraint languages on a three-element\nset was given as Theorem 4 of [3]. This result is stated in a very similar form to\nConjecture 7.5, and is easily shown to be equivalent to this conjecture restricted to\nthree-element algebras.\nExample 7.8. A constraint language containing all unary relations is called a\nconservative constraint language [5]. (One example of a problem with a conservative\nconstraint language is the List H-Colorability problem, defined in [19].)\nIt was shown in Theorem 4 of [5] that, for any conservative constraint language\n\u0393 on a finite set A, either \u0393 is tractable, or else there exists some two-element subset\nB \u2286 A, such that for every polymorphism f of \u0393, f |B is a projection. In this example\nwe will show that this result is equivalent to Conjecture 7.5 restricted to algebras\nwhose operations preserve all unary relations.\nLet A = (A,F ) be any finite algebra such that the set of relations \u0393 = Inv(F )\ncontains all unary relations. Since \u0393 contains every relation {(a)}, for each a \u2208 A, the\nalgebra A is idempotent. Furthermore, since \u0393 contains every relation {(a1), (a2)}, for\neach two-element subset B = {a1, a2} \u2286 A, it follows that each of the corresponding\n740 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\nalgebras B = (B,F |B) is a subalgebra of A.\nHence, by Theorem 4 of [5], either \u0393 is tractable, or else there exists some two-\nelement subalgebra B of A, all of whose operations are projections. Hence this result\nimplies that Conjecture 7.5 holds for any algebra whose operations preserve all unary\nrelations.\nConversely, to show that Conjecture 7.5 implies Theorem 4 of [5], assume that\nConjecture 7.5 holds for the algebra A. This implies that either \u0393 is tractable, or else\nthere exists some nontrivial factor C of A all of whose operations are projections. In\nthe latter case, by the definition of a factor, C must be the image of some subalgebra B\nof A under some homomorphism \u03d5. Choose elements a1, a2 \u2208 B such that their images\n\u03d5(a1), \u03d5(a2) in C are distinct. Since every two-element subset of A is a subalgebra, for\nany f \u2208 F we have that f |{a1,a2} has range {a1, a2}. Furthermore, the corresponding\noperation f \u2032 of C is a projection, so we have that for any tuple a over {a1, a2}, the tuple\n\u03d5(f(a)) = f \u2032(\u03d5(a)) = the ith component of \u03d5(a) for some i. Hence f |{a1,a2} is also a\nprojection, and we have shown that Conjecture 7.5 implies Theorem 4 of [5].\nFinally, we note that if Conjecture 7.5 is true, then it yields an effective procedure\nto determine whether any finite constraint language is tractable or NP-complete, as\nthe following result indicates.\nProposition 7.9. Let A be a finite set. If Conjecture 7.5 is true, then for any\nfinite constraint language \u0393 over A, it is possible to determine in polynomial time in\nthe size of \u0393 whether \u0393 is NP-complete or tractable.\nProof. First set \u0393\u2032 = f(\u0393) \u222a \u0393con, where f is a unary polymorphism of \u0393 whose\nrange f(A) = U is minimal and \u0393con = {{(a)} | a \u2208 U}. (Note that the number of\npossible unary operations depends only on |A|, so \u0393\u2032 can be obtained in polynomial\ntime in the size of \u0393.) By Proposition 4.2 and Corollary 4.8, \u0393 is NP-complete if and\nonly if \u0393\u2032 is NP-complete, and \u0393 is tractable if and only if \u0393\u2032 is tractable.\nBy Corollary 2.17 and Proposition 2.21, \u0393 is NP-complete if and only if the\nidempotent algebra A = (U,Pol(\u0393\u2032)) is NP-complete, and \u0393 is tractable if and only\nif A is tractable. By Conjecture 7.5, A is NP-complete if it has a nontrivial factor B\nwhose operations are all projections; otherwise it is tractable.\nAssume first that A does have a nontrivial factor B whose operations are all\nprojections, and let B be the homomorphic image of the subalgebra A\u2032 of A under the\nhomomorphism \u03d5. We may assume, without loss of generality, that the universe of B\ncontains the set {0, 1}. The ternaryNP-complete relationN , defined in Example 2.28,\nis preserved by all operations of B, so the ternary relation R = \u03d5\u22121(N) is preserved\nby all operations of A\u2032 and hence by all operations of A. By Proposition 2.21, this\nimplies that R \u2208 \u3008\u0393\u2032\u3009.\nConversely, assume that R = \u03d5\u22121(N) \u2208 \u3008\u0393\u2032\u3009, where \u03d5 is an arbitrary unary\nfunction from some subset A\u2032 of U onto {0, 1}. By Proposition 2.21, R is preserved by\nall operations of A, and hence A\u2032 is the universe of a subalgebra A\u2032 of A. Furthermore,\nthe relation \u03d5\u22121(={0,1}) = \u2203zR(x, z, z) \u2227 R(y, z, z) \u2208 \u3008\u0393\u2032\u3009. Using standard algebraic\nresults (see Theorem 1.16 of [42]), this implies that \u03d5 is a homomorphism from A\u2032 to\na two-element factor B of A whose operations preserve N . Moreover, B is idempotent,\nso all its operations are projections.\nIt follows that \u0393 is NP-complete if there is a relation R \u2208 \u3008\u0393\u2032\u3009 where R is of the\nform \u03d5\u22121(N) for some unary function \u03d5 from some subset of A onto {0, 1}, and in all\nother cases \u0393 is tractable. By Proposition 1.1.19 of [48], the presence of any relation\nR in \u3008\u0393\u2032\u3009 can be determined by checking whether R is preserved by all polymorphisms\nof \u0393\u2032 of arity bounded by |R| (see [26] for an explicit construction). Since the number\nof possible unary functions \u03d5 is less than 3|A|, and each |R| \u2264 |A|3, this condition can\nbe checked in polynomial time in the size of \u0393, for any fixed finite set A.\nCLASSIFYING THE COMPLEXITY OF CONSTRAINTS 741\nAcknowledgments. The authors thank Victor Dalmau for reporting the re-\nsult concerning idempotent reducts and for some comments simplifying the proof of\nTheorem 6.3, and David Cohen for drawing our attention to Corollary 4.9.\nREFERENCES\n[1] W. Bibel, Constraint satisfaction from a deductive viewpoint, Artificial Intelligence, 35 (1988),\npp. 401\u2013413.\n[2] M. Bodirsky and J. Nes\u02c7etr\u02c7il, Constraint satisfaction with countable homogeneous templates,\nin Proceedings of Computer Science Logic and the 8th Kurt Go\u00a8del Colloquium, Lecture\nNotes in Comput. Sci. 2803, Springer-Verlag, Berlin, 2003, pp. 44\u201357.\n[3] A. Bulatov, A dichotomy theorem for constraints on a three-element set, in Proceedings of\nthe 43rd IEEE Symposium on Foundations of Computer Science (FOCS\u201902), Vancouver,\nBC, Canada, 2002, pp. 649\u2013658.\n[4] A. Bulatov, Mal\u2019tsev Constraints Are Tractable, Tech. report PRG-RR-02-05, Computing\nLaboratory, University of Oxford, Oxford, UK, 2002.\n[5] A. Bulatov, Tractable conservative constraint satisfaction problems, in Proceedings of the\n18th IEEE Symposium on Logic in Computer Science (LICS\u201903), Ottawa, ON, Canada,\nIEEE Press, 2003, pp. 321\u2013330.\n[6] A. Bulatov and P. Jeavons, Tractable Constraints Closed under a Binary Operation, Tech.\nreport PRG-TR-12-00, Computing Laboratory, University of Oxford, Oxford, UK, 2002.\n[7] A. Bulatov, A. Krokhin, and P. Jeavons, The complexity of maximal constraint languages,\nin Proceedings of the 33rd ACM Symposium on Theory of Computing (STOC\u201901), 2001,\npp. 667\u2013674.\n[8] D. Cohen, P. Jeavons, P. Jonsson, and M. Koubarakis, Building tractable disjunctive con-\nstraints, J. ACM, 47 (2000), pp. 826\u2013853.\n[9] P. Cohn, Universal Algebra, Mathematics and Its Applications 6, D. Reidel, Dordrecht, The\nNetherlands, Boston, 1981.\n[10] M. Cooper, D. Cohen, and P. Jeavons, Characterising tractable constraints, Artificial Intel-\nligence, 65 (1994), pp. 347\u2013361.\n[11] N. Creignou, S. Khanna, and M. Sudan, Complexity Classifications of Boolean Constraint\nSatisfaction Problems, SIAM Monogr. Discrete Math. Appl. 7, SIAM, Philadelphia, 2001.\n[12] V. Dalmau, A new tractable class of constraint satisfaction problems, in Proceedings of the\n6th International Symposium on Artificial Intelligence and Mathematics, 2000.\n[13] V. Dalmau, Constraint satisfaction problems in non-deterministic logarithmic space, in Pro-\nceedings of the 29th International Colloquium on Automata, Languages and Programming\n(ICALP\u201902), Lecture Notes in Comput. Sci. 2380, Springer-Verlag, Berlin, 2002, pp. 414\u2013\n425.\n[14] V. Dalmau and J. Pearson, Set functions and width 1 problems, in Proceedings of the 5th\nInternational Conference on Constraint Programming (CP\u201999), Lecture Notes in Comput.\nSci. 1713, Springer-Verlag, Berlin, 1999, pp. 159\u2013173.\n[15] R. Dechter and J. Pearl, Network-based heuristics for constraint satisfaction problems,\nArtificial Intelligence, 34 (1988), pp. 1\u201338.\n[16] K. Denecke and S. Wismath, Universal Algebra and Applications in Theoretical Computer\nScience, Chapman and Hall\/CRC Press, Boca Raton, FL, 2002.\n[17] T. Drakengren and P. Jonsson, A complete classification of tractability in Allen\u2019s algebra\nrelative to subsets of basic relations, Artificial Intelligence, 106 (1998), pp. 205\u2013219.\n[18] T. Feder, Constraint satisfaction on finite groups with near subgroups, submitted; available\nonline from http:\/\/theory.stanford.edu\/\u223ctomas\/near.ps.\n[19] T. Feder, P. Hell, and J. Huang, List homomorphisms and circular arc graphs, Combina-\ntorica, 19 (1999), pp. 487\u2013505.\n[20] T. Feder and M. Vardi, The computational structure of monotone monadic SNP and con-\nstraint satisfaction: A study through Datalog and group theory, SIAM J. Comput., 28\n(1998), pp. 57\u2013104.\n[21] M. Garey and D. Johnson, Computers and Intractability: A Guide to the Theory of NP-\nCompleteness, Freeman, San Francisco, 1979.\n[22] G. Gottlob, L. Leone, and F. Scarcello, A comparison of structural CSP decomposition\nmethods, Artificial Intelligence, 124 (2000), pp. 243\u2013282.\n[23] M. Gyssens, P. Jeavons, and D. Cohen, Decomposing constraint satisfaction problems using\ndatabase techniques, Artificial Intelligence, 66 (1994), pp. 57\u201389.\n[24] P. Hell and J. Nes\u02c7etr\u02c7il, On the complexity of H-coloring, J. Combin. Theory Ser. B, 48\n(1990), pp. 92\u2013110.\n742 ANDREI BULATOV, PETER JEAVONS, AND ANDREI KROKHIN\n[25] D. Hobby and R. McKenzie, The Structure of Finite Algebras, Contemp. Math. 76, AMS,\nProvidence, RI, 1988.\n[26] P. Jeavons, Constructing constraints, in Proceedings of the 4th International Conference on\nPrinciples and Practice of Constraint Programming, Lecture Notes in Comput. Sci. 1520,\nSpringer-Verlag, London, 1998, pp. 2\u201316.\n[27] P. Jeavons, On the algebraic structure of combinatorial problems, Theoret. Comput. Sci., 200\n(1998), pp. 185\u2013204.\n[28] P. Jeavons, D. Cohen, and M. Cooper, Constraints, consistency and closure, Artificial In-\ntelligence, 101 (1998), pp. 251\u2013265.\n[29] P. Jeavons, D. Cohen, and M. Gyssens, A unifying framework for tractable constraints,\nin Proceedings of the 1st International Conference on Constraint Programming (CP\u201995),\nLecture Notes in Comput. Sci. 976, Springer-Verlag, 1995, pp. 276\u2013291.\n[30] P. Jeavons, D. Cohen, and M. Gyssens, Closure properties of constraints, J. ACM, 44 (1997),\npp. 527\u2013548.\n[31] P. Jeavons, D. Cohen, and J. Pearson, Constraints and universal algebra, Ann. Math.\nArtificial Intelligence, 24 (1998), pp. 51\u201367.\n[32] P. Jeavons and M. Cooper, Tractable constraints on ordered domains, Artificial Intelligence,\n79 (1995), pp. 327\u2013339.\n[33] L. Kirousis, Fast parallel constraint satisfaction, Artificial Intelligence, 64 (1993), pp. 147\u2013160.\n[34] P. Kolaitis and M. Vardi, Conjunctive-query containment and constraint satisfaction, J.\nComput. System Sci., 61 (2000), pp. 302\u2013332.\n[35] A. Krokhin, P. Jeavons, and P. Jonsson, Reasoning about temporal relations: The tractable\nsubalgebras of Allen\u2019s interval algebra, J. ACM, 50 (2003), pp. 591\u2013640.\n[36] P. Ladkin and R. Maddux, On binary constraint problems, J. ACM, 41 (1994), pp. 435\u2013469.\n[37] S. Lang, Algebra, Grad. Texts in Math., Springer-Verlag, New York, 2002.\n[38] D. Lesaint, N. Azarmi, R. Laithwaite, and P. Walker, Engineering dynamic scheduler for\nwork manager, BT Technology J., 16 (1998), pp. 16\u201329.\n[39] A. Mackworth, Consistency in networks of relations, Artificial Intelligence, 8 (1977), pp.\n99\u2013118.\n[40] A. Mackworth, Constraint satisfaction, in Encyclopedia of Artificial Intelligence, Vol. 1,\nS. Shapiro, ed., Wiley Interscience, New York, 1992, pp. 285\u2013293.\n[41] A. Mackworth and E. Freuder, The complexity of constraint satisfaction revisited, Artificial\nIntelligence, 59 (1993), pp. 57\u201362.\n[42] R. McKenzie, G. McNulty, and W. Taylor, Algebras, Lattices and Varieties, Vol. I, Wads-\nworth & Brooks\/Cole Advanced Books & Software, Monterey, CA, 1987.\n[43] U. Montanari, Networks of constraints: Fundamental properties and applications to picture\nprocessing, Inform. Sci., 7 (1974), pp. 95\u2013132.\n[44] B. Nebel and H.-J. Bu\u00a8rckert, Reasoning about temporal relations: A maximal tractable\nsubclass of Allen\u2019s interval algebra, J. ACM, 42 (1995), pp. 43\u201366.\n[45] C. Papadimitriou, Computational Complexity, Addison\u2013Wesley, Reading, MA, 1994.\n[46] J. Pearson and P. Jeavons, A Survey of Tractable Constraint Satisfaction Problems, Tech.\nreport CSD-TR-97-15, Royal Holloway, University of London, London, 1997.\n[47] N. Pippenger, Theories of Computability, Cambridge University Press, Cambridge, UK, 1997.\n[48] R. Po\u00a8schel and L. Kaluz\u02c7nin, Funktionen- und Relationenalgebren, DVW, Berlin, 1979.\n[49] E. Post, The Two-Valued Iterative Systems of Mathematical Logic, Annals Mathematics Stud-\nies 5, Princeton University Press, Princeton, NJ, 1941.\n[50] L. Purvis and P. Jeavons, Constraint tractability theory and its application to the product de-\nvelopment process for a constraint-based scheduler, in Proceedings of the 1st International\nConference on the Practical Application of Constraint Technologies and Logic Program-\nming (PACLP\u201999), The Practical Application Company, Blackpool, UK, 1999, pp. 63\u201379.\n[51] J. Renz and B. Nebel, On the complexity of qualitative spatial reasoning: A maximal tractable\nfragment of the region connection calculus, Artificial Intelligence, 108 (1999), pp. 69\u2013123.\n[52] T. Schaefer, The complexity of satisfiability problems, in Proceedings of the 10th ACM Sym-\nposium on Theory of Computing (STOC\u201978), 1978, pp. 216\u2013226.\n[53] A. Szendrei, Clones in Universal Algebra, Se\u00b4minaire de Mathematiques Supe\u00b4rieures 99, Uni-\nversity of Montreal Press, Montreal, QC, Canada, 1986.\n[54] A. Szendrei, Simple surjective algebras having no proper subalgebras, J. Austral. Math. Soc.\nSer. A, 48 (1990), pp. 434\u2013454.\n[55] A. Szendrei, Term minimal algebras, Algebra Universalis, 32 (1994), pp. 439\u2013477.\n[56] P. van Beek and R. Dechter, On the minimality and decomposability of row-convex con-\nstraint networks, J. ACM, 42 (1995), pp. 543\u2013561.\n"}