{"doi":"10.1145\/290000","coreId":"63198","oai":"oai:kar.kent.ac.uk:21591","identifiers":["oai:kar.kent.ac.uk:21591","10.1145\/290000"],"title":"Restructuring the BLAS Level-1 Routine for Computing the Modified Givens Transformation","authors":["Hopkins, Tim"],"enrichments":{"references":[{"id":18321503,"title":"[ANS66] [DDDH90] ANSI. Programming Language Fortran X3.9-1966. American National Standards Institute,","authors":[],"date":"1966","doi":null,"raw":"[ANS66] [DDDH90] ANSI.  Programming  Language  Fortran  X3.9-1966.  American National  Standards Institute, New York,  1966.","cites":null},{"id":1104895,"title":"[ANS66\\] \\[DDDH90\\] ANSI. Programming Language Fortran X3.9-1966. American National Standards Institute,","authors":[],"date":"1966","doi":null,"raw":null,"cites":null},{"id":1104902,"title":"A complexity measure.","authors":[],"date":"1976","doi":"10.1109\/tse.1976.233837","raw":"T. J. McCabe.  A complexity measure.  IEEE Transactions  on Software Engineering, SE-2(4) :308-320,  1976.","cites":null},{"id":18321522,"title":"A critique of cyclomatic complexity as a software metric.","authors":[],"date":"1988","doi":"10.1049\/sej.1988.0003","raw":"M.  Shepperd.  A  critique of cyclomatic complexity as  a  software metric.  Software Engineering  Journal, 3:30-36, March 1988.","cites":null},{"id":1104904,"title":"A critique of cyclomatic omplexity as a software metric.","authors":[],"date":"1988","doi":"10.1049\/sej.1988.0003","raw":null,"cites":null},{"id":1104905,"title":"A critique of three metrics\u2022","authors":[],"date":"1994","doi":"10.1016\/0164-1212(94)90011-6","raw":"M. Shepperd and D. C. Ince. A critique of three metrics\u2022 J. Systems Software, 26:197-210,  1994.","cites":null},{"id":1104907,"title":"A measure to control flow complexity in program text.","authors":[],"date":"1979","doi":"10.1109\/tse.1979.226497","raw":"M. R. Woodward, M. A. Hennell, and D. Hedley. A measure to control flow complexity in program text.  IEEE Transactions  on Software Engineering,  SE-5(1):45-50,  1979. A  Fortran  90  Version of the  Restructured  Code MODULE  modified_givens_rotation !  ..  Generic  Interface  Blocks  .. INTERFACE  grotmg MODULE  PROCEDURE  srotmg MODULE  PROCEDURE  drotmg END  INTERFACE !  .. !  ..  Intrinsic  Functions  .. INTRINSIC  kind !  .. !  ..  Parameters  .. INTEGER,  PARAMETER  ::  clts  =  I INTEGER,  PARAMETER  ::  dp  =  kind(1.0D0) INTEGER,  PARAMETER  ::  error  =  2,  rescaled  =  -1,  sltc  =  0 INTEGER,  PARAMETER  ::  sp  =  kind(1.0E0) INTEGER,  PARAMETER  ::  unit_matrix  =  -2 !  \u2022  \u2022 !  ..  Derived  Type  Declarations  .. TYPE  ::  spgivensrotation INTEGER  ::  matrixtype REAL  (sp)  ::  rotation(2,2) END  TYPE  spgivensrotation TYPE  ::  dpgivensrotation INTEGER  ::  matrixtype REAL  (dp)  ::  rotation(2,2) END  TYPE  dpgivensrotation CONTAINS SUBROUTINE  srotmg(sdl,sd2,sxl,syl,sparam) ..  Structure  Arguments  .. TYPE  (spgivensrotation),  INTENT  (0UT)  ::  sparam ..  Scalar  Arguments  .. REAL  (sp),  INTENT  (INOUT)  ::  sdl,  sd2,  sxl REAL  (sp),  INTENT  (IN)  ::  syl ! !  ..  Local  Scalars  .. REAL  (sp),  SAVE  ::  gamsq,  rgamsq REAL  (sp)  ::  shll,  shl2,  sh21,  sh22,  spl,  sp2,  sql,  sq2,  stemp,  su INTEGER  ::  sflag !  \u2022  \u2022 II ..  Intrinsic  Functions  .. INTKINSIC  abs,  huge,  min,  reshape,  sqrt,  tiny ..  Parameters  .. REAL  (sp), PAKAMETEK  ::  one  =  1.0_sp REAL  (sp), PARAMETER  ::  quarter  =  0.25_sp KEAL (sp), PARAMETEK  ::  zero  =  0.0_sp !  .. !  ..  Dependents  .. KEAL  (sp),  SAVE  ::  gam =  zero !  .. t Set  the  value  of  gam,  gamsq,  rgamsq  on first  call  to  the ! routine.  These  values  are  dependent  on the  underlying ! floating-point  arithmetic  and  should  only  be  computed ! once. IF  (gam==zero)  THEN gamsq  =  min(huge(one),one\/tiny(one))*quarter gam  =  sqrt(gamsq) rgamsq  =  one\/gamsq END  IF NOTE:  sd2  is  allowed  to be negative  to  allow  for  row removal in  least  squares  problems Test  for  illegal  input  sdl<0  --  return  H  as  zero  matrix  with  sflag=-I Set  matrix  to  zero  for  error  exit IF  (sdl<zero)  THEN sdl  =  zero sd2  =  zero sxl  =  zero sflag  =  error Special  cases Input  vector  is  of  the  required  form  (c,O)  where  c  can be  zero Set  H  =  I ELSE  IF  (sd2==zero  .OK.  syl==zero)  THEN sflag  =  unit_matrix ! Input  vector  is  of  the  form  (0,c)  --  just  need  to  reverse  elements ! May need  to  scale  d2 dependent  values ELSE  IF  ((sdl==zero  .0R.  sxl==zero).AND,  sd2>zero)  THEN sflag  =  clts shl2  =  one sh21  =  -one shll  =  zero sh22  =  zero ! set  new  x  value  to  old y  value sxl  =  syl ! swap  d  values su =  sdl sdl  =  sd2 sd2  =  su ! Compute  required  bits  and pieces ELSE sp2  =  sd2*syl spl  =  sdl*sxl sq2  =  sp2*syl 12 sql  =  spl~sxl Dcl  >  Isl;  type  zero  matrix  (diagonal  elements  one) IF  (abs(sql)>abs(sq2))  THEN sflag  =sltc sh11  =  one sh22  =  one sh21  =  -syl\/sxl sh12  =  sp2\/sp1 su  =  one  -  shl2*sh21 If  su has  underflowed  --  sparam  has  already  been  set  --  exit IF  (su<=zero)  THEN sdl  =  zero sd2  =  zero sxl  =  zero sflag  =  error ELSE sdl  =  sdl\/su sd2  =  sd2\/su SXi  =  SXI~SU END  IF ELSE !  Isl  >=  Ici;  type  i  matrix  (antidiagonal  case) IF  (sq2<zero)  THEN sdl  =  zero sd2  =  zero sxl  =  zero sflag  =  error ELSE sflag  =  clts sh21  =  -one sh12  =  one shll  =  spl\/sp2 sh22  =  sxl\/syl ! No  possibility  of  underflow  since  sd2>0  if here su =  one  +  shll~sh22 stemp  =  sdl\/su sdl  =  sd2\/su sd2  =  stemp sxl  =  syl~su END  IF END  IF END  IF ! Scaling  may  be necessary  -- matrices  now become  type  -1 ' Scale  --  sdl IF  (sflag\/=error  .AND.  sflag\/=unit_matrix)  THEN DO  WHILE  (sdl<=rgamsq  .AND.  sdl\/=zero) sflag  =  rescaled sdl  =  (sdl~gam)~gam sxl  =  sxl\/gam shll  =  shll\/gam shl2  =  shl2\/gam 13 END D0 D0 WHILE  (sdl>gamsq) sflag =  rescaled sdl =  (sdllgam)\/gam sxl  =  sxl*gam shll  =  shll*gam sh12 =  sh12*gam END DO ! Scale  --  sd2 D0 WHILE  (abs(sd2)<=rgamsq  .AND.  sd2\/=zero) sflag =  rescaled sd2 =  (sd2*gam)*gam sh21  =  sh21\/gam sh22  :  sh22\/gam END DO D0 WHILE  (abs(sd2)>gamsq) sflag =  -one sd2 =  (sd21gam)Igam sh21  =  sh21*gam sh22 =  sh22*gam END D0 END  IF ! set  sparam array and exit SELECT  CASE  (sflag) CASE  (clts)  .;&quot; sparam =  spgivensrotation(clts,reshape((\/shll,-one,one,sh22\/),(\/2,2 I))) CASE  (sltc) sparam =  spgivensrotation(sltc,reshape((lone,sh21,shl2,onel),(12,21) )) CASE  (rescaled) sparam =  spgivensrotation(rescaled,reshape((\/shll,sh21,sh12,sh22\/), (12,21))) CASE  (unitmatrix) sparam = spgivensrotation(unit_matrix,reshape((\/one,zero,one,zero\/), (\/2,2\/))) CASE  (error) sparam =  spgivensrotation(error,reshape((\/zero,zero,zero,zero\/),(\/2, 2\/))) END SELECT END SUBROUTINE  srotmg ) Double  precision  subroutine  code omitted END MODULE modifiedgivensrotation","cites":null},{"id":1104896,"title":"Algorithm 679: A set of level 3 basic linear algebra subprograms.","authors":[],"date":"1990","doi":"10.1145\/77626.79170","raw":"J.  J.  Dongarra,  J.  Du  Croz, I.  S.  Duff,  and S.  Hammarling.  Algorithm 679:  A  set of level 3 basic linear algebra subprograms.  ACM Trans.  Math.  Softw.,  16(1):18-28, March 1990. [DDHH88] [HK87] [Hop96] [IEE85] [LH74] [LHKK79] [McC76] [Mye77] [NejS8] [Num92] [Po193] J.  J.  Dongarra, J. Du Croz, S. Hammarling, and R. J.  Hanson.  Algorithm 656: An extended set  of basic  linear algebra subprograms:  Model implementation and  test programs.  ACM Trans.  Math.  Soflw., 14(1):18-32,  March 1988.","cites":null},{"id":1104903,"title":"An extension to the cyclomatic measure of program complexity.","authors":[],"date":"1977","doi":"10.1145\/954627.954633","raw":"G. J. Myers. An extension to the cyclomatic measure of program complexity. Sigplan Notices, 12(10):61-64,  1977. B. A. Nejmeh. NPATH: A measure of execution path complexity and its applications.","cites":null},{"id":1104901,"title":"Basic linear algebra subprograms for Fortran usage.","authors":[],"date":"1979","doi":"10.1145\/355841.355847","raw":"C. L. Lawson, R. J.  Hanson, D.  R. Kincaid, and F. T.  Krogh.  Basic linear algebra subprograms for Fortran usage.  ACM Trans.  Math.  Softw., 5:308-323,  1979.","cites":null},{"id":1104906,"title":"Basic Linear Algebra Subroutines: A Quick Reference Guide,","authors":[],"date":"1992","doi":null,"raw":"University of Tennessee, Tennessee, US.  Basic  Linear Algebra Subroutines:  A  Quick Reference  Guide, June 1992.","cites":null},{"id":1104898,"title":"Restructuring software: A case study.","authors":[],"date":"1996","doi":"10.1002\/(sici)1097-024x(199608)26:8<967::aid-spe41>3.3.co;2-7","raw":"T.R. Hopkins.  Restructuring software:  A case study.  Software-Practice  and Experience, 26(8):967-982,  August 1996.","cites":null},{"id":1104900,"title":"Solving least squares problems.","authors":[],"date":"1974","doi":"10.1137\/1.9781611971217","raw":"C. L. Lawson and R. J. Hanson.  Solving least  squares problems.  Series  in automatic computation. Prentice-Hall, Englewood Cliffs, N.J., 1974.","cites":null},{"id":1104899,"title":"standard for binary floating-point arithmetic.","authors":[],"date":"1985","doi":"10.1109\/c-m.1981.220377","raw":"IEEE.  IEEE standard for binary floating-point arithmetic.  Institute of Electrical and Electronic Engineers, New York,  ANSI\/IEEE standard 754-1985 edition, 1985.","cites":null},{"id":1104897,"title":"Translation of Algorithm 539: PC-BLAS basic linear algebra subprograms for Fortran usage with the INTEL8087 80287 numeric data processor.","authors":[],"date":"1987","doi":"10.1145\/29380.214346","raw":"R.  J.  Hanson and F. T.  Krogh.  Translation of Algorithm 539: PC-BLAS basic linear algebra subprograms for Fortran usage with the INTEL8087 80287 numeric data processor.  A CM  Transactions  on Mathematical  Software,  13(3):311-317,  September 1987.","cites":null}],"documentType":{"type":0.8888888889}},"contributors":[],"datePublished":"1997-10","abstract":"We look at how both logical restructuring and improvements available from successive versions of Fortran allow us to reduce the complexity (measured by a number of the commonly used software metrics) of the Level 1 BLAS code used to compute the modified Givens transformation. With these reductions in complexity we claim that we have improved both the maintainability and clarity of the code; in addition, we report a fix to a minor problem with the original code. The performance of two commercial Fortran restructuring tools is also reported. \\ud\n\\u","downloadUrl":"https:\/\/core.ac.uk\/download\/pdf\/63198.pdf","fullTextIdentifier":"http:\/\/kar.kent.ac.uk\/21591\/1\/Restructuring_the_BLAS_Level_1_Routine_for_Computing_the.pdf","pdfHashValue":"8cdee8f9973ded1800dae0600292d30ceefa2d68","publisher":"ACM","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:kar.kent.ac.uk:21591<\/identifier><datestamp>\n      2011-09-06T03:59:29Z<\/datestamp><setSpec>\n      7374617475733D707562<\/setSpec><setSpec>\n      7375626A656374733D51:5141:51413736<\/setSpec><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D466163756C74696573:3132303030:3132323030:31323230302F36<\/setSpec><\/header><metadata><rioxx xmlns=\"http:\/\/www.rioxx.net\/schema\/v2.0\/rioxx\/\" xmlns:ali=\"http:\/\/ali.niso.org\/2014\/ali\/1.0\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:dcterms=\"http:\/\/purl.org\/dc\/terms\/\" xmlns:rioxxterms=\"http:\/\/docs.rioxx.net\/schema\/v2.0\/rioxxterms\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.rioxx.net\/schema\/v2.0\/rioxx\/ http:\/\/www.rioxx.net\/schema\/v2.0\/rioxx\/rioxx.xsd\" ><ali:free_to_read>\n    \n      <\/ali:free_to_read><dc:description>We look at how both logical restructuring and improvements available from successive versions of Fortran allow us to reduce the complexity (measured by a number of the commonly used software metrics) of the Level 1 BLAS code used to compute the modified Givens transformation. With these reductions in complexity we claim that we have improved both the maintainability and clarity of the code; in addition, we report a fix to a minor problem with the original code. The performance of two commercial Fortran restructuring tools is also reported. \\ud\n\\ud\n<\/dc:description><dc:format>application\/pdf<\/dc:format><dc:identifier>http:\/\/kar.kent.ac.uk\/21591\/1\/Restructuring_the_BLAS_Level_1_Routine_for_Computing_the.pdf<\/dc:identifier><dc:language>en<\/dc:language><dc:publisher>ACM<\/dc:publisher><dc:relation>http:\/\/delivery.acm.org\/10.1145\/290000\/289253\/p2-hopkins.pdf?key1=289253&key2=6799211521&coll=GUIDE&dl=GUIDE&CFID=48656758&CFTOKEN=58428998<\/dc:relation><dc:source>0163-5778 <\/dc:source><dc:subject>QA76<\/dc:subject><dc:title>Restructuring the BLAS Level-1 Routine for Computing the Modified Givens Transformation<\/dc:title><rioxxterms:apc>unknown<\/rioxxterms:apc><rioxxterms:author>Hopkins, Tim<\/rioxxterms:author><rioxxterms:project funder_name=\"notused\" >notused<\/rioxxterms:project><rioxxterms:publication_date>1997-10<\/rioxxterms:publication_date><rioxxterms:type>Journal Article\/Review<\/rioxxterms:type><rioxxterms:version>NA<\/rioxxterms:version><rioxxterms:version_of_record>http:\/\/dx.doi.org\/10.1145\/289251.289253<\/rioxxterms:version_of_record><\/rioxx><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/delivery.acm.org\/10.1145\/290000\/289253\/p2-hopkins.pdf?key1=289253&key2=6799211521&coll=GUIDE&dl=GUIDE&CFID=48656758&CFTOKEN=58428998"],"year":1997,"topics":["QA76"],"subject":["QA76"],"fullText":"Restructuring the BLAS Level 1 Routine for Computing the \nModified Givens Transformation \nT im Hopkins (trh@ukc.ac.uk) \nComput ing  Laboratory  \nUniversity of Kent \nCanterbury,  CT2 7NF \nKent,  UK. \nNovember 19, 1997 \nAbst ract  \nWe look at how both logical restructuring and improvements available from successive \nversions of Fortran allow us to reduce the complexity (measured by a number of the com- \nmonly used software metrics) of the Level 1 BLAS code used to compute the modified Givens \ntransformation. With these reductions in complexity we claim that we have improved both \nthe maintainability and clarity of the code; in addition, we report a fix to a minor problem \nwith the original code. The performance of two commercial Fortran restructuring tools is also \nreported. \n1 In t roduct ion  \nThe Level 1 BLAS [LHKK79], originally published in Fortran 66 [ANS66], implemented a number \nof common vector operations and were designed to be used as building blocks for linear algebra \nsoftware. Hopkins [Hop96] used knot counts [WHH79] and path counts [Nej88] to identify routines \nfrom the Level 1 BLAS which might benefit from code restructuring \nTwo sets of routines, *NRM2, used to compute the Euclidean orm of a vector and *ROTMG, for \ncomputing the modified Givens transformation, were identified as having Extremely high metric \nvalues given their relatively low number of executable statements. The restructuring ofthe *NRM2 \nroutines, along with a dramatic decrease in the metric values, was reported by Hopkins [Hop96]; \nthe *ROTMG routines are considered here. \nFollowing a brief description of the software metrics used to compare versions of the *ROTMG \nroutines, we present a fiowgraph of the published code and look at how two Fortran code restruc- \nturing tools fared on this original source. We then compare the metric values obtained for the \noriginal and automatically restructured code with hand-coded Fortran 66 and Fortran 77 versions. \nSection 5 looks at how the metric values may be reduced further by using Fortran 90 and we \nshow how the use of some of the new facilities available in Fortran 90 may be used to improve \nthese routines further. \nFinally we look briefly at the testing of the new routine and report a fix to a minor problem \nin the original code. \n2 Mod i f ied  G ivens  Rotat ion  Mat r ix  \nThe input values to *ROTMG, dl, d2, Xl and Yl, define a two-vector [al, a2] T in the partitioned form \nas \na2 0 d~ Yl \n2 \nThe routines then determine the Modified Givens Rotation Matrix, H, that transforms Yl and thus \na2 to zero. Details of the computation may be found in Appendix A of [LHKK79]. \nThe values of dl and d2 are scaled to ensure that they are kept within the limits \n1 \n< Idil _< 72 , i = 1,2; \n72 \nwhere the value of 7 was originally chosen to be 4096 for portability reasons; see \u00a75 for details of \nhow this value may be computed using the new Fortran 90 environment enquiry functions. On \noutput, the values of dl, d2 and xl are changed to represent the effect of the transformation while \nyl, which would be zeroed by the transformation, is left unchanged. \nIn the case where the input vector is already in the correct form, i.e., (c, O) T, no scaling of the \nvalues of dl and d2 takes place even if the input values are outside the limits given above. \nLawson and Hanson [LH74] detail the use of a negative value of d2 to implement row removal in \nleast squares procedures. The original code thus allows the value of d2 to be negative as suggested \nby equation (27.48) on page 230 of [LH74]. \n3 Sof tware  Met r i cs  \nWe use the following software metrics as indicators of how successful any restructuring we perform \nhas been; a slightly more detailed description may be found in [Hop96]. \n. \n2. \n. \nKnot count [WHH79]: a knot is defined to occur in a segment of code whenever the paths \nassociated with transfers of control intersect. The higher the number of knots in a piece of \ncode the more difficult the code will be to read, understand and maintain. As an example, \nwhen coding in Fortran 66 the lack of a block IF construction meant that the equivalent \ncode to implement a simple IF-THEN-ELSE construction required two GOT0 statements and \none knot. \nPath count: this is based on the metric proposed by Nejmeh [Nej88] and provides a lower \nbound on the number of distinct paths through a section of code. This measure gives an \nestimate of the amount of effort required to thoroughly test the code. Nejmeh suggests a\nmaximum value of 200 for any routine. \nCyclomatic Complexity [McC76]: this was one of the first software metrics to be proposed \nand is calculated as one more than the number of predicates in the code. It was originally \nproposed as a measure of testing effort although this has been questioned recently (see [She88] \nand [SI94] for details). This metric has been found to be largely unaffected by code restruc- \nturing and appears to be more successful as a measure of the underlying complexity of the \nalgorithm. A routine with a high cyclomatic omplexity value is thus generally considered \nto be in need of modularization. Myers [Mye77] suggests the use of a complexity interval \nwhose lower bound is the cyclomatic omplexity and whose upper bound is one more than \nthe total number of conditions. \nIn addition to these three metrics we also consider the number of executable statements and \nthe number of explicit GOT0 statements in the routine. \nAll the software metric values stated in this paper were generated using QAFortran version \n6.0 [Pro92]. \n4 For t ran  66 and For t ran 77 \nFor each of the 46 routines listed on the BLAS reference card [Uni92], Table 1 shows the number \nof executable lines of code Mong with the values of the three metrics defined above. Although con- \ntaining more executable statements than any of the other routines, the *ROTMG family of routines \n3 \nstands out as far as both knot and path counts are concerned. The high knot count of 104 in a \nroutine containing just 131 executable statements suggests that the code is likely to be extremely \ndifficult to understand and maintain. This fact is reinforced by Hanson and Krogh [HK87] where, \nin a paper detailing the translation of the Level BLAS into assembler, they state \nHere, the subprograms [SROTtlG and DROTMG] are provided in Fortran only, due to the \ncomplexity of their specification ... \nand by the control graph of the original code which is shown in Figure 1. \nRoutine \n*ROTG \n*ROTMG \n*ROT \n*ROTM \n*SWAP \n*SCAL \n*COPY \n*AXPY \n*DOT \n*DOTU \n*DOTC \n*xDOT \n*NRM2 \n*ASUM \nI*AMAX \nExec Cyclomatic Knot Path \nStat Interval Count Count \n22 5:6 2 16 \n121 18:18 92 98304 \n22 7:8 1 8 \n84 13:15 17 144 \n37 10:11 2 16 \n22 8:9 2 8 \n31 10:11 2 16 \n29 11:12 2 16 \n29 10:11 4 32 \n22 7:8 1 8 \n22 7:8 1 8 \n23 7:8 3 16 \n48 18:19 64 10240 \n22 8:9 4 8 \n22 8:9 3 8 \nTable 1: Metric Values for BLAS 1 Routines \nThe large number of possible paths through the routine, 196608, indicates that it will be \ndifficult to be confident hat the routine has been thoroughly tested. In addition the routine \ncontains 34 explicit GOT0 statements and 27 target labels. \nSpag [Po193], a software tool designed to improve the structure of Fortran 66 code by rearrang- \ning (and if necessary duplicating) statements and using Fortran 77 (or Fortran 90), produced some \nimprovement in the metric values when applied to this original code. The knot count was reduced \nby more than a half and the path count was reduced by a factor of almost a hundred to 2304. \nNag~struct [Num92], one of NAG's suite of Fortran 77 software tools, was unable to restructure \nthe code due to multiple-entry loops being detected. However, it should be noted that, even with \nwhat appear to be big reductions in the metric values, the code produced by Spag is hardly any \nmore comprehensible that the original. \nRestructuring the code from scratch was far more successful. Even using Fortran 66 it was \npossible to reduce the knot count to 35 and the path count to 4096. This version used 22 explicit \nGOT0 statements and contained 12 target labels. The cyclomatic omplexity came down from 19 \nto 13 which is very unusual in any restructuring exercise; this would seem to imply that there \nwere unnecessarily repeated tests taking place in the original code. \nBoth the commercial restructurers fared much better on this recoded Fortran 66 code, pro- \nducing Fortran 77 versions with both knot and path counts reduced. The path count reported by \nQAFortran for the Spag restructuring is optimistically low. This is due to Spag restructuring a \nsequence of four WHILE statements (constructed with pairs of IF and GOT0 statements) into a set \nof nested labelled IF statements with GOT0s. Since the path count metric used by QAFortran is \nunaffected by GOT0 statements his has the effect of reducing the path count from 242 to 36. \nThe large knot counts associated with the Spag and Nag_struct versions are due mainly to \nlong jumps out of nested block IFs. This may be avoided with Fortran 77 by more careful \nstructuring and, although the path count is somewhat higher, the knot count, the number of \n4 \n10 ~ ~ 7 -- 8 \nz \n3O \ns~ ~ \nFigure 1: Flowgraph of originally published code \nexplicit GOT{] statements and the number of labels are all reduced to four; all these are required \nfor the construction of the four WHILE loops. \nFigure 2 shows the flowgraph for the hand-coded Fortran 77 version of the routine and clearly \nshows the improvement in structure over the original. \n5 For t ran90 \nMoving to Fortran 90 allowed us to replace the last four labels, knots and GOT0 statements by \nfour D0 WHILE blocks. Another minor improvement to the code was the combination of a CASE \nstatement and structure constructors to simplify the setting of the output matrix before exit. In \naddition the new TYPE construction provided us with a cleaner version of the *PARAM argument. \nIn the original Fortran 66 code this parameter is a real array of length five. The first element \nis used as a flag to indicate the type of 2 \u00d7 2 Givens Rotation Matrix that is being returned in the \nother four elements. The rotation matrix is stored by columns. The original possibilities were \nunit matrix \nrescaled \nA6 \nA7 \n*PARAM \n1 2 3 4 5 \n-2  1 0 0 1 \n-1  hn  h21 hn  h22 \n0 1 h21 hi2 1 \n1 hn  1 -1  h22 \nwhere A6 and A7 refer to the equations given in the Appendix to [LHKK79] and only the elements \nshown as hij are actually set by the routine. In the case of an error in the input data, the returned \nmatrix is classified as rescaled and all elements are set to zero. \nFor the new Fortran 90 version of the code we defined the following type \nTYPE: : SpGivensRotat ion \nINTEGER : : Matr ixType \nREAL(sp) :: Rotat ion(2,2) \"\" \nEND TYPE SpGivensRotat ion \nand the integer parameter values \nINTEGER, PARAMETER :: c l t s= l ,  s l t c=0,  resca led=- l ,  \nun i t _matr ix=-2 ,  e r ror=2 \nwhich are the only names used to set the MatrixType component of Spg ivensRotat ion .  A new \nvalue of MatrixType, e r ror ,  was used to differentiate between a normally rescaled matrix and \nan error condition. We also set all four values of the rotation matrix whatever type of rotation \nmatrix is generated. A similar definition is made for the double precision case. \nSince Fortran 77 users have been provided with generic intrinsic functions, Fortran 90 allows \nsuch functionality in user defined routines. Thus another improvement we made was to produce \na generic version of the routine, GROTMG. Basically this involves providing an interface to the two \nroutines SROTMG and DROTMG with the system selecting the correct version based on the type of \nthe actual arguments. \nThe Fortran 90 version was also altered to provide a single point of exit from the routine. This \nallowed the CASE statement to set all the possible settings of the SpGivensRotat ion variable. The \nextra cost here was an IF guard to the block of WHILE statements. \nFinally, we use the newly introduced environment enquiry functions to set the value of 7 and \nhence the values used to determine the range of values for which scaling will take place. The value \nused for 72 is \nMIN (HUGE (0. O_wp), i. O_wp\/TINY (0. O_wp)) *0.25 \n6 \n~f  \nFigure 2: F lowgraph of recoded Fortran 66 code \nn \n50 \n100 \n200 \nIndy 4400 SC \nNag f90 (2.2 260) \nS M Mf90 \n0.1 0.1 0.1 \n0.7 0.8 0.9 \n10.0 9.9 10.7 \nSun Sparc LX \nEpc f90 (1.1.5.1) \nS M Mr90 \n3.0 2.7 2.0 \n19.1 17.2 11.5 \n157.4 130.8 75.9 \nDec Alpha WS200 \nDigital f90 (2.0-1) \nS M Mf90 \n0.1 0.2 0.2 \n0.3 0.3 0.4 \n5.8 5.9 6.0 \nTable 2: Comparison of standard Givens (S), Modified Givens (M) and the Fortran 90 generic \nversion of the Modified Givens (Mf90) to triangularize a 2n x n matrix using double precision. All \ntimes are in seconds. \nwhere wp is the working precision of the floating point arithmetic. For IEEE standard floating- \npoint arithmetic we obtain an exact representation for 7 of 262 (single precision) and 251\u00b0 (double \nprecision). These values mean that scaling occurs far less frequently than with the original code \nwhilst preserving numerical safety. \nA listing of part of the final Fortran 90 implementation is given in the appendix. \n6 Test ing  \nWhen restructuring any code it is imperative that the new version produces the same results as \nthe original, except, of course, where the original version was incorrect. We thus attempted to \ngenerate an exhaustive set of test data in order to be as confident as possible that all of the new \nversions we produced performed exactly as the original code. Note that, with the new settings for \nV, the Fortran 90 version will generate results which differ from those produced by the original \nFortran 66 code. \nThis exercise unearthed a minor error in the original code. For the input values xl, yl \u00a2 0, \ndl = 0 and d2 > 0 the original code returned the 'solution' \nH= -1  \nYl \nThis input data effectively generates an input vect\u00b0r \u00b0f the f\u00b0rm [ 0 ] whose correct ransfOrma- r \n01 1 ] and take place dependent the size of d2. tion matrix is H = _ 0 rescaling may upon \n. l  \nUsing the profiling tool from the NAG suite of tools [Num92] on the rewritten Fortran 77 code \nwe were able to check for statement coverage using our set of test data. It was found that all \nstatements were executed at least once with the exception of the GOT0 60 statement immediately \nbefore the statement labelled 30. In order to execute this statement the following two conditions \nneed to hold simultaneously \nI(dl \u00d7 xl) \u00d7 xll > I(d2 x Yl) \u00d7 Yll (1) \nand \n1-  \u00d7 (2) \nwhere the bracketing indicates the order in which the evaluations take place. It is obvious that \ncondition (2) can be true only if d2 < 0, additionally it would appear that we require some peculiar \ncombination of rounding errors to allow both conditions to hold. Using IEEE arithmetic [IEE85] \nwe have been unable to discover any set of input values which causes both conditions (1) and (2) \nto be true. \nFinally, we repeated the timing experiment, performed in [LHKK79], to compare the efficiency \nof the modified plane rotation, both in its original and Fortran 90 forms, with the standard \n8 \nCode Version \n1. original \n2. Spag on 1. \n3. nag_struct on 1. \n4. hand coded 1. \n5. Spag on 4. \n6. nag_struct on 4. \n7. hand coded 4. \n8. Fortran 90 \nLanguage Exec Knots Paths Cyc. Int. GOTO's  Labels \nf66 131 104 196608 19:20 34 27 \nf77 120 48 2304 17:18 20 11 \nf77 Not restructured ue to multiple-entry loop \nf66 103 35 4096 13:17 22 12 \nf77 105 30 361 13:17 8 6 \nf77 114 22 241 13:17 8 6 \nf77 113 4 336 13:17 4 4 \nf90 94 0 336 18:23 0 0 \nTable 3: Summary of code versions and associated metrics \nGivens transformation. Both techniques were used to triangularize 2n \u00d7 n matrices A = (ai j )  \nwhere a i j  = ( i  + j - 1)-1. \nTable 2 gives a sample of the cpu times obtained for a number of compiler\/platform combi- \nnations. Given the accuracy of the timing routines there is, for this particular problem, little or \nnothing to choose between the two methods for the majority of the compilers tested. This was \nespecially the case when high optimization levels were selected. The Edinburgh Portable Com- \npilers Fortran 90 compiler on the SUN Sparc LX did still show a gain from using the modified \nGivens method when full run time checking was switched on. The efficiency gains in this case are \ncomparable to those reported in [LHKK79]. \nThe effect of using the Fortran 90 generic version of the ROTgG routines was generally to increase \nthe execution times very marginally. \n7 Conc lus ion  \nWe have shown how the combination of the knot and path count software metrics along with their \nnumber of executable statements in a subroutine allowed old Fortran code, that was difficult to \nunderstand and test comprehensively, to be identified. Table 3 provides a summary of the various \nversions of the routine generated along with the associated metric values. \nThe hand-coded Fortran 66 version (code 4 in Table 3) was better structured than the code \nproduced by applying the Spag restructuring tool to the original code even though Spag's target \nlanguage was Fortran 77. This is reflected by the lower knot count although it should be noted \nthat the path count is actually larger for code 4. \nApplying both restructurers to the hand-crafted version did produce a dramatic reduction in \nboth the path count and the number of explicit GOT0 statements used. The knot count remained \nhigh due mainly to a small number of long jumps out of deeply nested IF statements. This suggests \nthat code 4 was a logically clearer implementation of the algorithm than the original code. \nIn addition we would assert that the reduction in the path count can be translated into a \nsignificant saving in the effort required to produce adequate test data for the code. \nThe cyclomatic omplexity interval values are interesting; it is very rare that this value is \nreduced by code restructuring. Indeed Shepperd & Ince [SI94] state that cyclomatic omplexity \nis insensitive to the structure of the software. This implies that some of the tests in the original \ncode are either repeated or unnecessary. The higher interval associated with the Fortran 90 code \nincludes the extra test needed to set the value of V and a small number of repeated tests (within \nthe CASE statement) required to generate a consistent return strategy. \nIn the case of 'dusty deck' Fortran 66 code, automatic restructurers may be able to reduce both \nthe knot and path counts although the extent to which they are successful is very dependent on \nthe way in which the original code was structured. It is worth noting here that the metrics do not \nalways, in themselves, completely reflect improvements; applying Spag to the original code led to \na significant reduction in the metric values although the resultant code was still as impenetrable. \n1 Optimistically ow - see section 4 for details \n9 \nAn analysis of the knot and path counts for the 96 Level 2 and Level 3 BLAS ([DDHH88] \nand [DDDH90]) both developed in Fortran 77, reveals no knots and a maximum path count of \n6912 for a 140 line routine. These routines generally contain more executable statements han \nthe Level 1 routines. However the path and knot counts indicate that they are likely to be easier \nto understand and test than several of the shorter BLAS Level 1 routines. This would suggest \nthat using a combination of number of executable statements with path and knot counts may be \nhelpful in identifying code that is likely to be difficult o understand and maintain. \n8 Acknowledgements \nThanks to Richard Hanson who kindly read a draft of this paper in super quick time and made \nsome very useful comments. In particular, the use of the machine nquiry functions to set GAMSQ \nwas his idea. \nReferences \n[ANS66] \n[DDDH90] \nANSI. Programming Language Fortran X3.9-1966. American National Standards \nInstitute, New York, 1966. \nJ. J. Dongarra, J. Du Croz, I. S. Duff, and S. Hammarling. Algorithm 679: A set \nof level 3 basic linear algebra subprograms. ACM Trans. Math. Softw., 16(1):18-28, \nMarch 1990. \n[DDHH88] \n[HK87] \n[Hop96] \n[IEE85] \n[LH74] \n[LHKK79] \n[McC76] \n[Mye77] \n[NejS8] \n[Num92] \n[Po193] \nJ. J. Dongarra, J. Du Croz, S. Hammarling, and R. J. Hanson. Algorithm 656: An \nextended set of basic linear algebra subprograms: Model implementation a d test \nprograms. ACM Trans. Math. Soflw., 14(1):18-32, March 1988. \nR. J. Hanson and F. T. Krogh. Translation of Algorithm 539: PC-BLAS basic lin- \near algebra subprograms for Fortran usage with the INTEL8087 80287 numeric data \nprocessor. A CM Transactions on Mathematical Software, 13(3):311-317, September \n1987. \nT.R. Hopkins. Restructuring software: A case study. Software-Practice and Experi- \nence, 26(8):967-982, August 1996. \nIEEE. IEEE standard for binary floating-point arithmetic. Institute of Electrical and \nElectronic Engineers, New York, ANSI\/IEEE standard 754-1985 edition, 1985. \nC. L. Lawson and R. J. Hanson. Solving least squares problems. Series in automatic \ncomputation. Prentice-Hall, Englewood Cliffs, N.J., 1974. \nC. L. Lawson, R. J. Hanson, D. R. Kincaid, and F. T. Krogh. Basic linear algebra \nsubprograms for Fortran usage. ACM Trans. Math. Softw., 5:308-323, 1979. \nT. J. McCabe. A complexity measure. IEEE Transactions on Software Engineering, \nSE-2(4) :308-320, 1976. \nG. J. Myers. An extension to the cyclomatic measure of program complexity. Sigplan \nNotices, 12(10):61-64, 1977. \nB. A. Nejmeh. NPATH: A measure of execution path complexity and its applications. \nCommun. ACM, 31(2):188-200, 1988. \nNumerical Algorithms Group Ltd., Oxford, UK. NAGWare f77 Tools, second edition, \nSeptember 1992. \nPolyhedron Software, Oxford, UK. plusFORT, Revision B edition, 1993. \nl0 \n[Pro92] \n[She88] \n[SI94] \n[Uni92] \n[WHH79] \nProgramming Research Ltd, Hersham, Surrey\u2022 QA Fortran 6.0, 1992. \nM. Shepperd. A critique of cyclomatic omplexity as a software metric. Software \nEngineering Journal, 3:30-36, March 1988. \nM. Shepperd and D. C. Ince. A critique of three metrics\u2022 J. Systems Software, 26:197- \n210, 1994. \nUniversity of Tennessee, Tennessee, US. Basic Linear Algebra Subroutines: A Quick \nReference Guide, June 1992. \nM. R. Woodward, M. A. Hennell, and D. Hedley. A measure to control flow complexity \nin program text. IEEE Transactions on Software Engineering, SE-5(1):45-50, 1979. \nA Fortran 90 Version of the Restructured Code \nMODULE mod i f ied_g ivens_rota t ion  \n! .. Gener ic  Inter face Blocks .. \nINTERFACE grotmg \nMODULE PROCEDURE srotmg \nMODULE PROCEDURE drotmg \nEND INTERFACE \n! . .  \n! .. Intr ins ic  Funct ions .. \nINTRINSIC k ind \n! . .  \n! .. Parameters  .. \nINTEGER, PARAMETER :: clts = I \nINTEGER, PARAMETER :: dp = kind(1.0D0) \nINTEGER, PARAMETER :: error  = 2, rescaled = -1, sltc = 0 \nINTEGER, PARAMETER :: sp = kind(1.0E0) \nINTEGER, PARAMETER :: un i t_matr ix  = -2 \n! \u2022 \u2022 \n! .. Der ived Type Dec larat ions  .. \nTYPE :: spg ivensrotat ion  \nINTEGER :: matr ix type \nREAL (sp) :: rotat ion(2,2)  \nEND TYPE spg ivensrotat ion  \nTYPE :: dpg ivensrotat ion  \nINTEGER :: matr ix type \nREAL (dp) :: rotat ion(2,2)  \nEND TYPE dpg ivensrotat ion  \nCONTAINS \nSUBROUTINE srotmg(sd l ,sd2,sx l ,sy l ,sparam) \n.. Structure Arguments .. \nTYPE (spgivensrotat ion) ,  INTENT (0UT) :: sparam \n.. Scalar  Arguments  .. \nREAL (sp), INTENT (INOUT) :: sdl, sd2, sxl \nREAL (sp), INTENT (IN) :: syl \n! \n! .. Local  Scalars .. \nREAL (sp), SAVE :: gamsq, rgamsq \nREAL (sp) :: shll, shl2, sh21, sh22, spl, sp2, sql, sq2, stemp, su \nINTEGER :: s f lag \n! \u2022 \u2022 \nII \n.. In t r ins ic  Funct ions  .. \nINTKINSIC  abs, huge, min, reshape,  sqrt, t iny \n.. Parameters  .. \nREAL (sp), PAKAMETEK :: one = 1.0_sp \nREAL (sp), PARAMETER :: quarter  = 0 .25_sp \nKEAL (sp), PARAMETEK :: zero = 0.0_sp \n! . .  \n! .. Dependents  .. \nKEAL (sp), SAVE :: gam = zero \n! . .  \nt Set the va lue of gam, gamsq, rgamsq on f i rst  cal l  to the \n! rout ine.  These va lues are dependent  on the under ly ing  \n! f l oa t ing -po in t  ar i thmet ic  and shou ld  only be computed \n! once. \nIF (gam==zero) THEN \ngamsq = min(huge(one) ,one \/ t iny (one) )*quar ter  \ngam = sqrt(gamsq) \nrgamsq = one\/gamsq \nEND IF \nNOTE: sd2 is a l lowed to be negat ive  to a l low for  row removal  \nin least  squares prob lems \nTest  for  i l lega l  input sdl<0 -- return  H as zero matr ix  wi th s f lag=- I  \nSet mat r ix  to zero for  error  exit  \nIF (sdl<zero) THEN \nsdl = zero \nsd2 = zero \nsxl = zero \ns f lag = error  \nSpec ia l  cases \nInput  vector  is of the requ i red  fo rm (c,O) where c can be zero \nSet H = I \nELSE  IF (sd2==zero .OK. syl==zero) THEN \nsf lag = un i t _matr ix  \n! Input vector  is of the fo rm (0,c) -- just need to reverse  e lements  \n! May need  to scale d2 dependent  va lues \nELSE  IF ( (sd l==zero .0R. sx l==zero) .AND,  sd2>zero) THEN \nsf lag = clts \nshl2 = one \nsh21 = -one \nshl l  = zero \nsh22 = zero \n! set new x va lue to old y va lue \nsxl = syl \n! swap d va lues \nsu = sdl \nsdl = sd2 \nsd2  = su  \n! Compute  requ i red  bits  and p ieces \nELSE \nsp2 = sd2*syl  \nspl = sdl*sx l  \nsq2 = sp2*syl  \n12 \nsql = spl~sxl  \nDcl > Isl; type zero matr ix  (diagonal  e lements  one) \nIF (abs(sq l )>abs(sq2))  THEN \nsf lag =s l tc  \nsh11 = one \nsh22 = one \nsh21 = -sy l \/ sx l  \nsh12  = sp2\/sp1  \nsu  = one  - sh l2*sh21 \nIf su has under f lowed -- sparam has a l ready been set -- exit \nIF (su<=zero) THEN \nsdl = zero \nsd2 = zero \nsxl = zero \ns f lag = error  \nELSE \nsdl = sdl \/su \nsd2 = sd2\/su \nSXi = SXI~SU \nEND IF \nELSE \n! Isl >= Ici; type i matr ix  (ant id iagonal  case) \nIF (sq2<zero) THEN \nsdl = zero \nsd2 = zero \nsxl = zero \nsf lag = error  \nELSE \ns f lag = clts \nsh21 = -one \nsh12 = one \nshl l  = spl \/sp2 \nsh22 = sxl \/sy l  \n! No poss ib i l i ty  of under f low since sd2>0 if here \nsu = one + sh l l~sh22 \nstemp = sd l \/su  \nsdl = sd2\/su \nsd2 = stemp \nsxl = sy l~su \nEND IF \nEND IF \nEND IF \n! Sca l ing  may be necessary  -- matr ices  now become type -1 \n' Scale -- sdl \nIF (s f lag\/=error  .AND. s f lag\/=uni t_matr ix )  THEN \nDO WHILE  (sd l<=rgamsq .AND. sdl\/=zero) \ns f lag = resca led  \nsdl = (sd l~gam)~gam \nsxl = sx l \/gam \nshl l  = sh l l \/gam \nshl2 = sh l2 \/gam \n13 \nEND D0 \nD0 WHILE (sdl>gamsq) \nsflag = rescaled \nsdl = (sdllgam)\/gam \nsxl = sxl*gam \nshll = shll*gam \nsh12 = sh12*gam \nEND DO \n! Scale -- sd2 \nD0 WHILE (abs(sd2)<=rgamsq .AND. sd2\/=zero) \nsflag = rescaled \nsd2 = (sd2*gam)*gam \nsh21 = sh21\/gam \nsh22 : sh22\/gam \nEND DO \nD0 WHILE (abs(sd2)>gamsq) \nsflag = -one \nsd2 = (sd21gam)Igam \nsh21 = sh21*gam \nsh22 = sh22*gam \nEND D0 \nEND IF \n! set sparam array and exit \nSELECT CASE (sflag) \nCASE (clts) .;\" \nsparam = spgivensrotation(clts,reshape((\/shl l , -one,one,sh22\/),( \/2,2 \nI))) \nCASE (sltc) \nsparam = spgivensrotation(sltc,reshape(( lone,sh21,shl2,onel),(12,21) \n)) \nCASE (rescaled) \nsparam = spgivensrotation(rescaled,reshape((\/shl l ,sh21,sh12,sh22\/),  \n(12,21))) \nCASE (uni tmatr ix)  \nsparam = spgivensrotation(unit_matrix,reshape((\/one,zero,one,zero\/), \n( \/2,2\/)))  \nCASE (error) \nsparam = spgivensrotation(error,reshape((\/zero,zero,zero,zero\/),( \/2,  \n2\/))) \nEND SELECT \nEND SUBROUTINE srotmg \n) Double precision subroutine code omitted \nEND MODULE mod i f iedg ivensrota t ion  \n14 \n"}