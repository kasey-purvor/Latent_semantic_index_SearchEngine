{"doi":"10.1109\/LCOMM.2007.061780","coreId":"102583","oai":"oai:epubs.surrey.ac.uk:2070","identifiers":["oai:epubs.surrey.ac.uk:2070","10.1109\/LCOMM.2007.061780"],"title":"Gradient projection decoding of LDPC codes","authors":["Kasparis, C","Evans, BG"],"enrichments":{"references":[],"documentType":{"type":1}},"contributors":[],"datePublished":"2007-03-01","abstract":null,"downloadUrl":"","fullTextIdentifier":null,"pdfHashValue":null,"publisher":"IEEE-INST ELECTRICAL ELECTRONICS ENGINEERS INC","rawRecordXml":"<record><header><identifier>\n    \n    \n      oai:epubs.surrey.ac.uk:2070<\/identifier><datestamp>\n      2017-10-31T14:04:08Z<\/datestamp><setSpec>\n      74797065733D61727469636C65<\/setSpec><setSpec>\n      6469766973696F6E733D656E67616E64706879736963616C736369656E636573:656C656374726F6E6963656E67696E656572696E67:63637372<\/setSpec><\/header><metadata><oai_dc:dc xmlns:oai_dc=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/\" xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc\/ http:\/\/www.openarchives.org\/OAI\/2.0\/oai_dc.xsd\" ><dc:relation>\n    \n      \n        http:\/\/epubs.surrey.ac.uk\/2070\/<\/dc:relation><dc:title>\n        Gradient projection decoding of LDPC codes<\/dc:title><dc:creator>\n        Kasparis, C<\/dc:creator><dc:creator>\n        Evans, BG<\/dc:creator><dc:publisher>\n        IEEE-INST ELECTRICAL ELECTRONICS ENGINEERS INC<\/dc:publisher><dc:date>\n        2007-03-01<\/dc:date><dc:type>\n        Article<\/dc:type><dc:type>\n        PeerReviewed<\/dc:type><dc:format>\n        text<\/dc:format><dc:language>\n        en<\/dc:language><dc:identifier>\n        http:\/\/epubs.surrey.ac.uk\/2070\/1\/SRF002493.pdf<\/dc:identifier><dc:identifier>\n          Kasparis, C and Evans, BG  (2007) Gradient projection decoding of LDPC codes   IEEE COMMUNICATIONS LETTERS, 11 (3).  pp. 279-281.      <\/dc:identifier><dc:relation>\n        http:\/\/ieeexplore.ieee.org\/xpls\/abs_all.jsp?arnumber=4133922<\/dc:relation><dc:relation>\n        10.1109\/LCOMM.2007.061780<\/dc:relation><dc:language>\n        English<\/dc:language><\/oai_dc:dc><\/metadata><\/record>","journals":null,"language":{"code":"en","id":9,"name":"English"},"relations":["http:\/\/epubs.surrey.ac.uk\/2070\/","http:\/\/ieeexplore.ieee.org\/xpls\/abs_all.jsp?arnumber=4133922","10.1109\/LCOMM.2007.061780"],"year":2007,"topics":[],"subject":["Article","PeerReviewed"],"fullText":"IEEE COMMUNICATIONS LETTERS, VOL. 11, NO. 3, MARCH 2007 279\nGradient Projection Decoding of LDPC Codes\nChristos Kasparis and Barry G. Evans\nAbstract\u2014 A new practical method for decoding Low-Density\nParity Check (LDPC) codes is presented. The followed approach\ninvolves reformulating the parity check equations using non-\nlinear functions of a specific form, defined over \u0001\u03c1, where \u03c1\ndenotes the check node degree. By constraining the inputs to\nthese functions in the closed convex subset [0, 1]\u03c1 (\u201cbox\u201d set) of\n\u0001\u03c1, and also by exploiting their form, a multimodal objective\nfunction that entails the code constraints is formulated. The\ngradient projection algorithm is then used for searching for a\nvalid codeword that lies in the vicinity of the channel observation.\nThe computational complexity of the new decoding technique is\npractically sub-linearly dependent on the code\u2019s length, while\nprocessing on each variable node can be performed in parallel\nallowing very low decoding latencies. Simulation results show\nthat convergence is achieved within 10 iterations, although some\nperformance degradations relative to the Belief Propagation (BP)\nalgorithm are observed.\nIndex Terms\u2014 LDPC, decoding, non-linear, gradient, projec-\ntion.\nI. INTRODUCTION\nTHE rediscovery of Low Density Parity Check (LDPC)codes1 by MacKay and Neal [2,3] (as a class of error cor-\nrecting codes that achieve near Shannon-bound performances\nand allow manageable decoding complexities), has sparked\nresearch interest towards new powerful and efficiently encod-\nable LDPC codes (e.g. [8]), and also towards new decoding\nalgorithms with attractive performance-complexity features.\nWith increasing numbers of practical communication systems\nemploying LDPC codes, the search for efficient codes and\ndecoding algorithms still attracts significant research interest.\nThe current paper addresses the latter topic.\nFocusing on existing types of decoding algorithms, the\nBelief Propagation (BP) algorithm [1,3,4] is an iterative\ntechnique for computing (approximate) marginal posterior\nprobabilities, in which messages in the form of conditional\nprobabilities are exchanged between variable and check nodes\non the code\u2019s Tanner graph. The BP algorithm achieves best er-\nror performances amongst other practical decoding algorithms,\nalthough it also involves higher computational complexity.\nReduced complexity variations of the BP [5-7] offer trade-\noffs between performance and computational requirements. A\nlow complexity Bit Flipping (BF) decoding algorithm was also\nproposed by Gallager [1], in which the most unreliable bits,\nclassified in terms of the number of associated parity check\nfailures, are flipped. Various improved performance variations\nManuscript received October 31, 2006. The associate editor coordinating\nthe review of this letter and approving it for publication was Dr. Vladimir\nStankovic.\nThe authors are with the Centre for Communication Systems Re-\nsearch, University of Surrey, Guildford, GU2 7XH, Surrey, UK (e-mail:\nc.kasparis@surrey.ac.uk).\nDigital Object Identifier 10.1109\/LCOMM.2007.061780.\n1Originally discovered by Gallager in 1962 ([1])\nof the BF algorithm have been reported in [8,9]. A third\ndecoding approach based on linear programming has been\nrecently proposed in [10] and explored further in [11].\nIn this letter a new approach is followed in order to\ndevelop a decoding algorithm that is fundamentally different\nto any of the existing types. The central element in the\nproposed algorithm is the non-linear function f(x1, x2) =\nx1 + x2 \u2212 2x1x2 which is equivalent to addition over\nGF(2), when x1, x2\u0001{0, 1}. This basic function is nested:\nf(..f(f(x1, x2), x3).., x\u03c1) in order to redefine individual par-\nity check equations over the closed convex set [0, 1]\u03c1 (instead\nof the binary finite field). This type of convex relaxation, com-\nbined with the particular form of the proposed non-linear func-\ntion, allows formulation of a multimodal objective function\nthat entails the code\u2019s constraints. Iterative algorithms, such\nas the Gradient Projection (GP) method [12,13], can then be\nused to search for a local minimum of the objective function,\nthat lies in the vicinity of the noisy channel observation.\nThe number of multiplications in the new algorithm (al-\nthough it is random - depending on the number of bits that\nhave converged to 0 and 1 values) in practice is sub-linearly\ndependent on the code\u2019s length, whilst convergence is typically\nachieved within 10 iterations. Furthermore processing on in-\ndividual variable nodes can be performed in parallel, allowing\nvery small processing latencies.\nSection II provides a detailed description of the proposed\nalgorithm, comments on its computational requirements and\nalso describes a \u2018denser\u2019 representation of the code, which\nprovides improved performance and faster convergence. Sec-\ntion III includes simulation results that give the performance\nand convergence speed of the algorithm on short (96,48) and\nmedium-length (504,252) regular systematic codes. Finally\nSection IV gives a summary and conclusions.\nII. GRADIENT PROJECTION DECODING ALGORITHM\nA. Basics and Notations\nAn (n, k) binary LDPC code is a linear block code that\nis characterized by a parity check matrix H (of dimensions\n(n \u2212 k) \u00d7 n) that has a low density of 1\u2019s. Depending on\nwhether the rows and the columns of H are populated by equal\nnumbers of 1\u2019s or not, the LDPC code is categorized as regular\nor irregular, respectively. An LDPC code can alternatively\nbe represented by a bipartite graph with two independent\nnode sets: I = {I1, .., In}, J = {J1, .., Jn\u2212k}, (\u2018variable\u2019 and\n\u2018check\u2019 nodes respectively) that correspond to the columns\nand rows of H. For convenience some Ii and Jj will hereon\nsimply denoted as i and j, respectively. Connections between\nthe two sets of nodes are determined by the corresponding\npositions of 1\u2019s on H. The \u2018neighbourhood\u2019 Nc(j) of check\nnode j\u0001J is the set of variable nodes connected to j, and\n1089-7798\/07$25.00 c\u00a9 2007 IEEE\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 16,2010 at 14:19:42 UTC from IEEE Xplore.  Restrictions apply. \n280 IEEE COMMUNICATIONS LETTERS, VOL. 11, NO. 3, MARCH 2007\nsimilarly the \u2018neighbourhood\u2019 Nv(i) of a variable node i\u0001I\nis the set of check nodes connected to i. In regular LDPC\ncodes the cardinalities (\u03c1j) of the check node neighbourhoods\n(commonly referred to as degrees) are equal for all j\u0001J , and\nthe same is true for all variable node degrees (\u03b3i). On the\nother hand, in irregular codes the variable and check node\ndegrees are functions of i and j, respectively.\nB. Decoding Algorithm\nAs briefly discussed in Section I, the proposed approach\ninvolves defining and minimizing an objective function that\ndescribes directly the m = n \u2212 k parity check equations\nthat a valid codeword needs to satisfy. Starting point in\nthe development of such objective function is the non-linear\nfunction\nf(x1, x2) = x1 + x2 \u2212 2x1x2 (1)\nwhich is equivalent to addition over GF(2), when\nx1, x2\u0001{0, 1}. It is not difficult to think of alternative\nfunctions that provide this equivalency, but (1) has a\nnumber of features that make it a good choice. The most\nsignificant of these features is its shape over the relaxed\nranges x1, x2\u0001[0, 1], which can be better appreciated from\nFig. 1; assuming an AWGN channel, if a valid (2-bits long)\ncodeword c had to satisfy the parity check c1 \u2295 c2 = 0,\nand the corresponding noisy observations y= [y1, y2] were\navailable, then a constraint gradient minimization of (1)\n(over [0, 1]2, and by setting (y1, y2) as the starting solution)\nwould converge to the valid solution closest to the channel\nobservation, in the Euclidian distance sense. Function (1)\ncan be generalized for more than two variables, in order to\ndescribe some jth parity check, by putting it into a nested\nform\nfj(x1, .., x\u03c1j ) = f(..f(f(x1, x2), x3).., x\u03c1j ) (2)\nUsing the fact that (2) is symmetric, in the sense that it remains\nunchanged by any permutation of its variables, an overall\nobjective function is formulated as\nF (x1, .., xn) = f1(Nc(1)) + .. + fm(Nc(m)) (3)\nA constraint local minimum on (3) that lies in the vicinity of\nthe channel observation can be searched using the iterative GP\nmethod [12,13], which consists of the iteration:\nc\u02c6l = PQ[c\u02c6l\u22121 \u2212 \u03b1\u2207F ] (4)\nwhere c\u02c6l is the estimated codeword at iteration l, PQ[.]\nsignifies the orthogonal projection operator on the convex set\n[0, 1]n and \u03b1 is a positive step parameter that influences the\nconvergence speed and the accuracy of the algorithm. Under\nthe particular set constraints each signal component can be\nupdated independently and in parallel [12]:\nc\u02c6il =\n\u23a7\u23aa\u23a8\n\u23aa\u23a9\n0, if c\u02c6il\u22121 \u2212 \u03b1 \u2202F\u2202ci < 0\nc\u02c6il\u22121 \u2212 \u03b1 \u2202F\u2202ci , if 0 \u2264 c\u02c6il\u22121 \u2212 \u03b1 \u2202F\u2202ci \u2264 1\n1, if c\u02c6il\u22121 \u2212 \u03b1 \u2202F\u2202ci > 1\n(5)\nFurthermore it can easily be shown, using the symmetric\nproperty of (2), that\n0 0.2 0.4\n0.6 0.8 10\n0.5\n1\n0\n0.2\n0.4\n0.6\n0.8\n1\nx1\nx2\nf(x\n1,\nx 2\n)=x\n1+\nx 2\n\u2212\n2x\n1x\n2\nFig. 1. Plot of the f = x1+ x2\u2212 2x1x2 function over the box set [0, 1]2.\n\u2202fj(x1, ., xi, ., x\u03c1j )\n\u2202xi\n= 1\u2212 2fj(x1, ., xi\u22121, xi+1, ., x\u03c1j ) (6)\nAssuming a regular LDPC code, it can be deduced from (6)\nthat the proposed decoding algorithm requires approximately\nn(\u03c1\u2212 2)\u03b3 real multiplications, 4n(\u03c1\u2212 2)\u03b3 real additions, and\nn \u2018clipping\u2019 operations per iteration. In practice the number\nof computations will be random, but significantly less than the\nabove figures; since from (1) it can be seen that no operations\nare needed if any of x1, x2 = 0 and only one real addition is\nneeded if any of x1, x2 = 1.\nBased on the above, the proposed decoding algorithm\ninvolves two main steps: a) Set c\u02c60 = PQ[y] and b) update\nindividual signal estimates using (5) for a maximum number\nof iterations or until all parity check equations are satisfied.\nC. Performance Improvements through Denser Parity Check\nRepresentation of the Code\nThe use of additional (redundant) higher-order parity\nchecks, although can result in short cycles on the code\u2019s\nTanner graph (and thus degrade the performance of the BP\nalgorithm), has been shown in [10] to improve the perfor-\nmance of the linear programming based decoder. Simulation\nresults, which are discussed in Section III, show that the\nperformance and convergence speed of the proposed decoding\nalgorithm improve just through a higher-order (denser) parity\ncheck representation of the code, i.e. not by using higher-order\nparity checks additionally to the first-order ones.\nIn order to limit the impact on the decoding complexity,\nonly a \u2018second-order\u2019 representation of the code has been\nconsidered. In particular, second-order parity checks have been\nconstructed by taking, for each i, the mod-2 summation of\nall possible pairs of first-order parity checks that belong in\nNv(i). Assuming a regular (\u03c1, \u03b3) LDPC code, the second-\norder representation yields a (2(\u03c1 \u2212 1), (\u03c1 \u2212 1)\u03b3(\u03b3 \u2212 1))\nequivalent code.\nIII. SIMULATION RESULTS\nThe performance of the proposed algorithm has been eval-\nuated on short (96,48) and medium-length (504,252) regular\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 16,2010 at 14:19:42 UTC from IEEE Xplore.  Restrictions apply. \nKASPARIS and EVANS: GRADIENT PROJECTION DECODING OF LDPC CODES 281\n1 2 3 4 5 6 7 8 9 10\n10\u22124\n10\u22123\n10\u22122\n10\u22121\nEb\/N0 (dB)\nBE\nR\nAWGN\nBP: 100 iter.\nLP: 200 iter.\nGP: 5 iter. \u2212 step =0.4\nGP: 8 iter. \u2212 step=0.2\nGP: 20 iter \u2212 step=0.05\nGP*: 6 iter \u2212 step=0.05\nFig. 2. Performance of proposed decoding algorithm on the (96,48) code.\nsystematic LDPC codes; both with \u03c1 = 6 and \u03b3 = 3. The\nresults for the (96,48) code are given in Fig. 2. The GP\ndecoder was tested for three choices of the step parameter:\n\u03b1 = 0.05, 0.2 and 0.4, and also with the second-order parity\ncheck representation of the code. It is observed that larger\nvalues of the step parameter lead to faster convergence, with a\nsmall penalty on the performance (\u223c 0.1dB), while the denser\nrepresentation of the code (denoted as GP\u2217 on the figure) gives\na performance benefit of about 0.2-0.3dB at BER=10\u22125. For\ncomparison, the BF algorithm proposed by Liu and Pados (LP)\n([9]) was also simulated. It is observed that the GP decoder\ngives a performance benefit of about 0.8-1dB, although it\nlags the performance of the BP by about the same margin\nat BER=10\u22125. It is also worth noting that in the GP decoder\nwith \u03b1 = 0.2 and Eb\/N0 = 6dB, on average (over the 8\niterations) 44 variables are converged to 0 and another 44 to\n1. Similarly, in the denser code representation example, on\naverage 42 variables are converged to 0 and another 42 to\n1. These experimental results give a good indication that the\ncomputational requirements of the GP decoder are in practice\nvery small.\nFigure 3 gives the results for the (504,252) code. It is\nobserved that on this code the performance gap between the\nBP and the GP decoder is wider: about 2.5dB at BER=10\u22125,\nalthough the GP decoder still has a performance advantage\n(about 0.5dB at BER=10\u22125) relative to the LP decoder. The\nsecond-order representation of the code yields a 0.5dB benefit\n(at BER=10\u22125), and also faster convergence. In this code\nexample the average number of variables converged to 0 and 1\nin the GP decoder, is 235.15 for both signal values, and 215.9\nwith the denser code representation.\nIV. CONCLUSION\nA new type of decoding algorithm for LDPC codes has\nbeen proposed, which is based on the local minimization of\na multi-modal non-linear objective function that entails the\ncode constraints. A valid codeword in the vicinity of the\nnoisy channel observation is searched by the GP method,\nwhich converges to a constraint minimum over the \u2018box\u2019\n(convex) set. The new decoding approach has computational\n1 2 3 4 5 6 7 8 9 10\n10\u22124\n10\u22123\n10\u22122\n10\u22121\nEb\/N0 (dB)\nBE\nR\nBP: 100 iter.\nAWGN\nLP: 200 iter.\nGP: 20 iter. \u2212 step=0.1\nGP*: 6 iter. \u2212 step=0.1\nFig. 3. Performance of proposed decoding algorithm on the (504,252) code.\nand implementation advantages (e.g. no noise statistics need\nto be estimated) relative to the BP algorithm, although the\nlatter provides better performance. Finally it is commented\nthat the proposed decoder, being based on different principles\nthan with existing types of decoders, opens a new research\npath on the decoding of LDPC codes.\nACKNOWLEDGMENT\nThe authors would like to acknowledge the FP6 European\nprojects MOWGLY and SatNEx2 for funding this work. The\nauthors would also like to thank Dr. Elias Gyftodimos from\nthe Computing Science Department, University of Aberdeen,\nfor his valuable comments and suggestions.\nREFERENCES\n[1] R. G. Gallager, \u201cLow-density parity-check codes,\u201d IRE Trans. Inf. Theory,\nvol. 8, pp. 21-28, Jan. 1962.\n[2] D. J. C. MacKay and R. M. Neal, \u201cNear-Shannon-limit performance of\nlow-density parity-check codes,\u201d Electron. Lett., vol. 32, pp. 1645-1646,\nAug. 1996.\n[3] D. J. C. MacKay, \u201cGood error correcting codes based on very sparse\nmatrices,\u201d IEEE Trans. Inf. Theory, vol. 45, pp. 399-432, Mar. 1999.\n[4] T. Richardson et al., \u201cDesign of capacity-approaching irregular codes,\u201d\nIEEE Trans. Inf. Theory, vol. 47, pp. 619-637, Feb. 2001.\n[5] M. P. C. Fossorier et al., \u201cReduced-complexity iterative decoding of low-\ndensity parity-check codes based on belief propagation,\u201d IEEE Trans.\nCommun., vol. 47, pp. 673-680, May 1999.\n[6] J. Chen and M. P. C. Fossorier, \u201cNear-optimum universal belief\npropagation-based decoding of low-density parity-check codes,\u201d IEEE\nTrans. Commun., vol. 50, pp. 406-414, Mar. 2002.\n[7] H-Y Hu et. al., \u201cEfficient implementation of the sum-product algorithm\nfor decoding LDPC codes,\u201d in Proc. IEEE GLOBCOM, vol. 2, pp. 1036-\n1036E, San Antonio, 25-29 Nov. 2001.\n[8] Y. Kou, et al., \u201cLow density parity check codes based on finite geometries:\na rediscovery and new results,\u201d IEEE Trans. Inf. Theory, vol. 47, no. 7,\nNov. 2001.\n[9] Z. Liu and D. A. Pados, \u201cA decoding algorithm for finite-geometry LDPC\ncodes,\u201d IEEE Trans. Commun., vol. 53, no. 3, Mar. 2005.\n[10] J. Feldman et al., \u201cUsing linear programming to decode binary linear\ncodes,\u201d IEEE Trans. Inf. Theory, vol. 51, no. 3, March 2005.\n[11] K. Yang et al., \u201cNonlinear programming approaches to decoding low-\ndensity parity-check codes,\u201d IEEE J. Sel. Areas Commun., vol. 24, no. 8,\nAug. 2006.\n[12] E. S. Levitin and B. T. Polyak, \u201cConstrained minimization methods,\u201d\nUSSR Computational Mathematics and Math. Physics, vol. 6, pp. 1-50,\n1966.\n[13] A. A. Goldstein, \u201cConvex programming in Hilbert space,\u201d Bulletin of\nthe American Mathematical Society, vol. 70, pp. 709-710, 1964.\nAuthorized licensed use limited to: University of Surrey. Downloaded on April 16,2010 at 14:19:42 UTC from IEEE Xplore.  Restrictions apply. \n"}